filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_TA_104_WETH_RealWorld_20240812195305.log,104,WETH,24467,1408,25875,76.0,0.150495,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract WETH is ERC20 {
    constructor() ERC20(""Wrapped Eth"", ""WETH"") {
        _mint(msg.sender, 10000000 * 10**decimals());
    }
}",73
RealWorld_TA_104_WETH_RealWorld_20240812193733.log,104,WETH,24188,1370,25558,69.0,0.14834,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract WETH is ERC20 {
    constructor() ERC20(""Wrapped Eth"", ""WETH"") {
        _mint(msg.sender, 10000000 * 10**decimals());
    }
}",73
RealWorld_TA_105_ECDSA_RealWorld_20240812204540.log,105,ECDSA,200008,1463,201471,96.0,1.0293,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert(""ECDSA: invalid signature"");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert(""ECDSA: invalid signature length"");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert(""ECDSA: invalid signature 's' value"");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert(""ECDSA: invalid signature 'v' value"");
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature` or error string. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     *
     * Documentation for signature generation:
     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
     *
     * _Available since v4.3._
     */
    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
        // Check the signature length
        // - case 65: r,s,v signature (standard)
        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
     *
     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s;
        uint8 v;
        assembly {
            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            v := add(shr(255, vs), 27)
        }
        return tryRecover(hash, v, r, s);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
     *
     * _Available since v4.2._
     */
    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
     * `r` and `s` signature fields separately.
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * produces hash corresponding to the one signed with the
     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
     * JSON-RPC method as part of EIP-191.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
    }

    /**
     * @dev Returns an Ethereum Signed Typed Data, created from a
     * `domainSeparator` and a `structHash`. This produces hash corresponding
     * to the one signed with the
     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
     * JSON-RPC method as part of EIP-712.
     *
     * See {recover}.
     */
    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
    }
}",2172
RealWorld_TA_105_Ownable_RealWorld_20240812204231.log,105,Ownable,58738,1601,60339,88.0,0.32571,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./Context.sol"";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}",481
RealWorld_TA_105_PaladinToken_RealWorld_20240812203414.log,105,PaladinToken,205139,2716,207855,118.0,1.080015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""../open-zeppelin/ERC20.sol"";
import ""../open-zeppelin/AccessControl.sol"";
import ""../open-zeppelin/utils/Math.sol"";
import ""../open-zeppelin/utils/ECDSA.sol"";

/** @title Paladin Token contract  */
/// @author Paladin
contract PaladinToken is ERC20, AccessControl {
    /** @notice The identifier for admin role */
    bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN"");
    /** @notice The identifier for transfer-allwoed role */
    bytes32 public constant TRANSFER_ROLE = keccak256(""TRANSFER"");

    bytes32 public constant DOMAIN_TYPEHASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    bytes32 private constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    // Storage :

    /** @notice boolean allowing transfer for all users */
    bool public transfersAllowed = false;

    mapping(address => address) public delegates;

    mapping(address => Checkpoint[]) public checkpoints;

    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    mapping(address => uint256) public nonces;

    // Events :

    /** @notice Emitted when transfer toggle is switched */
    event TransfersAllowed(bool transfersAllowed);

    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    // Modifiers :

    /** @dev Allows only ADMIN role to call the function */
    modifier onlyAdmin() {
        require(
            hasRole(ADMIN_ROLE, msg.sender),
            ""PaladinToken: caller not admin""
        );
        _;
    }

    /** @dev Allows only caller with the TRANSFER role to execute transfer */
    modifier onlyTransferer(address from) {
        require(
            transfersAllowed || hasRole(TRANSFER_ROLE, msg.sender),
            ""PaladinToken: caller cannot transfer""
        );
        _;
    }

    constructor(
        uint256 initialSupply,
        address admin,
        address recipient
    ) ERC20(""Paladin Token"", ""PAL"") {
        _setupRole(TRANSFER_ROLE, admin);
        _setupRole(TRANSFER_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, admin);
        _setRoleAdmin(TRANSFER_ROLE, ADMIN_ROLE);

        _mint(recipient, initialSupply);
    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override onlyTransferer(from) {}

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function delegate(address delegatee) external virtual {
        return _delegate(_msgSender(), delegatee);
    }

    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external virtual {
        require(block.timestamp <= expiry, ""PaladinToken: signature expired"");

        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        address signer = ecrecover(digest, v, r, s);
        
        require(signer != address(0), ""PaladinToken: invalid signature"");
        require(nonce == nonces[signer], ""PaladinToken: invalid nonce"");
        nonces[signer]++;
        return _delegate(signer, delegatee);
    }

    function numCheckpoints(address account)
        external
        view
        virtual
        returns (uint256)
    {
        return checkpoints[account].length;
    }

    function getCurrentVotes(address account) external view returns (uint256) {
        uint256 nbCheckpoints = checkpoints[account].length;
        return
            nbCheckpoints == 0
                ? 0
                : checkpoints[account][nbCheckpoints - 1].votes;
    }

    function getPastVotes(address account, uint256 blockNumber)
        external
        view
        returns (uint256)
    {
        require(
            blockNumber < block.number,
            ""PaladinToken: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function getPastDelegate(address account, uint256 blockNumber)
        external
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""PaladinToken: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _delegate(address delegator, address delegatee) internal {
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    function _moveDelegates(
        address from,
        address to,
        uint256 amount
    ) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(
        address delegatee,
        uint256 newVotes
    ) internal {
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    function safe32(uint n) internal pure returns (uint32) {
        require(n <= type(uint32).max, ""PaladinToken : block number exceed 32 bits"");
        return uint32(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        require(n <= type(uint224).max, ""PaladinToken : amount exceed 224 bits"");
        return uint224(n);
    }

    function getChainId() internal view returns (uint) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return chainId;
    }



    // Admin methods :

    /**
     * @notice Allow/Block transfer for all users
     * @dev Change transfersAllowed flag
     * @param _transfersAllowed bool : true to allow Transfer, false to block
     */
    function setTransfersAllowed(bool _transfersAllowed) external onlyAdmin {
        transfersAllowed = _transfersAllowed;
        emit TransfersAllowed(transfersAllowed);
    }
}",2218
RealWorld_TA_105_MerkleProof_RealWorld_20240812204718.log,105,MerkleProof,48931,1203,50134,70.0,0.268715,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev These functions deal with verification of Merkle Trees proofs.
 *
 * The proofs can be generated using the JavaScript library
 * https://github.com/miguelmota/merkletreejs[merkletreejs].
 * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
 *
 * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",367
RealWorld_TA_105_IMerkleDistributor_RealWorld_20240812205455.log,105,IMerkleDistributor,27416,1384,28800,72.0,0.16476,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;


interface IMerkleDistributor {

    function token() external view returns (address);

    function merkleRoot() external view returns (bytes32);

    function isClaimed(uint256 index) external view returns (bool);

    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external;

    event Claimed(uint256 index, address account, uint256 amount);
}",109
RealWorld_TA_105_ERC165_RealWorld_20240812205234.log,105,ERC165,35031,1178,36209,66.0,0.198715,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""../interfaces/IERC165.sol"";

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}",204
RealWorld_TA_105_Strings_RealWorld_20240812205113.log,105,Strings,61197,1477,62674,78.0,0.335525,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant _HEX_SYMBOLS = ""0123456789abcdef"";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0x00"";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = ""0"";
        buffer[1] = ""x"";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, ""Strings: hex length insufficient"");
        return string(buffer);
    }
}",503
RealWorld_TA_105_Context_RealWorld_20240812204831.log,105,Context,32004,1261,33265,69.0,0.18524,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}",164
RealWorld_TA_105_Math_RealWorld_20240812204943.log,105,Math,44806,1868,46674,87.0,0.26139,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds up instead
     * of rounding down.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a / b + (a % b == 0 ? 0 : 1);
    }
}",309
RealWorld_TA_105_Utils_RealWorld_20240812210625.log,105,Utils,44473,1915,46388,83.0,0.260665,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.10;

import ""ds-test/test.sol"";
import ""forge-std/Vm.sol"";

//common utilities for forge tests
contract Utils is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);
    bytes32 internal nextUser = keccak256(abi.encodePacked(""user address""));

    function getNextUserAddress() external returns (address payable) {
        //bytes32 to address conversion
        address payable user = payable(address(uint160(uint256(nextUser))));
        nextUser = keccak256(abi.encodePacked(nextUser));
        return user;
    }

    //create users with 100 ether balance
    function createUsers(uint256 userNum)
        external
        returns (address payable[] memory)
    {
        address payable[] memory users = new address payable[](userNum);
        for (uint256 i = 0; i < userNum; i++) {
            address payable user = this.getNextUserAddress();
            vm.deal(user, 100 ether);
            users[i] = user;
        }
        return users;
    }

    //move block.number forward by a given number of blocks
    function mineBlocks(uint256 numBlocks) external {
        uint256 targetBlock = block.number + numBlocks;
        vm.roll(targetBlock);
    }

    function advanceTime(uint256 timeToAdvance) external {
        uint256 targetTimestamp = block.timestamp + timeToAdvance;
        vm.warp(targetTimestamp);
    }
}",313
RealWorld_TA_105_Address_RealWorld_20240812204402.log,105,Address,167187,2050,169237,96.0,0.876935,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1783
RealWorld_TA_105_IAccessControl_RealWorld_20240812205610.log,105,IAccessControl,76814,1602,78416,80.0,0.41611,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) external;
}",692
RealWorld_TA_105_StakingHPAL.test_RealWorld_20240812210007.log,105,StakingHPAL.test,221746,4647,226393,150.0,1.20167,"// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.10;

import ""ds-test/test.sol"";
import ""forge-std/Vm.sol"";
import ""forge-std/console.sol"";
import {Utils} from ""./utils/Utils.sol"";

import {PaladinToken} from ""../../contracts/test/PaladinToken.sol"";
import {HolyPaladinToken} from ""../../contracts/HolyPaladinToken.sol"";

contract StakingHPALTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utils internal utils;

    address payable[] internal users;

    PaladinToken internal pal;
    HolyPaladinToken internal hpal;

    function setUp() public {
        utils = new Utils();
        users = utils.createUsers(2);

        uint256 palSupply = 50000000 * 1e18;
        pal = new PaladinToken(palSupply, address(this), address(this));
        pal.setTransfersAllowed(true);

        //hPAL constructor parameters
        uint256 startDropPerSecond = 0.0005 * 1e18;
        uint256 endDropPerSecond = 0.00001 * 1e18;
        uint256 dropDecreaseDuration = 63115200;
        uint256 baseLockBonusRatio = 1 * 1e18;
        uint256 minLockBonusRatio = 2 * 1e18;
        uint256 maxLockBonusRatio = 6 * 1e18;

        hpal = new HolyPaladinToken(
            address(pal),
            address(this),
            address(this),
            startDropPerSecond,
            endDropPerSecond,
            dropDecreaseDuration,
            baseLockBonusRatio,
            minLockBonusRatio,
            maxLockBonusRatio
        );
    }

    // using uint72 since we gave only 1 000 PAL to the user
    function testStaking(uint72 amount) public {
        address payable staker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        pal.transfer(staker, transferAmount);

        uint256 previousBalance = pal.balanceOf(staker);
        uint256 previousStakedBalance = hpal.balanceOf(staker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        vm.prank(staker);

        pal.approve(address(hpal), amount);

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(staker);
            hpal.stake(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else if(amount > previousBalance) {
            vm.expectRevert(
                bytes(""ERC20: transfer amount exceeds balance"")
            );
            vm.prank(staker);
            hpal.stake(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else{
            vm.prank(staker);
            uint256 returnAmount = hpal.stake(amount);

            assertEq(returnAmount, amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance - amount);
            assertEq(newStakedBalance, previousStakedBalance + amount);
            assertEq(newContractBalance, previousContractBalance + amount);
            assertEq(newTotalSupply, previousTotalSupply + amount);

        }

    }

    // using uint72 since we gave only 1 000 PAL to the user
    function testUnstaking(uint72 amount) public {
        address payable staker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(staker, transferAmount);

        vm.prank(staker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(staker);
        hpal.stake(stakingAmount);

        vm.prank(staker);
        hpal.cooldown();

        utils.advanceTime(864100);

        uint256 previousBalance = pal.balanceOf(staker);
        uint256 previousStakedBalance = hpal.balanceOf(staker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(staker);
            hpal.unstake(amount, staker);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else if(amount > previousStakedBalance) {
            vm.prank(staker);
            uint256 returnAmount = hpal.unstake(amount, staker);

            assertLt(returnAmount, amount);
            assertEq(returnAmount, previousStakedBalance);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance + returnAmount);
            assertEq(newStakedBalance, 0);
            assertEq(newContractBalance, previousContractBalance - returnAmount);
            assertEq(newTotalSupply, previousTotalSupply - returnAmount);
        }
        else{
            vm.prank(staker);
            uint256 returnAmount = hpal.unstake(amount, staker);

            assertEq(returnAmount, amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newStakedBalance = hpal.balanceOf(staker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance + amount);
            assertEq(newStakedBalance, previousStakedBalance - amount);
            assertEq(newContractBalance, previousContractBalance - amount);
            assertEq(newTotalSupply, previousTotalSupply - amount);

        }

    }

    function testClaim(uint72 amount) public {
        address payable staker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(staker, transferAmount);

        pal.approve(address(hpal), 1000000 * 1e18);

        vm.prank(staker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(staker);
        hpal.stake(stakingAmount);

        vm.prank(staker);
        hpal.cooldown();

        utils.advanceTime(864100);

        vm.prank(staker);
        hpal.unstake(stakingAmount, staker);

        uint256 previousBalance = pal.balanceOf(staker);
        uint256 previousVaultBalance = pal.balanceOf(address(this));

        uint256 claimableAmount = hpal.claimableRewards(staker);

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: incorrect amount"")
            );
            vm.prank(staker);
            hpal.claim(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newVaultBalance = pal.balanceOf(address(this));

            assertEq(newBalance, previousBalance);
            assertEq(newVaultBalance, previousVaultBalance);
        }
        else if(amount > claimableAmount) {
            vm.prank(staker);
            hpal.claim(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newVaultBalance = pal.balanceOf(address(this));

            assertEq(newBalance, previousBalance + claimableAmount);
            assertEq(newVaultBalance, previousVaultBalance - claimableAmount);

            uint256 newClaimableAmount = hpal.claimableRewards(staker);

            assertEq(newClaimableAmount, 0);
        }
        else{
            vm.prank(staker);
            hpal.claim(amount);

            uint256 newBalance = pal.balanceOf(staker);
            uint256 newVaultBalance = pal.balanceOf(address(this));

            assertEq(newBalance, previousBalance + amount);
            assertEq(newVaultBalance, previousVaultBalance - amount);

            uint256 newClaimableAmount = hpal.claimableRewards(staker);

            assertEq(newClaimableAmount, claimableAmount - amount);

        }

    }

    function testTransfer(uint72 amount) public {
        address payable staker = users[0];
        address payable receiver = users[1];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(staker, transferAmount);

        vm.prank(staker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(staker);
        hpal.stake(stakingAmount);

        uint256 previousBalanceStaker = hpal.balanceOf(staker);
        uint256 previousBalanceReceiver = hpal.balanceOf(receiver);
        uint256 previousTotalSupply = hpal.totalSupply();

        if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Available balance too low"")
            );
            vm.prank(staker);
            hpal.transfer(receiver, amount);

            uint256 newBalanceStaker = hpal.balanceOf(staker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceStaker, previousBalanceStaker);
            assertEq(newBalanceReceiver, previousBalanceReceiver);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else{
            vm.prank(staker);
            bool success = hpal.transfer(receiver, amount);

            assertTrue(success);

            uint256 newBalanceStaker = hpal.balanceOf(staker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceStaker, previousBalanceStaker - amount);
            assertEq(newBalanceReceiver, previousBalanceReceiver + amount);
            assertEq(newTotalSupply, previousTotalSupply);

        }
    }

}",2411
RealWorld_TA_105_IERC20Metadata_RealWorld_20240812205732.log,105,IERC20Metadata,30029,1462,31491,76.0,0.179385,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./IERC20.sol"";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}",140
RealWorld_TA_105_LockingHPAL.test_RealWorld_20240812210240.log,105,LockingHPAL.test,623789,4743,628532,222.0,3.213805,"// SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.10;

import ""ds-test/test.sol"";
import ""forge-std/Vm.sol"";
import ""forge-std/console.sol"";
import {Utils} from ""./utils/Utils.sol"";

import {PaladinToken} from ""../../contracts/test/PaladinToken.sol"";
import {HolyPaladinToken} from ""../../contracts/HolyPaladinToken.sol"";

contract LockingHPALTest is DSTest {
    Vm internal immutable vm = Vm(HEVM_ADDRESS);

    Utils internal utils;

    address payable[] internal users;

    PaladinToken internal pal;
    HolyPaladinToken internal hpal;

    function setUp() public {
        utils = new Utils();
        users = utils.createUsers(2);

        uint256 palSupply = 50000000 * 1e18;
        pal = new PaladinToken(palSupply, address(this), address(this));
        pal.setTransfersAllowed(true);

        //hPAL constructor parameters
        uint256 startDropPerSecond = 0.0005 * 1e18;
        uint256 endDropPerSecond = 0.00001 * 1e18;
        uint256 dropDecreaseDuration = 63115200;
        uint256 baseLockBonusRatio = 1 * 1e18;
        uint256 minLockBonusRatio = 2 * 1e18;
        uint256 maxLockBonusRatio = 6 * 1e18;

        hpal = new HolyPaladinToken(
            address(pal),
            address(this),
            address(this),
            startDropPerSecond,
            endDropPerSecond,
            dropDecreaseDuration,
            baseLockBonusRatio,
            minLockBonusRatio,
            maxLockBonusRatio
        );
    }

    // using uint72 since we gave only 1 000 PAL to the user
    function testLockingAmount(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Amount over balance"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, lockDuration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount);

        }

    }

    function testReLockingAmount(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        uint256 lockAmount = 300 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Amount over balance"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount < lockAmount) {
            vm.expectRevert(
                bytes(""hPAL: smaller amount"")
            );
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(amount, lockDuration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, lockDuration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount - lockAmount);

        }

    }

    function testLockingDuration(uint256 duration) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockAmount = 300 * 1e18;

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(duration < hpal.MIN_LOCK_DURATION()){
            vm.expectRevert(
                bytes(""hPAL: Lock duration under min"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration > hpal.MAX_LOCK_DURATION()) {
            vm.expectRevert(
                bytes(""hPAL: Lock duration over max"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, lockAmount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, duration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + lockAmount);

        }
    }

    function testReLockingDuration(uint256 duration) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockAmount = 300 * 1e18;

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(duration < hpal.MIN_LOCK_DURATION()){
            vm.expectRevert(
                bytes(""hPAL: Lock duration under min"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration > hpal.MAX_LOCK_DURATION()) {
            vm.expectRevert(
                bytes(""hPAL: Lock duration over max"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration < lockDuration) {
            vm.expectRevert(
                bytes(""hPAL: smaller duration"")
            );
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.lock(lockAmount, duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);

        }

    }

    function testIncreaseLockAmount(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        uint256 lockAmount = 300 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();
        
        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > stakingAmount) {
            vm.expectRevert(
                bytes(""hPAL: Amount over balance"")
            );
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount < lockAmount) {
            vm.expectRevert(
                bytes(""hPAL: smaller amount"")
            );
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.increaseLock(amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, lockDuration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount - previousLock.amount);

        }

    }

    function testIncreaseLockDuration(uint256 duration) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        uint256 lockAmount = 300 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        vm.prank(locker);
        hpal.lock(lockAmount, lockDuration);

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();
        
        if(duration < hpal.MIN_LOCK_DURATION()){
            vm.expectRevert(
                bytes(""hPAL: Lock duration under min"")
            );
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration > hpal.MAX_LOCK_DURATION()) {
            vm.expectRevert(
                bytes(""hPAL: Lock duration over max"")
            );
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(duration < lockDuration) {
            vm.expectRevert(
                bytes(""hPAL: smaller duration"")
            );
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            hpal.increaseLockDuration(duration);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, duration);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total);

        }

    }

    function testLockAndUnlock(uint72 amount) public {
        address payable locker = users[0];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        if(amount > stakingAmount || amount == 0) return;

        vm.prank(locker);
        hpal.lock(amount, lockDuration);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        utils.advanceTime(lockDuration + 10);
        
        vm.prank(locker);
        hpal.unlock();

        HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

        assertEq(userLock.amount, 0);
        assertEq(userLock.startTimestamp, block.timestamp);
        assertEq(userLock.duration, 0);
        assertEq(userLock.fromBlock, block.number);
        assertEq(newTotalLocked.total, previousTotalLocked.total - amount);

        assertEq(hpal.userCurrentBonusRatio(locker), 0);

    }

    function testLockAndKick(uint72 amount) public {
        address payable locker = users[0];
        address payable kicker = users[1];

        uint256 transferAmount = 1000 * 1e18;

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, transferAmount);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockDuration = 31557600;

        if(amount > stakingAmount || amount == 0) return;

        vm.prank(locker);
        hpal.lock(amount, lockDuration);

        uint256 previousLockerBalance = hpal.balanceOf(locker);
        uint256 previousLockerKicker = hpal.balanceOf(kicker);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        utils.advanceTime(lockDuration + hpal.UNLOCK_DELAY() + 10);
        
        vm.prank(kicker);
        hpal.kick(locker);

        uint256 penaltyAmount = (amount * (hpal.UNLOCK_DELAY() / hpal.WEEK()) * hpal.kickRatioPerWeek()) / hpal.MAX_BPS();

        HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

        assertEq(userLock.amount, 0);
        assertEq(userLock.startTimestamp, block.timestamp);
        assertEq(userLock.duration, 0);
        assertEq(userLock.fromBlock, block.number);
        assertEq(newTotalLocked.total, previousTotalLocked.total - amount);

        assertEq(hpal.userCurrentBonusRatio(locker), 0);

        uint256 newLockerBalance = hpal.balanceOf(locker);
        uint256 newLockerKicker = hpal.balanceOf(kicker);

        assertEq(newLockerBalance, previousLockerBalance - penaltyAmount);
        assertEq(newLockerKicker, previousLockerKicker + penaltyAmount);

    }

    function testStakeAndLock(uint72 amount) public {
        address payable locker = users[0];

        pal.transfer(locker, 1000 * 1e18);

        uint256 previousBalance = pal.balanceOf(locker);
        uint256 previousStakedBalance = hpal.balanceOf(locker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        vm.prank(locker);
        pal.approve(address(hpal), amount);

        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();

        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.stakeAndLock(amount, 31557600);

            uint256 newBalance = pal.balanceOf(locker);
            uint256 newStakedBalance = hpal.balanceOf(locker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > previousBalance) {
            vm.expectRevert(
                bytes(""ERC20: transfer amount exceeds balance"")
            );
            vm.prank(locker);
            hpal.stakeAndLock(amount, 31557600);

            uint256 newBalance = pal.balanceOf(locker);
            uint256 newStakedBalance = hpal.balanceOf(locker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance);
            assertEq(newStakedBalance, previousStakedBalance);
            assertEq(newContractBalance, previousContractBalance);
            assertEq(newTotalSupply, previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, 0);
            assertEq(userLock.startTimestamp, 0);
            assertEq(userLock.duration, 0);
            assertEq(userLock.fromBlock, 0);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            uint256 returnAmount = hpal.stakeAndLock(amount, 31557600);

            assertEq(returnAmount, amount);

            uint256 newBalance = pal.balanceOf(locker);
            uint256 newStakedBalance = hpal.balanceOf(locker);
            uint256 newContractBalance = pal.balanceOf(address(hpal));
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalance, previousBalance - amount);
            assertEq(newStakedBalance, previousStakedBalance + amount);
            assertEq(newContractBalance, previousContractBalance + amount);
            assertEq(newTotalSupply, previousTotalSupply + amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, amount);
            assertEq(userLock.startTimestamp, block.timestamp);
            assertEq(userLock.duration, 31557600);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount);
        }
    }

    function testStakeAndIncreaseLock(uint72 amount) public {
        address payable locker = users[0];

        pal.transfer(locker, 1000 * 1e18);

        vm.prank(locker);
        pal.approve(address(hpal), 1000 * 1e18);
            
        vm.prank(locker);
        hpal.stake(700 * 1e18);

        vm.prank(locker);
        hpal.lock(300 * 1e18, 31557600);

        uint256 previousBalance = pal.balanceOf(locker);
        uint256 previousStakedBalance = hpal.balanceOf(locker);
        uint256 previousContractBalance = pal.balanceOf(address(hpal));
        uint256 previousTotalSupply = hpal.totalSupply();

        HolyPaladinToken.UserLock memory previousLock = hpal.getUserLock(locker);
        HolyPaladinToken.TotalLock memory previousTotalLocked = hpal.getCurrentTotalLock();
        
        if(amount == 0){
            vm.expectRevert(
                bytes(""hPAL: Null amount"")
            );
            vm.prank(locker);
            hpal.stakeAndIncreaseLock(amount, 31557600);

            assertEq(pal.balanceOf(locker), previousBalance);
            assertEq(hpal.balanceOf(locker), previousStakedBalance);
            assertEq(pal.balanceOf(address(hpal)), previousContractBalance);
            assertEq(hpal.totalSupply(), previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else if(amount > previousBalance) {
            vm.expectRevert(
                bytes(""ERC20: transfer amount exceeds balance"")
            );
            vm.prank(locker);
            hpal.stakeAndIncreaseLock(amount, 31557600);

            assertEq(pal.balanceOf(locker), previousBalance);
            assertEq(hpal.balanceOf(locker), previousStakedBalance);
            assertEq(pal.balanceOf(address(hpal)), previousContractBalance);
            assertEq(hpal.totalSupply(), previousTotalSupply);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, previousLock.duration);
            assertEq(userLock.fromBlock, previousLock.fromBlock);
            assertEq(newTotalLocked.total, previousTotalLocked.total);
        }
        else{
            vm.prank(locker);
            uint256 returnAmount = hpal.stakeAndIncreaseLock(amount, 31557600);

            assertEq(returnAmount, amount);

            assertEq(pal.balanceOf(locker), previousBalance - amount);
            assertEq(hpal.balanceOf(locker), previousStakedBalance + amount);
            assertEq(pal.balanceOf(address(hpal)), previousContractBalance + amount);
            assertEq(hpal.totalSupply(), previousTotalSupply + amount);

            HolyPaladinToken.UserLock memory userLock = hpal.getUserLock(locker);
            HolyPaladinToken.TotalLock memory newTotalLocked = hpal.getCurrentTotalLock();

            assertEq(userLock.amount, previousLock.amount + amount);
            assertEq(userLock.startTimestamp, previousLock.startTimestamp);
            assertEq(userLock.duration, 31557600);
            assertEq(userLock.fromBlock, block.number);
            assertEq(newTotalLocked.total, previousTotalLocked.total + amount);

        }

    }

    function testTransferLock(uint72 amount) public {
        address payable locker = users[0];
        address payable receiver = users[1];

        uint256 stakingAmount = 700 * 1e18;

        pal.transfer(locker, 1000 * 1e18);

        vm.prank(locker);
        pal.approve(address(hpal), stakingAmount);
            
        vm.prank(locker);
        hpal.stake(stakingAmount);

        uint256 lockAmount = 300 * 1e18;

        vm.prank(locker);
        hpal.lock(lockAmount, 31557600);

        uint256 previousBalanceLocker = hpal.balanceOf(locker);
        uint256 previousAvailableBalanceLocker = hpal.availableBalanceOf(locker);
        uint256 previousBalanceReceiver = hpal.balanceOf(receiver);
        uint256 previousTotalSupply = hpal.totalSupply();

        if(amount > previousAvailableBalanceLocker) {
            vm.expectRevert(
                bytes(""hPAL: Available balance too low"")
            );
            vm.prank(locker);
            hpal.transfer(receiver, amount);

            uint256 newBalanceLocker = hpal.balanceOf(locker);
            uint256 newAvailableBalanceLocker = hpal.availableBalanceOf(locker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceLocker, previousBalanceLocker);
            assertEq(newAvailableBalanceLocker, previousAvailableBalanceLocker);
            assertEq(newBalanceReceiver, previousBalanceReceiver);
            assertEq(newTotalSupply, previousTotalSupply);
        }
        else{
            vm.prank(locker);
            bool success = hpal.transfer(receiver, amount);

            assertTrue(success);

            uint256 newBalanceLocker = hpal.balanceOf(locker);
            uint256 newAvailableBalanceLocker = hpal.availableBalanceOf(locker);
            uint256 newBalanceReceiver = hpal.balanceOf(receiver);
            uint256 newTotalSupply = hpal.totalSupply();

            assertEq(newBalanceLocker, previousBalanceLocker - amount);
            assertEq(newAvailableBalanceLocker, previousAvailableBalanceLocker - amount);
            assertEq(newBalanceReceiver, previousBalanceReceiver + amount);
            assertEq(newTotalSupply, previousTotalSupply);

        }
    }

}",7126
RealWorld_TA_105_PaladinRewardReserve_RealWorld_20240812203239.log,105,PaladinRewardReserve,58956,2601,61557,92.0,0.3468,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";

/** @title Paladin Reward Reserve contract  */
/// @author Paladin
contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    /** @notice Addresses allowed to transfer tokens from this contract */
    mapping(address => bool) public approvedSpenders;

    /** @notice Emitted when a new spender is approved*/
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when the allowance of a spander is updated */
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when a spender allowance is removed */
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",494
RealWorld_TA_105_ReentrancyGuard_RealWorld_20240812204116.log,105,ReentrancyGuard,71584,1274,72858,72.0,0.3834,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}",637
RealWorld_TA_105_AccessControl_RealWorld_20240812203755.log,105,AccessControl,156536,1333,157869,105.0,0.80934,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interfaces/IAccessControl.sol"";
import ""./utils/Context.sol"";
import ""./utils/Strings.sol"";
import ""./utils/ERC165.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with a standardized message including the required role.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     *
     * _Available since v4.1._
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role, _msgSender());
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view override returns (bool) {
        return _roles[role].members[account];
    }

    /**
     * @dev Revert with a standard message if `account` is missing `role`.
     *
     * The format of the revert reason is given by the following regular expression:
     *
     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
     */
    function _checkRole(bytes32 role, address account) internal view {
        if (!hasRole(role, account)) {
            revert(
                string(
                    abi.encodePacked(
                        ""AccessControl: account "",
                        Strings.toHexString(uint160(account), 20),
                        "" is missing role "",
                        Strings.toHexString(uint256(role), 32)
                    )
                )
            );
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    function _grantRole(bytes32 role, address account) private {
        if (!hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}",1647
RealWorld_TA_105_SafeERC20_RealWorld_20240812203943.log,105,SafeERC20,88413,2383,90796,91.0,0.489725,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""../interfaces/IERC20.sol"";
import ""../utils/Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, ""SafeERC20: decreased allowance below zero"");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",863
RealWorld_TA_105_IERC20_RealWorld_20240812205343.log,105,IERC20,69916,1289,71205,70.0,0.37536,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",617
RealWorld_TA_105_ERC20_RealWorld_20240812203615.log,105,ERC20,247171,1904,249075,98.0,1.273935,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interfaces/IERC20.sol"";
import ""./interfaces/IERC20Metadata.sol"";
import ""./utils/Context.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, ""ERC20: transfer amount exceeds allowance"");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, ""ERC20: decreased allowance below zero"");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `sender` to `recipient`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""ERC20: transfer amount exceeds balance"");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, ""ERC20: burn amount exceeds balance"");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}",2760
RealWorld_TA_105_HolyPaladinToken_RealWorld_20240812202948.log,105,HolyPaladinToken,1058898,630,1059528,168.0,5.30709,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",12522
RealWorld_TA_105_IERC165_RealWorld_20240812205851.log,105,IERC165,34567,1304,35871,74.0,0.198915,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",193
RealWorld_TA_106_ILendTicket_RealWorld_20240812215125.log,106,ILendTicket,28199,1554,29753,77.0,0.172075,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface ILendTicket {
    /**
     * @notice Transfers a lend ticket
     * @dev can only be called by nft loan facilitator
     * @param from The current holder of the lend ticket
     * @param to Address to send the lend ticket to
     * @param loanId The lend ticket token id, which is also the loan id in the facilitator contract
     */
    function loanFacilitatorTransfer(address from, address to, uint256 loanId) external;
}",121
RealWorld_TA_106_LendTicketDescriptor_RealWorld_20240812213127.log,106,LendTicketDescriptor,36324,1338,37662,78.0,0.20838,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './NFTLoansTicketDescriptor.sol';

contract LendTicketDescriptor is NFTLoansTicketDescriptor {
    /// @dev Initializes the contract by setting a `nftType` and a `svgHelper`
    constructor(ITicketTypeSpecificSVGHelper _svgHelper) NFTLoansTicketDescriptor(""Lend"", _svgHelper) {}

    /**
     * @notice returns string with lend ticket description details
     * @dev Called by generateDescriptor when populating the description part of the token metadata. 
     */
    function generateDescription(string memory loanId) internal pure override returns (string memory) {
        return string.concat(
            'This Lend Ticket NFT was created when NFT Loan #', 
            loanId,
            ' was underwritten. On loan repayment, funds will be transferred to the lend ticket holder. ',
            'If the loan is not paid back on time, the lend ticket holder is entitled to ',
            'seize the NFT collateral.'
        );
    }

}",222
RealWorld_TA_106_NFTLoansTicketDescriptor_RealWorld_20240812212956.log,106,NFTLoansTicketDescriptor,80684,1863,82547,88.0,0.44068,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import 'base64-sol/base64.sol';
import '../NFTLoanFacilitator.sol';
import './libraries/NFTLoanTicketSVG.sol';
import './libraries/PopulateSVGParams.sol';

contract NFTLoansTicketDescriptor {
    // Lend or Borrow 
    string public nftType;
    ITicketTypeSpecificSVGHelper immutable public svgHelper;

    /// @dev Initializes the contract by setting a `nftType` and `svgHelper`
    constructor(string memory _nftType, ITicketTypeSpecificSVGHelper _svgHelper) {
        nftType = _nftType;
        svgHelper = _svgHelper;
    }

    /**
     * @dev Returns a string which is a data uri of base64 encoded JSON,
     * the JSON contains the token metadata: name, description, image
     * which reflect information about `id` loan in `nftLoanFacilitator`
     */ 
    function uri(NFTLoanFacilitator nftLoanFacilitator, uint256 id)
        external
        view
        returns (string memory)
    {
        NFTLoanTicketSVG.SVGParams memory svgParams;
        svgParams.nftType = nftType;
        svgParams = PopulateSVGParams.populate(svgParams, nftLoanFacilitator, id);
        
        return generateDescriptor(svgParams);
    }

    /**
     * @dev Returns a string which is a data uri of base64 encoded JSON,
     * the JSON contains the token metadata: name, description, image.
     * The metadata values come from `svgParams`
     */ 
    function generateDescriptor(NFTLoanTicketSVG.SVGParams memory svgParams)
        private
        view
        returns (string memory)
    {
        return string.concat(
            'data:application/json;base64,',
            Base64.encode(
                bytes(
                    string.concat(
                        '{""name"":""',
                        svgParams.nftType,
                        ' ticket',
                        ' #',
                        svgParams.id,
                        '"", ""description"":""',
                        generateDescription(svgParams.id),
                        generateDescriptionDetails(
                            svgParams.loanAssetContract,
                            svgParams.loanAssetSymbol,
                            svgParams.collateralContract, 
                            svgParams.collateralAssetSymbol,
                            svgParams.collateralId),
                        '"", ""image"": ""',
                        'data:image/svg+xml;base64,',
                        Base64.encode(bytes(NFTLoanTicketSVG.generateSVG(svgParams, svgHelper))),
                        '""}'
                    )
                )
            )
        );
    }

    /// @dev Returns string, ticket type (borrow or lend) specific description      
    function generateDescription(string memory loanId) internal pure virtual returns (string memory) {}

    /// @dev Returns string, important info about the loan that this ticket is related to 
    function generateDescriptionDetails(
        string memory loanAsset,
        string memory loanAssetSymbol,
        string memory collateralAsset,
        string memory collateralAssetSymbol,
        string memory collateralAssetId
    ) 
        private 
        pure 
        returns (string memory) 
    {
        return string.concat(
            '\\n\\nCollateral Address: ',
            collateralAsset,
            ' (',
            collateralAssetSymbol,
            ')\\n\\n',
            'Collateral ID: ',
            collateralAssetId,
            '\\n\\n',
            'Loan Asset Address: ',
            loanAsset,
            ' (',
            loanAssetSymbol,
            ')\\n\\n',
            'WARNING: Do your own research to verify the legitimacy of the assets related to this ticket'
        );
    }
}",747
RealWorld_TA_106_LendTicket_RealWorld_20240812210918.log,106,LendTicket,51477,2433,53910,95.0,0.306045,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {ILendTicket} from './interfaces/ILendTicket.sol';
import {NFTLoanTicket} from './NFTLoanTicket.sol';
import {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';
import {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';

contract LendTicket is NFTLoanTicket, ILendTicket {

    /// See NFTLoanTicket
    constructor(
        NFTLoanFacilitator _nftLoanFacilitator,
        NFTLoansTicketDescriptor _descriptor
    ) 
        NFTLoanTicket(""Lend Ticket"", ""LNDT"", _nftLoanFacilitator, _descriptor) 
    {}

    /// See {ILendTicket-loanFacilitatorTransfer}
    function loanFacilitatorTransfer(address from, address to, uint256 loanId) external override loanFacilitatorOnly {
        _transfer(from, to, loanId);
    }

    /// @dev exact copy of 
    /// https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol#L69-L96
    /// with L78 - L81 removed to enable loanFacilitatorTransfer
    function _transfer(
        address from,
        address to,
        uint256 id
    ) internal {
        require(from == ownerOf[id], ""WRONG_FROM"");

        require(to != address(0), ""INVALID_RECIPIENT"");

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        unchecked {
            balanceOf[from]--;

            balanceOf[to]++;
        }

        ownerOf[id] = to;

        delete getApproved[id];

        emit Transfer(from, to, id);
    }
}",402
RealWorld_TA_106_BorrowTicketSVGHelper_RealWorld_20240812213559.log,106,BorrowTicketSVGHelper,49128,1254,50382,75.0,0.27072,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './TicketTypeSpecificSVGHelper.sol';

contract BorrowTicketSVGHelper is TicketTypeSpecificSVGHelper {
    /**
     * @dev Returns SVG styles where the primary background color is derived
     * from the collateral asset address and the secondary background color 
     * is derived from the loan asset address
     */
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
    ) 
        external 
        pure
        override 
        returns (string memory)
    {
        return colorStyles(collateralAsset, loanAsset);
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function ticketIdXCoordinate() external pure override returns (string memory) {
        return '134';
    }
    
    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundTitleRectsXTranslate() external pure override returns (string memory) {
        return '31';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesPositionClass() external pure override returns (string memory) {
        return 'right';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesXTranslate() external pure override returns (string memory) {
        return '121';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundValueRectsXTranslate() external pure override returns (string memory) {
        return '129';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function alignmentClass() external pure override returns (string memory) {
        return 'left';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function valuesXTranslate() external pure override returns (string memory) {
        return '136';
    }
}",369
RealWorld_TA_106_MaliciousERC20_RealWorld_20240812212206.log,106,MaliciousERC20,42033,4425,46458,112.0,0.298665,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""../../interfaces/INFTLoanFacilitator.sol"";

contract MaliciousERC20 is ERC20, IERC721Receiver {
    INFTLoanFacilitator nftLoanFacilitator;

    constructor(address facilitatorAddress) ERC20("""", ""MAL"") {
        nftLoanFacilitator = INFTLoanFacilitator(facilitatorAddress);
        _mint(msg.sender, 1000000 * (10**uint256(decimals())));
    }

    function mint(uint256 amount, address to) external {
        _mint(to, amount * (10**decimals()));
    }

    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        nftLoanFacilitator.closeLoan(1, address(this));
        return true;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}",274
RealWorld_TA_106_BorrowTicketDescriptor_RealWorld_20240812212826.log,106,BorrowTicketDescriptor,36336,1398,37734,87.0,0.20964,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './NFTLoansTicketDescriptor.sol';

contract BorrowTicketDescriptor is NFTLoansTicketDescriptor {
    /// @dev see NFTLoansTicketDescriptor
    constructor(ITicketTypeSpecificSVGHelper _svgHelper) NFTLoansTicketDescriptor(""Borrow"", _svgHelper) {}

    /**
     * @notice returns string with borrow ticket description details
     * @dev Called by generateDescriptor when populating the description part of the token metadata. 
     */
    function generateDescription(string memory) internal pure override returns (string memory) {
        return 'This Borrow Ticket NFT was created by the deposit of an NFT into the NFT Loan Faciliator '
                'contract to serve as collateral for a loan. If the loan is underwritten, funds will be transferred '
                'to the borrow ticket holder. If the loan is repaid, the NFT collateral is transferred to the borrow '
                'ticket holder. If the loan is marked closed, the collateral has been withdrawn.';
                
    }

}",225
RealWorld_TA_106_DAI_RealWorld_20240812211844.log,106,DAI,24852,2771,27623,100.0,0.17968,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract DAI is ERC20 {
    constructor() ERC20("""", ""DAI"") {}

    function mint(uint256 amount, address to) external {
        _mint(to, amount);
    }
}",72
RealWorld_TA_106_HexStrings_RealWorld_20240812213717.log,106,HexStrings,66061,1310,67371,75.0,0.356505,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

library HexStrings {
    bytes16 internal constant ALPHABET = '0123456789abcdef';

    // @notice returns value as a hex string of desiredPartialStringLength length,
    // adding '0x' to the start and '...' to the end. 
    // Designed to be used for shortening addresses for display purposes.
    // @param value The value to return as a hex string
    // @param desiredPartialStringLength How many hex characters of `value` to return in the string
    // @param valueLengthAsHexString The length of `value` as a hex string
    function partialHexString(
        uint160 value,
        uint8 desiredPartialStringLength,
        uint8 valueLengthAsHexString
    ) 
        internal 
        pure 
        returns (string memory) 
    {
        bytes memory buffer = new bytes(desiredPartialStringLength + 5);
        buffer[0] = '0';
        buffer[1] = 'x';
        uint8 offset = desiredPartialStringLength + 1;
        // remove values not in partial length, four bytes for every hex character
        value >>= 4 * (valueLengthAsHexString - desiredPartialStringLength);
        for (uint8 i = offset; i > 1; --i) {
            buffer[i] = ALPHABET[value & 0xf];
            value >>= 4;
        }
        require(value == 0, 'HexStrings: hex length insufficient');
        // uint8 offset 
        buffer[offset + 1] = '.';
        buffer[offset + 2] = '.';
        buffer[offset + 3] = '.';
        return string(buffer);
    }

    /// @notice Converts a `uint160` to its ASCII `string` hexadecimal representation with fixed length.
    /// @dev Credit to Open Zeppelin under MIT license 
    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55
    function toHexString(uint160 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = '0';
        buffer[1] = 'x';
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = ALPHABET[value & 0xf];
            value >>= 4;
        }
        require(value == 0, 'HexStrings: hex length insufficient');
        return string(buffer);
    }
}",561
RealWorld_TA_106_IERC721Mintable_RealWorld_20240812214512.log,106,IERC721Mintable,26690,1806,28496,84.0,0.16957,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface IERC721Mintable {
    /**
     * @notice mints an ERC721 token of tokenId to the to address
     * @dev only callable by nft loan facilitator
     * @param to The address to send the token to
     * @param tokenId The id of the token to mint
     */
    function mint(address to, uint256 tokenId) external;
}",97
RealWorld_TA_106_NFTLoanTicketSVG_RealWorld_20240812213834.log,106,NFTLoanTicketSVG,183581,1538,185119,94.0,0.948665,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;
import 'base64-sol/base64.sol';
import '../../interfaces/ITicketTypeSpecificSVGHelper.sol';


library NFTLoanTicketSVG {

    struct SVGParams{
        // ""Borrow"" or ""Lend""
        string nftType;
        // The Token Id, which is also the Id of the associated loan in NFTLoanFacilitator
        string id;
        // Human readable status, see {PopulateSVGParams-loanStatus}
        string status;
        // The approximate APR loan interest rate
        string interestRate;
        // The contract address of the ERC20 loan asset
        string loanAssetContract;
        // The symbol of the ERC20 loan asset
        string loanAssetSymbol;
        // The contract address of the ERC721 collateral asset
        string collateralContract;
        // The contract address of the ERC721 collateral asset, shortened for display
        string collateralContractPartial;
        // Symbol of the ERC721 collateral asset
        string collateralAssetSymbol;
        // TokenId of the ERC721 collateral asset
        string collateralId;
        // The loan amount, in loan asset units
        string loanAmount;
        // The interest accrued so far on the loan, in loan asset units
        string interestAccrued;
        // The loan duration in days, 0 if duration is less than 1 day
        string durationDays;
        // The UTC end date and time of the loan, 'n/a' if loan does not have lender
        string endDateTime;
    }

    /// @notice returns an SVG image as a string. The SVG image is specific to the SVGParams
    function generateSVG(SVGParams memory params, ITicketTypeSpecificSVGHelper typeSpecificHelper) 
    internal 
    pure 
    returns (string memory svg) 
    {
        return string.concat(
            '<svg version=""1.1"" id=""Layer_1"" xmlns=""http://www.w3.org/2000/svg"" ',
            'xmlns:xlink=""http://www.w3.org/1999/xlink"" x=""0px"" y=""0px"" ',
            'viewBox=""0 0 300 300"" style=""enable-background:new 0 0 300 300;"" xml:space=""preserve"">',
            stylesAndBackground(
                typeSpecificHelper,
                params.id,
                params.loanAssetContract,
                params.collateralContract
            ),
            staticValues(params.nftType, typeSpecificHelper),
            dynamicValues(params, typeSpecificHelper),
            dynamicValues2(params),
            '</svg>'
        );
    }

    function stylesAndBackground(
        ITicketTypeSpecificSVGHelper typeSpecificHelper,
        string memory id, 
        string memory loanAsset,
        string memory collateralAsset
    ) 
        private 
        pure
        returns (string memory) 
    {
        return string.concat(
            '<style type=""text/css"">',
                '.st0{fill:url(#wash);}',
                '.st1{width: 171px; height: 23px; opacity:0.65; fill:#FFFFFF;}',
                '.st2{width: 171px; height: 23px; opacity:0.45; fill:#FFFFFF;}',
                '.st3{width: 98px; height: 23px; opacity:0.2; fill:#FFFFFF;}',
                '.st4{width: 98px; height: 23px; opacity:0.35; fill:#FFFFFF;}',
                '.st5{font-family: monospace, monospace; font-size: 28px;}',
                '.st7{font-family: monospace, monospace; font-size:10px; fill:#000000; opacity: .9;}',
                '.st8{width: 98px; height: 54px; opacity:0.35; fill:#FFFFFF;}',
                '.st9{width: 171px; height: 54px; opacity:0.65; fill:#FFFFFF;}',
                '.right{text-anchor: end;}',
                '.left{text-anchor: start;}',
                typeSpecificHelper.backgroundColorsStyles(loanAsset, collateralAsset),
            '</style>',
            '<defs>',
                '<radialGradient id=""wash"" cx=""120"" cy=""40"" r=""140"" gradientTransform=""skewY(5)"" ',
                'gradientUnits=""userSpaceOnUse"">',
                    '<stop  offset=""0%"" class=""highlight-hue""/>',
                    '<stop  offset=""100%"" class=""highlight-offset""/>',
                    '<animate attributeName=""r"" values=""300;520;320;420;300"" dur=""25s"" repeatCount=""indefinite""/>',
                    '<animate attributeName=""cx"" values=""120;420;260;120;60;120"" dur=""25s"" repeatCount=""indefinite""/>',
                    '<animate attributeName=""cy"" values=""40;300;40;250;390;40"" dur=""25s"" repeatCount=""indefinite""/>',
                '</radialGradient>',
            '</defs>',
            '<rect x=""0"" class=""st0"" width=""300"" height=""300""/>',
            '<rect y=""31"" x=""',
            typeSpecificHelper.backgroundValueRectsXTranslate(),
            '"" width=""171"" height=""54"" style=""opacity:0.65; fill:#FFFFFF;""/>',
            '<text x=""',
            typeSpecificHelper.ticketIdXCoordinate(),
            '"" y=""69"" class=""st5 ',
            typeSpecificHelper.alignmentClass(),
            '"" fill=""black"">',
            id,
            '</text>'
        );
    }

    function staticValues(
        string memory ticketType,
        ITicketTypeSpecificSVGHelper typeSpecificHelper
    )
        private
        pure
        returns (string memory) 
    {
        return string.concat(
            '<g transform=""translate(',
            typeSpecificHelper.backgroundTitleRectsXTranslate(),
            ',0)"">',
                '<rect y=""31"" class=""st8""/>',
                '<rect y=""85"" class=""st3""/>',
                '<rect y=""108"" class=""st4""/>',
                '<rect y=""131"" class=""st3""/>',
                '<rect y=""154"" class=""st4""/>',
                '<rect y=""177"" class=""st3""/>',
                '<rect y=""200"" class=""st4""/>',
                '<rect y=""223"" class=""st3""/>',
                '<rect y=""246"" class=""st4""/>',
            '</g>',
            '<g class=""st7 ',
            typeSpecificHelper.titlesPositionClass(),
            '"" transform=""translate(',
            typeSpecificHelper.titlesXTranslate(),
            ',0)"">',
                '<text y=""56"">',
                ticketType,
                'er</text>',
                '<text y=""70"">Ticket</text>',
                '<text y=""99"">Loan Amount</text>',
                '<text y=""122"">Interest Rate</text>',
                '<text y=""145"">Status</text>',
                '<text y=""168"">Accrued</text>',
                '<text y=""191"">Collateral NFT</text>',
                '<text y=""214"">Collateral ID</text>',
                '<text y=""237"">Duration</text>',
                '<text y=""260"">End Date</text>',
            '</g>',
            '<g transform=""translate(',
            typeSpecificHelper.backgroundValueRectsXTranslate(),
            ',0)"">',
                '<rect y=""246"" class=""st1""/>',
                '<rect y=""223"" class=""st2""/>',
                '<rect y=""200"" class=""st1""/>',
                '<rect y=""177"" class=""st2""/>',
                '<rect y=""154"" class=""st1""/>',
                '<rect y=""131"" class=""st2""/>',
                '<rect y=""108"" class=""st1""/>',
                '<rect y=""85"" class=""st2""/>',
            '</g>'
        );
    }

    function dynamicValues(
        SVGParams memory params, 
        ITicketTypeSpecificSVGHelper typeSpecificHelper
    ) 
        private
        pure
        returns (string memory) 
    {
        return string.concat(
            '<g class=""st7 ',
            typeSpecificHelper.alignmentClass(),
            '"" transform=""translate(',
            typeSpecificHelper.valuesXTranslate(),
            ',0)"">',
            '<text y=""99"">',
            params.loanAmount, 
            ' ',
            params.loanAssetSymbol,
            '</text>',
            '<text y=""122"">',
            params.interestRate,
            '</text>',
            '<text y=""145"">',
            params.status,
            '</text>',
            '<text y=""168"">'
        );
    }

    function dynamicValues2(
        SVGParams memory params
    ) 
        private 
        pure 
        returns (string memory) 
    {
        return string.concat(
            params.interestAccrued,
            ' ',
            params.loanAssetSymbol,
            '</text>',
            '<text y=""191"">(',
            params.collateralAssetSymbol,
            ') ',
            params.collateralContractPartial,
            '</text>',
            '<text y=""214"">',
            params.collateralId,
            '</text>',
            '<text y=""237"">',
            params.durationDays,
            ' days </text>',
            '<text y=""260"">',
            params.endDateTime,
            '</text>',
            '</g>'
        );
    }
}",1972
RealWorld_TA_106_TicketTypeSpecificSVGHelper_RealWorld_20240812213413.log,106,TicketTypeSpecificSVGHelper,67030,1840,68870,103.0,0.37195,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import '../interfaces/ITicketTypeSpecificSVGHelper.sol';
import ""@openzeppelin/contracts/utils/Strings.sol"";

contract TicketTypeSpecificSVGHelper is ITicketTypeSpecificSVGHelper {
    /// See {ITicketTypeSpecificSVGHelper-backgroundColorsStyles}
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
    ) 
        external 
        pure 
        override 
        virtual 
        returns (string memory) 
    {}

    /// See {ITicketTypeSpecificSVGHelper}
    function ticketIdXCoordinate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundTitleRectsXTranslate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesPositionClass() external pure virtual override returns (string memory) {}
    
    /// See {ITicketTypeSpecificSVGHelper}
    function titlesXTranslate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundValueRectsXTranslate() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function alignmentClass() external pure virtual override returns (string memory) {}

    /// See {ITicketTypeSpecificSVGHelper}
    function valuesXTranslate() external pure virtual override returns (string memory) {}

    /// @dev used by backgroundColorsStyles, returns SVG style classes    
    function colorStyles(string memory primary, string memory secondary) internal pure returns (string memory) {
        return string.concat(
            '.highlight-hue{stop-color:',
            addressStringToHSL(primary),
            '}',
            '.highlight-offset{stop-color:',
            addressStringToHSL(secondary),
            '}'
        );
    }

    /**
     * @dev returns a string, an HSL color specification that can be used in SVG styles. 
     * where H, S, and L, are derived from `account`
     */
    function addressStringToHSL(string memory account) private pure returns (string memory) {
        bytes32 hs = keccak256(abi.encodePacked(account));
        uint256 h = (uint256(uint8(hs[0])) + uint8(hs[1])) % 360;
        uint256 s = 80 + (uint8(hs[2]) % 20);
        uint256 l = 80 + (uint8(hs[3]) % 10);
        return string.concat(
            'hsl(',
            Strings.toString(h),
            ',',
            Strings.toString(s),
            '%,',
            Strings.toString(l),
            '%)'
        );
    }
}",574
RealWorld_TA_106_INFTLoanFacilitator_RealWorld_20240812214638.log,106,INFTLoanFacilitator,257152,2594,259746,112.0,1.33764,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface INFTLoanFacilitator {
    /// @notice See loanInfo
    struct Loan {
        bool closed;
        uint16 perAnumInterestRate;
        uint32 durationSeconds;
        uint40 lastAccumulatedTimestamp;
        address collateralContractAddress;
        address loanAssetContractAddress;
        uint128 accumulatedInterest;
        uint128 loanAmount;
        uint256 collateralTokenId;
    }

    /**
     * @notice The magnitude of SCALAR
     * @dev 10^INTEREST_RATE_DECIMALS = 1 = 100%
     */
    function INTEREST_RATE_DECIMALS() external returns (uint8);

    /**
     * @notice The SCALAR for all percentages in the loan facilitator contract
     * @dev Any interest rate passed to a function should already been multiplied by SCALAR
     */
    function SCALAR() external returns (uint256);

    /**
     * @notice The percent of the loan amount that the facilitator will take as a fee, scaled by SCALAR
     * @dev Starts set to 1%. Can only be set to 0 - 5%. 
     */
    function originationFeeRate() external returns (uint256);

    /**
     * @notice The lend ticket contract associated with this loan faciliator
     * @dev Once set, cannot be modified
     */
    function lendTicketContract() external returns (address);

    /**
     * @notice The borrow ticket contract associated with this loan faciliator
     * @dev Once set, cannot be modified
     */
    function borrowTicketContract() external returns (address);

    /**
     * @notice The percent improvement required of at least one loan term when buying out current lender 
     * a loan that already has a lender, scaled by SCALAR. 
     * E.g. setting this value to 100 (10%) means, when replacing a lender, the new loan terms must have
     * at least 10% greater duration or loan amount or at least 10% lower interest rate. 
     * @dev Starts at 100 = 10%. Only owner can set. Cannot be set to 0.
     */
    function requiredImprovementRate() external returns (uint256);
    
    /**
     * @notice Emitted when the loan is created
     * @param id The id of the new loan, matches the token id of the borrow ticket minted in the same transaction
     * @param minter msg.sender
     * @param collateralTokenId The token id of the collateral NFT
     * @param collateralContract The contract address of the collateral NFT
     * @param maxInterestRate The max per anum interest rate, scaled by SCALAR
     * @param loanAssetContract The contract address of the loan asset
     * @param minLoanAmount mimimum loan amount
     * @param minDurationSeconds minimum loan duration in seconds
    */
    event CreateLoan(
        uint256 indexed id,
        address indexed minter,
        uint256 collateralTokenId,
        address collateralContract,
        uint256 maxInterestRate,
        address loanAssetContract,
        uint256 minLoanAmount,
        uint256 minDurationSeconds
        );

    /** 
     * @notice Emitted when ticket is closed
     * @param id The id of the ticket which has been closed
     */
    event Close(uint256 indexed id);

    /** 
     * @notice Emitted when the loan is underwritten or re-underwritten
     * @param id The id of the ticket which is being underwritten
     * @param lender msg.sender
     * @param interestRate The per anum interest rate, scaled by SCALAR, for the loan
     * @param loanAmount The loan amount
     * @param durationSeconds The loan duration in seconds 
     */
    event Lend(
        uint256 indexed id,
        address indexed lender,
        uint256 interestRate,
        uint256 loanAmount,
        uint256 durationSeconds
    );

    /**
     * @notice Emitted when a loan is being re-underwritten, the current loan ticket holder is being bought out
     * @param lender msg.sender
     * @param replacedLoanOwner The current loan ticket holder
     * @param interestEarned The amount of interest the loan has accrued from first lender to this buyout
     * @param replacedAmount The loan amount prior to buyout
     */    
    event BuyoutLender(
        uint256 indexed id,
        address indexed lender,
        address indexed replacedLoanOwner,
        uint256 interestEarned,
        uint256 replacedAmount
    );
    
    /**
     * @notice Emitted when loan is repaid
     * @param id The loan id
     * @param repayer msg.sender
     * @param loanOwner The current holder of the lend ticket for this loan, token id matching the loan id
     * @param interestEarned The total interest accumulated on the loan
     * @param loanAmount The loan amount
     */
    event Repay(
        uint256 indexed id,
        address indexed repayer,
        address indexed loanOwner,
        uint256 interestEarned,
        uint256 loanAmount
    );

    /**
     * @notice Emitted when loan NFT collateral is seized 
     * @param id The ticket id
     */
    event SeizeCollateral(uint256 indexed id);

     /**
      * @notice Emitted when origination fees are withdrawn
      * @dev only owner can call
      * @param asset the ERC20 asset withdrawn
      * @param amount the amount withdrawn
      * @param to the address the withdrawn amount was sent to
      */
     event WithdrawOriginationFees(address asset, uint256 amount, address to);

      /**
      * @notice Emitted when originationFeeRate is updated
      * @dev only owner can call, value is scaled by SCALAR, 100% = SCALAR
      * @param feeRate the new origination fee rate
      */
     event UpdateOriginationFeeRate(uint32 feeRate);

     /**
      * @notice Emitted when requiredImprovementRate is updated
      * @dev only owner can call, value is scaled by SCALAR, 100% = SCALAR
      * @param improvementRate the new required improvementRate
      */
     event UpdateRequiredImprovementRate(uint256 improvementRate);

    /**
     * @notice (1) transfers the collateral NFT to the loan facilitator contract 
     * (2) creates the loan, populating loanInfo in the facilitator contract,
     * and (3) mints a Borrow Ticket to mintBorrowTicketTo
     * @dev loan duration or loan amount cannot be 0, 
     * this is done to protect borrowers from accidentally passing a default value
     * and also because it creates odd lending and buyout behavior: possible to lend
     * for 0 value or 0 duration, and possible to buyout with no improvement because, for example
     * previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds
     * evaluates to true if previousDurationSeconds is 0 and durationSeconds is 0.
     * loanAssetContractAddress cannot be address(0), we check this because Solmate SafeTransferLib
     * does not revert with address(0) and this could cause odd behavior.
     * collateralContractAddress cannot be address(borrowTicket) or address(lendTicket).
     * @param collateralTokenId The token id of the collateral NFT 
     * @param collateralContractAddress The contract address of the collateral NFT
     * @param maxPerAnumInterest The maximum per anum interest rate for this loan, scaled by SCALAR
     * @param minLoanAmount The minimum acceptable loan amount for this loan
     * @param loanAssetContractAddress The address of the loan asset
     * @param minDurationSeconds The minimum duration for this loan
     * @param mintBorrowTicketTo An address to mint the Borrow Ticket corresponding to this loan to
     * @return id of the created loan
     */
    function createLoan(
            uint256 collateralTokenId,
            address collateralContractAddress,
            uint16 maxPerAnumInterest,
            uint128 minLoanAmount,
            address loanAssetContractAddress,
            uint32 minDurationSeconds,
            address mintBorrowTicketTo
    ) external returns (uint256 id);

    /**
     * @notice Closes the loan, sends the NFT collateral to sendCollateralTo
     * @dev Can only be called by the holder of the Borrow Ticket with tokenId
     * matching the loanId. Can only be called if loan has not be underwritten,
     * i.e. lastAccumulatedInterestTimestamp = 0
     * @param loanId The loan id
     * @param sendCollateralTo The address to send the collateral NFT to
     */
    function closeLoan(uint256 loanId, address sendCollateralTo) external;

    /**
     * @notice Lends, meeting or beating the proposed loan terms, 
     * transferring `amount` of the loan asset 
     * to the facilitator contract. If the loan has not yet been underwritten, 
     * a Lend Ticket is minted to `sendLendTicketTo`. If the loan has already been 
     * underwritten, then this is a buyout, and the Lend Ticket will be transferred
     * from the current holder to `sendLendTicketTo`. Also in the case of a buyout, interestOwed()
     * is transferred from the caller to the facilitator contract, in addition to `amount`, and
     * totalOwed() is paid to the current Lend Ticket holder.
     * @dev Loan terms must meet or beat loan terms. If a buyout, at least one loan term
     * must be improved by at least 10%. E.g. 10% longer duration, 10% lower interest, 
     * 10% higher amount
     * @param loanId The loan id
     * @param interestRate The per anum interest rate, scaled by SCALAR
     * @param amount The loan amount
     * @param durationSeconds The loan duration in seconds
     * @param sendLendTicketTo The address to send the Lend Ticket to
     */
    function lend(
            uint256 loanId,
            uint16 interestRate,
            uint128 amount,
            uint32 durationSeconds,
            address sendLendTicketTo
    ) external;

    /**
     * @notice repays and closes the loan, transferring totalOwed() to the current Lend Ticket holder
     * and transferring the collateral NFT to the Borrow Ticket holder.
     * @param loanId The loan id
     */
    function repayAndCloseLoan(uint256 loanId) external;

    /**
     * @notice Transfers the collateral NFT to `sendCollateralTo` and closes the loan.
     * @dev Can only be called by Lend Ticket holder. Can only be called 
     * if block.timestamp > loanEndSeconds()
     * @param loanId The loan id
     * @param sendCollateralTo The address to send the collateral NFT to
     */
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external;

    /**
     * @notice returns the info for this loan
     * @param loanId The id of the loan
     * @return closed Whether or not the ticket is closed
     * @return perAnumInterestRate The per anum interest rate, scaled by SCALAR
     * @return durationSeconds The loan duration in seconds
     
     * @return lastAccumulatedTimestamp The timestamp (in seconds) when interest was last accumulated, 
     * i.e. the timestamp of the most recent underwriting
     * @return collateralContractAddress The contract address of the NFT collateral 
     * @return loanAssetContractAddress The contract address of the loan asset.
     * @return accumulatedInterest The amount of interest accumulated on the loan prior to the current lender
     * @return loanAmount The loan amount
     * @return collateralTokenId The token ID of the NFT collateral
     */
    function loanInfo(uint256 loanId)
        external 
        view 
        returns (
            bool closed,
            uint16 perAnumInterestRate,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmount,
            uint256 collateralTokenId
        );

    /**
     * @notice returns the info for this loan
     * @dev this is a convenience method for other contracts that would prefer to have the 
     * Loan object not decomposed. 
     * @param loanId The id of the loan
     * @return Loan struct corresponding to loanId
     */
    function loanInfoStruct(uint256 loanId) external view returns (Loan memory);

    /**
     * @notice returns the total amount owed for the loan, i.e. principal + interest
     * @param loanId The loan id
     */
    function totalOwed(uint256 loanId) view external returns (uint256);

    /**
     * @notice returns the interest owed on the loan, in loan asset units
     * @param loanId The loan id
     */
    function interestOwed(uint256 loanId) view external returns (uint256);

    /**
     * @notice returns the unix timestamp (seconds) of the loan end
     * @param loanId The loan id
     */
    function loanEndSeconds(uint256 loanId) view external returns (uint256);
}",2876
RealWorld_TA_106_UintStrings_RealWorld_20240812214336.log,106,UintStrings,107469,1702,109171,94.0,0.571385,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.12;


library UintStrings {
    /** 
     * @notice Converts `number` into a decimal string, with '%' is `isPercent` = true
     * @param number The number to convert to a string
     * @param decimals The number of decimals `number` should have when converted to a string
     * for example, number = 15 and decimals = 0 would yield ""15"", 
     * whereas number = 15 and decimals = 1 would yield ""1.5""
     * @param isPercent Whether the string returned should include '%' at the end
     * @return string
     */
    function decimalString(uint256 number, uint8 decimals, bool isPercent) internal pure returns (string memory) {
        if (number == 0) return isPercent ? ""0%"" : ""0"";
        
        uint8 percentBufferOffset = isPercent ? 1 : 0;
        uint256 tenPowDecimals = 10 ** decimals;

        uint256 temp = number;
        uint8 digits;
        uint8 numSigfigs;
        while (temp != 0) {
            if (numSigfigs > 0) {
                // count all digits preceding least significant figure
                numSigfigs++;
            } else if (temp % 10 != 0) {
                numSigfigs++;
            }
            digits++;
            temp /= 10;
        }

        DecimalStringParams memory params;
        params.isPercent = isPercent;
        if ((digits - numSigfigs) >= decimals) {
            // no decimals, ensure we preserve all trailing zeros
            params.sigfigs = number / tenPowDecimals;
            params.sigfigIndex = digits - decimals;
            params.bufferLength = params.sigfigIndex + percentBufferOffset;
        } else {
            // chop all trailing zeros for numbers with decimals
            params.sigfigs = number / (10 ** (digits - numSigfigs));
            if (tenPowDecimals > number) {
                // number is less than one
                // in this case, there may be leading zeros after the decimal place 
                // that need to be added

                // offset leading zeros by two to account for leading '0.'
                params.zerosStartIndex = 2;
                params.zerosEndIndex = decimals - digits + 2;
                params.sigfigIndex = numSigfigs + params.zerosEndIndex;
                params.bufferLength = params.sigfigIndex + percentBufferOffset;
                params.isLessThanOne = true;
            } else {
                // In this case, there are digits before and
                // after the decimal place
                params.sigfigIndex = numSigfigs + 1;
                params.decimalIndex = digits - decimals + 1;
            }
        }
        params.bufferLength = params.sigfigIndex + percentBufferOffset;
        return generateDecimalString(params);
    }

    /// @dev the below is from
    /// https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol#L189-L231
    // with modifications

    struct DecimalStringParams {
        // significant figures of decimal
        uint256 sigfigs;
        // length of decimal string
        uint8 bufferLength;
        // ending index for significant figures (funtion works backwards when copying sigfigs)
        uint8 sigfigIndex;
        // index of decimal place (0 if no decimal)
        uint8 decimalIndex;
        // start index for trailing/leading 0's for very small/large numbers
        uint8 zerosStartIndex;
        // end index for trailing/leading 0's for very small/large numbers
        uint8 zerosEndIndex;
        // true if decimal number is less than one
        bool isLessThanOne;
        // true if string should include ""%""
        bool isPercent;
    }

    function generateDecimalString(DecimalStringParams memory params) private pure returns (string memory) {
        bytes memory buffer = new bytes(params.bufferLength);
        if (params.isPercent) {
            buffer[buffer.length - 1] = '%';
        }
        if (params.isLessThanOne) {
            buffer[0] = '0';
            buffer[1] = '.';
        }

        // add leading/trailing 0's
        for (uint256 zerosCursor = params.zerosStartIndex; zerosCursor < params.zerosEndIndex; zerosCursor++) {
            buffer[zerosCursor] = bytes1(uint8(48));
        }
        // add sigfigs
        while (params.sigfigs > 0) {
            if (params.decimalIndex > 0 && params.sigfigIndex == params.decimalIndex) {
                buffer[--params.sigfigIndex] = '.';
            }
            buffer[--params.sigfigIndex] = bytes1(uint8(uint256(48) + (params.sigfigs % 10)));
            params.sigfigs /= 10;
        }
        return string(buffer);
    }
}",1060
RealWorld_TA_106_BorrowTicket_RealWorld_20240812211055.log,106,BorrowTicket,29802,1697,31499,85.0,0.18295,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import './NFTLoanTicket.sol';
import {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';
import {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';

contract BorrowTicket is NFTLoanTicket {

    /// See NFTLoanTicket
    constructor(
        NFTLoanFacilitator _nftLoanFacilitator,
        NFTLoansTicketDescriptor _descriptor
    ) 
        NFTLoanTicket(""Borrow Ticket"", ""BRWT"", _nftLoanFacilitator, _descriptor)
    {}
}",146
RealWorld_TA_106_CryptoPunks_RealWorld_20240812212026.log,106,CryptoPunks,34768,3143,37911,98.0,0.2367,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/utils/Strings.sol"";

contract CryptoPunks is ERC721 {
    using Strings for uint256;

    uint256 private _nonce = 999;

	constructor() ERC721(""CryptoPunks"", ""PUNKS"") {
    }

    function mint() external returns (uint256 id) {
        id = mintTo(msg.sender);
    }

    function mintTo(address to) public returns (uint256) {
        _safeMint(to, ++_nonce, """");
        return _nonce;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), ""ERC721Metadata: URI query for nonexistent token"");

        return """";
    }
}",183
RealWorld_TA_106_LendTicketSVGHelper_RealWorld_20240812213248.log,106,LendTicketSVGHelper,49117,1234,50351,82.0,0.270265,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import './TicketTypeSpecificSVGHelper.sol';

contract LendTicketSVGHelper is TicketTypeSpecificSVGHelper {
    /**
     * @dev Returns SVG styles where the primary background color is derived
     * from the loan asset address and the secondary background color 
     * is derived from the collateral asset address
     */
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
    ) 
        external
        pure
        override
        returns (string memory)
    {
        return colorStyles(loanAsset, collateralAsset);
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function ticketIdXCoordinate() external pure override returns (string memory) {
        return '165';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundTitleRectsXTranslate() external pure override returns (string memory) {
        return '171';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesPositionClass() external pure override returns (string memory) {
        return 'left';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function titlesXTranslate() external pure override returns (string memory) {
        return '179';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function backgroundValueRectsXTranslate() external pure override returns (string memory) {
        return '0';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function alignmentClass() external pure override returns (string memory) {
        return 'right';
    }

    /// See {ITicketTypeSpecificSVGHelper}
    function valuesXTranslate() external pure override returns (string memory) {
        return '163';
    }
}",369
RealWorld_TA_106_NFTLoanFacilitatorTest.t_RealWorld_20240812211646.log,106,NFTLoanFacilitatorTest.t,821222,68,821290,115.0,4.10747,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.12;

import {DSTest} from ""./helpers/test.sol"";
import {Vm} from ""./helpers/Vm.sol"";

import {NFTLoanFacilitator} from ""contracts/NFTLoanFacilitator.sol"";
import {NFTLoanFacilitatorFactory} from ""./helpers/NFTLoanFacilitatorFactory.sol"";
import {BorrowTicket} from ""contracts/BorrowTicket.sol"";
import {LendTicket} from ""contracts/LendTicket.sol"";
import {CryptoPunks} from ""./mocks/CryptoPunks.sol"";
import {DAI} from ""./mocks/DAI.sol"";

contract NFTLoanFacilitatorGasBenchMarkTest is DSTest {
    Vm vm = Vm(HEVM_ADDRESS);
    NFTLoanFacilitator facilitator;
    CryptoPunks punks = new CryptoPunks();
    DAI dai = new DAI();
    uint256 punkId;
    uint16 interestRate = 15;
    uint128 loanAmount = 1e20;
    uint32 loanDuration = 1000;
    uint256 startTimestamp = 5;

    function setUp() public {
        NFTLoanFacilitatorFactory factory = new NFTLoanFacilitatorFactory();
        (, , facilitator) = factory.newFacilitator(address(this));

        // approve for lending
        dai.mint(loanAmount * 3, address(this));
        dai.approve(address(facilitator), loanAmount * 3);

        // create a loan so we can close it or lend against it
        punkId = punks.mint();
        punks.approve(address(facilitator), punkId);
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            address(this)
        );

        // mint another punk so we can create a second loan
        punks.mint();
        punks.approve(address(facilitator), punkId + 1);

        // prevent errors from timestamp 0
        vm.warp(startTimestamp);

        // create another loan and lend against it so we can buyout or repay
        punks.mint();
        punks.approve(address(facilitator), punkId + 2);
        facilitator.createLoan(
            punkId + 2,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            address(this)
        );
        facilitator.lend(
            2,
            interestRate,
            loanAmount,
            loanDuration,
            address(this)
        );
    }

    function testCreateLoan() public {
        facilitator.createLoan(
            punkId + 1,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            address(this)
        );
    }

    function testCloseLoan() public {
        facilitator.closeLoan(1, address(this));
    }

    function testLend() public {
        facilitator.lend(
            1,
            interestRate,
            loanAmount,
            loanDuration,
            address(this)
        );
    }

    function testLendBuyout() public {
        facilitator.lend(
            2,
            interestRate,
            loanAmount + ((loanAmount * 10) / 100),
            loanDuration,
            address(this)
        );
    }

    function testRepayAndClose() public {
        facilitator.repayAndCloseLoan(2);
    }

    function testSeizeCollateral() public {
        vm.warp(startTimestamp + loanDuration + 1);
        facilitator.seizeCollateral(2, address(this));
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }
}

contract NFTLoanFacilitatorTest is DSTest {
    event CreateLoan(
        uint256 indexed id,
        address indexed minter,
        uint256 collateralTokenId,
        address collateralContract,
        uint256 maxInterestRate,
        address loanAssetContract,
        uint256 minLoanAmount,
        uint256 minDurationSeconds
    );

    event Lend(
        uint256 indexed id,
        address indexed lender,
        uint256 interestRate,
        uint256 loanAmount,
        uint256 durationSeconds
    );

    event BuyoutLender(
        uint256 indexed id,
        address indexed lender,
        address indexed replacedLoanOwner,
        uint256 interestEarned,
        uint256 replacedAmount
    );

    Vm vm = Vm(HEVM_ADDRESS);

    NFTLoanFacilitator facilitator;
    BorrowTicket borrowTicket;
    LendTicket lendTicket;

    address borrower = address(1);
    address lender = address(2);

    CryptoPunks punks = new CryptoPunks();
    DAI dai = new DAI();

    uint16 interestRate = 15;
    uint128 loanAmount = 1e20;
    uint32 loanDuration = 1000;
    uint256 startTimestamp = 5;
    uint256 punkId;

    function setUp() public {
        NFTLoanFacilitatorFactory factory = new NFTLoanFacilitatorFactory();
        (borrowTicket, lendTicket, facilitator) = factory.newFacilitator(
            address(this)
        );
        vm.warp(startTimestamp);

        vm.startPrank(borrower);
        punkId = punks.mint();
        punks.approve(address(facilitator), punkId);
        vm.stopPrank();
    }

    function testCreateLoanEmitsCorrectly() public {
        vm.expectEmit(true, true, true, true);
        emit CreateLoan(
            1,
            borrower,
            punkId,
            address(punks),
            interestRate,
            address(dai),
            loanAmount,
            loanDuration
        );
        vm.prank(borrower);
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testCreateLoanTransfersCollateralToSelf() public {
        vm.prank(borrower);
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );

        assertEq(punks.ownerOf(punkId), address(facilitator));
    }

    function testCreateLoanMintsBorrowTicketCorrectly() public {
        address mintBorrowTicketTo = address(3);
        vm.prank(borrower);
        uint256 loanId = facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            mintBorrowTicketTo
        );

        assertEq(borrowTicket.ownerOf(loanId), mintBorrowTicketTo);
    }

    function testCreateLoanSetsValuesCorrectly(
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        uint32 minDurationSeconds,
        address mintTo
    ) public {
        vm.assume(minLoanAmount > 0);
        vm.assume(minDurationSeconds > 0);
        vm.assume(mintTo != address(0));

        vm.prank(borrower);
        uint256 loanId = facilitator.createLoan(
            punkId,
            address(punks),
            maxPerAnumInterest,
            minLoanAmount,
            address(dai),
            minDurationSeconds,
            mintTo
        );
        (
            bool closed,
            uint16 perAnumInterestRate,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(durationSeconds, minDurationSeconds);
        assertEq(perAnumInterestRate, maxPerAnumInterest);
        assertEq(loanAmountFromLoan, minLoanAmount);
        assertEq(lastAccumulatedTimestamp, 0);
        assertEq(accumulatedInterest, 0);
        assertEq(collateralContractAddress, address(punks));
        assertEq(collateralTokenId, punkId);
        assertEq(loanAssetContractAddress, address(dai));
    }

    function testCreateLoanZeroDurationNotAllowed() public {
        vm.startPrank(borrower);
        vm.expectRevert(""NFTLoanFacilitator: 0 duration"");
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            0,
            borrower
        );
    }

    function testCreateLoanZeroAmountNotAllowed() public {
        vm.startPrank(borrower);
        vm.expectRevert(""NFTLoanFacilitator: 0 loan amount"");
        facilitator.createLoan(
            punkId,
            address(punks),
            interestRate,
            0,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testCreateLoanAddressZeroCollateralFails() public {
        vm.startPrank(borrower);
        vm.expectRevert(bytes(""""));
        facilitator.createLoan(
            punkId,
            address(0),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testBorrowTicketUnusableAsCollateral() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        borrowTicket.approve(address(facilitator), loanId);
        vm.expectRevert(""NFTLoanFacilitator: cannot use tickets as collateral"");
        facilitator.createLoan(
            loanId,
            address(borrowTicket),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testLendTicketUnusableAsCollateral() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        vm.startPrank(lender);

        lendTicket.approve(address(facilitator), loanId);
        vm.expectRevert(""NFTLoanFacilitator: cannot use tickets as collateral"");
        facilitator.createLoan(
            loanId,
            address(lendTicket),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
    }

    function testSuccessfulCloseLoan() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        facilitator.closeLoan(loanId, borrower);
        assertEq(punks.ownerOf(tokenId), borrower); // make sure borrower gets their NFT back
        (bool closed, , , , , , , , ) = facilitator.loanInfo(loanId);
        assertTrue(closed); // make sure loan was closed
    }

    function testClosingAlreadyClosedLoan() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        facilitator.closeLoan(loanId, borrower);

        // closing an already closed loan should revert
        vm.expectRevert(""NFTLoanFacilitator: loan closed"");
        facilitator.closeLoan(loanId, borrower);
    }

    function testClosingLoanWithLender() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);

        dai.mint(loanAmount, borrower);
        dai.approve(address(facilitator), loanAmount); // approve for lending
        vm.warp(startTimestamp); // make sure there's a non-zero timestamp
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            borrower
        ); // have borrower lend, this is not realistic, but will do for this test

        // loan has lender, should now revert
        vm.expectRevert(
            ""NFTLoanFacilitator: has lender, use repayAndCloseLoan""
        );
        facilitator.closeLoan(loanId, borrower);
    }

    function testClosingLoanFromNonBorrower() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);

        vm.startPrank(address(2));
        vm.expectRevert(""NFTLoanFacilitator: borrow ticket holder only"");
        facilitator.closeLoan(loanId, borrower);
        vm.stopPrank();
    }

    function testInterestExceedingUint128BuyoutReverts() public {
        loanAmount = type(uint128).max;
        // 100% APR
        interestRate = 1000;
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        facilitator.interestOwed(loanId);
        vm.warp(startTimestamp + 366 days);
        
        vm.expectRevert(""NFTLoanFacilitator: accumulated interest exceeds uint128"");
        facilitator.lend(loanId, 0, loanAmount, loanDuration, address(4));
    }

    function testInterestExceedingUint128InterestOwed() public {
        loanAmount = type(uint128).max;
        // 100% APR
        interestRate = 1000;
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        vm.warp(startTimestamp + 366 days);
        facilitator.interestOwed(loanId); 
    }

    function testRepayInterestOwedExceedingUint128() public {
        loanAmount = type(uint128).max;
        // 100% APR
        interestRate = 1000;
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        vm.warp(startTimestamp + 366 days);
        uint256 t = facilitator.totalOwed(loanId);
        vm.startPrank(address(3));
        dai.mint(t, address(3));
        dai.approve(address(facilitator), t);
        facilitator.repayAndCloseLoan(loanId);
        vm.stopPrank();
    }

    function testLendMintsLendTicketCorrectly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        setUpLender(lender);
        vm.startPrank(lender);
         facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );

        assertEq(lendTicket.ownerOf(loanId), lender);
    }

    function testLendTransfersERC20Correctly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        setUpLender(lender);

        uint256 lenderBalance = dai.balanceOf(lender);

        vm.startPrank(lender);
         facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );

        assertEq(dai.balanceOf(lender), lenderBalance - loanAmount);
        uint256 facilitatorTake = loanAmount * facilitator.originationFeeRate() / facilitator.SCALAR();
        assertEq(dai.balanceOf(address(facilitator)), facilitatorTake);
        assertEq(dai.balanceOf(borrower), loanAmount - facilitatorTake);
    }

    function testLendUpdatesValuesCorrectly(
        uint16 rate,
        uint128 amount,
        uint32 duration,
        address sendTo
    ) public {
        vm.assume(rate <= interestRate);
        vm.assume(amount >= loanAmount);
        vm.assume(duration >= loanDuration);
        vm.assume(sendTo != address(0));
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows

        (uint256 tokenId, uint256 loanId) = setUpLoanForTest(borrower);

        dai.mint(amount, address(this));
        dai.approve(address(facilitator), amount);

        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            sendTo
        );
        (
            bool closed,
            uint16 interest,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(rate, interest);
        assertEq(duration, durationSeconds);
        assertEq(amount, loanAmountFromLoan);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(accumulatedInterest, 0);
        // does not change immutable values
        assertEq(collateralContractAddress, address(punks));
        assertEq(loanAssetContractAddress, address(dai));
        assertEq(collateralTokenId, tokenId);
    }

    function testLendEmitsCorrectly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);

        dai.mint(loanAmount, address(this));
        dai.approve(address(facilitator), loanAmount);

        vm.expectEmit(true, true, false, true);
        emit Lend(
            loanId,
            address(this),
            interestRate,
            loanAmount,
            loanDuration
        );

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            address(1)
        );
    }

    function testSuccessfulLend() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        uint256 lenderBalance = dai.balanceOf(lender);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );
        (
            ,
            ,
            ,
            uint40 lastAccumulatedTimestamp,
            ,
            ,
            uint256 accumulatedInterest,
            ,

        ) = facilitator.loanInfo(loanId);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(accumulatedInterest, 0);

        // make sure lenders dai is transfered and lender gets lend ticket
        assertEq(dai.balanceOf(lender), lenderBalance - loanAmount);
        assertEq(lendTicket.ownerOf(loanId), lender);

        // make sure Facilitator subtracted origination fee
        uint256 facilitatorTake = (loanAmount *
            facilitator.originationFeeRate()) / facilitator.SCALAR();
        assertEq(dai.balanceOf(address(facilitator)), facilitatorTake);

        // make sure borrower got their loan in DAI
        assertEq(dai.balanceOf(borrower), loanAmount - facilitatorTake);
    }

    function testLoanValuesNotChangedAfterLend() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );
        (
            bool closed,
            uint16 interest,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(interestRate, interest);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(durationSeconds, loanDuration);
        assertEq(accumulatedInterest, 0);
        assertEq(loanAmountFromLoan, loanAmount);
        assertEq(collateralContractAddress, address(punks));
        assertEq(loanAssetContractAddress, address(dai));
        assertEq(collateralTokenId, tokenId);
    }

    function testLendFailsIfHigherInterestRate(uint16 rate, uint32 duration, uint128 amount) public {
        vm.assume(rate > interestRate);
        vm.assume(duration >= loanDuration);
        vm.assume(amount >= loanAmount);
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: rate too high"");
        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            lender
        );
    }

    function testLendFailsIfLowerAmount(uint16 rate, uint32 duration, uint128 amount) public {
        vm.assume(rate <= interestRate);
        vm.assume(duration >= loanDuration);
        vm.assume(amount < loanAmount);
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: amount too low"");
        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            lender
        );
    }

    function testLendFailsIfLowerDuration(uint16 rate, uint32 duration, uint128 amount) public {
        vm.assume(rate <= interestRate);
        vm.assume(duration < loanDuration);
        vm.assume(amount >= loanAmount);
        (, uint256 loanId) = setUpLoanForTest(borrower);

        setUpLender(lender);
        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: duration too low"");
        facilitator.lend(
            loanId,
            rate,
            amount,
            duration,
            lender
        );
    }

    function testInterestAccruesCorrectly() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        setUpLender(lender);
        vm.startPrank(lender);
        facilitator.lend(
            loanId,
            10, // 1% annual rate
            loanAmount,
            loanDuration,
            lender
        );

        uint256 interestAccrued = facilitator.interestOwed(loanId);
        assertEq(interestAccrued, 0);

        uint256 elapsedTime = 1; // simulate fast forwarding 100 seconds
        vm.warp(startTimestamp + elapsedTime);

        // 1 second with 1% annual = 0.000000031709792% per second
        // 0.00000000031709792 * 10^20 = 31709791983
        assertEq(facilitator.interestOwed(loanId), 31709791983);

        // 1 year with 1% annual on 10^20 = 10^18
        // tiny loss of precision, 10^18 - 999999999997963200 = 2036800
        // => 0.000000000002037 in the case of currencies with 18 decimals
        vm.warp(startTimestamp + 365 days);
        assertEq(facilitator.interestOwed(loanId), 999999999997963200);
    }

    function testBuyoutSucceedsIfRateImproved(uint16 rate) public {
        vm.assume(rate <= decreaseByMinPercent(interestRate));
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);

        facilitator.lend(
            loanId,
            rate,
            loanAmount,
            loanDuration,
            newLender
        );
    }

    function testBuyoutSucceedsIfAmountImproved(uint128 amount) public {
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        vm.assume(amount >= increaseByMinPercent(loanAmount));
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint256 amountIncrease = amount - loanAmount;
        dai.mint(amountIncrease, newLender);

        vm.startPrank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            loanDuration,
            newLender
        );
    }

    function testBuyoutSucceedsIfDurationImproved(uint32 duration) public {
        vm.assume(duration >= increaseByMinPercent(loanDuration));
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            duration,
            newLender
        );
    }

    function testBuyoutUpdatesValuesCorrectly() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        vm.prank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            address(1)
        );
        (
            bool closed,
            uint16 interest,
            uint32 durationSeconds,
            uint40 lastAccumulatedTimestamp,
            address collateralContractAddress,
            address loanAssetContractAddress,
            uint128 accumulatedInterest,
            uint128 loanAmountFromLoan,
            uint256 collateralTokenId
        ) = facilitator.loanInfo(loanId);

        assertTrue(!closed);
        assertEq(interestRate, interest);
        assertEq(newDuration, durationSeconds);
        assertEq(loanAmount, loanAmountFromLoan);
        assertEq(lastAccumulatedTimestamp, startTimestamp);
        assertEq(accumulatedInterest, 0);
        // does not change immutable values
        assertEq(collateralContractAddress, address(punks));
        assertEq(loanAssetContractAddress, address(dai));
        assertEq(collateralTokenId, tokenId);
    }

    function testBuyoutUpdatesAccumulatedInterestCorrectly() public {
        
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        uint256 elapsedTime = 100;
        vm.warp(startTimestamp + elapsedTime);
        uint256 interest = facilitator.interestOwed(loanId);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        dai.mint(loanAmount + interest, address(this));
        dai.approve(address(facilitator), loanAmount + interest);

        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            address(1)
        );
        (
            ,
            ,
            ,
            uint40 lastAccumulatedTimestamp,
            ,
            ,
            uint256 accumulatedInterest,
            ,
            
        ) = facilitator.loanInfo(loanId);

        assertEq(lastAccumulatedTimestamp, startTimestamp + elapsedTime);
        assertEq(accumulatedInterest, interest);
    }

    function testBuyoutTransfersLendTicket() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        vm.prank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            newLender
        );

        assertEq(lendTicket.ownerOf(loanId), newLender);
    }

    function testBuyoutPaysPreviousLenderCorrectly(uint128 amount) public {
        vm.assume(amount >= loanAmount);
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        vm.warp(startTimestamp + 100);
        uint256 interest = facilitator.interestOwed(loanId);

        dai.mint(amount + interest, address(this));
        dai.approve(address(facilitator), amount + interest);

        uint256 beforeBalance = dai.balanceOf(lender);
        
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            uint32(increaseByMinPercent(loanDuration)),
            address(1)
        );

        assertEq(beforeBalance + loanAmount + interest, dai.balanceOf(lender));
    }

    function testBuyoutPaysBorrowerCorrectly(uint128 amount) public {
        vm.assume(amount >= loanAmount);
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        dai.mint(amount, address(this));
        dai.approve(address(facilitator), amount);

        uint256 beforeBalance = dai.balanceOf(borrower);
        
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            uint32(increaseByMinPercent(loanDuration)),
            address(1)
        );

        uint256 amountIncrease = amount - loanAmount;
        uint256 originationFee = amountIncrease * facilitator.originationFeeRate() / facilitator.SCALAR();
        assertEq(beforeBalance + (amountIncrease - originationFee), dai.balanceOf(borrower));
    }

    function testBuyoutPaysFacilitatorCorrectly(uint128 amount) public {
        vm.assume(amount >= loanAmount);
        vm.assume(amount < type(uint256).max / 10); // else origination fee multiplication overflows
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        dai.mint(amount, newLender);
        vm.startPrank(newLender);
        dai.approve(address(facilitator), amount);

        uint256 beforeBalance = dai.balanceOf(address(facilitator));
        
        facilitator.lend(
            loanId,
            interestRate,
            amount,
            uint32(increaseByMinPercent(loanDuration)),
            address(1)
        );

        uint256 amountIncrease = amount - loanAmount;
        uint256 originationFee = amountIncrease * facilitator.originationFeeRate() / facilitator.SCALAR();
        assertEq(beforeBalance + originationFee, dai.balanceOf(address(facilitator)));
    }

    function testBuyoutEmitsCorrectly() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);
        
        address newLender = address(3);
        setUpLender(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration));

        vm.expectEmit(true, true, true, true);
        emit BuyoutLender(
            loanId,
            newLender,
            lender,
            0,
            loanAmount
        );

        vm.expectEmit(true, true, false, true);
        emit Lend(
            loanId,
            newLender,
            interestRate,
            loanAmount,
            newDuration
        );

        vm.prank(newLender);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            address(1)
        );
    }

    function testBuyoutFailsIfTermsNotImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            newLender
        );
    }

    function testBuyoutFailsIfLoanAmountNotSufficientlyImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        uint256 newAmount = increaseByMinPercent(loanAmount) - 1;
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            interestRate,
            uint128(newAmount),
            loanDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfLoanDurationNotSufficientlyImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        uint32 newDuration = uint32(increaseByMinPercent(loanDuration) - 1);
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfInterestRateNotSufficientlyImproved() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        uint16 newRate = uint16(decreaseByMinPercent(interestRate) + 1);
        vm.expectRevert(
            ""NFTLoanFacilitator: proposed terms must be better than existing terms""
        );
        facilitator.lend(
            loanId,
            newRate,
            loanAmount,
            loanDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfLoanAmountRegressed(uint16 newRate, uint32 newDuration, uint128 newAmount) public {
        vm.assume(newRate <= interestRate);
        vm.assume(newDuration >= loanDuration);
        vm.assume(newAmount < loanAmount);
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(abi.encodeWithSignature(""Panic(uint256)"", 0x11));
        facilitator.lend(
            loanId,
            newRate,
            uint128(newAmount),
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfInterestRateRegressed(uint16 newRate, uint32 newDuration, uint128 newAmount) public {
        vm.assume(newRate > interestRate);
        vm.assume(newDuration >= loanDuration);
        vm.assume(newAmount >= loanAmount);
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(""NFTLoanFacilitator: rate too high"");
        facilitator.lend(
            loanId,
            newRate,
            uint128(newAmount),
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testBuyoutFailsIfDurationRegressed(uint16 newRate, uint32 newDuration, uint128 newAmount) public {
        vm.assume(newRate <= interestRate);
        vm.assume(newDuration < loanDuration);
        vm.assume(newAmount >= loanAmount);
        (, uint256 loanId) = setUpLoanWithLenderForTest(borrower, lender);

        address newLender = address(3);
        setUpLender(newLender);
        vm.startPrank(newLender);
        vm.expectRevert(""NFTLoanFacilitator: duration too low"");
        facilitator.lend(
            loanId,
            newRate,
            uint128(newAmount),
            newDuration,
            newLender
        );
        vm.stopPrank();
    }

    function testRepayAndCloseSuccessful() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        vm.warp(startTimestamp + 10); // warp so we have some interest accrued on the loan
        vm.startPrank(borrower);

        uint256 interestAccrued = facilitator.interestOwed(loanId);
        dai.mint(interestAccrued + calculateTake(loanAmount), borrower); // give borrower enough money to pay back the loan
        dai.approve(address(facilitator), loanAmount + interestAccrued);
        uint256 balanceOfBorrower = dai.balanceOf(borrower);

        facilitator.repayAndCloseLoan(loanId);

        // ensure ERC20 balances are correct
        assertEq(
            dai.balanceOf(borrower),
            balanceOfBorrower - (loanAmount + interestAccrued)
        );
        assertEq(dai.balanceOf(lender), loanAmount + interestAccrued);

        assertEq(punks.ownerOf(tokenId), borrower); // ensure borrower gets their NFT back
        (bool closed, , , , , , , , ) = facilitator.loanInfo(loanId); // ensure loan is closed on-chain
        assertTrue(closed);
    }

    function testRepayAndCloseFailsIfLoanClosed() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.startPrank(borrower);
        facilitator.closeLoan(loanId, borrower);
        vm.expectRevert(""NFTLoanFacilitator: loan closed"");
        facilitator.repayAndCloseLoan(loanId);
    }

    function testSeizeCollateralSuccessful() public {
        (uint256 tokenId, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        vm.warp(startTimestamp + loanDuration + 1); // fast forward to timestamp where loan would be overdue
        vm.prank(lender);

        facilitator.seizeCollateral(loanId, lender);
        assertEq(punks.ownerOf(tokenId), lender); // ensure lender seized collateral

        (bool closed, , , , , , , , ) = facilitator.loanInfo(loanId); // ensure loan is closed on-chain
        assertTrue(closed);
    }

    function testSeizeCollateralFailsIfLoanNotOverdue() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        vm.warp(startTimestamp + loanDuration); // fast forward to timestamp where loan would not be overdue
        vm.prank(lender);

        vm.expectRevert(""NFTLoanFacilitator: payment is not late"");
        facilitator.seizeCollateral(loanId, lender);
    }

    function testSeizeCollateralFailsIfNonLoanOwnerCalls() public {
        (, uint256 loanId) = setUpLoanWithLenderForTest(
            borrower,
            lender
        );
        address randomAddress = address(4);
        vm.prank(randomAddress);

        vm.expectRevert(""NFTLoanFacilitator: lend ticket holder only"");
        facilitator.seizeCollateral(loanId, randomAddress);
    }

    function testSeizeCollateralFailsIfLoanIsClosed() public {
        (, uint256 loanId) = setUpLoanForTest(borrower);
        vm.prank(borrower);
        facilitator.closeLoan(loanId, borrower);

        vm.startPrank(lender);
        vm.expectRevert(""NFTLoanFacilitator: loan closed"");
        facilitator.seizeCollateral(loanId, lender);
        vm.stopPrank();
    }

    function testUpdateOriginationFeeRevertsIfNotCalledByManager() public {
        vm.startPrank(address(1));
        vm.expectRevert(""Ownable: caller is not the owner"");
        facilitator.updateOriginationFeeRate(1);
    }

    function testUpdateOriginationFeeRevertsIfGreaterThanFivePercent() public {
        uint256 interestRateDecimals = facilitator.INTEREST_RATE_DECIMALS();
        vm.startPrank(address(this));
        vm.expectRevert(""NFTLoanFacilitator: max fee 5%"");
        facilitator.updateOriginationFeeRate(
            uint32(6 * (10**(interestRateDecimals - 2)))
        );
    }

    function testUpdateOriginationFeeWorks() public {
        uint256 interestRateDecimals = facilitator.INTEREST_RATE_DECIMALS();
        vm.startPrank(address(this));
        facilitator.updateOriginationFeeRate(
            uint32(2 * (10**(interestRateDecimals - 2)))
        );
        assertEq(
            facilitator.originationFeeRate(),
            uint32(2 * (10**(interestRateDecimals - 2)))
        );
    }

    function testUpdateRequiredImprovementRateRevertsIfNotCalledByManager()
        public
    {
        vm.startPrank(address(1));
        vm.expectRevert(""Ownable: caller is not the owner"");
        facilitator.updateRequiredImprovementRate(1);
    }

    function testUpdateRequiredImprovementRateRevertsIf0()
        public
    {
        vm.startPrank(address(this));
        vm.expectRevert(""NFTLoanFacilitator: 0 improvement rate"");
        facilitator.updateRequiredImprovementRate(0);
    }

    function testUpdateRequiredImprovementRateWorks() public {
        vm.startPrank(address(this));
        facilitator.updateRequiredImprovementRate(20 * facilitator.SCALAR());
        assertEq(
            facilitator.requiredImprovementRate(),
            20 * facilitator.SCALAR()
        );
    }

    function setUpLender(address lenderAddress) public {
        // create a lender address and give them some approved dai
        vm.startPrank(lenderAddress);
        dai.mint(loanAmount, lenderAddress);
        dai.approve(address(facilitator), 2**256 - 1); // approve for lending
        vm.stopPrank();
    }

    function setUpLoanWithLenderForTest(
        address borrowerAddress,
        address lenderAddress
    ) public returns (uint256 tokenId, uint256 loanId) {
        (tokenId, loanId) = setUpLoanForTest(borrowerAddress);
        setUpLender(lenderAddress);
        vm.startPrank(lenderAddress);
        facilitator.lend(
            loanId,
            interestRate,
            loanAmount,
            loanDuration,
            lender
        );
        vm.stopPrank();
    }

    // returns tokenId of NFT used as collateral for the loan and loanId to be used in other test methods
    function setUpLoanForTest(address borrowerAddress)
        public
        returns (uint256 tokenId, uint256 loanId)
    {
        vm.startPrank(borrowerAddress);
        tokenId = punks.mint();
        punks.approve(address(facilitator), tokenId);
        loanId = facilitator.createLoan(
            tokenId,
            address(punks),
            interestRate,
            loanAmount,
            address(dai),
            loanDuration,
            borrower
        );
        vm.stopPrank();
    }

    function increaseByMinPercent(uint256 old) public view returns (uint256) {
        return
            old +
            old * 
            facilitator.requiredImprovementRate() /
            facilitator.SCALAR();
    }

    function decreaseByMinPercent(uint256 old) public view returns (uint256) {
        return old - old * facilitator.requiredImprovementRate() / facilitator.SCALAR();
    }

    function calculateTake(uint256 amount) public view returns (uint256) {
        return
            (amount * facilitator.originationFeeRate()) /
            facilitator.SCALAR();
    }
}

contract NFTLendTicketTest is DSTest {
    Vm vm = Vm(HEVM_ADDRESS);
    NFTLoanFacilitator facilitator;
    BorrowTicket borrowTicket;
    LendTicket lendTicket;

    function setUp() public {
        NFTLoanFacilitatorFactory factory = new NFTLoanFacilitatorFactory();
        (borrowTicket, lendTicket, facilitator) = factory.newFacilitator(
            address(this)
        );
    }

    function testLoanFacilitatorTransferSuccessful() public {
        address holder = address(1);
        address receiver = address(2);
        uint256 loanId = 0;

        vm.startPrank(address(facilitator));

        lendTicket.mint(holder, loanId);
        assertEq(lendTicket.ownerOf(loanId), holder);

        lendTicket.loanFacilitatorTransfer(holder, receiver, 0);
        assertEq(lendTicket.ownerOf(loanId), receiver);
    }

    function testLoanFacilitatorTransferRevertsIfNotFacilitator() public {
        vm.startPrank(address(1));
        vm.expectRevert(""NFTLoanTicket: only loan facilitator"");
        lendTicket.loanFacilitatorTransfer(address(1), address(2), 0);
    }
}",9746
RealWorld_TA_106_NFTLoanFacilitatorFactory_RealWorld_20240812212401.log,106,NFTLoanFacilitatorFactory,49855,2103,51958,81.0,0.291335,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import {NFTLoanFacilitator} from 'contracts/NFTLoanFacilitator.sol';
import {BorrowTicket} from 'contracts/BorrowTicket.sol';
import {LendTicket} from 'contracts/LendTicket.sol';
import {BorrowTicketDescriptor} from 'contracts/descriptors/BorrowTicketDescriptor.sol';
import {LendTicketDescriptor} from 'contracts/descriptors/LendTicketDescriptor.sol';
import {LendTicketSVGHelper} from 'contracts/descriptors/LendTicketSVGHelper.sol';
import {BorrowTicketSVGHelper} from 'contracts/descriptors/BorrowTicketSVGHelper.sol';

interface Vm {
    function startPrank(address account) external;
    function stopPrank() external;
}

contract NFTLoanFacilitatorFactory {
    Vm vm = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    function newFacilitator(address manager)
        public 
        returns (
            BorrowTicket borrowTicket,
            LendTicket lendTicket,
            NFTLoanFacilitator facilitator
        )
    {
        BorrowTicketSVGHelper bs = new BorrowTicketSVGHelper();
        BorrowTicketDescriptor bd = new BorrowTicketDescriptor(bs);

        LendTicketSVGHelper ls = new LendTicketSVGHelper();
        LendTicketDescriptor ld = new LendTicketDescriptor(ls);

        facilitator = new NFTLoanFacilitator(manager);
        borrowTicket = new BorrowTicket(facilitator, bd);
        lendTicket = new LendTicket(facilitator, ld);
        vm.startPrank(manager);
        facilitator.setBorrowTicketContract(address(borrowTicket));
        facilitator.setLendTicketContract(address(lendTicket));
        vm.stopPrank();
    }
}",391
RealWorld_TA_106_BokkyPooBahsDateTimeLibrary_RealWorld_20240812214152.log,106,BokkyPooBahsDateTimeLibrary,312361,1466,313827,101.0,1.591125,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.01
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.
// ----------------------------------------------------------------------------

library BokkyPooBahsDateTimeLibrary {

    uint constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint constant SECONDS_PER_HOUR = 60 * 60;
    uint constant SECONDS_PER_MINUTE = 60;
    int constant OFFSET19700101 = 2440588;

    uint constant DOW_MON = 1;
    uint constant DOW_TUE = 2;
    uint constant DOW_WED = 3;
    uint constant DOW_THU = 4;
    uint constant DOW_FRI = 5;
    uint constant DOW_SAT = 6;
    uint constant DOW_SUN = 7;

    // ------------------------------------------------------------------------
    // Calculate the number of days from 1970/01/01 to year/month/day using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and subtracting the offset 2440588 so that 1970/01/01 is day 0
    //
    // days = day
    //      - 32075
    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4
    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12
    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4
    //      - offset
    // ------------------------------------------------------------------------
    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {
        require(year >= 1970);
        int _year = int(year);
        int _month = int(month);
        int _day = int(day);

        int __days = _day
          - 32075
          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4
          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12
          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4
          - OFFSET19700101;

        _days = uint(__days);
    }

    // ------------------------------------------------------------------------
    // Calculate year/month/day from the number of days since 1970/01/01 using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and adding the offset 2440588 so that 1970/01/01 is day 0
    //
    // int L = days + 68569 + offset
    // int N = 4 * L / 146097
    // L = L - (146097 * N + 3) / 4
    // year = 4000 * (L + 1) / 1461001
    // L = L - 1461 * year / 4 + 31
    // month = 80 * L / 2447
    // dd = L - 2447 * month / 80
    // L = month / 11
    // month = month + 2 - 12 * L
    // year = 100 * (N - 49) + year + L
    // ------------------------------------------------------------------------
    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {
        int __days = int(_days);

        int L = __days + 68569 + OFFSET19700101;
        int N = 4 * L / 146097;
        L = L - (146097 * N + 3) / 4;
        int _year = 4000 * (L + 1) / 1461001;
        L = L - 1461 * _year / 4 + 31;
        int _month = 80 * L / 2447;
        int _day = L - 2447 * _month / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;

        year = uint(_year);
        month = uint(_month);
        day = uint(_day);
    }

    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
    }
    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;
    }
    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
        secs = secs % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
        second = secs % SECONDS_PER_MINUTE;
    }

    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {
        if (year >= 1970 && month > 0 && month <= 12) {
            uint daysInMonth = _getDaysInMonth(year, month);
            if (day > 0 && day <= daysInMonth) {
                valid = true;
            }
        }
    }
    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {
        if (isValidDate(year, month, day)) {
            if (hour < 24 && minute < 60 && second < 60) {
                valid = true;
            }
        }
    }
    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {
        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
        leapYear = _isLeapYear(year);
    }
    function _isLeapYear(uint year) internal pure returns (bool leapYear) {
        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }
    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {
        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
    }
    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {
        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
    }
    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {
        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
        daysInMonth = _getDaysInMonth(year, month);
    }
    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            daysInMonth = 31;
        } else if (month != 2) {
            daysInMonth = 30;
        } else {
            daysInMonth = _isLeapYear(year) ? 29 : 28;
        }
    }
    // 1 = Monday, 7 = Sunday
    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {
        uint _days = timestamp / SECONDS_PER_DAY;
        dayOfWeek = (_days + 3) % 7 + 1;
    }

    function getYear(uint timestamp) internal pure returns (uint year) {
        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getMonth(uint timestamp) internal pure returns (uint month) {
        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getDay(uint timestamp) internal pure returns (uint day) {
        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getHour(uint timestamp) internal pure returns (uint hour) {
        uint secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
    }
    function getMinute(uint timestamp) internal pure returns (uint minute) {
        uint secs = timestamp % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
    }
    function getSecond(uint timestamp) internal pure returns (uint second) {
        second = timestamp % SECONDS_PER_MINUTE;
    }

    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year += _years;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        month += _months;
        year += (month - 1) / 12;
        month = (month - 1) % 12 + 1;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _days * SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
        require(newTimestamp >= timestamp);
    }
    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp >= timestamp);
    }
    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _seconds;
        require(newTimestamp >= timestamp);
    }

    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year -= _years;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint yearMonth = year * 12 + (month - 1) - _months;
        year = yearMonth / 12;
        month = yearMonth % 12 + 1;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _days * SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
        require(newTimestamp <= timestamp);
    }
    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp <= timestamp);
    }
    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _seconds;
        require(newTimestamp <= timestamp);
    }

    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {
        require(fromTimestamp <= toTimestamp);
        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _years = toYear - fromYear;
    }
    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {
        require(fromTimestamp <= toTimestamp);
        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
    }
    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {
        require(fromTimestamp <= toTimestamp);
        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
    }
    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {
        require(fromTimestamp <= toTimestamp);
        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
    }
    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {
        require(fromTimestamp <= toTimestamp);
        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
    }
    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {
        require(fromTimestamp <= toTimestamp);
        _seconds = toTimestamp - fromTimestamp;
    }
}",3464
RealWorld_TA_106_NFTLoanTicket_RealWorld_20240812211223.log,106,NFTLoanTicket,49611,1827,51438,90.0,0.284595,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {ERC721} from ""@rari-capital/solmate/src/tokens/ERC721.sol"";

import {NFTLoanFacilitator} from './NFTLoanFacilitator.sol';
import {NFTLoansTicketDescriptor} from './descriptors/NFTLoansTicketDescriptor.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';

contract NFTLoanTicket is ERC721, IERC721Mintable {
    NFTLoanFacilitator public immutable nftLoanFacilitator;
    NFTLoansTicketDescriptor public immutable descriptor;

    modifier loanFacilitatorOnly() { 
        require(msg.sender == address(nftLoanFacilitator), ""NFTLoanTicket: only loan facilitator"");
        _; 
    }

    /// @dev Sets the values for {name} and {symbol} and {nftLoanFacilitator} and {descriptor}.
    constructor(
        string memory name, 
        string memory symbol, 
        NFTLoanFacilitator _nftLoanFacilitator, 
        NFTLoansTicketDescriptor _descriptor
    ) 
        ERC721(name, symbol) 
    {
        nftLoanFacilitator = _nftLoanFacilitator;
        descriptor = _descriptor;
    }

    /// See {IERC721Mintable-mint}.
    function mint(address to, uint256 tokenId) external override loanFacilitatorOnly {
        _mint(to, tokenId);
    }

    /// @notice returns a base64 encoded data uri containing the token metadata in JSON format
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        return descriptor.uri(nftLoanFacilitator, tokenId);
    }
}",385
RealWorld_TA_106_Vm_RealWorld_20240812212524.log,106,Vm,90440,1556,91996,79.0,0.48332,"// SPDX-License-Identifier: Apache 2.0 
// https://github.com/brockelmore/forge-std/blob/master/LICENSE-APACHE
pragma solidity >=0.6.0;
pragma experimental ABIEncoderV2;

interface Vm {
    // Set block.timestamp (newTimestamp)
    function warp(uint256) external;
    // Set block.height (newHeight)
    function roll(uint256) external;
    // Set block.basefee (newBasefee)
    function fee(uint256) external;
    // Loads a storage slot from an address (who, slot)
    function load(address,bytes32) external returns (bytes32);
    // Stores a value to an address' storage slot, (who, slot, value)
    function store(address,bytes32,bytes32) external;
    // Signs data, (privateKey, digest) => (v, r, s)
    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);
    // Gets address for a given private key, (privateKey) => (address)
    function addr(uint256) external returns (address);
    // Performs a foreign function call via terminal, (stringInputs) => (result)
    function ffi(string[] calldata) external returns (bytes memory);
    // Sets the *next* call's msg.sender to be the input address
    function prank(address) external;
    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
    function startPrank(address) external;
    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
    function prank(address,address) external;
    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, 
    // and the tx.origin to be the second input
    function startPrank(address,address) external;
    // Resets subsequent calls' msg.sender to be `address(this)`
    function stopPrank() external;
    // Sets an address' balance, (who, newBalance)
    function deal(address, uint256) external;
    // Sets an address' code, (who, newCode)
    function etch(address, bytes calldata) external;
    // Expects an error on next call
    function expectRevert(bytes calldata) external;
    function expectRevert(bytes4) external;
    function expectRevert() external;
    // Record all storage reads and writes
    function record() external;
    // Gets all accessed reads and write slot from a recording session, for a given address
    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);
    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    // Call this function, then emit an event, then call a function. Internally after the call, we check if
    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
    function expectEmit(bool,bool,bool,bool) external;
    // Mocks a call to an address, returning specified data.
    // Calldata can either be strict or a partial match, e.g. if you only
    // pass a Solidity selector to the expected calldata, then the entire Solidity
    // function will be mocked.
    function mockCall(address,bytes calldata,bytes calldata) external;
    // Clears all mocked calls
    function clearMockedCalls() external;
    // Expect a call to an address with the specified calldata.
    // Calldata can either be strict or a partial match
    function expectCall(address,bytes calldata) external;
    // Gets the code from an artifact file. Takes in the relative path to the json file
    function getCode(string calldata) external returns (bytes memory);
    // Labels an address in call traces
    function label(address, string calldata) external;
    // If the condition is false, discard this run's fuzz inputs and generate new ones
    function assume(bool) external;
}",867
RealWorld_TA_106_ITicketTypeSpecificSVGHelper_RealWorld_20240812214832.log,106,ITicketTypeSpecificSVGHelper,38329,1373,39702,79.0,0.219105,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface ITicketTypeSpecificSVGHelper {
    /**
     * @notice returns a string of styles for use within an SVG
     * @param collateralAsset A string of the collateral asset address
     * @param loanAsset A string of the loan asset address
     */
    function backgroundColorsStyles(
        string memory collateralAsset,
        string memory loanAsset
        ) 
        external pure 
        returns (string memory);

    /**
     * @dev All the below methods return ticket-type-specific values
     * used in building the ticket svg image. See NFTLoanTicketSVG for usage.
     */

    function ticketIdXCoordinate() external pure returns (string memory);

    function backgroundTitleRectsXTranslate() external pure returns (string memory);

    function titlesPositionClass() external pure returns (string memory);

    function titlesXTranslate() external pure returns (string memory);

    function backgroundValueRectsXTranslate() external pure returns (string memory);

    function alignmentClass() external pure returns (string memory);

    function valuesXTranslate() external pure returns (string memory);
}",237
RealWorld_TA_106_PopulateSVGParams_RealWorld_20240812214011.log,106,PopulateSVGParams,111589,2538,114127,98.0,0.608705,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/Strings.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

import './BokkyPooBahsDateTimeLibrary.sol';
import './UintStrings.sol';
import '../../NFTLoanFacilitator.sol';
import '../../interfaces/IERC20Metadata.sol';
import './HexStrings.sol';
import './NFTLoanTicketSVG.sol';


library PopulateSVGParams{
    /**
     * @notice Populates and returns the passed `svgParams` with loan info retrieved from
     * `nftLoanFacilitator` for `id`, the loan id
     * @param svgParams The svg params to populate, which already has `nftType` populated from NFTLoansTicketDescriptor
     * @param nftLoanFacilitator The loan facilitator contract to get loan info from for loan `id`
     * @param id The id of the loan
     * @return `svgParams`, with all values now populated
     */
    function populate(NFTLoanTicketSVG.SVGParams memory svgParams, NFTLoanFacilitator nftLoanFacilitator, uint256 id)
        internal
        view
        returns (NFTLoanTicketSVG.SVGParams memory)
    {
        (bool closed, uint256 perAnumInterestRate,
        uint256 durationSeconds, uint256 lastAccumulatedTimestamp,
        address collateralAddress, address loanAsset, ,
        uint256 loanAmount, uint256 collateralID) = nftLoanFacilitator.loanInfo(id);

        svgParams.id = Strings.toString(id);
        svgParams.status = loanStatus(lastAccumulatedTimestamp, durationSeconds, closed);
        svgParams.interestRate = interestRateString(nftLoanFacilitator, perAnumInterestRate); 
        svgParams.loanAssetContract = HexStrings.toHexString(uint160(loanAsset), 20);
        svgParams.loanAssetSymbol = loanAssetSymbol(loanAsset);
        svgParams.collateralContract = HexStrings.toHexString(uint160(collateralAddress), 20);
        svgParams.collateralContractPartial = HexStrings.partialHexString(uint160(collateralAddress), 10, 40);
        svgParams.collateralAssetSymbol = collateralAssetSymbol(collateralAddress);
        svgParams.collateralId = Strings.toString(collateralID);
        svgParams.loanAmount = loanAmountString(loanAmount, loanAsset);
        svgParams.interestAccrued = accruedInterest(nftLoanFacilitator, id, loanAsset);
        svgParams.durationDays = Strings.toString(durationSeconds / (24 * 60 * 60));
        svgParams.endDateTime = lastAccumulatedTimestamp == 0 ? ""n/a"" 
        : endDateTime(lastAccumulatedTimestamp + durationSeconds);
        
        return svgParams;
    }

    function interestRateString(NFTLoanFacilitator nftLoanFacilitator, uint256 perAnumInterestRate) 
        private 
        view 
        returns (string memory)
    {
        return UintStrings.decimalString(
            perAnumInterestRate,
            nftLoanFacilitator.INTEREST_RATE_DECIMALS() - 2,
            true
            );
    }

    function loanAmountString(uint256 amount, address asset) private view returns (string memory) {
        return UintStrings.decimalString(amount, IERC20Metadata(asset).decimals(), false);
    }

    function loanAssetSymbol(address asset) private view returns (string memory) {
        return IERC20Metadata(asset).symbol();
    }

    function collateralAssetSymbol(address asset) private view returns (string memory) {
        return ERC721(asset).symbol();
    }

    function accruedInterest(NFTLoanFacilitator nftLoanFacilitator, uint256 loanId, address loanAsset) 
        private 
        view 
        returns (string memory)
    {
        return UintStrings.decimalString(
            nftLoanFacilitator.interestOwed(loanId),
            IERC20Metadata(loanAsset).decimals(),
            false);
    }

    function loanStatus(uint256 lastAccumulatedTimestamp, uint256 durationSeconds, bool closed) 
        view 
        private 
        returns (string memory)
    {
        if (lastAccumulatedTimestamp == 0) return ""awaiting lender"";

        if (closed) return ""closed"";

        if (block.timestamp > (lastAccumulatedTimestamp + durationSeconds)) return ""past due"";

        return ""accruing interest"";
    }

    /** 
     * @param endDateSeconds The unix seconds timestamp of the loan end date
     * @return a string representation of the UTC end date and time of the loan,
     * in format YYYY-MM-DD HH:MM:SS
     */
    function endDateTime(uint256 endDateSeconds) private pure returns (string memory) {
        (uint year, uint month, 
        uint day, uint hour, 
        uint minute, uint second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(endDateSeconds);
        return string.concat(
                Strings.toString(year),
                '-',
                Strings.toString(month),
                '-',
                Strings.toString(day),
                ' ',
                Strings.toString(hour),
                ':',
                Strings.toString(minute),
                ':',
                Strings.toString(second),
                ' UTC'
        );
    } 
}",1117
RealWorld_TA_106_IERC20Metadata_RealWorld_20240812214954.log,106,IERC20Metadata,22859,1191,24050,88.0,0.138115,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.12;

interface IERC20Metadata {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}",56
RealWorld_TA_106_test_RealWorld_20240812212645.log,106,test,314560,1543,316103,99.0,1.60366,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log                    (string);
    event logs                   (bytes);

    event log_address            (address);
    event log_bytes32            (bytes32);
    event log_int                (int);
    event log_uint               (uint);
    event log_bytes              (bytes);
    event log_string             (string);

    event log_named_address      (string key, address val);
    event log_named_bytes32      (string key, bytes32 val);
    event log_named_decimal_int  (string key, int val, uint decimals);
    event log_named_decimal_uint (string key, uint val, uint decimals);
    event log_named_int          (string key, int val);
    event log_named_uint         (string key, uint val);
    event log_named_bytes        (string key, bytes val);
    event log_named_string       (string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));

    modifier mayRevert() { _; }
    modifier testopts(string memory) { _; }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint startGas = gasleft();
        _;
        uint endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }
    function assertEq(address a, address b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }
    function assertEq(bytes32 a, bytes32 b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }
    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
        assertEq(a, b, err);
    }

    function assertEq(int a, int b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }
    function assertEq(int a, int b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq(uint a, uint b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }
    function assertEq(uint a, uint b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEqDecimal(int a, int b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint a, uint b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGt(uint a, uint b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGt(int a, int b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGt(int a, int b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGtDecimal(int a, int b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint a, uint b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGe(uint a, uint b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGe(int a, int b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGe(int a, int b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGeDecimal(int a, int b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint a, uint b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLt(uint a, uint b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLt(int a, int b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLt(int a, int b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLtDecimal(int a, int b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint a, uint b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLe(uint a, uint b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLe(int a, int b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLe(int a, int b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLeDecimal(int a, int b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }
    function assertEq(string memory a, string memory b, string memory err) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
        ok = true;
        if (a.length == b.length) {
            for (uint i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }
    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }
    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3539
RealWorld_TA_106_NFTLoanFacilitator_RealWorld_20240812211355.log,106,NFTLoanFacilitator,294708,5340,300048,168.0,1.58034,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    // ==== constants ====

    /** 
     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     
     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%
     */
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    /// See {INFTLoanFacilitator-SCALAR}.
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    // ==== state variables ====

    /// See {INFTLoanFacilitator-originationFeeRate}.
    /// @dev starts at 1%
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    /// See {INFTLoanFacilitator-requiredImprovementRate}.
    /// @dev starts at 10%
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    /// See {INFTLoanFacilitator-lendTicketContract}.
    address public override lendTicketContract;

    /// See {INFTLoanFacilitator-borrowTicketContract}.
    address public override borrowTicketContract;

    /// See {INFTLoanFacilitator-loanInfo}.
    mapping(uint256 => Loan) public loanInfo;

    /// @dev tracks loan count
    uint256 private _nonce = 1;

    
    // ==== modifiers ====

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    // ==== constructor ====

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    // ==== state changing external functions ====

    /// See {INFTLoanFacilitator-createLoan}.
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    /// See {INFTLoanFacilitator-closeLoan}.
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-lend}.
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    /// See {INFTLoanFacilitator-repayAndCloseLoan}.
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-seizeCollateral}.
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    // === owner state changing ===

    /**
     * @notice Sets lendTicketContract to _contract
     * @dev cannot be set if lendTicketContract is already set
     */
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    /**
     * @notice Sets borrowTicketContract to _contract
     * @dev cannot be set if borrowTicketContract is already set
     */
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    /**
     * @notice Updates originationFeeRate the faciliator keeps of each loan amount
     * @dev Cannot be set higher than 5%
     */
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    /**
     * @notice updates the percent improvement required of at least one loan term when buying out lender 
     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount
     * must be 10% higher or interest rate must be 10% lower. 
     * @dev Cannot be 0.
     */
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    // ==== external view ====

    /// See {INFTLoanFacilitator-loanInfoStruct}.
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    /// See {INFTLoanFacilitator-totalOwed}.
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-interestOwed}.
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-loanEndSeconds}.
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    // === private ===

    /// @dev Returns the total interest owed on loan
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 // SCALAR * 1e18
            + accumulatedInterest;
    }
}",3357
RealWorld_TA_107_EtherRocks_RealWorld_20240814214810.log,107,EtherRocks,71433,6437,77870,173.0,0.485905,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8;

contract EtherRock {
    struct Rock {
        address owner;
        bool currentlyForSale;
        uint256 price;
        uint256 timesSold;
    }

    mapping(uint256 => Rock) public rocks;

    mapping(address => uint256[]) public rockOwners;

    uint256 public latestNewRockForSale;

    address owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() {
        rocks[0].currentlyForSale = true;
    }

    function getRockInfo(uint256 rockNumber)
        external
        view
        returns (
            address,
            bool,
            uint256,
            uint256
        )
    {
        return (
            rocks[rockNumber].owner,
            rocks[rockNumber].currentlyForSale,
            rocks[rockNumber].price,
            rocks[rockNumber].timesSold
        );
    }

    function rockOwningHistory(address _address)
        external
        view
        returns (uint256[] memory)
    {
        return rockOwners[_address];
    }

    function buyRock(uint256 rockNumber) external payable {
        require(rocks[rockNumber].currentlyForSale == true, ""Not for sale"");
        require(msg.value == rocks[rockNumber].price);
        rocks[rockNumber].currentlyForSale = false;
        rocks[rockNumber].timesSold++;
        if (rockNumber != latestNewRockForSale) {
            payable(rocks[rockNumber].owner).transfer(rocks[rockNumber].price);
        }
        rocks[rockNumber].owner = msg.sender;
        rockOwners[msg.sender].push(rockNumber);
        if (rockNumber == latestNewRockForSale) {
            if (rockNumber != 99) {
                latestNewRockForSale++;
                rocks[latestNewRockForSale].price = 0;
                rocks[latestNewRockForSale].currentlyForSale = true;
            }
        }
    }

    function sellRock(uint256 rockNumber, uint256 price) external {
        require(msg.sender == rocks[rockNumber].owner);
        require(price > 0);
        rocks[rockNumber].price = price;
        rocks[rockNumber].currentlyForSale = true;
    }

    function dontSellRock(uint256 rockNumber) external {
        require(msg.sender == rocks[rockNumber].owner);
        rocks[rockNumber].currentlyForSale = false;
    }

    function giftRock(uint256 rockNumber, address receiver) external {
        require(msg.sender == rocks[rockNumber].owner);
        rocks[rockNumber].owner = receiver;
        rockOwners[receiver].push(rockNumber);
    }

    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}",585
RealWorld_TA_107_yVault_RealWorld_20240814222301.log,107,yVault,153270,4311,157581,148.0,0.85257,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/IYVault.sol"";

/// @title JPEG'd yVault
/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).
/// Non whitelisted contracts can't deposit/withdraw.
/// Owner is DAO
contract YVault is ERC20, Ownable {
    using SafeERC20 for ERC20;
    using Address for address;

    event Deposit(address indexed depositor, uint256 wantAmount);
    event Withdrawal(address indexed withdrawer, uint256 wantAmount);

    struct Rate {
        uint128 numerator;
        uint128 denominator;
    }

    ERC20 public immutable token;
    IController public controller;
    
    address public farm;
    
    Rate internal availableTokensRate;

    mapping(address => bool) public whitelistedContracts;

    /// @param _token The token managed by this vault
    /// @param _controller The JPEG'd strategies controller
    constructor(
        address _token,
        address _controller,
        Rate memory _availableTokensRate
    )
        ERC20(
            string(
                abi.encodePacked(""JPEG\xE2\x80\x99d "", ERC20(_token).name())
            ),
            string(abi.encodePacked(""JPEGD"", ERC20(_token).symbol()))
        )
    {
        setController(_controller);
        setAvailableTokensRate(_availableTokensRate);
        token = ERC20(_token);
    }

    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.
    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.
    /// The {isContract} function returns false when `_account` is a contract executing constructor code.
    /// This may lead to some contracts being able to bypass this check.
    /// @param _account Address to check
    modifier noContract(address _account) {
        require(
            !_account.isContract() || whitelistedContracts[_account],
            ""Contracts not allowed""
        );
        _;
    }

    /// @inheritdoc ERC20
    function decimals() public view virtual override returns (uint8) {
        return token.decimals();
    }

    /// @return The total amount of tokens managed by this vault and the underlying strategy
    function balance() public view returns (uint256) {
        return
            token.balanceOf(address(this)) +
            controller.balanceOf(address(token));
    }

    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}
    function balanceOfJPEG() external view returns (uint256) {
        return controller.balanceOfJPEG(address(token));
    }

    /// @notice Allows the owner to whitelist/blacklist contracts
    /// @param _contract The contract address to whitelist/blacklist
    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`
    function setContractWhitelisted(address _contract, bool _isWhitelisted)
        external
        onlyOwner
    {
        whitelistedContracts[_contract] = _isWhitelisted;
    }

    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow
    /// @param _rate The new rate
    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {
        require(
            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,
            ""INVALID_RATE""
        );
        availableTokensRate = _rate;
    }

    /// @notice ALlows the owner to set this vault's controller
    /// @param _controller The new controller
    function setController(address _controller) public onlyOwner {
        require(_controller != address(0), ""INVALID_CONTROLLER"");
        controller = IController(_controller);
    }

    /// @notice Allows the owner to set the yVault LP farm
    /// @param _farm The new farm
    function setFarmingPool(address _farm) public onlyOwner {
        require(_farm != address(0), ""INVALID_FARMING_POOL"");
        farm = _farm;
    }

    /// @return How much the vault allows to be borrowed by the underlying strategy.
    /// Sets minimum required on-hand to keep small withdrawals cheap
    function available() public view returns (uint256) {
        return
            (token.balanceOf(address(this)) * availableTokensRate.numerator) /
            availableTokensRate.denominator;
    }

    /// @notice Deposits `token` into the underlying strategy
    function earn() external {
        uint256 _bal = available();
        token.safeTransfer(address(controller), _bal);
        controller.earn(address(token), _bal);
    }

    /// @notice Allows users to deposit their entire `token` balance
    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    /// @notice Allows users to deposit `token`. Contracts can't call this function
    /// @param _amount The amount to deposit
    function deposit(uint256 _amount) public noContract(msg.sender) {
        require(_amount > 0, ""INVALID_AMOUNT"");
        uint256 balanceBefore = balance();
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 supply = totalSupply();
        uint256 shares;
        if (supply == 0) {
            shares = _amount;
        } else {
            //balanceBefore can't be 0 if totalSupply is > 0
            shares = (_amount * supply) / balanceBefore;
        }
        _mint(msg.sender, shares);

        emit Deposit(msg.sender, _amount);
    }

    /// @notice Allows users to withdraw all their deposited balance
    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    /// @notice Allows users to withdraw tokens. Contracts can't call this function
    /// @param _shares The amount of shares to burn
    function withdraw(uint256 _shares) public noContract(msg.sender) {
        require(_shares > 0, ""INVALID_AMOUNT"");

        uint256 supply = totalSupply();
        require(supply > 0, ""NO_TOKENS_DEPOSITED"");

        uint256 backingTokens = (balance() * _shares) / supply;
        _burn(msg.sender, _shares);

        // Check balance
        uint256 vaultBalance = token.balanceOf(address(this));
        if (vaultBalance < backingTokens) {
            uint256 toWithdraw = backingTokens - vaultBalance;
            controller.withdraw(address(token), toWithdraw);
        }

        token.safeTransfer(msg.sender, backingTokens);
        emit Withdrawal(msg.sender, backingTokens);
    }

    /// @notice Allows anyone to withdraw JPEG to `farm` 
    function withdrawJPEG() external {
        require(farm != address(0), ""NO_FARM"");
        controller.withdrawJPEG(address(token), farm);
    }

    /// @return The underlying tokens per share
    function getPricePerFullShare() external view returns (uint256) {
        uint256 supply = totalSupply();
        if (supply == 0) return 0;
        return (balance() * 1e18) / supply;
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }
}",1617
RealWorld_TA_107_IUniswapV2Pair_RealWorld_20240814231542.log,107,IUniswapV2Pair,68788,1427,70215,125.0,0.37248,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IUniswapV2Pair {
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(
        address indexed sender,
        uint256 amount0,
        uint256 amount1,
        address indexed to
    );
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to)
        external
        returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}",601
RealWorld_TA_107_IUniswapV2Router_RealWorld_20240814225727.log,107,IUniswapV2Router,25360,1279,26639,112.0,0.15238,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint256,
        uint256,
        address[] calldata,
        address,
        uint256
    ) external;

    function getAmountsOut(uint256, address[] calldata)
        external
        returns (uint256[] memory);
}",88
RealWorld_TA_107_IEtherRocks_RealWorld_20240814231344.log,107,IEtherRocks,25910,1934,27844,116.0,0.16823,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8;

interface IEtherRocks {
    function getRockInfo(uint256 rockNumber)
        external
        view
        returns (
            address,
            bool,
            uint256,
            uint256
        );

    function giftRock(uint256 rockNumber, address receiver) external;

    function dontSellRock(uint256 rockNumber) external;
}",86
RealWorld_TA_107_JPEG_RealWorld_20240814223845.log,107,JPEG,33724,2135,35859,101.0,0.21132,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";

/// @title JPEG - Governance token
contract JPEG is ERC20Votes, AccessControl {

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    constructor(uint256 totalSupply)
        ERC20(""JPEG"", ""JPEG"")
        ERC20Permit(""JPEG"")
    {
        _mint(msg.sender, totalSupply);
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    function mint(address to, uint256 amount) external {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            ""JPEG: must have minter role to mint""
        );
        _mint(to, amount);
    }
}",185
RealWorld_TA_107_MockCurve_RealWorld_20240814220713.log,107,MockCurve,40510,4423,44933,146.0,0.29101,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/ICurve.sol"";

contract MockCurve is ICurve {
    IERC20 internal poolToken;
    IERC20[] internal tokens;

    constructor(IERC20 _poolToken, IERC20[] memory _tokens) {
        poolToken = _poolToken;
        tokens = _tokens;
    }

    function add_liquidity(uint256[4] memory amounts, uint256 minOut) external override {
        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i];
            if (amount > 0)
                tokens[i].transferFrom(msg.sender, address(this), amount);
        }

        uint256 balance = poolToken.balanceOf(address(this));
        require(balance >= minOut, ""INSUFFICIENT_TOKENS"");
        poolToken.transfer(msg.sender, balance);
    }

    function balances(uint256 index) external view override returns (uint256) {
        return tokens[index].balanceOf(address(this));
    }
}",240
RealWorld_TA_107_IStableCoin_RealWorld_20240814225309.log,107,IStableCoin,25952,2257,28209,131.0,0.1749,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface IStableCoin is IERC20Upgradeable {
    function mint(address _to, uint256 _value) external;

    function burn(uint256 _value) external;

    function burnFrom(address _from, uint256 _value) external;
}",94
RealWorld_TA_107_TestERC721_RealWorld_20240814215105.log,107,TestERC721,28943,2207,31150,114.0,0.188855,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

// This contract is only for testing
contract TestERC721 is ERC721(""TEST"", ""TEST"") {

    function mint(address to, uint256 index) external {
        _mint(to, index);
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId))
            return address(0);

        return super.ownerOf(tokenId);
    }
}",119
RealWorld_TA_107_IFungibleAssetVaultForDAO_RealWorld_20240814225921.log,107,IFungibleAssetVaultForDAO,24316,1510,25826,96.0,0.15178,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IFungibleAssetVaultForDAO {
    function deposit(uint256 amount) external payable;

    function borrow(uint256 amount) external;

    function getCreditLimit(uint256 amount) external view returns (uint256);
}",65
RealWorld_TA_107_JPEGStaking_RealWorld_20240814222841.log,107,JPEGStaking,56403,2296,58699,128.0,0.327935,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

/// @title JPEG staking contract
/// @notice Users can stake JPEG and get sJPEG back
/// @dev Every sJPEG token is backed 1:1 by JPEG
contract JPEGStaking is ERC20VotesUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    event Stake(address indexed user, uint256 amount);
    event Unstake(address indexed user, uint256 amount);

    /// @notice The stake token, JPEG
    IERC20Upgradeable public jpeg;

    /// @param _jpeg The stake token
    function initialize(IERC20Upgradeable _jpeg) external initializer {
        __ReentrancyGuard_init();
        __ERC20_init(""sJPEG"", ""sJPEG"");
        __ERC20Permit_init(""sJPEG"");
        jpeg = _jpeg;
    }

    /// @notice Allows user to stake `_amount` of JPEG
    /// @dev Emits a {Stake} event
    /// @param _amount The amount of JPEG to stake
    function stake(uint256 _amount) external {
        require(_amount > 0, ""invalid_amount"");

        jpeg.transferFrom(msg.sender, address(this), _amount);

        _mint(msg.sender, _amount);

        emit Stake(msg.sender, _amount);
    }

    /// @notice Allows users to unstake `_amount` of JPEG
    /// @dev Emits an {Unstake} event
    /// @param _amount The amount of JPEG to unstake
    function unstake(uint256 _amount) external nonReentrant {
        require(
            _amount > 0 && _amount <= balanceOf(msg.sender),
            ""invalid_amount""
        );

        _burn(msg.sender, _amount);

        jpeg.transfer(msg.sender, _amount);

        emit Unstake(msg.sender, _amount);
    }

    uint256[50] private __gap;
}",481
RealWorld_TA_107_IUniswapV2Factory_RealWorld_20240814230755.log,107,IUniswapV2Factory,32779,1413,34192,98.0,0.192155,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IUniswapV2Factory {
    event PairCreated(
        address indexed token0,
        address indexed token1,
        address pair,
        uint256
    );

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}",171
RealWorld_TA_107_FungibleAssetVaultForDAO_RealWorld_20240814221409.log,107,FungibleAssetVaultForDAO,175686,4156,179842,159.0,0.96155,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

import ""../interfaces/IAggregatorV3Interface.sol"";
import ""../interfaces/IStableCoin.sol"";
import ""../interfaces/IERC20Decimals.sol"";

/// @title Fungible asset vault (for DAO and ecosystem contracts)
/// @notice Allows the DAO and other whitelisted addresses to mint PUSD using fungible assets as collateral
/// @dev The contract only supports one asset, meaning that multiple instances
/// of this contract are going to be deployed if support for multiple assets is needed.
/// The credit limit rate of the supported asset is set at deploy time.
/// This contract doesn't support liquidations. In case of undercollateralization,
/// the DAO will promptly deposit more collateral.
/// The vault implements {AccessControlUpgradeable} and only allows whitelisted wallets
/// to deposit/borrow/withdraw/repay. The contract doesn't keep track of the individual
/// debt/deposited collateral of each whitelisted address, it instead uses global debt and deposited collateral.
/// This is intentional and it's done to allow the DAO to repay debt of ecosystem contracts ({StrategyPUSDConvex}, for example)
contract FungibleAssetVaultForDAO is
    AccessControlUpgradeable,
    ReentrancyGuardUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeERC20Upgradeable for IStableCoin;

    event Deposit(address indexed user, uint256 depositAmount);
    event Borrow(address indexed user, uint256 borrowAmount);
    event Repay(address indexed user, uint256 repayAmount);
    event Withdraw(address indexed user, uint256 withdrawAmount);

    struct Rate {
        uint128 numerator;
        uint128 denominator;
    }

    bytes32 public constant WHITELISTED_ROLE = keccak256(""WHITELISTED_ROLE"");

    /// @dev This contract can handle unwrapped ETH if `address(0)` is passed as the `_collateralAsset`
    /// parameter in the {initialize} function
    address internal constant ETH = address(0);

    address public collateralAsset;
    IStableCoin public stablecoin;
    /// @dev We store the value of a single unit of the collateral asset `10 ** decimals`
    /// instead of fetching it everytime to save gas
    uint256 private _collateralUnit;

    IAggregatorV3Interface public oracle;

    Rate public creditLimitRate;

    /// @notice Amount of deposited collateral
    uint256 public collateralAmount;
    /// @notice Outstanding debt
    uint256 public debtAmount;

    /// @param _collateralAsset The address of the collateral asset - `address(0)` for ETH
    /// @param _stablecoin PUSD address
    /// @param _oracle Chainlink price feed for `_collateralAsset`/USD
    /// @param _creditLimitRate Max outstanding debt to collateral ratio
    function initialize(
        address _collateralAsset,
        IStableCoin _stablecoin,
        IAggregatorV3Interface _oracle,
        Rate memory _creditLimitRate
    ) external initializer {
        __AccessControl_init();
        __ReentrancyGuard_init();

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        setCreditLimitRate(_creditLimitRate);

        collateralAsset = _collateralAsset;
        stablecoin = _stablecoin;
        if (_collateralAsset == ETH) {
            _collateralUnit = 1 ether;
        } else {
            _collateralUnit = 10**IERC20Decimals(_collateralAsset).decimals();
        }

        oracle = _oracle;
    }

    /// @notice Allows members of the `DEFAULT_ADMIN_ROLE` to change the max outstanding debt to collateral ratio
    /// @param _creditLimitRate The new ratio
    function setCreditLimitRate(Rate memory _creditLimitRate) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(
            _creditLimitRate.denominator > 0 &&
                //denominator can be equal to the numerator in some cases (stablecoins used as collateral)
                _creditLimitRate.denominator >= _creditLimitRate.numerator,
            ""invalid_rate""
        );
        creditLimitRate = _creditLimitRate;
    }

    /// @dev Returns the USD price of one unit of collateral asset, using 18 decimals precision
    /// @return The USD price
    function _collateralPriceUsd() internal view returns (uint256) {
        int256 answer = oracle.latestAnswer();
        uint8 decimals = oracle.decimals();

        require(answer > 0, ""invalid_oracle_answer"");

        //check chainlink's precision and convert it to 18 decimals
        return
            decimals > 18
                ? uint256(answer) / 10**(decimals - 18)
                : uint256(answer) * 10**(18 - decimals);
    }

    /// @dev Returns the USD value of `amount` units of collateral, using 18 decimals precision
    /// @param amount The amount of collateral to calculate the value of
    /// @return The USD value
    function _getCollateralValue(uint256 amount)
        internal
        view
        returns (uint256)
    {
        return (amount * _collateralPriceUsd()) / _collateralUnit;
    }

    /// @notice Returns the max debt for `amount` of collateral
    /// @param amount The amount of collateral to calculate max debt for
    /// @return Max debt value for `amount`
    function getCreditLimit(uint256 amount) public view returns (uint256) {
        uint256 collateralValue = _getCollateralValue(amount);
        return
            (collateralValue * creditLimitRate.numerator) /
            creditLimitRate.denominator;
    }

    /// @notice Allows members of the `WHITELISTED_ROLE` to deposit `amount` of collateral
    /// @dev Emits a {Deposit} event
    /// @param amount The amount of collateral to deposit
    function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {
        require(amount > 0, ""invalid_amount"");

        if (collateralAsset == ETH) {
            require(msg.value == amount, ""invalid_msg_value"");
        } else {
            require(msg.value == 0, ""non_zero_eth_value"");
            IERC20Upgradeable(collateralAsset).safeTransferFrom(
                msg.sender,
                address(this),
                amount
            );
        }

        collateralAmount += amount;

        emit Deposit(msg.sender, amount);
    }

    /// @notice Allows members of the `WHITELISTED_ROLE` to borrow `amount` of PUSD against the deposited collateral
    /// @dev Emits a {Borrow} event
    /// @param amount The amount of PUSD to borrow
    function borrow(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {
        require(amount > 0, ""invalid_amount"");

        uint256 creditLimit = getCreditLimit(collateralAmount);
        uint256 newDebtAmount = debtAmount + amount;
        require(newDebtAmount <= creditLimit, ""insufficient_credit"");

        debtAmount = newDebtAmount;
        stablecoin.mint(msg.sender, amount);

        emit Borrow(msg.sender, amount);
    }

    /// @notice Allows members of the `WHITELISTED_ROLE` to repay `amount` of debt using PUSD
    /// @dev Emits a {Repay} event
    /// @param amount The amount of debt to repay
    function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {
        require(amount > 0, ""invalid_amount"");

        amount = amount > debtAmount ? debtAmount : amount;

        debtAmount -= amount;
        stablecoin.burnFrom(msg.sender, amount);

        emit Repay(msg.sender, amount);
    }

    /// @notice Allows members of the `WHITELISTED_ROLE` to withdraw `amount` of deposited collateral
    /// @dev Emits a {Withdraw} event
    /// @param amount The amount of collateral to withdraw
    function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {
        require(amount > 0 && amount <= collateralAmount, ""invalid_amount"");

        uint256 creditLimit = getCreditLimit(collateralAmount - amount);
        require(creditLimit >= debtAmount, ""insufficient_credit"");

        collateralAmount -= amount;

        if (collateralAsset == ETH) payable(msg.sender).transfer(amount);
        else
            IERC20Upgradeable(collateralAsset).safeTransfer(msg.sender, amount);

        emit Withdraw(msg.sender, amount);
    }

    uint256[50] private __gap;
}",1914
RealWorld_TA_107_MockAggregator_RealWorld_20240814220942.log,107,MockAggregator,70190,3039,73229,129.0,0.41173,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""../interfaces/IAggregatorV3Interface.sol"";

/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */
contract MockV3Aggregator is IAggregatorV3Interface {
  uint256 constant public version = 0;

  uint8 public override decimals;
  int256 public override latestAnswer;
  uint256 public latestTimestamp;
  uint256 public latestRound;

  mapping(uint256 => int256) public getAnswer;
  mapping(uint256 => uint256) public getTimestamp;
  mapping(uint256 => uint256) private getStartedAt;

  constructor(
    uint8 _decimals,
    int256 _initialAnswer
  ) {
    decimals = _decimals;
    updateAnswer(_initialAnswer);
  }

  function updateAnswer(
    int256 _answer
  ) public {
    latestAnswer = _answer;
    latestTimestamp = block.timestamp;
    latestRound++;
    getAnswer[latestRound] = _answer;
    getTimestamp[latestRound] = block.timestamp;
    getStartedAt[latestRound] = block.timestamp;
  }

  function updateRoundData(
    uint80 _roundId,
    int256 _answer,
    uint256 _timestamp,
    uint256 _startedAt
  ) public {
    latestRound = _roundId;
    latestAnswer = _answer;
    latestTimestamp = _timestamp;
    getAnswer[latestRound] = _answer;
    getTimestamp[latestRound] = _timestamp;
    getStartedAt[latestRound] = _startedAt;
  }

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    return (
      _roundId,
      getAnswer[_roundId],
      getStartedAt[_roundId],
      getTimestamp[_roundId],
      _roundId
    );
  }

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    return (
      uint80(latestRound),
      getAnswer[latestRound],
      getStartedAt[latestRound],
      getTimestamp[latestRound],
      uint80(latestRound)
    );
  }

  function description()
    external
    pure
    returns (string memory)
  {
    return ""v0.6/tests/MockV3Aggregator.sol"";
  }
}",600
RealWorld_TA_107_MockStrategy_RealWorld_20240814215301.log,107,MockStrategy,52951,4011,56962,144.0,0.344975,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/IController.sol"";
import ""../interfaces/IStrategy.sol"";

contract MockStrategy is IStrategy {
    address public override want;
    address public jpeg;
    address public baseRewardPool;

    constructor(
        address _want,
        address _jpeg,
        address _baseRewardPool
    ) {
        want = _want;
        jpeg = _jpeg;
        baseRewardPool = _baseRewardPool;
    }

    function deposit() external override {}

    function withdraw(address token) external override {
        IERC20(token).transfer(
            msg.sender,
            IERC20(token).balanceOf(address(this))
        );
    }

    function withdraw(uint256 amount) external override {
        address vault = IController(msg.sender).vaults(want);
        IERC20(want).transfer(vault, amount);
    }

    function withdrawAll() external override returns (uint256) {
        address vault = IController(msg.sender).vaults(want);
        uint256 balance = IERC20(want).balanceOf(address(this));
        IERC20(want).transfer(vault, balance);
        return balance;
    }

    function balanceOf() external view override returns (uint256) {
        return IERC20(want).balanceOf(address(this));
    }

    function balanceOfJPEG() public view override returns (uint256) {
        return IERC20(jpeg).balanceOf(address(this));
    }

    function withdrawJPEG(address to) external override {
        IERC20(jpeg).transfer(to, balanceOfJPEG());
    }

    function convexConfig()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (address(0), baseRewardPool, 0);
    }
}",398
RealWorld_TA_107_WETH_RealWorld_20240814220317.log,107,WETH,28072,2402,30474,114.0,0.1884,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/IWETH.sol"";

contract WETH is ERC20(""WETH"", ""WETH""), IWETH {
    function deposit() external payable override {
        _mint(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external override {
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
    }
}",109
RealWorld_TA_107_CryptoPunksHelper_RealWorld_20240814224512.log,107,CryptoPunksHelper,103566,2966,106532,122.0,0.57715,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";

import ""../escrow/NFTEscrow.sol"";
import ""../interfaces/ICryptoPunks.sol"";

 /// @title CryptoPunks NFTVault helper contract
 /// @notice Allows compatibility between CryptoPunks and {NFTVault}
 /// @dev CryptoPunks IERC721 compatibility.
 /// Meant to only be used by {NFTVault}.
 /// This contract is NOT an ERC721 wrapper for punks and is not meant to implement the ERC721 interface fully, 
 /// its only purpose is to serve as a proxy between {NFTVault} and CryptoPunks.
 /// The owner is {NFTVault}
contract CryptoPunksHelper is NFTEscrow, OwnableUpgradeable {

    /// @param punksAddress Address of the CryptoPunks contract
    function initialize(address punksAddress) external initializer {
        __NFTEscrow_init(punksAddress);
        __Ownable_init();
    }

    /// @notice Returns the owner of the punk at index `_idx`
    /// @dev If the owner of the punk is this contract we return the address of the {NFTVault} for compatibility
    /// @param _idx The punk index
    /// @return The owner of the punk if != `address(this)`, otherwise the the owner of this contract
    function ownerOf(uint256 _idx) external view returns (address) {
        address account = ICryptoPunks(nftAddress).punkIndexToAddress(_idx);

        return account == address(this) ? owner() : account;
    }

    /// @notice Function called by {NFTVault} to transfer punks. Can only be called by the owner
    /// @param _from The sender address
    /// @param _to The recipient address
    /// @param _idx The index of the punk to transfer
    function transferFrom(
        address _from,
        address _to,
        uint256 _idx
    ) external onlyOwner {
        _transferFrom(_from, _to, _idx);
    }

    /// @dev We aren't calling {onERC721Received} on the _to address because punks don't implement
    /// the {ERC721} interface, but we are including this function for compatibility with the {NFTVault} contract.
    /// Calling the {onERC721Received} function on the receiver contract could cause problems as we aren't sending an ERC721.
    /// @param _from The sender address
    /// @param _to The recipient address
    /// @param _idx The index of the punk to transfer
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _idx
    ) external onlyOwner {
        _transferFrom(_from, _to, _idx);
    }

    /// @dev Implementation of {transferFrom} and {safeTransferFrom}. We are using {NFTEscrow} for atomic transfers.
    /// See {NFTEscrow} for more info
    /// @param _from The sender address
    /// @param _to The recipient address
    /// @param _idx The index of the punk to transfer
    function _transferFrom(
        address _from,
        address _to,
        uint256 _idx
    ) internal {
        ICryptoPunks punks = ICryptoPunks(nftAddress);

        address account = punks.punkIndexToAddress(_idx);

        //if the owner is this address we don't need to go through {NFTEscrow}
        if (account != address(this)) {
            _executeTransfer(_from, _idx);
        }

        require(
            punks.punkIndexToAddress(_idx) == address(this), //this should never be false
            ""CryptoPunksHelper: not_deposited""
        );

        //If _to is the owner ({NFTVault}), we aren't sending the punk
        //since we'd have no way to get it back
        if (_to != owner()) punks.transferPunk(_to, _idx);
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }

    /// @dev The {transferPunk} function is used as the escrow's payload.
    /// @param _idx The index of the punk that's going to be transferred using {NFTEscrow}
    function _encodeFlashEscrowPayload(uint256 _idx)
        internal
        view
        override
        returns (bytes memory)
    {
        return
            abi.encodeWithSignature(
                ""transferPunk(address,uint256)"",
                address(this),
                _idx
            );
    }
}",1024
RealWorld_TA_107_NFTEscrow_RealWorld_20240814223637.log,107,NFTEscrow,117663,3423,121086,126.0,0.656775,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

//inspired by https://github.com/thousandetherhomepage/ketherhomepage/blob/master/contracts/KetherNFT.sol
/// @title FlashEscrow contract 
/// @notice This contract sends and receives non ERC721 NFTs
/// @dev Deployed for each NFT, its address is calculated by {NFTEscrow} prior to it being deployed to allow atomic non ERC721 transfers 
contract FlashEscrow {

    /// @dev The contract selfdestructs in the constructor, its only purpose is to perform one call to the `target` address using `payload` as the payload
    /// @param target The call recipient
    /// @param payload The payload to use for the call
    constructor(address target, bytes memory payload) {
        (bool success, ) = target.call(payload);
        require(success, ""FlashEscrow: call_failed"");

        selfdestruct(payable(target));
    }
}

/// @title Escrow contract for non ERC721 NFTs
/// @notice Handles atomic non ERC721 NFT transfers by using {FlashEscrow}
/// @dev NFTEscrow allows an atomic, 2 step mechanism to transfer non ERC721 NFTs without requiring prior reservation.
/// - Users send the NFT to a precomputed address (calculated using the owner's address as salt) that can be fetched by calling the `precompute` function
/// - The child contract can then call the `_executeTransfer` function to deploy an instance of the {FlashEscrow} contract, deployed at the address calculated in the previous step
/// This allows atomic transfers, as the address calculated by the `precompute` function is unique and changes depending by the `_owner` address and the NFT index (`_idx`).
/// This is an alternative to the classic ""reservation"" method, which requires users to call 3 functions in a specifc order (making the process non atomic)
abstract contract NFTEscrow is Initializable {
    /// @notice The address of the non ERC721 NFT supported by the child contract
    address public nftAddress;

    /// @dev Initializer function, see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable
    /// @param _nftAddress See `nftAddress`
    function __NFTEscrow_init(address _nftAddress) internal initializer {
        nftAddress = _nftAddress;
    }

    /// @dev Computes the bytecode of the {FlashEscrow} instance to deploy
    /// @param _idx The index of the NFT that's going to be sent to the {FlashEscrow} instance
    /// @return The bytecode of the {FlashEscrow} instance relative to the NFT at index `_idx`
    function _encodeFlashEscrow(uint256 _idx)
        internal
        view
        returns (bytes memory)
    {
        return
            abi.encodePacked(
                type(FlashEscrow).creationCode,
                abi.encode(nftAddress, _encodeFlashEscrowPayload(_idx))
            );
    }

    /// @dev Virtual function, should return the `payload` to use in {FlashEscrow}'s constructor
    /// @param _idx The index of the NFT that's going to be sent to the {FlashEscrow} instance
    function _encodeFlashEscrowPayload(uint256 _idx)
        internal
        view
        virtual
        returns (bytes memory);

    /// @dev Deploys a {FlashEscrow} instance relative to owner `_owner` and index `_idx`
    /// @param _owner The owner of the NFT at index `_idx`
    /// @param _idx The index of the NFT owned by `_owner` 
    function _executeTransfer(address _owner, uint256 _idx) internal {
        (bytes32 salt, ) = precompute(_owner, _idx);
        new FlashEscrow{salt: salt}(
            nftAddress,
            _encodeFlashEscrowPayload(_idx)
        );
    }

    /// @notice This function returns the address where user `_owner` should send the `_idx` NFT to
    /// @dev `precompute` computes the salt and the address relative to NFT at index `_idx` owned by `_owner`
    /// @param _owner The owner of the NFT at index `_idx`
    /// @param _idx The index of the NFT owner by `_owner`
    /// @return salt The salt that's going to be used to deploy the {FlashEscrow} instance
    /// @return predictedAddress The address where the {FlashEscrow} instance relative to `_owner` and `_idx` will be deployed to
    function precompute(address _owner, uint256 _idx)
        public
        view
        returns (bytes32 salt, address predictedAddress)
    {
        require(
            _owner != address(this) && _owner != address(0),
            ""NFTEscrow: invalid_owner""
        );

        salt = sha256(abi.encodePacked(_owner));

        bytes memory bytecode = _encodeFlashEscrow(_idx);

        //hash from which the contract address can be derived
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                salt,
                keccak256(bytecode)
            )
        );

        predictedAddress = address(uint160(uint256(hash)));
        return (salt, predictedAddress);
    }

    uint256[50] private __gap;
}",1200
RealWorld_TA_107_IWETH_RealWorld_20240814230100.log,107,IWETH,22280,1242,23522,102.0,0.13624,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint wad) external;
}",51
RealWorld_TA_107_ISwapRouter_RealWorld_20240814230625.log,107,ISwapRouter,29926,1188,31114,87.0,0.17339,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface ISwapRouter {
  function uniswapV3SwapCallback(
    int256 amount0Delta,
    int256 amount1Delta,
    bytes calldata data
  ) external;

  struct ExactInputParams {
    bytes path;
    address recipient;
    uint256 deadline;
    uint256 amountIn;
    uint256 amountOutMinimum;
  }

  function exactInput(ExactInputParams calldata params)
    external
    returns (uint256 amountOut);

  function quoteExactInput(bytes calldata path, uint256 amountIn)
    external
    returns (uint256 amountOut);
}",143
RealWorld_TA_107_CryptoPunks_RealWorld_20240814220005.log,107,CryptoPunks,237398,6742,244140,190.0,1.32183,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

contract CryptoPunks {
    // You can use this hash to verify the image file containing all the punks
    string public imageHash =
        ""ac39af4793119ee46bbff351d8cb6b5f23da60222126add4268e261199a2921b"";

    address owner;

    string public standard = ""CryptoPunks"";
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    uint256 public nextPunkIndexToAssign = 0;

    bool public allPunksAssigned = false;
    uint256 public punksRemainingToAssign = 0;

    //mapping (address => uint) public addressToPunkIndex;
    mapping(uint256 => address) public punkIndexToAddress;

    /* This creates an array with all balances */
    mapping(address => uint256) public balanceOf;

    struct Offer {
        bool isForSale;
        uint256 punkIndex;
        address seller;
        uint256 minValue; // in ether
        address onlySellTo; // specify to sell only to a specific person
    }

    struct Bid {
        bool hasBid;
        uint256 punkIndex;
        address bidder;
        uint256 value;
    }

    // A record of punks that are offered for sale at a specific minimum value, and perhaps to a specific person
    mapping(uint256 => Offer) public punksOfferedForSale;

    // A record of the highest punk bid
    mapping(uint256 => Bid) public punkBids;

    mapping(address => uint256) public pendingWithdrawals;

    event Assign(address indexed to, uint256 punkIndex);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event PunkTransfer(
        address indexed from,
        address indexed to,
        uint256 punkIndex
    );
    event PunkOffered(
        uint256 indexed punkIndex,
        uint256 minValue,
        address indexed toAddress
    );
    event PunkBidEntered(
        uint256 indexed punkIndex,
        uint256 value,
        address indexed fromAddress
    );
    event PunkBidWithdrawn(
        uint256 indexed punkIndex,
        uint256 value,
        address indexed fromAddress
    );
    event PunkBought(
        uint256 indexed punkIndex,
        uint256 value,
        address indexed fromAddress,
        address indexed toAddress
    );
    event PunkNoLongerForSale(uint256 indexed punkIndex);

    /* Initializes contract with initial supply tokens to the creator of the contract */
    constructor() {
        //balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens
        owner = msg.sender;
        totalSupply = 10000; // Update total supply
        punksRemainingToAssign = totalSupply;
        name = ""CRYPTOPUNKS""; // Set the name for display purposes
        symbol = ""\xcf\xbe""; // Set the symbol for display purposes
        decimals = 0; // Amount of decimals for display purposes
    }

    function setInitialOwner(address to, uint256 punkIndex) public {
        if (msg.sender != owner) revert();
        //if (allPunksAssigned) revert();
        if (punkIndex >= 10000) revert();
        if (punkIndexToAddress[punkIndex] != to) {
            if (punkIndexToAddress[punkIndex] != address(0)) {
                balanceOf[punkIndexToAddress[punkIndex]]--;
            } else {
                punksRemainingToAssign--;
            }
            punkIndexToAddress[punkIndex] = to;
            balanceOf[to]++;
            emit Assign(to, punkIndex);
        }
    }

    function setInitialOwners(
        address[] memory addresses,
        uint256[] memory indices
    ) external {
        if (msg.sender != owner) revert();
        uint256 n = addresses.length;
        for (uint256 i = 0; i < n; i++) {
            setInitialOwner(addresses[i], indices[i]);
        }
    }

    function allInitialOwnersAssigned() external {
        if (msg.sender != owner) revert();
        allPunksAssigned = true;
    }

    function getPunk(uint256 punkIndex) external {
        //if (!allPunksAssigned) revert();
        if (punksRemainingToAssign == 0) revert();
        if (punkIndexToAddress[punkIndex] != address(0)) revert();
        if (punkIndex >= 10000) revert();
        punkIndexToAddress[punkIndex] = msg.sender;
        balanceOf[msg.sender]++;
        punksRemainingToAssign--;
        emit Assign(msg.sender, punkIndex);
    }

    // Transfer ownership of a punk to another user without requiring payment
    function transferPunk(address to, uint256 punkIndex) external {
        //if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] != msg.sender) revert();
        if (punkIndex >= 10000) revert();
        if (punksOfferedForSale[punkIndex].isForSale) {
            punkNoLongerForSale(punkIndex);
        }
        punkIndexToAddress[punkIndex] = to;
        balanceOf[msg.sender]--;
        balanceOf[to]++;
        emit Transfer(msg.sender, to, 1);
        emit PunkTransfer(msg.sender, to, punkIndex);
        // Check for the case where there is a bid from the new owner and refund it.
        // Any other bid can stay in place.
        Bid memory bid = punkBids[punkIndex];
        if (bid.bidder == to) {
            // Kill bid and refund value
            pendingWithdrawals[to] += bid.value;
            punkBids[punkIndex] = Bid(false, punkIndex, address(0), 0);
        }
    }

    function punkNoLongerForSale(uint256 punkIndex) public {
        //if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] != msg.sender) revert();
        if (punkIndex >= 10000) revert();
        punksOfferedForSale[punkIndex] = Offer(
            false,
            punkIndex,
            msg.sender,
            0,
            address(0)
        );
        emit PunkNoLongerForSale(punkIndex);
    }

    function offerPunkForSale(uint256 punkIndex, uint256 minSalePriceInWei)
        external
    {
        //if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] != msg.sender) revert();
        if (punkIndex >= 10000) revert();
        punksOfferedForSale[punkIndex] = Offer(
            true,
            punkIndex,
            msg.sender,
            minSalePriceInWei,
            address(0)
        );
        emit PunkOffered(punkIndex, minSalePriceInWei, address(0));
    }

    function offerPunkForSaleToAddress(
        uint256 punkIndex,
        uint256 minSalePriceInWei,
        address toAddress
    ) external {
        //if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] != msg.sender) revert();
        if (punkIndex >= 10000) revert();
        punksOfferedForSale[punkIndex] = Offer(
            true,
            punkIndex,
            msg.sender,
            minSalePriceInWei,
            toAddress
        );
        emit PunkOffered(punkIndex, minSalePriceInWei, toAddress);
    }

    function buyPunk(uint256 punkIndex) external payable {
        //if (!allPunksAssigned) revert();
        Offer memory offer = punksOfferedForSale[punkIndex];
        if (punkIndex >= 10000) revert();
        if (!offer.isForSale) revert(); // punk not actually for sale
        if (offer.onlySellTo != address(0) && offer.onlySellTo != msg.sender)
            revert(); // punk not supposed to be sold to this user
        if (msg.value < offer.minValue) revert(); // Didn't send enough ETH
        if (offer.seller != punkIndexToAddress[punkIndex]) revert(); // Seller no longer owner of punk

        address seller = offer.seller;

        punkIndexToAddress[punkIndex] = msg.sender;
        balanceOf[seller]--;
        balanceOf[msg.sender]++;
        emit Transfer(seller, msg.sender, 1);

        punkNoLongerForSale(punkIndex);
        pendingWithdrawals[seller] += msg.value;
        emit PunkBought(punkIndex, msg.value, seller, msg.sender);

        // Check for the case where there is a bid from the new owner and refund it.
        // Any other bid can stay in place.
        Bid memory bid = punkBids[punkIndex];
        if (bid.bidder == msg.sender) {
            // Kill bid and refund value
            pendingWithdrawals[msg.sender] += bid.value;
            punkBids[punkIndex] = Bid(false, punkIndex, address(0), 0);
        }
    }

    function withdraw() external {
        //if (!allPunksAssigned) revert();
        uint256 amount = pendingWithdrawals[msg.sender];
        // Remember to zero the pending refund before
        // sending to prevent re-entrancy attacks
        pendingWithdrawals[msg.sender] = 0;
        payable(msg.sender).transfer(amount);
    }

    function enterBidForPunk(uint256 punkIndex) external payable {
        if (punkIndex >= 10000) revert();
        if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] == address(0)) revert();
        if (punkIndexToAddress[punkIndex] == msg.sender) revert();
        if (msg.value == 0) revert();
        Bid memory existing = punkBids[punkIndex];
        if (msg.value <= existing.value) revert();
        if (existing.value > 0) {
            // Refund the failing bid
            pendingWithdrawals[existing.bidder] += existing.value;
        }
        punkBids[punkIndex] = Bid(true, punkIndex, msg.sender, msg.value);
        emit PunkBidEntered(punkIndex, msg.value, msg.sender);
    }

    function acceptBidForPunk(uint256 punkIndex, uint256 minPrice) external {
        if (punkIndex >= 10000) revert();
        //if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] != msg.sender) revert();
        address seller = msg.sender;
        Bid memory bid = punkBids[punkIndex];
        if (bid.value == 0) revert();
        if (bid.value < minPrice) revert();

        punkIndexToAddress[punkIndex] = bid.bidder;
        balanceOf[seller]--;
        balanceOf[bid.bidder]++;
        emit Transfer(seller, bid.bidder, 1);

        punksOfferedForSale[punkIndex] = Offer(
            false,
            punkIndex,
            bid.bidder,
            0,
            address(0)
        );
        uint256 amount = bid.value;
        punkBids[punkIndex] = Bid(false, punkIndex, address(0), 0);
        pendingWithdrawals[seller] += amount;
        emit PunkBought(punkIndex, bid.value, seller, bid.bidder);
    }

    function withdrawBidForPunk(uint256 punkIndex) external {
        if (punkIndex >= 10000) revert();
        //if (!allPunksAssigned) revert();
        if (punkIndexToAddress[punkIndex] == address(0)) revert();
        if (punkIndexToAddress[punkIndex] == msg.sender) revert();
        Bid memory bid = punkBids[punkIndex];
        if (bid.bidder != msg.sender) revert();
        emit PunkBidWithdrawn(punkIndex, bid.value, msg.sender);
        uint256 amount = bid.value;
        punkBids[punkIndex] = Bid(false, punkIndex, address(0), 0);
        // Refund the bid money
        payable(msg.sender).transfer(amount);
    }
}",2564
RealWorld_TA_107_IAggregatorV3Interface_RealWorld_20240814231945.log,107,IAggregatorV3Interface,23076,1362,24438,102.0,0.14262,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IAggregatorV3Interface {
    function decimals() external view returns (uint8);
    function latestAnswer() external view returns (int256 answer);
}",53
RealWorld_TA_107_IController_RealWorld_20240814232129.log,107,IController,30155,1989,32144,121.0,0.190555,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IController {
    function withdraw(address, uint256) external;

    function balanceOf(address) external view returns (uint256);

    function earn(address, uint256) external;

    function want(address) external view returns (address);

    function feeAddress() external view returns (address);

    function vaults(address) external view returns (address);

    function strategies(address) external view returns (address);

    function balanceOfJPEG(address strategyToken)
        external
        view
        returns (uint256);

    function withdrawJPEG(address strategyToken, address to) external;
}",137
RealWorld_TA_107_yVaultLPFarming_RealWorld_20240814223051.log,107,yVaultLPFarming,160942,3796,164738,156.0,0.88063,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

import ""../interfaces/IYVault.sol"";

/// @title JPEG'd yVault token farm
/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards
/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.
contract YVaultLPFarming is Ownable {
    using SafeERC20 for IERC20;
    using SafeERC20 for IYVault;
    using Address for address;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Claim(address indexed user, uint256 rewards);

    IYVault public immutable vault;
    IERC20 public immutable jpeg;

    uint256 public totalStaked;

    uint256 internal lastRewardBlock;
    uint256 internal previousBalance;
    uint256 internal accRewardPerShare;

    mapping(address => uint256) public balanceOf;
    mapping(address => uint256) private userLastAccRewardPerShare;
    mapping(address => uint256) private userPendingRewards;

    /// @notice Contracts that are allowed to interact with the LP farm
    /// @dev See the {noContract} modifier for more info
    mapping(address => bool) public whitelistedContracts;

    ///@param _vault The yVault address
    ///@param _jpeg The JPEG token address
    constructor(address _vault, address _jpeg) {
        require(_vault != address(0), ""INVALID_VAULT"");
        require(_jpeg != address(0), ""INVALID_JPEG"");

        vault = IYVault(_vault);
        jpeg = IERC20(_jpeg);
    }

    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.
    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.
    /// The {isContract} function returns false when `_account` is a contract executing constructor code.
    /// This may lead to some contracts being able to bypass this check.
    /// @param _account Address to check
    modifier noContract(address _account) {
        require(
            !_account.isContract() || whitelistedContracts[_account],
            ""Contracts aren't allowed to farm""
        );
        _;
    }

    /// @notice Allows the owner to whitelist/blacklist contracts
    /// @param _contract The contract address to whitelist/blacklist
    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`
    function setContractWhitelisted(address _contract, bool _isWhitelisted)
        external
        onlyOwner
    {
        whitelistedContracts[_contract] = _isWhitelisted;
    }

    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim
    /// @param _user The address of the user
    /// @return The amount of rewards claimable by user `_user`
    function pendingReward(address _user)
        external
        view
        returns (uint256)
    {
        uint256 rewardShare = accRewardPerShare;
        uint256 staked = totalStaked;
        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,
        //we need to calculate the up to date amount to return an accurate reward value
        if (block.number > lastRewardBlock && staked > 0) {
            (rewardShare, ) = _computeUpdate();
        }
        return
            //rewards that the user had already accumulated but not claimed
            userPendingRewards[_user] +
            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share
            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable
            //by the user
            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /
            1e36;
    }

    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function
    /// @dev Emits a {Deposit} event
    /// @param _amount The amount of tokens to deposit
    function deposit(uint256 _amount) external noContract(msg.sender) {
        require(_amount > 0, ""invalid_amount"");

        _update();
        _withdrawReward(msg.sender);

        vault.safeTransferFrom(msg.sender, address(this), _amount);

        balanceOf[msg.sender] += _amount;
        totalStaked += _amount;

        emit Deposit(msg.sender, _amount);
    }

    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function
    /// @dev Emits a {Withdraw} event
    /// @param _amount The amount of tokens to withdraw
    function withdraw(uint256 _amount) external noContract(msg.sender) {
        require(_amount > 0, ""invalid_amount"");
        require(balanceOf[msg.sender] >= _amount, ""insufficient_amount"");

        _update();
        _withdrawReward(msg.sender);

        balanceOf[msg.sender] -= _amount;
        totalStaked -= _amount;

        vault.safeTransfer(msg.sender, _amount);

        emit Withdraw(msg.sender, _amount);
    }

    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function
    /// @dev Emits a {Claim} event
    function claim() external noContract(msg.sender) {
        _update();
        _withdrawReward(msg.sender);

        uint256 rewards = userPendingRewards[msg.sender];
        require(rewards > 0, ""no_reward"");

        userPendingRewards[msg.sender] = 0;
        //we are subtracting the claimed rewards from the previous to have a consistent value next time
        //{_update is called}
        previousBalance -= rewards;

        if (jpeg.balanceOf(address(this)) < rewards)
            vault.withdrawJPEG();

        jpeg.safeTransfer(msg.sender, rewards);

        emit Claim(msg.sender, rewards);
    }

    /// @dev Updates this contract's rewards state
    function _update() internal {
        if (block.number <= lastRewardBlock) return;

        lastRewardBlock = block.number;

        if (totalStaked == 0) return;

        (accRewardPerShare, previousBalance) = _computeUpdate();
    }

    /// @dev Computes the updated contract state without writing storage
    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`
    /// @return currentBalance The new value of `previousBalance`
    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {
        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));
        uint256 newRewards = currentBalance - previousBalance;

        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;
    }

    /// @dev Updates `account`'s claimable rewards by adding pending rewards
    /// @param account The account to update
    function _withdrawReward(address account) internal returns (uint256) {
        uint256 pending = (balanceOf[account] *
            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;

        if (pending > 0) userPendingRewards[account] += pending;

        userLastAccRewardPerShare[account] = accRewardPerShare;

        return pending;
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }
}",1728
RealWorld_TA_107_JPEGLock_RealWorld_20240814221153.log,107,JPEGLock,79821,2710,82531,134.0,0.453305,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/// @title JPEG Locker contract
/// @notice Contract used by {NFTVault} to lock JPEG to increase the value of an NFT
contract JPEGLock is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    event Lock(address indexed user, uint256 indexed nftIndex, uint256 amount);
    event Unlock(address indexed user, uint256 indexed nftIndex, uint256 amount);

    struct LockPosition {
        address owner;
        uint256 unlockAt;
        uint256 lockAmount;
    }

    /// @notice The token to lock, JPEG
    IERC20 public immutable jpeg;
    /// @notice The amount of time to lock JPEG tokens for
    uint256 public lockTime;
    /// @notice Positions by NFT index
    mapping(uint256 => LockPosition) public positions;

    /// @param _jpeg The token to lock
    constructor(IERC20 _jpeg) Ownable() ReentrancyGuard() {
        jpeg = _jpeg;
        lockTime = 365 days;
    }

    /// @notice Allows the owner to change the amount of time JPEG tokens are locked for.
    /// The lock duration of already existing locked tokens won't change
    /// @param _newTime The new lock duration in seconds
    function setLockTime(uint256 _newTime) external onlyOwner {
        require(_newTime > 0, ""Invalid lock time"");
        lockTime = _newTime;
    }

    /// @notice Locks `_lockAmount` tokens for account `_account` and NFT `_nftIndex` for 1 year. 
    /// @dev Emits a {Lock} event
    /// @param _account The account to lock tokens for
    /// @param _nftIndex The NFT to lock tokens for
    /// @param _lockAmount The amount of tokens to lock
    function lockFor(
        address _account,
        uint256 _nftIndex,
        uint256 _lockAmount
    ) external onlyOwner nonReentrant {
        jpeg.safeTransferFrom(_account, address(this), _lockAmount);

        positions[_nftIndex] = LockPosition({
            owner: _account,
            unlockAt: block.timestamp + lockTime,
            lockAmount: _lockAmount
        });

        emit Lock(_account, _nftIndex, _lockAmount);
    }

    /// @notice Unlocks tokens for the position relative to NFT `_nftIndex`
    /// @dev Emits an {Unlock} event
    /// @param _nftIndex the NFT to unlock 
    function unlock(uint256 _nftIndex) external nonReentrant {
        LockPosition memory position = positions[_nftIndex];
        require(position.owner == msg.sender, ""unauthorized"");
        require(position.unlockAt <= block.timestamp, ""locked"");

        delete positions[_nftIndex];

        jpeg.safeTransfer(msg.sender, position.lockAmount);

        emit Unlock(msg.sender, _nftIndex, position.lockAmount);
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }
}",752
RealWorld_TA_107_LPFarming_RealWorld_20240814223329.log,107,LPFarming,314493,4220,318713,186.0,1.656865,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/// @title JPEG'd LP Farming
/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards
/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.
/// To ensure that enough tokens are allocated, an epoch system is implemented.
/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.
/// When there no epoch is ongoing, the contract stops emitting rewards
contract LPFarming is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using Address for address;

    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event Claim(address indexed user, uint256 indexed pid, uint256 amount);
    event ClaimAll(address indexed user, uint256 amount);

    /// @dev Data relative to a user's staking position
    /// @param amount The amount of LP tokens the user has provided
    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim
    struct UserInfo {
        uint256 amount;
        uint256 lastAccRewardPerShare;
    }

    /// @dev Data relative to an LP pool
    /// @param lpToken The LP token accepted by the pool
    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool
    /// @param lastRewardBlock Last block number in which reward distribution occurred
    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited
    struct PoolInfo {
        IERC20 lpToken;
        uint256 allocPoint;
        uint256 lastRewardBlock;
        uint256 accRewardPerShare;
    }

    /// @dev Data relative to an epoch
    /// @param startBlock The epoch's starting block
    /// @param endBlock The epoch's starting block
    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch
    struct EpochInfo {
        uint256 startBlock;
        uint256 endBlock;
        uint256 rewardPerBlock;
    }

    /// @notice The reward token, JPEG
    IERC20 public immutable jpeg;

    /// @notice The current epoch
    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch
    EpochInfo public epoch;
    /// @notice All the LP pools, active and inactive
    PoolInfo[] public poolInfo;
    /// @notice User staking positions, divided by PID
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    /// @notice Sum of the allocation points for all the pools
    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.
    uint256 public totalAllocPoint;

    /// @dev User's (total) withdrawable rewards
    mapping(address => uint256) private userRewards;
    /// @notice Contracts that are allowed to interact with the LP farm
    /// @dev See the {noContract} modifier for more info
    mapping(address => bool) public whitelistedContracts;

    /// @param _jpeg The reward token
    constructor(address _jpeg) {
        jpeg = IERC20(_jpeg);
    }

    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.
    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.
    /// The {isContract} function returns false when `_account` is a contract executing constructor code.
    /// This may lead to some contracts being able to bypass this check.
    /// @param _account Address to check
    modifier noContract(address _account) {
        require(
            !_account.isContract() || whitelistedContracts[_account],
            ""Contracts aren't allowed to farm""
        );
        _;
    }

    /// @notice Allows the owner to whitelist/blacklist contracts
    /// @param _contract The contract address to whitelist/blacklist
    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`
    function setContractWhitelisted(address _contract, bool _isWhitelisted)
        external
        onlyOwner
    {
        whitelistedContracts[_contract] = _isWhitelisted;
    }

    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch
    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`
    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`
    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0
    function newEpoch(
        uint256 _startBlock,
        uint256 _endBlock,
        uint256 _rewardPerBlock
    ) external onlyOwner {
        require(_startBlock >= block.number, ""Invalid start block"");
        require(_endBlock > _startBlock, ""Invalid end block"");
        require(_rewardPerBlock > 0, ""Invalid reward per block"");

        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`
        _massUpdatePools();

        uint256 remainingRewards = epoch.rewardPerBlock *
            (epoch.endBlock - _blockNumber());
        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);

        epoch.startBlock = _startBlock;
        epoch.endBlock = _endBlock;
        epoch.rewardPerBlock = _rewardPerBlock;

        if (remainingRewards > newRewards) {
            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);
        } else if (remainingRewards < newRewards) {
            jpeg.safeTransferFrom(
                msg.sender,
                address(this),
                newRewards - remainingRewards
            );
        }
    }

    /// @notice Allows the owner to add a new pool
    /// @param _allocPoint Allocation points to assign to the new pool
    /// @param _lpToken The LP token accepted by the new pool
    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {
        _massUpdatePools();

        uint256 lastRewardBlock = _blockNumber();
        totalAllocPoint = totalAllocPoint + _allocPoint;
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accRewardPerShare: 0
            })
        );
    }

    /// @notice Allows the owner to change a pool's allocation points
    /// @param _pid The pool id of the pool to modify
    /// @param _allocPoint The new allocation points
    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {
        _massUpdatePools();

        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;
        poolInfo[_pid].allocPoint = _allocPoint;
        if (prevAllocPoint != _allocPoint) {
            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;
        }
    }

    /// @notice Returns the number of pools available
    /// @return The length of the `poolInfo` array
    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`
    /// @param _pid The pool id
    /// @param _user The address of the user
    /// @return The amount of rewards claimable from `_pid` by user `_user`
    function pendingReward(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accRewardPerShare = pool.accRewardPerShare;
        uint256 blockNumber = _blockNumber();
        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch
        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,
        //we need to calculate the up to date amount to return an accurate reward value
        if (blockNumber > lastRewardBlock && lpSupply != 0) {
            uint256 reward = ((blockNumber - lastRewardBlock) *
                epoch.rewardPerBlock *
                1e36 *
                pool.allocPoint) / totalAllocPoint;
            accRewardPerShare += reward / lpSupply;
        }
        return
            //rewards that the user had already accumulated but not claimed
            userRewards[_user] +
            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share
            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable
            //by the user
            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /
            1e36;
    }

    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function
    /// @dev Emits a {Deposit} event
    /// @param _pid The id of the pool to deposit into
    /// @param _amount The amount of LP tokens to deposit
    function deposit(uint256 _pid, uint256 _amount)
        external
        noContract(msg.sender)
    {
        require(_amount > 0, ""invalid_amount"");

        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        _updatePool(_pid);
        _withdrawReward(_pid);

        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);
        user.amount = user.amount + _amount;

        emit Deposit(msg.sender, _pid, _amount);
    }

    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function
    /// @dev Emits a {Withdraw} event
    /// @param _pid The id of the pool to withdraw from
    /// @param _amount The amount of LP tokens to withdraw
    function withdraw(uint256 _pid, uint256 _amount)
        external
        noContract(msg.sender)
    {
        require(_amount > 0, ""invalid_amount"");

        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""insufficient_amount"");

        _updatePool(_pid);
        _withdrawReward(_pid);

        user.amount -= _amount;
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        emit Withdraw(msg.sender, _pid, _amount);
    }

    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info
    /// @return Normalized `block.number`
    function _blockNumber() internal view returns (uint256) {
        return _normalizeBlockNumber(block.number);
    }

    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.
    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.
    /// For example:
    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used
    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed
    /// @return Normalized `blockNumber`
    function _normalizeBlockNumber(uint256 blockNumber)
        internal
        view
        returns (uint256)
    {
        if (blockNumber < epoch.startBlock) return epoch.startBlock;

        if (blockNumber > epoch.endBlock) return epoch.endBlock;

        return blockNumber;
    }

    /// @dev Calls {_updatePool} for every pool
    function _massUpdatePools() internal {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            _updatePool(pid);
        }
    }

    /// @dev Updates the state of the pool at index `_pid`
    /// @param _pid The pool to update
    function _updatePool(uint256 _pid) internal {
        PoolInfo storage pool = poolInfo[_pid];
        if (pool.allocPoint == 0) {
            return;
        }

        uint256 blockNumber = _blockNumber();
        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch
        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);
        if (blockNumber <= lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = blockNumber;
            return;
        }
        uint256 reward = ((blockNumber - lastRewardBlock) *
            epoch.rewardPerBlock *
            1e36 *
            pool.allocPoint) / totalAllocPoint;
        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;
        pool.lastRewardBlock = blockNumber;
    }

    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`
    /// @param _pid The pool to withdraw rewards from
    function _withdrawReward(uint256 _pid) internal returns (uint256) {
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 pending = (user.amount *
            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /
            1e36;
        if (pending > 0) {
            userRewards[msg.sender] += pending;
        }

        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;

        return pending;
    }

    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function
    /// @dev Emits a {Claim} event
    /// @param _pid The pool to claim rewards from
    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {
        _updatePool(_pid);
        _withdrawReward(_pid);

        uint256 rewards = userRewards[msg.sender];
        require(rewards > 0, ""no_reward"");

        jpeg.safeTransfer(msg.sender, rewards);
        userRewards[msg.sender] = 0;

        emit Claim(msg.sender, _pid, rewards);
    }

    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function
    /// @dev Emits a {ClaimAll} event
    function claimAll() external nonReentrant noContract(msg.sender) {
        for (uint256 i = 0; i < poolInfo.length; i++) {
            _updatePool(i);
            _withdrawReward(i);
        }

        uint256 rewards = userRewards[msg.sender];
        require(rewards > 0, ""no_reward"");

        jpeg.safeTransfer(msg.sender, rewards);
        userRewards[msg.sender] = 0;

        emit ClaimAll(msg.sender, rewards);
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }
}",3581
RealWorld_TA_107_IBaseRewardPool_RealWorld_20240814230936.log,107,IBaseRewardPool,30430,1587,32017,104.0,0.18389,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IBaseRewardPool {
    function withdrawAndUnwrap(uint256 amount, bool claim)
        external
        returns (bool);

    function withdrawAllAndUnwrap(bool claim) external;

    function getReward(address _account, bool _claimExtras)
        external
        returns (bool);

    function balanceOf(address) external view returns (uint256);

    function extraRewards(uint256) external view returns (address);

    function extraRewardsLength() external view returns (uint256);

    function rewardToken() external view returns (address);

    function earned() external view returns (uint256);
}",144
RealWorld_TA_107_NFTVault_RealWorld_20240814221650.log,107,NFTVault,733024,679,733703,174.0,3.6787,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol"";

import ""../interfaces/IAggregatorV3Interface.sol"";
import ""../interfaces/IStableCoin.sol"";
import ""../interfaces/IJPEGLock.sol"";

/// @title NFT lending vault
/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.
/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits
/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their
/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price
/// worth of JPEG to make it effective
contract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    event PositionOpened(address indexed owner, uint256 indexed index);
    event Borrowed(
        address indexed owner,
        uint256 indexed index,
        uint256 amount
    );
    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);
    event PositionClosed(address indexed owner, uint256 indexed index);
    event Liquidated(
        address indexed liquidator,
        address indexed owner,
        uint256 indexed index,
        bool insured
    );
    event Repurchased(address indexed owner, uint256 indexed index);
    event InsuranceExpired(address indexed owner, uint256 indexed index);

    enum BorrowType {
        NOT_CONFIRMED,
        NON_INSURANCE,
        USE_INSURANCE
    }

    struct Position {
        BorrowType borrowType;
        uint256 debtPrincipal;
        uint256 debtPortion;
        uint256 debtAmountForRepurchase;
        uint256 liquidatedAt;
        address liquidator;
    }

    struct Rate {
        uint128 numerator;
        uint128 denominator;
    }

    struct VaultSettings {
        Rate debtInterestApr;
        Rate creditLimitRate;
        Rate liquidationLimitRate;
        Rate valueIncreaseLockRate;
        Rate organizationFeeRate;
        Rate insurancePurchaseRate;
        Rate insuranceLiquidationPenaltyRate;
        uint256 insuraceRepurchaseTimeLimit;
        uint256 borrowAmountCap;
    }

    bytes32 public constant DAO_ROLE = keccak256(""DAO_ROLE"");
    bytes32 public constant LIQUIDATOR_ROLE = keccak256(""LIQUIDATOR_ROLE"");

    bytes32 public constant CUSTOM_NFT_HASH = keccak256(""CUSTOM"");

    IStableCoin public stablecoin;
    /// @notice Chainlink ETH/USD price feed
    IAggregatorV3Interface public ethAggregator;
    /// @notice Chainlink JPEG/USD price feed
    IAggregatorV3Interface public jpegAggregator;
    /// @notice Chainlink NFT floor oracle
    IAggregatorV3Interface public floorOracle;
    /// @notice Chainlink NFT fallback floor oracle
    IAggregatorV3Interface public fallbackOracle;
    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT
    IJPEGLock public jpegLocker;
    IERC721Upgradeable public nftContract;

    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but
    /// a value set by the DAO will be used instead
    bool public daoFloorOverride;
    // @notice If true, the floor price will be fetched using the fallback oracle
    bool public useFallbackOracle;
    /// @notice Total outstanding debt
    uint256 public totalDebtAmount;
    /// @dev Last time debt was accrued. See {accrue} for more info
    uint256 public totalDebtAccruedAt;
    uint256 public totalFeeCollected;
    uint256 internal totalDebtPortion;

    VaultSettings public settings;

    /// @dev Keeps track of all the NFTs used as collateral for positions
    EnumerableSetUpgradeable.UintSet private positionIndexes;

    mapping(uint256 => Position) private positions;
    mapping(uint256 => address) public positionOwner;
    mapping(bytes32 => uint256) public nftTypeValueETH;
    mapping(uint256 => uint256) public nftValueETH;
    //bytes32(0) is floor
    mapping(uint256 => bytes32) public nftTypes;
    mapping(uint256 => uint256) public pendingNFTValueETH;

    /// @dev Checks if the provided NFT index is valid
    /// @param nftIndex The index to check
    modifier validNFTIndex(uint256 nftIndex) {
        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)
        require(nftContract.ownerOf(nftIndex) != address(0), ""invalid_nft"");
        _;
    }

    struct NFTCategoryInitializer {
        bytes32 hash;
        uint256 valueETH;
        uint256[] nfts;
    }

    /// @param _stablecoin PUSD address
    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract
    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)
    /// @param _ethAggregator Chainlink ETH/USD price feed address
    /// @param _jpegAggregator Chainlink JPEG/USD price feed address
    /// @param _floorOracle Chainlink floor oracle address
    /// @param _fallbackOracle Chainlink fallback floor oracle address
    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.
    /// Floor NFT shouldn't be initialized this way
    /// @param _jpegLocker JPEGLock address
    /// @param _settings Initial settings used by the contract
    function initialize(
        IStableCoin _stablecoin,
        IERC721Upgradeable _nftContract,
        IAggregatorV3Interface _ethAggregator,
        IAggregatorV3Interface _jpegAggregator,
        IAggregatorV3Interface _floorOracle,
        IAggregatorV3Interface _fallbackOracle,
        NFTCategoryInitializer[] memory _typeInitializers,
        IJPEGLock _jpegLocker,
        VaultSettings memory _settings
    ) external initializer {
        __AccessControl_init();
        __ReentrancyGuard_init();

        _setupRole(DAO_ROLE, msg.sender);
        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);
        _setRoleAdmin(DAO_ROLE, DAO_ROLE);

        _validateRate(_settings.debtInterestApr);
        _validateRate(_settings.creditLimitRate);
        _validateRate(_settings.liquidationLimitRate);
        _validateRate(_settings.valueIncreaseLockRate);
        _validateRate(_settings.organizationFeeRate);
        _validateRate(_settings.insurancePurchaseRate);
        _validateRate(_settings.insuranceLiquidationPenaltyRate);

        _validateCreditLimitAndLiquidationRate(
            _settings.creditLimitRate,
            _settings.liquidationLimitRate
        );

        stablecoin = _stablecoin;
        jpegLocker = _jpegLocker;
        ethAggregator = _ethAggregator;
        jpegAggregator = _jpegAggregator;
        floorOracle = _floorOracle;
        fallbackOracle = _fallbackOracle;
        nftContract = _nftContract;

        settings = _settings;

        //initializing the categories
        for (uint256 i = 0; i < _typeInitializers.length; i++) {
            NFTCategoryInitializer memory initializer = _typeInitializers[i];
            nftTypeValueETH[initializer.hash] = initializer.valueETH;
            for (uint256 j = 0; j < initializer.nfts.length; j++) {
                nftTypes[initializer.nfts[j]] = initializer.hash;
            }
        }
    }

    /// @dev The {accrue} function updates the contract's state by calculating
    /// the additional interest accrued since the last state update
    function accrue() public {
        uint256 additionalInterest = _calculateAdditionalInterest();

        totalDebtAccruedAt = block.timestamp;

        totalDebtAmount += additionalInterest;
        totalFeeCollected += additionalInterest;
    }

    /// @notice Allows the DAO to change the total debt cap
    /// @param _borrowAmountCap New total debt cap
    function setBorrowAmountCap(uint256 _borrowAmountCap)
        external
        onlyRole(DAO_ROLE)
    {
        settings.borrowAmountCap = _borrowAmountCap;
    }

    /// @notice Allows the DAO to change the interest APR on borrows
    /// @param _debtInterestApr The new interest rate
    function setDebtInterestApr(Rate memory _debtInterestApr)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_debtInterestApr);
        settings.debtInterestApr = _debtInterestApr;
    }

    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value
    /// @param _valueIncreaseLockRate The new rate
    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_valueIncreaseLockRate);
        settings.valueIncreaseLockRate = _valueIncreaseLockRate;
    }

    /// @notice Allows the DAO to change the max debt to collateral rate for a position
    /// @param _creditLimitRate The new rate
    function setCreditLimitRate(Rate memory _creditLimitRate)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_creditLimitRate);
        _validateCreditLimitAndLiquidationRate(
            _creditLimitRate,
            settings.liquidationLimitRate
        );

        settings.creditLimitRate = _creditLimitRate;
    }

    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable
    /// @param _liquidationLimitRate The new rate
    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_liquidationLimitRate);
        _validateCreditLimitAndLiquidationRate(
            settings.creditLimitRate,
            _liquidationLimitRate
        );

        settings.liquidationLimitRate = _liquidationLimitRate;
    }

    /// @notice Allows the DAO to toggle the fallback oracle
    /// @param _useFallback Whether to use the fallback oracle
    function toggleFallbackOracle(bool _useFallback)
        external
        onlyRole(DAO_ROLE)
    {
        useFallbackOracle = _useFallback;
    }

    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT
    /// @param _newLockTime The amount new lock time amount
    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {
        jpegLocker.setLockTime(_newLockTime);
    }

    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value
    /// @param _newFloor The new floor
    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {
        require(_newFloor > 0, ""Invalid floor"");
        nftTypeValueETH[bytes32(0)] = _newFloor;
        daoFloorOverride = true;
    }

    /// @notice Allows the DAO to stop overriding floor
    function disableFloorOverride() external onlyRole(DAO_ROLE) {
        daoFloorOverride = false;
    }

    /// @notice Allows the DAO to change the static borrow fee
    /// @param _organizationFeeRate The new fee rate
    function setOrganizationFeeRate(Rate memory _organizationFeeRate)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_organizationFeeRate);
        settings.organizationFeeRate = _organizationFeeRate;
    }

    /// @notice Allows the DAO to change the cost of insurance
    /// @param _insurancePurchaseRate The new insurance fee rate
    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_insurancePurchaseRate);
        settings.insurancePurchaseRate = _insurancePurchaseRate;
    }

    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT
    /// @param _insuranceLiquidationPenaltyRate The new rate
    function setInsuranceLiquidationPenaltyRate(
        Rate memory _insuranceLiquidationPenaltyRate
    ) external onlyRole(DAO_ROLE) {
        _validateRate(_insuranceLiquidationPenaltyRate);
        settings
            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;
    }

    /// @notice Allows the DAO to add an NFT to a specific price category
    /// @param _nftIndex The index to add to the category
    /// @param _type The category hash
    function setNFTType(uint256 _nftIndex, bytes32 _type)
        external
        validNFTIndex(_nftIndex)
        onlyRole(DAO_ROLE)
    {
        require(
            _type == bytes32(0) || nftTypeValueETH[_type] > 0,
            ""invalid_nftType""
        );
        nftTypes[_nftIndex] = _type;
    }

    /// @notice Allows the DAO to change the value of an NFT category
    /// @param _type The category hash
    /// @param _amountETH The new value, in ETH
    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)
        external
        onlyRole(DAO_ROLE)
    {
        nftTypeValueETH[_type] = _amountETH;
    }

    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.
    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details
    /// @param _nftIndex The index of the NFT to change the value of
    /// @param _amountETH The new desired ETH value
    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)
        external
        validNFTIndex(_nftIndex)
        onlyRole(DAO_ROLE)
    {
        pendingNFTValueETH[_nftIndex] = _amountETH;
    }

    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.
    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.
    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`
    /// to the new credit limit of the NFT
    /// @param _nftIndex The index of the NFT
    function finalizePendingNFTValueETH(uint256 _nftIndex)
        external
        validNFTIndex(_nftIndex)
    {
        uint256 pendingValue = pendingNFTValueETH[_nftIndex];
        require(pendingValue > 0, ""no_pending_value"");
        uint256 toLockJpeg = (((pendingValue *
            _ethPriceUSD() *
            settings.creditLimitRate.numerator) /
            settings.creditLimitRate.denominator) *
            settings.valueIncreaseLockRate.numerator) /
            settings.valueIncreaseLockRate.denominator /
            _jpegPriceUSD();

        //lock JPEG using JPEGLock
        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);

        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;
        nftValueETH[_nftIndex] = pendingValue;
        //clear pending value
        pendingNFTValueETH[_nftIndex] = 0;
    }

    /// @dev Validates the credit limit rate and the liquidation limit rate.
    /// The credit limit rate must be less than the liquidation rate
    /// @param _creditLimitRate The credit limit rate to validate
    /// @param _liquidationLimitRate The liquidation limit rate
    function _validateCreditLimitAndLiquidationRate(
        Rate memory _creditLimitRate,
        Rate memory _liquidationLimitRate
    ) internal pure {
        require(
            _liquidationLimitRate.numerator * _creditLimitRate.denominator >
                _creditLimitRate.numerator * _liquidationLimitRate.denominator,
            ""credit_rate_exceeds_or_equals_liquidation_rate""
        );
    }

    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.
    /// @param rate The rate to validate
    function _validateRate(Rate memory rate) internal pure {
        require(
            rate.denominator > 0 && rate.denominator >= rate.numerator,
            ""invalid_rate""
        );
    }

    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`
    /// @param _nftIndex The NFT to return the value of
    /// @return The value of the NFT, 18 decimals
    function _getNFTValueETH(uint256 _nftIndex)
        internal
        view
        returns (uint256)
    {
        bytes32 nftType = nftTypes[_nftIndex];

        if (nftType == bytes32(0) && !daoFloorOverride) {
            return
                _normalizeAggregatorAnswer(
                    useFallbackOracle ? fallbackOracle : floorOracle
                );
        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];

        return nftTypeValueETH[nftType];
    }

    /// @dev Returns the value in USD of the NFT at index `_nftIndex`
    /// @param _nftIndex The NFT to return the value of
    /// @return The value of the NFT in USD, 18 decimals
    function _getNFTValueUSD(uint256 _nftIndex)
        internal
        view
        returns (uint256)
    {
        uint256 nft_value = _getNFTValueETH(_nftIndex);
        return (nft_value * _ethPriceUSD()) / 1 ether;
    }

    /// @dev Returns the current ETH price in USD
    /// @return The current ETH price, 18 decimals
    function _ethPriceUSD() internal view returns (uint256) {
        return _normalizeAggregatorAnswer(ethAggregator);
    }

    /// @dev Returns the current JPEG price in USD
    /// @return The current JPEG price, 18 decimals
    function _jpegPriceUSD() internal view returns (uint256) {
        return _normalizeAggregatorAnswer(jpegAggregator);
    }

    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator
    /// @param aggregator The aggregator to fetch the answer from
    /// @return The latest aggregator answer, normalized
    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)
        internal
        view
        returns (uint256)
    {
        int256 answer = aggregator.latestAnswer();
        uint8 decimals = aggregator.decimals();

        require(answer > 0, ""invalid_oracle_answer"");
        //converts the answer to have 18 decimals
        return
            decimals > 18
                ? uint256(answer) / 10**(decimals - 18)
                : uint256(answer) * 10**(18 - decimals);
    }

    struct NFTInfo {
        uint256 index;
        bytes32 nftType;
        address owner;
        uint256 nftValueETH;
        uint256 nftValueUSD;
    }

    /// @notice Returns data relative to the NFT at index `_nftIndex`
    /// @param _nftIndex The NFT index
    /// @return nftInfo The data relative to the NFT
    function getNFTInfo(uint256 _nftIndex)
        external
        view
        returns (NFTInfo memory nftInfo)
    {
        nftInfo = NFTInfo(
            _nftIndex,
            nftTypes[_nftIndex],
            nftContract.ownerOf(_nftIndex),
            _getNFTValueETH(_nftIndex),
            _getNFTValueUSD(_nftIndex)
        );
    }

    /// @dev Returns the credit limit of an NFT
    /// @param _nftIndex The NFT to return credit limit of
    /// @return The NFT credit limit
    function _getCreditLimit(uint256 _nftIndex)
        internal
        view
        returns (uint256)
    {
        uint256 asset_value = _getNFTValueUSD(_nftIndex);
        return
            (asset_value * settings.creditLimitRate.numerator) /
            settings.creditLimitRate.denominator;
    }

    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT
    /// @param _nftIndex The index of the NFT
    /// @return The minimum amount of debt to liquidate the NFT
    function _getLiquidationLimit(uint256 _nftIndex)
        internal
        view
        returns (uint256)
    {
        uint256 asset_value = _getNFTValueUSD(_nftIndex);
        return
            (asset_value * settings.liquidationLimitRate.numerator) /
            settings.liquidationLimitRate.denominator;
    }

    /// @dev Calculates current outstanding debt of an NFT
    /// @param _nftIndex The NFT to calculate the outstanding debt of
    /// @return The outstanding debt value
    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {
        uint256 calculatedDebt = _calculateDebt(
            totalDebtAmount,
            positions[_nftIndex].debtPortion,
            totalDebtPortion
        );

        uint256 principal = positions[_nftIndex].debtPrincipal;

        //_calculateDebt is prone to rounding errors that may cause
        //the calculated debt amount to be 1 or 2 units less than
        //the debt principal when the accrue() function isn't called
        //in between the first borrow and the _calculateDebt call.
        return principal > calculatedDebt ? principal : calculatedDebt;
    }

    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions
    /// @param total The global outstanding debt
    /// @param userPortion The user's portion of debt
    /// @param totalPortion The total user portions of debt
    /// @return The outstanding debt of the position
    function _calculateDebt(
        uint256 total,
        uint256 userPortion,
        uint256 totalPortion
    ) internal pure returns (uint256) {
        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;
    }

    /// @dev Opens a position
    /// Emits a {PositionOpened} event
    /// @param _owner The owner of the position to open
    /// @param _nftIndex The NFT used as collateral for the position
    function _openPosition(address _owner, uint256 _nftIndex) internal {
        nftContract.transferFrom(_owner, address(this), _nftIndex);

        positions[_nftIndex] = Position({
            borrowType: BorrowType.NOT_CONFIRMED,
            debtPrincipal: 0,
            debtPortion: 0,
            debtAmountForRepurchase: 0,
            liquidatedAt: 0,
            liquidator: address(0)
        });
        positionOwner[_nftIndex] = _owner;
        positionIndexes.add(_nftIndex);

        emit PositionOpened(_owner, _nftIndex);
    }

    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}
    /// @return The additional interest value
    function _calculateAdditionalInterest() internal view returns (uint256) {
        // Number of seconds since {accrue} was called
        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;
        if (elapsedTime == 0) {
            return 0;
        }

        if (totalDebtAmount == 0) {
            return 0;
        }

        // Accrue interest
        uint256 interestPerYear = (totalDebtAmount *
            settings.debtInterestApr.numerator) /
            settings.debtInterestApr.denominator;
        uint256 interestPerSec = interestPerYear / 365 days;

        return elapsedTime * interestPerSec;
    }

    /// @notice Returns the number of open positions
    /// @return The number of open positions
    function totalPositions() external view returns (uint256) {
        return positionIndexes.length();
    }

    /// @notice Returns all open position NFT indexes
    /// @return The open position NFT indexes
    function openPositionsIndexes() external view returns (uint256[] memory) {
        return positionIndexes.values();
    }

    struct PositionPreview {
        address owner;
        uint256 nftIndex;
        bytes32 nftType;
        uint256 nftValueUSD;
        VaultSettings vaultSettings;
        uint256 creditLimit;
        uint256 debtPrincipal;
        uint256 debtInterest;
        BorrowType borrowType;
        bool liquidatable;
        uint256 liquidatedAt;
        address liquidator;
    }

    /// @notice Returns data relative to a postition, existing or not
    /// @param _nftIndex The index of the NFT used as collateral for the position
    /// @return preview See assignment below
    function showPosition(uint256 _nftIndex)
        external
        view
        validNFTIndex(_nftIndex)
        returns (PositionPreview memory preview)
    {
        address posOwner = positionOwner[_nftIndex];

        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;
        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0
            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt
            : _calculateDebt(
                totalDebtAmount + _calculateAdditionalInterest(),
                positions[_nftIndex].debtPortion,
                totalDebtPortion
            );

        //_calculateDebt is prone to rounding errors that may cause
        //the calculated debt amount to be 1 or 2 units less than
        //the debt principal if no time has elapsed in between the first borrow
        //and the _calculateDebt call.
        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;

        preview = PositionPreview({
            owner: posOwner, //the owner of the position, `address(0)` if the position doesn't exists
            nftIndex: _nftIndex, //the NFT used as collateral for the position
            nftType: nftTypes[_nftIndex], //the type of the NFT
            nftValueUSD: _getNFTValueUSD(_nftIndex), //the value in USD of the NFT
            vaultSettings: settings, //the current vault's settings
            creditLimit: _getCreditLimit(_nftIndex), //the NFT's credit limit
            debtPrincipal: debtPrincipal, //the debt principal for the position, `0` if the position doesn't exists
            debtInterest: debtAmount - debtPrincipal, //the interest of the position
            borrowType: positions[_nftIndex].borrowType, //the insurance type of the position, `NOT_CONFIRMED` if it doesn't exist
            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&
                debtAmount >= _getLiquidationLimit(_nftIndex), //if the position can be liquidated
            liquidatedAt: positions[_nftIndex].liquidatedAt, //if the position has been liquidated and it had insurance, the timestamp at which the liquidation happened
            liquidator: positions[_nftIndex].liquidator //if the position has been liquidated and it had insurance, the address of the liquidator
        });
    }

    /// @notice Allows users to open positions and borrow using an NFT
    /// @dev emits a {Borrowed} event
    /// @param _nftIndex The index of the NFT to be used as collateral
    /// @param _amount The amount of PUSD to be borrowed. Note that the user will receive less than the amount requested,
    /// the borrow fee and insurance automatically get removed from the amount borrowed
    /// @param _useInsurance Whereter to open an insured position. In case the position has already been opened previously,
    /// this parameter needs to match the previous insurance mode. To change insurance mode, a user needs to close and reopen the position
    function borrow(
        uint256 _nftIndex,
        uint256 _amount,
        bool _useInsurance
    ) external validNFTIndex(_nftIndex) nonReentrant {
        accrue();

        require(
            msg.sender == positionOwner[_nftIndex] ||
                address(0) == positionOwner[_nftIndex],
            ""unauthorized""
        );
        require(_amount > 0, ""invalid_amount"");
        require(
            totalDebtAmount + _amount <= settings.borrowAmountCap,
            ""debt_cap""
        );

        if (positionOwner[_nftIndex] == address(0)) {
            _openPosition(msg.sender, _nftIndex);
        }

        Position storage position = positions[_nftIndex];
        require(position.liquidatedAt == 0, ""liquidated"");
        require(
            position.borrowType == BorrowType.NOT_CONFIRMED ||
                (position.borrowType == BorrowType.USE_INSURANCE &&
                    _useInsurance) ||
                (position.borrowType == BorrowType.NON_INSURANCE &&
                    !_useInsurance),
            ""invalid_insurance_mode""
        );

        uint256 creditLimit = _getCreditLimit(_nftIndex);
        uint256 debtAmount = _getDebtAmount(_nftIndex);
        require(debtAmount + _amount <= creditLimit, ""insufficient_credit"");

        //calculate the borrow fee
        uint256 organizationFee = (_amount *
            settings.organizationFeeRate.numerator) /
            settings.organizationFeeRate.denominator;

        uint256 feeAmount = organizationFee;
        //if the position is insured, calculate the insurance fee
        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {
            feeAmount +=
                (_amount * settings.insurancePurchaseRate.numerator) /
                settings.insurancePurchaseRate.denominator;
        }
        totalFeeCollected += feeAmount;
        //subtract the fee from the amount borrowed
        stablecoin.mint(msg.sender, _amount - feeAmount);

        if (position.borrowType == BorrowType.NOT_CONFIRMED) {
            position.borrowType = _useInsurance
                ? BorrowType.USE_INSURANCE
                : BorrowType.NON_INSURANCE;
        }

        // update debt portion
        if (totalDebtPortion == 0) {
            totalDebtPortion = _amount;
            position.debtPortion = _amount;
        } else {
            uint256 plusPortion = (totalDebtPortion * _amount) /
                totalDebtAmount;
            totalDebtPortion += plusPortion;
            position.debtPortion += plusPortion;
        }
        position.debtPrincipal += _amount;
        totalDebtAmount += _amount;

        emit Borrowed(msg.sender, _nftIndex, _amount);
    }

    /// @notice Allows users to repay a portion/all of their debt. Note that since interest increases every second,
    /// a user wanting to repay all of their debt should repay for an amount greater than their current debt to account for the
    /// additional interest while the repay transaction is pending, the contract will only take what's necessary to repay all the debt
    /// @dev Emits a {Repaid} event
    /// @param _nftIndex The NFT used as collateral for the position
    /// @param _amount The amount of debt to repay. If greater than the position's outstanding debt, only the amount necessary to repay all the debt will be taken
    function repay(uint256 _nftIndex, uint256 _amount)
        external
        validNFTIndex(_nftIndex)
        nonReentrant
    {
        accrue();

        require(msg.sender == positionOwner[_nftIndex], ""unauthorized"");
        require(_amount > 0, ""invalid_amount"");

        Position storage position = positions[_nftIndex];
        require(position.liquidatedAt == 0, ""liquidated"");

        uint256 debtAmount = _getDebtAmount(_nftIndex);
        require(debtAmount > 0, ""position_not_borrowed"");

        uint256 debtPrincipal = position.debtPrincipal;
        uint256 debtInterest = debtAmount - debtPrincipal;

        _amount = _amount > debtAmount ? debtAmount : _amount;

        // burn all payment, the interest is sent to the DAO using the {collect} function
        stablecoin.burnFrom(msg.sender, _amount);

        uint256 paidPrincipal = _amount > debtInterest
            ? _amount - debtInterest
            : 0;

        uint256 minusPortion = paidPrincipal == debtPrincipal
            ? position.debtPortion
            : (totalDebtPortion * _amount) / totalDebtAmount;

        totalDebtPortion -= minusPortion;
        position.debtPortion -= minusPortion;
        position.debtPrincipal -= paidPrincipal;
        totalDebtAmount -= _amount;

        emit Repaid(msg.sender, _nftIndex, _amount);
    }

    /// @notice Allows a user to close a position and get their collateral back, if the position's outstanding debt is 0
    /// @dev Emits a {PositionClosed} event
    /// @param _nftIndex The index of the NFT used as collateral
    function closePosition(uint256 _nftIndex)
        external
        validNFTIndex(_nftIndex)
    {
        accrue();

        require(msg.sender == positionOwner[_nftIndex], ""unauthorized"");
        require(_getDebtAmount(_nftIndex) == 0, ""position_not_repaid"");

        positionOwner[_nftIndex] = address(0);
        delete positions[_nftIndex];
        positionIndexes.remove(_nftIndex);

        // transfer nft back to owner if nft was deposited
        if (nftContract.ownerOf(_nftIndex) == address(this)) {
            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);
        }

        emit PositionClosed(msg.sender, _nftIndex);
    }

    /// @notice Allows members of the `LIQUIDATOR_ROLE` to liquidate a position. Positions can only be liquidated
    /// once their debt amount exceeds the minimum liquidation debt to collateral value rate.
    /// In order to liquidate a position, the liquidator needs to repay the user's outstanding debt.
    /// If the position is not insured, it's closed immediately and the collateral is sent to the liquidator.
    /// If the position is insured, the position remains open (interest doesn't increase) and the owner of the position has a certain amount of time
    /// (`insuranceRepurchaseTimeLimit`) to fully repay the liquidator and pay an additional liquidation fee (`insuranceLiquidationPenaltyRate`), if this
    /// is done in time the user gets back their collateral and their position is automatically closed. If the user doesn't repurchase their collateral
    /// before the time limit passes, the liquidator can claim the liquidated NFT and the position is closed
    /// @dev Emits a {Liquidated} event
    /// @param _nftIndex The NFT to liquidate
    function liquidate(uint256 _nftIndex)
        external
        onlyRole(LIQUIDATOR_ROLE)
        validNFTIndex(_nftIndex)
        nonReentrant
    {
        accrue();

        address posOwner = positionOwner[_nftIndex];
        require(posOwner != address(0), ""position_not_exist"");

        Position storage position = positions[_nftIndex];
        require(position.liquidatedAt == 0, ""liquidated"");

        uint256 debtAmount = _getDebtAmount(_nftIndex);
        require(
            debtAmount >= _getLiquidationLimit(_nftIndex),
            ""position_not_liquidatable""
        );

        // burn all payment
        stablecoin.burnFrom(msg.sender, debtAmount);

        // update debt portion
        totalDebtPortion -= position.debtPortion;
        totalDebtAmount -= debtAmount;
        position.debtPortion = 0;

        bool insured = position.borrowType == BorrowType.USE_INSURANCE;
        if (insured) {
            position.debtAmountForRepurchase = debtAmount;
            position.liquidatedAt = block.timestamp;
            position.liquidator = msg.sender;
        } else {
            // transfer nft to liquidator
            positionOwner[_nftIndex] = address(0);
            delete positions[_nftIndex];
            positionIndexes.remove(_nftIndex);
            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);
        }

        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);
    }

    /// @notice Allows liquidated users who purchased insurance to repurchase their collateral within the time limit
    /// defined with the `insuranceRepurchaseTimeLimit`. The user needs to pay the liquidator the total amount of debt
    /// the position had at the time of liquidation, plus an insurance liquidation fee defined with `insuranceLiquidationPenaltyRate`
    /// @dev Emits a {Repurchased} event
    /// @param _nftIndex The NFT to repurchase
    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {
        Position memory position = positions[_nftIndex];
        require(msg.sender == positionOwner[_nftIndex], ""unauthorized"");
        require(position.liquidatedAt > 0, ""not_liquidated"");
        require(
            position.borrowType == BorrowType.USE_INSURANCE,
            ""non_insurance""
        );
        require(
            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=
                block.timestamp,
            ""insurance_expired""
        );

        uint256 debtAmount = position.debtAmountForRepurchase;
        uint256 penalty = (debtAmount *
            settings.insuranceLiquidationPenaltyRate.numerator) /
            settings.insuranceLiquidationPenaltyRate.denominator;

        // transfer payment to liquidator
        stablecoin.transferFrom(
            msg.sender,
            position.liquidator,
            debtAmount + penalty
        );

        // transfer nft to user
        positionOwner[_nftIndex] = address(0);
        delete positions[_nftIndex];
        positionIndexes.remove(_nftIndex);

        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);

        emit Repurchased(msg.sender, _nftIndex);
    }

    /// @notice Allows the liquidator who liquidated the insured position with NFT at index `_nftIndex` to claim the position's collateral
    /// after the time period defined with `insuranceRepurchaseTimeLimit` has expired and the position owner has not repurchased the collateral.
    /// @dev Emits an {InsuranceExpired} event
    /// @param _nftIndex The NFT to claim
    function claimExpiredInsuranceNFT(uint256 _nftIndex)
        external
        validNFTIndex(_nftIndex)
    {
        Position memory position = positions[_nftIndex];
        address owner = positionOwner[_nftIndex];
        require(address(0) != owner, ""no_position"");
        require(position.liquidatedAt > 0, ""not_liquidated"");
        require(
            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <
                block.timestamp,
            ""insurance_not_expired""
        );
        require(position.liquidator == msg.sender, ""unauthorized"");

        positionOwner[_nftIndex] = address(0);
        delete positions[_nftIndex];
        positionIndexes.remove(_nftIndex);

        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);

        emit InsuranceExpired(owner, _nftIndex);
    }

    /// @notice Allows the DAO to collect interest and fees before they are repaid
    function collect() external nonReentrant onlyRole(DAO_ROLE) {
        accrue();
        stablecoin.mint(msg.sender, totalFeeCollected);
        totalFeeCollected = 0;
    }

    uint256[50] private __gap;
}",8805
RealWorld_TA_107_ICurve_RealWorld_20240814231749.log,107,ICurve,23128,1285,24413,114.0,0.14134,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface ICurve {
    function add_liquidity(uint256[4] calldata, uint256) external;

    function balances(uint256 index) external view returns (uint256);
}",58
RealWorld_TA_107_IYVault_RealWorld_20240814230431.log,107,IYVault,27327,2440,29767,112.0,0.185435,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYVault is IERC20 {
    function token() external view returns (address);

    function controller() external view returns (address);

    function deposit(uint256 amount) external;

    function withdraw(uint256 shares) external;

    function withdrawJPEG() external;

    function balanceOfJPEG() external view returns (uint256);
}",105
RealWorld_TA_107_Controller_RealWorld_20240814221947.log,107,Controller,146824,7064,153888,192.0,0.8754,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IStrategy.sol"";

/// @title JPEG'd strategies controller
/// @notice Allows members of the `STRATEGIST_ROLE` to manage all the strategies in the JPEG'd ecosystem
contract Controller is AccessControl {
    using SafeERC20 for IERC20;

    bytes32 public constant STRATEGIST_ROLE = keccak256(""STRATEGIST_ROLE"");

    IERC20 public immutable jpeg;
    address public feeAddress;

    mapping(IERC20 => address) public vaults;
    mapping(IERC20 => IStrategy) public strategies;
    mapping(IERC20 => mapping(IStrategy => bool)) public approvedStrategies;

    /// @param _feeAddress The address to send fees to
    constructor(address _jpeg, address _feeAddress) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        setFeeAddress(_feeAddress);
        jpeg = IERC20(_jpeg);
    }

    /// @notice Allows the DAO to set the fee receiver address
    /// @param _feeAddress The new fee receiver address
    function setFeeAddress(address _feeAddress)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(_feeAddress != address(0), ""INVALID_FEE_ADDRESS"");
        feeAddress = _feeAddress;
    }

    /// @notice Allows the strategist to set the vault for a token
    /// @param _token The token to set the vault for
    /// @param _vault The vault address
    function setVault(IERC20 _token, address _vault)
        external
        onlyRole(STRATEGIST_ROLE)
    {
        require(vaults[_token] == address(0), ""ALREADY_HAS_VAULT"");
        require(_vault != address(0), ""INVALID_VAULT"");
        vaults[_token] = _vault;
    }

    /// @notice Allows the DAO to approve a strategy for a token
    /// @param _token The strategy's target token
    /// @param _strategy The strategy for the token
    function approveStrategy(IERC20 _token, IStrategy _strategy)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(address(_token) != address(0), ""INVALID_TOKEN"");
        require(address(_strategy) != address(0), ""INVALID_STRATEGY"");

        approvedStrategies[_token][_strategy] = true;
    }

    /// @notice Allows the DAO to revoke a strategy for a token
    /// @param _token The strategy's target token
    /// @param _strategy The strategy to revoke
    function revokeStrategy(IERC20 _token, IStrategy _strategy)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(address(_token) != address(0), ""INVALID_TOKEN"");
        require(address(_strategy) != address(0), ""INVALID_STRATEGY"");

        approvedStrategies[_token][_strategy] = false;
    }

    /// @notice Allows the members of the `STRATEGIST_ROLE` to change between approved strategies for `_token`
    /// @param _token The token to change strategy for
    /// @param _strategy The strategy to change to
    function setStrategy(IERC20 _token, IStrategy _strategy)
        external
        onlyRole(STRATEGIST_ROLE)
    {
        require(
            approvedStrategies[_token][_strategy] == true,
            ""STRATEGY_NOT_APPROVED""
        );

        IStrategy _current = strategies[_token];
        if (address(_current) != address(0)) {
            //withdraw all funds from the current strategy
            _current.withdrawAll();
            _current.withdraw(address(jpeg));
        }
        strategies[_token] = _strategy;
    }

    /// @notice Allows anyone to deposit tokens from this contract to the token's strategy. Usually called by a vault after having sent tokens to this contract.
    /// @param _token The token to deposit
    /// @param _amount The amount of tokens to deposit
    function earn(IERC20 _token, uint256 _amount) external {
        IStrategy strategy = strategies[_token];
        _token.safeTransfer(address(strategy), _amount);
        strategy.deposit();
    }

    /// @return The amount of tokens held by `_token`'s strategy
    /// @param _token The token to check
    function balanceOf(IERC20 _token) external view returns (uint256) {
        return strategies[_token].balanceOf();
    }

    /// @return The amount of JPEG available to be withdrawn from `_token`'s strategy
    /// @param _token The token to check
    function balanceOfJPEG(IERC20 _token) external view returns (uint256) {
        return strategies[_token].balanceOfJPEG();
    }

    /// @notice Allows members of the `STRATEGIST_ROLE` to withdraw all strategy tokens from a strategy (e.g. In case of a bug in the strategy)
    /// The tokens will be sent to the token's vault
    /// @param _token The token to withdraw
    function withdrawAll(IERC20 _token) external onlyRole(STRATEGIST_ROLE) {
        strategies[_token].withdrawAll();
    }

    /// @notice Allows members of the `STRATEGIST_ROLE` to withdraw tokens stuck in this constract
    /// @param _token The token to withdraw
    /// @param _amount The amount of tokens to withdraw
    function inCaseTokensGetStuck(IERC20 _token, uint256 _amount)
        external
        onlyRole(STRATEGIST_ROLE)
    {
        _token.safeTransfer(msg.sender, _amount);
    }

    /// @notice Allows members of the `STRATEGIST_ROLE` to withdraw non strategy tokens from a strategy
    /// @param _strategy The strategy to withdraw from
    /// @param _token The token to withdraw
    function inCaseStrategyTokensGetStuck(IStrategy _strategy, address _token)
        external
        onlyRole(STRATEGIST_ROLE)
    {
        _strategy.withdraw(_token);
    }

    /// @notice Allows a vault to withdraw strategy tokens from a strategy (usually done during withdrawals from vaults)
    /// @param _token The token to withdraw
    /// @param _amount The amount of tokens to withdraw
    function withdraw(IERC20 _token, uint256 _amount) public {
        require(msg.sender == vaults[_token], ""NOT_VAULT"");
        strategies[_token].withdraw(_amount);
    }

    /// @notice Allows the vault for token `_token` to withdraw JPEG from
    /// `_token`'s strategy
    /// @param _token The strategy's token
    /// @param _to The address to send JPEG to
    function withdrawJPEG(
        IERC20 _token,
        address _to
    ) external {
        require(msg.sender == vaults[_token], ""NOT_VAULT"");
        strategies[_token].withdrawJPEG(_to);
    }
}",1510
RealWorld_TA_107_IStrategy_RealWorld_20240814230244.log,107,IStrategy,34190,2194,36384,105.0,0.21483,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IStrategy {
    function want() external view returns (address);

    function deposit() external;

    // NOTE: must exclude any tokens used in the yield
    // Controller role - withdraw should return to Controller
    function withdraw(address) external;

    // Controller | Vault role - withdraw should always return to Vault
    function withdraw(uint256) external;

    // Controller | Vault role - withdraw should always return to Vault
    function withdrawAll() external returns (uint256);

    function balanceOf() external view returns (uint256);

    function withdrawJPEG(address to) external;

    function convexConfig()
        external
        view
        returns (
            address booster,
            address baseRewardPool,
            uint256 pid
        );

    function balanceOfJPEG() external view returns (uint256);
}",184
RealWorld_TA_107_StrategyPUSDConvex_RealWorld_20240814222531.log,107,StrategyPUSDConvex,327301,4722,332023,188.0,1.730945,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../../interfaces/ISwapRouter.sol"";
import ""../../../interfaces/IUniswapV2Router.sol"";
import ""../../../interfaces/ICurve.sol"";
import ""../../../interfaces/IBooster.sol"";
import ""../../../interfaces/IBaseRewardPool.sol"";

import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IFungibleAssetVaultForDAO.sol"";

/// @title JPEG'd PUSD Convex autocompounding strategy
/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.
/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.
/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the
/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral
contract StrategyPUSDConvex is AccessControl {
    using SafeERC20 for IERC20;

    event Harvested(uint256 wantEarned);

    struct Rate {
        uint128 numerator;
        uint128 denominator;
    }

    /// @param booster Convex Booster's address
    /// @param baseRewardPool Convex BaseRewardPool's address
    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens
    struct ConvexConfig {
        IBooster booster;
        IBaseRewardPool baseRewardPool;
        uint256 pid;
    }

    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address
    /// @param usdcIndex The USDC token index in curve's pool
    /// @param pusdIndex The PUSD token index in curve's pool
    struct CurveConfig {
        ICurve curve;
        uint256 usdcIndex;
        uint256 pusdIndex;
    }

    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address
    /// @param uniswapV3 The UniswapV3 router address
    struct DexConfig {
        IUniswapV2Router uniswapV2;
        ISwapRouter uniswapV3;
    }

    /// @param rewardTokens The Convex reward tokens
    /// @param controller The strategy controller
    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address
    struct StrategyConfig {
        IERC20[] rewardTokens;
        IController controller;
        IFungibleAssetVaultForDAO usdcVault;
    }

    bytes32 public constant STRATEGIST_ROLE = keccak256(""STRATEGIST_ROLE"");

    /// @notice The PUSD/USDC/USDT/MIM Curve LP token
    IERC20 public immutable want;
    IERC20 public immutable jpeg;
    IERC20 public immutable pusd;
    IERC20 public immutable weth;
    IERC20 public immutable usdc;

    DexConfig public dexConfig;
    CurveConfig public curveConfig;
    ConvexConfig public convexConfig;
    StrategyConfig public strategyConfig;

    /// @notice The performance fee to be sent to the DAO/strategists
    Rate public performanceFee;

    /// @notice lifetime strategy earnings denominated in `want` token
    uint256 public earned;

    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token
    /// @param _jpeg The JPEG token address
    /// @param _pusd The PUSD token address
    /// @param _weth The WETH token address
    /// @param _usdc The USDC token address
    /// @param _dexConfig See {DexConfig} struct
    /// @param _curveConfig See {CurveConfig} struct
    /// @param _convexConfig See {ConvexConfig} struct
    /// @param _strategyConfig See {StrategyConfig} struct
    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists
    constructor(
        address _want,
        address _jpeg,
        address _pusd,
        address _weth,
        address _usdc,
        DexConfig memory _dexConfig,
        CurveConfig memory _curveConfig,
        ConvexConfig memory _convexConfig,
        StrategyConfig memory _strategyConfig,
        Rate memory _performanceFee
    ) {
        require(_want != address(0), ""INVALID_WANT"");
        require(_jpeg != address(0), ""INVALID_JPEG"");
        require(_pusd != address(0), ""INVALID_PUSD"");
        require(_weth != address(0), ""INVALID_WETH"");
        require(_usdc != address(0), ""INVALID_USDC"");
        require(
            address(_dexConfig.uniswapV2) != address(0),
            ""INVALID_UNISWAP_V2""
        );
        require(
            address(_dexConfig.uniswapV3) != address(0),
            ""INVALID_UNISWAP_V3""
        );
        require(address(_curveConfig.curve) != address(0), ""INVALID_CURVE"");
        require(
            _curveConfig.pusdIndex != _curveConfig.usdcIndex,
            ""INVALID_CURVE_INDEXES""
        );
        require(_curveConfig.pusdIndex < 4, ""INVALID_PUSD_CURVE_INDEX"");
        require(_curveConfig.usdcIndex < 4, ""INVALID_USDC_CURVE_INDEX"");
        require(
            address(_convexConfig.booster) != address(0),
            ""INVALID_CONVEX_BOOSTER""
        );
        require(
            address(_convexConfig.baseRewardPool) != address(0),
            ""INVALID_CONVEX_BASE_REWARD_POOL""
        );
        require(
            address(_strategyConfig.controller) != address(0),
            ""INVALID_CONTROLLER""
        );
        require(
            address(_strategyConfig.usdcVault) != address(0),
            ""INVALID_USDC_VAULT""
        );

        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {
            require(
                address(_strategyConfig.rewardTokens[i]) != address(0),
                ""INVALID_REWARD_TOKEN""
            );
        }

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        setPerformanceFee(_performanceFee);

        want = IERC20(_want);
        jpeg = IERC20(_jpeg);
        pusd = IERC20(_pusd);
        weth = IERC20(_weth);
        usdc = IERC20(_usdc);

        dexConfig = _dexConfig;
        curveConfig = _curveConfig;
        convexConfig = _convexConfig;
        strategyConfig = _strategyConfig;
    }

    modifier onlyController() {
        require(
            msg.sender == address(strategyConfig.controller),
            ""NOT_CONTROLLER""
        );
        _;
    }

    /// @notice Allows the DAO to set the performance fee
    /// @param _performanceFee The new performance fee
    function setPerformanceFee(Rate memory _performanceFee)
        public
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(
            _performanceFee.denominator > 0 &&
                _performanceFee.denominator >= _performanceFee.numerator,
            ""INVALID_RATE""
        );
        performanceFee = _performanceFee;
    }

    /// @notice Allows the DAO to set the strategy controller
    /// @param _controller The new strategy controller
    function setController(address _controller)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(_controller != address(0), ""INVALID_CONTROLLER"");
        strategyConfig.controller = IController(_controller);
    }

    /// @notice Allows the DAO to set the USDC vault
    /// @param _vault The new USDC vault
    function setUSDCVault(address _vault)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        require(_vault != address(0), ""INVALID_USDC_VAULT"");
        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);
    }

    /// @return The strategy's name
    function getName() external pure returns (string memory) {
        return ""StrategyPUSDConvex"";
    }

    /// @return The amount of `want` tokens held by this contract
    function balanceOfWant() public view returns (uint256) {
        return want.balanceOf(address(this));
    }

    /// @return The amount of `want` tokens deposited in the Convex pool by this contract
    function balanceOfPool() public view returns (uint256) {
        return convexConfig.baseRewardPool.balanceOf(address(this));
    }

    /// @return The amount of JPEG currently held by this contract and the amount of JPEG
    /// rewards available from Convex
    function balanceOfJPEG() external view returns (uint256) {
        uint256 availableBalance = jpeg.balanceOf(address(this));

        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;
        uint256 length = baseRewardPool.extraRewardsLength();
        for (uint256 i = 0; i < length; i++) {
            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));
            if (address(jpeg) == extraReward.rewardToken()) {
                availableBalance += extraReward.earned();
                //we found jpeg, no need to continue the loop
                break;
            }
        }

        return availableBalance;
    }

    /// @return The total amount of `want` tokens this contract manages (held + deposited)
    function balanceOf() external view returns (uint256) {
        return balanceOfWant() + balanceOfPool();
    }

    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex
    function deposit() public {
        uint256 balance = want.balanceOf(address(this));
        ConvexConfig memory convex = convexConfig;
        want.safeIncreaseAllowance(address(convex.booster), balance);
        convex.booster.depositAll(convex.pid, true);
    }

    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)
    function withdraw(IERC20 _asset)
        external
        onlyController
        returns (uint256 balance)
    {
        require(want != _asset, ""want"");
        require(pusd != _asset, ""pusd"");
        require(usdc != _asset, ""usdc"");
        require(weth != _asset, ""weth"");
        require(jpeg != _asset, ""jpeg"");
        balance = _asset.balanceOf(address(this));
        _asset.safeTransfer(address(strategyConfig.controller), balance);
    }

    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal
    /// @param _amount The amount of `want` tokens to withdraw
    function withdraw(uint256 _amount) external onlyController {
        address vault = strategyConfig.controller.vaults(address(want));
        require(vault != address(0), ""ZERO_VAULT""); // additional protection so we don't burn the funds

        uint256 balance = want.balanceOf(address(this));
        //if the contract doesn't have enough want, withdraw from Convex
        if (balance < _amount)
            convexConfig.baseRewardPool.withdrawAndUnwrap(
                _amount - balance,
                false
            );

        want.safeTransfer(vault, _amount);
    }

    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies
    /// @return balance The total amount of funds that have been withdrawn
    function withdrawAll() external onlyController returns (uint256 balance) {
        address vault = strategyConfig.controller.vaults(address(want));
        require(vault != address(0), ""ZERO_VAULT""); // additional protection so we don't burn the funds

        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);

        balance = want.balanceOf(address(this));
        want.safeTransfer(vault, balance);
    }

    /// @notice Allows the controller to claim JPEG rewards from Convex
    /// and withdraw JPEG to the `_to` address
    /// @param _to The address to send JPEG to
    function withdrawJPEG(address _to) external onlyController {
        // claim from convex rewards pool
        convexConfig.baseRewardPool.getReward(address(this), true);
        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));
    }

    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve
    /// @param minOutCurve The minimum amount of `want` tokens to receive
    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {
        convexConfig.baseRewardPool.getReward(address(this), true);

        //Prevent `Stack too deep` errors
        {
            DexConfig memory dex = dexConfig;
            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;
            IERC20 _weth = weth;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                uint256 balance = rewardTokens[i].balanceOf(address(this));

                if (balance > 0)
                    //minOut is not needed here, we already have it on the Curve deposit
                    _swapUniswapV2(
                        dex.uniswapV2,
                        rewardTokens[i],
                        _weth,
                        balance,
                        0
                    );
            }

            uint256 wethBalance = _weth.balanceOf(address(this));
            require(wethBalance > 0, ""NOOP"");

            //handle sending jpeg here

            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);

            //minOut is not needed here, we already have it on the Curve deposit
            ISwapRouter.ExactInputParams memory params = ISwapRouter
                .ExactInputParams(
                    abi.encodePacked(weth, uint24(500), usdc),
                    address(this),
                    block.timestamp,
                    wethBalance,
                    0
                );

            dex.uniswapV3.exactInput(params);
        }

        StrategyConfig memory strategy = strategyConfig;
        CurveConfig memory curve = curveConfig;

        uint256 usdcBalance = usdc.balanceOf(address(this));

        //take the performance fee
        uint256 fee = (usdcBalance * performanceFee.numerator) /
            performanceFee.denominator;
        usdc.safeTransfer(strategy.controller.feeAddress(), fee);
        usdcBalance -= fee;

        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);
        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC
        //balance to 18 decimals to compare it with the PUSD balance
        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *
            10**12;

        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD
        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];
        if (usdcCurveBalance > pusdCurveBalance) {
            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD
            //and deposit it into the Curve pool
            usdc.safeIncreaseAllowance(
                address(strategy.usdcVault),
                usdcBalance
            );
            strategy.usdcVault.deposit(usdcBalance);

            //check the vault's credit limit, it should be 1:1 for USDC
            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);

            strategy.usdcVault.borrow(toBorrow);
            liquidityAmounts[curve.pusdIndex] = toBorrow;

            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);
        } else {
            //if there's more PUSD than USDC in the pool, deposit USDC
            liquidityAmounts[curve.usdcIndex] = usdcBalance;
            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);
        }

        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);

        uint256 wantBalance = balanceOfWant();

        deposit();

        earned += wantBalance;
        emit Harvested(wantBalance);
    }

    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)
    /// @param router The UniswapV2 (or Sushiswap) router
    /// @param tokenIn The input token for the swap
    /// @param tokenOut The output token for the swap
    /// @param amountIn The amount of `tokenIn` to swap
    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert
    function _swapUniswapV2(
        IUniswapV2Router router,
        IERC20 tokenIn,
        IERC20 tokenOut,
        uint256 amountIn,
        uint256 minOut
    ) internal {
        tokenIn.safeIncreaseAllowance(address(router), amountIn);

        address[] memory path = new address[](2);
        path[0] = address(tokenIn);
        path[1] = address(tokenOut);

        router.swapExactTokensForTokens(
            amountIn,
            minOut,
            path,
            address(this),
            block.timestamp
        );
    }
}",3743
RealWorld_TA_107_MockRewardPool_RealWorld_20240814215743.log,107,MockRewardPool,52392,4291,56683,140.0,0.34778,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/IBaseRewardPool.sol"";

contract MockRewardPool is IBaseRewardPool {
    IERC20 internal poolToken;
    address public override rewardToken;
    address[] public override extraRewards;

    constructor(
        IERC20 _poolToken,
        address _rewardToken,
        address[] memory _extraRewards
    ) {
        poolToken = _poolToken;
        rewardToken = _rewardToken;
        extraRewards = _extraRewards;
    }

    function withdrawAllAndUnwrap(bool claim) external override {
        withdrawAndUnwrap(balanceOf(address(0)), claim);
    }

    function withdrawAndUnwrap(uint256 amount, bool claim)
        public
        override
        returns (bool)
    {
        poolToken.transfer(msg.sender, amount);
        if (claim) getReward(msg.sender, true);
        return true;
    }

    function getReward(address recipient, bool claimExtras) public override returns (bool) {
        IERC20(rewardToken).transfer(recipient, IERC20(rewardToken).balanceOf(address(this)));
        if (claimExtras) {
            for (uint256 i = 0; i < extraRewards.length; i++) {
                IBaseRewardPool(extraRewards[i]).getReward(
                    recipient,
                    true
                );
            }
        }

        return true;
    }

    function balanceOf(address) public view override returns (uint256) {
        return poolToken.balanceOf(address(this));
    }

    function extraRewardsLength() external view override returns (uint256) {
        return extraRewards.length;
    }

    function earned() external view override returns (uint256) {
        return IERC20(rewardToken).balanceOf(address(this));
    }
}",400
RealWorld_TA_107_TestERC20_RealWorld_20240814220514.log,107,TestERC20,31233,3090,34323,117.0,0.217965,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol"";

contract TestERC20 is ERC20PresetMinterPauser {
    uint8 internal _decimals;

    constructor(string memory name, string memory symbol)
        ERC20PresetMinterPauser(name, symbol)
    {
        _decimals = 18;
    }

    function setDecimals(uint8 newDecimals) external {
        _decimals = newDecimals;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }
}",148
RealWorld_TA_107_IFloorOracle_RealWorld_20240814224927.log,107,IFloorOracle,25107,1839,26946,108.0,0.162315,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IFloorOracle {
    function update() external returns (bool);

    function floor_eth_18() external view returns (uint256);

    function last_update_time() external view returns (uint256);

    function last_update_remote() external view returns (bool);
}",74
RealWorld_TA_107_ICryptoPunks_RealWorld_20240814231123.log,107,ICryptoPunks,24031,1294,25325,138.0,0.146035,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface ICryptoPunks {
    function transferPunk(address _to, uint256 _punkIndex) external;

    function punkIndexToAddress(uint256 _punkIndex)
        external
        view
        returns (address);
}",67
RealWorld_TA_107_EtherRocksHelper_RealWorld_20240814224257.log,107,EtherRocksHelper,105058,3154,108212,133.0,0.58837,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";

import ""../escrow/NFTEscrow.sol"";
import ""../interfaces/IEtherRocks.sol"";

 /// @title EtherRocks NFTVault helper contract
 /// @notice Allows compatibility between EtherRocks and {NFTVault}
 /// @dev EtherRocks IERC721 compatibility.
 /// Meant to only be used by {NFTVault}.
 /// This contract is NOT an ERC721 wrapper for rocks and is not meant to implement the ERC721 interface fully, 
 /// its only purpose is to serve as a proxy between {NFTVault} and EtherRocks.
 /// The owner is {NFTVault}
contract EtherRocksHelper is NFTEscrow, OwnableUpgradeable {

    /// @param rocksAddress Address of the EtherRocks contract
    function initialize(address rocksAddress) external initializer {
        __NFTEscrow_init(rocksAddress);
        __Ownable_init();
    }

    /// @notice Returns the owner of the rock at index `_idx`
    /// @dev If the owner of the rock is this contract we return the address of the {NFTVault} for compatibility
    /// @param _idx The rock index
    /// @return The owner of the rock if != `address(this)`, otherwise the the owner of this contract
    function ownerOf(uint256 _idx) external view returns (address) {
        (address account,,,) = IEtherRocks(nftAddress).getRockInfo(_idx);

        return account == address(this) ? owner() : account;
    }

    /// @notice Function called by {NFTVault} to transfer rocks. Can only be called by the owner
    /// @param _from The sender address
    /// @param _to The recipient address
    /// @param _idx The index of the rock to transfer
    function transferFrom(
        address _from,
        address _to,
        uint256 _idx
    ) external onlyOwner {
        _transferFrom(_from, _to, _idx);
    }

    /// @dev We aren't calling {onERC721Received} on the _to address because rocks don't implement
    /// the {ERC721} interface, but we are including this function for compatibility with the {NFTVault} contract.
    /// Calling the {onERC721Received} function on the receiver contract could cause problems as we aren't sending an ERC721.
    /// @param _from The sender address
    /// @param _to The recipient address
    /// @param _idx The index of the rock to transfer
    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _idx
    ) external onlyOwner {
        _transferFrom(_from, _to, _idx);
    }

    /// @dev Implementation of {transferFrom} and {safeTransferFrom}. We are using {NFTEscrow} for atomic transfers.
    /// See {NFTEscrow} for more info
    /// @param _from The sender address
    /// @param _to The recipient address
    /// @param _idx The index of the rock to transfer
    function _transferFrom(
        address _from,
        address _to,
        uint256 _idx
    ) internal {
        IEtherRocks rocks = IEtherRocks(nftAddress);

        (address account,,,) = rocks.getRockInfo(_idx);

        //if the owner is this address we don't need to go through {NFTEscrow}
        if (account != address(this)) {
            _executeTransfer(_from, _idx);
        }

        (address newOwner,,,) = rocks.getRockInfo(_idx);

        require(
            newOwner == address(this), //this should never be false
            ""EtherRocksHelper: not_deposited""
        );

        //remove rock from sale
        rocks.dontSellRock(_idx);

        //If _to is the owner ({NFTVault}), we aren't sending the rock
        //since we'd have no way to get it back
        if (_to != owner()) rocks.giftRock(_idx, _to);
    }

    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable
    function renounceOwnership() public view override onlyOwner {
        revert(""Cannot renounce ownership"");
    }

    /// @dev The {giftRock} function is used as the escrow's payload.
    /// @param _idx The index of the rock that's going to be transferred using {NFTEscrow}
    function _encodeFlashEscrowPayload(uint256 _idx)
        internal
        view
        override
        returns (bytes memory)
    {
        return
            abi.encodeWithSignature(
                ""giftRock(uint256,address)"",
                _idx,
                address(this)
            );
    }
}",1040
RealWorld_TA_107_StableCoin_RealWorld_20240814224028.log,107,StableCoin,68357,2539,70896,147.0,0.392565,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol"";
import ""@openzeppelin/contracts/access/AccessControlEnumerable.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";

 /// @title PUSD - JPEG'd Stablecoin
 /// @notice PUSD is minted by the {NFTVault} (backed by NFTs) and the {AssetVaultForDAO} (backed by fungible assets)
 /// @dev Roles (at launch)
 /// DEFAULT_ADMIN_ROLE: DAO
 /// MINTER_ROLE: Vaults ({AssetVaultForDAO} and {NFTVault})
 /// PAUSER_ROLE: None
contract StableCoin is
    Context,
    AccessControlEnumerable,
    ERC20Burnable,
    ERC20Pausable
{
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

    constructor() ERC20(""Stablecoin"", ""PUSD"") {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
    }

    /// @dev Creates `amount` tokens and assigns them to `account`, increasing
    /// the total supply.
    ///
    /// Emits a {Transfer} event with `from` set to the zero address.
    ///
    /// Requirements:
    ///
    /// - `account` cannot be the zero address.
    ///
    function mint(address to, uint256 amount) external {
        require(
            hasRole(MINTER_ROLE, _msgSender()),
            ""StableCoin: must have minter role to mint""
        );
        _mint(to, amount);
    }

    /// @dev Triggers stopped state.
    ///
    /// Requirements:
    ///
    /// - The contract must not be paused.
    ///
    function pause() external {
        require(
            hasRole(PAUSER_ROLE, _msgSender()),
            ""StableCoin: must have pauser role to pause""
        );
        _pause();
    }

    /// @dev Returns to normal state.
    ///
    /// Requirements:
    ///
    /// - The contract must be paused.
    ///
    function unpause() external {
        require(
            hasRole(PAUSER_ROLE, _msgSender()),
            ""StableCoin: must have pauser role to unpause""
        );
        _unpause();
    }

    //override required by solidity
    /// @inheritdoc ERC20Pausable
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override(ERC20, ERC20Pausable) {
        super._beforeTokenTransfer(from, to, amount);
    }
}",613
RealWorld_TA_107_MockBooster_RealWorld_20240814215527.log,107,MockBooster,30920,2439,33359,134.0,0.20338,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/IBooster.sol"";

contract MockBooster is IBooster {
    IERC20 internal poolToken;
    address internal recipient;

    constructor(IERC20 _poolToken, address _recipient) {
        poolToken = _poolToken;
        recipient = _recipient;
    }

    function depositAll(uint256, bool) external override returns (bool) {
        poolToken.transferFrom(
            msg.sender,
            recipient,
            poolToken.balanceOf(msg.sender)
        );
        return true;
    }
}",143
RealWorld_TA_107_IERC20Decimals_RealWorld_20240814225522.log,107,IERC20Decimals,23114,1297,24411,123.0,0.14151,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface IERC20Decimals is IERC20Upgradeable {
    function decimals() external returns (uint8);
}",66
RealWorld_TA_107_IBooster_RealWorld_20240814225117.log,107,IBooster,22077,1403,23480,110.0,0.138445,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IBooster {
    function depositAll(uint256 _pid, bool _stake) external returns (bool);
}",45
RealWorld_TA_107_IJPEGLock_RealWorld_20240814224717.log,107,IJPEGLock,24277,1804,26081,127.0,0.157465,"// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

interface IJPEGLock {
    function lockFor(
        address _account,
        uint256 _punkIndex,
        uint256 _lockAmount
    ) external;

    function setLockTime(uint256 lockTime) external;
}",68
RealWorld_TA_109_IERC20BurnFrom_RealWorld_20240815001353.log,109,IERC20BurnFrom,21515,1657,23172,131.0,0.140715,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

interface IERC20BurnFrom {
    function burnFrom(address account, uint256 amount) external;
}",37
RealWorld_TA_109_AdminMultisigBase_RealWorld_20240814235043.log,109,AdminMultisigBase,147884,3418,151302,134.0,0.80778,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { EternalStorage } from './EternalStorage.sol';

contract AdminMultisigBase is EternalStorage {
    error NotAdmin();
    error AlreadyVoted();
    error InvalidAdmins();
    error InvalidAdminThreshold();
    error DuplicateAdmin(address admin);

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_ADMIN_EPOCH = keccak256('admin-epoch');

    bytes32 internal constant PREFIX_ADMIN = keccak256('admin');
    bytes32 internal constant PREFIX_ADMIN_COUNT = keccak256('admin-count');
    bytes32 internal constant PREFIX_ADMIN_THRESHOLD = keccak256('admin-threshold');
    bytes32 internal constant PREFIX_ADMIN_VOTE_COUNTS = keccak256('admin-vote-counts');
    bytes32 internal constant PREFIX_ADMIN_VOTED = keccak256('admin-voted');
    bytes32 internal constant PREFIX_IS_ADMIN = keccak256('is-admin');

    modifier onlyAdmin() {
        uint256 adminEpoch = _adminEpoch();

        if (!_isAdmin(adminEpoch, msg.sender)) revert NotAdmin();

        bytes32 topic = keccak256(msg.data);

        // Check that admin has not voted, then record that they have voted.
        if (_hasVoted(adminEpoch, topic, msg.sender)) revert AlreadyVoted();

        _setHasVoted(adminEpoch, topic, msg.sender, true);

        // Determine the new vote count and update it.
        uint256 adminVoteCount = _getVoteCount(adminEpoch, topic) + uint256(1);
        _setVoteCount(adminEpoch, topic, adminVoteCount);

        // Do not proceed with operation execution if insufficient votes.
        if (adminVoteCount < _getAdminThreshold(adminEpoch)) return;

        _;

        // Clear vote count and voted booleans.
        _setVoteCount(adminEpoch, topic, uint256(0));

        uint256 adminCount = _getAdminCount(adminEpoch);

        for (uint256 i; i < adminCount; i++) {
            _setHasVoted(adminEpoch, topic, _getAdmin(adminEpoch, i), false);
        }
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getAdminKey(uint256 adminEpoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN, adminEpoch, index));
    }

    function _getAdminCountKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_COUNT, adminEpoch));
    }

    function _getAdminThresholdKey(uint256 adminEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_THRESHOLD, adminEpoch));
    }

    function _getAdminVoteCountsKey(uint256 adminEpoch, bytes32 topic) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTE_COUNTS, adminEpoch, topic));
    }

    function _getAdminVotedKey(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_ADMIN_VOTED, adminEpoch, topic, account));
    }

    function _getIsAdminKey(uint256 adminEpoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_ADMIN, adminEpoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _adminEpoch() internal view returns (uint256) {
        return getUint(KEY_ADMIN_EPOCH);
    }

    function _getAdmin(uint256 adminEpoch, uint256 index) internal view returns (address) {
        return getAddress(_getAdminKey(adminEpoch, index));
    }

    function _getAdminCount(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminCountKey(adminEpoch));
    }

    function _getAdminThreshold(uint256 adminEpoch) internal view returns (uint256) {
        return getUint(_getAdminThresholdKey(adminEpoch));
    }

    function _getVoteCount(uint256 adminEpoch, bytes32 topic) internal view returns (uint256) {
        return getUint(_getAdminVoteCountsKey(adminEpoch, topic));
    }

    function _hasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account
    ) internal view returns (bool) {
        return getBool(_getAdminVotedKey(adminEpoch, topic, account));
    }

    function _isAdmin(uint256 adminEpoch, address account) internal view returns (bool) {
        return getBool(_getIsAdminKey(adminEpoch, account));
    }

    /***********\
    |* Setters *|
    \***********/

    function _setAdminEpoch(uint256 adminEpoch) internal {
        _setUint(KEY_ADMIN_EPOCH, adminEpoch);
    }

    function _setAdmin(
        uint256 adminEpoch,
        uint256 index,
        address account
    ) internal {
        _setAddress(_getAdminKey(adminEpoch, index), account);
    }

    function _setAdminCount(uint256 adminEpoch, uint256 adminCount) internal {
        _setUint(_getAdminCountKey(adminEpoch), adminCount);
    }

    function _setAdmins(
        uint256 adminEpoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 adminLength = accounts.length;

        if (adminLength < threshold) revert InvalidAdmins();

        if (threshold == uint256(0)) revert InvalidAdminThreshold();

        _setAdminThreshold(adminEpoch, threshold);
        _setAdminCount(adminEpoch, adminLength);

        for (uint256 i; i < adminLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an admin for this epoch.
            if (_isAdmin(adminEpoch, account)) revert DuplicateAdmin(account);

            // Set this account as the i-th admin in this epoch (needed to we can clear topic votes in `onlyAdmin`).
            _setAdmin(adminEpoch, i, account);
            _setIsAdmin(adminEpoch, account, true);
        }
    }

    function _setAdminThreshold(uint256 adminEpoch, uint256 adminThreshold) internal {
        _setUint(_getAdminThresholdKey(adminEpoch), adminThreshold);
    }

    function _setVoteCount(
        uint256 adminEpoch,
        bytes32 topic,
        uint256 voteCount
    ) internal {
        _setUint(_getAdminVoteCountsKey(adminEpoch, topic), voteCount);
    }

    function _setHasVoted(
        uint256 adminEpoch,
        bytes32 topic,
        address account,
        bool voted
    ) internal {
        _setBool(_getAdminVotedKey(adminEpoch, topic, account), voted);
    }

    function _setIsAdmin(
        uint256 adminEpoch,
        address account,
        bool isAdmin
    ) internal {
        _setBool(_getIsAdminKey(adminEpoch, account), isAdmin);
    }
}",1525
RealWorld_TA_109_BurnableMintableCappedERC20_RealWorld_20240815000313.log,109,BurnableMintableCappedERC20,62829,3718,66547,123.0,0.388505,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { MintableCappedERC20 } from './MintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { EternalStorage } from './EternalStorage.sol';

contract BurnableMintableCappedERC20 is MintableCappedERC20 {
    // keccak256('token-frozen')
    bytes32 private constant PREFIX_TOKEN_FROZEN =
        bytes32(0x1a7261d3a36c4ce4235d10859911c9444a6963a3591ec5725b96871d9810626b);

    // keccak256('all-tokens-frozen')
    bytes32 private constant KEY_ALL_TOKENS_FROZEN =
        bytes32(0x75a31d1ce8e5f9892188befc328d3b9bd3fa5037457e881abc21f388471b8d96);

    event Frozen(address indexed owner);
    event Unfrozen(address indexed owner);

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) MintableCappedERC20(name, symbol, decimals, capacity) {}

    function depositAddress(bytes32 salt) public view returns (address) {
        /* Convert a hash which is bytes32 to an address which is 20-byte long
        according to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=create2#salted-contract-creations-create2 */
        return
            address(
                uint160(
                    uint256(
                        keccak256(
                            abi.encodePacked(
                                bytes1(0xff),
                                owner,
                                salt,
                                keccak256(abi.encodePacked(type(DepositHandler).creationCode))
                            )
                        )
                    )
                )
            );
    }

    function burn(bytes32 salt) public onlyOwner {
        address account = depositAddress(salt);
        _burn(account, balanceOf[account]);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256
    ) internal view override {
        require(!EternalStorage(owner).getBool(KEY_ALL_TOKENS_FROZEN), 'IS_FROZEN');
        require(!EternalStorage(owner).getBool(keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol))), 'IS_FROZEN');
    }
}",528
RealWorld_TA_109_IAxelarGatewaySinglesig_RealWorld_20240815001812.log,109,IAxelarGatewaySinglesig,26700,1458,28158,108.0,0.16266,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './IAxelarGateway.sol';

interface IAxelarGatewaySinglesig is IAxelarGateway {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator);

    function owner() external view returns (address);

    function operator() external view returns (address);
}",101
RealWorld_TA_109_MintableCappedERC20_RealWorld_20240814235259.log,109,MintableCappedERC20,41384,3405,44789,130.0,0.27502,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { ERC20 } from './ERC20.sol';
import { ERC20Permit } from './ERC20Permit.sol';
import { Ownable } from './Ownable.sol';

contract MintableCappedERC20 is ERC20, ERC20Permit, Ownable, IERC20BurnFrom {
    uint256 public cap;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 capacity
    ) ERC20(name, symbol, decimals) ERC20Permit(name) Ownable() {
        cap = capacity;
    }

    function mint(address account, uint256 amount) public onlyOwner {
        uint256 capacity = cap;
        require(capacity == 0 || totalSupply + amount <= capacity, 'CAP_EXCEEDED');

        _mint(account, amount);
    }

    // TODO move burnFrom into a separate BurnableERC20 contract
    function burnFrom(address account, uint256 amount) external onlyOwner {
        _approve(account, owner, allowance[account][owner] - amount);
        _burn(account, amount);
    }
}",259
RealWorld_TA_109_ECDSA_RealWorld_20240814234424.log,109,ECDSA,94105,1262,95367,135.0,0.495765,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    error InvalidSignatureLength();
    error InvalidS();
    error InvalidV();
    error InvalidSignature();

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address signer) {
        // Check the signature length
        if (signature.length != 65) revert InvalidSignatureLength();

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();

        if (v != 27 && v != 28) revert InvalidV();

        // If the signature is valid (and not malleable), return the signer address
        if ((signer = ecrecover(hash, v, r, s)) == address(0)) revert InvalidSignature();
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n32', hash));
    }
}",901
RealWorld_TA_109_IERC20_RealWorld_20240815001131.log,109,IERC20,70082,1414,71496,139.0,0.37869,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",617
RealWorld_TA_109_IAxelarExecutable_RealWorld_20240815001606.log,109,IAxelarExecutable,51071,2009,53080,124.0,0.295535,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './IAxelarGateway.sol';

abstract contract IAxelarExecutable {
    error NotApprovedByGateway();

    IAxelarGateway public gateway;

    constructor(address gateway_) {
        gateway = IAxelarGateway(gateway_);
    }

    function execute(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload
    ) external {
        bytes32 payloadHash = keccak256(payload);
        if (!IAxelarGateway(gateway).validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))
            revert NotApprovedByGateway();
        _execute(sourceChain, sourceAddress, payload);
    }

    function executeWithToken(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) external {
        bytes32 payloadHash = keccak256(payload);
        if (
            !IAxelarGateway(gateway).validateContractCallAndMint(
                commandId,
                sourceChain,
                sourceAddress,
                payloadHash,
                tokenSymbol,
                amount
            )
        ) revert NotApprovedByGateway();

        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);
    }

    function _getTokenAddress(string memory tokenSymbol) internal view returns (address) {
        return IAxelarGateway(gateway).tokenAddresses(tokenSymbol);
    }

    function _execute(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload
    ) internal virtual {}

    function _executeWithToken(
        string memory sourceChain,
        string memory sourceAddress,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) internal virtual {}
}",398
RealWorld_TA_109_AxelarGatewaySinglesig_RealWorld_20240814234122.log,109,AxelarGatewaySinglesig,225569,4208,229777,179.0,1.212005,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGatewaySinglesig } from './interfaces/IAxelarGatewaySinglesig.sol';

import { ECDSA } from './ECDSA.sol';
import { AxelarGateway } from './AxelarGateway.sol';

contract AxelarGatewaySinglesig is IAxelarGatewaySinglesig, AxelarGateway {
    error InvalidAddress();
    error NotProxy();
    error InvalidChainId();
    error InvalidCommands();

    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');

    bytes32 internal constant PREFIX_OWNER = keccak256('owner');

    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');

    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');

    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOwnerKey(uint256 ownerEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER, ownerEpoch));
    }

    function _getOperatorKey(uint256 operatorEpoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR, operatorEpoch));
    }

    /***********\
    |* Getters *|
    \***********/

    function _ownerEpoch() internal view returns (uint256) {
        return getUint(KEY_OWNER_EPOCH);
    }

    function _getOwner(uint256 ownerEpoch) internal view returns (address) {
        return getAddress(_getOwnerKey(ownerEpoch));
    }

    /// @dev Returns true if a `account` is owner within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).
    function _isValidPreviousOwner(address account) internal view returns (bool) {
        uint256 ownerEpoch = _ownerEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOwnerEpoch = ownerEpoch > recentEpochs ? ownerEpoch - recentEpochs : uint256(0);

        --ownerEpoch;
        while (ownerEpoch > lowerBoundOwnerEpoch) {
            if (account == _getOwner(ownerEpoch--)) return true;
        }

        return false;
    }

    function owner() public view override returns (address) {
        return _getOwner(_ownerEpoch());
    }

    function _operatorEpoch() internal view returns (uint256) {
        return getUint(KEY_OPERATOR_EPOCH);
    }

    function _getOperator(uint256 operatorEpoch) internal view returns (address) {
        return getAddress(_getOperatorKey(operatorEpoch));
    }

    /// @dev Returns true if a `account` is operator within the last `OLD_KEY_RETENTION + 1` operator epochs.
    function _isValidRecentOperator(address account) internal view returns (bool) {
        uint256 operatorEpoch = _operatorEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOperatorEpoch = operatorEpoch > recentEpochs ? operatorEpoch - recentEpochs : uint256(0);

        while (operatorEpoch > lowerBoundOperatorEpoch) {
            if (account == _getOperator(operatorEpoch--)) return true;
        }

        return false;
    }

    function operator() public view override returns (address) {
        return _getOperator(_operatorEpoch());
    }

    /***********\
    |* Setters *|
    \***********/

    function _setOwnerEpoch(uint256 ownerEpoch) internal {
        _setUint(KEY_OWNER_EPOCH, ownerEpoch);
    }

    function _setOwner(uint256 ownerEpoch, address account) internal {
        _setAddress(_getOwnerKey(ownerEpoch), account);
    }

    function _setOperatorEpoch(uint256 operatorEpoch) internal {
        _setUint(KEY_OPERATOR_EPOCH, operatorEpoch);
    }

    function _setOperator(uint256 operatorEpoch, address account) internal {
        _setAddress(_getOperatorKey(operatorEpoch), account);
    }

    /**********************\
    |* Self Functionality *|
    \**********************/

    function deployToken(bytes calldata params, bytes32) external onlySelf {
        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(
            params,
            (string, string, uint8, uint256, address)
        );

        _deployToken(name, symbol, decimals, cap, tokenAddr);
    }

    function mintToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));

        _mintToken(symbol, account, amount);
    }

    function burnToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));

        _burnToken(symbol, salt);
    }

    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));

        _approveContractCall(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            string memory symbol,
            uint256 amount,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));

        _approveContractCallWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function transferOwnership(bytes calldata params, bytes32) external onlySelf {
        address newOwner = abi.decode(params, (address));
        uint256 ownerEpoch = _ownerEpoch();

        if (newOwner == address(0)) revert InvalidAddress();

        emit OwnershipTransferred(_getOwner(ownerEpoch), newOwner);

        _setOwnerEpoch(++ownerEpoch);
        _setOwner(ownerEpoch, newOwner);
    }

    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {
        address newOperator = abi.decode(params, (address));

        if (newOperator == address(0)) revert InvalidAddress();

        emit OperatorshipTransferred(operator(), newOperator);

        uint256 operatorEpoch = _operatorEpoch();
        _setOperatorEpoch(++operatorEpoch);
        _setOperator(operatorEpoch, newOperator);
    }

    /**************************\
    |* External Functionality *|
    \**************************/

    function setup(bytes calldata params) external override {
        // Prevent setup from being called on a non-proxy (the implementation).
        if (implementation() == address(0)) revert NotProxy();

        (address[] memory adminAddresses, uint256 adminThreshold, address ownerAddress, address operatorAddress) = abi
            .decode(params, (address[], uint256, address, address));

        uint256 adminEpoch = _adminEpoch() + uint256(1);
        _setAdminEpoch(adminEpoch);
        _setAdmins(adminEpoch, adminAddresses, adminThreshold);

        uint256 ownerEpoch = _ownerEpoch() + uint256(1);
        _setOwnerEpoch(ownerEpoch);
        _setOwner(ownerEpoch, ownerAddress);

        uint256 operatorEpoch = _operatorEpoch() + uint256(1);
        _setOperatorEpoch(operatorEpoch);
        _setOperator(operatorEpoch, operatorAddress);

        emit OwnershipTransferred(address(0), ownerAddress);
        emit OperatorshipTransferred(address(0), operatorAddress);
    }

    function execute(bytes calldata input) external override {
        (bytes memory data, bytes memory signature) = abi.decode(input, (bytes, bytes));

        _execute(data, signature);
    }

    function _execute(bytes memory data, bytes memory sig) internal {
        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), sig);

        (
            uint256 chainId,
            Role signerRole,
            bytes32[] memory commandIds,
            string[] memory commands,
            bytes[] memory params
        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));

        if (chainId != block.chainid) revert InvalidChainId();

        uint256 commandsLength = commandIds.length;

        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();

        bool isCurrentOwner;
        bool isValidRecentOwner;
        bool isValidRecentOperator;

        if (signerRole == Role.Owner) {
            isCurrentOwner = signer == owner();
            isValidRecentOwner = isCurrentOwner || _isValidPreviousOwner(signer);
        } else if (signerRole == Role.Operator) {
            isValidRecentOperator = _isValidRecentOperator(signer);
        }

        for (uint256 i; i < commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.deployToken.selector;
            } else if (commandHash == SELECTOR_MINT_TOKEN) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.mintToken.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.approveContractCall.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.approveContractCallWithMint.selector;
            } else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!isValidRecentOperator && !isValidRecentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!isCurrentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!isCurrentOwner) continue;

                commandSelector = AxelarGatewaySinglesig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }
}",2452
RealWorld_TA_109_AddressFormat_RealWorld_20240815000959.log,109,AddressFormat,33512,1131,34643,90.0,0.19018,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

library AddressFormat {
    function toLowerString(address a) internal pure returns (string memory) {
        bytes memory data = abi.encodePacked(a);
        bytes memory characters = '0123456789abcdef';
        bytes memory byteString = new bytes(2 + data.length * 2);

        byteString[0] = '0';
        byteString[1] = 'x';

        for (uint256 i = 0; i < data.length; i++) {
            byteString[2 + i * 2] = characters[uint256(uint8(data[i] >> 4))];
            byteString[3 + i * 2] = characters[uint256(uint8(data[i] & 0x0f))];
        }
        return string(byteString);
    }
}",178
RealWorld_TA_109_TokenSwapper_RealWorld_20240815000729.log,109,TokenSwapper,38707,4829,43536,148.0,0.290115,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IERC20 } from '../interfaces/IERC20.sol';

contract TokenSwapper {
    address tokenA;
    address tokenB;

    constructor(address tokenA_, address tokenB_) {
        tokenA = tokenA_;
        tokenB = tokenB_;
    }

    function swap(
        address tokenAddress,
        uint256 amount,
        address toTokenAddress,
        address recipient
    ) external returns (uint256 convertedAmount) {
        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);

        if (tokenAddress == tokenA) {
            require(toTokenAddress == tokenB, 'WRONG TOKEN PAIR');
            convertedAmount = amount * 2;
        } else {
            require(tokenAddress == tokenB && toTokenAddress == tokenA, 'WRONG TOKEN PAIR');
            convertedAmount = amount / 2;
        }

        IERC20(toTokenAddress).transfer(recipient, convertedAmount);
    }
}",215
RealWorld_TA_109_AxelarGatewayMultisig_RealWorld_20240814233801.log,109,AxelarGatewayMultisig,399958,4722,404680,199.0,2.09423,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';

import { ECDSA } from './ECDSA.sol';
import { AxelarGateway } from './AxelarGateway.sol';

contract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {
    error InvalidAddress();
    error InvalidOwners();
    error InvalidOwnerThreshold();
    error DuplicateOwner(address owner);
    error InvalidOperators();
    error InvalidOperatorThreshold();
    error DuplicateOperator(address operator);
    error NotProxy();
    error InvalidChainId();
    error MalformedSigners();
    error InvalidCommands();

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');

    bytes32 internal constant PREFIX_OWNER = keccak256('owner');
    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');
    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');
    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');

    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');

    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');
    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');
    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');
    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');

    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}

    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {
        for (uint256 i; i < accounts.length - 1; ++i) {
            if (accounts[i] >= accounts[i + 1]) {
                return false;
            }
        }

        return true;
    }

    /************************\
    |* Owners Functionality *|
    \************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));
    }

    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));
    }

    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));
    }

    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _ownerEpoch() internal view returns (uint256) {
        return getUint(KEY_OWNER_EPOCH);
    }

    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {
        return getAddress(_getOwnerKey(epoch, index));
    }

    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOwnerCountKey(epoch));
    }

    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOwnerThresholdKey(epoch));
    }

    function _isOwner(uint256 epoch, address account) internal view returns (bool) {
        return getBool(_getIsOwnerKey(epoch, account));
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).
    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {
        uint256 epoch = _ownerEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);

        --epoch;
        while (epoch > lowerBoundOwnerEpoch) {
            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;
        }

        return false;
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.
    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {
        uint256 threshold = _getOwnerThreshold(epoch);
        uint256 validSignerCount;

        for (uint256 i; i < accounts.length; i++) {
            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;
        }

        return false;
    }

    /// @dev Returns the current `ownerEpoch`.
    function ownerEpoch() external view override returns (uint256) {
        return _ownerEpoch();
    }

    /// @dev Returns the threshold for a given `ownerEpoch`.
    function ownerThreshold(uint256 epoch) external view override returns (uint256) {
        return _getOwnerThreshold(epoch);
    }

    /// @dev Returns the array of owners within a given `ownerEpoch`.
    function owners(uint256 epoch) public view override returns (address[] memory results) {
        uint256 ownerCount = _getOwnerCount(epoch);
        results = new address[](ownerCount);

        for (uint256 i; i < ownerCount; i++) {
            results[i] = _getOwner(epoch, i);
        }
    }

    /***********\
    |* Setters *|
    \***********/

    function _setOwnerEpoch(uint256 epoch) internal {
        _setUint(KEY_OWNER_EPOCH, epoch);
    }

    function _setOwner(
        uint256 epoch,
        uint256 index,
        address account
    ) internal {
        if (account == address(0)) revert InvalidAddress();

        _setAddress(_getOwnerKey(epoch, index), account);
    }

    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {
        _setUint(_getOwnerCountKey(epoch), ownerCount);
    }

    function _setOwners(
        uint256 epoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        if (accountLength < threshold) revert InvalidOwners();

        if (threshold == uint256(0)) revert InvalidOwnerThreshold();

        _setOwnerThreshold(epoch, threshold);
        _setOwnerCount(epoch, accountLength);

        for (uint256 i; i < accountLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an owner for this ownerEpoch.
            if (_isOwner(epoch, account)) revert DuplicateOwner(account);

            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).
            _setOwner(epoch, i, account);
            _setIsOwner(epoch, account, true);
        }
    }

    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {
        _setUint(_getOwnerThresholdKey(epoch), threshold);
    }

    function _setIsOwner(
        uint256 epoch,
        address account,
        bool isOwner
    ) internal {
        _setBool(_getIsOwnerKey(epoch, account), isOwner);
    }

    /**************************\
    |* Operator Functionality *|
    \**************************/

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));
    }

    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));
    }

    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));
    }

    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));
    }

    /***********\
    |* Getters *|
    \***********/

    function _operatorEpoch() internal view returns (uint256) {
        return getUint(KEY_OPERATOR_EPOCH);
    }

    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {
        return getAddress(_getOperatorKey(epoch, index));
    }

    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOperatorCountKey(epoch));
    }

    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {
        return getUint(_getOperatorThresholdKey(epoch));
    }

    function _isOperator(uint256 epoch, address account) internal view returns (bool) {
        return getBool(_getIsOperatorKey(epoch, account));
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.
    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {
        uint256 epoch = _operatorEpoch();
        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);
        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);

        while (epoch > lowerBoundOperatorEpoch) {
            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;
        }

        return false;
    }

    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.
    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {
        uint256 threshold = _getOperatorThreshold(epoch);
        uint256 validSignerCount;

        for (uint256 i; i < accounts.length; i++) {
            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;
        }

        return false;
    }

    /// @dev Returns the current `operatorEpoch`.
    function operatorEpoch() external view override returns (uint256) {
        return _operatorEpoch();
    }

    /// @dev Returns the threshold for a given `operatorEpoch`.
    function operatorThreshold(uint256 epoch) external view override returns (uint256) {
        return _getOperatorThreshold(epoch);
    }

    /// @dev Returns the array of operators within a given `operatorEpoch`.
    function operators(uint256 epoch) public view override returns (address[] memory results) {
        uint256 operatorCount = _getOperatorCount(epoch);
        results = new address[](operatorCount);

        for (uint256 i; i < operatorCount; i++) {
            results[i] = _getOperator(epoch, i);
        }
    }

    /***********\
    |* Setters *|
    \***********/

    function _setOperatorEpoch(uint256 epoch) internal {
        _setUint(KEY_OPERATOR_EPOCH, epoch);
    }

    function _setOperator(
        uint256 epoch,
        uint256 index,
        address account
    ) internal {
        _setAddress(_getOperatorKey(epoch, index), account);
    }

    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {
        _setUint(_getOperatorCountKey(epoch), operatorCount);
    }

    function _setOperators(
        uint256 epoch,
        address[] memory accounts,
        uint256 threshold
    ) internal {
        uint256 accountLength = accounts.length;

        if (accountLength < threshold) revert InvalidOperators();

        if (threshold == uint256(0)) revert InvalidOperatorThreshold();

        _setOperatorThreshold(epoch, threshold);
        _setOperatorCount(epoch, accountLength);

        for (uint256 i; i < accountLength; i++) {
            address account = accounts[i];

            // Check that the account wasn't already set as an operator for this operatorEpoch.
            if (_isOperator(epoch, account)) revert DuplicateOperator(account);

            if (account == address(0)) revert InvalidAddress();

            // Set this account as the i-th operator in this operatorEpoch (needed to we can get all the operators for `operators`).
            _setOperator(epoch, i, account);
            _setIsOperator(epoch, account, true);
        }
    }

    function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {
        _setUint(_getOperatorThresholdKey(epoch), threshold);
    }

    function _setIsOperator(
        uint256 epoch,
        address account,
        bool isOperator
    ) internal {
        _setBool(_getIsOperatorKey(epoch, account), isOperator);
    }

    /**********************\
    |* Self Functionality *|
    \**********************/

    function deployToken(bytes calldata params, bytes32) external onlySelf {
        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(
            params,
            (string, string, uint8, uint256, address)
        );

        _deployToken(name, symbol, decimals, cap, tokenAddr);
    }

    function mintToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));

        _mintToken(symbol, account, amount);
    }

    function burnToken(bytes calldata params, bytes32) external onlySelf {
        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));

        _burnToken(symbol, salt);
    }

    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));

        _approveContractCall(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {
        (
            string memory sourceChain,
            string memory sourceAddress,
            address contractAddress,
            bytes32 payloadHash,
            string memory symbol,
            uint256 amount,
            bytes32 sourceTxHash,
            uint256 sourceEventIndex
        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));

        _approveContractCallWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function transferOwnership(bytes calldata params, bytes32) external onlySelf {
        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        uint256 epoch = _ownerEpoch();

        emit OwnershipTransferred(owners(epoch), _getOwnerThreshold(epoch), newOwners, newThreshold);

        _setOwnerEpoch(++epoch);
        _setOwners(epoch, newOwners, newThreshold);
    }

    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {
        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));

        uint256 epoch = _operatorEpoch();

        emit OperatorshipTransferred(operators(epoch), _getOperatorThreshold(epoch), newOperators, newThreshold);

        _setOperatorEpoch(++epoch);
        _setOperators(epoch, newOperators, newThreshold);
    }

    /**************************\
    |* External Functionality *|
    \**************************/

    function setup(bytes calldata params) external override {
        // Prevent setup from being called on a non-proxy (the implementation).
        if (implementation() == address(0)) revert NotProxy();

        (
            address[] memory adminAddresses,
            uint256 newAdminThreshold,
            address[] memory ownerAddresses,
            uint256 newOwnerThreshold,
            address[] memory operatorAddresses,
            uint256 newOperatorThreshold
        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));

        uint256 newAdminEpoch = _adminEpoch() + uint256(1);
        _setAdminEpoch(newAdminEpoch);
        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);

        uint256 newOwnerEpoch = _ownerEpoch() + uint256(1);
        _setOwnerEpoch(newOwnerEpoch);
        _setOwners(newOwnerEpoch, ownerAddresses, newOwnerThreshold);

        uint256 newOperatorEpoch = _operatorEpoch() + uint256(1);
        _setOperatorEpoch(newOperatorEpoch);
        _setOperators(newOperatorEpoch, operatorAddresses, newOperatorThreshold);

        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, newOwnerThreshold);
        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, newOperatorThreshold);
    }

    function execute(bytes calldata input) external override {
        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));

        _execute(data, signatures);
    }

    function _execute(bytes memory data, bytes[] memory signatures) internal {
        uint256 signatureCount = signatures.length;

        address[] memory signers = new address[](signatureCount);

        for (uint256 i; i < signatureCount; i++) {
            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);
        }

        (
            uint256 chainId,
            Role signersRole,
            bytes32[] memory commandIds,
            string[] memory commands,
            bytes[] memory params
        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));

        if (chainId != block.chainid) revert InvalidChainId();

        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();

        uint256 commandsLength = commandIds.length;

        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();

        bool areValidCurrentOwners;
        bool areValidRecentOwners;
        bool areValidRecentOperators;

        if (signersRole == Role.Owner) {
            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);
            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);
        } else if (signersRole == Role.Operator) {
            areValidRecentOperators = _areValidRecentOperators(signers);
        }

        for (uint256 i; i < commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.deployToken.selector;
            } else if (commandHash == SELECTOR_MINT_TOKEN) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.mintToken.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;
            } else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }
}",4538
RealWorld_TA_109_ERC20_RealWorld_20240814233110.log,109,ERC20,179158,2103,181261,150.0,0.93785,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IERC20 } from './interfaces/IERC20.sol';

import { Context } from './Context.sol';

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20 {
    mapping(address => uint256) public override balanceOf;

    mapping(address => mapping(address => uint256)) public override allowance;

    uint256 public override totalSupply;

    string public name;
    string public symbol;

    uint8 public immutable decimals;

    /**
     * @dev Sets the values for {name}, {symbol}, and {decimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_
    ) {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), allowance[sender][_msgSender()] - amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, allowance[_msgSender()][spender] - subtractedValue);
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), 'ZERO_ADDR');
        require(recipient != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(sender, recipient, amount);

        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(address(0), account, amount);

        totalSupply += amount;
        balanceOf[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), 'ZERO_ADDR');

        _beforeTokenTransfer(account, address(0), amount);

        balanceOf[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), 'ZERO_ADDR');
        require(spender != address(0), 'ZERO_ADDR');

        allowance[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}",1935
RealWorld_TA_109_ERC20Permit_RealWorld_20240814233544.log,109,ERC20Permit,61820,2066,63886,135.0,0.35042,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { ERC20 } from './ERC20.sol';

abstract contract ERC20Permit is ERC20 {
    bytes32 public DOMAIN_SEPARATOR;

    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\x19\x01';

    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')
    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH =
        bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);

    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')
    bytes32 private constant PERMIT_SIGNATURE_HASH =
        bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);

    mapping(address => uint256) public nonces;

    constructor(string memory name) {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                DOMAIN_TYPE_SIGNATURE_HASH,
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                block.chainid,
                address(this)
            )
        );
    }

    function permit(
        address issuer,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(block.timestamp < deadline, 'EXPIRED');
        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'INV_S');
        require(v == 27 || v == 28, 'INV_V');

        bytes32 digest = keccak256(
            abi.encodePacked(
                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))
            )
        );

        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == issuer, 'INV_SIG');

        // _approve will revert if issuer is address(0x0)
        _approve(issuer, spender, value);
    }
}",514
RealWorld_TA_109_IAxelarGatewayMultisig_RealWorld_20240815002218.log,109,IAxelarGatewayMultisig,33958,1216,35174,98.0,0.19411,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './IAxelarGateway.sol';

interface IAxelarGatewayMultisig is IAxelarGateway {
    event OwnershipTransferred(address[] preOwners, uint256 prevThreshold, address[] newOwners, uint256 newThreshold);

    event OperatorshipTransferred(
        address[] preOperators,
        uint256 prevThreshold,
        address[] newOperators,
        uint256 newThreshold
    );

    function ownerEpoch() external view returns (uint256);

    function ownerThreshold(uint256 epoch) external view returns (uint256);

    function owners(uint256 epoch) external view returns (address[] memory);

    function operatorEpoch() external view returns (uint256);

    function operatorThreshold(uint256 epoch) external view returns (uint256);

    function operators(uint256 epoch) external view returns (address[] memory);
}",192
RealWorld_TA_109_IAxelarGateway_RealWorld_20240815002002.log,109,IAxelarGateway,92714,2251,94965,133.0,0.50859,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

interface IAxelarGateway {
    /**********\
    |* Events *|
    \**********/

    event TokenSent(
        address indexed sender,
        string destinationChain,
        string destinationAddress,
        string symbol,
        uint256 amount
    );

    event ContractCall(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload
    );

    event ContractCallWithToken(
        address indexed sender,
        string destinationChain,
        string destinationContractAddress,
        bytes32 indexed payloadHash,
        bytes payload,
        string symbol,
        uint256 amount
    );

    event Executed(bytes32 indexed commandId);

    event TokenDeployed(string symbol, address tokenAddresses);

    event ContractCallApproved(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event ContractCallApprovedWithMint(
        bytes32 indexed commandId,
        string sourceChain,
        string sourceAddress,
        address indexed contractAddress,
        bytes32 indexed payloadHash,
        string symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    );

    event TokenFrozen(string symbol);

    event TokenUnfrozen(string symbol);

    event AllTokensFrozen();

    event AllTokensUnfrozen();

    event AccountBlacklisted(address indexed account);

    event AccountWhitelisted(address indexed account);

    event Upgraded(address indexed implementation);

    /******************\
    |* Public Methods *|
    \******************/

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external;

    function callContract(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload
    ) external;

    function callContractWithToken(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external;

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view returns (bool);

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view returns (bool);

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external returns (bool);

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external returns (bool);

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() external view returns (bool);

    function implementation() external view returns (address);

    function tokenAddresses(string memory symbol) external view returns (address);

    function tokenFrozen(string memory symbol) external view returns (bool);

    function isCommandExecuted(bytes32 commandId) external view returns (bool);

    function adminEpoch() external view returns (uint256);

    function adminThreshold(uint256 epoch) external view returns (uint256);

    function admins(uint256 epoch) external view returns (address[] memory);

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external;

    function unfreezeToken(string memory symbol) external;

    function freezeAllTokens() external;

    function unfreezeAllTokens() external;

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external;

    /**********************\
    |* External Functions *|
    \**********************/

    function setup(bytes calldata params) external;

    function execute(bytes calldata input) external;
}",886
RealWorld_TA_109_DestinationSwapExecutable_RealWorld_20240815000519.log,109,DestinationSwapExecutable,37903,3538,41441,128.0,0.260275,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';
import { IERC20 } from '../interfaces/IERC20.sol';
import { TokenSwapper } from './TokenSwapper.sol';

contract DestinationSwapExecutable is IAxelarExecutable {
    address swapper;

    constructor(address gatewayAddress, address swapperAddress) IAxelarExecutable(gatewayAddress) {
        swapper = swapperAddress;
    }

    function _executeWithToken(
        string memory,
        string memory,
        bytes calldata payload,
        string memory tokenSymbol,
        uint256 amount
    ) internal override {
        (address toTokenAddress, address recipient) = abi.decode(payload, (address, address));

        address tokenAddress = _getTokenAddress(tokenSymbol);
        IERC20(tokenAddress).approve(swapper, amount);
        TokenSwapper(swapper).swap(tokenAddress, amount, toTokenAddress, recipient);
    }
}",213
RealWorld_TA_109_Ownable_RealWorld_20240814233342.log,109,Ownable,29492,1780,31272,119.0,0.18306,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

abstract contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    modifier onlyOwner() {
        require(owner == msg.sender, 'NOT_OWNER');
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), 'ZERO_ADDR');

        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",132
RealWorld_TA_109_DepositHandler_RealWorld_20240814234641.log,109,DepositHandler,35007,4135,39142,137.0,0.257735,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

contract DepositHandler {
    uint256 internal constant IS_NOT_LOCKED = uint256(0);
    uint256 internal constant IS_LOCKED = uint256(1);

    uint256 internal _lockedStatus = IS_NOT_LOCKED;

    modifier noReenter() {
        require(_lockedStatus == IS_NOT_LOCKED);

        _lockedStatus = IS_LOCKED;
        _;
        _lockedStatus = IS_NOT_LOCKED;
    }

    function execute(address callee, bytes calldata data)
        external
        noReenter
        returns (bool success, bytes memory returnData)
    {
        (success, returnData) = callee.call(data);
    }

    function destroy(address etherDestination) external noReenter {
        selfdestruct(payable(etherDestination));
    }
}",175
RealWorld_TA_109_AxelarGatewayProxy_RealWorld_20240814232818.log,109,AxelarGatewayProxy,49905,4617,54522,169.0,0.341865,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';

import { EternalStorage } from './EternalStorage.sol';

contract AxelarGatewayProxy is EternalStorage {
    error SetupFailed();

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    constructor(address gatewayImplementation, bytes memory params) {
        _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);

        (bool success, ) = gatewayImplementation.delegatecall(
            abi.encodeWithSelector(IAxelarGateway.setup.selector, params)
        );

        if (!success) revert SetupFailed();
    }

    function setup(bytes calldata params) external {}

    fallback() external payable {
        address implementation = getAddress(KEY_IMPLEMENTATION);

        assembly {
            calldatacopy(0, 0, calldatasize())

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    receive() external payable {
        revert('NO_ETHER');
    }
}",347
RealWorld_TA_109_AxelarGateway_RealWorld_20240814235729.log,109,AxelarGateway,363031,4523,367554,225.0,1.905615,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';
import { IERC20 } from './interfaces/IERC20.sol';
import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { AdminMultisigBase } from './AdminMultisigBase.sol';
import { TokenDeployer } from './TokenDeployer.sol';

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    error NotSelf();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAmount();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error TokenIsFrozen(string symbol);

    enum Role {
        Admin,
        Owner,
        Operator
    }

    enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;

    constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }

    modifier onlySelf() {
        if (msg.sender != address(this)) revert NotSelf();

        _;
    }

    /******************\
    |* Public Methods *|
    \******************/

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);
    }

    function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    /// @dev Returns the current `adminEpoch`.
    function adminEpoch() external view override returns (uint256) {
        return _adminEpoch();
    }

    /// @dev Returns the admin threshold for a given `adminEpoch`.
    function adminThreshold(uint256 epoch) external view override returns (uint256) {
        return _getAdminThreshold(epoch);
    }

    /// @dev Returns the array of admins within a given `adminEpoch`.
    function admins(uint256 epoch) external view override returns (address[] memory results) {
        uint256 adminCount = _getAdminCount(epoch);
        results = new address[](adminCount);

        for (uint256 i; i < adminCount; i++) {
            results[i] = _getAdmin(epoch, i);
        }
    }

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external override onlyAdmin {
        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();

        emit Upgraded(newImplementation);

        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)
        //        if `upgrade` is entered within the context of _this_ implementation itself.
        if (setupParams.length > 0) {
            (bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );

            if (!success) revert SetupFailed();
        }

        _setImplementation(newImplementation);
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    function _burnTokenFrom(
        address sender,
        string memory symbol,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);
        if (amount == 0) revert InvalidAmount();

        TokenType tokenType = _getTokenType(symbol);
        bool burnSuccess;

        if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );

        if (!burnSuccess) revert BurnFailed(symbol);

        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));
    }

    function _deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        address tokenAddress
    ) internal {
        // Ensure that this symbol has not been taken.
        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);

        if (tokenAddress == address(0)) {
            // If token address is no specified, it indicates a request to deploy one.
            bytes32 salt = keccak256(abi.encodePacked(symbol));

            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(
                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)
            );

            if (!success) revert TokenDeployFailed(symbol);

            tokenAddress = abi.decode(data, (address));

            _setTokenType(symbol, TokenType.InternalBurnableFrom);
        } else {
            // If token address is specified, ensure that there is a contact at the specified addressed.
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.
            _setTokenType(symbol, TokenType.External);
        }

        _setTokenAddress(symbol, tokenAddress);

        emit TokenDeployed(symbol, tokenAddress);
    }

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            bool success = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)
            );

            if (!success) revert MintFailed(symbol);
        } else {
            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);
        }
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            DepositHandler depositHandler = new DepositHandler{ salt: salt }();

            (bool success, bytes memory returnData) = depositHandler.execute(
                tokenAddress,
                abi.encodeWithSelector(
                    IERC20.transfer.selector,
                    address(this),
                    IERC20(tokenAddress).balanceOf(address(depositHandler))
                )
            );

            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);

            depositHandler.destroy(address(this));
        } else {
            BurnableMintableCappedERC20(tokenAddress).burn(salt);
        }
    }

    function _approveContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function _approveContractCallWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }

    function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    /********************\
    |* Internal Methods *|
    \********************/

    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }

    /********************\
    |* Internal Getters *|
    \********************/

    function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }

    function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }

    /********************\
    |* Internal Setters *|
    \********************/

    function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }

    function _setTokenAddress(string memory symbol, address tokenAddress) internal {
        _setAddress(_getTokenAddressKey(symbol), tokenAddress);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }

    function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}",4083
RealWorld_TA_109_EternalStorage_RealWorld_20240815000117.log,109,EternalStorage,66045,1645,67690,114.0,0.363125,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/**
 * @title EternalStorage
 * @dev This contract holds all the necessary state variables to carry out the storage of any contract.
 */
contract EternalStorage {
    mapping(bytes32 => uint256) private _uintStorage;
    mapping(bytes32 => string) private _stringStorage;
    mapping(bytes32 => address) private _addressStorage;
    mapping(bytes32 => bytes) private _bytesStorage;
    mapping(bytes32 => bool) private _boolStorage;
    mapping(bytes32 => int256) private _intStorage;

    // *** Getter Methods ***
    function getUint(bytes32 key) public view returns (uint256) {
        return _uintStorage[key];
    }

    function getString(bytes32 key) public view returns (string memory) {
        return _stringStorage[key];
    }

    function getAddress(bytes32 key) public view returns (address) {
        return _addressStorage[key];
    }

    function getBytes(bytes32 key) public view returns (bytes memory) {
        return _bytesStorage[key];
    }

    function getBool(bytes32 key) public view returns (bool) {
        return _boolStorage[key];
    }

    function getInt(bytes32 key) public view returns (int256) {
        return _intStorage[key];
    }

    // *** Setter Methods ***
    function _setUint(bytes32 key, uint256 value) internal {
        _uintStorage[key] = value;
    }

    function _setString(bytes32 key, string memory value) internal {
        _stringStorage[key] = value;
    }

    function _setAddress(bytes32 key, address value) internal {
        _addressStorage[key] = value;
    }

    function _setBytes(bytes32 key, bytes memory value) internal {
        _bytesStorage[key] = value;
    }

    function _setBool(bytes32 key, bool value) internal {
        _boolStorage[key] = value;
    }

    function _setInt(bytes32 key, int256 value) internal {
        _intStorage[key] = value;
    }

    // *** Delete Methods ***
    function _deleteUint(bytes32 key) internal {
        delete _uintStorage[key];
    }

    function _deleteString(bytes32 key) internal {
        delete _stringStorage[key];
    }

    function _deleteAddress(bytes32 key) internal {
        delete _addressStorage[key];
    }

    function _deleteBytes(bytes32 key) internal {
        delete _bytesStorage[key];
    }

    function _deleteBool(bytes32 key) internal {
        delete _boolStorage[key];
    }

    function _deleteInt(bytes32 key) internal {
        delete _intStorage[key];
    }
}",560
RealWorld_TA_109_Context_RealWorld_20240814235511.log,109,Context,34914,1359,36273,136.0,0.20175,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}",195
RealWorld_TA_109_TokenDeployer_RealWorld_20240814234900.log,109,TokenDeployer,28184,1884,30068,101.0,0.1786,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';

contract TokenDeployer {
    function deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        bytes32 salt
    ) external returns (address tokenAddress) {
        tokenAddress = address(new BurnableMintableCappedERC20{ salt: salt }(name, symbol, decimals, cap));
    }
}",117
RealWorld_TA_110_test_RealWorld_20240815003709.log,110,test,314796,1665,316461,156.0,1.60728,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log                    (string);
    event logs                   (bytes);

    event log_address            (address);
    event log_bytes32            (bytes32);
    event log_int                (int);
    event log_uint               (uint);
    event log_bytes              (bytes);
    event log_string             (string);

    event log_named_address      (string key, address val);
    event log_named_bytes32      (string key, bytes32 val);
    event log_named_decimal_int  (string key, int val, uint decimals);
    event log_named_decimal_uint (string key, uint val, uint decimals);
    event log_named_int          (string key, int val);
    event log_named_uint         (string key, uint val);
    event log_named_bytes        (string key, bytes val);
    event log_named_string       (string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));

    modifier mayRevert() { _; }
    modifier testopts(string memory) { _; }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint startGas = gasleft();
        _;
        uint endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }
    function assertEq(address a, address b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }
    function assertEq(bytes32 a, bytes32 b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }
    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
        assertEq(a, b, err);
    }

    function assertEq(int a, int b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }
    function assertEq(int a, int b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq(uint a, uint b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }
    function assertEq(uint a, uint b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEqDecimal(int a, int b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint a, uint b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGt(uint a, uint b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGt(int a, int b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGt(int a, int b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGtDecimal(int a, int b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint a, uint b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGe(uint a, uint b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGe(int a, int b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGe(int a, int b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGeDecimal(int a, int b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint a, uint b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLt(uint a, uint b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLt(int a, int b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLt(int a, int b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLtDecimal(int a, int b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint a, uint b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLe(uint a, uint b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLe(int a, int b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLe(int a, int b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLeDecimal(int a, int b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }
    function assertEq(string memory a, string memory b, string memory err) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
        ok = true;
        if (a.length == b.length) {
            for (uint i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }
    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }
    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3539
RealWorld_TA_110_demo_RealWorld_20240815003948.log,110,demo,189982,1782,191764,124.0,0.98555,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.4.23;

import ""../src/test.sol"";

contract DemoTest is DSTest {
    function test_this() public pure {
        require(true);
    }
    function test_logs() public {
        emit log(""-- log(string)"");
        emit log(""a string"");

        emit log(""-- log_named_uint(string, uint)"");
        log_named_uint(""uint"", 512);

        emit log(""-- log_named_int(string, int)"");
        log_named_int(""int"", -512);

        emit log(""-- log_named_address(string, address)"");
        log_named_address(""address"", address(this));

        emit log(""-- log_named_bytes32(string, bytes32)"");
        log_named_bytes32(""bytes32"", ""a string"");

        emit log(""-- log_named_bytes(string, bytes)"");
        log_named_bytes(""bytes"", hex""cafefe"");

        emit log(""-- log_named_string(string, string)"");
        log_named_string(""string"", ""a string"");

        emit log(""-- log_named_decimal_uint(string, uint, uint)"");
        log_named_decimal_uint(""decimal uint"", 1.0e18, 18);

        emit log(""-- log_named_decimal_int(string, int, uint)"");
        log_named_decimal_int(""decimal int"", -1.0e18, 18);
    }
    event log_old_named_uint(bytes32,uint);
    function test_old_logs() public {
        log_old_named_uint(""key"", 500);
        log_named_bytes32(""bkey"", ""val"");
    }
    function test_trace() public view {
        this.echo(""string 1"", ""string 2"");
    }
    function test_multiline() public {
        emit log(""a multiline\\n"" ""string"");
        emit log(""a multiline "" ""string"");
        log_bytes(""a string"");
        log_bytes(""a multiline\n"" ""string"");
        log_bytes(""a multiline\\n"" ""string"");
        emit log(unicode""Ώ"");
        logs(hex""0000"");
        log_named_bytes(""0x0000"", hex""0000"");
        logs(hex""ff"");
    }
    function echo(string memory s1, string memory s2) public pure
        returns (string memory, string memory)
    {
        return (s1, s2);
    }

    function prove_this(uint x) public {
        log_named_uint(""sym x"", x);
        assertGt(x + 1, 0);
    }

    function test_logn() public {
        assembly {
            log0(0x01, 0x02)
            log1(0x01, 0x02, 0x03)
            log2(0x01, 0x02, 0x03, 0x04)
            log3(0x01, 0x02, 0x03, 0x04, 0x05)
        }
    }

    event MyEvent(uint, uint indexed, uint, uint indexed);
    function test_events() public {
        emit MyEvent(1, 2, 3, 4);
    }

    function test_asserts() public {
        string memory err = ""this test has failed!"";
        emit log(""## assertTrue(bool)\n"");
        assertTrue(false);
        emit log(""\n"");
        assertTrue(false, err);

        emit log(""\n## assertEq(address,address)\n"");
        assertEq(address(this), msg.sender);
        emit log(""\n"");
        assertEq(address(this), msg.sender, err);

        emit log(""\n## assertEq32(bytes32,bytes32)\n"");
        assertEq32(""bytes 1"", ""bytes 2"");
        emit log(""\n"");
        assertEq32(""bytes 1"", ""bytes 2"", err);

        emit log(""\n## assertEq(bytes32,bytes32)\n"");
        assertEq32(""bytes 1"", ""bytes 2"");
        emit log(""\n"");
        assertEq32(""bytes 1"", ""bytes 2"", err);

        emit log(""\n## assertEq(uint,uint)\n"");
        assertEq(uint(0), 1);
        emit log(""\n"");
        assertEq(uint(0), 1, err);

        emit log(""\n## assertEq(int,int)\n"");
        assertEq(-1, -2);
        emit log(""\n"");
        assertEq(-1, -2, err);

        emit log(""\n## assertEqDecimal(int,int,uint)\n"");
        assertEqDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertEqDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertEqDecimal(uint,uint,uint)\n"");
        assertEqDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertGt(uint,uint)\n"");
        assertGt(uint(0), 0);
        emit log(""\n"");
        assertGt(uint(0), 0, err);

        emit log(""\n## assertGt(int,int)\n"");
        assertGt(-1, -1);
        emit log(""\n"");
        assertGt(-1, -1, err);

        emit log(""\n## assertGtDecimal(int,int,uint)\n"");
        assertGtDecimal(-2.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertGtDecimal(-2.0e18, -1.1e18, 18, err);

        emit log(""\n## assertGtDecimal(uint,uint,uint)\n"");
        assertGtDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertGe(uint,uint)\n"");
        assertGe(uint(0), 1);
        emit log(""\n"");
        assertGe(uint(0), 1, err);

        emit log(""\n## assertGe(int,int)\n"");
        assertGe(-1, 0);
        emit log(""\n"");
        assertGe(-1, 0, err);

        emit log(""\n## assertGeDecimal(int,int,uint)\n"");
        assertGeDecimal(-2.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertGeDecimal(-2.0e18, -1.1e18, 18, err);

        emit log(""\n## assertGeDecimal(uint,uint,uint)\n"");
        assertGeDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertLt(uint,uint)\n"");
        assertLt(uint(0), 0);
        emit log(""\n"");
        assertLt(uint(0), 0, err);

        emit log(""\n## assertLt(int,int)\n"");
        assertLt(-1, -1);
        emit log(""\n"");
        assertLt(-1, -1, err);

        emit log(""\n## assertLtDecimal(int,int,uint)\n"");
        assertLtDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertLtDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertLtDecimal(uint,uint,uint)\n"");
        assertLtDecimal(uint(2.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);

        emit log(""\n## assertLe(uint,uint)\n"");
        assertLe(uint(1), 0);
        emit log(""\n"");
        assertLe(uint(1), 0, err);

        emit log(""\n## assertLe(int,int)\n"");
        assertLe(0, -1);
        emit log(""\n"");
        assertLe(0, -1, err);

        emit log(""\n## assertLeDecimal(int,int,uint)\n"");
        assertLeDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertLeDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertLeDecimal(uint,uint,uint)\n"");
        assertLeDecimal(uint(2.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);

        emit log(""\n## assertEq(string,string)\n"");
        string memory s1 = ""string 1"";
        string memory s2 = ""string 2"";
        assertEq(s1, s2);
        emit log(""\n"");
        assertEq(s1, s2, err);

        emit log(""\n## assertEq0(bytes,bytes)\n"");
        assertEq0(hex""abcdef01"", hex""abcdef02"");
        log(""\n"");
        assertEq0(hex""abcdef01"", hex""abcdef02"", err);
    }
}

contract DemoTestWithSetUp {
    function setUp() public {
    }
    function test_pass() public pure {
    }
}",2045
RealWorld_TA_110_Vm_RealWorld_20240815004413.log,110,Vm,87950,1915,89865,103.0,0.47805,"// SPDX-License-Identifier: Unlicense
pragma solidity >=0.6.0;
pragma experimental ABIEncoderV2;

interface Vm {
    // Set block.timestamp (newTimestamp)
    function warp(uint256) external;
    // Set block.height (newHeight)
    function roll(uint256) external;
    // Set block.basefee (newBasefee)
    function fee(uint256) external;
    // Loads a storage slot from an address (who, slot)
    function load(address,bytes32) external returns (bytes32);
    // Stores a value to an address' storage slot, (who, slot, value)
    function store(address,bytes32,bytes32) external;
    // Signs data, (privateKey, digest) => (v, r, s)
    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);
    // Gets address for a given private key, (privateKey) => (address)
    function addr(uint256) external returns (address);
    // Performs a foreign function call via terminal, (stringInputs) => (result)
    function ffi(string[] calldata) external returns (bytes memory);
    // Sets the *next* call's msg.sender to be the input address
    function prank(address) external;
    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called
    function startPrank(address) external;
    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input
    function prank(address,address) external;
    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input
    function startPrank(address,address) external;
    // Resets subsequent calls' msg.sender to be `address(this)`
    function stopPrank() external;
    // Sets an address' balance, (who, newBalance)
    function deal(address, uint256) external;
    // Sets an address' code, (who, newCode)
    function etch(address, bytes calldata) external;
    // Expects an error on next call
    function expectRevert(bytes calldata) external;
    function expectRevert(bytes4) external;
    // Record all storage reads and writes
    function record() external;
    // Gets all accessed reads and write slot from a recording session, for a given address
    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);
    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).
    // Call this function, then emit an event, then call a function. Internally after the call, we check if
    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)
    function expectEmit(bool,bool,bool,bool) external;
    // Mocks a call to an address, returning specified data.
    // Calldata can either be strict or a partial match, e.g. if you only
    // pass a Solidity selector to the expected calldata, then the entire Solidity
    // function will be mocked.
    function mockCall(address,bytes calldata,bytes calldata) external;
    // Clears all mocked calls
    function clearMockedCalls() external;
    // Expect a call to an address with the specified calldata.
    // Calldata can either be strict or a partial match
    function expectCall(address,bytes calldata) external;
    // Gets the code from an artifact file. Takes in the relative path to the json file
    function getCode(string calldata) external returns (bytes memory);
    // Labels an address in call traces
    function label(address, string calldata) external;
    // If the condition is false, discard this run's fuzz inputs and generate new ones
    function assume(bool) external;
}",833
RealWorld_TA_110_demo_RealWorld_20240815003506.log,110,demo,189989,1693,191682,121.0,0.983805,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.4.23;

import ""../src/test.sol"";

contract DemoTest is DSTest {
    function test_this() public pure {
        require(true);
    }
    function test_logs() public {
        emit log(""-- log(string)"");
        emit log(""a string"");

        emit log(""-- log_named_uint(string, uint)"");
        log_named_uint(""uint"", 512);

        emit log(""-- log_named_int(string, int)"");
        log_named_int(""int"", -512);

        emit log(""-- log_named_address(string, address)"");
        log_named_address(""address"", address(this));

        emit log(""-- log_named_bytes32(string, bytes32)"");
        log_named_bytes32(""bytes32"", ""a string"");

        emit log(""-- log_named_bytes(string, bytes)"");
        log_named_bytes(""bytes"", hex""cafefe"");

        emit log(""-- log_named_string(string, string)"");
        log_named_string(""string"", ""a string"");

        emit log(""-- log_named_decimal_uint(string, uint, uint)"");
        log_named_decimal_uint(""decimal uint"", 1.0e18, 18);

        emit log(""-- log_named_decimal_int(string, int, uint)"");
        log_named_decimal_int(""decimal int"", -1.0e18, 18);
    }
    event log_old_named_uint(bytes32,uint);
    function test_old_logs() public {
        log_old_named_uint(""key"", 500);
        log_named_bytes32(""bkey"", ""val"");
    }
    function test_trace() public view {
        this.echo(""string 1"", ""string 2"");
    }
    function test_multiline() public {
        emit log(""a multiline\\n"" ""string"");
        emit log(""a multiline "" ""string"");
        log_bytes(""a string"");
        log_bytes(""a multiline\n"" ""string"");
        log_bytes(""a multiline\\n"" ""string"");
        emit log(unicode""Ώ"");
        logs(hex""0000"");
        log_named_bytes(""0x0000"", hex""0000"");
        logs(hex""ff"");
    }
    function echo(string memory s1, string memory s2) public pure
        returns (string memory, string memory)
    {
        return (s1, s2);
    }

    function prove_this(uint x) public {
        log_named_uint(""sym x"", x);
        assertGt(x + 1, 0);
    }

    function test_logn() public {
        assembly {
            log0(0x01, 0x02)
            log1(0x01, 0x02, 0x03)
            log2(0x01, 0x02, 0x03, 0x04)
            log3(0x01, 0x02, 0x03, 0x04, 0x05)
        }
    }

    event MyEvent(uint, uint indexed, uint, uint indexed);
    function test_events() public {
        emit MyEvent(1, 2, 3, 4);
    }

    function test_asserts() public {
        string memory err = ""this test has failed!"";
        emit log(""## assertTrue(bool)\n"");
        assertTrue(false);
        emit log(""\n"");
        assertTrue(false, err);

        emit log(""\n## assertEq(address,address)\n"");
        assertEq(address(this), msg.sender);
        emit log(""\n"");
        assertEq(address(this), msg.sender, err);

        emit log(""\n## assertEq32(bytes32,bytes32)\n"");
        assertEq32(""bytes 1"", ""bytes 2"");
        emit log(""\n"");
        assertEq32(""bytes 1"", ""bytes 2"", err);

        emit log(""\n## assertEq(bytes32,bytes32)\n"");
        assertEq32(""bytes 1"", ""bytes 2"");
        emit log(""\n"");
        assertEq32(""bytes 1"", ""bytes 2"", err);

        emit log(""\n## assertEq(uint,uint)\n"");
        assertEq(uint(0), 1);
        emit log(""\n"");
        assertEq(uint(0), 1, err);

        emit log(""\n## assertEq(int,int)\n"");
        assertEq(-1, -2);
        emit log(""\n"");
        assertEq(-1, -2, err);

        emit log(""\n## assertEqDecimal(int,int,uint)\n"");
        assertEqDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertEqDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertEqDecimal(uint,uint,uint)\n"");
        assertEqDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertGt(uint,uint)\n"");
        assertGt(uint(0), 0);
        emit log(""\n"");
        assertGt(uint(0), 0, err);

        emit log(""\n## assertGt(int,int)\n"");
        assertGt(-1, -1);
        emit log(""\n"");
        assertGt(-1, -1, err);

        emit log(""\n## assertGtDecimal(int,int,uint)\n"");
        assertGtDecimal(-2.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertGtDecimal(-2.0e18, -1.1e18, 18, err);

        emit log(""\n## assertGtDecimal(uint,uint,uint)\n"");
        assertGtDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertGe(uint,uint)\n"");
        assertGe(uint(0), 1);
        emit log(""\n"");
        assertGe(uint(0), 1, err);

        emit log(""\n## assertGe(int,int)\n"");
        assertGe(-1, 0);
        emit log(""\n"");
        assertGe(-1, 0, err);

        emit log(""\n## assertGeDecimal(int,int,uint)\n"");
        assertGeDecimal(-2.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertGeDecimal(-2.0e18, -1.1e18, 18, err);

        emit log(""\n## assertGeDecimal(uint,uint,uint)\n"");
        assertGeDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertLt(uint,uint)\n"");
        assertLt(uint(0), 0);
        emit log(""\n"");
        assertLt(uint(0), 0, err);

        emit log(""\n## assertLt(int,int)\n"");
        assertLt(-1, -1);
        emit log(""\n"");
        assertLt(-1, -1, err);

        emit log(""\n## assertLtDecimal(int,int,uint)\n"");
        assertLtDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertLtDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertLtDecimal(uint,uint,uint)\n"");
        assertLtDecimal(uint(2.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);

        emit log(""\n## assertLe(uint,uint)\n"");
        assertLe(uint(1), 0);
        emit log(""\n"");
        assertLe(uint(1), 0, err);

        emit log(""\n## assertLe(int,int)\n"");
        assertLe(0, -1);
        emit log(""\n"");
        assertLe(0, -1, err);

        emit log(""\n## assertLeDecimal(int,int,uint)\n"");
        assertLeDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertLeDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertLeDecimal(uint,uint,uint)\n"");
        assertLeDecimal(uint(2.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);

        emit log(""\n## assertEq(string,string)\n"");
        string memory s1 = ""string 1"";
        string memory s2 = ""string 2"";
        assertEq(s1, s2);
        emit log(""\n"");
        assertEq(s1, s2, err);

        emit log(""\n## assertEq0(bytes,bytes)\n"");
        assertEq0(hex""abcdef01"", hex""abcdef02"");
        log(""\n"");
        assertEq0(hex""abcdef01"", hex""abcdef02"", err);
    }
}

contract DemoTestWithSetUp {
    function setUp() public {
    }
    function test_pass() public pure {
    }
}",2045
RealWorld_TA_110_test_RealWorld_20240815004154.log,110,test,316009,3006,319015,137.0,1.640165,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log                    (string);
    event logs                   (bytes);

    event log_address            (address);
    event log_bytes32            (bytes32);
    event log_int                (int);
    event log_uint               (uint);
    event log_bytes              (bytes);
    event log_string             (string);

    event log_named_address      (string key, address val);
    event log_named_bytes32      (string key, bytes32 val);
    event log_named_decimal_int  (string key, int val, uint decimals);
    event log_named_decimal_uint (string key, uint val, uint decimals);
    event log_named_int          (string key, int val);
    event log_named_uint         (string key, uint val);
    event log_named_bytes        (string key, bytes val);
    event log_named_string       (string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));

    modifier mayRevert() { _; }
    modifier testopts(string memory) { _; }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint startGas = gasleft();
        _;
        uint endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }
    function assertEq(address a, address b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }
    function assertEq(bytes32 a, bytes32 b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }
    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
        assertEq(a, b, err);
    }

    function assertEq(int a, int b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }
    function assertEq(int a, int b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq(uint a, uint b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }
    function assertEq(uint a, uint b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEqDecimal(int a, int b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint a, uint b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGt(uint a, uint b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGt(int a, int b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGt(int a, int b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGtDecimal(int a, int b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint a, uint b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGe(uint a, uint b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGe(int a, int b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGe(int a, int b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGeDecimal(int a, int b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint a, uint b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLt(uint a, uint b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLt(int a, int b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLt(int a, int b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLtDecimal(int a, int b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint a, uint b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLe(uint a, uint b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLe(int a, int b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLe(int a, int b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLeDecimal(int a, int b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }
    function assertEq(string memory a, string memory b, string memory err) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
        ok = true;
        if (a.length == b.length) {
            for (uint i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }
    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }
    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3539
RealWorld_TA_110_stdlib_RealWorld_20240815004558.log,110,stdlib,257699,2393,260092,129.0,1.336355,"// SPDX-License-Identifier: Unlicense
pragma solidity >=0.6.0 <0.9.0;

import ""./Vm.sol"";

// Wrappers around Cheatcodes to avoid footguns
abstract contract stdCheats {
    using stdStorage for StdStorage;

    // we use custom names that are unlikely to cause collisions so this contract
    // can be inherited easily
    Vm constant vm_std_cheats = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));
    StdStorage std_store_std_cheats;

    // Skip forward or rewind time by the specified number of seconds
    function skip(uint256 time) public {
        vm_std_cheats.warp(block.timestamp + time);
    }

    function rewind(uint256 time) public {
        vm_std_cheats.warp(block.timestamp - time);
    }

    // Setup a prank from an address that has some ether
    function hoax(address who) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.prank(who);
    }

    function hoax(address who, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.prank(who);
    }

    function hoax(address who, address origin) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.prank(who, origin);
    }

    function hoax(address who, address origin, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.prank(who, origin);
    }

    // Start perpetual prank from an address that has some ether
    function startHoax(address who) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.startPrank(who);
    }

    function startHoax(address who, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.startPrank(who);
    }

    // Start perpetual prank from an address that has some ether
    // tx.origin is set to the origin parameter
    function startHoax(address who, address origin) public {
        vm_std_cheats.deal(who, 1 << 128);
        vm_std_cheats.startPrank(who, origin);
    }

    function startHoax(address who, address origin, uint256 give) public {
        vm_std_cheats.deal(who, give);
        vm_std_cheats.startPrank(who, origin);
    }

    // Allows you to set the balance of an account for a majority of tokens
    // Be careful not to break something!
    function tip(address token, address to, uint256 give) public {
        std_store_std_cheats
            .target(token)
            .sig(0x70a08231)
            .with_key(to)
            .checked_write(give);
    }

    // Deploys a contract by fetching the contract bytecode from
    // the artifacts directory
    function deployCode(string memory what, bytes memory args)
        public
        returns (address addr)
    {
        bytes memory bytecode = abi.encodePacked(vm_std_cheats.getCode(what), args);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
    }

    function deployCode(string memory what)
        public
        returns (address addr)
    {
        bytes memory bytecode = vm_std_cheats.getCode(what);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
    }
}


library stdError {
    bytes public constant assertionError = abi.encodeWithSignature(""Panic(uint256)"", 0x01);
    bytes public constant arithmeticError = abi.encodeWithSignature(""Panic(uint256)"", 0x11);
    bytes public constant divisionError = abi.encodeWithSignature(""Panic(uint256)"", 0x12);
    bytes public constant enumConversionError = abi.encodeWithSignature(""Panic(uint256)"", 0x21);
    bytes public constant encodeStorageError = abi.encodeWithSignature(""Panic(uint256)"", 0x22);
    bytes public constant popError = abi.encodeWithSignature(""Panic(uint256)"", 0x31);
    bytes public constant indexOOBError = abi.encodeWithSignature(""Panic(uint256)"", 0x32);
    bytes public constant memOverflowError = abi.encodeWithSignature(""Panic(uint256)"", 0x41);
    bytes public constant zeroVarError = abi.encodeWithSignature(""Panic(uint256)"", 0x51);
    bytes public constant lowLevelError = bytes(""""); // `0x`
}

struct StdStorage {
    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;
    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;
    
    bytes32[] _keys;
    bytes4 _sig;
    uint256 _depth;
    address _target;
    bytes32 _set;
}


library stdStorage {
    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);
    event WARNING_UninitedSlot(address who, uint slot);
    
    Vm constant stdstore_vm = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));

    function sigs(
        string memory sigStr
    )
        internal
        pure
        returns (bytes4)
    {
        return bytes4(keccak256(bytes(sigStr)));
    }

    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
    // slot complexity:
    //  if flat, will be bytes32(uint256(uint));
    //  if map, will be keccak256(abi.encode(key, uint(slot)));
    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
    function find(
        StdStorage storage self
    ) 
        internal 
        returns (uint256)
    {
        address who = self._target;
        bytes4 fsig = self._sig;
        uint256 field_depth = self._depth;
        bytes32[] memory ins = self._keys;

        // calldata to test against
        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
        }
        bytes memory cald = abi.encodePacked(fsig, flatten(ins));
        stdstore_vm.record();
        bytes32 fdat;
        {
            (, bytes memory rdat) = who.staticcall(cald);
            fdat = bytesToBytes32(rdat, 32*field_depth);
        }
        
        (bytes32[] memory reads, ) = stdstore_vm.accesses(address(who));
        if (reads.length == 1) {
            bytes32 curr = stdstore_vm.load(who, reads[0]);
            if (curr == bytes32(0)) {
                emit WARNING_UninitedSlot(who, uint256(reads[0]));
            }
            if (fdat != curr) {
                require(false, ""Packed slot. This would cause dangerous overwriting and currently isnt supported"");
            }
            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));
            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);
            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
        } else if (reads.length > 1) {
            for (uint256 i = 0; i < reads.length; i++) {
                bytes32 prev = stdstore_vm.load(who, reads[i]);
                if (prev == bytes32(0)) {
                    emit WARNING_UninitedSlot(who, uint256(reads[i]));
                }
                // store
                stdstore_vm.store(who, reads[i], bytes32(hex""1337""));
                {
                    (, bytes memory rdat) = who.staticcall(cald);
                    fdat = bytesToBytes32(rdat, 32*field_depth);
                }
                
                if (fdat == bytes32(hex""1337"")) {
                    // we found which of the slots is the actual one
                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));
                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);
                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;
                    stdstore_vm.store(who, reads[i], prev);
                    break;
                }
                stdstore_vm.store(who, reads[i], prev);
            }
        } else {
            require(false, ""No storage use detected for target"");
        }

        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], ""NotFound"");

        delete self._target;
        delete self._sig;
        delete self._keys;
        delete self._depth; 

        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];
    }

    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
        self._target = _target;
        return self;
    }

    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
        self._sig = _sig;
        return self;
    }

    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
        self._sig = sigs(_sig);
        return self;
    }

    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
        self._keys.push(bytes32(uint256(uint160(who))));
        return self;
    }

    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
        self._keys.push(bytes32(amt));
        return self;
    }
    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
        self._keys.push(key);
        return self;
    }

    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
        self._depth = _depth;
        return self;
    }

    function checked_write(StdStorage storage self, address who) internal {
        checked_write(self, bytes32(uint256(uint160(who))));
    }

    function checked_write(StdStorage storage self, uint256 amt) internal {
        checked_write(self, bytes32(amt));
    }

    function checked_write(StdStorage storage self, bool write) internal {
        bytes32 t;
        assembly {
            t := write
        }
        checked_write(self, t);
    }

    function checked_write(
        StdStorage storage self,
        bytes32 set
    ) internal {
        address who = self._target;
        bytes4 fsig = self._sig;
        uint256 field_depth = self._depth;
        bytes32[] memory ins = self._keys;

        bytes memory cald = abi.encodePacked(fsig, flatten(ins));
        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {
            find(self);
        }
        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);

        bytes32 fdat;
        {
            (, bytes memory rdat) = who.staticcall(cald);
            fdat = bytesToBytes32(rdat, 32*field_depth);
        }
        bytes32 curr = stdstore_vm.load(who, slot);

        if (fdat != curr) {
            require(false, ""Packed slot. This would cause dangerous overwriting and currently isnt supported"");
        }
        stdstore_vm.store(who, slot, set);
        delete self._target;
        delete self._sig;
        delete self._keys;
        delete self._depth; 
    }

    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {
        bytes32 out;

        for (uint i = 0; i < 32; i++) {
            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
        }
        return out;
    }

    function flatten(bytes32[] memory b) private pure returns (bytes memory)
    {
        bytes memory result = new bytes(b.length * 32);
        for (uint256 i = 0; i < b.length; i++) {
            bytes32 k = b[i];
            assembly {
                mstore(add(result, add(32, mul(32, i))), k)
            }
        }

        return result;
    }
}",2849
RealWorld_TA_112_IRoleManager_RealWorld_20240815125325.log,112,IRoleManager,37702,1391,39093,152.0,0.21633,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IRoleManager {
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    function grantRole(bytes32 role, address account) external;

    function revokeRole(bytes32 role, address account) external;

    function hasRole(bytes32 role, address account) external view returns (bool);

    function hasAnyRole(bytes32[] memory roles, address account) external view returns (bool);

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        address account
    ) external view returns (bool);

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        address account
    ) external view returns (bool);

    function getRoleMemberCount(bytes32 role) external view returns (uint256);

    function getRoleMember(bytes32 role, uint256 index) external view returns (address);
}",229
RealWorld_TA_112_MockAMMToken_RealWorld_20240815085402.log,112,MockAMMToken,25563,1833,27396,87.0,0.164475,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockAmmToken is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}

    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }
}",87
RealWorld_TA_112_MockTopUpHandler_RealWorld_20240815090038.log,112,MockTopUpHandler,64708,3781,68489,131.0,0.39916,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../actions/topup/handlers/BaseHandler.sol"";

contract MockTopUpHandler is BaseHandler, Initializable {
    using SafeERC20 for IERC20;

    MockUserFactors public immutable userFactors;

    constructor() {
        userFactors = new MockUserFactors();
    }

    /**
     * @dev Executes the top-up of a position, in this case, just send money back to the user
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory /* extra */
    ) external override returns (bool) {
        address addr = address(bytes20(account));
        if (underlying == address(0)) {
            payable(addr).transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(addr, amount);
        }

        userFactors.increaseUserFactor(addr);

        return true;
    }

    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {
        require(address(userFactors) != address(0), ""user factors not set"");
        address addr = address(bytes20(account));
        return userFactors.getUserFactor(addr);
    }
}

contract MockUserFactors {
    /**
     * @dev all users start with `_DEFAULT_USER_FACTOR` and their position is
     * increased by `_INCREMENT_USER_FACTOR` when they are topped up
     */
    uint256 internal constant _DEFAULT_USER_FACTOR = 1.3e18;
    uint256 internal constant _INCREMENT_USER_FACTOR = 0.3e18;

    mapping(address => uint256) internal _userFactors;

    function increaseUserFactor(address account) external {
        // NOTE: add _INCREMENT_USER_FACTOR to the current user factor to be able
        // to simulate topping up actually increasing the current factor
        uint256 userFactor = _userFactors[account];
        if (userFactor == 0) {
            userFactor = _DEFAULT_USER_FACTOR;
        }
        _userFactors[account] = userFactor + _INCREMENT_USER_FACTOR;
    }

    function getUserFactor(address account) external view returns (uint256) {
        uint256 userFactor = _userFactors[account];
        return userFactor == 0 ? _DEFAULT_USER_FACTOR : userFactor;
    }
}",540
RealWorld_TA_112_BkdLocker_RealWorld_20240815080622.log,112,BkdLocker,250788,5460,256248,145.0,1.36314,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""../libraries/ScaledMath.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/EnumerableExtensions.sol"";
import ""../interfaces/IBkdLocker.sol"";
import ""../interfaces/tokenomics/IBkdToken.sol"";
import ""../interfaces/tokenomics/IMigrationContract.sol"";
import ""./utils/Preparable.sol"";
import ""./access/Authorization.sol"";

contract BkdLocker is IBkdLocker, Authorization, Preparable {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableMapping for EnumerableMapping.AddressToUintMap;
    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;

    bytes32 internal constant _START_BOOST = ""startBoost"";
    bytes32 internal constant _MAX_BOOST = ""maxBoost"";
    bytes32 internal constant _INCREASE_PERIOD = ""increasePeriod"";
    bytes32 internal constant _WITHDRAW_DELAY = ""withdrawDelay"";

    // User-specific data
    mapping(address => uint256) public balances;
    mapping(address => uint256) public boostFactors;
    mapping(address => uint256) public lastUpdated;
    mapping(address => WithdrawStash[]) public stashedGovTokens;
    mapping(address => uint256) public totalStashed;

    // Global data
    uint256 public totalLocked;
    uint256 public totalLockedBoosted;
    uint256 public lastMigrationEvent;
    EnumerableMapping.AddressToUintMap private _replacedRewardTokens;

    // Reward token data
    mapping(address => RewardTokenData) public rewardTokenData;
    address public rewardToken;
    IERC20 public immutable govToken;

    constructor(
        address _rewardToken,
        address _govToken,
        IRoleManager roleManager
    ) Authorization(roleManager) {
        rewardToken = _rewardToken;
        govToken = IBkdToken(_govToken);
    }

    function initialize(
        uint256 startBoost,
        uint256 maxBoost,
        uint256 increasePeriod,
        uint256 withdrawDelay
    ) external override onlyGovernance {
        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);
        _setConfig(_START_BOOST, startBoost);
        _setConfig(_MAX_BOOST, maxBoost);
        _setConfig(_INCREASE_PERIOD, increasePeriod);
        _setConfig(_WITHDRAW_DELAY, withdrawDelay);
    }

    /**
     * @notice Sets a new token to be the rewardToken. Fees are then accumulated in this token.
     * @dev Previously used rewardTokens can be set again here.
     */
    function migrate(address newRewardToken) external override onlyGovernance {
        _replacedRewardTokens.remove(newRewardToken);
        _replacedRewardTokens.set(rewardToken, block.timestamp);
        lastMigrationEvent = block.timestamp;
        rewardToken = newRewardToken;
    }

    /**
     * @notice Lock gov. tokens.
     * @dev The amount needs to be approved in advance.
     */
    function lock(uint256 amount) external override {
        return lockFor(msg.sender, amount);
    }

    /**
     * @notice Deposit fees (in the rewardToken) to be distributed to lockers of gov. tokens.
     * @dev `deposit` or `depositFor` needs to be called at least once before this function can be called
     * @param amount Amount of rewardToken to deposit.
     */
    function depositFees(uint256 amount) external {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);
        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);

        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];

        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);
        curRewardTokenData.feeBalance += amount;
        emit FeesDeposited(amount);
    }

    function claimFees() external override {
        claimFees(rewardToken);
    }

    /**
     * @notice Checkpoint function to update user data, in particular the boost factor.
     */
    function userCheckpoint(address user) external override {
        _userCheckpoint(user, 0, balances[user]);
    }

    /**
     * @notice Prepare unlocking of locked gov. tokens.
     * @dev A delay is enforced and unlocking can only be executed after that.
     * @param amount Amount of gov. tokens to prepare for unlocking.
     */
    function prepareUnlock(uint256 amount) external override {
        require(
            totalStashed[msg.sender] + amount <= balances[msg.sender],
            ""Amount exceeds locked balance""
        );
        totalStashed[msg.sender] += amount;
        stashedGovTokens[msg.sender].push(
            WithdrawStash(block.timestamp + currentUInts256[_WITHDRAW_DELAY], amount)
        );
        emit WithdrawPrepared(msg.sender, amount);
    }

    /**
     * @notice Execute all prepared gov. token withdrawals.
     */
    function executeUnlocks() external override {
        uint256 totalAvailableToWithdraw = 0;
        WithdrawStash[] storage stashedWithdraws = stashedGovTokens[msg.sender];
        uint256 length = stashedWithdraws.length;
        require(length > 0, ""No entries"");
        uint256 i = length;
        while (i > 0) {
            i = i - 1;
            if (stashedWithdraws[i].releaseTime <= block.timestamp) {
                totalAvailableToWithdraw += stashedWithdraws[i].amount;

                stashedWithdraws[i] = stashedWithdraws[stashedWithdraws.length - 1];

                stashedWithdraws.pop();
            }
        }
        totalStashed[msg.sender] -= totalAvailableToWithdraw;
        uint256 newTotal = balances[msg.sender] - totalAvailableToWithdraw;
        _userCheckpoint(msg.sender, 0, newTotal);
        totalLocked -= totalAvailableToWithdraw;
        govToken.safeTransfer(msg.sender, totalAvailableToWithdraw);
        emit WithdrawExecuted(msg.sender, totalAvailableToWithdraw);
    }

    function getUserShare(address user) external view override returns (uint256) {
        return getUserShare(user, rewardToken);
    }

    /**
     * @notice Get the boosted locked balance for a user.
     * @dev This includes the gov. tokens queued for withdrawal.
     * @param user Address to get the boosted balance for.
     * @return boosted balance for user.
     */
    function boostedBalance(address user) external view override returns (uint256) {
        return balances[user].scaledMul(boostFactors[user]);
    }

    /**
     * @notice Get the vote weight for a user.
     * @dev This does not invlude the gov. tokens queued for withdrawal.
     * @param user Address to get the vote weight for.
     * @return vote weight for user.
     */
    function balanceOf(address user) external view override returns (uint256) {
        return (balances[user] - totalStashed[user]).scaledMul(boostFactors[user]);
    }

    /**
     * @notice Get the share of the total boosted locked balance for a user.
     * @dev This includes the gov. tokens queued for withdrawal.
     * @param user Address to get the share of the total boosted balance for.
     * @return share of the total boosted balance for user.
     */
    function getShareOfTotalBoostedBalance(address user) external view override returns (uint256) {
        return balances[user].scaledMul(boostFactors[user]).scaledDiv(totalLockedBoosted);
    }

    function getStashedGovTokens(address user)
        external
        view
        override
        returns (WithdrawStash[] memory)
    {
        return stashedGovTokens[user];
    }

    function claimableFees(address user) external view override returns (uint256) {
        return claimableFees(user, rewardToken);
    }

    /**
     * @notice Claim fees accumulated in the Locker.
     */
    function claimFees(address _rewardToken) public override {
        require(
            _rewardToken == rewardToken || _replacedRewardTokens.contains(_rewardToken),
            Error.INVALID_ARGUMENT
        );
        _userCheckpoint(msg.sender, 0, balances[msg.sender]);
        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];
        uint256 claimable = curRewardTokenData.userShares[msg.sender];
        curRewardTokenData.userShares[msg.sender] = 0;
        curRewardTokenData.feeBalance -= claimable;
        IERC20(_rewardToken).safeTransfer(msg.sender, claimable);
        emit RewardsClaimed(msg.sender, _rewardToken, claimable);
    }

    /**
     * @notice Lock gov. tokens on behalf of another user.
     * @dev The amount needs to be approved in advance.
     * @param user Address of user to lock on behalf of.
     * @param amount Amount of gov. tokens to lock.
     */
    function lockFor(address user, uint256 amount) public override {
        govToken.safeTransferFrom(msg.sender, address(this), amount);
        _userCheckpoint(user, amount, balances[user] + amount);
        totalLocked += amount;
        emit Locked(user, amount);
    }

    function getUserShare(address user, address _rewardToken)
        public
        view
        override
        returns (uint256)
    {
        return rewardTokenData[_rewardToken].userShares[user];
    }

    function claimableFees(address user, address _rewardToken)
        public
        view
        override
        returns (uint256)
    {
        uint256 currentShare;
        uint256 userBalance = balances[user];
        RewardTokenData storage curRewardTokenData = rewardTokenData[_rewardToken];

        // Compute the share earned by the user since he last updated
        if (userBalance > 0) {
            currentShare += (curRewardTokenData.feeIntegral -
                curRewardTokenData.userFeeIntegrals[user]).scaledMul(
                    userBalance.scaledMul(boostFactors[user])
                );
        }
        return curRewardTokenData.userShares[user] + currentShare;
    }

    function computeNewBoost(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) public view override returns (uint256) {
        uint256 newBoost;
        uint256 balance = balances[user];
        uint256 startBoost = currentUInts256[_START_BOOST];
        if (balance == 0 || newTotal == 0) {
            newBoost = startBoost;
        } else {
            uint256 maxBoost = currentUInts256[_MAX_BOOST];
            newBoost = boostFactors[user];
            newBoost += (block.timestamp - lastUpdated[user])
                .scaledDiv(currentUInts256[_INCREASE_PERIOD])
                .scaledMul(maxBoost - startBoost);
            if (newBoost > maxBoost) {
                newBoost = maxBoost;
            }
            if (newTotal <= balance) {
                return newBoost;
            }
            newBoost =
                newBoost.scaledMul(balance.scaledDiv(newTotal)) +
                startBoost.scaledMul(amountAdded.scaledDiv(newTotal));
        }
        return newBoost;
    }

    function _userCheckpoint(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) internal {
        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];

        // Compute the share earned by the user since he last updated
        uint256 userBalance = balances[user];
        if (userBalance > 0) {
            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -
                curRewardTokenData.userFeeIntegrals[user]).scaledMul(
                    userBalance.scaledMul(boostFactors[user])
                );
        }

        // Update values for previous rewardTokens
        if (lastUpdated[user] < lastMigrationEvent && userBalance > 0) {
            uint256 length = _replacedRewardTokens.length();
            for (uint256 i = 0; i < length; i++) {
                (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);
                if (lastUpdated[user] < replacedAt) {
                    RewardTokenData storage prevRewardTokenData = rewardTokenData[token];
                    prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -
                        prevRewardTokenData.userFeeIntegrals[user]).scaledMul(
                            userBalance.scaledMul(boostFactors[user])
                        );
                    prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData.feeIntegral;
                }
            }
        }

        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);
        totalLockedBoosted =
            totalLockedBoosted +
            newTotal.scaledMul(newBoost) -
            balances[user].scaledMul(boostFactors[user]);

        // Update user values
        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;
        lastUpdated[user] = block.timestamp;
        boostFactors[user] = newBoost;
        balances[user] = newTotal;
    }
}",2752
RealWorld_TA_112_IBooster_RealWorld_20240815143909.log,112,IBooster,35364,1608,36972,149.0,0.20898,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IBooster {
    /**
     * @dev `_pid` is the ID of the Convex for a specific Curve LP token.
     */
    function deposit(
        uint256 _pid,
        uint256 _amount,
        bool _stake
    ) external returns (bool);

    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);

    function withdrawAll(uint256 _pid) external returns (bool);

    function withdrawTo(
        uint256 _pid,
        uint256 _amount,
        address _to
    ) external returns (bool);

    function depositAll(uint256 _pid, bool _stake) external returns (bool);

    function poolInfo(uint256 pid)
        external
        view
        returns (
            address lpToken,
            address token,
            address gauge,
            address crvRewards,
            address stash,
            bool shutdown
        );
}",205
RealWorld_TA_112_UniswapRouter02_RealWorld_20240815151619.log,112,UniswapRouter02,56801,1293,58094,129.0,0.309865,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface UniswapRouter02 {
    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapETHForExactTokens(
        uint256 amountOut,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable returns (uint256[] memory amounts);

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) external returns (uint256 amountIn);

    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) external view returns (uint256 amountOut);

    function getAmountsIn(uint256 amountOut, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);

    function getAmountsOut(uint256 amountIn, address[] memory path)
        external
        view
        returns (uint256[] memory amounts);

    function getReserves(
        address factory,
        address tokenA,
        address tokenB
    ) external view returns (uint256 reserveA, uint256 reserveB);

    function WETH() external pure returns (address);
}

interface UniswapV2Pair {
    function getReserves()
        external
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        );
}

interface UniswapV2Factory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}",467
RealWorld_TA_112_Errors_RealWorld_20240815122130.log,112,Errors,144110,1182,145292,168.0,0.74419,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

// solhint-disable private-vars-leading-underscore

library Error {
    string internal constant ADDRESS_WHITELISTED = ""address already whitelisted"";
    string internal constant ADMIN_ALREADY_SET = ""admin has already been set once"";
    string internal constant ADDRESS_NOT_WHITELISTED = ""address not whitelisted"";
    string internal constant ADDRESS_NOT_FOUND = ""address not found"";
    string internal constant CONTRACT_INITIALIZED = ""contract can only be initialized once"";
    string internal constant CONTRACT_PAUSED = ""contract is paused"";
    string internal constant UNAUTHORIZED_PAUSE = ""not authorized to pause"";
    string internal constant INVALID_AMOUNT = ""invalid amount"";
    string internal constant INVALID_INDEX = ""invalid index"";
    string internal constant INVALID_VALUE = ""invalid msg.value"";
    string internal constant INVALID_SENDER = ""invalid msg.sender"";
    string internal constant INVALID_TOKEN = ""token address does not match pool's LP token address"";
    string internal constant INVALID_DECIMALS = ""incorrect number of decimals"";
    string internal constant INVALID_ARGUMENT = ""invalid argument"";
    string internal constant INVALID_PARAMETER_VALUE = ""invalid parameter value attempted"";
    string internal constant INVALID_IMPLEMENTATION = ""invalid pool implementation for given coin"";
    string internal constant INVALID_POOL_IMPLEMENTATION =
        ""invalid pool implementation for given coin"";
    string internal constant INVALID_LP_TOKEN_IMPLEMENTATION =
        ""invalid LP Token implementation for given coin"";
    string internal constant INVALID_VAULT_IMPLEMENTATION =
        ""invalid vault implementation for given coin"";
    string internal constant INVALID_STAKER_VAULT_IMPLEMENTATION =
        ""invalid stakerVault implementation for given coin"";
    string internal constant INSUFFICIENT_BALANCE = ""insufficient balance"";
    string internal constant ADDRESS_ALREADY_SET = ""Address is already set"";
    string internal constant INSUFFICIENT_STRATEGY_BALANCE = ""insufficient strategy balance"";
    string internal constant INSUFFICIENT_FUNDS_RECEIVED = ""insufficient funds received"";
    string internal constant ADDRESS_DOES_NOT_EXIST = ""address does not exist"";
    string internal constant ADDRESS_FROZEN = ""address is frozen"";
    string internal constant ROLE_EXISTS = ""role already exists"";
    string internal constant CANNOT_REVOKE_ROLE = ""cannot revoke role"";
    string internal constant UNAUTHORIZED_ACCESS = ""unauthorized access"";
    string internal constant SAME_ADDRESS_NOT_ALLOWED = ""same address not allowed"";
    string internal constant SELF_TRANSFER_NOT_ALLOWED = ""self-transfer not allowed"";
    string internal constant ZERO_ADDRESS_NOT_ALLOWED = ""zero address not allowed"";
    string internal constant ZERO_TRANSFER_NOT_ALLOWED = ""zero transfer not allowed"";
    string internal constant THRESHOLD_TOO_HIGH = ""threshold is too high, must be under 10"";
    string internal constant INSUFFICIENT_THRESHOLD = ""insufficient threshold"";
    string internal constant NO_POSITION_EXISTS = ""no position exists"";
    string internal constant POSITION_ALREADY_EXISTS = ""position already exists"";
    string internal constant PROTOCOL_NOT_FOUND = ""protocol not found"";
    string internal constant TOP_UP_FAILED = ""top up failed"";
    string internal constant SWAP_PATH_NOT_FOUND = ""swap path not found"";
    string internal constant UNDERLYING_NOT_SUPPORTED = ""underlying token not supported"";
    string internal constant NOT_ENOUGH_FUNDS_WITHDRAWN =
        ""not enough funds were withdrawn from the pool"";
    string internal constant FAILED_TRANSFER = ""transfer failed"";
    string internal constant FAILED_MINT = ""mint failed"";
    string internal constant FAILED_REPAY_BORROW = ""repay borrow failed"";
    string internal constant FAILED_METHOD_CALL = ""method call failed"";
    string internal constant NOTHING_TO_CLAIM = ""there is no claimable balance"";
    string internal constant ERC20_BALANCE_EXCEEDED = ""ERC20: transfer amount exceeds balance"";
    string internal constant INVALID_MINTER =
        ""the minter address of the LP token and the pool address do not match"";
    string internal constant STAKER_VAULT_EXISTS = ""a staker vault already exists for the token"";
    string internal constant DEADLINE_NOT_ZERO = ""deadline must be 0"";
    string internal constant DEADLINE_NOT_SET = ""deadline is 0"";
    string internal constant DEADLINE_NOT_REACHED = ""deadline has not been reached yet"";
    string internal constant DELAY_TOO_SHORT = ""delay be at least 3 days"";
    string internal constant INSUFFICIENT_UPDATE_BALANCE =
        ""insufficient funds for updating the position"";
    string internal constant SAME_AS_CURRENT = ""value must be different to existing value"";
    string internal constant NOT_CAPPED = ""the pool is not currently capped"";
    string internal constant ALREADY_CAPPED = ""the pool is already capped"";
    string internal constant EXCEEDS_DEPOSIT_CAP = ""deposit exceeds deposit cap"";
    string internal constant VALUE_TOO_LOW_FOR_GAS = ""value too low to cover gas"";
    string internal constant NOT_ENOUGH_FUNDS = ""not enough funds to withdraw"";
    string internal constant ESTIMATED_GAS_TOO_HIGH = ""too much ETH will be used for gas"";
    string internal constant DEPOSIT_FAILED = ""deposit failed"";
    string internal constant GAS_TOO_HIGH = ""too much ETH used for gas"";
    string internal constant GAS_BANK_BALANCE_TOO_LOW = ""not enough ETH in gas bank to cover gas"";
    string internal constant INVALID_TOKEN_TO_ADD = ""Invalid token to add"";
    string internal constant INVALID_TOKEN_TO_REMOVE = ""token can not be removed"";
    string internal constant TIME_DELAY_NOT_EXPIRED = ""time delay not expired yet"";
    string internal constant UNDERLYING_NOT_WITHDRAWABLE =
        ""pool does not support additional underlying coins to be withdrawn"";
    string internal constant STRATEGY_SHUT_DOWN = ""Strategy is shut down"";
    string internal constant STRATEGY_DOES_NOT_EXIST = ""Strategy does not exist"";
    string internal constant UNSUPPORTED_UNDERLYING = ""Underlying not supported"";
    string internal constant NO_DEX_SET = ""no dex has been set for token"";
    string internal constant INVALID_TOKEN_PAIR = ""invalid token pair"";
    string internal constant TOKEN_NOT_USABLE = ""token not usable for the specific action"";
    string internal constant ADDRESS_NOT_ACTION = ""address is not registered action"";
    string internal constant INVALID_SLIPPAGE_TOLERANCE = ""Invalid slippage tolerance"";
    string internal constant POOL_NOT_PAUSED = ""Pool must be paused to withdraw from reserve"";
    string internal constant INTERACTION_LIMIT = ""Max of one deposit and withdraw per block"";
    string internal constant GAUGE_EXISTS = ""Gauge already exists"";
    string internal constant GAUGE_DOES_NOT_EXIST = ""Gauge does not exist"";
    string internal constant EXCEEDS_MAX_BOOST = ""Not allowed to exceed maximum boost on Convex"";
    string internal constant PREPARED_WITHDRAWAL =
        ""Cannot relock funds when withdrawal is being prepared"";
    string internal constant ASSET_NOT_SUPPORTED = ""Asset not supported"";
    string internal constant STALE_PRICE = ""Price is stale"";
    string internal constant NEGATIVE_PRICE = ""Price is negative"";
    string internal constant NOT_ENOUGH_BKD_STAKED = ""Not enough BKD tokens staked"";
    string internal constant RESERVE_ACCESS_EXCEEDED = ""Reserve access exceeded"";
}",1489
RealWorld_TA_112_IGauge_RealWorld_20240815151424.log,112,IGauge,34034,1295,35329,112.0,0.19607,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IGauge {
    function deposit(uint256) external;

    function balanceOf(address) external view returns (uint256);

    function withdraw(uint256) external;

    function user_checkpoint(address) external;

    function claimable_tokens(address) external view returns (uint256);
}

interface IVotingEscrow {
    function create_lock(uint256 _value, uint256 _time) external;

    function increase_amount(uint256 _value) external;

    function increase_unlock_time(uint256 _unlock_time) external;

    function withdraw() external;

    function balanceOf(address _address) external view returns (uint256);

    function totalSupply() external view returns (uint256);
}

interface IFeeDistributor {
    function claim(address _addr) external returns (uint256);
}

interface IMinter {
    function mint(address gauge_addr) external;
}",188
RealWorld_TA_112_VaultStorage_RealWorld_20240815121613.log,112,VaultStorage,39186,1250,40436,152.0,0.22093,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/EnumerableMapping.sol"";
import ""../../interfaces/IVaultReserve.sol"";
import ""../../interfaces/IStrategy.sol"";

contract VaultStorage {
    uint256 public currentAllocated;
    uint256 public waitingForRemovalAllocated;
    address public pool;

    uint256 public totalDebt;
    bool public strategyActive;

    EnumerableMapping.AddressToUintMap internal _strategiesWaitingForRemoval;
}

contract VaultStorageV1 is VaultStorage {
    /**
     * @dev This is to avoid breaking contracts inheriting from `VaultStorage`
     * such as `Erc20Vault`, especially if they have storage variables
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     * for more details
     *
     * A new field can be added using a new contract such as
     *
     * ```solidity
     * contract VaultStorageV2 is VaultStorage {
     *   uint256 someNewField;
     *   uint256[49] private __gap;
     * }
     */
    uint256[50] private __gap;
}",256
RealWorld_TA_112_IWETH_RealWorld_20240815145744.log,112,IWETH,27239,1423,28662,145.0,0.164655,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @notice Interface for WETH9
 * @dev https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code
 */
interface IWETH is IERC20 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}",112
RealWorld_TA_112_Preparable_RealWorld_20240815084418.log,112,Preparable,119961,2936,122897,109.0,0.658525,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IPreparable.sol"";
import ""../../libraries/Errors.sol"";

/**
 * @notice Implements the base logic for a two-phase commit
 * @dev This does not implements any access-control so publicly exposed
 * callers should make sure to have the proper checks in palce
 */
contract Preparable is IPreparable {
    uint256 private constant _MIN_DELAY = 3 days;

    mapping(bytes32 => address) public pendingAddresses;
    mapping(bytes32 => uint256) public pendingUInts256;

    mapping(bytes32 => address) public currentAddresses;
    mapping(bytes32 => uint256) public currentUInts256;

    /**
     * @dev Deadlines shares the same namespace regardless of the type
     * of the pending variable so this needs to be enforced in the caller
     */
    mapping(bytes32 => uint256) public deadlines;

    function _prepareDeadline(bytes32 key, uint256 delay) internal {
        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);
        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);
        deadlines[key] = block.timestamp + delay;
    }

    /**
     * @notice Prepares an uint256 that should be commited to the contract
     * after `_MIN_DELAY` elapsed
     * @param value The value to prepare
     * @return `true` if success.
     */
    function _prepare(
        bytes32 key,
        uint256 value,
        uint256 delay
    ) internal returns (bool) {
        _prepareDeadline(key, delay);
        pendingUInts256[key] = value;
        emit ConfigPreparedNumber(key, value, delay);
        return true;
    }

    /**
     * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay
     */
    function _prepare(bytes32 key, uint256 value) internal returns (bool) {
        return _prepare(key, value, _MIN_DELAY);
    }

    /**
     * @notice Prepares an address that should be commited to the contract
     * after `_MIN_DELAY` elapsed
     * @param value The value to prepare
     * @return `true` if success.
     */
    function _prepare(
        bytes32 key,
        address value,
        uint256 delay
    ) internal returns (bool) {
        _prepareDeadline(key, delay);
        pendingAddresses[key] = value;
        emit ConfigPreparedAddress(key, value, delay);
        return true;
    }

    /**
     * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay
     */
    function _prepare(bytes32 key, address value) internal returns (bool) {
        return _prepare(key, value, _MIN_DELAY);
    }

    /**
     * @notice Reset a uint256 key
     * @return `true` if success.
     */
    function _resetUInt256Config(bytes32 key) internal returns (bool) {
        require(deadlines[key] != 0, Error.DEADLINE_NOT_ZERO);
        deadlines[key] = 0;
        pendingUInts256[key] = 0;
        emit ConfigReset(key);
        return true;
    }

    /**
     * @notice Reset an address key
     * @return `true` if success.
     */
    function _resetAddressConfig(bytes32 key) internal returns (bool) {
        require(deadlines[key] != 0, Error.DEADLINE_NOT_ZERO);
        deadlines[key] = 0;
        pendingAddresses[key] = address(0);
        emit ConfigReset(key);
        return true;
    }

    /**
     * @dev Checks the deadline of the key and reset it
     */
    function _executeDeadline(bytes32 key) internal {
        uint256 deadline = deadlines[key];
        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);
        require(deadline != 0, Error.DEADLINE_NOT_SET);
        deadlines[key] = 0;
    }

    /**
     * @notice Execute uint256 config update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return New value.
     */
    function _executeUInt256(bytes32 key) internal returns (uint256) {
        _executeDeadline(key);
        uint256 newValue = pendingUInts256[key];
        _setConfig(key, newValue);
        return newValue;
    }

    /**
     * @notice Execute address config update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return New value.
     */
    function _executeAddress(bytes32 key) internal returns (address) {
        _executeDeadline(key);
        address newValue = pendingAddresses[key];
        _setConfig(key, newValue);
        return newValue;
    }

    function _setConfig(bytes32 key, address value) internal returns (address) {
        address oldValue = currentAddresses[key];
        currentAddresses[key] = value;
        pendingAddresses[key] = address(0);
        deadlines[key] = 0;
        emit ConfigUpdatedAddress(key, oldValue, value);
        return value;
    }

    function _setConfig(bytes32 key, uint256 value) internal returns (uint256) {
        uint256 oldValue = currentUInts256[key];
        currentUInts256[key] = value;
        pendingUInts256[key] = 0;
        deadlines[key] = 0;
        emit ConfigUpdatedNumber(key, oldValue, value);
        return value;
    }
}",1184
RealWorld_TA_112_ITopUpAction_RealWorld_20240815134358.log,112,ITopUpAction,74907,2517,77424,150.0,0.424875,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../IPreparable.sol"";
import ""../IAction.sol"";

interface ITopUpAction is IAction, IPreparable {
    struct RecordKey {
        address payer;
        bytes32 account;
        bytes32 protocol;
    }

    struct RecordMeta {
        bytes32 account;
        bytes32 protocol;
    }

    struct Record {
        uint64 threshold;
        uint64 priorityFee;
        uint64 maxFee;
        address actionToken;
        address depositToken;
        uint128 singleTopUpAmount; // denominated in action token
        uint128 totalTopUpAmount; // denominated in action token
        uint128 depositTokenBalance;
        bytes extra;
    }

    struct RecordWithMeta {
        bytes32 account;
        bytes32 protocol;
        Record record;
    }

    event Register(
        bytes32 indexed account,
        bytes32 indexed protocol,
        uint256 indexed threshold,
        address payer,
        address depositToken,
        uint256 depositAmount,
        address actionToken,
        uint256 singleTopUpAmount,
        uint256 totalTopUpAmount,
        uint256 maxGasPrice,
        bytes extra
    );

    event Deregister(address indexed payer, bytes32 indexed account, bytes32 indexed protocol);

    event TopUp(
        bytes32 indexed account,
        bytes32 indexed protocol,
        address indexed payer,
        address depositToken,
        uint256 consumedDepositAmount,
        address actionToken,
        uint256 topupAmount
    );

    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool);

    function execute(
        address payer,
        bytes32 account,
        address keeper,
        bytes32 protocol
    ) external returns (bool);

    function execute(
        address payer,
        bytes32 account,
        address keeper,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) external returns (bool);

    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external returns (bool);

    function getSupportedProtocols() external view returns (bytes32[] memory);

    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) external view returns (Record memory);

    function getUserPositions(address payer) external view returns (RecordMeta[] memory);

    function getHandler(bytes32 protocol) external view returns (address);

    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        returns (address[] memory users, uint256 nextCursor);

    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) external view returns (uint256);

    function getTopUpHandler(bytes32 protocol) external view returns (address);

    function prepareTopUpHandler(bytes32 protocol, address newHandler) external returns (bool);

    function executeTopUpHandler(bytes32 protocol) external returns (address);

    function resetTopUpHandler(bytes32 protocol) external returns (bool);

    function getSwapperSlippage() external view returns (uint256);
}",665
RealWorld_TA_112_Controller_RealWorld_20240815080217.log,112,Controller,99234,2055,101289,91.0,0.53727,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../interfaces/actions/IAction.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../interfaces/tokenomics/IInflationManager.sol"";

import ""../libraries/AddressProviderHelpers.sol"";

import ""./utils/Preparable.sol"";
import ""./access/Authorization.sol"";

contract Controller is IController, Authorization, Preparable {
    using AddressProviderHelpers for IAddressProvider;

    IAddressProvider public immutable override addressProvider;

    IInflationManager public inflationManager;

    bytes32 internal constant _KEEPER_REQUIRED_STAKED_BKD = ""KEEPER_REQUIRED_STAKED_BKD"";

    constructor(IAddressProvider _addressProvider)
        Authorization(_addressProvider.getRoleManager())
    {
        addressProvider = _addressProvider;
    }

    function setInflationManager(address _inflationManager) external onlyGovernance {
        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);
        require(_inflationManager != address(0), Error.INVALID_ARGUMENT);
        inflationManager = IInflationManager(_inflationManager);
    }

    function addStakerVault(address stakerVault)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)
        returns (bool)
    {
        if (!addressProvider.addStakerVault(stakerVault)) {
            return false;
        }
        if (address(inflationManager) != address(0)) {
            address lpGauge = IStakerVault(stakerVault).getLpGauge();
            if (lpGauge != address(0)) {
                inflationManager.whitelistGauge(lpGauge);
            }
        }
        return true;
    }

    /**
     * @notice Delists pool.
     * @param pool Address of pool to delist.
     * @return `true` if successful.
     */
    function removePool(address pool) external override onlyGovernance returns (bool) {
        if (!addressProvider.removePool(pool)) {
            return false;
        }
        address lpToken = ILiquidityPool(pool).getLpToken();

        if (address(inflationManager) != address(0)) {
            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);
            if (exists) {
                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);
            }
        }

        return true;
    }

    /**
     * @notice Prepares the minimum amount of staked BKD required by a keeper
     */
    function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {
        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);
    }

    /**
     * @notice Sets the minimum amount of staked BKD required by a keeper to the prepared value
     */
    function executeKeeperRequiredStakedBKD() external override {
        _executeUInt256(_KEEPER_REQUIRED_STAKED_BKD);
    }

    /**
     * @notice Returns true if the given keeper has enough staked BKD to execute actions
     */
    function canKeeperExecuteAction(address keeper) external view override returns (bool) {
        uint256 requiredBKD = getKeeperRequiredStakedBKD();
        return
            requiredBKD == 0 ||
            IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;
    }

    /**
     * @return Returns the minimum amount of staked BKD required by a keeper
     */
    function getKeeperRequiredStakedBKD() public view override returns (uint256) {
        return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];
    }

    /**
     * @return the total amount of ETH require by `payer` to cover the fees for
     * positions registered in all actions
     */
    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {
        // solhint-disable-previous-line ordering
        uint256 totalEthRequired = 0;
        address[] memory actions = addressProvider.allActions();
        uint256 numActions = actions.length;
        for (uint256 i = 0; i < numActions; i++) {
            totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);
        }
        return totalEthRequired;
    }
}",959
RealWorld_TA_112_MockChainlinkFeed_RealWorld_20240815092312.log,112,MockChainlinkFeed,32661,1458,34119,85.0,0.192465,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.9;

contract MockChainlinkFeed {
    uint8 public immutable decimals;
    int256 public immutable price;
    uint256 public immutable lastUpdate;

    constructor(
        uint8 _decimals,
        int256 _price,
        uint256 _lastUpdate
    ) {
        decimals = _decimals;
        price = _price;
        lastUpdate = _lastUpdate;
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, price, lastUpdate, lastUpdate, 0);
    }
}",167
RealWorld_TA_112_LiquidityPool_RealWorld_20240815115958.log,112,LiquidityPool,572536,5053,577589,230.0,2.96374,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/pool/ILiquidityPool.sol"";
import ""../../interfaces/ILpToken.sol"";
import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IVault.sol"";

import ""../../libraries/AddressProviderHelpers.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/ScaledMath.sol"";

import ""../access/Authorization.sol"";
import ""../utils/Preparable.sol"";
import ""../utils/Pausable.sol"";

/**
 * @dev Pausing/unpausing the pool will disable/re-enable deposits.
 */
abstract contract LiquidityPool is
    ILiquidityPool,
    Authorization,
    Preparable,
    Pausable,
    Initializable
{
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    struct WithdrawalFeeMeta {
        uint64 timeToWait;
        uint64 feeRatio;
        uint64 lastActionTimestamp;
    }

    bytes32 internal constant _VAULT_KEY = ""Vault"";
    bytes32 internal constant _RESERVE_DEVIATION_KEY = ""ReserveDeviation"";
    bytes32 internal constant _REQUIRED_RESERVES_KEY = ""RequiredReserves"";

    bytes32 internal constant _MAX_WITHDRAWAL_FEE_KEY = ""MaxWithdrawalFee"";
    bytes32 internal constant _MIN_WITHDRAWAL_FEE_KEY = ""MinWithdrawalFee"";
    bytes32 internal constant _WITHDRAWAL_FEE_DECREASE_PERIOD_KEY = ""WithdrawalFeeDecreasePeriod"";

    uint256 internal constant _INITIAL_RESERVE_DEVIATION = 0.005e18; // 0.5%
    uint256 internal constant _INITIAL_FEE_DECREASE_PERIOD = 1 weeks;
    uint256 internal constant _INITIAL_MAX_WITHDRAWAL_FEE = 0.03e18; // 3%

    /**
     * @notice even through admin votes and later governance, the withdrawal
     * fee will never be able to go above this value
     */
    uint256 internal constant _MAX_WITHDRAWAL_FEE = 0.05e18;

    /**
     * @notice Keeps track of the withdrawal fees on a per-address basis
     */
    mapping(address => WithdrawalFeeMeta) public withdrawalFeeMetas;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    uint256 public depositCap;
    IStakerVault public staker;
    ILpToken public lpToken;
    string public name;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = IController(_controller);
        addressProvider = IController(_controller).addressProvider();
    }

    /**
     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.
     * @param depositAmount Amount of the underlying asset to supply.
     * @return The actual amount minted.
     */
    function deposit(uint256 depositAmount) external payable override returns (uint256) {
        return depositFor(msg.sender, depositAmount, 0);
    }

    /**
     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.
     * @param depositAmount Amount of the underlying asset to supply.
     * @param minTokenAmount Minimum amount of LP tokens that should be minted.
     * @return The actual amount minted.
     */
    function deposit(uint256 depositAmount, uint256 minTokenAmount)
        external
        payable
        override
        returns (uint256)
    {
        return depositFor(msg.sender, depositAmount, minTokenAmount);
    }

    /**
     * @notice Deposit funds into liquidity pool and stake LP Tokens in Staker Vault.
     * @param depositAmount Amount of the underlying asset to supply.
     * @param minTokenAmount Minimum amount of LP tokens that should be minted.
     * @return The actual amount minted and staked.
     */
    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)
        external
        payable
        override
        returns (uint256)
    {
        uint256 amountMinted_ = depositFor(address(this), depositAmount, minTokenAmount);
        staker.stakeFor(msg.sender, amountMinted_);
        return amountMinted_;
    }

    /**
     * @notice Withdraws all funds from vault.
     * @dev Should be called in case of emergencies.
     */
    function withdrawAll() external override onlyGovernance {
        getVault().withdrawAll();
    }

    function setLpToken(address _lpToken)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)
        returns (bool)
    {
        require(address(lpToken) == address(0), Error.ADDRESS_ALREADY_SET);
        require(ILpToken(_lpToken).minter() == address(this), Error.INVALID_MINTER);
        lpToken = ILpToken(_lpToken);
        _approveStakerVaultSpendingLpTokens();
        emit LpTokenSet(_lpToken);
        return true;
    }

    /**
     * @notice Checkpoint function to update a user's withdrawal fees on deposit and redeem
     * @param from Address sending from
     * @param to Address sending to
     * @param amount Amount to redeem or deposit
     */
    function handleLpTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) external override {
        require(
            msg.sender == address(lpToken) || msg.sender == address(staker),
            Error.UNAUTHORIZED_ACCESS
        );
        if (
            addressProvider.isStakerVault(to, address(lpToken)) ||
            addressProvider.isStakerVault(from, address(lpToken)) ||
            addressProvider.isAction(to) ||
            addressProvider.isAction(from)
        ) {
            return;
        }

        if (to != address(0)) {
            _updateUserFeesOnDeposit(to, from, amount);
        }
    }

    /**
     * @notice Prepare update of required reserve ratio (with time delay enforced).
     * @param _newRatio New required reserve ratio.
     * @return `true` if success.
     */
    function prepareNewRequiredReserves(uint256 _newRatio) external onlyGovernance returns (bool) {
        require(_newRatio <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        return _prepare(_REQUIRED_RESERVES_KEY, _newRatio);
    }

    /**
     * @notice Execute required reserve ratio update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New required reserve ratio.
     */
    function executeNewRequiredReserves() external override returns (uint256) {
        uint256 requiredReserveRatio = _executeUInt256(_REQUIRED_RESERVES_KEY);
        _rebalanceVault();
        return requiredReserveRatio;
    }

    /**
     * @notice Reset the prepared required reserves.
     * @return `true` if success.
     */
    function resetRequiredReserves() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_REQUIRED_RESERVES_KEY);
    }

    /**
     * @notice Prepare update of reserve deviation ratio (with time delay enforced).
     * @param newRatio New reserve deviation ratio.
     * @return `true` if success.
     */
    function prepareNewReserveDeviation(uint256 newRatio) external onlyGovernance returns (bool) {
        require(newRatio <= (ScaledMath.DECIMAL_SCALE * 50) / 100, Error.INVALID_AMOUNT);
        return _prepare(_RESERVE_DEVIATION_KEY, newRatio);
    }

    /**
     * @notice Execute reserve deviation ratio update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New reserve deviation ratio.
     */
    function executeNewReserveDeviation() external override returns (uint256) {
        uint256 reserveDeviation = _executeUInt256(_RESERVE_DEVIATION_KEY);
        _rebalanceVault();
        return reserveDeviation;
    }

    /**
     * @notice Reset the prepared reserve deviation.
     * @return `true` if success.
     */
    function resetNewReserveDeviation() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_RESERVE_DEVIATION_KEY);
    }

    /**
     * @notice Prepare update of min withdrawal fee (with time delay enforced).
     * @param newFee New min withdrawal fee.
     * @return `true` if success.
     */
    function prepareNewMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _checkFeeInvariants(newFee, getMaxWithdrawalFee());
        return _prepare(_MIN_WITHDRAWAL_FEE_KEY, newFee);
    }

    /**
     * @notice Execute min withdrawal fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New withdrawal fee.
     */
    function executeNewMinWithdrawalFee() external returns (uint256) {
        uint256 newFee = _executeUInt256(_MIN_WITHDRAWAL_FEE_KEY);
        _checkFeeInvariants(newFee, getMaxWithdrawalFee());
        return newFee;
    }

    /**
     * @notice Reset the prepared min withdrawal fee
     * @return `true` if success.
     */
    function resetNewMinWithdrawalFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MIN_WITHDRAWAL_FEE_KEY);
    }

    /**
     * @notice Prepare update of max withdrawal fee (with time delay enforced).
     * @param newFee New max withdrawal fee.
     * @return `true` if success.
     */
    function prepareNewMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _checkFeeInvariants(getMinWithdrawalFee(), newFee);
        return _prepare(_MAX_WITHDRAWAL_FEE_KEY, newFee);
    }

    /**
     * @notice Execute max withdrawal fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New max withdrawal fee.
     */
    function executeNewMaxWithdrawalFee() external override returns (uint256) {
        uint256 newFee = _executeUInt256(_MAX_WITHDRAWAL_FEE_KEY);
        _checkFeeInvariants(getMinWithdrawalFee(), newFee);
        return newFee;
    }

    /**
     * @notice Reset the prepared max fee.
     * @return `true` if success.
     */
    function resetNewMaxWithdrawalFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_WITHDRAWAL_FEE_KEY);
    }

    /**
     * @notice Prepare update of withdrawal decrease fee period (with time delay enforced).
     * @param newPeriod New withdrawal fee decrease period.
     * @return `true` if success.
     */
    function prepareNewWithdrawalFeeDecreasePeriod(uint256 newPeriod)
        external
        onlyGovernance
        returns (bool)
    {
        return _prepare(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, newPeriod);
    }

    /**
     * @notice Execute withdrawal fee decrease period update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New withdrawal fee decrease period.
     */
    function executeNewWithdrawalFeeDecreasePeriod() external returns (uint256) {
        return _executeUInt256(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);
    }

    /**
     * @notice Reset the prepared withdrawal fee decrease period update.
     * @return `true` if success.
     */
    function resetNewWithdrawalFeeDecreasePeriod() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);
    }

    /**
     * @notice Set the staker vault for this pool's LP token
     * @dev Staker vault and LP token pairs are immutable and the staker vault can only be set once for a pool.
     *      Only one vault exists per LP token. This information will be retrieved from the controller of the pool.
     * @return Address of the new staker vault for the pool.
     */
    function setStaker()
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)
        returns (bool)
    {
        require(address(staker) == address(0), Error.ADDRESS_ALREADY_SET);
        address stakerVault = addressProvider.getStakerVault(address(lpToken));
        require(stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        staker = IStakerVault(stakerVault);
        _approveStakerVaultSpendingLpTokens();
        emit StakerVaultSet(stakerVault);
        return true;
    }

    /**
     * @notice Prepare setting a new Vault (with time delay enforced).
     * @param _vault Address of new Vault contract.
     * @return `true` if success.
     */
    function prepareNewVault(address _vault) external override onlyGovernance returns (bool) {
        _prepare(_VAULT_KEY, _vault);
        return true;
    }

    /**
     * @notice Execute Vault update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return Address of new Vault contract.
     */
    function executeNewVault() external override returns (address) {
        IVault vault = getVault();
        if (address(vault) != address(0)) {
            vault.withdrawAll();
        }
        address newVault = _executeAddress(_VAULT_KEY);
        addressProvider.updateVault(address(vault), newVault);
        return newVault;
    }

    /**
     * @notice Reset the vault deadline.
     * @return `true` if success.
     */
    function resetNewVault() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_VAULT_KEY);
    }

    /**
     * @notice Redeems the underlying asset by burning LP tokens.
     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.
     * @return Actual amount of the underlying redeemed.
     */
    function redeem(uint256 redeemLpTokens) external override returns (uint256) {
        return redeem(redeemLpTokens, 0);
    }

    /**
     * @notice Uncap the pool to remove the deposit limit.
     * @return `true` if success.
     */
    function uncap() external override onlyGovernance returns (bool) {
        require(isCapped(), Error.NOT_CAPPED);

        depositCap = 0;
        return true;
    }

    /**
     * @notice Update the deposit cap value.
     * @param _depositCap The maximum allowed deposits per address in the pool
     * @return `true` if success.
     */
    function updateDepositCap(uint256 _depositCap) external override onlyGovernance returns (bool) {
        require(isCapped(), Error.NOT_CAPPED);
        require(depositCap != _depositCap, Error.SAME_AS_CURRENT);
        require(_depositCap > 0, Error.INVALID_AMOUNT);

        depositCap = _depositCap;
        return true;
    }

    /**
     * @notice Rebalance vault according to required underlying backing reserves.
     */
    function rebalanceVault() external onlyGovernance {
        _rebalanceVault();
    }

    /**
     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.
     * @param account Account to deposit for.
     * @param depositAmount Amount of the underlying asset to supply.
     * @return Actual amount minted.
     */
    function depositFor(address account, uint256 depositAmount)
        external
        payable
        override
        returns (uint256)
    {
        return depositFor(account, depositAmount, 0);
    }

    /**
     * @notice Redeems the underlying asset by burning LP tokens, unstaking any LP tokens needed.
     * @param redeemLpTokens Number of tokens to unstake and/or burn for redeeming the underlying.
     * @param minRedeemAmount Minimum amount of underlying that should be received.
     * @return Actual amount of the underlying redeemed.
     */
    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)
        external
        override
        returns (uint256)
    {
        uint256 lpBalance_ = lpToken.balanceOf(msg.sender);
        require(
            lpBalance_ + staker.balanceOf(msg.sender) >= redeemLpTokens,
            Error.INSUFFICIENT_BALANCE
        );
        if (lpBalance_ < redeemLpTokens) {
            staker.unstakeFor(msg.sender, msg.sender, redeemLpTokens - lpBalance_);
        }
        return redeem(redeemLpTokens, minRedeemAmount);
    }

    /**
     * @notice Returns the address of the LP token of this pool
     * @return The address of the LP token
     */
    function getLpToken() external view override returns (address) {
        return address(lpToken);
    }

    /**
     * @notice Calculates the amount of LP tokens that need to be redeemed to get a certain amount of underlying (includes fees and exchange rate)
     * @param account Address of the account redeeming.
     * @param underlyingAmount The amount of underlying desired.
     * @return Amount of LP tokens that need to be redeemed.
     */
    function calcRedeem(address account, uint256 underlyingAmount)
        external
        view
        override
        returns (uint256)
    {
        require(underlyingAmount > 0, Error.INVALID_AMOUNT);
        ILpToken lpToken_ = lpToken;
        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);

        uint256 currentExchangeRate = exchangeRate();
        uint256 withoutFeesLpAmount = underlyingAmount.scaledDiv(currentExchangeRate);
        if (withoutFeesLpAmount == lpToken_.totalSupply()) {
            return withoutFeesLpAmount;
        }

        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];

        uint256 currentFeeRatio = 0;
        if (!addressProvider.isAction(account)) {
            currentFeeRatio = getNewCurrentFees(
                meta.timeToWait,
                meta.lastActionTimestamp,
                meta.feeRatio
            );
        }
        uint256 scalingFactor = currentExchangeRate.scaledMul((ScaledMath.ONE - currentFeeRatio));
        uint256 neededLpTokens = underlyingAmount.scaledDivRoundUp(scalingFactor);

        return neededLpTokens;
    }

    function getUnderlying() external view virtual override returns (address);

    /**
     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.
     * @param account Account to deposit for.
     * @param depositAmount Amount of the underlying asset to supply.
     * @param minTokenAmount Minimum amount of LP tokens that should be minted.
     * @return Actual amount minted.
     */
    function depositFor(
        address account,
        uint256 depositAmount,
        uint256 minTokenAmount
    ) public payable override notPaused returns (uint256) {
        uint256 rate = exchangeRate();

        if (isCapped()) {
            uint256 lpBalance = lpToken.balanceOf(account);
            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);
            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);
            require(
                currentUnderlyingBalance + depositAmount <= depositCap,
                Error.EXCEEDS_DEPOSIT_CAP
            );
        }

        _doTransferIn(msg.sender, depositAmount);
        uint256 mintedLp = depositAmount.scaledDiv(rate);
        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);

        lpToken.mint(account, mintedLp);
        _rebalanceVault();

        if (msg.sender == account || address(this) == account) {
            emit Deposit(msg.sender, depositAmount, mintedLp);
        } else {
            emit DepositFor(msg.sender, account, depositAmount, mintedLp);
        }
        return mintedLp;
    }

    /**
     * @notice Redeems the underlying asset by burning LP tokens.
     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.
     * @param minRedeemAmount Minimum amount of underlying that should be received.
     * @return Actual amount of the underlying redeemed.
     */
    function redeem(uint256 redeemLpTokens, uint256 minRedeemAmount)
        public
        override
        returns (uint256)
    {
        require(redeemLpTokens > 0, Error.INVALID_AMOUNT);
        ILpToken lpToken_ = lpToken;
        require(lpToken_.balanceOf(msg.sender) >= redeemLpTokens, Error.INSUFFICIENT_BALANCE);

        uint256 withdrawalFee = addressProvider.isAction(msg.sender)
            ? 0
            : getWithdrawalFee(msg.sender, redeemLpTokens);
        uint256 redeemMinusFees = redeemLpTokens - withdrawalFee;
        // Pay no fees on the last withdrawal (avoid locking funds in the pool)
        if (redeemLpTokens == lpToken_.totalSupply()) {
            redeemMinusFees = redeemLpTokens;
        }
        uint256 redeemUnderlying = redeemMinusFees.scaledMul(exchangeRate());
        require(redeemUnderlying >= minRedeemAmount, Error.NOT_ENOUGH_FUNDS_WITHDRAWN);

        _rebalanceVault(redeemUnderlying);

        lpToken_.burn(msg.sender, redeemLpTokens);
        _doTransferOut(payable(msg.sender), redeemUnderlying);
        emit Redeem(msg.sender, redeemUnderlying, redeemLpTokens);
        return redeemUnderlying;
    }

    /**
     * @return the current required reserves ratio
     */
    function getRequiredReserveRatio() public view virtual returns (uint256) {
        return currentUInts256[_REQUIRED_RESERVES_KEY];
    }

    /**
     * @return the current maximum reserve deviation ratio
     */
    function getMaxReserveDeviationRatio() public view virtual returns (uint256) {
        return currentUInts256[_RESERVE_DEVIATION_KEY];
    }

    /**
     * @notice Returns the current minimum withdrawal fee
     */
    function getMinWithdrawalFee() public view returns (uint256) {
        return currentUInts256[_MIN_WITHDRAWAL_FEE_KEY];
    }

    /**
     * @notice Returns the current maximum withdrawal fee
     */
    function getMaxWithdrawalFee() public view returns (uint256) {
        return currentUInts256[_MAX_WITHDRAWAL_FEE_KEY];
    }

    /**
     * @notice Returns the current withdrawal fee decrease period
     */
    function getWithdrawalFeeDecreasePeriod() public view returns (uint256) {
        return currentUInts256[_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY];
    }

    /**
     * @return the current vault of the liquidity pool
     */
    function getVault() public view virtual override returns (IVault) {
        return IVault(currentAddresses[_VAULT_KEY]);
    }

    /**
     * @notice Compute current exchange rate of LP tokens to underlying scaled to 1e18.
     * @dev Exchange rate means: underlying = LP token * exchangeRate
     * @return Current exchange rate.
     */
    function exchangeRate() public view override returns (uint256) {
        uint256 totalUnderlying_ = totalUnderlying();
        uint256 totalSupply = lpToken.totalSupply();
        if (totalSupply == 0 || totalUnderlying_ == 0) {
            return ScaledMath.ONE;
        }

        return totalUnderlying_.scaledDiv(totalSupply);
    }

    /**
     * @notice Compute total amount of underlying tokens for this pool.
     * @return Total amount of underlying in pool.
     */
    function totalUnderlying() public view override returns (uint256) {
        IVault vault = getVault();
        uint256 balanceUnderlying = _getBalanceUnderlying();
        if (address(vault) == address(0)) {
            return balanceUnderlying;
        }
        uint256 investedUnderlying = vault.getTotalUnderlying();
        return investedUnderlying + balanceUnderlying;
    }

    /**
     * @notice Retuns if the pool has an active deposit limit
     * @return `true` if there is currently a deposit limit
     */
    function isCapped() public view override returns (bool) {
        return depositCap != 0;
    }

    /**
     * @notice Returns the withdrawal fee for `account`
     * @param account Address to get the withdrawal fee for
     * @param amount Amount to calculate the withdrawal fee for
     * @return Withdrawal fee in LP tokens
     */
    function getWithdrawalFee(address account, uint256 amount)
        public
        view
        override
        returns (uint256)
    {
        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];

        if (lpToken.balanceOf(account) == 0) {
            return 0;
        }
        uint256 currentFee = getNewCurrentFees(
            meta.timeToWait,
            meta.lastActionTimestamp,
            meta.feeRatio
        );
        return amount.scaledMul(currentFee);
    }

    /**
     * @notice Calculates the withdrawal fee a user would currently need to pay on currentBalance.
     * @param timeToWait The total time to wait until the withdrawal fee reached the min. fee
     * @param lastActionTimestamp Timestamp of the last fee update
     * @param feeRatio Fees that would currently be paid on the user's entire balance
     * @return Updated fee amount on the currentBalance
     */
    function getNewCurrentFees(
        uint256 timeToWait,
        uint256 lastActionTimestamp,
        uint256 feeRatio
    ) public view returns (uint256) {
        uint256 timeElapsed = _getTime() - lastActionTimestamp;
        uint256 minFeePercentage = getMinWithdrawalFee();
        if (timeElapsed >= timeToWait) {
            return minFeePercentage;
        }
        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);
        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);
    }

    function _rebalanceVault() internal {
        _rebalanceVault(0);
    }

    function _initialize(
        string memory name_,
        uint256 depositCap_,
        address vault_
    ) internal initializer returns (bool) {
        name = name_;
        depositCap = depositCap_;

        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, _INITIAL_FEE_DECREASE_PERIOD);
        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _INITIAL_MAX_WITHDRAWAL_FEE);
        _setConfig(_REQUIRED_RESERVES_KEY, ScaledMath.ONE);
        _setConfig(_RESERVE_DEVIATION_KEY, _INITIAL_RESERVE_DEVIATION);
        _setConfig(_VAULT_KEY, vault_);
        return true;
    }

    function _approveStakerVaultSpendingLpTokens() internal {
        address staker_ = address(staker);
        address lpToken_ = address(lpToken);
        if (staker_ == address(0) || lpToken_ == address(0)) return;
        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);
    }

    function _doTransferIn(address from, uint256 amount) internal virtual;

    function _doTransferOut(address payable to, uint256 amount) internal virtual;

    /**
     * @dev Rebalances the pool's allocations to the vault
     * @param underlyingToWithdraw Amount of underlying to withdraw such that after the withdrawal the pool and vault allocations are correctly balanced.
     */
    function _rebalanceVault(uint256 underlyingToWithdraw) internal {
        IVault vault = getVault();

        if (address(vault) == address(0)) return;
        uint256 lockedLp = staker.getStakedByActions();
        uint256 totalUnderlyingStaked = lockedLp.scaledMul(exchangeRate());

        uint256 underlyingBalance = _getBalanceUnderlying(true);
        uint256 maximumDeviation = totalUnderlyingStaked.scaledMul(getMaxReserveDeviationRatio());

        uint256 nextTargetBalance = totalUnderlyingStaked.scaledMul(getRequiredReserveRatio());

        if (
            underlyingToWithdraw > underlyingBalance ||
            (underlyingBalance - underlyingToWithdraw) + maximumDeviation < nextTargetBalance
        ) {
            uint256 requiredDeposits = nextTargetBalance + underlyingToWithdraw - underlyingBalance;
            vault.withdraw(requiredDeposits);
        } else {
            uint256 nextBalance = underlyingBalance - underlyingToWithdraw;
            if (nextBalance > nextTargetBalance + maximumDeviation) {
                uint256 excessDeposits = nextBalance - nextTargetBalance;
                _doTransferOut(payable(address(vault)), excessDeposits);
                vault.deposit();
            }
        }
    }

    function _updateUserFeesOnDeposit(
        address account,
        address from,
        uint256 amountAdded
    ) internal {
        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];
        uint256 balance = lpToken.balanceOf(account) +
            staker.stakedAndActionLockedBalanceOf(account);
        uint256 newCurrentFeeRatio = getNewCurrentFees(
            meta.timeToWait,
            meta.lastActionTimestamp,
            meta.feeRatio
        );
        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);
        uint256 shareExisting = ScaledMath.ONE - shareAdded;
        uint256 feeOnDeposit;
        if (from == address(0)) {
            feeOnDeposit = getMaxWithdrawalFee();
        } else {
            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];
            feeOnDeposit = getNewCurrentFees(
                fromMeta.timeToWait,
                fromMeta.lastActionTimestamp,
                fromMeta.feeRatio
            );
        }

        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +
            shareAdded.scaledMul(feeOnDeposit);

        meta.feeRatio = uint64(newFeeRatio);
        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());
        meta.lastActionTimestamp = uint64(_getTime());
    }

    function _getBalanceUnderlying() internal view virtual returns (uint256);

    function _getBalanceUnderlying(bool transferInDone) internal view virtual returns (uint256);

    function _isAuthorizedToPause(address account) internal view override returns (bool) {
        return _roleManager().hasRole(Roles.GOVERNANCE, account);
    }

    /**
     * @dev Overriden for testing
     */
    function _getTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    function _checkFeeInvariants(uint256 minFee, uint256 maxFee) internal pure {
        require(maxFee >= minFee, Error.INVALID_AMOUNT);
        require(maxFee <= _MAX_WITHDRAWAL_FEE, Error.INVALID_AMOUNT);
    }
}",6754
RealWorld_TA_112_CvxMintAmount_RealWorld_20240815084609.log,112,CvxMintAmount,50735,1633,52368,84.0,0.286335,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

abstract contract CvxMintAmount {
    uint256 private constant _CLIFF_SIZE = 100000 * 1e18; //new cliff every 100,000 tokens
    uint256 private constant _CLIFF_COUNT = 1000; // 1,000 cliffs
    uint256 private constant _MAX_SUPPLY = 100000000 * 1e18; //100 mil max supply
    IERC20 private constant _CVX_TOKEN =
        IERC20(address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)); // CVX Token

    function getCvxMintAmount(uint256 crvEarned) public view returns (uint256) {
        //first get total supply
        uint256 cvxTotalSupply = _CVX_TOKEN.totalSupply();

        //get current cliff
        uint256 currentCliff = cvxTotalSupply / _CLIFF_SIZE;

        //if current cliff is under the max
        if (currentCliff >= _CLIFF_COUNT) return 0;

        //get remaining cliffs
        uint256 remaining = _CLIFF_COUNT - currentCliff;

        //multiply ratio of remaining cliffs to total cliffs against amount CRV received
        uint256 cvxEarned = (crvEarned * remaining) / _CLIFF_COUNT;

        //double check we have not gone over the max supply
        uint256 amountTillMax = _MAX_SUPPLY - cvxTotalSupply;
        if (cvxEarned > amountTillMax) cvxEarned = amountTillMax;
        return cvxEarned;
    }
}",390
RealWorld_TA_112_IVault_RealWorld_20240815130026.log,112,IVault,45368,2262,47630,178.0,0.27208,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IStrategy.sol"";
import ""./IPreparable.sol"";

/**
 * @title Interface for a Vault
 */

interface IVault is IPreparable {
    event StrategyActivated(address indexed strategy);

    event StrategyDeactivated(address indexed strategy);

    /**
     * @dev 'netProfit' is the profit after all fees have been deducted
     */
    event Harvest(uint256 indexed netProfit, uint256 indexed loss);

    function initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) external;

    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256);

    function deposit() external payable;

    function withdraw(uint256 amount) external returns (bool);

    function initializeStrategy(address strategy_) external returns (bool);

    function withdrawAll() external;

    function withdrawFromReserve(uint256 amount) external;

    function executeNewStrategy() external returns (address);

    function prepareNewStrategy(address newStrategy) external returns (bool);

    function getStrategy() external view returns (IStrategy);

    function getStrategiesWaitingForRemoval() external view returns (address[] memory);

    function getAllocatedToStrategyWaitingForRemoval(address strategy)
        external
        view
        returns (uint256);

    function getTotalUnderlying() external view returns (uint256);

    function getUnderlying() external view returns (address);
}",318
RealWorld_TA_112_ITopUpKeeperHelper_RealWorld_20240815133919.log,112,ITopUpKeeperHelper,33047,1240,34287,138.0,0.190035,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./ITopUpAction.sol"";

interface ITopUpKeeperHelper {
    struct TopupData {
        address payer;
        bytes32 account;
        bytes32 protocol;
        ITopUpAction.Record record;
    }

    function listPositions(address payer)
        external
        view
        returns (ITopUpAction.RecordWithMeta[] memory);

    function getExecutableTopups(uint256 cursor, uint256 howMany)
        external
        returns (TopupData[] memory topups, uint256 nextCursor);

    function canExecute(ITopUpAction.RecordKey calldata key) external view returns (bool);

    function batchCanExecute(ITopUpAction.RecordKey[] calldata keys)
        external
        returns (bool[] memory);
}",175
RealWorld_TA_112_ComptrollerInterface_RealWorld_20240815141552.log,112,ComptrollerInterface,71898,1680,73578,186.0,0.39309,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

abstract contract ComptrollerInterface {
    /// @notice Indicator that this is a Comptroller contract (for inspection)
    bool public constant isComptroller = true;

    /*** Assets You Are In ***/

    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);

    function exitMarket(address cToken) external virtual returns (uint256);

    /*** Policy Hooks ***/

    function mintAllowed(
        address cToken,
        address minter,
        uint256 mintAmount
    ) external virtual returns (uint256);

    function mintVerify(
        address cToken,
        address minter,
        uint256 mintAmount,
        uint256 mintTokens
    ) external virtual;

    function redeemAllowed(
        address cToken,
        address redeemer,
        uint256 redeemTokens
    ) external virtual returns (uint256);

    function redeemVerify(
        address cToken,
        address redeemer,
        uint256 redeemAmount,
        uint256 redeemTokens
    ) external virtual;

    function borrowAllowed(
        address cToken,
        address borrower,
        uint256 borrowAmount
    ) external virtual returns (uint256);

    function borrowVerify(
        address cToken,
        address borrower,
        uint256 borrowAmount
    ) external virtual;

    function repayBorrowAllowed(
        address cToken,
        address payer,
        address borrower,
        uint256 repayAmount
    ) external virtual returns (uint256);

    function repayBorrowVerify(
        address cToken,
        address payer,
        address borrower,
        uint256 repayAmount,
        uint256 borrowerIndex
    ) external virtual;

    function liquidateBorrowAllowed(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint256 repayAmount
    ) external virtual returns (uint256);

    function liquidateBorrowVerify(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint256 repayAmount,
        uint256 seizeTokens
    ) external virtual;

    function seizeAllowed(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint256 seizeTokens
    ) external virtual returns (uint256);

    function seizeVerify(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint256 seizeTokens
    ) external virtual;

    function transferAllowed(
        address cToken,
        address src,
        address dst,
        uint256 transferTokens
    ) external virtual returns (uint256);

    function transferVerify(
        address cToken,
        address src,
        address dst,
        uint256 transferTokens
    ) external virtual;

    /*** Liquidity/Liquidation Calculations ***/

    function liquidateCalculateSeizeTokens(
        address cTokenBorrowed,
        address cTokenCollateral,
        uint256 repayAmount
    ) external view virtual returns (uint256, uint256);
}",653
RealWorld_TA_112_MockERC20Swapper_RealWorld_20240815091941.log,112,MockERC20Swapper,35699,3094,38793,102.0,0.240375,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../interfaces/ISwapper.sol"";

contract MockERC20Swapper is ISwapper {
    using ScaledMath for uint256;
    uint256 public constant RATE = 1.1 * 1e18;

    function swap(
        address,
        address toToken,
        uint256 swapAmount,
        uint256
    ) external override returns (uint256) {
        // Assumes a suffient amount of toTokens was minted to the contract
        uint256 amount = swapAmount.scaledMul(RATE);
        ERC20(toToken).transfer(msg.sender, amount);
        return amount;
    }

    function getRate(address, address) external pure override returns (uint256) {
        return RATE;
    }
}",197
RealWorld_TA_112_IBkdLocker_RealWorld_20240815132506.log,112,IBkdLocker,54325,1610,55935,127.0,0.303825,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IBkdLocker {
    struct WithdrawStash {
        uint256 releaseTime;
        uint256 amount;
    }

    struct RewardTokenData {
        mapping(address => uint256) userFeeIntegrals;
        mapping(address => uint256) userShares;
        uint256 feeBalance;
        uint256 feeIntegral;
    }

    event Locked(address indexed user, uint256 amount);
    event WithdrawPrepared(address indexed user, uint256 amount);
    event WithdrawExecuted(address indexed user, uint256 amount);
    event RewardsClaimed(address indexed user, address indexed rewardToken, uint256 amount);
    event FeesDeposited(uint256 amount);

    function initialize(
        uint256 startBoost,
        uint256 maxBoost,
        uint256 increasePeriod,
        uint256 withdrawDelay
    ) external;

    function migrate(address newRewardToken) external;

    function lock(uint256 amount) external;

    function lockFor(address user, uint256 amount) external;

    function userCheckpoint(address user) external;

    function claimFees() external;

    function claimFees(address _rewardToken) external;

    function prepareUnlock(uint256 amount) external;

    function executeUnlocks() external;

    function getUserShare(address user) external view returns (uint256);

    function getUserShare(address user, address _rewardToken) external view returns (uint256);

    function getStashedGovTokens(address user) external view returns (WithdrawStash[] memory);

    function claimableFees(address user) external view returns (uint256);

    function claimableFees(address user, address _rewardToken) external view returns (uint256);

    function boostedBalance(address user) external view returns (uint256);

    function balanceOf(address user) external view returns (uint256);

    function getShareOfTotalBoostedBalance(address user) external view returns (uint256);

    function computeNewBoost(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) external view returns (uint256);
}",430
RealWorld_TA_112_ILendingPool_RealWorld_20240815145419.log,112,ILendingPool,349930,3006,352936,203.0,1.80977,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""../../libraries/vendor/DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(
        address indexed reserve,
        address indexed user,
        address indexed to,
        uint256 amount
    );

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(
        address indexed reserve,
        address indexed user,
        address indexed repayer,
        uint256 amount
    );

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external payable;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)
        external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset)
        external
        view
        returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user)
        external
        view
        returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    // function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3996
RealWorld_TA_112_ErrorReporter_RealWorld_20240815145142.log,112,ErrorReporter,173751,1499,175250,155.0,0.898735,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

contract ComptrollerErrorReporter {
    enum Error {
        NO_ERROR,
        UNAUTHORIZED,
        COMPTROLLER_MISMATCH,
        INSUFFICIENT_SHORTFALL,
        INSUFFICIENT_LIQUIDITY,
        INVALID_CLOSE_FACTOR,
        INVALID_COLLATERAL_FACTOR,
        INVALID_LIQUIDATION_INCENTIVE,
        MARKET_NOT_ENTERED, // no longer possible
        MARKET_NOT_LISTED,
        MARKET_ALREADY_LISTED,
        MATH_ERROR,
        NONZERO_BORROW_BALANCE,
        PRICE_ERROR,
        REJECTION,
        SNAPSHOT_ERROR,
        TOO_MANY_ASSETS,
        TOO_MUCH_REPAY
    }

    enum FailureInfo {
        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,
        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,
        EXIT_MARKET_BALANCE_OWED,
        EXIT_MARKET_REJECTION,
        SET_CLOSE_FACTOR_OWNER_CHECK,
        SET_CLOSE_FACTOR_VALIDATION,
        SET_COLLATERAL_FACTOR_OWNER_CHECK,
        SET_COLLATERAL_FACTOR_NO_EXISTS,
        SET_COLLATERAL_FACTOR_VALIDATION,
        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,
        SET_IMPLEMENTATION_OWNER_CHECK,
        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,
        SET_LIQUIDATION_INCENTIVE_VALIDATION,
        SET_MAX_ASSETS_OWNER_CHECK,
        SET_PENDING_ADMIN_OWNER_CHECK,
        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,
        SET_PRICE_ORACLE_OWNER_CHECK,
        SUPPORT_MARKET_EXISTS,
        SUPPORT_MARKET_OWNER_CHECK,
        SET_PAUSE_GUARDIAN_OWNER_CHECK
    }

    /**
     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
     **/
    event Failure(uint256 error, uint256 info, uint256 detail);

    /**
     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
     */
    function fail(Error err, FailureInfo info) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), 0);

        return uint256(err);
    }

    /**
     * @dev use this when reporting an opaque error from an upgradeable collaborator contract
     */
    function failOpaque(
        Error err,
        FailureInfo info,
        uint256 opaqueError
    ) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), opaqueError);

        return uint256(err);
    }
}

contract TokenErrorReporter {
    enum Error {
        NO_ERROR,
        UNAUTHORIZED,
        BAD_INPUT,
        COMPTROLLER_REJECTION,
        COMPTROLLER_CALCULATION_ERROR,
        INTEREST_RATE_MODEL_ERROR,
        INVALID_ACCOUNT_PAIR,
        INVALID_CLOSE_AMOUNT_REQUESTED,
        INVALID_COLLATERAL_FACTOR,
        MATH_ERROR,
        MARKET_NOT_FRESH,
        MARKET_NOT_LISTED,
        TOKEN_INSUFFICIENT_ALLOWANCE,
        TOKEN_INSUFFICIENT_BALANCE,
        TOKEN_INSUFFICIENT_CASH,
        TOKEN_TRANSFER_IN_FAILED,
        TOKEN_TRANSFER_OUT_FAILED
    }

    /*
     * Note: FailureInfo (but not Error) is kept in alphabetical order
     *       This is because FailureInfo grows significantly faster, and
     *       the order of Error has some meaning, while the order of FailureInfo
     *       is entirely arbitrary.
     */
    enum FailureInfo {
        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,
        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,
        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,
        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,
        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,
        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,
        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,
        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,
        BORROW_ACCRUE_INTEREST_FAILED,
        BORROW_CASH_NOT_AVAILABLE,
        BORROW_FRESHNESS_CHECK,
        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,
        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,
        BORROW_MARKET_NOT_LISTED,
        BORROW_COMPTROLLER_REJECTION,
        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,
        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,
        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,
        LIQUIDATE_COMPTROLLER_REJECTION,
        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,
        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,
        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,
        LIQUIDATE_FRESHNESS_CHECK,
        LIQUIDATE_LIQUIDATOR_IS_BORROWER,
        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,
        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,
        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,
        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,
        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,
        LIQUIDATE_SEIZE_TOO_MUCH,
        MINT_ACCRUE_INTEREST_FAILED,
        MINT_COMPTROLLER_REJECTION,
        MINT_EXCHANGE_CALCULATION_FAILED,
        MINT_EXCHANGE_RATE_READ_FAILED,
        MINT_FRESHNESS_CHECK,
        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,
        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,
        MINT_TRANSFER_IN_FAILED,
        MINT_TRANSFER_IN_NOT_POSSIBLE,
        REDEEM_ACCRUE_INTEREST_FAILED,
        REDEEM_COMPTROLLER_REJECTION,
        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,
        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,
        REDEEM_EXCHANGE_RATE_READ_FAILED,
        REDEEM_FRESHNESS_CHECK,
        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,
        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,
        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,
        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,
        REDUCE_RESERVES_ADMIN_CHECK,
        REDUCE_RESERVES_CASH_NOT_AVAILABLE,
        REDUCE_RESERVES_FRESH_CHECK,
        REDUCE_RESERVES_VALIDATION,
        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,
        REPAY_BORROW_ACCRUE_INTEREST_FAILED,
        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,
        REPAY_BORROW_COMPTROLLER_REJECTION,
        REPAY_BORROW_FRESHNESS_CHECK,
        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,
        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,
        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,
        SET_COLLATERAL_FACTOR_OWNER_CHECK,
        SET_COLLATERAL_FACTOR_VALIDATION,
        SET_COMPTROLLER_OWNER_CHECK,
        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,
        SET_INTEREST_RATE_MODEL_FRESH_CHECK,
        SET_INTEREST_RATE_MODEL_OWNER_CHECK,
        SET_MAX_ASSETS_OWNER_CHECK,
        SET_ORACLE_MARKET_NOT_LISTED,
        SET_PENDING_ADMIN_OWNER_CHECK,
        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,
        SET_RESERVE_FACTOR_ADMIN_CHECK,
        SET_RESERVE_FACTOR_FRESH_CHECK,
        SET_RESERVE_FACTOR_BOUNDS_CHECK,
        TRANSFER_COMPTROLLER_REJECTION,
        TRANSFER_NOT_ALLOWED,
        TRANSFER_NOT_ENOUGH,
        TRANSFER_TOO_MUCH,
        ADD_RESERVES_ACCRUE_INTEREST_FAILED,
        ADD_RESERVES_FRESH_CHECK,
        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE
    }

    /**
     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
     **/
    event Failure(uint256 error, uint256 info, uint256 detail);

    /**
     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
     */
    function fail(Error err, FailureInfo info) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), 0);

        return uint256(err);
    }

    /**
     * @dev use this when reporting an opaque error from an upgradeable collaborator contract
     */
    function failOpaque(
        Error err,
        FailureInfo info,
        uint256 opaqueError
    ) internal returns (uint256) {
        emit Failure(uint256(err), uint256(info), opaqueError);

        return uint256(err);
    }
}",1836
RealWorld_TA_112_Comptroller_RealWorld_20240815142358.log,112,Comptroller,27094,1501,28595,165.0,0.16549,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./ComptrollerInterface.sol"";
import ""./ComptrollerStorage.sol"";

abstract contract Comptroller is ComptrollerV5Storage, ComptrollerInterface {
    function getAssetsIn(address account) external view virtual returns (CToken[] memory);

    function getAllMarkets() public view virtual returns (CToken[] memory);

    function isDeprecated(CToken cToken) public view virtual returns (bool);
}",104
RealWorld_TA_112_PoolFactory_RealWorld_20240815115702.log,112,PoolFactory,165633,2111,167744,173.0,0.870385,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IVault.sol"";
import ""../../interfaces/ILpToken.sol"";
import ""../../interfaces/IAdmin.sol"";
import ""../../interfaces/IController.sol"";
import ""../../interfaces/pool/ILiquidityPool.sol"";
import ""../../interfaces/pool/IErc20Pool.sol"";
import ""../../interfaces/pool/IEthPool.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract PoolFactory is Authorization {
    using AddressProviderHelpers for IAddressProvider;

    struct Addresses {
        address pool;
        address vault;
        address lpToken;
        address stakerVault;
    }

    struct ImplementationNames {
        bytes32 pool;
        bytes32 vault;
        bytes32 lpToken;
        bytes32 stakerVault;
    }

    struct VaultArgs {
        uint256 debtLimit;
        uint256 targetAllocation;
        uint256 bound;
    }

    struct LpTokenArgs {
        string name;
        string symbol;
        uint8 decimals;
    }

    struct DeployPoolVars {
        address lpTokenImplementation;
        address poolImplementation;
        address stakerVaultImplementation;
        address vaultImplementation;
    }

    bytes32 internal constant _POOL_KEY = ""pool"";
    bytes32 internal constant _LP_TOKEN_KEY = ""lp_token"";
    bytes32 internal constant _STAKER_VAULT_KEY = ""staker_vault"";
    bytes32 internal constant _VAULT_KEY = ""vault"";

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    /**
     * @dev maps a contract type (e.g. ""pool"" or ""lp_token"", as defined in constants above)
     * to a mapping from an implementation name to the actual implementation
     * The implementation name is decided when registering the implementation
     * and can be arbitrary (e.g. ""ERC20PoolV1"")
     */
    mapping(bytes32 => mapping(bytes32 => address)) public implementations;

    event NewPool(address pool, address vault, address lpToken, address stakerVault);
    event NewImplementation(bytes32 key, bytes32 name, address implementation);

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = IController(_controller);
        addressProvider = IController(_controller).addressProvider();
    }

    /**
     * @notice Add a new pool implementation to the factory.
     * @param name of the pool implementation.
     * @param implementation of pool implementation to add.
     */
    function addPoolImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_POOL_KEY, name, implementation);
    }

    /**
     * @notice Add a new LP token implementation to the factory.
     * @param name of the LP token implementation.
     * @param implementation of lp token implementation to add.
     */
    function addLpTokenImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_LP_TOKEN_KEY, name, implementation);
    }

    /**
     * @notice Add a new vault implementation to the factory.
     * @param name of the vault implementation.
     * @param implementation of vault implementation to add.
     */
    function addVaultImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_VAULT_KEY, name, implementation);
    }

    /**
     * @notice Add a new staker vault implementation to the factory.
     * @param name of the staker vault implementation.
     * @param implementation of staker vault implementation to add.
     */
    function addStakerVaultImplementation(bytes32 name, address implementation)
        external
        onlyGovernance
        returns (bool)
    {
        return _addImplementation(_STAKER_VAULT_KEY, name, implementation);
    }

    /**
     * @notice Deploys a new pool and LP token.
     * @dev Decimals is an argument as not all ERC20 tokens implement the ERC20Detailed interface.
     *      An implementation where `getUnderlying()` returns the zero address is for ETH pools.
     * @param poolName Name of the pool.
     * @param underlying Address of the pool's underlying.
     * @param lpTokenArgs Arguments to create the LP token for the pool
     * @param vaultArgs Arguments to create the vault
     * @param implementationNames Name of the implementations to use
     * @return addrs Address of the deployed pool, address of the pool's deployed LP token.
     */
    function deployPool(
        string calldata poolName,
        uint256 depositCap,
        address underlying,
        LpTokenArgs calldata lpTokenArgs,
        VaultArgs calldata vaultArgs,
        ImplementationNames calldata implementationNames
    ) external onlyGovernance returns (Addresses memory addrs) {
        DeployPoolVars memory vars;

        vars.poolImplementation = implementations[_POOL_KEY][implementationNames.pool];
        require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION);

        vars.lpTokenImplementation = implementations[_LP_TOKEN_KEY][implementationNames.lpToken];
        require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION);

        vars.vaultImplementation = implementations[_VAULT_KEY][implementationNames.vault];
        require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION);

        vars.stakerVaultImplementation = implementations[_STAKER_VAULT_KEY][
            implementationNames.stakerVault
        ];
        require(
            vars.stakerVaultImplementation != address(0),
            Error.INVALID_STAKER_VAULT_IMPLEMENTATION
        );

        addrs.pool = Clones.clone(vars.poolImplementation);
        addrs.vault = Clones.clone(vars.vaultImplementation);

        if (underlying == address(0)) {
            // ETH pool
            require(
                ILiquidityPool(vars.poolImplementation).getUnderlying() == address(0),
                Error.INVALID_POOL_IMPLEMENTATION
            );
            require(lpTokenArgs.decimals == 18, Error.INVALID_DECIMALS);
            IEthPool(addrs.pool).initialize(poolName, depositCap, addrs.vault);
        } else {
            IErc20Pool(addrs.pool).initialize(poolName, underlying, depositCap, addrs.vault);
        }

        addrs.lpToken = Clones.clone(vars.lpTokenImplementation);

        ILpToken(addrs.lpToken).initialize(
            lpTokenArgs.name,
            lpTokenArgs.symbol,
            lpTokenArgs.decimals,
            addrs.pool
        );

        addrs.stakerVault = Clones.clone(vars.stakerVaultImplementation);
        IStakerVault(addrs.stakerVault).initialize(addrs.lpToken);
        controller.addStakerVault(addrs.stakerVault);

        ILiquidityPool(addrs.pool).setLpToken(addrs.lpToken);
        ILiquidityPool(addrs.pool).setStaker();

        IVault(addrs.vault).initialize(
            addrs.pool,
            vaultArgs.debtLimit,
            vaultArgs.targetAllocation,
            vaultArgs.bound
        );

        addressProvider.addPool(addrs.pool);

        emit NewPool(addrs.pool, addrs.vault, addrs.lpToken, addrs.stakerVault);
        return addrs;
    }

    /**
     * @notice Add a new implementation of type `name` to the factory.
     * @param key of the implementation to add.
     * @param name of the implementation to add.
     * @param implementation of lp token implementation to add.
     */
    function _addImplementation(
        bytes32 key,
        bytes32 name,
        address implementation
    ) internal returns (bool) {
        mapping(bytes32 => address) storage currentImplementations = implementations[key];
        if (currentImplementations[name] != address(0)) {
            return false;
        }
        currentImplementations[name] = implementation;
        emit NewImplementation(key, name, implementation);
        return true;
    }
}",1767
RealWorld_TA_112_Erc20Vault_RealWorld_20240815120350.log,112,Erc20Vault,51010,3121,54131,155.0,0.31747,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./Vault.sol"";

contract Erc20Vault is Vault {
    using AddressProviderHelpers for IAddressProvider;
    using SafeERC20 for IERC20;

    constructor(IController controller) Vault(controller) {}

    function initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) external virtual override initializer {
        _initialize(_pool, _debtLimit, _targetAllocation, _bound);
        address underlying_ = ILiquidityPool(pool).getUnderlying();
        require(underlying_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        IERC20(underlying_).safeApprove(address(reserve), type(uint256).max);
        IERC20(underlying_).safeApprove(_pool, type(uint256).max);
    }

    function getUnderlying() public view override returns (address) {
        return ILiquidityPool(pool).getUnderlying();
    }

    function _transfer(address to, uint256 amount) internal override {
        IERC20(getUnderlying()).safeTransfer(to, amount);
    }

    function _depositToReserve(uint256 amount) internal override {
        reserve.deposit(getUnderlying(), amount);
    }

    function _depositToTreasury(uint256 amount) internal override {
        IERC20(getUnderlying()).safeTransfer(addressProvider.getTreasury(), amount);
    }

    function _payStrategist(uint256 amount, address strategist) internal override {
        if (strategist == address(0)) return;
        ILiquidityPool(pool).depositFor(strategist, amount);
    }

    function _availableUnderlying() internal view override returns (uint256) {
        return IERC20(getUnderlying()).balanceOf(address(this));
    }
}",396
RealWorld_TA_112_ExponentialNoError_RealWorld_20240815144411.log,112,ExponentialNoError,133936,1685,135621,154.0,0.70338,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

/**
 * @title Exponential module for storing fixed-precision decimals
 * @author Compound
 * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.
 *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:
 *         `Exp({mantissa: 5100000000000000000})`.
 */
contract ExponentialNoError {
    uint256 constant expScale = 1e18;
    uint256 constant doubleScale = 1e36;
    uint256 constant halfExpScale = expScale / 2;
    uint256 constant mantissaOne = expScale;

    struct Exp {
        uint256 mantissa;
    }

    struct Double {
        uint256 mantissa;
    }

    /**
     * @dev Truncates the given exp to a whole number value.
     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15
     */
    function truncate(Exp memory exp) internal pure returns (uint256) {
        // Note: We are not using careful math here as we're performing a division that cannot fail
        return exp.mantissa / expScale;
    }

    /**
     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.
     */
    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {
        Exp memory product = mul_(a, scalar);
        return truncate(product);
    }

    /**
     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.
     */
    function mul_ScalarTruncateAddUInt(
        Exp memory a,
        uint256 scalar,
        uint256 addend
    ) internal pure returns (uint256) {
        Exp memory product = mul_(a, scalar);
        return truncate(product) + addend;
    }

    /**
     * @dev Checks if first Exp is less than second Exp.
     */
    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {
        return left.mantissa < right.mantissa;
    }

    /**
     * @dev Checks if left Exp <= right Exp.
     */
    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {
        return left.mantissa <= right.mantissa;
    }

    /**
     * @dev Checks if left Exp > right Exp.
     */
    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {
        return left.mantissa > right.mantissa;
    }

    /**
     * @dev returns true if Exp is exactly zero
     */
    function isZeroExp(Exp memory value) internal pure returns (bool) {
        return value.mantissa == 0;
    }

    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {
        require(n < 2**224, errorMessage);
        return uint224(n);
    }

    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: a.mantissa + b.mantissa});
    }

    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa + b.mantissa});
    }

    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: a.mantissa - b.mantissa});
    }

    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa - b.mantissa});
    }

    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: (a.mantissa * b.mantissa) / expScale});
    }

    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {
        return Exp({mantissa: (a.mantissa * b)});
    }

    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {
        return (a * b.mantissa) / expScale;
    }

    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: (a.mantissa * b.mantissa) / doubleScale});
    }

    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa * b});
    }

    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {
        return (a * b.mantissa) / doubleScale;
    }

    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {
        return Exp({mantissa: (a.mantissa * expScale) / b.mantissa});
    }

    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {
        return Exp({mantissa: a.mantissa / b});
    }

    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {
        return (a * expScale) / b.mantissa;
    }

    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {
        return Double({mantissa: (a.mantissa * doubleScale) / b.mantissa});
    }

    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {
        return Double({mantissa: a.mantissa / b});
    }

    function div_(uint256 a, Double memory b) internal pure returns (uint256) {
        return (a * doubleScale) / b.mantissa;
    }

    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {
        return Double({mantissa: (a * doubleScale) / b});
    }
}",1367
RealWorld_TA_112_TopUpKeeperHelper_RealWorld_20240815094941.log,112,TopUpKeeperHelper,144461,3895,148356,121.0,0.800205,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/topup/ITopUpKeeperHelper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";

/**
 * This TopUp Keeper Helper.
 * It is a utility contract to help create Backd TopUp Keepers.
 * It exposes a view that allows the user to query a list of TopUp Positions that can be executed.
 */
contract TopUpKeeperHelper is ITopUpKeeperHelper {
    using EnumerableSet for EnumerableSet.AddressSet;

    ITopUpAction private immutable _topupAction;

    constructor(address topupAction_) {
        _topupAction = ITopUpAction(topupAction_);
    }

    /**
     * @notice Gets a list of topup positions that can be executed.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of topups to return in this pagination request.
     * @return topups List of topup positions that can be executed.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function getExecutableTopups(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (TopupData[] memory topups, uint256 nextCursor)
    {
        TopupData[] memory executableTopups = new TopupData[](howMany);
        uint256 topupsAdded;
        while (true) {
            (address[] memory users, ) = _topupAction.usersWithPositions(cursor, howMany);
            if (users.length == 0) return (_shortenTopups(executableTopups, topupsAdded), 0);
            for (uint256 i = 0; i < users.length; i++) {
                address user = users[i];
                ITopUpAction.RecordWithMeta[] memory positions = listPositions(user);
                for (uint256 j = 0; j < positions.length; j++) {
                    ITopUpAction.RecordWithMeta memory position = positions[j];
                    if (!_canExecute(user, position)) continue;
                    executableTopups[topupsAdded] = _positionToTopup(user, position);
                    topupsAdded++;
                    uint256 offset = j == positions.length - 1 ? 1 : 0;
                    if (topupsAdded == howMany) return (executableTopups, cursor + i + offset);
                }
            }
            cursor += howMany;
        }
    }

    /**
     * @notice Check if the action can be executed for the positions
     * of the given `keys`
     * @param keys Unique keys to check for
     * @return an array of boolean containing a result per input
     */
    function batchCanExecute(ITopUpAction.RecordKey[] calldata keys)
        external
        view
        override
        returns (bool[] memory)
    {
        bool[] memory results = new bool[](keys.length);
        for (uint256 i = 0; i < keys.length; i++) {
            ITopUpAction.RecordKey calldata key = keys[i];
            results[i] = canExecute(key);
        }
        return results;
    }

    /**
     * @notice Get a list of all positions the `payer` has registered.
     * @param payer Address to list position for.
     * @return Records of all registered positions.
     */
    function listPositions(address payer)
        public
        view
        override
        returns (ITopUpAction.RecordWithMeta[] memory)
    {
        ITopUpAction.RecordMeta[] memory userRecordsMeta = _topupAction.getUserPositions(payer);
        uint256 length = userRecordsMeta.length;
        ITopUpAction.RecordWithMeta[] memory result = new ITopUpAction.RecordWithMeta[](length);
        for (uint256 i = 0; i < length; i++) {
            bytes32 account = userRecordsMeta[i].account;
            bytes32 protocol = userRecordsMeta[i].protocol;
            ITopUpAction.Record memory record = _topupAction.getPosition(payer, account, protocol);
            result[i] = ITopUpAction.RecordWithMeta(account, protocol, record);
        }
        return result;
    }

    /**
     * @notice Check if action can be executed.
     * @param key Unique key of the account to check for
     * the key contains information about the payer, the account and the protocol
     * @return `true` if action can be executed, else `false.
     */
    function canExecute(ITopUpAction.RecordKey memory key) public view override returns (bool) {
        ITopUpAction.Record memory position = _topupAction.getPosition(
            key.payer,
            key.account,
            key.protocol
        );
        if (position.threshold == 0 || position.totalTopUpAmount == 0) {
            return false;
        }
        uint256 healthFactor = _topupAction.getHealthFactor(
            key.protocol,
            key.account,
            position.extra
        );
        return healthFactor < position.threshold;
    }

    /**
     * @dev Returns if a position can be executed.
     * @param user The user paying for the position.
     * @param position The position record with metadata.
     * @return 'true' if it can be executed, 'false' if not.
     */
    function _canExecute(address user, ITopUpAction.RecordWithMeta memory position)
        private
        view
        returns (bool)
    {
        return canExecute(ITopUpAction.RecordKey(user, position.account, position.protocol));
    }

    /**
     * @dev Converts from RecordWithMeta struct to TopupData struct.
     * @param user The user paying for the position.
     * @param position The position record with metadata.
     * @return The topup positions as a TopupData struct.
     */
    function _positionToTopup(address user, ITopUpAction.RecordWithMeta memory position)
        private
        pure
        returns (TopupData memory)
    {
        return TopupData(user, position.account, position.protocol, position.record);
    }

    /**
     * @dev Shortens a list of topups by truncating it to a given length.
     * @param topups The list of topups to shorten.
     * @param length The length to trucate the list of topups to.
     * @return The shortened list of topups.
     */
    function _shortenTopups(TopupData[] memory topups, uint256 length)
        private
        pure
        returns (TopupData[] memory)
    {
        TopupData[] memory shortened = new TopupData[](length);
        for (uint256 i = 0; i < length; i++) {
            shortened[i] = topups[i];
        }
        return shortened;
    }
}",1477
RealWorld_TA_112_MockErc20Strategy_RealWorld_20240815090622.log,112,MockErc20Strategy,92374,4616,96990,123.0,0.55419,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../access/Authorization.sol"";
import ""../../interfaces/IStrategy.sol"";
import ""../../interfaces/IStakerVault.sol"";

/**
 * MockStrategy for testing.
 * This strategy does not do anything with funds it receives.
 */
contract MockErc20Strategy is IStrategy, Authorization {
    using SafeERC20 for IERC20;

    address internal _underlying;

    address internal _vault;

    address public override strategist;

    modifier onlyVault() {
        require(msg.sender == _vault, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IRoleManager roleManager, address underlying) Authorization(roleManager) {
        _underlying = underlying;
        strategist = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);
    }

    function setVault(address newVault) external onlyGovernance returns (bool) {
        require(_vault == address(0), ""Vault can only be set once"");
        require(newVault != address(0), ""Vault cannot be zero address"");
        _vault = newVault;
        return true;
    }

    // Deposits token (same as want() returns) into a smart contact specified by the Strategy.
    function deposit() external payable override onlyVault returns (bool) {
        // Does nothing in mock
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdraw(uint256 amount) external override onlyVault returns (bool) {
        uint256 currentBalance = IERC20(_underlying).balanceOf(address(this));
        if (amount <= currentBalance) IERC20(_underlying).safeTransfer(_vault, amount);
        else IERC20(_underlying).safeTransfer(_vault, currentBalance);
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdrawAll() external virtual override onlyVault returns (uint256) {
        uint256 currentBalance = IERC20(_underlying).balanceOf(address(this));
        IERC20(_underlying).safeTransfer(_vault, currentBalance);
        return currentBalance;
    }

    function withdrawDust(address coin) external returns (bool) {
        require(coin != address(_underlying), ""Unauthorized withdrawal"");
        uint256 currentBalance = IERC20(coin).balanceOf(address(this));
        require(currentBalance > 0, ""Invalid amount to withdraw"");
        IERC20(coin).transfer(_vault, currentBalance);
        return true;
    }

    function transfer(
        address coin,
        address to,
        uint256 amount
    ) external returns (bool) {
        require(amount > 0, ""Invalid amount to transfer"");
        IERC20(coin).transfer(to, amount);
        return true;
    }

    function drainFunds(address account) external {
        uint256 _balance = IERC20(_underlying).balanceOf(address(this));
        IERC20(_underlying).transfer(account, _balance);
    }

    function stakeInVault(address lpToken, address stakerVault) external {
        IERC20(lpToken).approve(stakerVault, 4e18);
        IStakerVault(stakerVault).stake(4e18);
    }

    function want() external view returns (address) {
        return _underlying;
    }

    function balance() external view override returns (uint256) {
        return IERC20(_underlying).balanceOf(address(this));
    }

    function name() external pure override returns (string memory) {
        return ""MockStrategy"";
    }

    function shutdown() external pure override returns (bool) {
        return true;
    }

    function harvestable() external pure override returns (uint256) {
        return 0;
    }

    function harvest() external pure override returns (uint256) {
        return 0;
    }

    function hasPendingFunds() external pure override returns (bool) {
        return false;
    }
}",883
RealWorld_TA_112_ControllerProfiler_RealWorld_20240815094224.log,112,ControllerProfiler,35047,2665,37712,97.0,0.228535,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../Controller.sol"";

contract ControllerProfiler {
    Controller public immutable controller;

    constructor(address _controller) {
        controller = Controller(_controller);
    }

    function profileIsAction() external {
        IAddressProvider addressProvider = controller.addressProvider();
        addressProvider.isAction(address(this));
        addressProvider.addAction(address(this));
        addressProvider.isAction(address(this));
        addressProvider.isAction(address(controller));
        addressProvider.addAction(address(this));
        addressProvider.isAction(address(this));
        addressProvider.isAction(address(controller));
    }

    function profilePoolAddingAndLpTokenGet(address pool, address token) external {
        IAddressProvider addressProvider = controller.addressProvider();
        addressProvider.addPool(pool);
        addressProvider.getPoolForToken(token);
        controller.removePool(pool);
    }
}",183
RealWorld_TA_112_IBkdToken_RealWorld_20240815140140.log,112,IBkdToken,23788,2016,25804,178.0,0.15926,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IBkdToken is IERC20 {
    function mint(address account, uint256 amount) external;
}",62
RealWorld_TA_112_IPausable_RealWorld_20240815084735.log,112,IPausable,24774,1479,26253,82.0,0.15345,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IPausable {
    function pause() external returns (bool);

    function unpause() external returns (bool);

    function isPaused() external view returns (bool);

    function isAuthorizedToPause(address account) external view returns (bool);
}",74
RealWorld_TA_112_ILiquidityPool_RealWorld_20240815140957.log,112,ILiquidityPool,68468,3283,71751,183.0,0.408,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../IPreparable.sol"";
import ""../../interfaces/IVault.sol"";

interface ILiquidityPool is IPreparable {
    event Deposit(address indexed minter, uint256 depositAmount, uint256 mintedLpTokens);

    event DepositFor(
        address indexed minter,
        address indexed mintee,
        uint256 depositAmount,
        uint256 mintedLpTokens
    );

    event Redeem(address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens);

    event LpTokenSet(address indexed lpToken);

    event StakerVaultSet(address indexed stakerVault);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function redeem(uint256 redeemTokens, uint256 minRedeemAmount) external returns (uint256);

    function calcRedeem(address account, uint256 underlyingAmount) external returns (uint256);

    function deposit(uint256 mintAmount) external payable returns (uint256);

    function deposit(uint256 mintAmount, uint256 minTokenAmount) external payable returns (uint256);

    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)
        external
        payable
        returns (uint256);

    function depositFor(address account, uint256 depositAmount) external payable returns (uint256);

    function depositFor(
        address account,
        uint256 depositAmount,
        uint256 minTokenAmount
    ) external payable returns (uint256);

    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)
        external
        returns (uint256);

    function handleLpTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) external;

    function prepareNewVault(address _vault) external returns (bool);

    function executeNewVault() external returns (address);

    function executeNewMaxWithdrawalFee() external returns (uint256);

    function executeNewRequiredReserves() external returns (uint256);

    function executeNewReserveDeviation() external returns (uint256);

    function setLpToken(address _lpToken) external returns (bool);

    function setStaker() external returns (bool);

    function isCapped() external returns (bool);

    function uncap() external returns (bool);

    function updateDepositCap(uint256 _depositCap) external returns (bool);

    function withdrawAll() external;

    function getUnderlying() external view returns (address);

    function getLpToken() external view returns (address);

    function getWithdrawalFee(address account, uint256 amount) external view returns (uint256);

    function getVault() external view returns (IVault);

    function exchangeRate() external view returns (uint256);

    function totalUnderlying() external view returns (uint256);
}",613
RealWorld_TA_112_MockTopUpActionFeeHandler_RealWorld_20240815091359.log,112,MockTopUpActionFeeHandler,32614,2755,35369,102.0,0.21817,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../actions/topup/TopUpActionFeeHandler.sol"";

contract MockTopUpActionFeeHandler is TopUpActionFeeHandler {
    constructor(
        IController _controller,
        address _actionContract,
        uint256 keeperFee,
        uint256 treasuryFee
    ) TopUpActionFeeHandler(_controller, _actionContract, keeperFee, treasuryFee) {}

    function callReportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external {
        address keeperGauge = getKeeperGauge(lpTokenAddress);
        IKeeperGauge(keeperGauge).reportFees(beneficiary, amount, lpTokenAddress);
    }
}",164
RealWorld_TA_112_ISwapper_RealWorld_20240815132234.log,112,ISwapper,25410,1688,27098,150.0,0.16081,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ISwapper {
    function swap(
        address fromToken,
        address toToken,
        uint256 swapAmount,
        uint256 minAmount
    ) external returns (uint256);

    function getRate(address fromToken, address toToken) external view returns (uint256);
}",82
RealWorld_TA_112_ICurveRegistry_RealWorld_20240815144918.log,112,ICurveRegistry,21764,1384,23148,142.0,0.1365,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveRegistry {
    function get_A(address curvePool_) external view returns (uint256);
}",39
RealWorld_TA_112_AaveHandler_RealWorld_20240815095835.log,112,AaveHandler,67654,2722,70376,104.0,0.39271,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../../../libraries/Errors.sol"";
import ""../../../../libraries/AccountEncoding.sol"";

import ""../../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../../interfaces/vendor/ILendingPool.sol"";
import ""../../../../interfaces/vendor/IWETH.sol"";
import ""../../../../libraries/vendor/DataTypes.sol"";

contract AaveHandler is ITopUpHandler {
    using SafeERC20 for IERC20;
    using AccountEncoding for bytes32;

    uint16 public constant BACKD_REFERRAL_CODE = 62314;

    ILendingPool public immutable lendingPool;
    IWETH public immutable weth;

    constructor(address lendingPoolAddress, address wethAddress) {
        lendingPool = ILendingPool(lendingPoolAddress);
        weth = IWETH(wethAddress);
    }

    /**
     * @notice Executes the top-up of a position.
     * @param account Account holding the position.
     * @param underlying Underlying for tup-up.
     * @param amount Amount to top-up by.
     * @return `true` if successful.
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory extra
    ) external override returns (bool) {
        bool repayDebt = abi.decode(extra, (bool));
        if (underlying == address(0)) {
            weth.deposit{value: amount}();
            underlying = address(weth);
        }

        address addr = account.addr();

        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);
        require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);

        IERC20(underlying).safeApprove(address(lendingPool), amount);

        if (repayDebt) {
            uint256 stableDebt = IERC20(reserve.stableDebtTokenAddress).balanceOf(addr);
            uint256 variableDebt = IERC20(reserve.variableDebtTokenAddress).balanceOf(addr);
            if (variableDebt + stableDebt > 0) {
                uint256 rateMode = stableDebt > variableDebt ? 1 : 2;
                amount -= lendingPool.repay(underlying, amount, rateMode, addr);
                if (amount == 0) return true;
            }
        }

        lendingPool.deposit(underlying, amount, addr, BACKD_REFERRAL_CODE);
        return true;
    }

    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {
        (, , , , , uint256 healthFactor) = lendingPool.getUserAccountData(account.addr());
        return healthFactor;
    }
}",606
RealWorld_TA_112_MockMinter_RealWorld_20240815094048.log,112,MockMinter,30208,2559,32767,94.0,0.20222,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../../interfaces/vendor/IGauge.sol"";
import ""./../MockErc20.sol"";

contract MockMinter is IMinter {
    address public token;

    uint256 private _mintAmount;

    constructor(address _token) {
        token = _token;
    }

    function setMintAmount(uint256 mintAmount_) external {
        _mintAmount = mintAmount_;
    }

    function mint(
        address /* gaugeAddr */
    ) external override {
        MockErc20(token).mintFor(msg.sender, _mintAmount);
    }
}",134
RealWorld_TA_112_IChainlinkOracleProvider_RealWorld_20240815132932.log,112,IChainlinkOracleProvider,25351,2862,28213,151.0,0.183995,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IOracleProvider.sol"";

interface IChainlinkOracleProvider is IOracleProvider {
    function setFeed(address asset, address feed) external;

    function setStalePriceDelay(uint256 stalePriceDelay_) external;
}",69
RealWorld_TA_112_RoleManager_RealWorld_20240815082538.log,112,RoleManager,120143,2372,122515,95.0,0.648155,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../interfaces/IAddressProvider.sol"";
import ""../../interfaces/IRoleManager.sol"";

import ""../../libraries/Roles.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderKeys.sol"";

contract RoleManager is IRoleManager {
    using EnumerableSet for EnumerableSet.AddressSet;

    struct RoleData {
        mapping(address => bool) members;
        bytes32 adminRole;
    }
    mapping(bytes32 => RoleData) private _roles;
    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;

    IAddressProvider public immutable addressProvider;

    modifier onlyGovernance() {
        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IAddressProvider _addressProvider) {
        addressProvider = _addressProvider;
        _grantRole(Roles.GOVERNANCE, msg.sender);
    }

    function grantRole(bytes32 role, address account) external onlyGovernance {
        _grantRole(role, account);
    }

    function addGovernor(address newGovernor) external onlyGovernance {
        _grantRole(Roles.GOVERNANCE, newGovernor);
    }

    function renounceGovernance() external onlyGovernance {
        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);
        _revokeRole(Roles.GOVERNANCE, msg.sender);
    }

    function addGaugeZap(address zap) external onlyGovernance {
        _grantRole(Roles.GAUGE_ZAP, zap);
    }

    function removeGaugeZap(address zap) external {
        revokeRole(Roles.GAUGE_ZAP, zap);
    }

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        address account
    ) external view returns (bool) {
        return hasRole(role1, account) || hasRole(role2, account);
    }

    function hasAnyRole(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        address account
    ) external view returns (bool) {
        return hasRole(role1, account) || hasRole(role2, account) || hasRole(role3, account);
    }

    function hasAnyRole(bytes32[] memory roles, address account)
        external
        view
        virtual
        override
        returns (bool)
    {
        for (uint256 i = 0; i < roles.length; i++) {
            if (hasRole(roles[i], account)) {
                return true;
            }
        }
        return false;
    }

    function getRoleMember(bytes32 role, uint256 index)
        external
        view
        virtual
        override
        returns (address)
    {
        if (role == Roles.ADDRESS_PROVIDER && index == 0) {
            return address(addressProvider);
        } else if (role == Roles.POOL_FACTORY && index == 0) {
            return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);
        } else if (role == Roles.CONTROLLER && index == 0) {
            return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);
        } else if (role == Roles.POOL) {
            return addressProvider.getPoolAtIndex(index);
        } else if (role == Roles.VAULT) {
            return addressProvider.getVaultAtIndex(index);
        }
        return _roleMembers[role].at(index);
    }

    function revokeRole(bytes32 role, address account) public onlyGovernance {
        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);
        require(hasRole(role, account), Error.INVALID_ARGUMENT);
        _revokeRole(role, account);
    }

    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {
        if (
            role == Roles.ADDRESS_PROVIDER || role == Roles.POOL_FACTORY || role == Roles.CONTROLLER
        ) {
            return 1;
        }
        if (role == Roles.POOL) {
            return addressProvider.poolsCount();
        }
        if (role == Roles.VAULT) {
            return addressProvider.vaultsCount();
        }
        return _roleMembers[role].length();
    }

    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {
        if (role == Roles.ADDRESS_PROVIDER) {
            return account == address(addressProvider);
        } else if (role == Roles.POOL_FACTORY) {
            return
                account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);
        } else if (role == Roles.CONTROLLER) {
            return
                account == addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY, false);
        } else if (role == Roles.MAINTENANCE) {
            return _roles[role].members[account] || _roles[Roles.GOVERNANCE].members[account];
        } else if (role == Roles.POOL) {
            return addressProvider.isPool(account);
        } else if (role == Roles.VAULT) {
            return addressProvider.isVault(account);
        }
        return _roles[role].members[account];
    }

    function _grantRole(bytes32 role, address account) internal {
        _roles[role].members[account] = true;
        _roleMembers[role].add(account);
        emit RoleGranted(role, account, msg.sender);
    }

    function _revokeRole(bytes32 role, address account) internal {
        _roles[role].members[account] = false;
        emit RoleRevoked(role, account, msg.sender);
    }
}",1200
RealWorld_TA_112_IKeeperGauge_RealWorld_20240815140440.log,112,IKeeperGauge,28641,2149,30790,169.0,0.186185,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;
import ""./IRewardsGauge.sol"";

interface IKeeperGauge is IRewardsGauge {
    function reportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external returns (bool);

    function advanceEpoch() external returns (bool);

    function poolCheckpoint() external returns (bool);

    function kill() external returns (bool);

    function killed() external view returns (bool);

    function claimableRewards(address beneficiary) external view returns (uint256);
}",128
RealWorld_TA_112_EnumerableExtensions_RealWorld_20240815122420.log,112,EnumerableExtensions,90077,1234,91311,164.0,0.475065,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""../libraries/EnumerableMapping.sol"";

library EnumerableExtensions {
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;
    using EnumerableMapping for EnumerableMapping.AddressToUintMap;
    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;

    function toArray(EnumerableSet.AddressSet storage addresses)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = addresses.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = addresses.at(i);
        }
        return result;
    }

    function toArray(EnumerableSet.Bytes32Set storage values)
        internal
        view
        returns (bytes32[] memory)
    {
        uint256 len = values.length();
        bytes32[] memory result = new bytes32[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = values.at(i);
        }
        return result;
    }

    function keyAt(EnumerableMapping.AddressToAddressMap storage map, uint256 index)
        internal
        view
        returns (address)
    {
        (address key, ) = map.at(index);
        return key;
    }

    function valueAt(EnumerableMapping.AddressToAddressMap storage map, uint256 index)
        internal
        view
        returns (address)
    {
        (, address value) = map.at(index);
        return value;
    }

    function keyAt(EnumerableMapping.AddressToUintMap storage map, uint256 index)
        internal
        view
        returns (address)
    {
        (address key, ) = map.at(index);
        return key;
    }

    function keyAt(EnumerableMapping.Bytes32ToUIntMap storage map, uint256 index)
        internal
        view
        returns (bytes32)
    {
        (bytes32 key, ) = map.at(index);
        return key;
    }

    function valueAt(EnumerableMapping.AddressToUintMap storage map, uint256 index)
        internal
        view
        returns (uint256)
    {
        (, uint256 value) = map.at(index);
        return value;
    }

    function keysArray(EnumerableMapping.AddressToAddressMap storage map)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = map.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = keyAt(map, i);
        }
        return result;
    }

    function valuesArray(EnumerableMapping.AddressToAddressMap storage map)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = map.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = valueAt(map, i);
        }
        return result;
    }

    function keysArray(EnumerableMapping.AddressToUintMap storage map)
        internal
        view
        returns (address[] memory)
    {
        uint256 len = map.length();
        address[] memory result = new address[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = keyAt(map, i);
        }
        return result;
    }

    function keysArray(EnumerableMapping.Bytes32ToUIntMap storage map)
        internal
        view
        returns (bytes32[] memory)
    {
        uint256 len = map.length();
        bytes32[] memory result = new bytes32[](len);
        for (uint256 i = 0; i < len; i++) {
            result[i] = keyAt(map, i);
        }
        return result;
    }
}",857
RealWorld_TA_112_IPreparable_RealWorld_20240815131546.log,112,IPreparable,27674,1214,28888,122.0,0.16265,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IPreparable {
    event ConfigPreparedAddress(bytes32 indexed key, address value, uint256 delay);
    event ConfigPreparedNumber(bytes32 indexed key, uint256 value, uint256 delay);

    event ConfigUpdatedAddress(bytes32 indexed key, address oldValue, address newValue);
    event ConfigUpdatedNumber(bytes32 indexed key, uint256 oldValue, uint256 newValue);

    event ConfigReset(bytes32 indexed key);
}",109
RealWorld_TA_112_VaultReserve_RealWorld_20240815121309.log,112,VaultReserve,83460,2591,86051,182.0,0.46912,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/IVaultReserve.sol"";
import ""../../libraries/Errors.sol"";

import ""../access/Authorization.sol"";
import ""../vault/Vault.sol"";

/**
 * @notice Contract holding vault reserves
 * @dev ETH reserves are stored under address(0)
 */
contract VaultReserve is IVaultReserve, Authorization {
    using SafeERC20 for IERC20;

    uint256 internal constant _INITIAL_WITHDRAWAL_DELAY = 3 days;

    mapping(address => mapping(address => uint256)) private _balances;
    mapping(address => uint256) private _lastWithdrawal;

    uint256 public minWithdrawalDelay;

    modifier onlyVault() {
        require(_roleManager().hasRole(Roles.VAULT, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IRoleManager roleManager) Authorization(roleManager) {
        minWithdrawalDelay = _INITIAL_WITHDRAWAL_DELAY;
    }

    /**
     * @notice Deposit funds into vault reserve.
     * @notice Only callable by a whitelisted vault.
     * @param token Token to deposit.
     * @param amount Amount to deposit.
     * @return True if deposit was successful.
     */
    function deposit(address token, uint256 amount)
        external
        payable
        override
        onlyVault
        returns (bool)
    {
        if (token == address(0)) {
            require(msg.value == amount, Error.INVALID_AMOUNT);
            _balances[msg.sender][token] += msg.value;
            return true;
        }
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBalance = IERC20(token).balanceOf(address(this));
        uint256 received = newBalance - balance;
        require(received >= amount, Error.INVALID_AMOUNT);
        _balances[msg.sender][token] += received;
        emit Deposit(msg.sender, token, amount);
        return true;
    }

    /**
     * @notice Withdraw funds from vault reserve.
     * @notice Only callable by a whitelisted vault.
     * @param token Token to withdraw.
     * @param amount Amount to withdraw.
     * @return True if withdrawal was successful.
     */
    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {
        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);
        uint256 accountBalance = _balances[msg.sender][token];
        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);

        _balances[msg.sender][token] -= amount;
        _lastWithdrawal[msg.sender] = block.timestamp;

        if (token == address(0)) {
            payable(msg.sender).transfer(amount);
        } else {
            IERC20(token).safeTransfer(msg.sender, amount);
        }
        emit Withdraw(msg.sender, token, amount);
        return true;
    }

    /**
     * @notice Check token balance of a specific vault.
     * @param vault Vault to check balance of.
     * @param token Token to check balance in.
     * @return Token balance of vault.
     */
    function getBalance(address vault, address token) public view override returns (uint256) {
        return _balances[vault][token];
    }

    /**
     * @notice returns true if the vault is allowed to withdraw from the reserve
     */
    function canWithdraw(address vault) public view returns (bool) {
        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;
    }
}",792
RealWorld_TA_112_DataTypes_RealWorld_20240815124520.log,112,DataTypes,51319,1364,52683,145.0,0.283875,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
RealWorld_TA_112_ITopUpHandler_RealWorld_20240815134139.log,112,ITopUpHandler,43200,1244,44444,137.0,0.24088,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

/**
 * This interface should be implemented by protocols integrating with Backd
 * that require topping up a registered position
 */
interface ITopUpHandler {
    /**
     * @notice Tops up the account for the protocol associated with this handler
     * This is designed to be called using delegatecall and should therefore
     * not assume that storage will be available
     *
     * @param account account to be topped up
     * @param underlying underlying currency to be used for top up
     * @param amount amount to be topped up
     * @param extra arbitrary data that can be passed to the handler
     * @return true if the top up succeeded and false otherwise
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory extra
    ) external returns (bool);

    /**
     * @notice Returns a factor for the user which should always be >= 1 for sufficiently
     *         colletaralized positions and should get closer to 1 when collaterization level decreases
     * This should be an aggregate value including all the collateral of the user
     * @param account account for which to get the factor
     */
    function getUserFactor(bytes32 account, bytes memory extra) external view returns (uint256);
}",292
RealWorld_TA_112_ChainlinkAggregator_RealWorld_20240815142910.log,112,ChainlinkAggregator,46968,1475,48443,142.0,0.26434,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface AggregatorInterface {
    function latestAnswer() external view returns (int256);

    function latestTimestamp() external view returns (uint256);

    function latestRound() external view returns (uint256);

    function getAnswer(uint256 roundId) external view returns (int256);

    function getTimestamp(uint256 roundId) external view returns (uint256);

    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);
    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);
}

interface AggregatorV3Interface {
    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

    // getRoundData and latestRoundData should both raise ""No data present""
    // if they do not have data to report, instead of returning unset values
    // which could be misinterpreted as actual reported values.
    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}

interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}",334
RealWorld_TA_112_MockAction_RealWorld_20240815092126.log,112,MockAction,51677,3247,54924,103.0,0.323325,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/actions/IAction.sol"";
import ""../../interfaces/IGasBank.sol"";

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

contract MockAction is IAction {
    using EnumerableSet for EnumerableSet.AddressSet;
    mapping(address => uint256) private _totalGasRegistered;

    EnumerableSet.AddressSet private _usableTokens;

    receive() external payable {}

    function setEthRequiredForGas(address payer, uint256 amount) external {
        _totalGasRegistered[payer] = amount;
    }

    function withdrawFromGasBank(
        IGasBank bank,
        address account,
        uint256 amount
    ) external {
        bank.withdrawFrom(account, payable(address(this)), amount);
    }

    function addUsableToken(address token) external override returns (bool) {
        return _usableTokens.add(token);
    }

    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        return _totalGasRegistered[payer];
    }

    function getUsableTokens() external pure returns (address[] memory) {
        return new address[](0);
    }

    function isUsable(address) external pure returns (bool) {
        return false;
    }

    function getActionFee() external pure returns (uint256) {
        return 0;
    }

    function getFeeHandler() external pure returns (address) {
        return address(0);
    }

    function executeActionFee() external pure returns (uint256) {
        return 0;
    }

    function executeSwapperSlippage() external pure returns (uint256) {
        return 0;
    }

    function executeFeeHandler() external pure returns (address) {
        return address(0);
    }
}",382
RealWorld_TA_112_IVaultReserve_RealWorld_20240815130326.log,112,IVaultReserve,29208,1676,30884,151.0,0.17956,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IVaultReserve {
    event Deposit(address indexed vault, address indexed token, uint256 amount);
    event Withdraw(address indexed vault, address indexed token, uint256 amount);
    event VaultListed(address indexed vault);

    function deposit(address token, uint256 amount) external payable returns (bool);

    function withdraw(address token, uint256 amount) external returns (bool);

    function getBalance(address vault, address token) external view returns (uint256);

    function canWithdraw(address vault) external view returns (bool);
}",130
RealWorld_TA_112_EthPool_RealWorld_20240815115240.log,112,EthPool,43472,3961,47433,133.0,0.29658,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./LiquidityPool.sol"";
import ""../../interfaces/pool/IEthPool.sol"";

contract EthPool is LiquidityPool, IEthPool {
    constructor(IController _controller) LiquidityPool(_controller) {}

    receive() external payable {}

    function initialize(
        string memory name_,
        uint256 depositCap_,
        address vault_
    ) external override returns (bool) {
        return _initialize(name_, depositCap_, vault_);
    }

    function getUnderlying() public pure override returns (address) {
        return address(0);
    }

    function _doTransferIn(address from, uint256 amount) internal override {
        require(msg.sender == from, Error.INVALID_SENDER);
        require(msg.value == amount, Error.INVALID_AMOUNT);
    }

    function _doTransferOut(address payable to, uint256 amount) internal override {
        to.transfer(amount);
    }

    function _getBalanceUnderlying() internal view override returns (uint256) {
        return _getBalanceUnderlying(false);
    }

    function _getBalanceUnderlying(bool transferInDone) internal view override returns (uint256) {
        uint256 balance = address(this).balance;
        if (!transferInDone) {
            balance -= msg.value;
        }
        return balance;
    }
}",284
RealWorld_TA_112_IDelegateRegistry_RealWorld_20240815151830.log,112,IDelegateRegistry,24740,1803,26543,143.0,0.15976,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

/**
 * Full contract can be found here: https://github.com/gnosis/delegate-registry/blob/main/contracts/DelegateRegistry.sol
 */

interface IDelegateRegistry {
    function setDelegate(bytes32 id, address delegate) external;

    function clearDelegate(bytes32 id) external;
}",76
RealWorld_TA_112_ICurveSwap_RealWorld_20240815151003.log,112,ICurveSwap,50651,2074,52725,134.0,0.294735,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveSwap {
    function get_virtual_price() external view returns (uint256);

    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;

    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;

    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;

    function exchange(
        int128 from,
        int128 to,
        uint256 _from_amount,
        uint256 _min_to_amount
    ) external;

    function coins(uint256 i) external view returns (address);

    function get_dy(
        int128 i,
        int128 j,
        uint256 _dx
    ) external view returns (uint256);

    function calc_token_amount(uint256[4] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_token_amount(uint256[3] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)
        external
        view
        returns (uint256);

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;
}",386
RealWorld_TA_112_IUniswapV2Pair_RealWorld_20240815152055.log,112,IUniswapV2Pair,66995,1351,68346,143.0,0.361995,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to) external returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}",578
RealWorld_TA_112_MockErc20_RealWorld_20240815085857.log,112,MockErc20,38591,2364,40955,99.0,0.240235,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockErc20 is ERC20 {
    uint8 internal _decimals;

    constructor(uint8 decimals_) ERC20(""mock"", ""MOK"") {
        _decimals = decimals_;
    }

    function mintFor(address account, uint256 amount) external returns (bool) {
        _mint(account, amount);
        return true;
    }

    function mint(uint256 amount) external {
        _mint(msg.sender, amount);
    }

    /**
     * @dev Uses same function name as `MintableForkToken` from Brownie-Token-Tester, which makes
     *      it cleaner in tests to use this both in fork and dev mode
     */
    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing(address account, uint256 amount) external {
        _mint(account, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}",237
RealWorld_TA_112_MockBooster_RealWorld_20240815091017.log,112,MockBooster,64459,3662,68121,120.0,0.395535,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/vendor/IBooster.sol"";
import ""../testing/MockErc20.sol"";
import ""./MockRewardStaking.sol"";

// solhint-disable no-unused-vars
contract MockBooster is IBooster {
    address public lpToken;
    address public token;
    address public crvRewards;

    mapping(address => uint256) public balances;

    constructor(
        address _lpToken,
        address _token,
        address _crvRewards
    ) {
        lpToken = _lpToken;
        token = _token;
        crvRewards = _crvRewards;
    }

    function deposit(
        uint256 _pid,
        uint256 _amount,
        bool _stake
    ) external override returns (bool) {
        IERC20(lpToken).transferFrom(msg.sender, address(this), _amount);
        if (_stake) {
            MockErc20(token).mint_for_testing(address(this), _amount);
            balances[msg.sender] += _amount;
            MockErc20(token).approve(crvRewards, _amount);
            MockRewardStaking(crvRewards).stakeFor(msg.sender, _amount);
        } else {
            MockErc20(token).mint_for_testing(msg.sender, _amount);
        }
        return true;
    }

    function withdraw(uint256 _pid, uint256 _amount) external override returns (bool) {
        MockErc20(token).transferFrom(msg.sender, address(0), _amount);
        IERC20(lpToken).transfer(msg.sender, _amount);
        return true;
    }

    function withdrawTo(
        uint256 _pid,
        uint256 _amount,
        address _to
    ) external override returns (bool) {
        MockErc20(token).transferFrom(msg.sender, address(0), _amount);
        IERC20(lpToken).transfer(_to, _amount);
        return true;
    }

    function withdrawAll(uint256 _pid) external override returns (bool) {
        return true;
    }

    function depositAll(uint256 _pid, bool _stake) external override returns (bool) {
        return true;
    }

    function poolInfo(uint256 pid)
        external
        view
        override
        returns (
            address,
            address,
            address,
            address,
            address,
            bool
        )
    {
        return (lpToken, token, address(0), crvRewards, address(0), false);
    }
}",551
RealWorld_TA_112_ICvxCrvRewardsLocker_RealWorld_20240815125559.log,112,ICvxCrvRewardsLocker,26854,1456,28310,137.0,0.16339,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ICvxCrvRewardsLocker {
    function lockRewards() external returns (bool);

    function lockCvx() external;

    function lockCrv() external;

    function claimRewards(bool lockAndStake) external returns (bool);

    function stakeCvxCrv() external returns (bool);

    function processExpiredLocks(bool relock) external returns (bool);
}",104
RealWorld_TA_112_ComptrollerStorage_RealWorld_20240815150514.log,112,ComptrollerStorage,106974,2816,109790,137.0,0.59119,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./CToken.sol"";
import ""./PriceOracle.sol"";

contract UnitrollerAdminStorage {
    /**
     * @notice Administrator for this contract
     */
    address public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address public pendingAdmin;

    /**
     * @notice Active brains of Unitroller
     */
    address public comptrollerImplementation;

    /**
     * @notice Pending brains of Unitroller
     */
    address public pendingComptrollerImplementation;
}

contract ComptrollerV1Storage is UnitrollerAdminStorage {
    /**
     * @notice Oracle which gives the price of any given asset
     */
    PriceOracle public oracle;

    /**
     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow
     */
    uint256 public closeFactorMantissa;

    /**
     * @notice Multiplier representing the discount on collateral that a liquidator receives
     */
    uint256 public liquidationIncentiveMantissa;

    /**
     * @notice Max number of assets a single account can participate in (borrow or use as collateral)
     */
    uint256 public maxAssets;

    /**
     * @notice Per-account mapping of ""assets you are in"", capped by maxAssets
     */
    mapping(address => CToken[]) public accountAssets;
}

contract ComptrollerV2Storage is ComptrollerV1Storage {
    struct Market {
        /// @notice Whether or not this market is listed
        bool isListed;
        /**
         * @notice Multiplier representing the most one can borrow against their collateral in this market.
         *  For instance, 0.9 to allow borrowing 90% of collateral value.
         *  Must be between 0 and 1, and stored as a mantissa.
         */
        uint256 collateralFactorMantissa;
        /// @notice Per-market mapping of ""accounts in this asset""
        mapping(address => bool) accountMembership;
        /// @notice Whether or not this market receives COMP
        bool isComped;
    }

    /**
     * @notice Official mapping of cTokens -> Market metadata
     * @dev Used e.g. to determine if a market is supported
     */
    mapping(address => Market) public markets;

    /**
     * @notice The Pause Guardian can pause certain actions as a safety mechanism.
     *  Actions which allow users to remove their own assets cannot be paused.
     *  Liquidation / seizing / transfer can only be paused globally, not by market.
     */
    address public pauseGuardian;
    bool public _mintGuardianPaused;
    bool public _borrowGuardianPaused;
    bool public transferGuardianPaused;
    bool public seizeGuardianPaused;
    mapping(address => bool) public mintGuardianPaused;
    mapping(address => bool) public borrowGuardianPaused;
}

contract ComptrollerV3Storage is ComptrollerV2Storage {
    struct CompMarketState {
        /// @notice The market's last updated compBorrowIndex or compSupplyIndex
        uint224 index;
        /// @notice The block number the index was last updated at
        uint32 block;
    }

    /// @notice A list of all markets
    CToken[] public allMarkets;

    /// @notice The rate at which the flywheel distributes COMP, per block
    uint256 public compRate;

    /// @notice The portion of compRate that each market currently receives
    mapping(address => uint256) public compSpeeds;

    /// @notice The COMP market supply state for each market
    mapping(address => CompMarketState) public compSupplyState;

    /// @notice The COMP market borrow state for each market
    mapping(address => CompMarketState) public compBorrowState;

    /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP
    mapping(address => mapping(address => uint256)) public compSupplierIndex;

    /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP
    mapping(address => mapping(address => uint256)) public compBorrowerIndex;

    /// @notice The COMP accrued but not yet transferred to each user
    mapping(address => uint256) public compAccrued;
}

contract ComptrollerV4Storage is ComptrollerV3Storage {
    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.
    address public borrowCapGuardian;

    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.
    mapping(address => uint256) public borrowCaps;
}

contract ComptrollerV5Storage is ComptrollerV4Storage {
    /// @notice The portion of COMP that each contributor receives per block
    mapping(address => uint256) public compContributorSpeeds;

    /// @notice Last block at which a contributor's COMP rewards have been allocated
    mapping(address => uint256) public lastContributorBlock;
}",1067
RealWorld_TA_112_LpGauge_RealWorld_20240815113545.log,112,LpGauge,105022,3277,108299,139.0,0.59065,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/ILpGauge.sol"";
import ""../../interfaces/tokenomics/IRewardsGauge.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract LpGauge is ILpGauge, IRewardsGauge, Authorization {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;

    IController public immutable controller;
    IStakerVault public immutable stakerVault;
    IInflationManager public immutable inflationManager;

    uint256 public poolStakedIntegral;
    uint256 public poolLastUpdate;
    mapping(address => uint256) public perUserStakedIntegral;
    mapping(address => uint256) public perUserShare;

    constructor(IController _controller, address _stakerVault)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(_stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = IController(_controller);
        stakerVault = IStakerVault(_stakerVault);
        IInflationManager _inflationManager = IController(_controller).inflationManager();
        require(address(_inflationManager) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        inflationManager = _inflationManager;
    }

    /**
     * @notice Checkpoint function for the pool statistics.
     * @return `true` if successful.
     */
    function poolCheckpoint() external override returns (bool) {
        return _poolCheckpoint();
    }

    /**
     * @notice Calculates the token rewards a user should receive and mints these.
     * @param beneficiary Address to claim rewards for.
     * @return `true` if success.
     */
    function claimRewards(address beneficiary) external override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        if (amount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        _mintRewards(beneficiary, amount);
        return amount;
    }

    function claimableRewards(address beneficiary) external view override returns (uint256) {
        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();
        uint256 poolStakedIntegral_ = poolStakedIntegral;
        if (poolTotalStaked > 0) {
            poolStakedIntegral_ += (inflationManager.getLpRateForStakerVault(address(stakerVault)) *
                (block.timestamp - poolLastUpdate)).scaledDiv(poolTotalStaked);
        }

        return
            perUserShare[beneficiary] +
            stakerVault.stakedAndActionLockedBalanceOf(beneficiary).scaledMul(
                poolStakedIntegral_ - perUserStakedIntegral[beneficiary]
            );
    }

    /**
     * @notice Checkpoint function for the statistics for a particular user.
     * @param user Address of the user to checkpoint.
     * @return `true` if successful.
     */
    function userCheckpoint(address user) public override returns (bool) {
        _poolCheckpoint();

        // No checkpoint for the actions and strategies, since this does not accumulate tokens
        if (
            IController(controller).addressProvider().isAction(user) || stakerVault.isStrategy(user)
        ) {
            return false;
        }
        uint256 poolStakedIntegral_ = poolStakedIntegral;
        perUserShare[user] += (
            (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(
                (poolStakedIntegral_ - perUserStakedIntegral[user])
            )
        );

        perUserStakedIntegral[user] = poolStakedIntegral_;

        return true;
    }

    function _mintRewards(address beneficiary, uint256 amount) internal {
        inflationManager.mintRewards(beneficiary, amount);
    }

    function _poolCheckpoint() internal returns (bool) {
        uint256 currentRate = inflationManager.getLpRateForStakerVault(address(stakerVault));
        // Update the integral of total token supply for the pool
        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();
        if (poolTotalStaked > 0) {
            poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv(
                poolTotalStaked
            );
        }
        poolLastUpdate = block.timestamp;
        return true;
    }
}",1024
RealWorld_TA_112_MockGauge_RealWorld_20240815093711.log,112,MockGauge,48062,2849,50911,113.0,0.29729,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/vendor/IGauge.sol"";
import ""./MockErc20.sol"";

contract MockGauge is IGauge {
    address private _lpToken;

    mapping(address => uint256) private _balances;

    // mock claimable CRV rewards
    uint256 private _claimableTokens = 0;

    constructor(address lpToken_) {
        _lpToken = lpToken_;
    }

    function deposit(uint256 amount) external override {
        require(
            MockErc20(_lpToken).balanceOf(msg.sender) >= amount,
            ""insufficient user gauge balance""
        );
        MockErc20(_lpToken).transferFrom(msg.sender, address(this), amount);
        _balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external override {
        require(_balances[msg.sender] >= amount, ""insufficient user gauge balance"");
        _balances[msg.sender] -= amount;
        MockErc20(_lpToken).transfer(msg.sender, amount);
    }

    // for mocking CRV rewards
    function setClaimableTokens(uint256 amount) external {
        _claimableTokens = amount;
    }

    // solhint-disable-next-line func-name-mixedcase
    function user_checkpoint(address account) external override {}

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    // solhint-disable-next-line func-name-mixedcase
    function claimable_tokens(address) external view override returns (uint256) {
        return _claimableTokens;
    }
}",344
RealWorld_TA_112_ICTokenRegistry_RealWorld_20240815124748.log,112,ICTokenRegistry,25316,1072,26388,170.0,0.14802,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./vendor/CToken.sol"";

interface ICTokenRegistry {
    function getCToken(address underlying) external view returns (CToken);

    function getCToken(address underlying, bool ensureExists) external view returns (CToken);

    function fetchCToken(address underlying) external returns (CToken);
}",85
RealWorld_TA_112_ICurveCryptoSwap_RealWorld_20240815144140.log,112,ICurveCryptoSwap,23290,1372,24662,149.0,0.14389,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveCryptoSwap {
    function exchange_underlying(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external returns (uint256);
}",60
RealWorld_TA_112_MockRewardStaking_RealWorld_20240815091543.log,112,MockRewardStaking,81121,5512,86633,134.0,0.515845,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./MockBooster.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/vendor/IBooster.sol"";
import ""../../interfaces/vendor/IRewardStaking.sol"";
import ""../testing/MockErc20.sol"";
import ""../utils/CvxMintAmount.sol"";

// solhint-disable no-unused-vars
contract MockRewardStaking is IRewardStaking, CvxMintAmount {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public crvEarned;
    mapping(address => uint256) public cvxEarned;

    address public token;
    address public crvToken;
    address public cvxToken;
    address public booster;

    constructor(
        address _token,
        address _tokenCrv,
        address _tokenCvx
    ) {
        token = _token;
        crvToken = _tokenCrv;
        cvxToken = _tokenCvx;
    }

    function setBooster(address _booster) external {
        booster = _booster;
    }

    function setCrvEarned(address user, uint256 amount) external {
        crvEarned[user] = amount;
        cvxEarned[user] = getCvxMintAmount(amount);
    }

    function stakeFor(address user, uint256 amount) external override {
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        balances[user] += amount;
    }

    function stake(uint256) external override {}

    function stakeAll() external override returns (bool) {
        return true;
    }

    function withdraw(uint256 amount, bool claim) external override returns (bool) {
        return true;
    }

    function withdrawAndUnwrap(uint256 amount, bool claim) external override returns (bool) {
        require(!claim, ""Not implemented claiming in withdraw and unwrap"");
        balances[msg.sender] -= amount;
        IBooster(booster).withdrawTo(0, amount, msg.sender);
        return true;
    }

    function getReward() external override {
        MockErc20(crvToken).mint_for_testing(msg.sender, crvEarned[msg.sender]);
        MockErc20(cvxToken).mint_for_testing(msg.sender, cvxEarned[msg.sender]);
        crvEarned[msg.sender] = 0;
        cvxEarned[msg.sender] = 0;
    }

    function getReward(address _account, bool _claimExtras) external override {
        MockErc20(crvToken).mint_for_testing(_account, crvEarned[_account]);
        MockErc20(cvxToken).mint_for_testing(_account, cvxEarned[_account]);
        crvEarned[_account] = 0;
        cvxEarned[_account] = 0;
    }

    function earned(address account) external view override returns (uint256) {
        return crvEarned[account];
    }

    function extraRewardsLength() external view override returns (uint256) {
        return 0;
    }

    function extraRewards(uint256 _pid) external view override returns (address) {
        return address(0);
    }

    function rewardToken() external view override returns (address) {
        return crvToken;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }
}",721
RealWorld_TA_112_LiquidityPoolProfiler_RealWorld_20240815094403.log,112,LiquidityPoolProfiler,36408,3528,39936,110.0,0.2526,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../../interfaces/pool/ILiquidityPool.sol"";

import ""../../LpToken.sol"";
import ""../../pool/LiquidityPool.sol"";

contract LiquidityPoolProfiler {
    LiquidityPool public liquidityPool;

    constructor(address _liquidityPool, address token) {
        liquidityPool = LiquidityPool(_liquidityPool);
        LpToken(address(liquidityPool.lpToken())).approve(
            address(liquidityPool),
            type(uint256).max
        );
        ERC20(token).approve(address(liquidityPool), type(uint256).max);
    }

    function profileDeposit(uint256 amount) external {
        liquidityPool.deposit(amount);
        liquidityPool.deposit(amount);
        liquidityPool.deposit(amount);

        liquidityPool.redeem(amount);
        liquidityPool.redeem(amount);
    }
}",205
RealWorld_TA_112_AccountEncoding_RealWorld_20240815124005.log,112,AccountEncoding,24940,1378,26318,151.0,0.15226,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

library AccountEncoding {
    function addr(bytes32 account) internal pure returns (address) {
        return address(bytes20(account));
    }

    function meta(bytes32 account) internal pure returns (bytes12) {
        return bytes12(account << 160);
    }
}",77
RealWorld_TA_112_MockStrategySwapper_RealWorld_20240815083442.log,112,MockStrategySwapper,27545,3399,30944,96.0,0.205705,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./StrategySwapper.sol"";

contract MockStrategySwapper is StrategySwapper {
    constructor(address addressProvider_, uint256 slippageTolerance_)
        StrategySwapper(addressProvider_, slippageTolerance_)
    {}

    function overrideSlippageTolerance(uint256 slippageTolerance_) external {
        slippageTolerance = slippageTolerance_;
    }
}",103
RealWorld_TA_112_MockFeeDistributor_RealWorld_20240815093331.log,112,MockFeeDistributor,28318,2400,30718,98.0,0.18959,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/vendor/IGauge.sol"";

contract MockFeeDistributor is IFeeDistributor {
    uint256 private _feeToClaim = 100;

    // this is for mocking fees
    function setFeeToClaim(uint256 _fee) external {
        _feeToClaim = _fee;
    }

    function claim(address) external view override returns (uint256) {
        return _feeToClaim;
    }
}",111
RealWorld_TA_112_IGasBank_RealWorld_20240815130559.log,112,IGasBank,28870,1400,30270,155.0,0.17235,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IGasBank {
    event Deposit(address indexed account, uint256 value);
    event Withdraw(address indexed account, address indexed receiver, uint256 value);

    function depositFor(address account) external payable;

    function withdrawUnused(address account) external;

    function withdrawFrom(address account, uint256 amount) external;

    function withdrawFrom(
        address account,
        address payable to,
        uint256 amount
    ) external;

    function balanceOf(address account) external view returns (uint256);
}",124
RealWorld_TA_112_MockInflationManager_RealWorld_20240815092439.log,112,MockInflationManager,26914,2782,29696,107.0,0.19021,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/tokenomics/IKeeperGauge.sol"";

import ""../tokenomics/InflationManager.sol"";

contract MockInflationManager is InflationManager {
    constructor(IAddressProvider addressProvider) InflationManager(addressProvider) {}

    function callKillKeeperGauge(address _keeperGauge) external {
        IKeeperGauge(_keeperGauge).kill();
    }
}",100
RealWorld_TA_112_Erc20Pool_RealWorld_20240815115455.log,112,Erc20Pool,45111,2504,47615,124.0,0.275635,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./LiquidityPool.sol"";
import ""../../interfaces/pool/IErc20Pool.sol"";

contract Erc20Pool is LiquidityPool, IErc20Pool {
    using SafeERC20 for IERC20;

    address private _underlying;

    constructor(IController _controller) LiquidityPool(_controller) {}

    function initialize(
        string memory name_,
        address underlying_,
        uint256 depositCap_,
        address vault_
    ) public override returns (bool) {
        require(underlying_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _underlying = underlying_;
        return _initialize(name_, depositCap_, vault_);
    }

    function getUnderlying() public view override returns (address) {
        return _underlying;
    }

    function _doTransferIn(address from, uint256 amount) internal override {
        require(msg.value == 0, Error.INVALID_VALUE);
        IERC20(_underlying).safeTransferFrom(from, address(this), amount);
    }

    function _doTransferOut(address payable to, uint256 amount) internal override {
        IERC20(_underlying).safeTransfer(to, amount);
    }

    function _getBalanceUnderlying() internal view override returns (uint256) {
        return IERC20(_underlying).balanceOf(address(this));
    }

    function _getBalanceUnderlying(bool) internal view override returns (uint256) {
        return _getBalanceUnderlying();
    }
}",323
RealWorld_TA_112_ChainlinkOracleProvider_RealWorld_20240815082355.log,112,ChainlinkOracleProvider,63866,3226,67092,101.0,0.38385,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../access/Authorization.sol"";

import ""../../interfaces/oracles/IChainlinkOracleProvider.sol"";
import ""../../interfaces/vendor/ChainlinkAggregator.sol"";

import ""../../libraries/Errors.sol"";
import ""../../libraries/DecimalScale.sol"";

contract ChainlinkOracleProvider is IChainlinkOracleProvider, Authorization {
    using DecimalScale for uint256;

    uint256 public stalePriceDelay;

    mapping(address => address) public feeds;

    event FeedUpdated(address indexed asset, address indexed previousFeed, address indexed newFeed);

    constructor(IRoleManager roleManager, address ethFeed) Authorization(roleManager) {
        feeds[address(0)] = ethFeed;
        stalePriceDelay = 2 hours;
    }

    /// @notice Allows to set Chainlink feeds
    /// @dev All feeds should be set relative to USD.
    /// This can only be called by governance
    function setFeed(address asset, address feed) external override onlyGovernance {
        address previousFeed = feeds[asset];
        require(feed != previousFeed, Error.INVALID_ARGUMENT);
        feeds[asset] = feed;
        emit FeedUpdated(asset, previousFeed, feed);
    }

    /**
     * @notice Sets the stake price delay value.
     * @param stalePriceDelay_ The new stale price delay to set.
     */
    function setStalePriceDelay(uint256 stalePriceDelay_) external override onlyGovernance {
        require(stalePriceDelay_ >= 1 hours, Error.INVALID_ARGUMENT);
        stalePriceDelay = stalePriceDelay_;
    }

    /// @inheritdoc IOracleProvider
    function getPriceETH(address asset) external view override returns (uint256) {
        return (getPriceUSD(asset) * 1e18) / getPriceUSD(address(0));
    }

    /// @inheritdoc IOracleProvider
    function getPriceUSD(address asset) public view override returns (uint256) {
        address feed = feeds[asset];
        require(feed != address(0), Error.ASSET_NOT_SUPPORTED);

        (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();

        require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);
        require(answer >= 0, Error.NEGATIVE_PRICE);

        uint256 price = uint256(answer);
        uint8 decimals = AggregatorV2V3Interface(feed).decimals();
        return price.scaleFrom(decimals);
    }
}",519
RealWorld_TA_112_IStakerVault_RealWorld_20240815125040.log,112,IStakerVault,56139,2523,58662,162.0,0.331155,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IStakerVault {
    event Staked(address indexed account, uint256 amount);
    event Unstaked(address indexed account, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function initialize(address _token) external;

    function initializeLpGauge(address _lpGauge) external returns (bool);

    function stake(uint256 amount) external returns (bool);

    function stakeFor(address account, uint256 amount) external returns (bool);

    function unstake(uint256 amount) external returns (bool);

    function unstakeFor(
        address src,
        address dst,
        uint256 amount
    ) external returns (bool);

    function approve(address spender, uint256 amount) external returns (bool);

    function transfer(address account, uint256 amount) external returns (bool);

    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function getToken() external view returns (address);

    function balanceOf(address account) external view returns (uint256);

    function stakedAndActionLockedBalanceOf(address account) external view returns (uint256);

    function actionLockedBalanceOf(address account) external view returns (uint256);

    function increaseActionLockedBalance(address account, uint256 amount) external returns (bool);

    function decreaseActionLockedBalance(address account, uint256 amount) external returns (bool);

    function getStakedByActions() external view returns (uint256);

    function addStrategy(address strategy) external returns (bool);

    function getPoolTotalStaked() external view returns (uint256);

    function prepareLpGauge(address _lpGauge) external returns (bool);

    function executeLpGauge() external returns (bool);

    function getLpGauge() external view returns (address);

    function poolCheckpoint() external returns (bool);

    function isStrategy(address user) external view returns (bool);
}",455
RealWorld_TA_112_GasBank_RealWorld_20240815081645.log,112,GasBank,71479,4301,75780,116.0,0.443415,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../libraries/Errors.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IGasBank.sol"";

contract GasBank is IGasBank {
    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    /**
     * @notice Keeps track of the user balances
     */
    mapping(address => uint256) internal _balances;

    constructor(IController _controller) {
        addressProvider = _controller.addressProvider();
        controller = _controller;
    }

    /**
     * @notice Deposit `msg.value` on behalf of `account`
     */
    function depositFor(address account) external payable override {
        _balances[account] += msg.value;
        emit Deposit(account, msg.value);
    }

    /**
     * @notice Withdraws `amount` from `account`
     */
    function withdrawFrom(address account, uint256 amount) external override {
        withdrawFrom(account, payable(account), amount);
    }

    /**
     * @notice Withdraws amount not required by any action
     */
    function withdrawUnused(address account) external {
        uint256 currentBalance = _balances[account];
        require(
            msg.sender == account || addressProvider.isAction(msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        uint256 ethRequired = controller.getTotalEthRequiredForGas(account);
        if (currentBalance > ethRequired) {
            _withdrawFrom(account, payable(account), currentBalance - ethRequired, currentBalance);
        }
    }

    /**
     * @return the balance of `account`
     */
    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @notice Withdraws `amount` on behalf of `account` and send to `to`
     */
    function withdrawFrom(
        address account,
        address payable to,
        uint256 amount
    ) public override {
        uint256 currentBalance = _balances[account];
        require(currentBalance >= amount, Error.NOT_ENOUGH_FUNDS);
        require(
            msg.sender == account || addressProvider.isAction(msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );

        if (msg.sender == account) {
            uint256 ethRequired = controller.getTotalEthRequiredForGas(account);
            require(currentBalance - amount >= ethRequired, Error.NOT_ENOUGH_FUNDS);
        }
        _withdrawFrom(account, to, amount, currentBalance);
    }

    function _withdrawFrom(
        address account,
        address payable to,
        uint256 amount,
        uint256 currentBalance
    ) internal {
        _balances[account] = currentBalance - amount;

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = to.call{value: amount}("""");
        require(success, Error.FAILED_TRANSFER);

        emit Withdraw(account, to, amount);
    }
}",607
RealWorld_TA_112_Swapper3Crv_RealWorld_20240815081843.log,112,Swapper3Crv,198967,4877,203844,129.0,1.092375,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/vendor/ICurveSwap.sol"";
import ""../../interfaces/vendor/UniswapRouter02.sol"";
import ""../../interfaces/ISwapper.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/ScaledMath.sol"";

contract Swapper3Crv is ISwapper {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    // Dex contracts
    address public constant UNISWAP = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address public constant SUSHISWAP = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);

    // Dex factories
    address public constant UNISWAP_FACTORY = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    address public constant SUSHISWAP_FACTORY = address(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);

    // ERC20 tokens
    address public constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    address public constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    address public constant USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    address public constant TRI_CRV = address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);

    // Curve pool
    address public constant CURVE_POOL = address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);

    mapping(address => int128) public triPoolIndex; // dev: 3Pool is immutable so these won't change
    mapping(address => mapping(address => address)) public lpTokens;

    constructor() {
        triPoolIndex[DAI] = int128(0);
        triPoolIndex[USDC] = int128(1);
        triPoolIndex[USDT] = int128(2);

        IERC20(DAI).safeApprove(SUSHISWAP, type(uint256).max);
        IERC20(USDC).safeApprove(SUSHISWAP, type(uint256).max);
        IERC20(USDT).safeApprove(SUSHISWAP, type(uint256).max);

        IERC20(DAI).safeApprove(UNISWAP, type(uint256).max);
        IERC20(USDC).safeApprove(UNISWAP, type(uint256).max);
        IERC20(USDT).safeApprove(UNISWAP, type(uint256).max);
    }

    function swap(
        address fromToken,
        address toToken,
        uint256 swapAmount,
        uint256 minAmount
    ) external override returns (uint256) {
        require(
            fromToken == TRI_CRV && ((toToken == DAI) || (toToken == USDC) || (toToken == USDT)),
            ""Token pair not swappable""
        );
        IERC20(fromToken).transferFrom(msg.sender, address(this), swapAmount);
        (address dex, address token) = _getBestTokenToWithdraw(swapAmount, toToken);
        ICurveSwap(CURVE_POOL).remove_liquidity_one_coin(swapAmount, triPoolIndex[token], 0);
        uint256 amountReceived = _swapAll(token, toToken, dex);

        require(amountReceived >= minAmount, Error.INSUFFICIENT_FUNDS_RECEIVED);
        return amountReceived;
    }

    /**
     * @notice Calculate the exchange rate for the token pair.
     */
    function getRate(address fromToken, address toToken) external view override returns (uint256) {
        require(
            fromToken == TRI_CRV && ((toToken == DAI) || (toToken == USDC) || (toToken == USDT)),
            ""Token pair not swappable""
        );
        if (toToken == DAI) return ICurveSwap(CURVE_POOL).get_virtual_price();
        return ICurveSwap(CURVE_POOL).get_virtual_price() / 1e12;
    }

    /**
     * @dev Swaps the contracts full balance of tokenIn for tokenOut.
     * @param tokenIn Token to swap for tokenOut.
     * @param tokenOut Target token to receive in swap.
     * @return The amount of tokenOut received.
     */
    function _swapAll(
        address tokenIn,
        address tokenOut,
        address dex
    ) internal returns (uint256) {
        uint256 amountIn = IERC20(tokenIn).balanceOf(address(this));
        if (tokenIn == tokenOut) {
            IERC20(tokenOut).safeTransfer(msg.sender, amountIn);
            return amountIn;
        }
        if (amountIn == 0) return 0;
        address[] memory path = new address[](3);
        path[0] = tokenIn;
        path[1] = WETH;
        path[2] = tokenOut;
        return
            UniswapRouter02(dex).swapExactTokensForTokens(
                amountIn,
                0,
                path,
                msg.sender,
                block.timestamp
            )[2];
    }

    /**
     * @dev Gets the best token to withdraw from Curve Pool for swapping.
     * @param amount Amount of 3CRV to withdraw and swap.
     * @param tokenOut Target token to receive in swap.
     * @return The best token to withdraw from Curve Pool for swapping.
     */
    function _getBestTokenToWithdraw(uint256 amount, address tokenOut)
        internal
        view
        returns (address, address)
    {
        (address daiDex, uint256 daiOutput) = _getAmountOut(amount, DAI, tokenOut);
        (address usdcDex, uint256 usdcOutput) = _getAmountOut(amount, USDC, tokenOut);
        (address usdtDex, uint256 usdtOutput) = _getAmountOut(amount, USDT, tokenOut);
        if (daiOutput > usdcOutput && daiOutput > usdtOutput) {
            return (daiDex, DAI);
        } else if (usdcOutput > usdtOutput) {
            return (usdcDex, USDC);
        } else {
            return (usdtDex, USDT);
        }
    }

    /**
     * @dev Gets the amount of tokenOut received if swapping 3CRV via tokenIn.
     * @param amountIn The amount of 3CRV to withdraw and swap.
     * @param tokenIn Token to withdraw liquidity in from Curve Pool and to swap with tokenOut.
     * @param tokenOut Target token out.
     * @return The amount of tokenOut received.
     */
    function _getAmountOut(
        uint256 amountIn,
        address tokenIn,
        address tokenOut
    ) internal view returns (address, uint256) {
        uint256 coinReceived = ICurveSwap(CURVE_POOL).calc_withdraw_one_coin(
            amountIn,
            triPoolIndex[tokenIn]
        );
        if (tokenIn == tokenOut) return (address(0), coinReceived);
        (address dex, uint256 amountOut) = _getBestDex(tokenIn, tokenOut, coinReceived);
        return (dex, amountOut);
    }

    /**
     * @dev Gets the best DEX to use for swapping token.
     *      Compares the amount out for Uniswap and Sushiswap.
     * @param fromToken Token to swap from.
     * @param toToken Token to swap to.
     * @param amount Amount of fromToken to swap.
     * @return bestDex The address of the best DEX to use.
     * @return amountOut The amount of toToken received from swapping.
     */
    function _getBestDex(
        address fromToken,
        address toToken,
        uint256 amount
    ) internal view returns (address bestDex, uint256 amountOut) {
        address uniswap_ = UNISWAP;
        address sushiSwap_ = UNISWAP;
        uint256 amountOutUniswap = _tokenAmountOut(fromToken, toToken, amount, uniswap_);
        uint256 amountOutSushiSwap = _tokenAmountOut(fromToken, toToken, amount, sushiSwap_);
        return
            amountOutUniswap >= amountOutSushiSwap
                ? (uniswap_, amountOutUniswap)
                : (sushiSwap_, amountOutSushiSwap);
    }

    /**
     * @notice Gets the amount of tokenOut that would be received by selling the tokenIn for underlying
     * @return tokenOut amount that would be received
     */
    function _tokenAmountOut(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        address dex
    ) internal view returns (uint256) {
        address[] memory path = new address[](3);
        path[0] = tokenIn;
        path[1] = WETH;
        path[2] = tokenOut;
        return UniswapRouter02(dex).getAmountsOut(amountIn, path)[2];
    }
}",2160
RealWorld_TA_112_Authorization_RealWorld_20240815082839.log,112,Authorization,25783,1435,27218,82.0,0.157615,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./AuthorizationBase.sol"";

contract Authorization is AuthorizationBase {
    IRoleManager internal immutable __roleManager;

    constructor(IRoleManager roleManager) {
        __roleManager = roleManager;
    }

    function _roleManager() internal view override returns (IRoleManager) {
        return __roleManager;
    }
}",89
RealWorld_TA_112_MockVault_RealWorld_20240815090827.log,112,MockVault,44116,3551,47667,108.0,0.2916,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../vault/EthVault.sol"";
import ""../vault/Erc20Vault.sol"";

abstract contract MockVaultMethods is Vault {
    function setStrategy(address _strategy) external onlyGovernance returns (bool) {
        if (address(getStrategy()) == _strategy) return false;

        _setConfig(_STRATEGY_KEY, _strategy);
        return true;
    }

    function setTargetAllocation(uint256 allocation) external onlyGovernance returns (uint256) {
        _setConfig(_TARGET_ALLOCATION_KEY, allocation);
        return allocation;
    }

    function setBound(uint256 newBound) external onlyGovernance returns (uint256) {
        _setConfig(_BOUND_KEY, newBound);
        return newBound;
    }

    function depositToReserve(address coin, uint256 amount) external {
        IERC20(coin).approve(address(reserve), amount);
        reserve.deposit(coin, amount);
    }

    function withdrawFromReserve(address coin, uint256 amount) external {
        reserve.withdraw(coin, amount);
    }
}

contract MockErc20Vault is Erc20Vault, MockVaultMethods {
    constructor(IController controller) Erc20Vault(controller) {}
}

contract MockEthVault is EthVault, MockVaultMethods {
    constructor(IController controller) EthVault(controller) {}
}",292
RealWorld_TA_112_IRewardsGauge_RealWorld_20240815135905.log,112,IRewardsGauge,21968,1334,23302,153.0,0.13652,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IRewardsGauge {
    function claimRewards(address beneficiary) external returns (uint256);
}",45
RealWorld_TA_112_MockStableSwap_RealWorld_20240815092759.log,112,MockStableSwap,122258,5295,127553,128.0,0.71719,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""../../interfaces/vendor/ICurveSwap.sol"";
import ""./MockCurveToken.sol"";

/**
 * @notice This is a just a mock contract and does NOT contain the logic for a Curve StableSwap pool.
 */

contract MockStableSwap is ICurveSwap {
    using SafeCast for uint256;
    using SafeCast for int128;

    uint256 private _virtualPrice = 1e18;
    uint256[3] private _balances = [0, 0, 0];
    address[3] private _allCoins;
    address private _lpToken;

    constructor(address[3] memory _coins, address lpToken_) {
        _allCoins = _coins;
        _lpToken = lpToken_;
    }

    // solhint-disable-next-line no-unused-vars, func-name-mixedcase
    function add_liquidity(uint256[3] calldata amounts, uint256) external override {
        uint256 total = 0;
        for (uint256 i = 0; i < 3; i++) {
            _balances[i] += amounts[i];
            total += amounts[i];
            IERC20(_allCoins[i]).transferFrom(msg.sender, address(this), amounts[i]);
        }
        // assume we mint 1 LP token per 1 underlying
        MockCurveToken(_lpToken).mintFor(msg.sender, total);
    }

    // solhint-disable-next-line no-unused-vars, func-name-mixedcase
    function add_liquidity(uint256[2] calldata amounts, uint256) external override {
        uint256 total = 0;
        for (uint256 i = 0; i < 2; i++) {
            _balances[i] += amounts[i];
            total += amounts[i];
            IERC20(_allCoins[i]).transferFrom(msg.sender, address(this), amounts[i]);
        }
        // assume we mint 1 LP token per 1 underlying
        MockCurveToken(_lpToken).mintFor(msg.sender, total);
    }

    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 maxBurnAmount)
        external
        override
    {}

    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 maxBurnAmount)
        external
        override
    {}

    /**
     * @param _amount LP tokens to burn
     * @param minAmounts Minimum amount of each underlying coin to withdraw
     */
    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity(uint256 _amount, uint256[3] calldata minAmounts) external override {
        // for mock; just withdraw minAmounts
        for (uint256 i = 0; i < 3; i++) {
            _balances[i] -= minAmounts[i];
            IERC20(_allCoins[i]).transfer(msg.sender, minAmounts[i]);
        }
        MockCurveToken(_lpToken).burnFrom(msg.sender, _amount);
    }

    // solhint-disable-next-line func-name-mixedcase
    function remove_liquidity_one_coin(
        uint256 tokenAmount,
        int128 i,
        uint256 minAmount
    ) external override {
        require(_balances[i.toUint256()] >= minAmount, ""Insufficient liquidity in mock curve pool"");
        _balances[i.toUint256()] -= minAmount;
        IERC20(_allCoins[i.toUint256()]).transfer(msg.sender, minAmount);
        MockCurveToken(_lpToken).burnFrom(msg.sender, tokenAmount);
    }

    function exchange(
        int128 from,
        int128 to,
        uint256 fromAmount,
        uint256 minToAmount
    ) external override {}

    // solhint-disable-next-line func-name-mixedcase
    function get_balances() external view returns (uint256[3] memory) {
        return _balances;
    }

    // solhint-disable-next-line func-name-mixedcase
    function calc_token_amount(uint256[3] calldata amounts, bool deposit)
        external
        view
        override
        returns (uint256)
    {}

    // solhint-disable-next-line func-name-mixedcase
    function get_virtual_price() external view override returns (uint256) {
        return _virtualPrice;
    }

    function coins(uint256 index) external view override returns (address) {
        require(index >= 0 && index < 3, ""Invalid coin index"");
        return _allCoins[index];
    }

    // solhint-disable-next-line no-unused-vars, func-name-mixedcase
    function calc_withdraw_one_coin(uint256 tokenAmount, int128)
        external
        pure
        override
        returns (uint256)
    {
        // return amount assuming that 1 LP = 1 underlying
        return tokenAmount;
    }

    // solhint-disable-next-line func-name-mixedcase
    function get_dy(
        int128,
        int128,
        uint256
    ) external pure override returns (uint256) {
        return 10;
    }

    // solhint-disable-next-line func-name-mixedcase
    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        pure
        override
        returns (uint256)
    {}

    // solhint-disable-next-line func-name-mixedcase
    function calc_token_amount(uint256[4] calldata amounts, bool deposit)
        external
        pure
        override
        returns (uint256)
    {}
}",1226
RealWorld_TA_112_IMigrationContract_RealWorld_20240815134630.log,112,IMigrationContract,22695,2023,24718,147.0,0.153935,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface IMigrationContract {
    function migrate(
        address user,
        uint256 balance,
        uint256 boost
    ) external;
}",46
RealWorld_TA_112_ISwapperRegistry_RealWorld_20240815131333.log,112,ISwapperRegistry,25714,1401,27115,131.0,0.15659,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ISwapperRegistry {
    function getSwapper(address fromToken, address toToken) external view returns (address);

    function swapperExists(address fromToken, address toToken) external view returns (bool);

    function getAllSwappableTokens(address token) external view returns (address[] memory);
}",85
RealWorld_TA_112_MockPriceOracle_RealWorld_20240815085531.log,112,MockPriceOracle,39840,2790,42630,96.0,0.255,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/oracles/IOracleProvider.sol"";

contract MockPriceOracle is IOracleProvider {
    mapping(address => uint256) internal _prices;

    function setPrice(address baseAsset, uint256 price) external {
        _prices[baseAsset] = price;
    }

    /// @inheritdoc IOracleProvider
    /// @dev this is a dummy function that tries to read from the state
    /// and otherwise simply returns 1
    function getPriceUSD(address baseAsset) external view returns (uint256) {
        uint256 cachedPrice = _prices[baseAsset];
        return cachedPrice == 0 ? 1e18 : cachedPrice;
    }

    /// @inheritdoc IOracleProvider
    /// @dev this is a dummy function that tries to read from the state
    /// and otherwise simply returns 1
    function getPriceETH(address baseAsset) external view returns (uint256) {
        uint256 cachedPrice = _prices[baseAsset];
        return cachedPrice == 0 ? 1e18 : cachedPrice;
    }
}",240
RealWorld_TA_112_CToken_RealWorld_20240815143632.log,112,CToken,27212,1958,29170,155.0,0.17522,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./ComptrollerInterface.sol"";
import ""./CTokenInterfaces.sol"";
import ""./ErrorReporter.sol"";

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
abstract contract CToken is CTokenInterface, CErc20Interface, TokenErrorReporter {

}

abstract contract CEthToken is CTokenInterface, CEthInterface, TokenErrorReporter {}",101
RealWorld_TA_112_InflationManager_RealWorld_20240815114628.log,112,InflationManager,499939,4728,504667,214.0,2.594255,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/tokenomics/IInflationManager.sol"";
import ""../../interfaces/tokenomics/IKeeperGauge.sol"";
import ""../../interfaces/tokenomics/IAmmGauge.sol"";

import ""../../libraries/EnumerableMapping.sol"";
import ""../../libraries/EnumerableExtensions.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""./Minter.sol"";
import ""../utils/Preparable.sol"";
import ""../access/Authorization.sol"";

contract InflationManager is Authorization, IInflationManager, Preparable {
    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;
    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;
    using AddressProviderHelpers for IAddressProvider;

    IAddressProvider public immutable addressProvider;

    bytes32 internal constant _KEEPER_WEIGHT_KEY = ""keeperWeight"";
    bytes32 internal constant _AMM_WEIGHT_KEY = ""ammWeight"";
    bytes32 internal constant _LP_WEIGHT_KEY = ""lpWeight"";

    address public minter;
    bool public weightBasedKeeperDistributionDeactivated;
    uint256 public totalKeeperPoolWeight;
    uint256 public totalLpPoolWeight;
    uint256 public totalAmmTokenWeight;

    // Pool -> keeperGauge
    EnumerableMapping.AddressToAddressMap private _keeperGauges;
    // AMM token -> ammGauge
    EnumerableMapping.AddressToAddressMap private _ammGauges;

    mapping(address => bool) public gauges;

    event NewKeeperWeight(address indexed pool, uint256 newWeight);
    event NewLpWeight(address indexed pool, uint256 newWeight);
    event NewAmmTokenWeight(address indexed token, uint256 newWeight);

    modifier onlyGauge() {
        require(gauges[msg.sender], Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IAddressProvider _addressProvider)
        Authorization(_addressProvider.getRoleManager())
    {
        addressProvider = _addressProvider;
    }

    function setMinter(address _minter) external onlyGovernance returns (bool) {
        require(minter == address(0), Error.ADDRESS_ALREADY_SET);
        require(_minter != address(0), Error.INVALID_MINTER);
        minter = _minter;
        return true;
    }

    /**
     * @notice Advance the keeper gauge for a pool by on epoch.
     * @param pool Pool for which the keeper gauge is advanced.
     * @return `true` if successful.
     */
    function advanceKeeperGaugeEpoch(address pool) external onlyGovernance returns (bool) {
        IKeeperGauge(_keeperGauges.get(pool)).advanceEpoch();
        return true;
    }

    /**
     * @notice Mints BKD tokens.
     * @param beneficiary Address to receive the tokens.
     * @param amount Amount of tokens to mint.
     */
    function mintRewards(address beneficiary, uint256 amount) external override onlyGauge {
        Minter(minter).mint(beneficiary, amount);
    }

    /**
     * @notice Deactivates the weight-based distribution of keeper inflation.
     * @dev This can only be done once, when the keeper inflation mechanism is altered.
     * @return `true` if successful.
     */
    function deactivateWeightBasedKeeperDistribution() external onlyGovernance returns (bool) {
        require(!weightBasedKeeperDistributionDeactivated, ""Weight-based dist. deactivated."");
        address[] memory liquidityPools = addressProvider.allPools();
        uint256 length = liquidityPools.length;
        for (uint256 i = 0; i < length; i++) {
            _removeKeeperGauge(address(liquidityPools[i]));
        }
        weightBasedKeeperDistributionDeactivated = true;
        return true;
    }

    /**
     * @notice Checkpoints all gauges.
     * @dev This is mostly used upon inflation rate updates.
     * @return `true` if successful.
     */
    function checkpointAllGauges() external override returns (bool) {
        uint256 length = _keeperGauges.length();
        for (uint256 i = 0; i < length; i++) {
            IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();
        }
        address[] memory stakerVaults = addressProvider.allStakerVaults();
        for (uint256 i = 0; i < stakerVaults.length; i++) {
            IStakerVault(stakerVaults[i]).poolCheckpoint();
        }

        length = _ammGauges.length();
        for (uint256 i = 0; i < length; i++) {
            IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();
        }
        return true;
    }

    /**
     * @notice Prepare update of a keeper pool weight (with time delay enforced).
     * @param pool Pool to update the keeper weight for.
     * @param newPoolWeight New weight for the keeper inflation for the pool.
     * @return `true` if successful.
     */
    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(_keeperGauges.contains(pool), Error.INVALID_ARGUMENT);
        bytes32 key = _getKeeperGaugeKey(pool);
        _prepare(key, newPoolWeight);
        return true;
    }

    /**
     * @notice Execute update of keeper pool weight (with time delay enforced).
     * @param pool Pool to execute the keeper weight update for.
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New keeper pool weight.
     */
    function executeKeeperPoolWeight(address pool) external override returns (uint256) {
        bytes32 key = _getKeeperGaugeKey(pool);
        _executeKeeperPoolWeight(key, pool, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

    /**
     * @notice Prepare update of a batch of keeperGauge weights (with time delay enforced).
     * @dev Each entry in the pools array corresponds to an entry in the weights array.
     * @param pools Pools to update the keeper weight for.
     * @param weights New weights for the keeper inflation for the pools.
     * @return `true` if successful.
     */
    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)
        external
        override
        onlyGovernance
        returns (bool)
    {
        uint256 length = pools.length;
        require(length == weights.length, Error.INVALID_ARGUMENT);
        bytes32 key;
        for (uint256 i = 0; i < length; i++) {
            require(_keeperGauges.contains(pools[i]), Error.INVALID_ARGUMENT);
            key = _getKeeperGaugeKey(pools[i]);
            _prepare(key, weights[i]);
        }
        return true;
    }

    function whitelistGauge(address gauge) external onlyRole(Roles.CONTROLLER) {
        gauges[gauge] = true;
    }

    /**
     * @notice Execute weight updates for a batch of _keeperGauges.
     * @param pools Pools to execute the keeper weight updates for.
     * @return `true` if successful.
     */
    function batchExecuteKeeperPoolWeights(address[] calldata pools)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = pools.length;
        bytes32 key;
        for (uint256 i = 0; i < length; i++) {
            key = _getKeeperGaugeKey(pools[i]);
            _executeKeeperPoolWeight(key, pools[i], isInflationWeightManager(msg.sender));
        }
        return true;
    }

    function removeStakerVaultFromInflation(address stakerVault, address lpToken)
        external
        onlyRole(Roles.CONTROLLER)
    {
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        _prepare(key, 0);
        _executeLpPoolWeight(key, lpToken, stakerVault, true);
    }

    /**
     * @notice Prepare update of a lp pool weight (with time delay enforced).
     * @param lpToken LP token to update the weight for.
     * @param newPoolWeight New LP inflation weight.
     * @return `true` if successful.
     */
    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        address stakerVault = addressProvider.getStakerVault(lpToken);
        // Require both that gauge is registered and that pool is still in action
        require(gauges[IStakerVault(stakerVault).getLpGauge()], Error.GAUGE_DOES_NOT_EXIST);
        _ensurePoolExists(lpToken);
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        _prepare(key, newPoolWeight);
        return true;
    }

    /**
     * @notice Execute update of lp pool weight (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return New lp pool weight.
     */
    function executeLpPoolWeight(address lpToken) external override returns (uint256) {
        address stakerVault = addressProvider.getStakerVault(lpToken);
        // Require both that gauge is registered and that pool is still in action
        require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);
        _ensurePoolExists(lpToken);
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

    /**
     * @notice Prepare update of a batch of LP token weights (with time delay enforced).
     * @dev Each entry in the lpTokens array corresponds to an entry in the weights array.
     * @param lpTokens LpTokens to update the inflation weight for.
     * @param weights New weights for the inflation for the LpTokens.
     * @return `true` if successful.
     */
    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = lpTokens.length;
        require(length == weights.length, ""Invalid length of arguments"");
        bytes32 key;
        for (uint256 i = 0; i < length; i++) {
            address stakerVault = addressProvider.getStakerVault(lpTokens[i]);
            // Require both that gauge is registered and that pool is still in action
            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);
            _ensurePoolExists(lpTokens[i]);
            key = _getLpStakerVaultKey(stakerVault);
            _prepare(key, weights[i]);
        }
        return true;
    }

    /**
     * @notice Execute weight updates for a batch of LpTokens.
     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.
     * @param lpTokens LpTokens to execute the weight updates for.
     * @return `true` if successful.
     */
    function batchExecuteLpPoolWeights(address[] calldata lpTokens)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = lpTokens.length;
        for (uint256 i = 0; i < length; i++) {
            address lpToken = lpTokens[i];
            address stakerVault = addressProvider.getStakerVault(lpToken);
            // Require both that gauge is registered and that pool is still in action
            require(IStakerVault(stakerVault).getLpGauge() != address(0), Error.ADDRESS_NOT_FOUND);
            _ensurePoolExists(lpToken);
            bytes32 key = _getLpStakerVaultKey(stakerVault);
            _executeLpPoolWeight(key, lpToken, stakerVault, isInflationWeightManager(msg.sender));
        }
        return true;
    }

    /**
     * @notice Prepare an inflation weight update for an AMM token (with time delay enforced).
     * @param token AMM token to update the weight for.
     * @param newTokenWeight New AMM token inflation weight.
     * @return `true` if successful.
     */
    function prepareAmmTokenWeight(address token, uint256 newTokenWeight)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        require(_ammGauges.contains(token), ""amm gauge not found"");
        bytes32 key = _getAmmGaugeKey(token);
        _prepare(key, newTokenWeight);
        return true;
    }

    /**
     * @notice Execute update of lp pool weight (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New lp pool weight.
     */
    function executeAmmTokenWeight(address token) external override returns (uint256) {
        bytes32 key = _getAmmGaugeKey(token);
        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

    /**
     * @notice Registers a pool's strategy with the stakerVault of the pool where the strategy deposits.
     * @dev This simply avoids the strategy accumulating tokens in the deposit pool.
     * @param depositStakerVault StakerVault of the pool where the strategy deposits.
     * @param strategyPool The pool of the strategy to register (avoids blacklisting other addresses).
     * @return `true` if successful.
     */
    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)
        external
        onlyGovernance
        returns (bool)
    {
        IVault _vault = ILiquidityPool(strategyPool).getVault();
        IStakerVault(depositStakerVault).addStrategy(address(_vault.getStrategy()));
        return true;
    }

    /**
     * @notice Prepare update of a batch of AMM token weights (with time delay enforced).
     * @dev Each entry in the tokens array corresponds to an entry in the weights array.
     * @param tokens AMM tokens to update the inflation weight for.
     * @param weights New weights for the inflation for the AMM tokens.
     * @return `true` if successful.
     */
    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = tokens.length;
        bytes32 key;
        require(length == weights.length, ""Invalid length of arguments"");
        for (uint256 i = 0; i < length; i++) {
            require(_ammGauges.contains(tokens[i]), ""amm gauge not found"");
            key = _getAmmGaugeKey(tokens[i]);
            _prepare(key, weights[i]);
        }
        return true;
    }

    /**
     * @notice Execute weight updates for a batch of AMM tokens.
     * @dev If this is called by the INFLATION_MANAGER role address, no time delay is enforced.
     * @param tokens AMM tokens to execute the weight updates for.
     * @return `true` if successful.
     */
    function batchExecuteAmmTokenWeights(address[] calldata tokens)
        external
        override
        onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)
        returns (bool)
    {
        uint256 length = tokens.length;
        bool isWeightManager = isInflationWeightManager(msg.sender);
        bytes32 key;
        address token;
        for (uint256 i = 0; i < length; i++) {
            token = tokens[i];
            key = _getAmmGaugeKey(token);
            _executeAmmTokenWeight(token, key, isWeightManager);
        }
        return true;
    }

    /**
     * @notice Sets the KeeperGauge for a pool.
     * @dev Multiple pools can have the same KeeperGauge.
     * @param pool Address of pool to set the KeeperGauge for.
     * @param _keeperGauge Address of KeeperGauge.
     * @return `true` if successful.
     */
    function setKeeperGauge(address pool, address _keeperGauge)
        external
        override
        onlyGovernance
        returns (bool)
    {
        uint256 length = _keeperGauges.length();
        bool keeperGaugeExists = false;
        for (uint256 i = 0; i < length; i++) {
            if (address(_keeperGauges.valueAt(i)) == _keeperGauge) {
                keeperGaugeExists = true;
                break;
            }
        }
        // Check to make sure that once weight-based dist is deactivated, only one gauge can exist
        if (!keeperGaugeExists && weightBasedKeeperDistributionDeactivated && length >= 1) {
            return false;
        }
        (bool exists, address keeperGauge) = _keeperGauges.tryGet(pool);
        require(!exists || keeperGauge != _keeperGauge, Error.INVALID_ARGUMENT);

        if (exists && !IKeeperGauge(keeperGauge).killed()) {
            IKeeperGauge(keeperGauge).poolCheckpoint();
            IKeeperGauge(keeperGauge).kill();
        }
        _keeperGauges.set(pool, _keeperGauge);
        gauges[_keeperGauge] = true;
        return true;
    }

    function removeKeeperGauge(address pool) external onlyGovernance returns (bool) {
        _removeKeeperGauge(pool);
        return true;
    }

    /**
     * @notice Sets the AmmGauge for a particular AMM token.
     * @param token Address of the amm token.
     * @param _ammGauge Address of AmmGauge.
     * @return `true` if successful.
     */
    function setAmmGauge(address token, address _ammGauge)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(IAmmGauge(_ammGauge).isAmmToken(token), Error.ADDRESS_NOT_WHITELISTED);
        uint256 length = _ammGauges.length();
        for (uint256 i = 0; i < length; i++) {
            if (address(_ammGauges.valueAt(i)) == _ammGauge) {
                return false;
            }
        }
        if (_ammGauges.contains(token)) {
            address ammGauge = _ammGauges.get(token);
            IAmmGauge(ammGauge).poolCheckpoint();
            IAmmGauge(ammGauge).kill();
        }
        _ammGauges.set(token, _ammGauge);
        gauges[_ammGauge] = true;
        return true;
    }

    function removeAmmGauge(address token) external onlyGovernance returns (bool) {
        if (!_ammGauges.contains(token)) return false;
        address ammGauge = _ammGauges.get(token);
        bytes32 key = _getAmmGaugeKey(token);
        _prepare(key, 0);
        _executeAmmTokenWeight(token, key, true);
        IAmmGauge(ammGauge).kill();
        _ammGauges.remove(token);
        // Do not delete from the gauges map to allow claiming of remaining balances
        emit AmmGaugeDelisted(token, ammGauge);
        return true;
    }

    function addGaugeForVault(address lpToken) external override returns (bool) {
        IStakerVault _stakerVault = IStakerVault(msg.sender);
        require(addressProvider.isStakerVault(msg.sender, lpToken), Error.UNAUTHORIZED_ACCESS);
        address lpGauge = _stakerVault.getLpGauge();
        require(lpGauge != address(0), Error.GAUGE_DOES_NOT_EXIST);
        gauges[lpGauge] = true;
        return true;
    }

    function getAllAmmGauges() external view override returns (address[] memory) {
        return _ammGauges.valuesArray();
    }

    function getLpRateForStakerVault(address stakerVault) external view override returns (uint256) {
        if (minter == address(0) || totalLpPoolWeight == 0) {
            return 0;
        }

        bytes32 key = _getLpStakerVaultKey(stakerVault);
        uint256 lpInflationRate = Minter(minter).getLpInflationRate();
        uint256 poolInflationRate = (currentUInts256[key] * lpInflationRate) / totalLpPoolWeight;

        return poolInflationRate;
    }

    function getKeeperRateForPool(address pool) external view override returns (uint256) {
        if (minter == address(0)) {
            return 0;
        }
        uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();
        // After deactivation of weight based dist, KeeperGauge handles the splitting
        if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;
        if (totalKeeperPoolWeight == 0) return 0;
        bytes32 key = _getKeeperGaugeKey(pool);
        uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /
            totalKeeperPoolWeight;
        return poolInflationRate;
    }

    function getAmmRateForToken(address token) external view override returns (uint256) {
        if (minter == address(0) || totalAmmTokenWeight == 0) {
            return 0;
        }
        bytes32 key = _getAmmGaugeKey(token);
        uint256 ammInflationRate = Minter(minter).getAmmInflationRate();
        uint256 ammTokenInflationRate = (currentUInts256[key] * ammInflationRate) /
            totalAmmTokenWeight;
        return ammTokenInflationRate;
    }

    //TOOD: See if this is still needed somewhere
    function getKeeperWeightForPool(address pool) external view override returns (uint256) {
        bytes32 key = _getKeeperGaugeKey(pool);
        return currentUInts256[key];
    }

    function getAmmWeightForToken(address token) external view override returns (uint256) {
        bytes32 key = _getAmmGaugeKey(token);
        return currentUInts256[key];
    }

    function getLpPoolWeight(address lpToken) external view override returns (uint256) {
        address stakerVault = addressProvider.getStakerVault(lpToken);
        bytes32 key = _getLpStakerVaultKey(stakerVault);
        return currentUInts256[key];
    }

    function getKeeperGaugeForPool(address pool) external view override returns (address) {
        (, address keeperGauge) = _keeperGauges.tryGet(pool);
        return keeperGauge;
    }

    function getAmmGaugeForToken(address token) external view override returns (address) {
        (, address ammGauge) = _ammGauges.tryGet(token);
        return ammGauge;
    }

    /**
     * @notice Check if an account is governance proxy.
     * @param account Address to check.
     * @return `true` if account is governance proxy.
     */
    function isInflationWeightManager(address account) public view override returns (bool) {
        return _roleManager().hasRole(Roles.INFLATION_MANAGER, account);
    }

    function _executeKeeperPoolWeight(
        bytes32 key,
        address pool,
        bool isWeightManager
    ) internal returns (bool) {
        IKeeperGauge(_keeperGauges.get(pool)).poolCheckpoint();
        totalKeeperPoolWeight = totalKeeperPoolWeight - currentUInts256[key] + pendingUInts256[key];
        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;
        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);
        emit NewKeeperWeight(pool, currentUInts256[key]);
        return true;
    }

    function _executeLpPoolWeight(
        bytes32 key,
        address lpToken,
        address stakerVault,
        bool isWeightManager
    ) internal returns (bool) {
        IStakerVault(stakerVault).poolCheckpoint();
        totalLpPoolWeight = totalLpPoolWeight - currentUInts256[key] + pendingUInts256[key];
        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;
        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);
        emit NewLpWeight(lpToken, currentUInts256[key]);
        return true;
    }

    function _executeAmmTokenWeight(
        address token,
        bytes32 key,
        bool isWeightManager
    ) internal returns (bool) {
        IAmmGauge(_ammGauges.get(token)).poolCheckpoint();
        totalAmmTokenWeight = totalAmmTokenWeight - currentUInts256[key] + pendingUInts256[key];
        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;
        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);
        // Do pool checkpoint to update the pool integrals
        emit NewAmmTokenWeight(token, currentUInts256[key]);
        return true;
    }

    function _removeKeeperGauge(address pool) internal {
        address keeperGauge = _keeperGauges.get(pool);
        bytes32 key = _getKeeperGaugeKey(pool);
        _prepare(key, 0);
        _executeKeeperPoolWeight(key, pool, true);
        _keeperGauges.remove(pool);
        IKeeperGauge(keeperGauge).kill();
        // Do not delete from the gauges map to allow claiming of remaining balances
        emit KeeperGaugeDelisted(pool, keeperGauge);
    }

    function _ensurePoolExists(address lpToken) internal view {
        require(
            address(addressProvider.safeGetPoolForToken(lpToken)) != address(0),
            Error.ADDRESS_NOT_FOUND
        );
    }

    function _getKeeperGaugeKey(address pool) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_KEEPER_WEIGHT_KEY, pool));
    }

    function _getAmmGaugeKey(address token) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_AMM_WEIGHT_KEY, token));
    }

    function _getLpStakerVaultKey(address vault) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_LP_WEIGHT_KEY, vault));
    }
}",5861
RealWorld_TA_112_BaseHandler_RealWorld_20240815100022.log,112,BaseHandler,26905,1421,28326,89.0,0.162945,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../../../interfaces/actions/topup/ITopUpHandler.sol"";

abstract contract BaseHandler is ITopUpHandler {
    /// @dev Handlers will be called through delegatecall from the topup action
    /// so we add a gap to ensure that the children contracts do not
    /// overwrite the topup action storage
    uint256[100] private __gap;
}",99
RealWorld_TA_112_DecimalScale_RealWorld_20240815122933.log,112,DecimalScale,29651,1543,31194,131.0,0.179115,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

library DecimalScale {
    uint8 internal constant DECIMALS = 18; // 18 decimal places

    function scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {
        if (decimals == DECIMALS) {
            return value;
        } else if (decimals > DECIMALS) {
            return value / 10**(decimals - DECIMALS);
        } else {
            return value * 10**(DECIMALS - decimals);
        }
    }
}",129
RealWorld_TA_112_IAction_RealWorld_20240815133421.log,112,IAction,32742,1628,34370,141.0,0.19627,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IAction {
    /**
     * @return the total amount of ETH (in wei) required to cover gas
     */
    function getEthRequiredForGas(address payer) external view returns (uint256);

    function addUsableToken(address token) external returns (bool);

    function getUsableTokens() external view returns (address[] memory);

    function isUsable(address token) external view returns (bool);

    function getActionFee() external view returns (uint256);

    function getFeeHandler() external view returns (address);

    function executeActionFee() external returns (uint256);

    function executeSwapperSlippage() external returns (uint256);

    function executeFeeHandler() external returns (address);
}",173
RealWorld_TA_112_AmmConvexGauge_RealWorld_20240815113030.log,112,AmmConvexGauge,210648,5370,216018,178.0,1.16064,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";

import ""../../interfaces/vendor/IBooster.sol"";
import ""../../interfaces/vendor/IRewardStaking.sol"";
import ""../../interfaces/tokenomics/IAmmConvexGauge.sol"";
import ""./AmmGauge.sol"";
import ""../utils/CvxMintAmount.sol"";

contract AmmConvexGauge is IAmmConvexGauge, AmmGauge, CvxMintAmount {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    address public immutable cvx;
    address public immutable crv;
    address public immutable booster;
    address public inflationRecipient;

    uint256 public immutable bkdPoolPID; // bkd pool id on Convex
    IRewardStaking public immutable crvRewardsContract; // Staking contract for bkd convex deposit token

    // Additional integrals etc. for crv and cvx rewards
    uint256 public crvStakedIntegral;
    uint256 public cvxStakedIntegral;
    mapping(address => uint256) public perUserCrvStakedIntegral;
    mapping(address => uint256) public perUserCvxStakedIntegral;
    mapping(address => uint256) public perUserShareCrv;
    mapping(address => uint256) public perUserShareCvx;

    uint256 private _crvLastEarned;
    uint256 private _cvxLastEarned;
    uint256 private _preClaimRewardsCrvEarned;

    event RewardClaimed(
        address indexed beneficiary,
        uint256 bkdAmount,
        uint256 crvAmount,
        uint256 cvxAmount
    );

    constructor(
        IController _controller,
        address _ammToken,
        uint256 _bkdPoolPID,
        address _crv,
        address _cvx,
        address _booster
    ) AmmGauge(_controller, _ammToken) {
        cvx = _cvx;
        crv = _crv;
        booster = _booster;
        bkdPoolPID = _bkdPoolPID;
        (, , , address _crvRewards, , ) = IBooster(booster).poolInfo(_bkdPoolPID);
        crvRewardsContract = IRewardStaking(_crvRewards);

        // approve for Convex deposit
        IERC20(ammToken).safeApprove(booster, type(uint256).max);
    }

    function claimRewards(address beneficiary) external virtual override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        uint256 crvAmount = perUserShareCrv[beneficiary];
        uint256 cvxAmount = perUserShareCvx[beneficiary];
        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0;
        crvRewardsContract.getReward();
        _crvLastEarned = 0;
        _cvxLastEarned = 0;
        perUserShare[beneficiary] = 0;
        perUserShareCrv[beneficiary] = 0;
        perUserShareCvx[beneficiary] = 0;
        IController(controller).inflationManager().mintRewards(beneficiary, amount);
        IERC20(crv).safeTransfer(beneficiary, crvAmount);
        IERC20(cvx).safeTransfer(beneficiary, cvxAmount);
        _preClaimRewardsCrvEarned = IERC20(crv).balanceOf(address(this));
        emit RewardClaimed(beneficiary, amount, crvAmount, cvxAmount);
        return amount;
    }

    function setInflationRecipient(address recipient) external override onlyGovernance {
        require(inflationRecipient == address(0), Error.ADDRESS_ALREADY_SET);
        poolCheckpoint();
        inflationRecipient = recipient;
    }

    function deactivateInflationRecipient() external override onlyGovernance {
        require(inflationRecipient != address(0), Error.ADDRESS_NOT_FOUND);
        poolCheckpoint();
        inflationRecipient = address(0);
    }

    function claimableRewards(address user) external view virtual override returns (uint256) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        if (user == inflationRecipient) {
            return
                perUserShare[inflationRecipient] +
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed;
        }
        if (!killed && totalStaked > 0) {
            ammStakedIntegral_ +=
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed.scaledDiv(totalStaked);
        }
        return
            perUserShare[user] +
            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
    }

    function allClaimableRewards(address user) external view override returns (uint256[3] memory) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        uint256 crvStakedIntegral_ = crvStakedIntegral;
        uint256 cvxStakedIntegral_ = cvxStakedIntegral;
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) -
            _preClaimRewardsCrvEarned +
            crvRewardsContract.earned(address(this));
        uint256 cvxEarned = getCvxMintAmount(crvEarned);

        if (!killed && totalStaked > 0) {
            if (inflationRecipient == address(0)) {
                ammStakedIntegral_ +=
                    (IController(controller).inflationManager().getAmmRateForToken(ammToken)) *
                    (timeElapsed).scaledDiv(totalStaked);
            }
            crvStakedIntegral_ += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);
            cvxStakedIntegral_ += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);
        }
        uint256 bkdRewards;
        if (user == inflationRecipient) {
            bkdRewards =
                perUserShare[user] +
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed;
        } else {
            bkdRewards =
                perUserShare[user] +
                balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
        }
        uint256 crvRewards = perUserShareCrv[user] +
            balances[user].scaledMul(crvStakedIntegral_ - perUserCrvStakedIntegral[user]);
        uint256 cvxRewards = perUserShareCvx[user] +
            balances[user].scaledMul(cvxStakedIntegral_ - perUserCvxStakedIntegral[user]);
        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];
        return allRewards;
    }

    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);

        _userCheckpoint(account);

        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);
        IBooster(booster).deposit(bkdPoolPID, amount, true);
        balances[account] += amount;
        totalStaked += amount;
        emit AmmStaked(account, ammToken, amount);
        return true;
    }

    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        _userCheckpoint(msg.sender);

        crvRewardsContract.withdrawAndUnwrap(amount, false);
        IERC20(ammToken).safeTransfer(dst, amount);
        balances[msg.sender] -= amount;
        totalStaked -= amount;
        emit AmmUnstaked(msg.sender, ammToken, amount);
        return true;
    }

    function poolCheckpoint() public virtual override returns (bool) {
        if (killed) {
            return false;
        }
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        uint256 currentRate = IController(controller).inflationManager().getAmmRateForToken(
            ammToken
        );
        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) -
            _preClaimRewardsCrvEarned +
            crvRewardsContract.earned(address(this));
        uint256 cvxEarned = getCvxMintAmount(crvEarned);

        // Update the integral of total token supply for the pool
        if (totalStaked > 0) {
            if (inflationRecipient == address(0)) {
                ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);
            } else {
                perUserShare[inflationRecipient] += currentRate * timeElapsed;
            }
            crvStakedIntegral += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);
            cvxStakedIntegral += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);
        }
        _crvLastEarned = crvEarned;
        _cvxLastEarned = cvxEarned;
        ammLastUpdated = uint48(block.timestamp);
        return true;
    }

    function _userCheckpoint(address user) internal virtual override returns (bool) {
        poolCheckpoint();
        perUserShare[user] += balances[user].scaledMul(
            ammStakedIntegral - perUserStakedIntegral[user]
        );
        perUserShareCrv[user] += balances[user].scaledMul(
            crvStakedIntegral - perUserCrvStakedIntegral[user]
        );
        perUserShareCvx[user] += balances[user].scaledMul(
            cvxStakedIntegral - perUserCvxStakedIntegral[user]
        );
        perUserStakedIntegral[user] = ammStakedIntegral;
        perUserCrvStakedIntegral[user] = crvStakedIntegral;
        perUserCvxStakedIntegral[user] = cvxStakedIntegral;
        return true;
    }
}",2322
RealWorld_TA_112_EnumerableMapping_RealWorld_20240815123401.log,112,EnumerableMapping,254129,1428,255557,181.0,1.299205,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

library EnumerableMapping {
    using EnumerableSet for EnumerableSet.Bytes32Set;

    // Code take from contracts/utils/structs/EnumerableMap.sol
    // because the helper functions are private

    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct Map {
        // Storage of keys
        EnumerableSet.Bytes32Set _keys;
        mapping(bytes32 => bytes32) _values;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(
        Map storage map,
        bytes32 key,
        bytes32 value
    ) private returns (bool) {
        map._values[key] = value;
        return map._keys.add(key);
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        delete map._values[key];
        return map._keys.remove(key);
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key) private view returns (bool) {
        return map._keys.contains(key);
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._keys.length();
    }

    /**
     * @dev Returns the key-value pair stored at position `index` in the map. O(1).
     *
     * Note that there are no guarantees on the ordering of entries inside the
     * array, and it may change when more entries are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
        bytes32 key = map._keys.at(index);
        return (key, map._values[key]);
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     */
    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {
        bytes32 value = map._values[key];
        if (value == bytes32(0)) {
            return (_contains(map, key), bytes32(0));
        } else {
            return (true, value);
        }
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        bytes32 value = map._values[key];
        require(value != 0 || _contains(map, key), ""EnumerableMap: nonexistent key"");
        return value;
    }

    // AddressToAddressMap

    struct AddressToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        AddressToAddressMap storage map,
        address key,
        address value
    ) internal returns (bool) {
        return _set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {
        return _remove(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {
        return _contains(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(AddressToAddressMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressToAddressMap storage map, uint256 index)
        internal
        view
        returns (address, address)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (address(uint160(uint256(key))), address(uint160(uint256(value))));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(AddressToAddressMap storage map, address key)
        internal
        view
        returns (bool, address)
    {
        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(uint256(uint160(key))));
        return (success, address(uint160(uint256(value))));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(AddressToAddressMap storage map, address key) internal view returns (address) {
        return address(uint160(uint256(_get(map._inner, bytes32(uint256(uint160(key)))))));
    }

    // AddressToUintMap

    struct AddressToUintMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        AddressToUintMap storage map,
        address key,
        uint256 value
    ) internal returns (bool) {
        return _set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(AddressToUintMap storage map, address key) internal returns (bool) {
        return _remove(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {
        return _contains(map._inner, bytes32(uint256(uint160(key))));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(AddressToUintMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressToUintMap storage map, uint256 index)
        internal
        view
        returns (address, uint256)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (address(uint160(uint256(key))), uint256(value));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(AddressToUintMap storage map, address key)
        internal
        view
        returns (bool, uint256)
    {
        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(uint256(uint160(key))));
        return (success, uint256(value));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {
        return uint256(_get(map._inner, bytes32(uint256(uint160(key)))));
    }

    // Bytes32ToUIntMap

    struct Bytes32ToUIntMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        Bytes32ToUIntMap storage map,
        bytes32 key,
        uint256 value
    ) internal returns (bool) {
        return _set(map._inner, key, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(Bytes32ToUIntMap storage map, bytes32 key) internal returns (bool) {
        return _remove(map._inner, key);
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(Bytes32ToUIntMap storage map, bytes32 key) internal view returns (bool) {
        return _contains(map._inner, key);
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(Bytes32ToUIntMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32ToUIntMap storage map, uint256 index)
        internal
        view
        returns (bytes32, uint256)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (key, uint256(value));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(Bytes32ToUIntMap storage map, bytes32 key)
        internal
        view
        returns (bool, uint256)
    {
        (bool success, bytes32 value) = _tryGet(map._inner, key);
        return (success, uint256(value));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(Bytes32ToUIntMap storage map, bytes32 key) internal view returns (uint256) {
        return uint256(_get(map._inner, key));
    }
}",2807
RealWorld_TA_112_StakerVault_RealWorld_20240815080350.log,112,StakerVault,282313,5211,287524,150.0,1.515785,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../libraries/ScaledMath.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/Errors.sol"";
import ""../libraries/AddressProviderHelpers.sol"";

import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/tokenomics/IRewardsGauge.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../interfaces/tokenomics/ILpGauge.sol"";
import ""../interfaces/IERC20Full.sol"";

import ""./utils/Preparable.sol"";
import ""./Controller.sol"";
import ""./pool/LiquidityPool.sol"";
import ""./access/Authorization.sol"";
import ""./utils/Pausable.sol"";

/**
 * @notice This contract handles staked tokens from Backd pools
 * However, not that this is NOT an ERC-20 compliant contract and these
 * tokens should never be integrated with any protocol assuming ERC-20 compliant
 * tokens
 * @dev When paused, allows only withdraw/unstake
 */
contract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {
    using AddressProviderHelpers for IAddressProvider;
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;

    bytes32 internal constant _LP_GAUGE = ""lpGauge"";

    IController public immutable controller;

    address public token;

    mapping(address => uint256) public balances;
    mapping(address => uint256) public actionLockedBalances;

    mapping(address => mapping(address => uint256)) internal _allowances;

    // All the data fields required for the staking tracking
    uint256 private _poolTotalStaked;

    mapping(address => bool) public strategies;
    uint256 public strategiesTotalStaked;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        controller = _controller;
    }

    function initialize(address _token) external override initializer {
        token = _token;
    }

    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {
        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);
        _setConfig(_LP_GAUGE, _lpGauge);
        controller.inflationManager().addGaugeForVault(token);
        return true;
    }

    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {
        _prepare(_LP_GAUGE, _lpGauge);
        return true;
    }

    function executeLpGauge() external override onlyGovernance returns (bool) {
        _executeAddress(_LP_GAUGE);
        controller.inflationManager().addGaugeForVault(token);
        return true;
    }

    /**
     * @notice Registers an address as a strategy to be excluded from token accumulation.
     * @dev This should be used is a strategy deposits into a stakerVault and should not get gov. tokens.
     * @return `true` if success.
     */
    function addStrategy(address strategy) external override returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        strategies[strategy] = true;
        return true;
    }

    /**
     * @notice Transfer staked tokens to an account.
     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.
     * @param account Address to transfer to.
     * @param amount Amount to transfer.
     * @return `true` if success.
     */
    function transfer(address account, uint256 amount) external override notPaused returns (bool) {
        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        pool.handleLpTokenTransfer(msg.sender, account, amount);

        balances[msg.sender] -= amount;
        balances[account] += amount;

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(msg.sender);
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        emit Transfer(msg.sender, account, amount);
        return true;
    }

    /**
     * @notice Transfer staked tokens from src to dst.
     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.
     * @param src Address to transfer from.
     * @param dst Address to transfer to.
     * @param amount Amount to transfer.
     * @return `true` if success.
     */
    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external override notPaused returns (bool) {
        /* Do not allow self transfers */
        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);

        address spender = msg.sender;

        /* Get the allowance, infinite for the account owner */
        uint256 startingAllowance = 0;
        if (spender == src) {
            startingAllowance = type(uint256).max;
        } else {
            startingAllowance = _allowances[src][spender];
        }
        require(startingAllowance >= amount, Error.INSUFFICIENT_BALANCE);

        uint256 srcTokens = balances[src];
        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
            ILpGauge(lpGauge).userCheckpoint(dst);
        }
        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        pool.handleLpTokenTransfer(src, dst, amount);

        uint256 allowanceNew = startingAllowance - amount;
        uint256 srcTokensNew = srcTokens - amount;
        uint256 dstTokensNew = balances[dst] + amount;

        /* Update token balances */
        balances[src] = srcTokensNew;
        balances[dst] = dstTokensNew;

        /* Update allowance if necessary */
        if (startingAllowance != type(uint256).max) {
            _allowances[src][spender] = allowanceNew;
        }
        emit Transfer(src, dst, amount);
        return true;
    }

    /**
     * @notice Approve staked tokens for spender.
     * @param spender Address to approve tokens for.
     * @param amount Amount to approve.
     * @return `true` if success.
     */
    function approve(address spender, uint256 amount) external override notPaused returns (bool) {
        address src = msg.sender;
        _allowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.
     * @param account Address that registered the action.
     * @param amount Amount staked by the action.
     * @return `true` if success.
     */
    function increaseActionLockedBalance(address account, uint256 amount)
        external
        override
        returns (bool)
    {
        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }
        actionLockedBalances[account] += amount;
        return true;
    }

    /**
     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.
     * @param account Address that registered the action.
     * @param amount Amount executed/reset by the action.
     * @return `true` if success.
     */
    function decreaseActionLockedBalance(address account, uint256 amount)
        external
        override
        returns (bool)
    {
        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }
        if (actionLockedBalances[account] > amount) {
            actionLockedBalances[account] -= amount;
        } else {
            actionLockedBalances[account] = 0;
        }
        return true;
    }

    function poolCheckpoint() external override returns (bool) {
        if (currentAddresses[_LP_GAUGE] != address(0)) {
            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();
        }
        return false;
    }

    function getLpGauge() external view override returns (address) {
        return currentAddresses[_LP_GAUGE];
    }

    function isStrategy(address user) external view override returns (bool) {
        return strategies[user];
    }

    /**
     * @notice Get the total amount of tokens that are staked by actions
     * @return Total amount staked by actions
     */
    function getStakedByActions() external view override returns (uint256) {
        address[] memory actions = controller.addressProvider().allActions();
        uint256 total;
        for (uint256 i = 0; i < actions.length; i++) {
            total += balances[actions[i]];
        }
        return total;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function balanceOf(address account) external view override returns (uint256) {
        return balances[account];
    }

    function getPoolTotalStaked() external view override returns (uint256) {
        return _poolTotalStaked;
    }

    /**
     * @notice Returns the total balance in the staker vault, including that locked in positions.
     * @param account Account to query balance for.
     * @return Total balance in staker vault for account.
     */
    function stakedAndActionLockedBalanceOf(address account)
        external
        view
        override
        returns (uint256)
    {
        return balances[account] + actionLockedBalances[account];
    }

    function actionLockedBalanceOf(address account) external view override returns (uint256) {
        return actionLockedBalances[account];
    }

    function decimals() external view returns (uint8) {
        return IERC20Full(token).decimals();
    }

    function getToken() external view override returns (address) {
        return token;
    }

    function unstake(uint256 amount) public override returns (bool) {
        return unstakeFor(msg.sender, msg.sender, amount);
    }

    /**
     * @notice Stake an amount of vault tokens.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stake(uint256 amount) public override returns (bool) {
        return stakeFor(msg.sender, amount);
    }

    /**
     * @notice Stake amount of vault token on behalf of another account.
     * @param account Account for which tokens will be staked.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {
        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        uint256 oldBal = IERC20(token).balanceOf(address(this));

        if (msg.sender != account) {
            ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
            pool.handleLpTokenTransfer(msg.sender, account, amount);
        }

        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;
        require(staked == amount, Error.INVALID_AMOUNT);
        balances[account] += staked;

        if (strategies[account]) {
            strategiesTotalStaked += staked;
        } else {
            _poolTotalStaked += staked;
        }
        emit Staked(account, amount);
        return true;
    }

    /**
     * @notice Unstake tokens on behalf of another account.
     * @dev Needs to be approved.
     * @param src Account for which tokens will be unstaked.
     * @param dst Account receiving the tokens.
     * @param amount Amount of token to unstake/receive.
     * @return `true` if success.
     */
    function unstakeFor(
        address src,
        address dst,
        uint256 amount
    ) public override returns (bool) {
        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);
        uint256 allowance_ = _allowances[src][msg.sender];
        require(
            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,
            Error.UNAUTHORIZED_ACCESS
        );
        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);
        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
        }
        uint256 oldBal = IERC20(token).balanceOf(address(this));

        if (src != dst) {
            pool.handleLpTokenTransfer(src, dst, amount);
        }

        IERC20(token).safeTransfer(dst, amount);

        uint256 unstaked = oldBal - IERC20(token).balanceOf(address(this));

        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {
            // update allowance
            _allowances[src][msg.sender] -= unstaked;
        }
        balances[src] -= unstaked;

        if (strategies[src]) {
            strategiesTotalStaked -= unstaked;
        } else {
            _poolTotalStaked -= unstaked;
        }
        emit Unstaked(src, amount);
        return true;
    }

    function _isAuthorizedToPause(address account) internal view override returns (bool) {
        return _roleManager().hasRole(Roles.GOVERNANCE, account);
    }
}",3192
RealWorld_TA_112_IDelegation_RealWorld_20240815143354.log,112,IDelegation,24386,1992,26378,156.0,0.16177,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IDelegation {
    function clearDelegate(bytes32 _id) external;

    function setDelegate(bytes32 _id, address _delegate) external;

    function delegation(address _address, bytes32 _id) external view returns (address);
}",66
RealWorld_TA_112_MockEthStrategy_RealWorld_20240815093511.log,112,MockEthStrategy,85507,4293,89800,117.0,0.513395,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../access/Authorization.sol"";
import ""../../interfaces/IStrategy.sol"";
import ""../../interfaces/IStakerVault.sol"";

/**
 * MockStrategy for testing.
 * This strategy does not do anything with funds it receives.
 */
contract MockEthStrategy is IStrategy, Authorization {
    using SafeERC20 for IERC20;

    address internal _underlying = address(0);

    address payable internal _vault;

    address public override strategist;

    modifier onlyVault() {
        require(msg.sender == _vault, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IRoleManager roleManager) Authorization(roleManager) {
        strategist = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);
    }

    receive() external payable {}

    function setVault(address payable newVault) external onlyGovernance returns (bool) {
        require(_vault == address(0), ""Vault can only be set once"");
        require(newVault != address(0), ""Vault cannot be zero address"");
        _vault = newVault;
        return true;
    }

    // Deposits token (same as want() returns) into a smart contact specified by the Strategy.
    function deposit() external payable override onlyVault returns (bool) {
        // Does nothing in mock
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdraw(uint256 amount) external override onlyVault returns (bool) {
        uint256 currentBalance = address(this).balance;
        if (amount <= currentBalance) payable(address(_vault)).transfer(amount);
        else payable(address(_vault)).transfer(currentBalance);
        return true;
    }

    // Controller | Vault role - withdraw should always return to Vault
    function withdrawAll() external virtual override onlyVault returns (uint256) {
        uint256 currentBalance = address(this).balance;
        payable(address(_vault)).transfer(currentBalance);
        return currentBalance;
    }

    function withdrawDust(address coin) external returns (bool) {
        require(coin != address(_underlying), ""Unauthorized withdrawal"");
        uint256 currentBalance = address(this).balance;
        require(currentBalance > 0, ""Invalid amount to withdraw"");
        payable(address(_vault)).transfer(currentBalance);
        return true;
    }

    // For testing
    function burnETH(uint256 amount) external {
        uint256 currentBalance = address(this).balance;
        require(currentBalance >= amount, Error.INSUFFICIENT_BALANCE);
        payable(address(0)).transfer(amount);
    }

    function stakeInVault(address lpToken, address stakerVault) external {
        IERC20(lpToken).approve(stakerVault, 4e18);
        IStakerVault(stakerVault).stake(4e18);
    }

    function name() external view override returns (string memory) {
        return ""MockStrategy"";
    }

    function want() external view returns (address) {
        return _underlying;
    }

    function balance() external view override returns (uint256) {
        return address(this).balance;
    }

    function shutdown() external pure override returns (bool) {
        return true;
    }

    function hasPendingFunds() external pure override returns (bool) {
        return false;
    }

    function harvestable() external pure override returns (uint256) {
        return 0;
    }

    function harvest() external pure override returns (uint256) {
        return 0;
    }
}",786
RealWorld_TA_112_Minter_RealWorld_20240815114058.log,112,Minter,179110,4841,183951,167.0,0.99237,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/IBkdToken.sol"";

import ""../../libraries/Errors.sol"";
import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""./BkdToken.sol"";
import ""../access/Authorization.sol"";

contract Minter is Authorization, ReentrancyGuard {
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;

    // Lp Rates
    uint256 public immutable initialAnnualInflationRateLp;
    uint256 public immutable annualInflationDecayLp;
    uint256 public currentInflationAmountLp;

    // Keeper Rates
    uint256 public immutable initialPeriodKeeperInflation;
    uint256 public immutable initialAnnualInflationRateKeeper;
    uint256 public immutable annualInflationDecayKeeper;
    uint256 public currentInflationAmountKeeper;

    // AMM Rates
    uint256 public immutable initialPeriodAmmInflation;
    uint256 public immutable initialAnnualInflationRateAmm;
    uint256 public immutable annualInflationDecayAmm;
    uint256 public currentInflationAmountAmm;

    bool public initialPeriodEnded;

    // Non-inflation rates
    uint256 public immutable nonInflationDistribution;
    uint256 public issuedNonInflationSupply;

    uint256 public lastInflationDecay;
    uint256 public currentTotalInflation;

    // Used for final safety check to ensure inflation is not exceeded
    uint256 public totalAvailableToNow;
    uint256 public totalMintedToNow;
    uint256 public lastEvent;

    IController public immutable controller;
    BkdToken public token;

    event TokensMinted(address beneficiary, uint256 amount);

    constructor(
        uint256 _annualInflationRateLp,
        uint256 _annualInflationRateKeeper,
        uint256 _annualInflationRateAmm,
        uint256 _annualInflationDecayLp,
        uint256 _annualInflationDecayKeeper,
        uint256 _annualInflationDecayAmm,
        uint256 _initialPeriodKeeperInflation,
        uint256 _initialPeriodAmmInflation,
        uint256 _nonInflationDistribution,
        IController _controller
    ) Authorization(_controller.addressProvider().getRoleManager()) {
        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);
        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);
        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);
        initialAnnualInflationRateLp = _annualInflationRateLp;
        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;
        initialAnnualInflationRateAmm = _annualInflationRateAmm;

        annualInflationDecayLp = _annualInflationDecayLp;
        annualInflationDecayKeeper = _annualInflationDecayKeeper;
        annualInflationDecayAmm = _annualInflationDecayAmm;

        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;
        initialPeriodAmmInflation = _initialPeriodAmmInflation;

        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;
        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;
        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;

        currentTotalInflation =
            currentInflationAmountLp +
            currentInflationAmountKeeper +
            currentInflationAmountAmm;

        nonInflationDistribution = _nonInflationDistribution;
        controller = _controller;
    }

    function setToken(address _token) external onlyGovernance {
        require(address(token) == address(0), ""Token already set!"");
        token = BkdToken(_token);
    }

    function startInflation() external onlyGovernance {
        require(lastEvent == 0, ""Inflation has already started."");
        lastEvent = block.timestamp;
        lastInflationDecay = block.timestamp;
    }

    /**
     * @notice Update the inflation rate according to the piecewise linear schedule.
     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.
     * @return `true` if successful.
     */
    function executeInflationRateUpdate() external returns (bool) {
        return _executeInflationRateUpdate();
    }

    /**
     * @notice Mints BKD tokens to a specified address.
     * @dev Can only be called by the controller.
     * @param beneficiary Address to mint tokens for.
     * @param amount Amount of tokens to mint.
     * @return `true` if successful.
     */
    function mint(address beneficiary, uint256 amount) external nonReentrant returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        if (lastEvent == 0) return false;
        return _mint(beneficiary, amount);
    }

    /**
     * @notice Mint tokens that are not part of the inflation schedule.
     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.
     * @param beneficiary Address to mint tokens for.
     * @param amount Amount of tokens to mint.
     * @return `true` if successful.
     */
    function mintNonInflationTokens(address beneficiary, uint256 amount)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            issuedNonInflationSupply + amount <= nonInflationDistribution,
            ""Maximum non-inflation amount exceeded.""
        );
        issuedNonInflationSupply += amount;
        token.mint(beneficiary, amount);
        emit TokensMinted(beneficiary, amount);
        return true;
    }

    /**
     * @notice Supplies the inflation rate for LPs per unit of time (seconds).
     * @return LP inflation rate.
     */
    function getLpInflationRate() external view returns (uint256) {
        if (lastEvent == 0) return 0;
        return currentInflationAmountLp;
    }

    /**
     * @notice Supplies the inflation rate for keepers per unit of time (seconds).
     * @return keeper inflation rate.
     */
    function getKeeperInflationRate() external view returns (uint256) {
        if (lastEvent == 0) return 0;
        return currentInflationAmountKeeper;
    }

    /**
     * @notice Supplies the inflation rate for LPs on AMMs per unit of time (seconds).
     * @return AMM inflation rate.
     */
    function getAmmInflationRate() external view returns (uint256) {
        if (lastEvent == 0) return 0;
        return currentInflationAmountAmm;
    }

    function _executeInflationRateUpdate() internal returns (bool) {
        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));
        lastEvent = block.timestamp;
        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {
            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);
            if (initialPeriodEnded) {
                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(
                    annualInflationDecayKeeper
                );
                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(
                    annualInflationDecayAmm
                );
            } else {
                currentInflationAmountKeeper =
                    initialAnnualInflationRateKeeper /
                    _INFLATION_DECAY_PERIOD;

                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;
                initialPeriodEnded = true;
            }
            currentTotalInflation =
                currentInflationAmountLp +
                currentInflationAmountKeeper +
                currentInflationAmountAmm;
            controller.inflationManager().checkpointAllGauges();
            lastInflationDecay = block.timestamp;
        }
        return true;
    }

    function _mint(address beneficiary, uint256 amount) internal returns (bool) {
        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);
        uint256 newTotalMintedToNow = totalMintedToNow + amount;
        require(newTotalMintedToNow <= totalAvailableToNow, ""Mintable amount exceeded"");
        totalMintedToNow = newTotalMintedToNow;
        lastEvent = block.timestamp;
        token.mint(beneficiary, amount);
        _executeInflationRateUpdate();
        emit TokensMinted(beneficiary, amount);
        return true;
    }
}",1932
RealWorld_TA_112_CTokenRegistry_RealWorld_20240815095642.log,112,CTokenRegistry,79872,3329,83201,111.0,0.46594,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../../../interfaces/vendor/CToken.sol"";
import ""../../../../interfaces/vendor/Comptroller.sol"";
import ""../../../../libraries/Errors.sol"";

contract CTokenRegistry {
    Comptroller public immutable comptroller;

    address public constant COMPTROLLER_MAINNET_ADDRESS =
        address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);

    mapping(address => address) internal _underlyingToCToken;

    constructor(address comptrollerAddress) {
        comptroller = Comptroller(comptrollerAddress);
        _updateCTokenMapping();
    }

    /**
     * @notice Tries to read the CToken contract address for a given underlying token address
     * If not found, tries to fetch it from the Comptroller contract and fails if
     * cannot find it in the comptroller either
     */
    function fetchCToken(address underlying) external returns (CToken) {
        CToken ctoken = getCToken(underlying, false);
        if (address(ctoken) != address(0)) {
            return CToken(ctoken);
        }

        _updateCTokenMapping();
        return getCToken(underlying, true);
    }

    /**
     * @notice Reads the CToken contract address for a given underlying token address
     * or fails if not found
     */
    function getCToken(address underlying) external view returns (CToken) {
        return getCToken(underlying, true);
    }

    /**
     * @notice Reads the CToken contract address for a given underlying token address
     * If `ensureExists` is `true`, fails if not found, otherwise returns address 0
     */
    function getCToken(address underlying, bool ensureExists) public view returns (CToken) {
        CToken ctoken = CToken(_underlyingToCToken[underlying]);
        if (ensureExists && (address(ctoken) == address(0) || !_isCTokenUsable(ctoken))) {
            revert(Error.UNDERLYING_NOT_SUPPORTED);
        }
        return ctoken;
    }

    /**
     * @dev Updates the CToken mapping by fetching information from the Comptroller contract
     */
    function _updateCTokenMapping() internal {
        CToken[] memory ctokens = comptroller.getAllMarkets();
        for (uint256 i = 0; i < ctokens.length; i++) {
            CToken ctoken = ctokens[i];
            if (!_isCTokenUsable(ctoken)) {
                continue;
            }
            if (
                keccak256(abi.encodePacked(ctoken.symbol())) == keccak256(abi.encodePacked(""cETH""))
            ) {
                _underlyingToCToken[address(0)] = address(ctoken);
            } else {
                _underlyingToCToken[ctoken.underlying()] = address(ctoken);
            }
        }
    }

    function _isCTokenUsable(CToken ctoken) internal view returns (bool) {
        (bool listed, , ) = comptroller.markets(address(ctoken));
        // NOTE: comptroller.isDeprecated is not available on Kovan
        bool deprecated = address(comptroller) == COMPTROLLER_MAINNET_ADDRESS &&
            comptroller.isDeprecated(ctoken);
        return listed && !deprecated;
    }
}",720
RealWorld_TA_112_ICurveSwapEth_RealWorld_20240815142645.log,112,ICurveSwapEth,48292,1584,49876,143.0,0.27314,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICurveSwapEth {
    function get_virtual_price() external view returns (uint256);

    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external payable;

    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external payable;

    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount)
        external;

    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;

    function exchange(
        uint256 i,
        uint256 j,
        uint256 dx,
        uint256 min_dy
    ) external payable;

    function coins(uint256 i) external view returns (address);

    function get_dy(
        uint256 i,
        uint256 j,
        uint256 dx
    ) external view returns (uint256);

    function calc_token_amount(uint256[3] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_token_amount(uint256[2] calldata amounts, bool deposit)
        external
        view
        returns (uint256);

    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)
        external
        view
        returns (uint256);

    function remove_liquidity_one_coin(
        uint256 _token_amount,
        int128 i,
        uint256 min_amount
    ) external;
}",356
RealWorld_TA_112_AddressProvider_RealWorld_20240815080850.log,112,AddressProvider,293503,4560,298063,140.0,1.558715,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../interfaces/IGasBank.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IStakerVault.sol"";
import ""../interfaces/oracles/IOracleProvider.sol"";

import ""../libraries/EnumerableExtensions.sol"";
import ""../libraries/EnumerableMapping.sol"";
import ""../libraries/AddressProviderKeys.sol"";
import ""../libraries/AddressProviderMeta.sol"";
import ""../libraries/Roles.sol"";

import ""./access/AuthorizationBase.sol"";
import ""./utils/Preparable.sol"";

// solhint-disable ordering

contract AddressProvider is IAddressProvider, AuthorizationBase, Initializable, Preparable {
    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;
    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using EnumerableExtensions for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;
    using EnumerableExtensions for EnumerableMapping.Bytes32ToUIntMap;
    using AddressProviderMeta for AddressProviderMeta.Meta;

    // LpToken -> stakerVault
    EnumerableMapping.AddressToAddressMap internal _stakerVaults;

    EnumerableSet.AddressSet internal _whiteListedFeeHandlers;

    // value is encoded as (bool freezable, bool frozen)
    EnumerableMapping.Bytes32ToUIntMap internal _addressKeyMetas;

    EnumerableSet.AddressSet internal _actions; // list of all actions ever registered

    EnumerableSet.AddressSet internal _vaults; // list of all active vaults

    EnumerableMapping.AddressToAddressMap internal _tokenToPools;

    constructor(address treasury) {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false);
        _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());
        _setConfig(AddressProviderKeys._TREASURY_KEY, treasury);
    }

    function initialize(address roleManager) external initializer {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);
        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());
        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);
    }

    function getKnownAddressKeys() external view returns (bytes32[] memory) {
        return _addressKeyMetas.keysArray();
    }

    function addFeeHandler(address feeHandler) external onlyGovernance returns (bool) {
        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);
        _whiteListedFeeHandlers.add(feeHandler);
        return true;
    }

    function removeFeeHandler(address feeHandler) external onlyGovernance returns (bool) {
        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);
        _whiteListedFeeHandlers.remove(feeHandler);
        return true;
    }

    /**
     * @notice Adds action.
     * @param action Address of action to add.
     */
    function addAction(address action) external onlyGovernance returns (bool) {
        bool result = _actions.add(action);
        if (result) {
            emit ActionListed(action);
        }
        return result;
    }

    /**
     * @notice Adds pool.
     * @param pool Address of pool to add.
     */
    function addPool(address pool)
        external
        override
        onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)
    {
        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);

        ILiquidityPool ipool = ILiquidityPool(pool);
        address poolToken = ipool.getLpToken();
        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        if (_tokenToPools.set(poolToken, pool)) {
            address vault = address(ipool.getVault());
            if (vault != address(0)) {
                _vaults.add(vault);
            }
            emit PoolListed(pool);
        }
    }

    /**
     * @notice Delists pool.
     * @param pool Address of pool to delist.
     * @return `true` if successful.
     */
    function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {
        address lpToken = ILiquidityPool(pool).getLpToken();
        bool removed = _tokenToPools.remove(lpToken);
        if (removed) {
            address vault = address(ILiquidityPool(pool).getVault());
            if (vault != address(0)) {
                _vaults.remove(vault);
            }
            emit PoolDelisted(pool);
        }

        return removed;
    }

    /** Vault functions  */

    /**
     * @notice returns all the registered vaults
     */
    function allVaults() external view returns (address[] memory) {
        return _vaults.toArray();
    }

    /**
     * @notice returns the vault at the given index
     */
    function getVaultAtIndex(uint256 index) external view returns (address) {
        return _vaults.at(index);
    }

    /**
     * @notice returns the number of vaults
     */
    function vaultsCount() external view returns (uint256) {
        return _vaults.length();
    }

    function isVault(address vault) external view returns (bool) {
        return _vaults.contains(vault);
    }

    function updateVault(address previousVault, address newVault) external onlyRole(Roles.POOL) {
        if (previousVault != address(0)) {
            _vaults.remove(previousVault);
        }
        if (newVault != address(0)) {
            _vaults.add(newVault);
        }
        emit VaultUpdated(previousVault, newVault);
    }

    /**
     * @notice Returns the address for the given key
     */
    function getAddress(bytes32 key) public view returns (address) {
        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);
        return currentAddresses[key];
    }

    /**
     * @notice Returns the address for the given key
     * @dev if `checkExists` is true, it will fail if the key does not exist
     */
    function getAddress(bytes32 key, bool checkExists) public view returns (address) {
        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);
        return currentAddresses[key];
    }

    /**
     * @notice returns the address metadata for the given key
     */
    function getAddressMeta(bytes32 key) public view returns (AddressProviderMeta.Meta memory) {
        (bool exists, uint256 metadata) = _addressKeyMetas.tryGet(key);
        require(exists, Error.ADDRESS_DOES_NOT_EXIST);
        return AddressProviderMeta.fromUInt(metadata);
    }

    function initializeAddress(bytes32 key, address initialAddress) external {
        initializeAddress(key, initialAddress, false);
    }

    /**
     * @notice Initializes an address
     * @param key Key to initialize
     * @param initialAddress Address for `key`
     */
    function initializeAddress(
        bytes32 key,
        address initialAddress,
        bool freezable
    ) public override onlyGovernance {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(freezable, false);
        _initializeAddress(key, initialAddress, meta);
    }

    /**
     * @notice Initializes and freezes address
     * @param key Key to initialize
     * @param initialAddress Address for `key`
     */
    function initializeAndFreezeAddress(bytes32 key, address initialAddress)
        external
        override
        onlyGovernance
    {
        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);
        _initializeAddress(key, initialAddress, meta);
    }

    /**
     * @notice Freezes a configuration key, making it immutable
     * @param key Key to feeze
     */
    function freezeAddress(bytes32 key) external override onlyGovernance {
        AddressProviderMeta.Meta memory meta = getAddressMeta(key);
        require(!meta.frozen, Error.ADDRESS_FROZEN);
        require(meta.freezable, Error.INVALID_ARGUMENT);
        meta.frozen = true;
        _addressKeyMetas.set(key, meta.toUInt());
    }

    /**
     * @notice Prepare update of an address
     * @param key Key to update
     * @param newAddress New address for `key`
     * @return `true` if successful.
     */
    function prepareAddress(bytes32 key, address newAddress)
        external
        override
        onlyGovernance
        returns (bool)
    {
        AddressProviderMeta.Meta memory meta = getAddressMeta(key);
        require(!meta.frozen, Error.ADDRESS_FROZEN);
        return _prepare(key, newAddress);
    }

    /**
     * @notice Execute update of `key`
     * @return New address.
     */
    function executeAddress(bytes32 key) external override returns (address) {
        AddressProviderMeta.Meta memory meta = getAddressMeta(key);
        require(!meta.frozen, Error.ADDRESS_FROZEN);
        return _executeAddress(key);
    }

    /**
     * @notice Reset `key`
     * @return true if it was reset
     */
    function resetAddress(bytes32 key) external onlyGovernance returns (bool) {
        return _resetAddressConfig(key);
    }

    /**
     * @notice Add a new staker vault and add it's lpGauge if set in vault.
     * @dev This fails if the token of the staker vault is the token of an existing staker vault.
     * @param stakerVault Vault to add.
     * @return `true` if successful.
     */
    function addStakerVault(address stakerVault)
        external
        override
        onlyRole(Roles.CONTROLLER)
        returns (bool)
    {
        address token = IStakerVault(stakerVault).getToken();
        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);
        _stakerVaults.set(token, stakerVault);
        emit StakerVaultListed(stakerVault);
        return true;
    }

    function isWhiteListedFeeHandler(address feeHandler) external view override returns (bool) {
        return _whiteListedFeeHandlers.contains(feeHandler);
    }

    /**
     * @notice Get the liquidity pool for a given token
     * @dev Does not revert if the pool deos not exist
     * @param token Token for which to get the pool.
     * @return Pool address.
     */
    function safeGetPoolForToken(address token) external view override returns (address) {
        (, address poolAddress) = _tokenToPools.tryGet(token);
        return poolAddress;
    }

    /**
     * @notice Get the liquidity pool for a given token
     * @dev Reverts if the pool deos not exist
     * @param token Token for which to get the pool.
     * @return Pool address.
     */
    function getPoolForToken(address token) external view override returns (ILiquidityPool) {
        (bool exists, address poolAddress) = _tokenToPools.tryGet(token);
        require(exists, Error.ADDRESS_NOT_FOUND);
        return ILiquidityPool(poolAddress);
    }

    /**
     * @notice Get list of all action addresses.
     * @return Array with action addresses.
     */
    function allActions() external view override returns (address[] memory) {
        return _actions.toArray();
    }

    /**
     * @notice Check whether an address is an action.
     * @param action Address to check whether it is action.
     * @return True if address is an action.
     */
    function isAction(address action) external view override returns (bool) {
        return _actions.contains(action);
    }

    /**
     * @notice Check whether an address is an pool.
     * @param pool Address to check whether it is a pool.
     * @return True if address is a pool.
     */
    function isPool(address pool) external view returns (bool) {
        address lpToken = ILiquidityPool(pool).getLpToken();
        (bool exists, address poolAddress) = _tokenToPools.tryGet(lpToken);
        return exists && pool == poolAddress;
    }

    /**
     * @notice Get list of all pool addresses.
     * @return Array with pool addresses.
     */
    function allPools() external view override returns (address[] memory) {
        return _tokenToPools.valuesArray();
    }

    /**
     * @notice returns the pool at the given index
     */
    function getPoolAtIndex(uint256 index) external view returns (address) {
        return _tokenToPools.valueAt(index);
    }

    /**
     * @notice returns the number of pools
     */
    function poolsCount() external view returns (uint256) {
        return _tokenToPools.length();
    }

    /**
     * @notice Returns all the staker vaults.
     */
    function allStakerVaults() external view override returns (address[] memory) {
        return _stakerVaults.valuesArray();
    }

    /**
     * @notice Get the staker vault for a given token
     * @dev There can only exist one staker vault per unique token.
     * @param token Token for which to get the vault.
     * @return Vault address.
     */
    function getStakerVault(address token) external view override returns (address) {
        return _stakerVaults.get(token);
    }

    /**
     * @notice Tries to get the staker vault for a given token but does not throw if it does not exist
     * @return A boolean set to true if the vault exists and the vault address.
     */
    function tryGetStakerVault(address token) external view override returns (bool, address) {
        return _stakerVaults.tryGet(token);
    }

    /**
     * @notice Check if a vault is registered (exists).
     * @param stakerVault Address of staker vault to check.
     * @return `true` if registered, `false` if not.
     */
    function isStakerVaultRegistered(address stakerVault) external view override returns (bool) {
        address token = IStakerVault(stakerVault).getToken();
        return isStakerVault(stakerVault, token);
    }

    function isStakerVault(address stakerVault, address token) public view override returns (bool) {
        (bool exists, address vault) = _stakerVaults.tryGet(token);
        return exists && vault == stakerVault;
    }

    function _roleManager() internal view override returns (IRoleManager) {
        return IRoleManager(getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));
    }

    function _initializeAddress(
        bytes32 key,
        address initialAddress,
        AddressProviderMeta.Meta memory meta
    ) internal {
        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);
        _addKnownAddressKey(key, meta);
        _setConfig(key, initialAddress);
    }

    function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal {
        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT);
        emit KnownAddressKeyAdded(key);
    }
}",3272
RealWorld_TA_112_IAmmGauge_RealWorld_20240815135151.log,112,IAmmGauge,32658,2443,35101,147.0,0.21215,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IRewardsGauge.sol"";

interface IAmmGauge is IRewardsGauge {
    event AmmStaked(address indexed account, address indexed token, uint256 amount);
    event AmmUnstaked(address indexed account, address indexed token, uint256 amount);

    function kill() external returns (bool);

    function stake(uint256 amount) external returns (bool);

    function unstake(uint256 amount) external returns (bool);

    function poolCheckpoint() external returns (bool);

    function getAmmToken() external view returns (address);

    function isAmmToken(address token) external view returns (bool);

    function claimableRewards(address user) external view returns (uint256);
}",170
RealWorld_TA_112_AddressProviderKeys_RealWorld_20240815123705.log,112,AddressProviderKeys,32173,1198,33371,178.0,0.184825,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

library AddressProviderKeys {
    bytes32 internal constant _TREASURY_KEY = ""treasury"";
    bytes32 internal constant _GAS_BANK_KEY = ""gasBank"";
    bytes32 internal constant _VAULT_RESERVE_KEY = ""vaultReserve"";
    bytes32 internal constant _SWAPPER_REGISTRY_KEY = ""swapperRegistry"";
    bytes32 internal constant _ORACLE_PROVIDER_KEY = ""oracleProvider"";
    bytes32 internal constant _POOL_FACTORY_KEY = ""poolFactory"";
    bytes32 internal constant _CONTROLLER_KEY = ""controller"";
    bytes32 internal constant _BKD_LOCKER_KEY = ""bkdLocker"";
    bytes32 internal constant _ROLE_MANAGER_KEY = ""roleManager"";
}",166
RealWorld_TA_112_IAddressProvider_RealWorld_20240815131052.log,112,IAddressProvider,76454,2309,78763,158.0,0.42845,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./pool/ILiquidityPool.sol"";
import ""./IPreparable.sol"";
import ""./IGasBank.sol"";
import ""./oracles/IOracleProvider.sol"";
import ""../libraries/AddressProviderMeta.sol"";

// solhint-disable ordering

interface IAddressProvider is IPreparable {
    event KnownAddressKeyAdded(bytes32 indexed key);
    event StakerVaultListed(address indexed stakerVault);
    event StakerVaultDelisted(address indexed stakerVault);
    event ActionListed(address indexed action);
    event PoolListed(address indexed pool);
    event PoolDelisted(address indexed pool);
    event VaultUpdated(address indexed previousVault, address indexed newVault);

    /** Key functions */
    function getKnownAddressKeys() external view returns (bytes32[] memory);

    function freezeAddress(bytes32 key) external;

    /** Pool functions */

    function allPools() external view returns (address[] memory);

    function addPool(address pool) external;

    function poolsCount() external view returns (uint256);

    function getPoolAtIndex(uint256 index) external view returns (address);

    function isPool(address pool) external view returns (bool);

    function removePool(address pool) external returns (bool);

    function getPoolForToken(address token) external view returns (ILiquidityPool);

    function safeGetPoolForToken(address token) external view returns (address);

    /** Vault functions  */

    function updateVault(address previousVault, address newVault) external;

    function allVaults() external view returns (address[] memory);

    function vaultsCount() external view returns (uint256);

    function getVaultAtIndex(uint256 index) external view returns (address);

    function isVault(address vault) external view returns (bool);

    /** Action functions */

    function allActions() external view returns (address[] memory);

    function addAction(address action) external returns (bool);

    function isAction(address action) external view returns (bool);

    /** Address functions */
    function initializeAddress(
        bytes32 key,
        address initialAddress,
        bool frezable
    ) external;

    function initializeAndFreezeAddress(bytes32 key, address initialAddress) external;

    function getAddress(bytes32 key) external view returns (address);

    function getAddress(bytes32 key, bool checkExists) external view returns (address);

    function getAddressMeta(bytes32 key) external view returns (AddressProviderMeta.Meta memory);

    function prepareAddress(bytes32 key, address newAddress) external returns (bool);

    function executeAddress(bytes32 key) external returns (address);

    function resetAddress(bytes32 key) external returns (bool);

    /** Staker vault functions */
    function allStakerVaults() external view returns (address[] memory);

    function tryGetStakerVault(address token) external view returns (bool, address);

    function getStakerVault(address token) external view returns (address);

    function addStakerVault(address stakerVault) external returns (bool);

    function isStakerVault(address stakerVault, address token) external view returns (bool);

    function isStakerVaultRegistered(address stakerVault) external view returns (bool);

    function isWhiteListedFeeHandler(address feeHandler) external view returns (bool);
}",687
RealWorld_TA_112_MockVotingEscrow_RealWorld_20240815085710.log,112,MockVotingEscrow,56794,3258,60052,105.0,0.34913,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/vendor/IGauge.sol"";
import ""./MockErc20.sol"";

contract MockVotingEscrow is IVotingEscrow {
    // mock total veCRV supply
    uint256 private _supply = 0;

    address private _crvToken;

    // veCRV balances
    mapping(address => uint256) private _balances;

    constructor(address crvToken_) {
        _crvToken = crvToken_;
    }

    // we don't actually lock tokens and we don't account for linear decay in balance
    // solhint-disable-next-line func-name-mixedcase
    function create_lock(
        uint256 _value,
        uint256 /* _time */
    ) external override {
        require(
            MockErc20(_crvToken).balanceOf(msg.sender) >= _value,
            ""msg.sender has insufficient funds to lock""
        );
        _deposit(_value);
    }

    // solhint-disable-next-line func-name-mixedcase
    function increase_amount(uint256 _value) external override {
        require(_balances[msg.sender] > 0, ""a lock needs to first be created"");
        _deposit(_value);
    }

    // solhint-disable-next-line func-name-mixedcase
    function increase_unlock_time(uint256 unlockTime) external override {}

    function withdraw() external override {
        // We don't withdraw; skip for mocking
    }

    // mock change in total veCRV supply
    function updateTotalSupply(uint256 amount) external {
        _supply = amount;
    }

    function balanceOf(address _address) external view override returns (uint256) {
        return _balances[_address];
    }

    function totalSupply() external view override returns (uint256) {
        return _supply;
    }

    function _deposit(uint256 amount) internal {
        MockErc20(_crvToken).transferFrom(msg.sender, address(this), amount);
        _balances[msg.sender] += amount;
        _supply += amount;
    }
}",438
RealWorld_TA_112_ConvexStrategyBase_RealWorld_20240815083004.log,112,ConvexStrategyBase,358902,5187,364089,152.0,1.89825,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

// TODO Add validation of curve pools
// TODO Test validation

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./IStrategySwapper.sol"";

import ""../utils/CvxMintAmount.sol"";

import ""../access/Authorization.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";
import ""../../libraries/EnumerableExtensions.sol"";

import ""../../interfaces/IStrategy.sol"";
import ""../../interfaces/vendor/IBooster.sol"";
import ""../../interfaces/vendor/IRewardStaking.sol"";
import ""../../interfaces/vendor/ICurveSwapEth.sol"";
import ""../../interfaces/vendor/ICurveRegistry.sol"";

abstract contract ConvexStrategyBase is IStrategy, Authorization, CvxMintAmount {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    IBooster internal constant _BOOSTER = IBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31); // Convex Booster Contract
    IERC20 internal constant _CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52); // CRV
    IERC20 internal constant _CVX = IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); // CVX
    IERC20 internal constant _WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH
    ICurveRegistry internal constant _CURVE_REGISTRY =
        ICurveRegistry(0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5); // Curve Registry Contract
    address internal constant _CURVE_ETH_ADDRESS =
        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE); // Null Address used for Curve ETH pools

    IStrategySwapper internal immutable _strategySwapper;

    address internal _strategist; // The strategist for the strategy
    EnumerableSet.AddressSet internal _rewardTokens; // List of additional reward tokens when claiming rewards on Convex
    IERC20 public underlying; // Strategy Underlying
    bool public isShutdown; // If the strategy is shutdown, stops all deposits
    address public communityReserve; // Address for sending CVX & CRV Community Reserve share
    address public immutable vault; // Backd Vault
    uint256 public crvCommunityReserveShare; // Share of CRV sent to Community Reserve
    uint256 public cvxCommunityReserveShare; // Share of CVX sent to Community Reserve
    uint256 public imbalanceToleranceIn; // Maximum allowed slippage from Curve Pool Imbalance for depositing
    uint256 public imbalanceToleranceOut; // Maximum allowed slippage from Curve Pool Imbalance for withdrawing
    IRewardStaking public rewards; // Rewards Contract for claiming Convex Rewards
    IERC20 public lp; // Curve Pool LP Token
    ICurveSwapEth public curvePool; // Curve Pool
    uint256 public convexPid; // Index of Convex Pool in Booster Contract
    uint256 public curveIndex; // Underlying index in Curve Pool

    event Deposit(); // Emitted after a successfull deposit
    event Withdraw(uint256 amount); // Emitted after a successful withdrawal
    event WithdrawAll(uint256 amount); // Emitted after successfully withdrwaing all
    event Shutdown(); // Emitted after a successful shutdown
    event SetCommunityReserve(address reserve); // Emitted after a succuessful setting of reserve
    event SetCrvCommunityReserveShare(uint256 value); // Emitted after a succuessful setting of CRV Community Reserve Share
    event SetCvxCommunityReserveShare(uint256 value); // Emitted after a succuessful setting of CVX Community Reserve Share
    event SetImbalanceToleranceIn(uint256 value); // Emitted after a succuessful setting of imbalance tolerance in
    event SetImbalanceToleranceOut(uint256 value); // Emitted after a succuessful setting of imbalance tolerance out
    event SetStrategist(address strategist); // Emitted after a succuessful setting of strategist
    event AddRewardToken(address token); // Emitted after successfully adding a new reward token
    event RemoveRewardToken(address token); // Emitted after successfully removing a reward token
    event Harvest(uint256 amount); // Emitted after a successful harvest

    modifier onlyVault() {
        require(msg.sender == vault, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(
        address vault_,
        address strategist_,
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_,
        IAddressProvider addressProvider_,
        address strategySwapper_
    ) Authorization(addressProvider_.getRoleManager()) {
        // Getting data from supporting contracts
        _validateCurvePool(curvePool_);
        (address lp_, , , address rewards_, , ) = _BOOSTER.poolInfo(convexPid_);
        lp = IERC20(lp_);
        rewards = IRewardStaking(rewards_);
        curvePool = ICurveSwapEth(curvePool_);
        address underlying_ = ICurveSwapEth(curvePool_).coins(curveIndex_);
        if (underlying_ == _CURVE_ETH_ADDRESS) underlying_ = address(0);
        underlying = IERC20(underlying_);

        // Setting inputs
        vault = vault_;
        _strategist = strategist_;
        convexPid = convexPid_;
        curveIndex = curveIndex_;
        _strategySwapper = IStrategySwapper(strategySwapper_);

        // Approvals
        _CRV.safeApprove(address(_strategySwapper), type(uint256).max);
        _CVX.safeApprove(address(_strategySwapper), type(uint256).max);
        _WETH.safeApprove(address(_strategySwapper), type(uint256).max);
    }

    /**
     * @notice Deposit all available underlying into Convex pool.
     * @return True if successful deposit.
     */
    function deposit() external payable override onlyVault returns (bool) {
        require(!isShutdown, Error.STRATEGY_SHUT_DOWN);
        if (!_deposit()) return false;
        emit Deposit();
        return true;
    }

    /**
     * @notice Withdraw an amount of underlying to the vault.
     * @dev This can only be called by the vault.
     *      If the amount is not available, it will be made liquid.
     * @param amount_ Amount of underlying to withdraw.
     * @return True if successful withdrawal.
     */
    function withdraw(uint256 amount_) external override onlyVault returns (bool) {
        if (amount_ == 0) return false;
        if (!_withdraw(amount_)) return false;
        emit Withdraw(amount_);
        return true;
    }

    /**
     * @notice Withdraw all underlying.
     * @dev This does not liquidate reward tokens and only considers
     *      idle underlying, idle lp tokens and staked lp tokens.
     * @return Amount of underlying withdrawn
     */
    function withdrawAll() external override returns (uint256) {
        require(
            msg.sender == vault || _roleManager().hasRole(Roles.GOVERNANCE, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        uint256 amountWithdrawn_ = _withdrawAll();
        if (amountWithdrawn_ == 0) return 0;
        emit WithdrawAll(amountWithdrawn_);
        return amountWithdrawn_;
    }

    /**
     * @notice Harvests reward tokens and sells these for the underlying.
     * @dev Any underlying harvested is not redeposited by this method.
     * @return Amount of underlying harvested.
     */
    function harvest() external override onlyVault returns (uint256) {
        return _harvest();
    }

    /**
     * @notice Shuts down the strategy, disabling deposits.
     * @return True if reserve was successfully set.
     */
    function shutdown() external override onlyVault returns (bool) {
        if (isShutdown) return false;
        isShutdown = true;
        emit Shutdown();
        return true;
    }

    /**
     * @notice Set the address of the communit reserve.
     * @dev CRV & CVX will be taxed and allocated to the reserve,
     *      such that Backd can participate in governance.
     * @param _communityReserve Address of the community reserve.
     * @return True if successfully set.
     */
    function setCommunityReserve(address _communityReserve) external onlyGovernance returns (bool) {
        communityReserve = _communityReserve;
        emit SetCommunityReserve(_communityReserve);
        return true;
    }

    /**
     * @notice Set the share of CRV to send to the Community Reserve.
     * @param crvCommunityReserveShare_ New fee charged on CRV rewards for governance.
     * @return True if successfully set.
     */
    function setCrvCommunityReserveShare(uint256 crvCommunityReserveShare_)
        external
        onlyGovernance
        returns (bool)
    {
        require(crvCommunityReserveShare_ <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(communityReserve != address(0), ""Community reserve must be set"");
        crvCommunityReserveShare = crvCommunityReserveShare_;
        emit SetCrvCommunityReserveShare(crvCommunityReserveShare_);
        return true;
    }

    /**
     * @notice Set the share of CVX to send to the Community Reserve.
     * @param cvxCommunityReserveShare_ New fee charged on CVX rewards for governance.
     * @return True if successfully set.
     */
    function setCvxCommunityReserveShare(uint256 cvxCommunityReserveShare_)
        external
        onlyGovernance
        returns (bool)
    {
        require(cvxCommunityReserveShare_ <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(communityReserve != address(0), ""Community reserve must be set"");
        cvxCommunityReserveShare = cvxCommunityReserveShare_;
        emit SetCvxCommunityReserveShare(cvxCommunityReserveShare_);
        return true;
    }

    /**
     * @notice Set imbalance tolerance for Curve Pool deposits.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param imbalanceToleranceIn_ New imbalance tolarance in.
     * @return True if successfully set.
     */
    function setImbalanceToleranceIn(uint256 imbalanceToleranceIn_)
        external
        onlyGovernance
        returns (bool)
    {
        imbalanceToleranceIn = imbalanceToleranceIn_;
        emit SetImbalanceToleranceIn(imbalanceToleranceIn_);
        return true;
    }

    /**
     * @notice Set imbalance tolerance for Curve Pool withdrawals.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param imbalanceToleranceOut_ New imbalance tolarance out.
     * @return True if successfully set.
     */
    function setImbalanceToleranceOut(uint256 imbalanceToleranceOut_)
        external
        onlyGovernance
        returns (bool)
    {
        imbalanceToleranceOut = imbalanceToleranceOut_;
        emit SetImbalanceToleranceOut(imbalanceToleranceOut_);
        return true;
    }

    /**
     * @notice Set strategist.
     * @dev Can only be set by current strategist.
     * @param strategist_ Address of new strategist.
     * @return True if successfully set.
     */
    function setStrategist(address strategist_) external returns (bool) {
        require(msg.sender == _strategist, Error.UNAUTHORIZED_ACCESS);
        _strategist = strategist_;
        emit SetStrategist(strategist_);
        return true;
    }

    /**
     * @notice Add a reward token to list of extra reward tokens.
     * @dev These are tokens that are not the main assets of the strategy. For instance, temporary incentives.
     * @param token_ Address of token to add to reward token list.
     * @return True if successfully added.
     */
    function addRewardToken(address token_) external onlyGovernance returns (bool) {
        require(
            token_ != address(_CVX) && token_ != address(underlying) && token_ != address(_CRV),
            Error.INVALID_TOKEN_TO_ADD
        );
        if (_rewardTokens.contains(token_)) return false;
        _rewardTokens.add(token_);
        IERC20(token_).safeApprove(address(_strategySwapper), 0);
        IERC20(token_).safeApprove(address(_strategySwapper), type(uint256).max);
        emit AddRewardToken(token_);
        return true;
    }

    /**
     * @notice Remove a reward token.
     * @param token_ Address of token to remove from reward token list.
     * @return True if successfully removed.
     */
    function removeRewardToken(address token_) external onlyGovernance returns (bool) {
        if (!_rewardTokens.remove(token_)) return false;
        emit RemoveRewardToken(token_);
        return true;
    }

    /**
     * @notice Amount of rewards that can be harvested in the underlying.
     * @dev Includes rewards for CRV, CVX & Extra Rewards.
     * @return Estimated amount of underlying available to harvest.
     */
    function harvestable() external view override returns (uint256) {
        IRewardStaking rewards_ = rewards;
        uint256 crvAmount_ = rewards_.earned(address(this));
        if (crvAmount_ == 0) return 0;
        uint256 harvestable_ = _underlyingAmountOut(
            address(_CRV),
            crvAmount_.scaledMul(ScaledMath.ONE - crvCommunityReserveShare)
        ) +
            _underlyingAmountOut(
                address(_CVX),
                getCvxMintAmount(crvAmount_).scaledMul(ScaledMath.ONE - cvxCommunityReserveShare)
            );
        for (uint256 i = 0; i < _rewardTokens.length(); i++) {
            IRewardStaking extraRewards_ = IRewardStaking(rewards_.extraRewards(i));
            address rewardToken_ = extraRewards_.rewardToken();
            if (!_rewardTokens.contains(rewardToken_)) continue;
            harvestable_ += _underlyingAmountOut(rewardToken_, extraRewards_.earned(address(this)));
        }
        return harvestable_;
    }

    /**
     * @notice Returns the address of the strategist.
     * @return The the address of the strategist.
     */
    function strategist() external view override returns (address) {
        return _strategist;
    }

    /**
     * @notice Returns the list of reward tokens supported by the strategy.
     * @return The list of reward tokens supported by the strategy.
     */
    function rewardTokens() external view returns (address[] memory) {
        return _rewardTokens.toArray();
    }

    /**
     * @notice Get the total underlying balance of the strategy.
     * @return Underlying balance of strategy.
     */
    function balance() external view virtual override returns (uint256);

    /**
     * @notice Returns the name of the strategy.
     * @return The name of the strategy.
     */
    function name() external view virtual override returns (string memory);

    /**
     * @dev Contract does not stash tokens.
     */
    function hasPendingFunds() external pure override returns (bool) {
        return false;
    }

    function _deposit() internal virtual returns (bool);

    function _withdraw(uint256 amount_) internal virtual returns (bool);

    function _withdrawAll() internal virtual returns (uint256);

    function _harvest() internal returns (uint256) {
        uint256 initialBalance_ = _underlyingBalance();

        // Claim Convex rewards
        rewards.getReward();

        // Sending share to Community Reserve
        _sendCommunityReserveShare();

        // Swap CVX for WETH
        IStrategySwapper strategySwapper_ = _strategySwapper;
        strategySwapper_.swapAllForWeth(address(_CVX));

        // Swap CRV for WETH
        strategySwapper_.swapAllForWeth(address(_CRV));

        // Swap Extra Rewards for WETH
        for (uint256 i = 0; i < _rewardTokens.length(); i++) {
            strategySwapper_.swapAllForWeth(_rewardTokens.at(i));
        }

        // Swap WETH for underlying
        strategySwapper_.swapAllWethForToken(address(underlying));

        uint256 harvested_ = _underlyingBalance() - initialBalance_;
        emit Harvest(harvested_);
        return harvested_;
    }

    /**
     * @notice Sends a share of the current balance of CRV and CVX to the Community Reserve.
     */
    function _sendCommunityReserveShare() internal {
        address communityReserve_ = communityReserve;
        if (communityReserve_ == address(0)) return;
        uint256 cvxCommunityReserveShare_ = cvxCommunityReserveShare;
        if (cvxCommunityReserveShare_ > 0) {
            IERC20 cvx_ = _CVX;
            uint256 cvxBalance_ = cvx_.balanceOf(address(this));
            if (cvxBalance_ > 0) {
                cvx_.safeTransfer(
                    communityReserve_,
                    cvxBalance_.scaledMul(cvxCommunityReserveShare_)
                );
            }
        }
        uint256 crvCommunityReserveShare_ = crvCommunityReserveShare;
        if (crvCommunityReserveShare_ > 0) {
            IERC20 crv_ = _CRV;
            uint256 crvBalance_ = crv_.balanceOf(address(this));
            if (crvBalance_ > 0) {
                crv_.safeTransfer(
                    communityReserve_,
                    crvBalance_.scaledMul(crvCommunityReserveShare_)
                );
            }
        }
    }

    /**
     * @dev Get the balance of the underlying.
     */
    function _underlyingBalance() internal view virtual returns (uint256);

    /**
     * @dev Get the balance of the lp.
     */
    function _lpBalance() internal view returns (uint256) {
        return lp.balanceOf(address(this));
    }

    /**
     * @dev Get the balance of the underlying staked in the Curve pool.
     */
    function _stakedBalance() internal view returns (uint256) {
        return rewards.balanceOf(address(this));
    }

    function _underlyingAmountOut(address token_, uint256 amount_) internal view returns (uint256) {
        return _strategySwapper.amountOut(token_, address(underlying), amount_);
    }

    /**
     * @dev Reverts if it is not a valid Curve Pool.
     */
    function _validateCurvePool(address curvePool_) internal view {
        _CURVE_REGISTRY.get_A(curvePool_);
    }
}",4120
RealWorld_TA_112_CvxCrvRewardsLocker_RealWorld_20240815081424.log,112,CvxCrvRewardsLocker,230219,5094,235313,139.0,1.252975,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./access/Authorization.sol"";

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/vendor/IRewardStaking.sol"";
import ""../interfaces/vendor/ICrvDepositor.sol"";
import ""../interfaces/vendor/IDelegation.sol"";
import ""../interfaces/vendor/IvlCvxExtraRewardDistribution.sol"";
import ""../interfaces/vendor/ICurveSwap.sol"";
import ""../interfaces/vendor/ICvxLocker.sol"";
import ""../interfaces/ICvxCrvRewardsLocker.sol"";

import ""../libraries/Errors.sol"";
import ""../libraries/AddressProviderHelpers.sol"";

contract CvxCrvRewardsLocker is ICvxCrvRewardsLocker, Authorization {
    using AddressProviderHelpers for IAddressProvider;

    using SafeERC20 for IERC20;

    // ERC20 tokens
    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public constant CVX_CRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);
    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);

    address public constant CVX_CRV_CRV_CURVE_POOL =
        address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8); // cvxCRV/CRV Curve Pool
    address public constant CRV_DEPOSITOR = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Lock CRV for cvxCRV
    address public constant CVX_CRV_STAKING = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); // Stake cvxCRV and get rewards
    address public constant CVX_LOCKER = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E); // CVX Locker
    address public constant VL_CVX_EXTRA_REWARD_DISTRIBUTION =
        address(0xDecc7d761496d30F30b92Bdf764fb8803c79360D);

    uint256 public spendRatio;
    bool public prepareWithdrawal;
    address public treasury;

    int128 private constant _CRV_INDEX = 0;
    int128 private constant _CVX_CRV_INDEX = 1;

    event NewSpendRatio(uint256 newSpendRatio);
    event NewTreasury(address newTreasury);

    constructor(IAddressProvider _addressProvider)
        Authorization(_addressProvider.getRoleManager())
    {
        // Approve for locking CRV for cvxCRV
        IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);

        // Approve for staking cvxCRV
        IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);

        // Approve for cvxCRV/CRV Curve Pool Swaps
        IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);

        // Approve CVX Locker
        IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);

        treasury = _addressProvider.getTreasury();
    }

    function lockCvx() external override {
        _lockCvx();
    }

    function lockCrv() external override {
        _lockCrv();
    }

    /**
     * @notice Set spend ratio for CVX locking.
     * @dev Spend ratio is the amount of CVX that should be donated to
     * the Convex treasury to boost vote power. This needs to be enabled
     * by Convex.
     * @param _spendRatio New spend ratio to be used.
     */
    function setSpendRatio(uint256 _spendRatio) external onlyGovernance returns (bool) {
        require(
            _spendRatio <= ICvxLocker(CVX_LOCKER).maximumBoostPayment(),
            Error.EXCEEDS_MAX_BOOST
        );
        spendRatio = _spendRatio;
        emit NewSpendRatio(_spendRatio);
        return true;
    }

    /**
     * @notice Claim rewards from Convex.
     * @dev Rewards to claim are for staked cvxCRV and locked CVX.
     * @param lockAndStake If true, claimed reward tokens (CRV) will be locked and staked (CRV for cvxCRV and CVX for vlCVX).
     */
    function claimRewards(bool lockAndStake) external override returns (bool) {
        ICvxLocker(CVX_LOCKER).getReward(address(this), false);

        IRewardStaking(CVX_CRV_STAKING).getReward();

        if (lockAndStake) {
            lockRewards();
        }
        return true;
    }

    /**
     * @notice Stakes cvxCRV in the cvxCRV rewards contract on Convex.
     */
    function stakeCvxCrv() external override returns (bool) {
        return _stakeCvxCrv();
    }

    /**
     * @notice Prepares a withdrawal of funds.
     * @dev If this is set then no idle funds can get locked or staked.
     */
    function setWithdrawalFlag() external onlyGovernance {
        prepareWithdrawal = true;
    }

    /**
     * @notice Resets prepared withdrawal of funds.
     */
    function resetWithdrawalFlag() external onlyGovernance {
        prepareWithdrawal = false;
    }

    /**
     * @notice Processes exipred locks.
     */
    function processExpiredLocks(bool relock) external override returns (bool) {
        if (relock) {
            require(!prepareWithdrawal, Error.PREPARED_WITHDRAWAL);
        }

        if (relock) {
            ICvxLocker(CVX_LOCKER).processExpiredLocks(relock);
        } else {
            ICvxLocker(CVX_LOCKER).withdrawExpiredLocksTo(treasury);
        }

        return true;
    }

    /**
     * @notice Set treasury to receive withdrawn funds.
     */
    function setTreasury(address _treasury) external onlyGovernance returns (bool) {
        treasury = _treasury;
        emit NewTreasury(treasury);
        return true;
    }

    /**
     * @notice Withdraw full amount of a token to the treasury.
     * @param token Token to withdraw entire balance of.
     */
    function withdraw(address token) external onlyGovernance returns (bool) {
        uint256 balance = IERC20(token).balanceOf(address(this));
        IERC20(token).safeTransfer(treasury, balance);
        return true;
    }

    /**
     * @notice Withdraw cvxCRV to treasury.
     * @dev Unstakes cvxCRV if it is staked.
     */
    function withdrawCvxCrv(uint256 amount) external onlyGovernance {
        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);
        uint256 cvxcrvBal = IERC20(CVX_CRV).balanceOf(address(this));
        if (cvxcrvBal > 0) {
            IERC20(CVX_CRV).safeTransfer(treasury, cvxcrvBal);
        }
    }

    function unstakeCvxCrv() external onlyGovernance {
        unstakeCvxCrv(false);
    }

    function unstakeCvxCrv(uint256 amount, bool withdrawal) external onlyGovernance {
        _unstakeCvxCrv(amount, withdrawal);
    }

    /**
     * @notice Set delegate to receive vote weight.
     */
    function setDelegate(address delegateContract, address delegate) external onlyGovernance {
        IDelegation(delegateContract).setDelegate(""cvx.eth"", delegate);
    }

    /**
     * @notice Clears a delegate for the msg.sender and a specific id.
     */
    function clearDelegate(address delegateContract) external onlyGovernance {
        IDelegation(delegateContract).clearDelegate(""cvx.eth"");
    }

    function forfeitRewards(address token, uint256 index) external onlyGovernance {
        IvlCvxExtraRewardDistribution(VL_CVX_EXTRA_REWARD_DISTRIBUTION).forfeitRewards(
            token,
            index
        );
    }

    /**
     * @notice Lock CRV and CVX tokens.
     * @dev CRV get locked for cvxCRV and staked on Convex.
     */
    function lockRewards() public returns (bool) {
        _lockCrv();
        _lockCvx();
        return true;
    }

    /**
     * @notice Withdraw an amount of a token to the treasury.
     * @param token Token to withdraw.
     * @param amount Amount of token to withdraw.
     */
    function withdraw(address token, uint256 amount) public onlyGovernance returns (bool) {
        IERC20(token).safeTransfer(treasury, amount);
        return true;
    }

    /**
     * @notice Unstake cvxCRV from Convex.
     */
    function unstakeCvxCrv(bool withdrawal) public onlyGovernance {
        uint256 staked = IRewardStaking(CVX_CRV_STAKING).balanceOf(address(this));
        _unstakeCvxCrv(staked, withdrawal);
    }

    function _lockCrv() internal {
        if (prepareWithdrawal) return;

        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));
        if (currentBalance != 0) {
            // Checks if we can get a better rate on Curve Pool
            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(
                _CRV_INDEX,
                _CVX_CRV_INDEX,
                currentBalance
            );
            if (amountOut > currentBalance) {
                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(
                    _CRV_INDEX,
                    _CVX_CRV_INDEX,
                    currentBalance,
                    0
                );
            } else {
                // Swap CRV for cxvCRV and stake
                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));
            }
            IRewardStaking(CVX_CRV_STAKING).stakeAll();
            return;
        }

        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)
            IRewardStaking(CVX_CRV_STAKING).stakeAll();
    }

    function _lockCvx() internal {
        // Locks CVX for vlCVX
        if (prepareWithdrawal) return;
        uint256 currentBalance = IERC20(CVX).balanceOf(address(this));
        if (currentBalance == 0) return;
        ICvxLocker(CVX_LOCKER).lock(address(this), currentBalance, spendRatio);
    }

    function _stakeCvxCrv() internal returns (bool) {
        if (prepareWithdrawal) return false;

        if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;
        IRewardStaking(CVX_CRV_STAKING).stakeAll();
        return true;
    }

    function _unstakeCvxCrv(uint256 amount, bool withdrawal) internal {
        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);
        if (withdrawal) {
            IERC20(CVX_CRV).safeTransfer(treasury, amount);
        }
    }
}",2583
RealWorld_TA_112_ScaledMath_RealWorld_20240815122706.log,112,ScaledMath,49132,1536,50668,145.0,0.27638,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/*
 * @dev To use functions of this contract, at least one of the numbers must
 * be scaled to `DECIMAL_SCALE`. The result will scaled to `DECIMAL_SCALE`
 * if both numbers are scaled to `DECIMAL_SCALE`, otherwise to the scale
 * of the number not scaled by `DECIMAL_SCALE`
 */
library ScaledMath {
    // solhint-disable-next-line private-vars-leading-underscore
    uint256 internal constant DECIMAL_SCALE = 1e18;
    // solhint-disable-next-line private-vars-leading-underscore
    uint256 internal constant ONE = 1e18;

    /**
     * @notice Performs a multiplication between two scaled numbers
     */
    function scaledMul(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a * b) / DECIMAL_SCALE;
    }

    /**
     * @notice Performs a division between two scaled numbers
     */
    function scaledDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a * DECIMAL_SCALE) / b;
    }

    /**
     * @notice Performs a division between two numbers, rounding up the result
     */
    function scaledDivRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a * DECIMAL_SCALE + b - 1) / b;
    }

    /**
     * @notice Performs a division between two numbers, ignoring any scaling and rounding up the result
     */
    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {
        return (a + b - 1) / b;
    }
}",363
RealWorld_TA_112_KeeperGauge_RealWorld_20240815114347.log,112,KeeperGauge,121382,3527,124909,159.0,0.67745,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/IKeeperGauge.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract KeeperGauge is IKeeperGauge, Authorization {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;

    struct KeeperRecord {
        mapping(uint256 => uint256) feesInPeriod;
        uint256 nextEpochToClaim;
        bool firstEpochSet;
    }

    mapping(address => KeeperRecord) public keeperRecords;
    mapping(uint256 => uint256) public perPeriodTotalFees;

    IController public immutable controller;
    address public immutable pool;
    uint256 public epoch;

    uint48 public lastUpdated;
    mapping(uint256 => uint256) public perPeriodTotalInflation;

    bool public override killed;

    modifier onlyInflationManager() {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor(IController _controller, address _pool)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        pool = _pool;
        lastUpdated = uint48(block.timestamp);
    }

    /**
     * @notice Shut down the gauge.
     * @dev Accrued inflation can still be claimed from the gauge after shutdown.
     * @return `true` if successful.
     */
    function kill() external override onlyInflationManager returns (bool) {
        poolCheckpoint();
        epoch++;
        killed = true;
        return true;
    }

    /**
     * @notice Report fees generated by a keeper (this is the basis for inflation accrual).
     * @dev lpTokenAddress is included for forward compatibility with a single gauge solution.
     * @param beneficiary Address of the keeper who earned the fees.
     * @param amount Amount of fees (in lp tokens) earned.
     * @param lpTokenAddress Address of the lpToken in which the fees are paid.
     * @return `true` if successful.
     */
    function reportFees(
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external override returns (bool) {
        lpTokenAddress; // silencing compiler warning
        require(
            IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender),
            Error.ADDRESS_NOT_WHITELISTED
        );
        require(!killed, Error.CONTRACT_PAUSED);
        if (!keeperRecords[beneficiary].firstEpochSet) {
            keeperRecords[beneficiary].firstEpochSet = true;
            keeperRecords[beneficiary].nextEpochToClaim = epoch;
        }
        keeperRecords[beneficiary].feesInPeriod[epoch] += amount;
        perPeriodTotalFees[epoch] += amount;
        return true;
    }

    /**
     * @notice Advance the inflation accrual epoch.
     * @return `true` if successful.
     */
    function advanceEpoch() external virtual override onlyInflationManager returns (bool) {
        poolCheckpoint();
        epoch++;
        return true;
    }

    function claimRewards(address beneficiary) external override returns (uint256) {
        return claimRewards(beneficiary, epoch);
    }

    function claimableRewards(address beneficiary) external view override returns (uint256) {
        return _calcTotalClaimable(beneficiary, keeperRecords[beneficiary].nextEpochToClaim, epoch);
    }

    function poolCheckpoint() public override returns (bool) {
        if (killed) return false;
        uint256 timeElapsed = block.timestamp - uint256(lastUpdated);
        uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);
        perPeriodTotalInflation[epoch] += currentRate * timeElapsed;
        lastUpdated = uint48(block.timestamp);
        return true;
    }

    /**
     * @notice Claim rewards with an epoch up to which they should be claimed specified.
     * @param beneficiary Address to claim rewards for.
     * @param endEpoch Epoch up to which to claim rewards.
     * @return The amount of rewards claimed.
     */
    function claimRewards(address beneficiary, uint256 endEpoch) public returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        if (endEpoch > epoch) {
            endEpoch = epoch;
        }

        uint256 totalClaimable = _calcTotalClaimable(
            beneficiary,
            keeperRecords[beneficiary].nextEpochToClaim,
            endEpoch
        );
        keeperRecords[beneficiary].nextEpochToClaim = endEpoch;
        require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);
        _mintRewards(beneficiary, totalClaimable);

        return totalClaimable;
    }

    function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) {
        IController(controller).inflationManager().mintRewards(beneficiary, amount);
        return true;
    }

    function _calcTotalClaimable(
        address beneficiary,
        uint256 startEpoch,
        uint256 endEpoch
    ) internal view returns (uint256) {
        uint256 totalClaimable = 0;
        for (uint256 i = startEpoch; i < endEpoch; i++) {
            totalClaimable += (
                keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])
            ).scaledMul(perPeriodTotalInflation[i]);
        }
        return totalClaimable;
    }
}",1224
RealWorld_TA_112_IRewardBase_RealWorld_20240815144647.log,112,IRewardBase,22682,1288,23970,149.0,0.13917,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

// NOTE: does not strictly but contains fucntions from `BaseRewardPool`
interface IRewardBase {
    function periodFinish() external view returns (uint256);
}",52
RealWorld_TA_112_BkdTriHopCvx_RealWorld_20240815083621.log,112,BkdTriHopCvx,314281,4361,318642,142.0,1.658625,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./ConvexStrategyBase.sol"";
import ""../../interfaces/IERC20Full.sol"";

/**
 * This is the BkdTriHopCvx strategy, which is designed to be used by a Backd ERC20 Vault.
 * The strategy holds a given ERC20 underlying and allocates liquidity to Convex via a given Curve Pool.
 * The Curve Pools used are Meta Pools which first require getting an LP Token from another Curve Pool.
 * The strategy does a 'Hop' when depositing and withdrawing, by first getting the required LP Token, and then the final LP Token for Convex.
 * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.
 * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.
 */
contract BkdTriHopCvx is ConvexStrategyBase {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    ICurveSwapEth public immutable curveHopPool; // Curve Pool to use for Hops
    IERC20 public immutable hopLp; // Curve Hop Pool LP Token
    uint256 public immutable curveHopIndex; // Underlying index in Curve Pool

    uint256 public hopImbalanceToleranceIn; // Maximum allowed slippage from Curve Hop Pool Imbalance for depositing
    uint256 public hopImbalanceToleranceOut; // Maximum allowed slippage from Curve Hop Pool Imbalance for withdrawing
    uint256 public decimalMultiplier; // Used for converting between underlying and LP

    event SetHopImbalanceToleranceIn(uint256 value); // Emitted after a succuessful setting of hop imbalance tolerance in
    event SetHopImbalanceToleranceOut(uint256 value); // Emitted after a succuessful setting of hop imbalance tolerance out

    constructor(
        address vault_,
        address strategist_,
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_,
        address curveHopPool_,
        uint256 curveHopIndex_,
        IAddressProvider addressProvider_,
        address strategySwapper_
    )
        ConvexStrategyBase(
            vault_,
            strategist_,
            convexPid_,
            curvePool_,
            curveIndex_,
            addressProvider_,
            strategySwapper_
        )
    {
        // Getting data from supporting contracts
        _validateCurvePool(curveHopPool_);
        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);
        address hopLp_ = ICurveSwapEth(curvePool_).coins(curveIndex_);
        hopLp = IERC20(hopLp_);
        curveHopPool = ICurveSwapEth(curveHopPool_);
        address underlying_ = ICurveSwapEth(curveHopPool_).coins(curveHopIndex_);
        underlying = IERC20(underlying_);
        decimalMultiplier = 10**(18 - IERC20Full(underlying_).decimals());

        // Setting inputs
        curveHopIndex = curveHopIndex_;

        // Setting default values
        imbalanceToleranceIn = 0.001e18;
        imbalanceToleranceOut = 0.048e18;
        hopImbalanceToleranceIn = 0.001e18;
        hopImbalanceToleranceOut = 0.0015e18;

        // Approvals
        IERC20(underlying_).safeApprove(curveHopPool_, type(uint256).max);
        IERC20(hopLp_).safeApprove(curvePool_, type(uint256).max);
        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);
    }

    /**
     * @notice Set hop imbalance tolerance for Curve Hop Pool deposits.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param _hopImbalanceToleranceIn New hop imbalance tolarance in.
     * @return True if successfully set.
     */
    function setHopImbalanceToleranceIn(uint256 _hopImbalanceToleranceIn)
        external
        onlyGovernance
        returns (bool)
    {
        hopImbalanceToleranceIn = _hopImbalanceToleranceIn;
        emit SetHopImbalanceToleranceIn(_hopImbalanceToleranceIn);
        return true;
    }

    /**
     * @notice Set hop imbalance tolerance for Curve Hop Pool withdrawals.
     * @dev Stored as a percent, e.g. 1% would be set as 0.01
     * @param _hopImbalanceToleranceOut New hop imbalance tolarance out.
     * @return True if successfully set.
     */
    function setHopImbalanceToleranceOut(uint256 _hopImbalanceToleranceOut)
        external
        onlyGovernance
        returns (bool)
    {
        hopImbalanceToleranceOut = _hopImbalanceToleranceOut;
        emit SetHopImbalanceToleranceOut(_hopImbalanceToleranceOut);
        return true;
    }

    /**
     * @notice Changes the Convex Pool used for farming yield, e.g. from FRAX to MIM.
     * @dev First withdraws all funds, then harvests any rewards, then changes pool, then deposits again.
     * @param convexPid_ The PID for the new Convex Pool.
     * @param curvePool_ The Curve Pool to deposit into to get the required LP Token for Convex staking.
     * @param curveIndex_ The index of the new Convex Pool Token in the new Curve Pool.
     */
    function changeConvexPool(
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_
    ) external onlyGovernance {
        _validateCurvePool(curvePool_);
        _harvest();
        _withdrawAllToHopLp();
        convexPid = convexPid_;
        curveIndex = curveIndex_;
        (address lp_, , , address rewards_, , ) = _BOOSTER.poolInfo(convexPid_);
        lp = IERC20(lp_);
        rewards = IRewardStaking(rewards_);
        curvePool = ICurveSwapEth(curvePool_);
        IERC20(hopLp).safeApprove(curvePool_, 0);
        IERC20(hopLp).safeApprove(curvePool_, type(uint256).max);
        IERC20(lp_).safeApprove(address(_BOOSTER), 0);
        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);
        require(_deposit(), Error.DEPOSIT_FAILED);
    }

    function balance() public view override returns (uint256) {
        return
            _underlyingBalance() +
            _hopLpToUnderlying(_lpToHopLp(_stakedBalance() + _lpBalance()) + _hopLpBalance());
    }

    function name() public pure override returns (string memory) {
        return ""BkdTriHopCvx"";
    }

    function _deposit() internal override returns (bool) {
        require(msg.value == 0, Error.INVALID_VALUE);

        // Depositing into Curve Hop Pool
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance > 0) {
            uint256[3] memory hopAmounts;
            hopAmounts[curveHopIndex] = underlyingBalance;
            curveHopPool.add_liquidity(hopAmounts, _minHopLpAcceptedFromDeposit(underlyingBalance));
        }

        // Depositing into Curve Pool
        uint256 hopLpBalance = _hopLpBalance();
        if (hopLpBalance > 0) {
            uint256[2] memory amounts;
            amounts[curveIndex] = hopLpBalance;
            curvePool.add_liquidity(amounts, _minLpAccepted(hopLpBalance));
        }

        // Depositing into Convex and Staking
        if (_lpBalance() == 0) return false;
        if (!_BOOSTER.depositAll(convexPid, true)) return false;
        return true;
    }

    function _withdraw(uint256 amount) internal override returns (bool) {
        // Transferring from idle balance if enough
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance >= amount) {
            underlying.safeTransfer(vault, amount);
            emit Withdraw(amount);
            return true;
        }

        // Calculating needed amount of LP to withdraw
        uint256 requiredUnderlyingAmount = amount - underlyingBalance;
        uint256 maxHopLpBurned = _maxHopLpBurned(requiredUnderlyingAmount);
        uint256 requiredHopLpAmount = maxHopLpBurned - _hopLpBalance();
        uint256 maxLpBurned = _maxLpBurned(requiredHopLpAmount);
        uint256 requiredLpAmount = maxLpBurned - _lpBalance();

        // Unstaking needed LP Tokens from Convex
        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;

        // Removing needed liquidity from Curve Pool
        uint256[2] memory amounts;
        amounts[curveIndex] = requiredHopLpAmount;
        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);

        // Removing needed liquidity from Curve Hop Pool
        uint256[3] memory hopAmounts;
        hopAmounts[curveHopIndex] = requiredUnderlyingAmount;
        curveHopPool.remove_liquidity_imbalance(hopAmounts, maxHopLpBurned);

        // Sending underlying to vault
        underlying.safeTransfer(vault, amount);
        return true;
    }

    function _withdrawAll() internal override returns (uint256) {
        // Withdrawing all from Convex and converting to Hop LP Token
        _withdrawAllToHopLp();

        // Removing liquidity from Curve Hop Pool
        uint256 hopLpBalance = _hopLpBalance();
        if (hopLpBalance > 0) {
            curveHopPool.remove_liquidity_one_coin(
                hopLpBalance,
                int128(uint128(curveHopIndex)),
                _minUnderlyingAccepted(hopLpBalance)
            );
        }

        // Transferring underlying to vault
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance == 0) return 0;
        underlying.safeTransfer(vault, underlyingBalance);
        return underlyingBalance;
    }

    function _underlyingBalance() internal view override returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    /**
     * @dev Get the balance of the hop lp.
     */
    function _hopLpBalance() internal view returns (uint256) {
        return hopLp.balanceOf(address(this));
    }

    /**
     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.
     * @param _hopLpAmount Amount of Hop LP that is being deposited into Curve Pool.
     * @return The minimum LP balance to accept.
     */
    function _minLpAccepted(uint256 _hopLpAmount) internal view returns (uint256) {
        return _hopLpToLp(_hopLpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);
    }

    /**
     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.
     * @param _hopLpAmount Amount of Hop LP that is being widthdrawn from Curve Pool.
     * @return The maximum LP balance to accept burning.
     */
    function _maxLpBurned(uint256 _hopLpAmount) internal view returns (uint256) {
        return _hopLpToLp(_hopLpAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);
    }

    /**
     * @notice Calculates the minimum Hop LP to accept when burning LP tokens to withdraw from Curve Pool.
     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.
     * @return The mininum Hop LP balance to accept.
     */
    function _minHopLpAcceptedFromWithdraw(uint256 _lpAmount) internal view returns (uint256) {
        return _lpToHopLp(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);
    }

    /**
     * @notice Calculates the minimum Hop LP to accept when depositing underlying into Curve Hop Pool.
     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Hop Pool.
     * @return The minimum Hop LP balance to accept.
     */
    function _minHopLpAcceptedFromDeposit(uint256 _underlyingAmount)
        internal
        view
        returns (uint256)
    {
        return
            _underlyingToHopLp(_underlyingAmount).scaledMul(
                ScaledMath.ONE - hopImbalanceToleranceIn
            );
    }

    /**
     * @notice Calculates the maximum Hop LP to accept burning when withdrawing amount from Curve Hop Pool.
     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Hop Pool.
     * @return The maximum Hop LP balance to accept burning.
     */
    function _maxHopLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {
        return
            _underlyingToHopLp(_underlyingAmount).scaledMul(
                ScaledMath.ONE + hopImbalanceToleranceOut
            );
    }

    /**
     * @notice Calculates the minimum underlying to accept when burning Hop LP tokens to withdraw from Curve Hop Pool.
     * @param _hopLpAmount Amount of Hop LP tokens being burned to withdraw from Curve Hop Pool.
     * @return The mininum underlying balance to accept.
     */
    function _minUnderlyingAccepted(uint256 _hopLpAmount) internal view returns (uint256) {
        return
            _hopLpToUnderlying(_hopLpAmount).scaledMul(ScaledMath.ONE - hopImbalanceToleranceOut);
    }

    /**
     * @notice Converts an amount of underlying into their estimated Hop LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _underlyingAmount Amount of underlying to convert.
     * @return The estimated value in the Hop LP.
     */
    function _underlyingToHopLp(uint256 _underlyingAmount) internal view returns (uint256) {
        return (_underlyingAmount * decimalMultiplier).scaledDiv(curveHopPool.get_virtual_price());
    }

    /**
     * @notice Converts an amount of Hop LP into their estimated underlying value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _hopLpAmount Amount of Hop LP to convert.
     * @return The estimated value in the underlying.
     */
    function _hopLpToUnderlying(uint256 _hopLpAmount) internal view returns (uint256) {
        return (_hopLpAmount / decimalMultiplier).scaledMul(curveHopPool.get_virtual_price());
    }

    /**
     * @notice Converts an amount of LP into their estimated Hop LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _lpAmount Amount of underlying to convert.
     * @return The estimated value in the Hop LP.
     */
    function _lpToHopLp(uint256 _lpAmount) internal view returns (uint256) {
        return
            _lpAmount.scaledMul(curvePool.get_virtual_price()).scaledDiv(
                curveHopPool.get_virtual_price()
            );
    }

    /**
     * @notice Converts an amount of Hop LP into their estimated LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _hopLpAmount Amount of Hop LP to convert.
     * @return The estimated value in the LP.
     */
    function _hopLpToLp(uint256 _hopLpAmount) internal view returns (uint256) {
        return
            _hopLpAmount.scaledMul(curveHopPool.get_virtual_price()).scaledDiv(
                curvePool.get_virtual_price()
            );
    }

    /**
     * @dev Withdraw all underlying and convert to the Hop LP Token.
     */
    function _withdrawAllToHopLp() private {
        // Unstaking and withdrawing from Convex pool
        uint256 stakedBalance = _stakedBalance();
        if (stakedBalance > 0) {
            rewards.withdrawAndUnwrap(stakedBalance, false);
        }

        // Removing liquidity from Curve Pool
        uint256 lpBalance = _lpBalance();
        if (lpBalance > 0) {
            curvePool.remove_liquidity_one_coin(
                lpBalance,
                int128(uint128(curveIndex)),
                _minHopLpAcceptedFromWithdraw(lpBalance)
            );
        }
    }
}",3634
RealWorld_TA_112_MockTopUpAction_RealWorld_20240815093147.log,112,MockTopUpAction,34692,3123,37815,101.0,0.23592,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../actions/topup/TopUpAction.sol"";

contract MockTopUpAction is TopUpAction {
    constructor(IController _controller) TopUpAction(_controller) {
        // solhint-disable-previous-line no-empty-blocks
    }

    function updateFeeHandler(address feeHandlerAddress) external onlyGovernance {
        _setConfig(_FEE_HANDLER_KEY, feeHandlerAddress);
    }

    function setActionFee(uint256 fee) external onlyGovernance {
        _setConfig(_ACTION_FEE_KEY, fee);
    }

    function testingPayFees(
        address payer,
        address keeper,
        uint256 amount,
        address lpToken
    ) external {
        _payFees(payer, keeper, amount, lpToken);
    }
}",179
RealWorld_TA_112_ICvxLocker_RealWorld_20240815141900.log,112,ICvxLocker,43687,1310,44997,138.0,0.244635,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICvxLocker {
    function getReward(address _account, bool _stake) external;

    function balanceOf(address _user) external view returns (uint256);

    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external;

    function processExpiredLocks(bool _relock) external;

    function withdrawExpiredLocksTo(address _withdrawTo) external;

    function maximumBoostPayment() external returns (uint256);

    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external;

    function lockedBalanceOf(address _user) external view returns (uint256 amount);

    function checkpointEpoch() external;

    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 indexed _epoch,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );

    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Recovered(address _token, uint256 _amount);
}",301
RealWorld_TA_112_EthVault_RealWorld_20240815120628.log,112,EthVault,45758,4110,49868,153.0,0.31099,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./Vault.sol"";

contract EthVault is Vault {
    using AddressProviderHelpers for IAddressProvider;

    address private constant _UNDERLYING = address(0);

    constructor(IController controller) Vault(controller) {}

    receive() external payable {}

    function initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) external virtual override initializer {
        _initialize(_pool, _debtLimit, _targetAllocation, _bound);
    }

    function getUnderlying() public pure override returns (address) {
        return _UNDERLYING;
    }

    function _transfer(address to, uint256 amount) internal override {
        payable(to).transfer(amount);
    }

    function _depositToReserve(uint256 amount) internal override {
        reserve.deposit{value: amount}(_UNDERLYING, amount);
    }

    function _depositToTreasury(uint256 amount) internal override {
        payable(addressProvider.getTreasury()).transfer(amount);
    }

    function _payStrategist(uint256 amount, address strategist) internal override {
        if (strategist == address(0)) return;
        ILiquidityPool(pool).depositFor{value: amount}(strategist, amount);
    }

    function _availableUnderlying() internal view override returns (uint256) {
        return address(this).balance;
    }
}",313
RealWorld_TA_112_IStrategy_RealWorld_20240815130836.log,112,IStrategy,29890,1458,31348,134.0,0.17861,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IStrategy {
    function name() external view returns (string memory);

    function deposit() external payable returns (bool);

    function balance() external view returns (uint256);

    function withdraw(uint256 amount) external returns (bool);

    function withdrawAll() external returns (uint256);

    function harvestable() external view returns (uint256);

    function harvest() external returns (uint256);

    function strategist() external view returns (address);

    function shutdown() external returns (bool);

    function hasPendingFunds() external view returns (bool);
}",137
RealWorld_TA_112_MockSwapper3Crv_RealWorld_20240815085223.log,112,MockSwapper3Crv,32475,1598,34073,97.0,0.194335,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../swappers/Swapper3Crv.sol"";

contract MockSwapper3Crv is Swapper3Crv {
    // Wrapped internal methods for testing only
    function getBestDex(
        address fromToken,
        address toToken,
        uint256 amount
    ) external view returns (address bestDex, uint256 amountOut) {
        return _getBestDex(fromToken, toToken, amount);
    }

    function tokenAmountOut(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        address dex
    ) external view returns (uint256) {
        return _tokenAmountOut(tokenIn, tokenOut, amountIn, dex);
    }
}",170
RealWorld_TA_112_IActionFeeHandler_RealWorld_20240815133644.log,112,IActionFeeHandler,29341,2132,31473,153.0,0.189345,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../IPreparable.sol"";

interface IActionFeeHandler is IPreparable {
    function payFees(
        address payer,
        address keeper,
        uint256 amount,
        address token
    ) external returns (bool);

    function claimKeeperFeesForPool(address keeper, address token) external returns (bool);

    function claimTreasuryFees(address token) external returns (bool);

    function setInitialKeeperGaugeForToken(address lpToken, address _keeperGauge)
        external
        returns (bool);
}",132
RealWorld_TA_112_IERC20Full_RealWorld_20240815125818.log,112,IERC20Full,27204,1261,28465,126.0,0.16124,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @notice This is the ERC20 interface including optional getter functions
/// The interface is used in the frontend through the generated typechain wrapper
interface IERC20Full is IERC20 {
    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function decimals() external view returns (uint8);
}",113
RealWorld_TA_112_DummyErc20_RealWorld_20240815084859.log,112,DummyErc20,26890,1585,28475,83.0,0.16615,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract DummyERC20 is ERC20, Ownable {
    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

    function mintAsOwner(uint256 amount) external onlyOwner {
        _mint(msg.sender, amount);
    }
}",108
RealWorld_TA_112_MockBKDMinter_RealWorld_20240815090251.log,112,MockBKDMinter,46629,3059,49688,109.0,0.294325,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.9;

import ""../tokenomics/Minter.sol"";

contract MockBKDMinter is Minter {
    constructor(
        uint256 _annualInflationRateLp,
        uint256 _annualInflationRateKeeper,
        uint256 _annualInflationRateAmm,
        uint256 _annualInflationDecayLp,
        uint256 _annualInflationDecayKeeper,
        uint256 _annualInflationDecayAmm,
        uint256 _initialPeriodKeeperInflation,
        uint256 _initialPeriodAmmInflation,
        uint256 _nonInflationDistribution,
        IController _controller
    )
        Minter(
            _annualInflationRateLp,
            _annualInflationRateKeeper,
            _annualInflationRateAmm,
            _annualInflationDecayLp,
            _annualInflationDecayKeeper,
            _annualInflationDecayAmm,
            _initialPeriodKeeperInflation,
            _initialPeriodAmmInflation,
            _nonInflationDistribution,
            _controller
        )
    {}

    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing(address beneficiary, uint256 amount) external returns (bool) {
        token.mint(beneficiary, amount);
        return true;
    }

    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing_with_checks(address beneficiary, uint256 amount)
        external
        returns (bool)
    {
        return _mint(beneficiary, amount);
    }
}",336
RealWorld_TA_112_MockAmmGauge_RealWorld_20240815093009.log,112,MockAmmGauge,34229,2065,36294,96.0,0.212445,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../Controller.sol"";
import ""../tokenomics/AmmGauge.sol"";

contract MockAmmGauge is AmmGauge {
    constructor(IController _controller, address _ammToken) AmmGauge(_controller, _ammToken) {}

    function stake(uint256) external override returns (bool) {
        return true;
    }

    function unstake(uint256) external override returns (bool) {
        return true;
    }

    // solhint-disable-next-line no-unused-vars
    function claimableRewards(address user) external view override returns (uint256) {
        return 0;
    }

    function claimRewards(address) external pure override returns (uint256) {
        return 0;
    }

    function poolCheckpoint() public pure override returns (bool) {
        return true;
    }
}",192
RealWorld_TA_112_MockCurveToken_RealWorld_20240815093906.log,112,MockCurveToken,26528,2726,29254,100.0,0.18716,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./MockErc20.sol"";

contract MockCurveToken is MockErc20 {
    constructor(uint8 _decimals) MockErc20(_decimals) {}

    function burnFrom(address to, uint256 value) external returns (bool) {
        _burn(to, value);
        return true;
    }
}",89
RealWorld_TA_112_StakerVaultProfiler_RealWorld_20240815094751.log,112,StakerVaultProfiler,33981,3319,37300,108.0,0.236285,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../StakerVault.sol"";
import ""../../LpToken.sol"";

contract StakerVaultProfiler {
    StakerVault public stakerVault;

    constructor(address _stakerVault) {
        stakerVault = StakerVault(_stakerVault);
        LpToken(stakerVault.token()).approve(address(stakerVault), type(uint256).max);
    }

    function profileStake(uint256 amount) external {
        stakerVault.stake(amount);
        stakerVault.stake(amount);
        stakerVault.stake(amount);
        stakerVault.stake(amount);

        stakerVault.unstake(amount);
        stakerVault.unstake(amount);
        stakerVault.unstake(amount);
    }
}",170
RealWorld_TA_112_IStrategySwapper_RealWorld_20240815083845.log,112,IStrategySwapper,32087,2193,34280,92.0,0.204295,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IStrategySwapper {
    function swapAllForWeth(address token) external;

    function swapAllWethForToken(address token_) external;

    function setSlippageTolerance(uint256 _slippageTolerance) external;

    function setSwapViaUniswap(address token_, bool swapViaUniswap_) external;

    function swapForWeth(address token, uint256 amount) external;

    function setCurvePool(address token_, address curvePool_) external;

    function amountOut(
        address tokenIn_,
        address tokenOut_,
        uint256 amountIn
    ) external view returns (uint256);
}",170
RealWorld_TA_112_OracleProviderExtensions_RealWorld_20240815082228.log,112,OracleProviderExtensions,28441,2011,30452,85.0,0.182425,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/ScaledMath.sol"";
import ""../../interfaces/oracles/IOracleProvider.sol"";

library OracleProviderExtensions {
    using ScaledMath for uint256;

    function getRelativePrice(
        IOracleProvider priceOracle,
        address fromToken,
        address toToken
    ) internal view returns (uint256) {
        return priceOracle.getPriceUSD(fromToken).scaledDiv(priceOracle.getPriceUSD(toToken));
    }
}",109
RealWorld_TA_112_IAmmConvexGauge_RealWorld_20240815135639.log,112,IAmmConvexGauge,24772,1734,26506,144.0,0.15854,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IAmmConvexGauge {
    function deactivateInflationRecipient() external;

    function setInflationRecipient(address recipient) external;

    function allClaimableRewards(address user) external view returns (uint256[3] memory);
}",73
RealWorld_TA_112_BkdEthCvx_RealWorld_20240815083239.log,112,BkdEthCvx,143973,4908,148881,120.0,0.818025,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./ConvexStrategyBase.sol"";

/**
 * This is the BkdEthCvx strategy, which is designed to be used by a Backd ETH Vault.
 * The strategy holds ETH as it's underlying and allocates liquidity to Convex via given Curve Pool with 2 underlying tokens.
 * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.
 * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.
 */
contract BkdEthCvx is ConvexStrategyBase {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    constructor(
        address vault_,
        address strategist_,
        uint256 convexPid_,
        address curvePool_,
        uint256 curveIndex_,
        IAddressProvider addressProvider_,
        address strategySwapper_
    )
        ConvexStrategyBase(
            vault_,
            strategist_,
            convexPid_,
            curvePool_,
            curveIndex_,
            addressProvider_,
            strategySwapper_
        )
    {
        // Setting default values
        imbalanceToleranceIn = 0.0007e18;
        imbalanceToleranceOut = 0.0104e18;

        // Approvals
        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);
        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);
    }

    receive() external payable {}

    function name() external pure override returns (string memory) {
        return ""BkdEthCvx"";
    }

    function balance() public view override returns (uint256) {
        return _underlyingBalance() + _lpToUnderlying(_stakedBalance() + _lpBalance());
    }

    function _deposit() internal override returns (bool) {
        // Depositing into Curve Pool
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance == 0) return false;
        uint256[2] memory amounts;
        amounts[curveIndex] = underlyingBalance;
        curvePool.add_liquidity{value: underlyingBalance}(
            amounts,
            _minLpAccepted(underlyingBalance)
        );

        // Depositing into Convex and Staking
        if (!_BOOSTER.depositAll(convexPid, true)) return false;
        return true;
    }

    function _withdraw(uint256 amount) internal override returns (bool) {
        uint256 underlyingBalance = _underlyingBalance();

        // Transferring from idle balance if enough
        if (underlyingBalance >= amount) {
            payable(vault).transfer(amount);
            emit Withdraw(amount);
            return true;
        }

        // Unstaking needed LP Tokens from Convex
        uint256 requiredUnderlyingAmount = amount - underlyingBalance;
        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);
        uint256 requiredLpAmount = maxLpBurned - _lpBalance();
        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;

        // Removing needed liquidity from Curve
        uint256[2] memory amounts;
        // solhint-disable-next-line reentrancy
        amounts[curveIndex] = requiredUnderlyingAmount;
        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);
        payable(vault).transfer(amount);
        return true;
    }

    function _withdrawAll() internal override returns (uint256) {
        // Unstaking and withdrawing from Convex pool
        uint256 stakedBalance = _stakedBalance();
        if (stakedBalance > 0) {
            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;
        }

        // Removing liquidity from Curve
        uint256 lpBalance = _lpBalance();
        if (lpBalance > 0) {
            curvePool.remove_liquidity_one_coin(
                lpBalance,
                int128(uint128(curveIndex)),
                _minUnderlyingAccepted(lpBalance)
            );
        }

        // Transferring underlying to vault
        uint256 underlyingBalance = _underlyingBalance();
        if (underlyingBalance == 0) return 0;
        payable(vault).transfer(underlyingBalance);
        return underlyingBalance;
    }

    function _underlyingBalance() internal view override returns (uint256) {
        return address(this).balance;
    }

    /**
     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.
     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Pool.
     * @return The minimum LP balance to accept.
     */
    function _minLpAccepted(uint256 _underlyingAmount) internal view returns (uint256) {
        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);
    }

    /**
     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.
     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Pool.
     * @return The maximum LP balance to accept burning.
     */
    function _maxLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {
        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);
    }

    /**
     * @notice Calculates the minimum underlying to accept when burning LP tokens to withdraw from Curve Pool.
     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.
     * @return The minimum underlying balance to accept.
     */
    function _minUnderlyingAccepted(uint256 _lpAmount) internal view returns (uint256) {
        return _lpToUnderlying(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);
    }

    /**
     * @notice Converts an amount of underlying into their estimated LP value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _underlyingAmount Amount of underlying to convert.
     * @return The estimated value in the LP.
     */
    function _underlyingToLp(uint256 _underlyingAmount) internal view returns (uint256) {
        return _underlyingAmount.scaledDiv(curvePool.get_virtual_price());
    }

    /**
     * @notice Converts an amount of LP into their estimated underlying value.
     * @dev Uses get_virtual_price which is less suceptible to manipulation.
     *  But is also less accurate to how much could be withdrawn.
     * @param _lpAmount Amount of LP to convert.
     * @return The estimated value in the underlying.
     */
    function _lpToUnderlying(uint256 _lpAmount) internal view returns (uint256) {
        return _lpAmount.scaledMul(curvePool.get_virtual_price());
    }
}",1503
RealWorld_TA_112_IEthPool_RealWorld_20240815140731.log,112,IEthPool,23058,1597,24655,144.0,0.14723,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IEthPool {
    function initialize(
        string memory name_,
        uint256 depositCap_,
        address vault_
    ) external returns (bool);
}",55
RealWorld_TA_112_MockLpToken_RealWorld_20240815091759.log,112,MockLpToken,25380,2686,28066,100.0,0.18062,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../LpToken.sol"";

contract MockLpToken is LpToken {
    // solhint-disable-next-line func-name-mixedcase
    function mint_for_testing(address account, uint256 mintAmount) external {
        _mint(account, mintAmount);
    }
}",79
RealWorld_TA_112_LpToken_RealWorld_20240815081113.log,112,LpToken,67247,2846,70093,98.0,0.393155,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""../libraries/ScaledMath.sol"";
import ""../interfaces/ILpToken.sol"";
import ""../interfaces/pool/ILiquidityPool.sol"";
import ""../libraries/Errors.sol"";

contract LpToken is ILpToken, ERC20Upgradeable {
    using ScaledMath for uint256;

    uint8 private _decimals;

    address public override minter;

    /**
     * @notice Make a function only callable by the minter contract.
     * @dev Fails if msg.sender is not the minter.
     */
    modifier onlyMinter() {
        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    constructor() ERC20Upgradeable() {}

    function initialize(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address _minter
    ) external override initializer returns (bool) {
        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        __ERC20_init(name_, symbol_);
        _decimals = decimals_;
        minter = _minter;
        return true;
    }

    /**
     * @notice Mint tokens.
     * @param account Account from which tokens should be burned.
     * @param amount Amount of tokens to mint.
     */
    function mint(address account, uint256 amount) external override onlyMinter {
        _mint(account, amount);
    }

    /**
     * @notice Burns tokens of msg.sender.
     * @param amount Amount of tokens to burn.
     */
    function burn(uint256 amount) external override {
        _burn(msg.sender, amount);
    }

    /**
     * @notice Burn tokens.
     * @param owner Account from which tokens should be burned.
     * @param burnAmount Amount of tokens to burn.
     * @return Aamount of tokens burned.
     */
    function burn(address owner, uint256 burnAmount)
        external
        override
        onlyMinter
        returns (uint256)
    {
        _burn(owner, burnAmount);
        return burnAmount;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }

    /**
     * @dev We notify that LP tokens have been transfered
     * this is currently used to keep track of the withdrawal fees
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers
    }
}",582
RealWorld_TA_112_CTokenInterfaces_RealWorld_20240815152320.log,112,CTokenInterfaces,222501,2693,225194,153.0,1.166365,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./ComptrollerInterface.sol"";
import ""./InterestRateModel.sol"";

contract CTokenStorage {
    /**
     * @dev Guard variable for re-entrancy checks
     */
    bool internal _notEntered;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token
     */
    uint8 public decimals;

    /**
     * @notice Maximum borrow rate that can ever be applied (.0005% / block)
     */

    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;

    /**
     * @notice Maximum fraction of interest that can be set aside for reserves
     */
    uint256 internal constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice Contract which oversees inter-cToken operations
     */
    ComptrollerInterface public comptroller;

    /**
     * @notice Model which tells what the current interest rate should be
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)
     */
    uint256 internal initialExchangeRateMantissa;

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint256 public reserveFactorMantissa;

    /**
     * @notice Block number that interest was last accrued at
     */
    uint256 public accrualBlockNumber;

    /**
     * @notice Accumulator of the total earned interest rate since the opening of the market
     */
    uint256 public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint256 public totalBorrows;

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint256 public totalReserves;

    /**
     * @notice Total number of tokens in circulation
     */
    uint256 public totalSupply;

    /**
     * @notice Official record of token balances for each account
     */
    mapping(address => uint256) internal accountTokens;

    /**
     * @notice Approved token transfer amounts on behalf of others
     */
    mapping(address => mapping(address => uint256)) internal transferAllowances;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint256 principal;
        uint256 interestIndex;
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) internal accountBorrows;
}

abstract contract CTokenInterface is CTokenStorage {
    /**
     * @notice Indicator that this is a CToken contract (for inspection)
     */
    bool public constant isCToken = true;

    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(
        uint256 cashPrior,
        uint256 interestAccumulated,
        uint256 borrowIndex,
        uint256 totalBorrows
    );

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(
        address borrower,
        uint256 borrowAmount,
        uint256 accountBorrows,
        uint256 totalBorrows
    );

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(
        address payer,
        address borrower,
        uint256 repayAmount,
        uint256 accountBorrows,
        uint256 totalBorrows
    );

    /**
     * @notice Event emitted when a borrow is liquidated
     */
    event LiquidateBorrow(
        address liquidator,
        address borrower,
        uint256 repayAmount,
        address cTokenCollateral,
        uint256 seizeTokens
    );

    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when comptroller is changed
     */
    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    event NewMarketInterestRateModel(
        InterestRateModel oldInterestRateModel,
        InterestRateModel newInterestRateModel
    );

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are added
     */
    event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);

    /**
     * @notice EIP20 Transfer event
     */
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /**
     * @notice EIP20 Approval event
     */
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /**
     * @notice Failure event
     */
    // event Failure(uint256 error, uint256 info, uint256 detail);

    /*** User Interface ***/

    function transfer(address dst, uint256 amount) external virtual returns (bool);

    function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external virtual returns (bool);

    function approve(address spender, uint256 amount) external virtual returns (bool);

    function allowance(address owner, address spender) external view virtual returns (uint256);

    function balanceOf(address owner) external view virtual returns (uint256);

    function balanceOfUnderlying(address owner) external virtual returns (uint256);

    function getAccountSnapshot(address account)
        external
        view
        virtual
        returns (
            uint256,
            uint256,
            uint256,
            uint256
        );

    function borrowRatePerBlock() external view virtual returns (uint256);

    function supplyRatePerBlock() external view virtual returns (uint256);

    function totalBorrowsCurrent() external virtual returns (uint256);

    function borrowBalanceCurrent(address account) external virtual returns (uint256);

    function borrowBalanceStored(address account) public view virtual returns (uint256);

    function exchangeRateCurrent() public virtual returns (uint256);

    function exchangeRateStored() public view virtual returns (uint256);

    function getCash() external view virtual returns (uint256);

    function accrueInterest() public virtual returns (uint256);

    function seize(
        address liquidator,
        address borrower,
        uint256 seizeTokens
    ) external virtual returns (uint256);

    /*** Admin Functions ***/

    function _setPendingAdmin(address payable newPendingAdmin) external virtual returns (uint256);

    function _acceptAdmin() external virtual returns (uint256);

    function _setComptroller(ComptrollerInterface newComptroller) public virtual returns (uint256);

    function _setReserveFactor(uint256 newReserveFactorMantissa) external virtual returns (uint256);

    function _reduceReserves(uint256 reduceAmount) external virtual returns (uint256);

    function _setInterestRateModel(InterestRateModel newInterestRateModel)
        public
        virtual
        returns (uint256);
}

contract CErc20Storage {
    /**
     * @notice Underlying asset for this CToken
     */
    address public underlying;
}

abstract contract CErc20Interface is CErc20Storage {
    /*** User Interface ***/

    function mint(uint256 mintAmount) external payable virtual returns (uint256);

    function redeem(uint256 redeemTokens) external virtual returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);

    function borrow(uint256 borrowAmount) external virtual returns (uint256);

    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);

    function repayBorrowBehalf(address borrower, uint256 repayAmount)
        external
        virtual
        returns (uint256);

    function liquidateBorrow(
        address borrower,
        uint256 repayAmount,
        CTokenInterface cTokenCollateral
    ) external virtual returns (uint256);

    /*** Admin Functions ***/

    function _addReserves(uint256 addAmount) external virtual returns (uint256);
}

interface CEthInterface {
    /*** User Interface ***/

    function mint() external payable returns (uint256);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function borrow(uint256 borrowAmount) external returns (uint256);

    function repayBorrow(uint256 repayAmount) external payable returns (uint256);

    function repayBorrowBehalf(address borrower, uint256 repayAmount)
        external
        payable
        returns (uint256);

    function liquidateBorrow(
        address borrower,
        uint256 repayAmount,
        CTokenInterface cTokenCollateral
    ) external payable returns (uint256);
}

contract CDelegationStorage {
    /**
     * @notice Implementation address for this contract
     */
    address public implementation;
}

abstract contract CDelegatorInterface is CDelegationStorage {
    /**
     * @notice Emitted when implementation is changed
     */
    event NewImplementation(address oldImplementation, address newImplementation);

    /**
     * @notice Called by the admin to update the implementation of the delegator
     * @param implementation_ The address of the new implementation for delegation
     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation
     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation
     */
    function _setImplementation(
        address implementation_,
        bool allowResign,
        bytes memory becomeImplementationData
    ) public virtual;
}

abstract contract CDelegateInterface is CDelegationStorage {
    /**
     * @notice Called by the delegator on a delegate to initialize it for duty
     * @dev Should revert if any issues arise which make it unfit for delegation
     * @param data The encoded bytes data for any initialization
     */
    function _becomeImplementation(bytes memory data) public virtual;

    /**
     * @notice Called by the delegator on a delegate to forfeit its responsibility
     */
    function _resignImplementation() public virtual;
}

abstract contract CEther {
    function repayBorrowBehalf(address borrower) external payable virtual returns (uint256);
}",2461
RealWorld_TA_112_IRewardStaking_RealWorld_20240815150011.log,112,IRewardStaking,33089,1531,34620,146.0,0.196065,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IRewardStaking {
    function stakeFor(address, uint256) external;

    function stake(uint256) external;

    function stakeAll() external returns (bool);

    function withdraw(uint256 amount, bool claim) external returns (bool);

    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);

    function earned(address account) external view returns (uint256);

    function getReward() external;

    function getReward(address _account, bool _claimExtras) external;

    function extraRewardsLength() external view returns (uint256);

    function extraRewards(uint256 _pid) external view returns (address);

    function rewardToken() external view returns (address);

    function balanceOf(address account) external view returns (uint256);
}",175
RealWorld_TA_112_ICrvDepositor_RealWorld_20240815142120.log,112,ICrvDepositor,24198,1570,25768,156.0,0.15239,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

interface ICrvDepositor {
    function deposit(
        uint256 _amount,
        bool _lock,
        address _stakeAddress
    ) external;

    function depositAll(bool _lock, address _stakeAddress) external;
}",68
RealWorld_TA_112_IErc20Pool_RealWorld_20240815141303.log,112,IErc20Pool,23456,1657,25113,167.0,0.15042,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IErc20Pool {
    function initialize(
        string memory name_,
        address underlying_,
        uint256 depositCap_,
        address vault_
    ) external returns (bool);
}",60
RealWorld_TA_112_VestedEscrowRevocable_RealWorld_20240815112743.log,112,VestedEscrowRevocable,87319,4572,91891,164.0,0.528035,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/*
Rewrite of Convex Finance's Vested Escrow
found at https://github.com/convex-eth/platform/blob/main/contracts/contracts/VestedEscrow.sol
Changes:
- remove safe math (default from Solidity >=0.8)
- remove claim and stake logic
- remove safeTransferFrom logic and add support for ""airdropped"" reward token
- add revoke logic to allow admin to stop vesting for a recipient
*/

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../libraries/Errors.sol"";

import ""./VestedEscrow.sol"";

contract VestedEscrowRevocable is VestedEscrow {
    using SafeERC20 for IERC20;

    address public immutable treasury;

    uint256 private _vestedBefore;

    mapping(address => uint256) public revokedTime;

    event Revoked(address indexed user, uint256 revokedAmount);

    constructor(
        address rewardToken_,
        uint256 starttime_,
        uint256 endtime_,
        address fundAdmin_,
        address treasury_
    ) VestedEscrow(rewardToken_, starttime_, endtime_, fundAdmin_) {
        treasury = treasury_;
        holdingContract[treasury_] = address(new EscrowTokenHolder(rewardToken_));
    }

    function claim() external override {
        claim(msg.sender);
    }

    function revoke(address _recipient) external returns (bool) {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        require(revokedTime[_recipient] == 0, ""Recipient already revoked"");
        require(_recipient != treasury, ""Treasury cannot be revoked!"");
        revokedTime[_recipient] = block.timestamp;
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);

        uint256 initialAmount = initialLocked[_recipient];
        uint256 revokedAmount = initialAmount - vested;
        rewardToken.safeTransferFrom(
            holdingContract[_recipient],
            holdingContract[treasury],
            revokedAmount
        );
        initialLocked[treasury] += initialAmount;
        totalClaimed[treasury] += vested;
        _vestedBefore += vested;
        emit Revoked(_recipient, revokedAmount);
        return true;
    }

    function vestedOf(address _recipient) external view override returns (uint256) {
        if (_recipient == treasury) {
            return _totalVestedOf(_recipient, block.timestamp) - _vestedBefore;
        }

        uint256 timeRevoked = revokedTime[_recipient];
        if (timeRevoked != 0) {
            return _totalVestedOf(_recipient, timeRevoked);
        }
        return _totalVestedOf(_recipient, block.timestamp);
    }

    function balanceOf(address _recipient) external view override returns (uint256) {
        uint256 timestamp = block.timestamp;
        uint256 timeRevoked = revokedTime[_recipient];
        if (timeRevoked != 0) {
            timestamp = timeRevoked;
        }
        return _balanceOf(_recipient, timestamp);
    }

    function lockedOf(address _recipient) external view override returns (uint256) {
        if (revokedTime[_recipient] != 0) {
            return 0;
        }
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);
        return initialLocked[_recipient] - vested;
    }

    function claim(address _recipient) public override nonReentrant {
        uint256 timestamp = block.timestamp;
        if (revokedTime[msg.sender] != 0) {
            timestamp = revokedTime[msg.sender];
        }
        _claimUntil(_recipient, timestamp);
    }
}",805
RealWorld_TA_112_IInflationManager_RealWorld_20240815134900.log,112,IInflationManager,73204,2118,75322,169.0,0.40838,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IInflationManager {
    event KeeperGaugeListed(address indexed pool, address indexed keeperGauge);
    event AmmGaugeListed(address indexed token, address indexed ammGauge);
    event KeeperGaugeDelisted(address indexed pool, address indexed keeperGauge);
    event AmmGaugeDelisted(address indexed token, address indexed ammGauge);

    /** Pool functions */

    function setKeeperGauge(address pool, address _keeperGauge) external returns (bool);

    function setAmmGauge(address token, address _ammGauge) external returns (bool);

    function getAllAmmGauges() external view returns (address[] memory);

    function getLpRateForStakerVault(address stakerVault) external view returns (uint256);

    function getKeeperRateForPool(address pool) external view returns (uint256);

    function getAmmRateForToken(address token) external view returns (uint256);

    function getKeeperWeightForPool(address pool) external view returns (uint256);

    function getAmmWeightForToken(address pool) external view returns (uint256);

    function getLpPoolWeight(address pool) external view returns (uint256);

    function getKeeperGaugeForPool(address pool) external view returns (address);

    function getAmmGaugeForToken(address token) external view returns (address);

    function isInflationWeightManager(address account) external view returns (bool);

    function removeStakerVaultFromInflation(address stakerVault, address lpToken) external;

    function addGaugeForVault(address lpToken) external returns (bool);

    function whitelistGauge(address gauge) external;

    function checkpointAllGauges() external returns (bool);

    function mintRewards(address beneficiary, uint256 amount) external;

    function addStrategyToDepositStakerVault(address depositStakerVault, address strategyPool)
        external
        returns (bool);

    /** Weight setter functions **/

    function prepareLpPoolWeight(address lpToken, uint256 newPoolWeight) external returns (bool);

    function prepareAmmTokenWeight(address token, uint256 newTokenWeight) external returns (bool);

    function prepareKeeperPoolWeight(address pool, uint256 newPoolWeight) external returns (bool);

    function executeLpPoolWeight(address lpToken) external returns (uint256);

    function executeAmmTokenWeight(address token) external returns (uint256);

    function executeKeeperPoolWeight(address pool) external returns (uint256);

    function batchPrepareLpPoolWeights(address[] calldata lpTokens, uint256[] calldata weights)
        external
        returns (bool);

    function batchPrepareAmmTokenWeights(address[] calldata tokens, uint256[] calldata weights)
        external
        returns (bool);

    function batchPrepareKeeperPoolWeights(address[] calldata pools, uint256[] calldata weights)
        external
        returns (bool);

    function batchExecuteLpPoolWeights(address[] calldata lpTokens) external returns (bool);

    function batchExecuteAmmTokenWeights(address[] calldata tokens) external returns (bool);

    function batchExecuteKeeperPoolWeights(address[] calldata pools) external returns (bool);
}",685
RealWorld_TA_112_IvlCvxExtraRewardDistribution_RealWorld_20240815151219.log,112,IvlCvxExtraRewardDistribution,24362,1560,25922,122.0,0.15301,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

interface IvlCvxExtraRewardDistribution {
    function getReward(address _account, address _token) external;

    function getRewards(address _account, address[] calldata _tokens) external;

    function forfeitRewards(address _token, uint256 _index) external;
}",75
RealWorld_TA_112_TopUpAction_RealWorld_20240815095407.log,112,TopUpAction,686128,1970,688098,152.0,3.47004,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""../../../interfaces/IGasBank.sol"";
import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/ISwapperRegistry.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/IStakerVault.sol"";
import ""../../../interfaces/ISwapper.sol"";
import ""../../../interfaces/actions/topup/ITopUpHandler.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";
import ""../../../interfaces/actions/IActionFeeHandler.sol"";

import ""../../../libraries/AddressProviderHelpers.sol"";
import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/EnumerableExtensions.sol"";

import ""../../access/Authorization.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice The logic here should really be part of the top-up action
 * but is split in a library to circumvent the byte-code size limit
 */
library TopUpActionLibrary {
    using SafeERC20 for IERC20;
    using ScaledMath for uint256;
    using AddressProviderHelpers for IAddressProvider;

    function lockFunds(
        address stakerVaultAddress,
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) external {
        uint256 amountLeft = lockAmount;
        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);

        // stake deposit amount
        if (depositAmount > 0) {
            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;
            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);
            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);
            stakerVault.stake(depositAmount);
            stakerVault.increaseActionLockedBalance(payer, depositAmount);
            amountLeft -= depositAmount;
        }

        // use stake vault allowance if available and required
        if (amountLeft > 0) {
            uint256 balance = stakerVault.balanceOf(payer);
            uint256 allowance = stakerVault.allowance(payer, address(this));
            uint256 availableFunds = balance < allowance ? balance : allowance;
            if (availableFunds >= amountLeft) {
                stakerVault.transferFrom(payer, address(this), amountLeft);
                amountLeft = 0;
            }
        }

        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function calcExchangeAmount(
        IAddressProvider addressProvider,
        address token,
        address actionToken,
        uint256 amount
    ) external view returns (uint256) {
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        uint256 rate = pool.exchangeRate();
        address underlying = pool.getUnderlying();
        if (underlying == actionToken) {
            return amount.scaledDivRoundUp(rate);
        }

        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);
        uint256 swapperRate = swapper.getRate(underlying, actionToken);
        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));
    }

    function getSwapper(
        IAddressProvider addressProvider,
        address underlying,
        address actionToken
    ) public view returns (ISwapper) {
        address swapperRegistry = addressProvider.getSwapperRegistry();
        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);
        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);
        return ISwapper(swapper);
    }
}

contract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {
    using ScaledMath for uint256;
    using ScaledMath for uint128;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using AddressProviderHelpers for IAddressProvider;

    /**
     * @dev Temporary struct to hold local variables in execute
     * and avoid the stack being ""too deep""
     */
    struct ExecuteLocalVars {
        uint256 minActionAmountToTopUp;
        uint256 actionTokenAmount;
        uint256 depositTotalFeesAmount;
        uint256 actionAmountWithFees;
        uint256 userFactor;
        uint256 rate;
        uint256 depositAmountWithFees;
        uint256 depositAmountWithoutFees;
        uint256 actionFee;
        uint256 totalActionTokenAmount;
        uint128 totalTopUpAmount;
        bool success;
        bytes topupResult;
        uint256 gasBankBalance;
        uint256 initialGas;
        uint256 gasConsumed;
        uint256 userGasPrice;
        uint256 estimatedRequiredGas;
        uint256 estimatedRequiredWeiForGas;
        uint256 requiredWeiForGas;
        uint256 reimbursedWeiForGas;
        address underlying;
        bool removePosition;
    }

    EnumerableSet.AddressSet private _usableTokens;

    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;

    bytes32 internal constant _ACTION_FEE_KEY = ""ActionFee"";
    bytes32 internal constant _FEE_HANDLER_KEY = ""FeeHandler"";
    bytes32 internal constant _TOP_UP_HANDLER_KEY = ""TopUpHandler"";
    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = ""EstimatedGasUsage"";
    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = ""MaxSwapperSlippage"";

    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;
    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;
    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;

    EnumerableSet.Bytes32Set internal _supportedProtocols;

    /// @notice mapping of (payer -> account -> protocol -> Record)
    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;

    mapping(address => RecordMeta[]) internal _userPositions;

    EnumerableSet.AddressSet internal _usersWithPositions;

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        addressProvider = controller.addressProvider();
        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);
    }

    receive() external payable {
        // solhint-disable-previous-line no-empty-blocks
    }

    function initialize(
        address feeHandler,
        bytes32[] calldata protocols,
        address[] calldata handlers
    ) external initializer onlyGovernance {
        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);
        _setConfig(_FEE_HANDLER_KEY, feeHandler);
        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);
        for (uint256 i = 0; i < protocols.length; i++) {
            bytes32 protocolKey = _getProtocolKey(protocols[i]);
            _setConfig(protocolKey, handlers[i]);
            _updateTopUpHandler(protocols[i], address(0), handlers[i]);
        }
    }

    /**
     * @notice Register a top up action.
     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).
     * @param account Account to be topped up (first 20 bytes will typically be the address).
     * @param depositAmount Amount of `depositToken` that will be locked.
     * @param protocol Protocol which holds position to be topped up.
     * @param record containing the data for the position to register
     */
    function register(
        bytes32 account,
        bytes32 protocol,
        uint128 depositAmount,
        Record memory record
    ) external payable returns (bool) {
        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);
        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);
        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);
        require(
            _positions[msg.sender][account][protocol].threshold == 0,
            Error.POSITION_ALREADY_EXISTS
        );
        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);
        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);

        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *
            record.maxFee *
            getEstimatedGasUsage();

        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);

        uint256 totalLockAmount = _calcExchangeAmount(
            record.depositToken,
            record.actionToken,
            record.totalTopUpAmount
        );
        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);

        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);

        record.depositTokenBalance = uint128(totalLockAmount);
        _positions[msg.sender][account][protocol] = record;
        _userPositions[msg.sender].push(RecordMeta(account, protocol));
        _usersWithPositions.add(msg.sender);

        emit Register(
            account,
            protocol,
            record.threshold,
            msg.sender,
            record.depositToken,
            totalLockAmount,
            record.actionToken,
            record.singleTopUpAmount,
            record.totalTopUpAmount,
            record.maxFee,
            record.extra
        );
        return true;
    }

    /**
     * @notice See overloaded version of `execute` for more details.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external override returns (bool) {
        return execute(payer, account, beneficiary, protocol, 0);
    }

    /**
     * @notice Delete a position to back on the given protocol for `account`.
     * @param account Account holding the position.
     * @param protocol Protocol the position is held on.
     * @param unstake If the tokens should be unstaked from vault.
     * @return `true` if successful.
     */
    function resetPosition(
        bytes32 account,
        bytes32 protocol,
        bool unstake
    ) external override returns (bool) {
        address payer = msg.sender;
        Record memory position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);

        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist
        IStakerVault staker = IStakerVault(vault);
        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);
        if (unstake) {
            staker.unstake(position.depositTokenBalance);
            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);
        } else {
            staker.transfer(payer, position.depositTokenBalance);
        }

        _removePosition(payer, account, protocol);
        addressProvider.getGasBank().withdrawUnused(payer);
        return true;
    }

    /**
     * @notice Execute top up handler update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @param protocol Protocol for which a new handler should be executed.
     * @return Address of new handler.
     */
    function executeTopUpHandler(bytes32 protocol) external override returns (address) {
        address oldHandler = _getHandler(protocol, false);
        address newHandler = _executeAddress(_getProtocolKey(protocol));

        _updateTopUpHandler(protocol, oldHandler, newHandler);
        return newHandler;
    }

    /**
     * @notice Reset new top up handler deadline for a protocol.
     * @param protocol Protocol for which top up handler deadline should be reset.
     * @return `true` if successful.
     */
    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getProtocolKey(protocol));
    }

    /**
     * @notice Prepare action fee update.
     * @param newActionFee New fee to set.
     * @return `true` if success.
     */
    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {
        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);
        return _prepare(_ACTION_FEE_KEY, newActionFee);
    }

    /**
     * @notice Execute action fee update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeActionFee() external override returns (uint256) {
        return _executeUInt256(_ACTION_FEE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetActionFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ACTION_FEE_KEY);
    }

    /**
     * @notice Prepare swapper slippage update.
     * @param newSwapperSlippage New slippage to set.
     * @return `true` if success.
     */
    function prepareSwapperSlippage(uint256 newSwapperSlippage)
        external
        onlyGovernance
        returns (bool)
    {
        require(
            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&
                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,
            Error.INVALID_AMOUNT
        );
        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);
    }

    /**
     * @notice Execute swapper slippage update (with time delay enforced).
     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeSwapperSlippage() external override returns (uint256) {
        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /**
     * @notice Reset action fee deadline.
     * @return `true` if successful.
     */
    function resetSwapperSlippage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);
    }

    /** Set fee handler */
    /**
     * @notice Prepare update of fee handler.
     * @param handler New fee handler.
     * @return `true` if success.
     */
    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {
        return _prepare(_FEE_HANDLER_KEY, handler);
    }

    /**
     * @notice Execute update of fee handler (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return `true` if successful.
     */
    function executeFeeHandler() external override returns (address) {
        return _executeAddress(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Reset the handler deadline.
     * @return `true` if success.
     */
    function resetFeeHandler() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_FEE_HANDLER_KEY);
    }

    /**
     * @notice Prepare update of estimated gas usage.
     * @param gasUsage New estimated gas usage.
     * @return `true` if success.
     */
    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {
        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);
    }

    /**
     * @notice Execute update of gas usage (with time delay enforced).
     * @return `true` if successful.
     */
    function executeEstimatedGasUsage() external returns (uint256) {
        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Reset the gas usage deadline.
     * @return `true` if success.
     */
    function resetGasUsage() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);
    }

    /**
     * @notice Add a new deposit token that is supported by the action.
     * @dev There is a separate check for whether the usable token (i.e. deposit token)
     *      is swappable for some action token.
     * @param token Address of deposit token that can be used by the action.
     */
    function addUsableToken(address token) external override onlyGovernance returns (bool) {
        return _usableTokens.add(token);
    }

    /**
     * @notice Computes the total amount of ETH (as wei) required to pay for all
     * the top-ups assuming the maximum gas price and the current estimated gas
     * usage of a top-up
     */
    function getEthRequiredForGas(address payer) external view override returns (uint256) {
        uint256 totalEthRequired = 0;
        RecordMeta[] memory userRecordsMeta = _userPositions[payer];
        uint256 gasUsagePerCall = getEstimatedGasUsage();
        uint256 length = userRecordsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta memory meta = userRecordsMeta[i];
            Record memory record = _positions[payer][meta.account][meta.protocol];
            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);
            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;
        }
        return totalEthRequired;
    }

    /**
     * @notice Returns a list of positions for the given payer
     */
    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {
        return _userPositions[payer];
    }

    /**
     * @notice Get a list supported protocols.
     * @return List of supported protocols.
     */
    function getSupportedProtocols() external view override returns (bytes32[] memory) {
        uint256 length = _supportedProtocols.length();
        bytes32[] memory protocols = new bytes32[](length);
        for (uint256 i = 0; i < length; i++) {
            protocols[i] = _supportedProtocols.at(i);
        }
        return protocols;
    }

    /*
     * @notice Gets a list of users that have an active position.
     * @dev Uses cursor pagination.
     * @param cursor The cursor for pagination (should start at 0 for first call).
     * @param howMany Maximum number of users to return in this pagination request.
     * @return users List of users that have an active position.
     * @return nextCursor The cursor to use for the next pagination request.
     */
    function usersWithPositions(uint256 cursor, uint256 howMany)
        external
        view
        override
        returns (address[] memory users, uint256 nextCursor)
    {
        uint256 length = _usersWithPositions.length();
        if (cursor >= length) return (new address[](0), 0);
        if (howMany >= length - cursor) {
            howMany = length - cursor;
        }

        address[] memory usersWithPositions_ = new address[](howMany);
        for (uint256 i = 0; i < howMany; i++) {
            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);
        }

        return (usersWithPositions_, cursor + howMany);
    }

    /**
     * @notice Get a list of all tokens usable for this action.
     * @dev This refers to all tokens that can be used as deposit tokens.
     * @return Array of addresses of usable tokens.
     */
    function getUsableTokens() external view override returns (address[] memory) {
        return _usableTokens.toArray();
    }

    /**
     * @notice Retrieves the topup handler for the given `protocol`
     */
    function getTopUpHandler(bytes32 protocol) external view returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice Successfully tops up a position if it's conditions are met.
     * @dev pool and vault funds are rebalanced after withdrawal for top up
     * @param payer Account that pays for the top up.
     * @param account Account owning the position for top up.
     * @param beneficiary Address of the keeper's wallet for fee accrual.
     * @param protocol Protocol of the top up position.
     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas
     * @return `true` if successful.
     */
    function execute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol,
        uint256 maxWeiForGas
    ) public override returns (bool) {
        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);

        ExecuteLocalVars memory vars;

        vars.initialGas = gasleft();

        Record storage position = _positions[payer][account][protocol];
        require(position.threshold != 0, Error.NO_POSITION_EXISTS);
        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);

        address topUpHandler = _getHandler(protocol, true);
        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);

        // ensure that the position is actually below its set user factor threshold
        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);

        IGasBank gasBank = addressProvider.getGasBank();

        // fail early if the user does not have enough funds in the gas bank
        // to cover the cost of the transaction
        vars.estimatedRequiredGas = getEstimatedGasUsage();
        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;

        // compute the gas price that the user will be paying
        vars.userGasPrice = block.basefee + position.priorityFee;
        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;
        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;

        // ensure the current position allows for the gas to be paid
        require(
            vars.estimatedRequiredWeiForGas <=
                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,
            Error.ESTIMATED_GAS_TOO_HIGH
        );

        vars.gasBankBalance = gasBank.balanceOf(payer);
        // ensure the user has enough funds in the gas bank to cover the gas
        require(
            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,
            Error.GAS_BANK_BALANCE_TOO_LOW
        );

        vars.totalTopUpAmount = position.totalTopUpAmount;
        vars.actionFee = getActionFee();
        // add top-up fees to top-up amount
        vars.minActionAmountToTopUp = position.singleTopUpAmount;
        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(
            ScaledMath.ONE + vars.actionFee
        );

        // if the amount that we want to top-up (including fees) is higher than
        // the available topup amount, we lower this down to what is left of the position
        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {
            vars.actionAmountWithFees = vars.totalTopUpAmount;
            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(
                ScaledMath.ONE + vars.actionFee
            );
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);
        vars.underlying = pool.getUnderlying();
        vars.rate = pool.exchangeRate();

        ISwapper swapper;

        if (vars.underlying != position.actionToken) {
            swapper = _getSwapper(vars.underlying, position.actionToken);
            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));
        }

        // compute the deposit tokens amount with and without fees
        // we will need to unstake the amount with fees and to
        // swap the amount without fees into action tokens
        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);
        if (position.depositTokenBalance < vars.depositAmountWithFees) {
            vars.depositAmountWithFees = position.depositTokenBalance;
            vars.minActionAmountToTopUp =
                (vars.depositAmountWithFees * vars.rate) /
                (ScaledMath.ONE + vars.actionFee);
        }

        // compute amount of LP tokens needed to pay for action
        // rate is expressed in actionToken per depositToken
        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);
        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;

        // will revert if vault does not exist
        address vault = addressProvider.getStakerVault(position.depositToken);

        // unstake deposit tokens including fees
        IStakerVault(vault).unstake(vars.depositAmountWithFees);
        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);

        // swap the amount without the fees
        // as the fees are paid in deposit token, not in action token
        // Redeem first and use swapper only if the underlying tokens are not action tokens
        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);

        if (address(swapper) != address(0)) {
            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(
                getSwapperSlippage()
            );
            _approve(vars.underlying, address(swapper));
            vars.actionTokenAmount = swapper.swap(
                vars.underlying,
                position.actionToken,
                vars.actionTokenAmount,
                vars.minActionAmountToTopUp
            );
        }

        // compute how much of action token was actually redeemed and add fees to it
        // this is to ensure that no funds get locked inside the contract
        vars.totalActionTokenAmount =
            vars.actionTokenAmount +
            vars.depositTotalFeesAmount.scaledMul(vars.rate);

        // at this point, we have exactly `vars.actionTokenAmount`
        // (at least `position.singleTopUpAmount`) of action token
        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract
        // solhint-disable-next-line avoid-low-level-calls
        (vars.success, vars.topupResult) = topUpHandler.delegatecall(
            abi.encodeWithSignature(
                ""topUp(bytes32,address,uint256,bytes)"",
                account,
                position.actionToken,
                vars.actionTokenAmount,
                position.extra
            )
        );

        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);

        // totalTopUpAmount is updated to reflect the new ""balance"" of the position
        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {
            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);
        } else {
            position.totalTopUpAmount = 0;
        }

        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);

        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;
        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);
        if (vars.removePosition) {
            if (position.depositTokenBalance > 0) {
                // transfer any unused locked tokens to the payer
                IStakerVault(vault).transfer(payer, position.depositTokenBalance);
                IStakerVault(vault).decreaseActionLockedBalance(
                    payer,
                    position.depositTokenBalance
                );
            }
            _removePosition(payer, account, protocol);
        }

        emit TopUp(
            account,
            protocol,
            payer,
            position.depositToken,
            vars.depositAmountWithFees,
            position.actionToken,
            vars.actionTokenAmount
        );

        // compute gas used and reimburse the keeper by using the
        // funds of payer in the gas bank
        // TODO: add constant gas consumed for transfer and tx prologue
        vars.gasConsumed = vars.initialGas - gasleft();

        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;
        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {
            vars.reimbursedWeiForGas = vars.gasBankBalance;
        }

        // ensure that the keeper is not overpaying
        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;
        require(
            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,
            Error.GAS_TOO_HIGH
        );
        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);
        if (vars.removePosition) {
            gasBank.withdrawUnused(payer);
        }

        return true;
    }

    /**
     * @notice Prepare new top up handler fee update.
     * @dev Setting the addres to 0 means that the protocol will no longer be supported.
     * @param protocol Protocol for which a new handler should be prepared.
     * @param newHandler Address of new handler.
     * @return `true` if success.
     */
    function prepareTopUpHandler(bytes32 protocol, address newHandler)
        public
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getProtocolKey(protocol), newHandler);
    }

    /**
     * @notice Check if action can be executed.
     * @param protocol for which to get the health factor
     * @param account for which to get the health factor
     * @param extra data to be used by the topup handler
     * @return healthFactor of the position
     */
    function getHealthFactor(
        bytes32 protocol,
        bytes32 account,
        bytes memory extra
    ) public view override returns (uint256 healthFactor) {
        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));
        return topUpHandler.getUserFactor(account, extra);
    }

    function getHandler(bytes32 protocol) public view override returns (address) {
        return _getHandler(protocol, false);
    }

    /**
     * @notice returns the current estimated gas usage
     */
    function getEstimatedGasUsage() public view returns (uint256) {
        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];
    }

    /**
     * @notice Returns the current action fee
     */
    function getActionFee() public view override returns (uint256) {
        return currentUInts256[_ACTION_FEE_KEY];
    }

    /**
     * @notice Returns the current max swapper slippage
     */
    function getSwapperSlippage() public view override returns (uint256) {
        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];
    }

    /**
     * @notice Returns the current fee handler
     */
    function getFeeHandler() public view override returns (address) {
        return currentAddresses[_FEE_HANDLER_KEY];
    }

    /**
     * @notice Get the record for a position.
     * @param payer Registered payer of the position.
     * @param account Address holding the position.
     * @param protocol Protocol where the position is held.
     */
    function getPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) public view override returns (Record memory) {
        return _positions[payer][account][protocol];
    }

    /**
     * @notice Check whether a token is usable as a deposit token.
     * @param token Address of token to check.
     * @return True if token is usable as a deposit token for this action.
     */
    function isUsable(address token) public view override returns (bool) {
        return _usableTokens.contains(token);
    }

    function _updateTopUpHandler(
        bytes32 protocol,
        address oldHandler,
        address newHandler
    ) internal {
        if (newHandler == address(0)) {
            _supportedProtocols.remove(protocol);
        } else if (oldHandler == address(0)) {
            _supportedProtocols.add(protocol);
        }
    }

    /**
     * @dev Pays fees to the feeHandler
     * @param payer The account who's position the fees are charged on
     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)
     * @param feeAmount The amount in tokens to pay as fees
     * @param depositToken The LpToken used to pay the fees
     */
    function _payFees(
        address payer,
        address beneficiary,
        uint256 feeAmount,
        address depositToken
    ) internal {
        address feeHandler = getFeeHandler();
        IERC20(depositToken).safeApprove(feeHandler, feeAmount);
        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);
    }

    /**
     * @dev ""Locks"" an amount of tokens on behalf of the TopUpAction
     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.
     * @param payer Owner of the funds to be locked
     * @param token Token to lock
     * @param lockAmount Minimum amount of `token` to lock
     * @param depositAmount Amount of `token` that was deposited.
     *                      If this is 0 then the staker vault allowance should be used.
     *                      If this is greater than `requiredAmount` more tokens will be locked.
     */
    function _lockFunds(
        address payer,
        address token,
        uint256 lockAmount,
        uint256 depositAmount
    ) internal {
        address stakerVaultAddress = addressProvider.getStakerVault(token);
        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);
    }

    function _removePosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        delete _positions[payer][account][protocol];
        _removeUserPosition(payer, account, protocol);
        if (_userPositions[payer].length == 0) {
            _usersWithPositions.remove(payer);
        }
        emit Deregister(payer, account, protocol);
    }

    function _removeUserPosition(
        address payer,
        bytes32 account,
        bytes32 protocol
    ) internal {
        RecordMeta[] storage positionsMeta = _userPositions[payer];
        uint256 length = positionsMeta.length;
        for (uint256 i = 0; i < length; i++) {
            RecordMeta storage positionMeta = positionsMeta[i];
            if (positionMeta.account == account && positionMeta.protocol == protocol) {
                positionsMeta[i] = positionsMeta[length - 1];
                positionsMeta.pop();
                return;
            }
        }
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token The token to approve for.
     * @param spender The spender to approve.
     */
    function _approve(address token, address spender) internal {
        if (IERC20(token).allowance(address(this), spender) > 0) return;
        IERC20(token).safeApprove(spender, type(uint256).max);
    }

    /**
     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.
     */
    function _calcExchangeAmount(
        address token,
        address actionToken,
        uint256 amount
    ) internal view returns (uint256) {
        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);
    }

    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {
        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);
    }

    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {
        address handler = currentAddresses[_getProtocolKey(protocol)];
        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);
        return handler;
    }

    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {
        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);
        address underlying = pool.getUnderlying();
        if (underlying == toToken) {
            return true;
        }
        address swapperRegistry = addressProvider.getSwapperRegistry();
        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);
    }

    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));
    }
}",8074
RealWorld_TA_112_IOracleProvider_RealWorld_20240815133205.log,112,IOracleProvider,30669,1540,32209,134.0,0.184145,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IOracleProvider {
    /// @notice Quotes the USD price of `baseAsset`
    /// @param baseAsset the asset of which the price is to be quoted
    /// @return the USD price of the asset
    function getPriceUSD(address baseAsset) external view returns (uint256);

    /// @notice Quotes the ETH price of `baseAsset`
    /// @param baseAsset the asset of which the price is to be quoted
    /// @return the ETH price of the asset
    function getPriceETH(address baseAsset) external view returns (uint256);
}",141
RealWorld_TA_112_VestedEscrow_RealWorld_20240815113806.log,112,VestedEscrow,129414,5241,134655,170.0,0.75189,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

/*
Rewrite of Convex Finance's Vested Escrow
found at https://github.com/convex-eth/platform/blob/main/contracts/contracts/VestedEscrow.sol
Changes:
- remove safe math (default from Solidity >=0.8)
- remove claim and stake logic
- remove safeTransferFrom logic and add support for ""airdropped"" reward token
*/

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import ""../../libraries/Errors.sol"";

contract EscrowTokenHolder {
    constructor(address rewardToken_) {
        IERC20(rewardToken_).approve(msg.sender, type(uint256).max);
    }
}

contract VestedEscrow is ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct FundingAmount {
        address recipient;
        uint256 amount;
    }

    IERC20 public immutable rewardToken;
    address public admin;
    address public fundAdmin;

    uint256 public immutable startTime;
    uint256 public immutable endTime;
    uint256 public totalTime;
    uint256 public initialLockedSupply;
    uint256 public unallocatedSupply;
    bool public initializedSupply;

    mapping(address => uint256) public initialLocked;
    mapping(address => uint256) public totalClaimed;
    mapping(address => address) public holdingContract;

    event Fund(address indexed recipient, uint256 reward);
    event Claim(address indexed user, uint256 amount);

    constructor(
        address rewardToken_,
        uint256 starttime_,
        uint256 endtime_,
        address fundAdmin_
    ) {
        require(starttime_ >= block.timestamp, ""start must be future"");
        require(endtime_ > starttime_, ""end must be greater"");

        rewardToken = IERC20(rewardToken_);
        startTime = starttime_;
        endTime = endtime_;
        totalTime = endtime_ - starttime_;
        admin = msg.sender;
        fundAdmin = fundAdmin_;
    }

    function setAdmin(address _admin) external {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        admin = _admin;
    }

    function setFundAdmin(address _fundadmin) external {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        fundAdmin = _fundadmin;
    }

    function initializeUnallocatedSupply() external returns (bool) {
        require(msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        require(!initializedSupply, ""Supply already initialized once"");
        unallocatedSupply = rewardToken.balanceOf(address(this));
        require(unallocatedSupply > 0, ""No reward tokens in contract"");
        initializedSupply = true;
        return true;
    }

    function fund(FundingAmount[] calldata amounts) external nonReentrant returns (bool) {
        require(msg.sender == fundAdmin || msg.sender == admin, Error.UNAUTHORIZED_ACCESS);
        require(initializedSupply, ""Supply must be initialized"");

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i].amount;
            address holdingAddress = holdingContract[amounts[i].recipient];
            if (holdingAddress == address(0)) {
                holdingAddress = address(new EscrowTokenHolder(address(rewardToken)));
                holdingContract[amounts[i].recipient] = holdingAddress;
            }
            rewardToken.safeTransfer(holdingAddress, amount);
            initialLocked[amounts[i].recipient] = initialLocked[amounts[i].recipient] + amount;
            totalAmount = totalAmount + amount;
            emit Fund(amounts[i].recipient, amount);
        }

        initialLockedSupply = initialLockedSupply + totalAmount;
        unallocatedSupply = unallocatedSupply - totalAmount;
        return true;
    }

    function claim() external virtual {
        _claimUntil(msg.sender, block.timestamp);
    }

    function vestedSupply() external view returns (uint256) {
        return _totalVested();
    }

    function lockedSupply() external view returns (uint256) {
        return initialLockedSupply - _totalVested();
    }

    function vestedOf(address _recipient) external view virtual returns (uint256) {
        return _totalVestedOf(_recipient, block.timestamp);
    }

    function balanceOf(address _recipient) external view virtual returns (uint256) {
        return _balanceOf(_recipient, block.timestamp);
    }

    function lockedOf(address _recipient) external view virtual returns (uint256) {
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);
        return initialLocked[_recipient] - vested;
    }

    function claim(address _recipient) public virtual nonReentrant {
        _claimUntil(_recipient, block.timestamp);
    }

    function _claimUntil(address _recipient, uint256 _time) internal {
        uint256 claimable = _balanceOf(msg.sender, _time);
        if (claimable == 0) return;
        totalClaimed[msg.sender] = totalClaimed[msg.sender] + claimable;
        rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable);

        emit Claim(msg.sender, claimable);
    }

    function _computeVestedAmount(uint256 locked, uint256 _time) internal view returns (uint256) {
        if (_time < startTime) {
            return 0;
        }
        uint256 elapsed = _time - startTime;
        return Math.min((locked * elapsed) / totalTime, locked);
    }

    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256) {
        return _computeVestedAmount(initialLocked[_recipient], _time);
    }

    function _totalVested() internal view returns (uint256) {
        return _computeVestedAmount(initialLockedSupply, block.timestamp);
    }

    function _balanceOf(address _recipient, uint256 _time) internal view returns (uint256) {
        uint256 vested = _totalVestedOf(_recipient, _time);
        return vested - totalClaimed[_recipient];
    }
}",1301
RealWorld_TA_112_BkdToken_RealWorld_20240815113330.log,112,BkdToken,36851,1815,38666,133.0,0.220555,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../interfaces/tokenomics/IBkdToken.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";

contract BkdToken is IBkdToken, ERC20 {
    using ScaledMath for uint256;

    address public immutable minter;

    constructor(
        string memory name_,
        string memory symbol_,
        address _minter
    ) ERC20(name_, symbol_) {
        minter = _minter;
    }

    /**
     * @notice Mints tokens for a given address.
     * @dev Fails if msg.sender is not the minter.
     * @param account Account for which tokens should be minted.
     * @param amount Amount of tokens to mint.
     */
    function mint(address account, uint256 amount) external override {
        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);
        _mint(account, amount);
    }
}",223
RealWorld_TA_112_AddressProviderMeta_RealWorld_20240815124238.log,112,AddressProviderMeta,32253,1308,33561,160.0,0.187425,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

library AddressProviderMeta {
    struct Meta {
        bool freezable;
        bool frozen;
    }

    function fromUInt(uint256 value) internal pure returns (Meta memory) {
        Meta memory meta;
        meta.freezable = (value & 1) == 1;
        meta.frozen = ((value >> 1) & 1) == 1;
        return meta;
    }

    function toUInt(Meta memory meta) internal pure returns (uint256) {
        uint256 value;
        value |= meta.freezable ? 1 : 0;
        value |= meta.frozen ? 1 << 1 : 0;
        return value;
    }
}",165
RealWorld_TA_112_MockKeeperGauge_RealWorld_20240815092628.log,112,MockKeeperGauge,25941,2019,27960,89.0,0.170085,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../Controller.sol"";
import ""../tokenomics/KeeperGauge.sol"";

contract MockKeeperGauge is KeeperGauge {
    constructor(IController _controller, address _pool) KeeperGauge(_controller, _pool) {}

    function advanceEpoch() external override returns (bool) {
        return true;
    }
}",88
RealWorld_TA_112_PriceOracle_RealWorld_20240815143134.log,112,PriceOracle,30032,1449,31481,138.0,0.17914,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

import ""./CToken.sol"";

abstract contract PriceOracle {
    /// @notice Indicator that this is a PriceOracle contract (for inspection)
    bool public constant isPriceOracle = true;

    /**
     * @notice Get the underlying price of a cToken asset
     * @param cToken The cToken to get the underlying price of
     * @return The underlying asset price mantissa (scaled by 1e18).
     *  Zero means the price is unavailable.
     */
    function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);
}",138
RealWorld_TA_112_MockErc20Pool_RealWorld_20240815091220.log,112,MockErc20Pool,55105,2803,57908,97.0,0.331585,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IStakerVault.sol"";
import ""../../interfaces/IVault.sol"";

import ""../pool/Erc20Pool.sol"";

contract MockErc20Pool is Erc20Pool {
    uint256 public currentTime;

    constructor(IController _controller) Erc20Pool(_controller) {}

    function setMinWithdrawalFee(uint256 _newFee) external onlyGovernance returns (bool) {
        _setConfig(_MIN_WITHDRAWAL_FEE_KEY, _newFee);
        return true;
    }

    function setMaxWithdrawalFee(uint256 _newFee) external onlyGovernance returns (bool) {
        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _newFee);
        return true;
    }

    function setWithdrawalFeeDecreasePeriod(uint256 period) external onlyGovernance returns (bool) {
        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, period);
        return true;
    }

    function setVault(address payable _vault) external {
        setVault(_vault, true);
    }

    function setMaxBackingReserveDeviationRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_RESERVE_DEVIATION_KEY, newRatio);
        _rebalanceVault();
    }

    function setRequiredBackingReserveRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_REQUIRED_RESERVES_KEY, newRatio);
        _rebalanceVault();
    }

    function setTime(uint256 _currentTime) external {
        currentTime = _currentTime;
    }

    function setVault(address payable _vault, bool updateAddressProvider) public onlyGovernance {
        if (updateAddressProvider) {
            addressProvider.updateVault(currentAddresses[_VAULT_KEY], _vault);
        }
        _setConfig(_VAULT_KEY, _vault);
    }

    function _getTime() internal view override returns (uint256) {
        return currentTime == 0 ? block.timestamp : currentTime;
    }
}",426
RealWorld_TA_112_MockLockingStrategy_RealWorld_20240815085024.log,112,MockLockingStrategy,43734,4574,48308,117.0,0.31015,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./MockErc20Strategy.sol"";
import ""./MockEthStrategy.sol"";

contract MockLockingStrategy {
    uint256 public amountLocked;

    function setAmountLocked(uint256 amount) external {
        amountLocked = amount;
    }
}

contract MockLockingErc20Strategy is MockErc20Strategy, MockLockingStrategy {
    using SafeERC20 for IERC20;

    constructor(IRoleManager roleManager, address _underlying)
        MockErc20Strategy(roleManager, _underlying)
    {}

    function withdrawAll() external override returns (uint256) {
        uint256 currentBalance = IERC20(_underlying).balanceOf(address(this));
        uint256 toWithdraw = currentBalance - amountLocked;
        IERC20(_underlying).safeTransfer(_vault, toWithdraw);
        return toWithdraw;
    }
}

contract MockLockingEthStrategy is MockEthStrategy, MockLockingStrategy {
    constructor(IRoleManager roleManager) MockEthStrategy(roleManager) {}

    function withdrawAll() external override returns (uint256) {
        uint256 currentBalance = address(this).balance;
        uint256 toWithdraw = currentBalance - amountLocked;
        payable(address(_vault)).transfer(toWithdraw);
        return toWithdraw;
    }
}",282
RealWorld_TA_112_AddressProviderHelpers_RealWorld_20240815123146.log,112,AddressProviderHelpers,60540,1425,61965,133.0,0.3312,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../interfaces/IGasBank.sol"";
import ""../interfaces/IVaultReserve.sol"";
import ""../interfaces/oracles/IOracleProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IRoleManager.sol"";
import ""../interfaces/tokenomics/IBkdToken.sol"";
import ""../interfaces/IController.sol"";

import ""./AddressProviderKeys.sol"";

library AddressProviderHelpers {
    /**
     * @return The address of the treasury.
     */
    function getTreasury(IAddressProvider provider) internal view returns (address) {
        return provider.getAddress(AddressProviderKeys._TREASURY_KEY);
    }

    /**
     * @return The gas bank.
     */
    function getGasBank(IAddressProvider provider) internal view returns (IGasBank) {
        return IGasBank(provider.getAddress(AddressProviderKeys._GAS_BANK_KEY));
    }

    /**
     * @return The address of the vault reserve.
     */
    function getVaultReserve(IAddressProvider provider) internal view returns (IVaultReserve) {
        return IVaultReserve(provider.getAddress(AddressProviderKeys._VAULT_RESERVE_KEY));
    }

    /**
     * @return The address of the swapperRegistry.
     */
    function getSwapperRegistry(IAddressProvider provider) internal view returns (address) {
        return provider.getAddress(AddressProviderKeys._SWAPPER_REGISTRY_KEY);
    }

    /**
     * @return The oracleProvider.
     */
    function getOracleProvider(IAddressProvider provider) internal view returns (IOracleProvider) {
        return IOracleProvider(provider.getAddress(AddressProviderKeys._ORACLE_PROVIDER_KEY));
    }

    /**
     * @return the address of the BKD locker
     */
    function getBKDLocker(IAddressProvider provider) internal view returns (address) {
        return provider.getAddress(AddressProviderKeys._BKD_LOCKER_KEY);
    }

    /**
     * @return the address of the BKD locker
     */
    function getRoleManager(IAddressProvider provider) internal view returns (IRoleManager) {
        return IRoleManager(provider.getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));
    }

    /**
     * @return the controller
     */
    function getController(IAddressProvider provider) internal view returns (IController) {
        return IController(provider.getAddress(AddressProviderKeys._CONTROLLER_KEY));
    }
}",496
RealWorld_TA_112_StrategySwapper_RealWorld_20240815084019.log,112,StrategySwapper,300616,5516,306132,149.0,1.6134,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IAddressProvider.sol"";
import ""../access/Authorization.sol"";
import ""./IStrategySwapper.sol"";
import ""../../interfaces/vendor/UniswapRouter02.sol"";
import ""../../interfaces/vendor/ICurveSwapEth.sol"";
import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";
import ""../../interfaces/IERC20Full.sol"";
import ""../../interfaces/vendor/IWETH.sol"";

contract StrategySwapper is IStrategySwapper, Authorization {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using AddressProviderHelpers for IAddressProvider;

    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH
    UniswapRouter02 internal constant _SUSHISWAP =
        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router for swaps
    UniswapRouter02 internal constant _UNISWAP =
        UniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router for swaps

    IAddressProvider internal immutable _addressProvider; // Address provider used for getting oracle provider

    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset
    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swaps to ETH (if any)
    mapping(address => bool) public swapViaUniswap; // If Uniswap should be used over Sushiswap for swaps

    event SetSlippageTolerance(uint256 value); // Emitted after a succuessful setting of slippage tolerance
    event SetCurvePool(address token, address curvePool); // Emitted after a succuessful setting of a Curve Pool
    event SetSwapViaUniswap(address token, bool swapViaUniswap); // Emitted after a succuessful setting of swap via Uniswap

    constructor(address addressProvider_, uint256 slippageTolerance_)
        Authorization(IAddressProvider(addressProvider_).getRoleManager())
    {
        _addressProvider = IAddressProvider(addressProvider_);
        slippageTolerance = slippageTolerance_;
    }

    receive() external payable {}

    /**
     * @notice Swaps all the balance of a token for WETH.
     * @param token_ Address of the token to swap for WETH.
     */
    function swapAllForWeth(address token_) external override {
        return swapForWeth(token_, IERC20(token_).balanceOf(msg.sender));
    }

    /**
     * @notice Swaps all available WETH for underlying.
     * @param token_ Address of the token to swap WETH to.
     */
    function swapAllWethForToken(address token_) external override {
        IWETH weth_ = _WETH;
        uint256 wethBalance_ = weth_.balanceOf(msg.sender);
        if (wethBalance_ == 0) return;
        weth_.transferFrom(msg.sender, address(this), wethBalance_);

        if (token_ == address(0)) {
            weth_.withdraw(wethBalance_);
            // solhint-disable-next-line avoid-low-level-calls
            (bool sent, ) = payable(msg.sender).call{value: wethBalance_}("""");
            require(sent, ""failed to send eth"");
            return;
        }

        // Handling Curve Pool swaps
        ICurveSwapEth curvePool_ = curvePools[token_];
        if (address(curvePool_) != address(0)) {
            _approve(address(weth_), address(curvePool_));
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            curvePool_.exchange(
                wethIndex_,
                tokenIndex_,
                wethBalance_,
                _minTokenAmountOut(wethBalance_, token_)
            );
            IERC20(token_).safeTransfer(msg.sender, IERC20(token_).balanceOf(address(this)));
            return;
        }

        // Handling Uniswap or Sushiswap swaps
        address[] memory path_ = new address[](2);
        path_[0] = address(weth_);
        path_[1] = token_;
        UniswapRouter02 dex_ = _getDex(token_);
        _approve(address(weth_), address(dex_));
        uint256 amountOut_ = dex_.swapExactTokensForTokens(
            wethBalance_,
            _minTokenAmountOut(wethBalance_, token_),
            path_,
            address(this),
            block.timestamp
        )[1];
        IERC20(token_).safeTransfer(msg.sender, amountOut_);
    }

    /**
     * @notice Set slippage tolerance for swaps.
     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.
     * @param slippageTolerance_ New slippage tolerance.
     */
    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {
        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);
        require(slippageTolerance_ > 0.8e18, Error.INVALID_SLIPPAGE_TOLERANCE);
        slippageTolerance = slippageTolerance_;
        emit SetSlippageTolerance(slippageTolerance_);
    }

    /**
     * @notice Sets the Curve Pool to use for swapping a token with WETH.
     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.
     * @param token_ The token to set the Curve Pool for.
     * @param curvePool_ The address of the Curve Pool.
     */
    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {
        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);
        curvePools[token_] = ICurveSwapEth(curvePool_);
        emit SetCurvePool(token_, curvePool_);
    }

    /**
     * @notice Sets if swaps should go via Uniswap for the given token_.
     * @param token_ The token to set the swapViaUniswap for.
     * @param swapViaUniswap_ If Sushiswap should be use for swaps for token_.
     */
    function setSwapViaUniswap(address token_, bool swapViaUniswap_)
        external
        override
        onlyGovernance
    {
        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        swapViaUniswap[token_] = swapViaUniswap_;
        emit SetSwapViaUniswap(token_, swapViaUniswap_);
    }

    /**
     * @notice Gets the amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.
     * @param tokenIn_ The token to swap in.
     * @param tokenOut_ The token to get out.
     * @param amountIn_ The amount to swap in.
     * @return The amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.
     */
    function amountOut(
        address tokenIn_,
        address tokenOut_,
        uint256 amountIn_
    ) external view override returns (uint256) {
        if (amountIn_ == 0) return 0;
        uint256 wethOut_ = _tokenToWethAmountOut(tokenIn_, amountIn_);
        return _wethToTokenAmountOut(tokenOut_, wethOut_);
    }

    /**
     * @notice Swaps a token for WETH.
     * @param token_ Address of the token to swap for WETH.
     * @param amount_ Amount of the token to swap for WETH.
     */
    function swapForWeth(address token_, uint256 amount_) public override {
        if (amount_ == 0) return;
        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);

        // Handling Curve Pool swaps
        ICurveSwapEth curvePool_ = curvePools[token_];
        IWETH weth_ = _WETH;
        if (address(curvePool_) != address(0)) {
            _approve(token_, address(curvePool_));
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            curvePool_.exchange(
                tokenIndex_,
                wethIndex_,
                amount_,
                _minWethAmountOut(amount_, token_)
            );
            IERC20(weth_).safeTransfer(msg.sender, weth_.balanceOf(address(this)));
            return;
        }

        // Handling Uniswap or Sushiswap swaps
        address[] memory path_ = new address[](2);
        path_[0] = token_;
        path_[1] = address(weth_);
        UniswapRouter02 dex_ = _getDex(token_);
        _approve(token_, address(dex_));
        uint256 amountOut_ = dex_.swapExactTokensForTokens(
            amount_,
            _minWethAmountOut(amount_, token_),
            path_,
            address(this),
            block.timestamp
        )[1];
        IERC20(weth_).safeTransfer(msg.sender, amountOut_);
    }

    /**
     * @dev Approves infinite spending for the given spender.
     * @param token_ The token to approve for.
     * @param spender_ The spender to approve.
     */
    function _approve(address token_, address spender_) internal {
        if (IERC20(token_).allowance(address(this), spender_) > 0) return;
        IERC20(token_).safeApprove(spender_, type(uint256).max);
    }

    /**
     * @dev Gets the dex to use for swapping a given token.
     * @param token_ The token to get the dex for.
     * @return The dex to use for swapping a given token.
     */
    function _getDex(address token_) internal view returns (UniswapRouter02) {
        return swapViaUniswap[token_] ? _UNISWAP : _SUSHISWAP;
    }

    /**
     * @dev Returns the amount of WETH received by swapping amount_ of token_.
     * @param token_ The token to get the amount for swapping to WETH.
     * @param amount_ The amount of token_ that is being swapped to WETH.
     * @return The amount of WETH received by swapping amount_ of token_.
     */
    function _tokenToWethAmountOut(address token_, uint256 amount_)
        internal
        view
        returns (uint256)
    {
        if (amount_ == 0) return 0;
        IWETH weth_ = _WETH;
        if (token_ == address(weth_)) return amount_;
        if (token_ == address(0)) return amount_;

        // Getting amount via Curve Pool if set
        ICurveSwapEth curvePool_ = curvePools[token_];
        if (address(curvePool_) != address(0)) {
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);
        }

        // Getting amount via Uniswap or Sushiswap
        address[] memory path_ = new address[](2);
        path_[0] = token_;
        path_[1] = address(weth_);
        return _getDex(token_).getAmountsOut(amount_, path_)[1];
    }

    /**
     * @dev Returns the amount of token_ received by swapping amount_ of WETH.
     * @param token_ The token to get the amount for swapping from WETH.
     * @param amount_ The amount of WETH that is being swapped to token_.
     * @return The amount of token_ received by swapping amount_ of WETH.
     */
    function _wethToTokenAmountOut(address token_, uint256 amount_)
        internal
        view
        returns (uint256)
    {
        if (amount_ == 0) return 0;
        IWETH weth_ = _WETH;
        if (token_ == address(weth_)) return amount_;
        if (token_ == address(0)) return amount_;

        // Getting amount via Curve Pool if set
        ICurveSwapEth curvePool_ = curvePools[token_];
        if (address(curvePool_) != address(0)) {
            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);
            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);
        }

        // Getting amount via Uniswap or Sushiswap
        address[] memory path_ = new address[](2);
        path_[0] = address(weth_);
        path_[1] = token_;
        return _getDex(token_).getAmountsOut(amount_, path_)[1];
    }

    /**
     * @dev Returns the multiplier for converting a token_ amount to the same decimals as WETH.
     *   For example, USDC (which has decimals of 6) would have a multiplier of 12e18.
     * @param token_ The token to get the decimal multiplier for.
     * @return the multiplier for converting a token_ amount to the same decimals as WETH.
     */
    function _decimalMultiplier(address token_) internal view returns (uint256) {
        return 10**(18 - IERC20Full(token_).decimals());
    }

    /**
     * @dev Returns the Curve Pool coin indicies for a given Token.
     * @param curvePool_ The Curve Pool to return the indicies for.
     * @param token_ The Token to get the indicies for.
     * @return wethIndex_ The coin index for WETH.
     * @return tokenIndex_ The coin index for the Token.
     */
    function _getIndices(ICurveSwapEth curvePool_, address token_)
        internal
        view
        returns (uint256 wethIndex_, uint256 tokenIndex_)
    {
        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);
    }

    /**
     * @dev Returns the minimum amount of Token to recieve from swap.
     * @param wethAmount_ The amount of WETH being swapped.
     * @param token_ The Token the WETH is being swapped to.
     * @return minAmountOut The minimum amount of Token to recieve from swap.
     */
    function _minTokenAmountOut(uint256 wethAmount_, address token_)
        internal
        view
        returns (uint256 minAmountOut)
    {
        return
            wethAmount_
                .scaledDiv(_addressProvider.getOracleProvider().getPriceETH(token_))
                .scaledMul(slippageTolerance) / _decimalMultiplier(token_);
    }

    /**
     * @dev Returns the minimum amount of WETH to recieve from swap.
     * @param tokenAmount_ The amount of Token being swapped.
     * @param token_ The Token that is being swapped for WETH.
     * @return minAmountOut The minimum amount of WETH to recieve from swap.
     */
    function _minWethAmountOut(uint256 tokenAmount_, address token_)
        internal
        view
        returns (uint256 minAmountOut)
    {
        return
            tokenAmount_
                .scaledMul(_addressProvider.getOracleProvider().getPriceETH(token_))
                .scaledMul(slippageTolerance) * _decimalMultiplier(token_);
    }
}",3455
RealWorld_TA_112_MockEthPool_RealWorld_20240815090442.log,112,MockEthPool,54945,2472,57417,98.0,0.324165,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../pool/EthPool.sol"";

contract MockEthPool is EthPool {
    uint256 public currentTime;

    constructor(IController _controller) EthPool(_controller) {}

    function setMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _setConfig(_MIN_WITHDRAWAL_FEE_KEY, newFee);
        _checkFeeInvariants(newFee, getMaxWithdrawalFee());
        return true;
    }

    function setMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {
        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, newFee);
        _checkFeeInvariants(getMinWithdrawalFee(), newFee);
        return true;
    }

    function setWithdrawalFeeDecreasePeriod(uint256 period) external onlyGovernance returns (bool) {
        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, period);
        return true;
    }

    function setVault(address payable _vault) external {
        setVault(_vault, true);
    }

    function setMaxBackingReserveDeviationRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_RESERVE_DEVIATION_KEY, newRatio);
        _rebalanceVault();
    }

    function setRequiredBackingReserveRatio(uint256 newRatio) external onlyGovernance {
        _setConfig(_REQUIRED_RESERVES_KEY, newRatio);
        _rebalanceVault();
    }

    function setTime(uint256 _currentTime) external {
        currentTime = _currentTime;
    }

    function setVault(address payable _vault, bool updateAddressProvider) public onlyGovernance {
        if (updateAddressProvider) {
            addressProvider.updateVault(currentAddresses[_VAULT_KEY], _vault);
        }
        _setConfig(_VAULT_KEY, _vault);
    }

    function _getTime() internal view override returns (uint256) {
        return currentTime == 0 ? block.timestamp : currentTime;
    }
}",427
RealWorld_TA_112_Vault_RealWorld_20240815120903.log,112,Vault,541253,5602,546855,244.0,2.818305,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../interfaces/IVault.sol"";
import ""../../interfaces/IVaultReserve.sol"";
import ""../../interfaces/IController.sol"";
import ""../../interfaces/IStrategy.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/EnumerableExtensions.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""./VaultStorage.sol"";
import ""../utils/Preparable.sol"";
import ""../utils/IPausable.sol"";
import ""../access/Authorization.sol"";

abstract contract Vault is IVault, Authorization, VaultStorageV1, Preparable, Initializable {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using EnumerableSet for EnumerableSet.AddressSet;
    using EnumerableExtensions for EnumerableSet.AddressSet;
    using EnumerableMapping for EnumerableMapping.AddressToUintMap;
    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;
    using AddressProviderHelpers for IAddressProvider;

    bytes32 internal constant _STRATEGY_KEY = ""Strategy"";
    bytes32 internal constant _PERFORMANCE_FEE_KEY = ""PerformanceFee"";
    bytes32 internal constant _STRATEGIST_FEE_KEY = ""StrategistFee"";
    bytes32 internal constant _DEBT_LIMIT_KEY = ""DebtLimit"";
    bytes32 internal constant _TARGET_ALLOCATION_KEY = ""TargetAllocation"";
    bytes32 internal constant _RESERVE_FEE_KEY = ""ReserveFee"";
    bytes32 internal constant _BOUND_KEY = ""Bound"";

    uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;
    uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;
    uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;

    uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;
    uint256 public constant MAX_DEVIATION_BOUND = 0.5e18;
    uint256 public constant STRATEGY_DELAY = 5 days;

    IController public immutable controller;
    IAddressProvider public immutable addressProvider;
    IVaultReserve public immutable reserve;

    modifier onlyPool() {
        require(msg.sender == pool, Error.UNAUTHORIZED_ACCESS);
        _;
    }

    modifier onlyPoolOrGovernance() {
        require(
            msg.sender == pool || _roleManager().hasRole(Roles.GOVERNANCE, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _;
    }

    modifier onlyPoolOrMaintenance() {
        require(
            msg.sender == pool || _roleManager().hasRole(Roles.MAINTENANCE, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _;
    }

    constructor(IController _controller)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        controller = _controller;
        IAddressProvider addressProvider_ = _controller.addressProvider();
        addressProvider = addressProvider_;
        reserve = IVaultReserve(addressProvider_.getVaultReserve());
    }

    function _initialize(
        address _pool,
        uint256 _debtLimit,
        uint256 _targetAllocation,
        uint256 _bound
    ) internal {
        require(_debtLimit <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(_targetAllocation <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        require(_bound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);

        pool = _pool;

        _setConfig(_DEBT_LIMIT_KEY, _debtLimit);
        _setConfig(_TARGET_ALLOCATION_KEY, _targetAllocation);
        _setConfig(_BOUND_KEY, _bound);
        _setConfig(_RESERVE_FEE_KEY, _INITIAL_RESERVE_FEE);
        _setConfig(_STRATEGIST_FEE_KEY, _INITIAL_STRATEGIST_FEE);
        _setConfig(_PERFORMANCE_FEE_KEY, _INITIAL_PERFORMANCE_FEE);
    }

    /**
     * @notice Handles deposits from the liquidity pool
     */
    function deposit() external payable override onlyPoolOrMaintenance {
        // solhint-disable-previous-line ordering
        _deposit();
    }

    /**
     * @notice Withdraws specified amount of underlying from vault.
     * @dev If the specified amount exceeds idle funds, an amount of funds is withdrawn
     *      from the strategy such that it will achieve a target allocation for after the
     *      amount has been withdrawn.
     * @param amount Amount to withdraw.
     * @return `true` if successful.
     */
    function withdraw(uint256 amount) external override onlyPoolOrGovernance returns (bool) {
        IStrategy strategy = getStrategy();
        uint256 availableUnderlying_ = _availableUnderlying();

        if (availableUnderlying_ < amount) {
            if (address(strategy) == address(0)) return false;
            uint256 allocated = strategy.balance();
            uint256 requiredWithdrawal = amount - availableUnderlying_;

            if (requiredWithdrawal > allocated) return false;

            // compute withdrawal amount to sustain target allocation
            uint256 newTarget = (allocated - requiredWithdrawal).scaledMul(getTargetAllocation());
            uint256 excessAmount = allocated - newTarget;
            strategy.withdraw(excessAmount);
            currentAllocated = _computeNewAllocated(currentAllocated, excessAmount);
        } else {
            uint256 allocatedUnderlying = 0;
            if (address(strategy) != address(0))
                allocatedUnderlying = IStrategy(strategy).balance();
            uint256 totalUnderlying = availableUnderlying_ +
                allocatedUnderlying +
                waitingForRemovalAllocated;
            uint256 totalUnderlyingAfterWithdraw = totalUnderlying - amount;
            _rebalance(totalUnderlyingAfterWithdraw, allocatedUnderlying);
        }

        _transfer(pool, amount);
        return true;
    }

    /**
     * @notice Withdraws all funds from vault and strategy and transfer them to the pool.
     */
    function withdrawAll() external override onlyPoolOrGovernance {
        _withdrawAllFromStrategy();
        _transfer(pool, _availableUnderlying());
    }

    /**
     * @notice Withdraws specified amount of underlying from reserve to vault.
     * @dev Withdraws from reserve will cause a spike in pool exchange rate.
     *  Pool deposits should be paused during this to prevent front running
     * @param amount Amount to withdraw.
     */
    function withdrawFromReserve(uint256 amount) external override onlyGovernance {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED);
        uint256 reserveBalance_ = reserve.getBalance(address(this), getUnderlying());
        require(amount <= reserveBalance_, Error.INSUFFICIENT_BALANCE);
        reserve.withdraw(getUnderlying(), amount);
    }

    /**
     * @notice Activate the current strategy set for the vault.
     * @return `true` if strategy has been activated
     */
    function activateStrategy() external onlyGovernance returns (bool) {
        return _activateStrategy();
    }

    /**
     * @notice Deactivates a strategy.
     * @return `true` if strategy has been deactivated
     */
    function deactivateStrategy() external onlyGovernance returns (bool) {
        return _deactivateStrategy();
    }

    /**
     * @notice Initializes the vault's strategy.
     * @dev Bypasses the time delay, but can only be called if strategy is not set already.
     * @param strategy_ Address of the strategy.
     * @return `true` if successful.
     */
    function initializeStrategy(address strategy_) external override onlyGovernance returns (bool) {
        require(currentAddresses[_STRATEGY_KEY] == address(0), Error.ADDRESS_ALREADY_SET);
        require(strategy_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _setConfig(_STRATEGY_KEY, strategy_);
        _activateStrategy();
        require(IStrategy(strategy_).strategist() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        return true;
    }

    /**
     * @notice Prepare update of the vault's strategy (with time delay enforced).
     * @param newStrategy Address of the new strategy.
     * @return `true` if successful.
     */
    function prepareNewStrategy(address newStrategy)
        external
        override
        onlyGovernance
        returns (bool)
    {
        return _prepare(_STRATEGY_KEY, newStrategy, STRATEGY_DELAY);
    }

    /**
     * @notice Execute strategy update (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New strategy address.
     */
    function executeNewStrategy() external override returns (address) {
        _executeDeadline(_STRATEGY_KEY);
        IStrategy strategy = getStrategy();
        if (address(strategy) != address(0)) {
            _harvest();
            strategy.shutdown();
            strategy.withdrawAll();

            // there might still be some balance left if the strategy did not
            // manage to withdraw all funds (e.g. due to locking)
            uint256 remainingStrategyBalance = strategy.balance();
            if (remainingStrategyBalance > 0) {
                _strategiesWaitingForRemoval.set(address(strategy), remainingStrategyBalance);
                waitingForRemovalAllocated += remainingStrategyBalance;
            }
        }
        _deactivateStrategy();
        currentAllocated = 0;
        totalDebt = 0;
        address newStrategy = pendingAddresses[_STRATEGY_KEY];
        _setConfig(_STRATEGY_KEY, newStrategy);

        if (newStrategy != address(0)) {
            _activateStrategy();
        }

        return newStrategy;
    }

    function resetNewStrategy() external onlyGovernance returns (bool) {
        return _resetAddressConfig(_STRATEGY_KEY);
    }

    /**
     * @notice Prepare update of performance fee (with time delay enforced).
     * @param newPerformanceFee New performance fee value.
     * @return `true` if successful.
     */
    function preparePerformanceFee(uint256 newPerformanceFee)
        external
        onlyGovernance
        returns (bool)
    {
        require(newPerformanceFee <= MAX_PERFORMANCE_FEE, Error.INVALID_AMOUNT);
        return _prepare(_PERFORMANCE_FEE_KEY, newPerformanceFee);
    }

    /**
     * @notice Execute update of performance fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New performance fee.
     */
    function executePerformanceFee() external returns (uint256) {
        return _executeUInt256(_PERFORMANCE_FEE_KEY);
    }

    function resetPerformanceFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_PERFORMANCE_FEE_KEY);
    }

    /**
     * @notice Prepare update of strategist fee (with time delay enforced).
     * @param newStrategistFee New strategist fee value.
     * @return `true` if successful.
     */
    function prepareStrategistFee(uint256 newStrategistFee) external onlyGovernance returns (bool) {
        _checkFeesInvariant(getReserveFee(), newStrategistFee);
        return _prepare(_STRATEGIST_FEE_KEY, newStrategistFee);
    }

    /**
     * @notice Execute update of strategist fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New strategist fee.
     */
    function executeStrategistFee() external returns (uint256) {
        uint256 newStrategistFee = _executeUInt256(_STRATEGIST_FEE_KEY);
        _checkFeesInvariant(getReserveFee(), newStrategistFee);
        return newStrategistFee;
    }

    function resetStrategistFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_STRATEGIST_FEE_KEY);
    }

    /**
     * @notice Prepare update of debt limit (with time delay enforced).
     * @param newDebtLimit New debt limit.
     * @return `true` if successful.
     */
    function prepareDebtLimit(uint256 newDebtLimit) external onlyGovernance returns (bool) {
        return _prepare(_DEBT_LIMIT_KEY, newDebtLimit);
    }

    /**
     * @notice Execute update of debt limit (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New debt limit.
     */
    function executeDebtLimit() external returns (uint256) {
        uint256 debtLimit = _executeUInt256(_DEBT_LIMIT_KEY);
        uint256 debtLimitAllocated = currentAllocated.scaledMul(debtLimit);
        if (totalDebt >= debtLimitAllocated) {
            _handleExcessDebt();
        }
        return debtLimit;
    }

    function resetDebtLimit() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_DEBT_LIMIT_KEY);
    }

    /**
     * @notice Prepare update of target allocation (with time delay enforced).
     * @param newTargetAllocation New target allocation.
     * @return `true` if successful.
     */
    function prepareTargetAllocation(uint256 newTargetAllocation)
        external
        onlyGovernance
        returns (bool)
    {
        return _prepare(_TARGET_ALLOCATION_KEY, newTargetAllocation);
    }

    /**
     * @notice Execute update of target allocation (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New target allocation.
     */
    function executeTargetAllocation() external returns (uint256) {
        uint256 targetAllocation = _executeUInt256(_TARGET_ALLOCATION_KEY);
        _deposit();
        return targetAllocation;
    }

    function resetTargetAllocation() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_TARGET_ALLOCATION_KEY);
    }

    /**
     * @notice Prepare update of reserve fee (with time delay enforced).
     * @param newReserveFee New reserve fee.
     * @return `true` if successful.
     */
    function prepareReserveFee(uint256 newReserveFee) external onlyGovernance returns (bool) {
        _checkFeesInvariant(newReserveFee, getStrategistFee());
        return _prepare(_RESERVE_FEE_KEY, newReserveFee);
    }

    /**
     * @notice Execute update of reserve fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New reserve fee.
     */
    function executeReserveFee() external returns (uint256) {
        uint256 newReserveFee = _executeUInt256(_RESERVE_FEE_KEY);
        _checkFeesInvariant(newReserveFee, getStrategistFee());
        return newReserveFee;
    }

    function resetReserveFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_RESERVE_FEE_KEY);
    }

    /**
     * @notice Prepare update of deviation bound for strategy allocation (with time delay enforced).
     * @param newBound New deviation bound for target allocation.
     * @return `true` if successful.
     */
    function prepareBound(uint256 newBound) external onlyGovernance returns (bool) {
        require(newBound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);
        return _prepare(_BOUND_KEY, newBound);
    }

    /**
     * @notice Execute update of deviation bound for strategy allocation (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New deviation bound.
     */
    function executeBound() external returns (uint256) {
        uint256 bound = _executeUInt256(_BOUND_KEY);
        _deposit();
        return bound;
    }

    function resetBound() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_BOUND_KEY);
    }

    /**
     * @notice Withdraws an amount of underlying from the strategy to the vault.
     * @param amount Amount of underlying to withdraw.
     * @return True if successful withdrawal.
     */
    function withdrawFromStrategy(uint256 amount) external onlyGovernance returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) return false;
        if (strategy.balance() < amount) return false;
        uint256 oldBalance = _availableUnderlying();
        strategy.withdraw(amount);
        uint256 newBalance = _availableUnderlying();
        currentAllocated -= newBalance - oldBalance;
        return true;
    }

    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256) {
        (bool exists, uint256 allocated) = _strategiesWaitingForRemoval.tryGet(strategy);
        require(exists, Error.STRATEGY_DOES_NOT_EXIST);

        IStrategy strategy_ = IStrategy(strategy);

        strategy_.harvest();
        uint256 withdrawn = strategy_.withdrawAll();

        uint256 _waitingForRemovalAllocated = waitingForRemovalAllocated;
        if (withdrawn >= _waitingForRemovalAllocated) {
            waitingForRemovalAllocated = 0;
        } else {
            waitingForRemovalAllocated = _waitingForRemovalAllocated - withdrawn;
        }

        if (withdrawn > allocated) {
            uint256 profit = withdrawn - allocated;
            uint256 strategistShare = _shareFees(profit.scaledMul(getPerformanceFee()));
            if (strategistShare > 0) {
                _payStrategist(strategistShare, strategy_.strategist());
            }
            allocated = 0;
            emit Harvest(profit, 0);
        } else {
            allocated -= withdrawn;
        }

        if (strategy_.balance() == 0) {
            _strategiesWaitingForRemoval.remove(address(strategy_));
        } else {
            _strategiesWaitingForRemoval.set(address(strategy_), allocated);
        }

        return withdrawn;
    }

    function getStrategiesWaitingForRemoval() external view returns (address[] memory) {
        return _strategiesWaitingForRemoval.keysArray();
    }

    /**
     * @notice Computes the total underlying of the vault: idle funds + allocated funds - debt
     * @return Total amount of underlying.
     */
    function getTotalUnderlying() external view override returns (uint256) {
        uint256 availableUnderlying_ = _availableUnderlying();

        if (address(getStrategy()) == address(0)) {
            return availableUnderlying_;
        }

        uint256 netUnderlying = availableUnderlying_ +
            currentAllocated +
            waitingForRemovalAllocated;
        if (totalDebt <= netUnderlying) return netUnderlying - totalDebt;
        return 0;
    }

    function getAllocatedToStrategyWaitingForRemoval(address strategy)
        external
        view
        returns (uint256)
    {
        return _strategiesWaitingForRemoval.get(strategy);
    }

    /**
     * @notice Withdraws all funds from strategy to vault.
     * @dev Harvests profits before withdrawing. Deactivates strategy after withdrawing.
     * @return `true` if successful.
     */
    function withdrawAllFromStrategy() public onlyPoolOrGovernance returns (bool) {
        return _withdrawAllFromStrategy();
    }

    /**
     * @notice Harvest profits from the vault's strategy.
     * @dev Harvesting adds profits to the vault's balance and deducts fees.
     *  No performance fees are charged on profit used to repay debt.
     * @return `true` if successful.
     */
    function harvest() public onlyPoolOrMaintenance returns (bool) {
        return _harvest();
    }

    /**
     * @notice Returns the percentage of the performance fee that goes to the strategist.
     */
    function getStrategistFee() public view returns (uint256) {
        return currentUInts256[_STRATEGIST_FEE_KEY];
    }

    function getStrategy() public view override returns (IStrategy) {
        return IStrategy(currentAddresses[_STRATEGY_KEY]);
    }

    /**
     * @notice Returns the percentage of the performance fee which is allocated to the vault reserve
     */
    function getReserveFee() public view returns (uint256) {
        return currentUInts256[_RESERVE_FEE_KEY];
    }

    /**
     * @notice Returns the fee charged on a strategy's generated profits.
     * @dev The strategist is paid in LP tokens, while the remainder of the profit stays in the vault.
     *      Default performance fee is set to 5% of harvested profits.
     */
    function getPerformanceFee() public view returns (uint256) {
        return currentUInts256[_PERFORMANCE_FEE_KEY];
    }

    /**
     * @notice Returns the allowed symmetric bound for target allocation (e.g. +- 5%)
     */
    function getBound() public view returns (uint256) {
        return currentUInts256[_BOUND_KEY];
    }

    /**
     * @notice The target percentage of total underlying funds to be allocated towards a strategy.
     * @dev this is to reduce gas costs. Withdrawals first come from idle funds and can therefore
     *      avoid unnecessary gas costs.
     */
    function getTargetAllocation() public view returns (uint256) {
        return currentUInts256[_TARGET_ALLOCATION_KEY];
    }

    /**
     * @notice The debt limit that the total debt of a strategy may not exceed.
     */
    function getDebtLimit() public view returns (uint256) {
        return currentUInts256[_DEBT_LIMIT_KEY];
    }

    function getUnderlying() public view virtual override returns (address);

    function _activateStrategy() internal returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) return false;

        strategyActive = true;
        emit StrategyActivated(address(strategy));
        _deposit();
        return true;
    }

    function _harvest() internal returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) {
            return false;
        }

        strategy.harvest();

        uint256 strategistShare = 0;

        uint256 allocatedUnderlying = strategy.balance();
        uint256 amountAllocated = currentAllocated;
        uint256 currentDebt = totalDebt;

        if (allocatedUnderlying > amountAllocated) {
            // we made profits
            uint256 profit = allocatedUnderlying - amountAllocated;

            if (profit > currentDebt) {
                if (currentDebt > 0) {
                    profit -= currentDebt;
                    currentDebt = 0;
                }
                (profit, strategistShare) = _shareProfit(profit);
            } else {
                currentDebt -= profit;
            }
            emit Harvest(profit, 0);
        } else if (allocatedUnderlying < amountAllocated) {
            // we made a loss
            uint256 loss = amountAllocated - allocatedUnderlying;
            currentDebt += loss;

            // check debt limit and withdraw funds if exceeded
            uint256 debtLimit = getDebtLimit();
            uint256 debtLimitAllocated = amountAllocated.scaledMul(debtLimit);
            if (currentDebt > debtLimitAllocated) {
                currentDebt = _handleExcessDebt(currentDebt);
            }
            emit Harvest(0, loss);
        } else {
            // nothing to declare
            return true;
        }

        totalDebt = currentDebt;
        currentAllocated = strategy.balance();

        if (strategistShare > 0) {
            _payStrategist(strategistShare);
        }

        return true;
    }

    function _withdrawAllFromStrategy() internal returns (bool) {
        IStrategy strategy = getStrategy();
        if (address(strategy) == address(0)) return false;
        _harvest();
        uint256 oldBalance = _availableUnderlying();
        strategy.withdrawAll();
        uint256 newBalance = _availableUnderlying();
        uint256 withdrawnAmount = newBalance - oldBalance;

        currentAllocated = _computeNewAllocated(currentAllocated, withdrawnAmount);
        _deactivateStrategy();
        return true;
    }

    function _handleExcessDebt(uint256 currentDebt) internal returns (uint256) {
        uint256 underlyingReserves = reserve.getBalance(address(this), getUnderlying());
        if (currentDebt > underlyingReserves) {
            _emergencyStop(underlyingReserves);
        } else if (reserve.canWithdraw(address(this))) {
            reserve.withdraw(getUnderlying(), currentDebt);
            currentDebt = 0;
            _deposit();
        }
        return currentDebt;
    }

    function _handleExcessDebt() internal {
        uint256 currentDebt = totalDebt;
        uint256 newDebt = _handleExcessDebt(totalDebt);
        if (currentDebt != newDebt) {
            totalDebt = newDebt;
        }
    }

    /**
     * @notice Invest the underlying money in the vault after a deposit from the pool is made.
     * @dev After each deposit, the vault checks whether it needs to rebalance underlying funds allocated to strategy.
     * If no strategy is set then all deposited funds will be idle.
     */
    function _deposit() internal {
        if (!strategyActive) return;

        uint256 allocatedUnderlying = getStrategy().balance();
        uint256 totalUnderlying = _availableUnderlying() +
            allocatedUnderlying +
            waitingForRemovalAllocated;

        if (totalUnderlying == 0) return;
        _rebalance(totalUnderlying, allocatedUnderlying);
    }

    function _shareProfit(uint256 profit) internal returns (uint256, uint256) {
        uint256 totalFeeAmount = profit.scaledMul(getPerformanceFee());
        if (_availableUnderlying() < totalFeeAmount) {
            getStrategy().withdraw(totalFeeAmount);
        }
        uint256 strategistShare = _shareFees(totalFeeAmount);

        return ((profit - totalFeeAmount), strategistShare);
    }

    function _shareFees(uint256 totalFeeAmount) internal returns (uint256) {
        uint256 strategistShare = totalFeeAmount.scaledMul(getStrategistFee());

        uint256 reserveShare = totalFeeAmount.scaledMul(getReserveFee());
        uint256 treasuryShare = totalFeeAmount - strategistShare - reserveShare;

        _depositToReserve(reserveShare);
        if (treasuryShare > 0) {
            _depositToTreasury(treasuryShare);
        }
        return strategistShare;
    }

    function _emergencyStop(uint256 underlyingReserves) internal {
        // debt limit exceeded: withdraw funds from strategy
        uint256 withdrawn = getStrategy().withdrawAll();

        uint256 actualDebt = _computeNewAllocated(currentAllocated, withdrawn);

        if (reserve.canWithdraw(address(this))) {
            // check if debt can be covered with reserve funds
            if (underlyingReserves >= actualDebt) {
                reserve.withdraw(getUnderlying(), actualDebt);
            } else if (underlyingReserves > 0) {
                // debt can not be covered with reserves
                reserve.withdraw(getUnderlying(), underlyingReserves);
            }
        }

        // too much money lost, stop the strategy
        _deactivateStrategy();
    }

    /**
     * @notice Deactivates a strategy. All positions of the strategy are exited.
     * @return `true` if strategy has been deactivated
     */
    function _deactivateStrategy() internal returns (bool) {
        if (!strategyActive) return false;

        strategyActive = false;
        emit StrategyDeactivated(address(getStrategy()));
        return true;
    }

    function _payStrategist(uint256 amount) internal {
        _payStrategist(amount, getStrategy().strategist());
    }

    function _payStrategist(uint256 amount, address strategist) internal virtual;

    function _transfer(address to, uint256 amount) internal virtual;

    function _depositToReserve(uint256 amount) internal virtual;

    function _depositToTreasury(uint256 amount) internal virtual;

    function _availableUnderlying() internal view virtual returns (uint256);

    function _computeNewAllocated(uint256 allocated, uint256 withdrawn)
        internal
        pure
        returns (uint256)
    {
        if (allocated > withdrawn) {
            return allocated - withdrawn;
        }
        return 0;
    }

    function _checkFeesInvariant(uint256 reserveFee, uint256 strategistFee) internal pure {
        require(
            reserveFee + strategistFee <= ScaledMath.ONE,
            ""sum of strategist fee and reserve fee should be below 1""
        );
    }

    function _rebalance(uint256 totalUnderlying, uint256 allocatedUnderlying)
        private
        returns (bool)
    {
        if (!strategyActive) return false;
        uint256 targetAllocation = getTargetAllocation();

        IStrategy strategy = getStrategy();
        uint256 bound = getBound();

        uint256 target = totalUnderlying.scaledMul(targetAllocation);
        uint256 upperBound = targetAllocation == 0 ? 0 : targetAllocation + bound;
        upperBound = upperBound > ScaledMath.ONE ? ScaledMath.ONE : upperBound;
        uint256 lowerBound = bound > targetAllocation ? 0 : targetAllocation - bound;
        if (allocatedUnderlying > totalUnderlying.scaledMul(upperBound)) {
            // withdraw funds from strategy
            uint256 withdrawAmount = allocatedUnderlying - target;
            strategy.withdraw(withdrawAmount);

            currentAllocated = _computeNewAllocated(currentAllocated, withdrawAmount);
        } else if (allocatedUnderlying < totalUnderlying.scaledMul(lowerBound)) {
            // allocate more funds to strategy
            uint256 depositAmount = target - allocatedUnderlying;
            _transfer(address(strategy), depositAmount);
            currentAllocated += depositAmount;
            strategy.deposit();
        }
        return true;
    }
}",6432
RealWorld_TA_112_TopUpActionProfiler_RealWorld_20240815094555.log,112,TopUpActionProfiler,73709,3710,77419,113.0,0.442745,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../../interfaces/pool/ILiquidityPool.sol"";
import ""../../../interfaces/actions/topup/ITopUpAction.sol"";

import ""../../pool/LiquidityPool.sol"";
import ""../../actions/topup/TopUpAction.sol"";
import ""../../LpToken.sol"";

contract TopUpActionProfiler {
    TopUpAction public topUpAction;

    constructor(address _topUpAction, address lpToken) {
        topUpAction = TopUpAction(payable(_topUpAction));
        LpToken(lpToken).approve(address(topUpAction), type(uint256).max);
    }

    function profileRegister(
        bytes32 account,
        bytes32 protocol,
        uint64 threshold,
        address depositToken,
        uint128 depositAmount,
        address actionToken,
        uint128 singleTopUpAmount,
        uint128 totalTopUpAmount,
        bytes memory extra
    ) external {
        topUpAction.register(
            account,
            protocol,
            depositAmount,
            ITopUpAction.Record({
                threshold: threshold,
                priorityFee: 10**9,
                maxFee: 30 * 10**9,
                actionToken: actionToken,
                depositToken: depositToken,
                singleTopUpAmount: singleTopUpAmount,
                totalTopUpAmount: totalTopUpAmount,
                depositTokenBalance: 0,
                extra: extra
            })
        );

        topUpAction.resetPosition(account, protocol, true);

        topUpAction.register(
            account,
            protocol,
            depositAmount,
            ITopUpAction.Record({
                threshold: threshold,
                priorityFee: 10**9,
                maxFee: 30 * 10**9,
                actionToken: actionToken,
                depositToken: depositToken,
                singleTopUpAmount: singleTopUpAmount,
                totalTopUpAmount: totalTopUpAmount,
                depositTokenBalance: 0,
                extra: extra
            })
        );
    }

    function simpleRegister(
        bytes32 account,
        bytes32 protocol,
        uint64 threshold,
        address depositToken,
        uint128 depositAmount,
        address actionToken,
        uint128 singleTopUpAmount,
        uint128 totalTopUpAmount,
        bytes memory extra
    ) external {
        topUpAction.register(
            account,
            protocol,
            depositAmount,
            ITopUpAction.Record({
                threshold: threshold,
                priorityFee: 10**9,
                maxFee: 30 * 10**9,
                actionToken: actionToken,
                depositToken: depositToken,
                singleTopUpAmount: singleTopUpAmount,
                totalTopUpAmount: totalTopUpAmount,
                depositTokenBalance: 0,
                extra: extra
            })
        );
    }

    function profileExecute(
        address payer,
        bytes32 account,
        address beneficiary,
        bytes32 protocol
    ) external {
        topUpAction.execute(payer, account, beneficiary, protocol, 0);
    }
}",647
RealWorld_TA_112_ILpToken_RealWorld_20240815132003.log,112,ILpToken,30192,2492,32684,148.0,0.2008,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface ILpToken is IERC20Upgradeable {
    function mint(address account, uint256 lpTokens) external;

    function burn(address account, uint256 burnAmount) external returns (uint256);

    function burn(uint256 burnAmount) external;

    function minter() external view returns (address);

    function initialize(
        string memory name_,
        string memory symbol_,
        uint8 _decimals,
        address _minter
    ) external returns (bool);
}",142
RealWorld_TA_112_AuthorizationBase_RealWorld_20240815082715.log,112,AuthorizationBase,48843,1310,50153,82.0,0.270415,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../interfaces/IRoleManager.sol"";

import ""../../libraries/Errors.sol"";
import ""../../libraries/Roles.sol"";

/**
 * @notice Provides modifiers for authorization
 */
abstract contract AuthorizationBase {
    /**
     * @notice Only allows a sender with `role` to perform the given action
     */
    modifier onlyRole(bytes32 role) {
        require(_roleManager().hasRole(role, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    /**
     * @notice Only allows a sender with GOVERNANCE role to perform the given action
     */
    modifier onlyGovernance() {
        require(_roleManager().hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    /**
     * @notice Only allows a sender with any of `roles` to perform the given action
     */
    modifier onlyRoles2(bytes32 role1, bytes32 role2) {
        require(_roleManager().hasAnyRole(role1, role2, msg.sender), Error.UNAUTHORIZED_ACCESS);
        _;
    }

    /**
     * @notice Only allows a sender with any of `roles` to perform the given action
     */
    modifier onlyRoles3(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3
    ) {
        require(
            _roleManager().hasAnyRole(role1, role2, role3, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _;
    }

    function roleManager() external view virtual returns (IRoleManager) {
        return _roleManager();
    }

    function _roleManager() internal view virtual returns (IRoleManager);
}",366
RealWorld_TA_112_IController_RealWorld_20240815132715.log,112,IController,37297,1636,38933,135.0,0.219205,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""./IAddressProvider.sol"";
import ""./IPreparable.sol"";
import ""./IGasBank.sol"";
import ""./pool/ILiquidityPool.sol"";
import ""./tokenomics/IInflationManager.sol"";

// solhint-disable ordering

interface IController is IPreparable {
    function addressProvider() external view returns (IAddressProvider);

    function inflationManager() external view returns (IInflationManager);

    function addStakerVault(address stakerVault) external returns (bool);

    function removePool(address pool) external returns (bool);

    /** Keeper functions */
    function prepareKeeperRequiredStakedBKD(uint256 amount) external;

    function executeKeeperRequiredStakedBKD() external;

    function getKeeperRequiredStakedBKD() external view returns (uint256);

    function canKeeperExecuteAction(address keeper) external view returns (bool);

    /** Miscellaneous functions */

    function getTotalEthRequiredForGas(address payer) external view returns (uint256);
}",220
RealWorld_TA_112_ILido_RealWorld_20240815150734.log,112,ILido,117652,2974,120626,146.0,0.64774,"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>

// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.9;

/**
 * @title Liquid staking pool
 *
 * For the high-level description of the pool operation please refer to the paper.
 * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side
 * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,
 * only a small portion (buffer) of it.
 * It also mints new tokens for rewards generated at the ETH 2.0 side.
 */
interface ILido {
    /**
     * @dev From ISTETH interface, because ""Interfaces cannot inherit"".
     */
    function totalSupply() external view returns (uint256);

    function getTotalShares() external view returns (uint256);

    /**
     * @notice Stop pool routine operations
     */
    function stop() external;

    /**
     * @notice Resume pool routine operations
     */
    function resume() external;

    event Stopped();
    event Resumed();

    /**
     * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results
     * @param _feeBasisPoints Fee rate, in basis points
     */
    function setFee(uint16 _feeBasisPoints) external;

    /**
     * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.
     */
    function setFeeDistribution(
        uint16 _treasuryFeeBasisPoints,
        uint16 _insuranceFeeBasisPoints,
        uint16 _operatorsFeeBasisPoints
    ) external;

    /**
     * @notice Returns staking rewards fee rate
     */
    function getFee() external view returns (uint16 feeBasisPoints);

    /**
     * @notice Returns fee distribution proportion
     */
    function getFeeDistribution()
        external
        view
        returns (
            uint16 treasuryFeeBasisPoints,
            uint16 insuranceFeeBasisPoints,
            uint16 operatorsFeeBasisPoints
        );

    event FeeSet(uint16 feeBasisPoints);

    event FeeDistributionSet(
        uint16 treasuryFeeBasisPoints,
        uint16 insuranceFeeBasisPoints,
        uint16 operatorsFeeBasisPoints
    );

    /**
     * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`
     * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.
     * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by
     *        the deposit_contract.deposit function
     */
    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;

    /**
     * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched
     */
    function getWithdrawalCredentials() external view returns (bytes memory);

    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);

    /**
     * @notice Ether on the ETH 2.0 side reported by the oracle
     * @param _epoch Epoch id
     * @param _eth2balance Balance in wei on the ETH 2.0 side
     */
    function pushBeacon(uint256 _epoch, uint256 _eth2balance) external;

    // User functions

    /**
     * @notice Adds eth to the pool
     * @return StETH Amount of StETH generated
     */
    function submit(address _referral) external payable returns (uint256 StETH);

    // Records a deposit made by a user
    event Submitted(address indexed sender, uint256 amount, address referral);

    // The `_amount` of ether was sent to the deposit_contract.deposit function.
    event Unbuffered(uint256 amount);

    /**
     * @notice Issues withdrawal request. Large withdrawals will be processed only after the phase 2 launch.
     * @param _amount Amount of StETH to burn
     * @param _pubkeyHash Receiving address
     */
    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external;

    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,
    // `sentFromBuffer` was sent on the current Ethereum side.
    event Withdrawal(
        address indexed sender,
        uint256 tokenAmount,
        uint256 sentFromBuffer,
        bytes32 indexed pubkeyHash,
        uint256 etherAmount
    );

    // Info functions

    /**
     * @notice Gets the amount of Ether controlled by the system
     */
    function getTotalPooledEther() external view returns (uint256);

    /**
     * @notice Gets the amount of Ether temporary buffered on this contract balance
     */
    function getBufferedEther() external view returns (uint256);

    /**
     * @notice Returns the key values related to Beacon-side
     * @return depositedValidators - number of deposited validators
     * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles
     * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)
     */
    function getBeaconStat()
        external
        view
        returns (
            uint256 depositedValidators,
            uint256 beaconValidators,
            uint256 beaconBalance
        );
}",1198
RealWorld_TA_112_CompoundHandler_RealWorld_20240815100153.log,112,CompoundHandler,137768,3723,141491,5147.0,0.7633,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../../../../libraries/AccountEncoding.sol"";

import ""./BaseHandler.sol"";
import ""../../../../interfaces/ICTokenRegistry.sol"";
import ""../../../../interfaces/vendor/CToken.sol"";
import ""../../../../interfaces/vendor/ExponentialNoError.sol"";
import ""../../../../interfaces/vendor/Comptroller.sol"";
import ""../../../../libraries/Errors.sol"";
import ""../../../../libraries/ScaledMath.sol"";

contract CompoundHandler is BaseHandler, ExponentialNoError {
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;
    using AccountEncoding for bytes32;

    struct AccountLiquidityLocalVars {
        uint256 sumCollateral;
        uint256 sumBorrow;
        uint256 cTokenBalance;
        uint256 borrowBalance;
        uint256 exchangeRateMantissa;
        uint256 oraclePriceMantissa;
        Exp collateralFactor;
        Exp exchangeRate;
        Exp oraclePrice;
        Exp tokensToDenom;
    }

    Comptroller public immutable comptroller;
    ICTokenRegistry public immutable cTokenRegistry;

    constructor(address comptrollerAddress, address _cTokenRegistry) {
        comptroller = Comptroller(comptrollerAddress);
        cTokenRegistry = ICTokenRegistry(_cTokenRegistry);
    }

    /**
     * @notice Executes the top-up of a position.
     * @param account Account holding the position.
     * @param underlying Underlying for tup-up.
     * @param amount Amount to top-up by.
     * @return `true` if successful.
     */
    function topUp(
        bytes32 account,
        address underlying,
        uint256 amount,
        bytes memory extra
    ) external override returns (bool) {
        bool repayDebt = abi.decode(extra, (bool));
        CToken ctoken = cTokenRegistry.fetchCToken(underlying);
        uint256 initialTokens = ctoken.balanceOf(address(this));

        address addr = account.addr();

        if (repayDebt) {
            amount -= _repayAnyDebt(addr, underlying, amount, ctoken);
            if (amount == 0) return true;
        }

        uint256 err;
        if (underlying == address(0)) {
            err = ctoken.mint{value: amount}(amount);
        } else {
            IERC20(underlying).safeApprove(address(ctoken), amount);
            err = ctoken.mint(amount);
        }
        require(err == 0, Error.FAILED_MINT);

        uint256 newTokens = ctoken.balanceOf(address(this));
        uint256 mintedTokens = newTokens - initialTokens;

        bool success = ctoken.transfer(addr, mintedTokens);
        require(success, Error.FAILED_TRANSFER);
        return true;
    }

    /**
     * @notice Returns the collaterization ratio of the user.
     *         A result of 1.5 (x1e18) means that the user has a 150% collaterization ratio.
     * @param account account for which to check the factor.
     * @return User factor.
     */
    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {
        (uint256 sumCollateral, uint256 sumBorrow) = _getAccountBorrowsAndSupply(account.addr());
        if (sumBorrow == 0) {
            return type(uint256).max;
        }
        return sumCollateral.scaledDiv(sumBorrow);
    }

    /**
     * @notice Repays any existing debt for the given underlying.
     * @param account Account for which to repay the debt.
     * @param underlying The underlying token to repay the debt for.
     * @param maximum The maximum amount of debt to repay.
     * @return The amount of debt that was repayed in the underlying.
     */
    function _repayAnyDebt(
        address account,
        address underlying,
        uint256 maximum,
        CToken ctoken
    ) internal returns (uint256) {
        uint256 debt = ctoken.borrowBalanceCurrent(account);
        if (debt == 0) return 0;
        if (debt > maximum) debt = maximum;

        uint256 err;
        if (underlying == address(0)) {
            CEther cether = CEther(address(ctoken));
            err = cether.repayBorrowBehalf{value: debt}(account);
        } else {
            IERC20(underlying).safeApprove(address(ctoken), debt);
            err = ctoken.repayBorrowBehalf(account, debt);
        }
        require(err == 0, Error.FAILED_REPAY_BORROW);

        return debt;
    }

    function _getAccountBorrowsAndSupply(address account) internal view returns (uint256, uint256) {
        AccountLiquidityLocalVars memory vars; // Holds all our calculation results
        uint256 oErr;

        PriceOracle oracle = comptroller.oracle();
        // For each asset the account is in
        CToken[] memory assets = comptroller.getAssetsIn(account);
        for (uint256 i = 0; i < assets.length; i++) {
            CToken asset = assets[i];

            // Read the balances and exchange rate from the cToken
            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset
                .getAccountSnapshot(account);
            require(oErr == 0, Error.FAILED_METHOD_CALL);
            (, uint256 collateralFactorMantissa, ) = comptroller.markets(address(asset));
            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});
            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});

            // Get the normalized price of the asset
            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);
            require(vars.oraclePriceMantissa != 0, Error.FAILED_METHOD_CALL);
            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});

            // Pre-compute a conversion factor from tokens -> ether (normalized price value)
            vars.tokensToDenom = mul_(
                mul_(vars.collateralFactor, vars.exchangeRate),
                vars.oraclePrice
            );

            // sumCollateral += tokensToDenom * cTokenBalance
            vars.sumCollateral = mul_ScalarTruncateAddUInt(
                vars.tokensToDenom,
                vars.cTokenBalance,
                vars.sumCollateral
            );

            // sumBorrow += oraclePrice * borrowBalance
            vars.sumBorrow = mul_ScalarTruncateAddUInt(
                vars.oraclePrice,
                vars.borrowBalance,
                vars.sumBorrow
            );
        }

        return (vars.sumCollateral, vars.sumBorrow);
    }
}",1456
RealWorld_TA_112_AmmGauge_RealWorld_20240815115005.log,112,AmmGauge,130759,4384,135143,153.0,0.741475,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../../interfaces/IController.sol"";
import ""../../interfaces/tokenomics/IAmmGauge.sol"";

import ""../../libraries/ScaledMath.sol"";
import ""../../libraries/Errors.sol"";
import ""../../libraries/AddressProviderHelpers.sol"";

import ""../access/Authorization.sol"";

contract AmmGauge is Authorization, IAmmGauge {
    using AddressProviderHelpers for IAddressProvider;
    using ScaledMath for uint256;
    using SafeERC20 for IERC20;

    IController public immutable controller;

    mapping(address => uint256) public balances;

    // All the data fields required for the staking tracking
    uint256 public ammStakedIntegral;
    uint256 public totalStaked;
    mapping(address => uint256) public perUserStakedIntegral;
    mapping(address => uint256) public perUserShare;

    address public immutable ammToken;
    bool public killed;
    uint48 public ammLastUpdated;

    event RewardClaimed(address indexed account, uint256 amount);

    constructor(IController _controller, address _ammToken)
        Authorization(_controller.addressProvider().getRoleManager())
    {
        ammToken = _ammToken;
        controller = _controller;
        ammLastUpdated = uint48(block.timestamp);
    }

    /**
     * @notice Shut down the gauge.
     * @dev Accrued inflation can still be claimed from the gauge after shutdown.
     * @return `true` if successful.
     */
    function kill() external override returns (bool) {
        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
        poolCheckpoint();
        killed = true;
        return true;
    }

    function claimRewards(address beneficiary) external virtual override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        if (amount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        controller.inflationManager().mintRewards(beneficiary, amount);
        emit RewardClaimed(beneficiary, amount);
        return amount;
    }

    function stake(uint256 amount) external virtual override returns (bool) {
        return stakeFor(msg.sender, amount);
    }

    function unstake(uint256 amount) external virtual override returns (bool) {
        return unstakeFor(msg.sender, amount);
    }

    function getAmmToken() external view override returns (address) {
        return ammToken;
    }

    function isAmmToken(address token) external view override returns (bool) {
        return token == ammToken;
    }

    function claimableRewards(address user) external view virtual override returns (uint256) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        if (!killed && totalStaked > 0) {
            ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) *
                (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);
        }
        return
            perUserShare[user] +
            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
    }

    /**
     * @notice Stake amount of AMM token on behalf of another account.
     * @param account Account for which tokens will be staked.
     * @param amount Amount of token to stake.
     * @return `true` if success.
     */
    function stakeFor(address account, uint256 amount) public virtual returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);

        _userCheckpoint(account);

        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));
        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = IERC20(ammToken).balanceOf(address(this));
        uint256 staked = newBal - oldBal;
        balances[account] += staked;
        totalStaked += staked;
        emit AmmStaked(account, ammToken, amount);
        return true;
    }

    /**
     * @notice Unstake amount of AMM token and send to another account.
     * @param dst Account to which unstaked AMM tokens will be sent.
     * @param amount Amount of token to unstake.
     * @return `true` if success.
     */
    function unstakeFor(address dst, uint256 amount) public virtual returns (bool) {
        require(amount > 0, Error.INVALID_AMOUNT);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        _userCheckpoint(msg.sender);

        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));
        IERC20(ammToken).safeTransfer(dst, amount);
        uint256 newBal = IERC20(ammToken).balanceOf(address(this));
        uint256 unstaked = oldBal - newBal;
        balances[msg.sender] -= unstaked;
        totalStaked -= unstaked;
        emit AmmUnstaked(msg.sender, ammToken, amount);
        return true;
    }

    function poolCheckpoint() public virtual override returns (bool) {
        if (killed) {
            return false;
        }
        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);
        // Update the integral of total token supply for the pool
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        if (totalStaked > 0) {
            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);
        }
        ammLastUpdated = uint48(block.timestamp);
        return true;
    }

    function _userCheckpoint(address user) internal virtual returns (bool) {
        poolCheckpoint();
        perUserShare[user] += balances[user].scaledMul(
            ammStakedIntegral - perUserStakedIntegral[user]
        );
        perUserStakedIntegral[user] = ammStakedIntegral;
        return true;
    }
}",1342
RealWorld_TA_112_SwapperRegistry_RealWorld_20240815081253.log,112,SwapperRegistry,80614,1961,82575,89.0,0.44229,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

import ""../libraries/Errors.sol"";
import ""./access/Authorization.sol"";
import ""../interfaces/ISwapperRegistry.sol"";

contract SwapperRegistry is ISwapperRegistry, Authorization {
    mapping(address => address[]) private _swappableTokens;
    mapping(address => mapping(address => address)) private _swapperImplementations;

    event NewSwapper(address fromToken, address toToken, address newSwapper);
    event SwapperRemoved(address fromToken, address toToken, address oldSwapper);
    event NewSwappablePair(address fromToken, address toToken);

    constructor(IRoleManager roleManager) Authorization(roleManager) {}

    /**
     * @notice Add new swapper implementation for a given token pair.
     * @param fromToken Address of token to swap.
     * @param toToken Address of token to receive.
     * @param newSwapper Address of new swapper implementation for the token pair.
     * @return True if the swapper was successfully set for the token pair.
     */
    function registerSwapper(
        address fromToken,
        address toToken,
        address newSwapper
    ) external onlyGovernance returns (bool) {
        require(
            fromToken != toToken &&
                fromToken != address(0) &&
                toToken != address(0) &&
                newSwapper != address(0),
            Error.INVALID_TOKEN_PAIR
        );
        address swapper = _swapperImplementations[fromToken][toToken];
        if (swapper != address(0)) {
            if (swapper == newSwapper) return false;
            emit SwapperRemoved(fromToken, toToken, swapper);
        } else {
            _swappableTokens[fromToken].push(toToken);
            emit NewSwappablePair(fromToken, toToken);
        }
        _swapperImplementations[fromToken][toToken] = newSwapper;
        emit NewSwapper(fromToken, toToken, newSwapper);
        return true;
    }

    /**
     * @notice Get swapper implementation for a given token pair.
     * @param fromToken Address of token to swap.
     * @param toToken Address of token to receive.
     * @return Address of swapper for token pair. Returns zero address if no swapper implementation exists.
     */
    function getSwapper(address fromToken, address toToken)
        external
        view
        override
        returns (address)
    {
        return _swapperImplementations[fromToken][toToken];
    }

    /**
     * @notice Check if a swapper implementation exists for a given token pair.
     * @param fromToken Address of token to swap.
     * @param toToken Address of token to receive.
     * @return True if a swapper exists for the token pair.
     */
    function swapperExists(address fromToken, address toToken)
        external
        view
        override
        returns (bool)
    {
        return _swapperImplementations[fromToken][toToken] != address(0) ? true : false;
    }

    function getAllSwappableTokens(address token)
        external
        view
        override
        returns (address[] memory)
    {
        return _swappableTokens[token];
    }
}",753
RealWorld_TA_112_ILpGauge_RealWorld_20240815135420.log,112,ILpGauge,23974,1336,25310,137.0,0.14659,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface ILpGauge {
    function poolCheckpoint() external returns (bool);

    function userCheckpoint(address user) external returns (bool);

    function claimableRewards(address beneficiary) external view returns (uint256);
}",68
RealWorld_TA_112_IAdmin_RealWorld_20240815131751.log,112,IAdmin,26765,1716,28481,129.0,0.168145,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

interface IAdmin {
    event NewAdminAdded(address newAdmin);
    event AdminRenounced(address oldAdmin);

    function admins() external view returns (address[] memory);

    function addAdmin(address newAdmin) external returns (bool);

    function renounceAdmin() external returns (bool);

    function isAdmin(address account) external view returns (bool);
}",94
RealWorld_TA_112_TopUpActionFeeHandler_RealWorld_20240815095145.log,112,TopUpActionFeeHandler,184110,4257,188367,140.0,1.00569,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

import ""../../../interfaces/actions/IActionFeeHandler.sol"";
import ""../../../interfaces/IController.sol"";
import ""../../../interfaces/tokenomics/IKeeperGauge.sol"";

import ""../../../libraries/Errors.sol"";
import ""../../../libraries/ScaledMath.sol"";
import ""../../../libraries/AddressProviderHelpers.sol"";

import ""../../LpToken.sol"";
import ""../../access/Authorization.sol"";
import ""../../pool/LiquidityPool.sol"";
import ""../../utils/Preparable.sol"";

/**
 * @notice Contract to manage the distribution protocol fees
 */
contract TopUpActionFeeHandler is IActionFeeHandler, Authorization, Preparable {
    using ScaledMath for uint256;
    using SafeERC20Upgradeable for LpToken;
    using AddressProviderHelpers for IAddressProvider;

    bytes32 internal constant _KEEPER_FEE_FRACTION_KEY = ""KeeperFee"";
    bytes32 internal constant _KEEPER_GAUGE_KEY = ""KeeperGauge"";
    bytes32 internal constant _TREASURY_FEE_FRACTION_KEY = ""TreasuryFee"";

    address public immutable actionContract;
    IController public immutable controller;

    mapping(address => uint256) public treasuryAmounts;
    mapping(address => mapping(address => uint256)) public keeperRecords;

    event KeeperFeesClaimed(address indexed keeper, address token, uint256 totalClaimed);

    event FeesPayed(
        address indexed payer,
        address indexed keeper,
        address token,
        uint256 amount,
        uint256 keeperAmount,
        uint256 lpAmount
    );

    constructor(
        IController _controller,
        address _actionContract,
        uint256 keeperFee,
        uint256 treasuryFee
    ) Authorization(_controller.addressProvider().getRoleManager()) {
        require(keeperFee + treasuryFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        actionContract = _actionContract;
        controller = _controller;
        _setConfig(_KEEPER_FEE_FRACTION_KEY, keeperFee);
        _setConfig(_TREASURY_FEE_FRACTION_KEY, treasuryFee);
    }

    function setInitialKeeperGaugeForToken(address lpToken, address _keeperGauge)
        external
        override
        onlyGovernance
        returns (bool)
    {
        require(getKeeperGauge(lpToken) == address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        require(_keeperGauge != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);
        _setConfig(_getKeeperGaugeKey(lpToken), _keeperGauge);
        return true;
    }

    /**
     * @notice Transfers the keeper and treasury fees to the fee handler and burns LP fees.
     * @param payer Account who's position the fees are charged on.
     * @param beneficiary Beneficiary of the fees paid (usually this will be the keeper).
     * @param amount Total fee value (both keeper and LP fees).
     * @param lpTokenAddress Address of the lpToken used to pay fees.
     * @return `true` if successful.
     */
    function payFees(
        address payer,
        address beneficiary,
        uint256 amount,
        address lpTokenAddress
    ) external override returns (bool) {
        require(msg.sender == actionContract, Error.UNAUTHORIZED_ACCESS);
        // Handle keeper fees
        uint256 keeperAmount = amount.scaledMul(getKeeperFeeFraction());
        uint256 treasuryAmount = amount.scaledMul(getTreasuryFeeFraction());
        LpToken lpToken = LpToken(lpTokenAddress);

        lpToken.safeTransferFrom(msg.sender, address(this), amount);

        address keeperGauge = getKeeperGauge(lpTokenAddress);
        if (keeperGauge != address(0)) {
            IKeeperGauge(keeperGauge).reportFees(beneficiary, keeperAmount, lpTokenAddress);
        }

        // Accrue keeper and treasury fees here for periodic claiming
        keeperRecords[beneficiary][lpTokenAddress] += keeperAmount;
        treasuryAmounts[lpTokenAddress] += treasuryAmount;

        // Handle LP fees
        uint256 lpAmount = amount - keeperAmount - treasuryAmount;
        lpToken.burn(lpAmount);
        emit FeesPayed(payer, beneficiary, lpTokenAddress, amount, keeperAmount, lpAmount);
        return true;
    }

    /**
     * @notice Claim all accrued fees for an LPToken.
     * @param beneficiary Address to claim the fees for.
     * @param token Address of the lpToken for claiming.
     * @return `true` if successful.
     */
    function claimKeeperFeesForPool(address beneficiary, address token)
        external
        override
        returns (bool)
    {
        uint256 totalClaimable = keeperRecords[beneficiary][token];
        require(totalClaimable > 0, Error.NOTHING_TO_CLAIM);
        keeperRecords[beneficiary][token] = 0;

        LpToken lpToken = LpToken(token);
        lpToken.safeTransfer(beneficiary, totalClaimable);

        emit KeeperFeesClaimed(beneficiary, token, totalClaimable);
        return true;
    }

    /**
     * @notice Claim all accrued treasury fees for an LPToken.
     * @param token Address of the lpToken for claiming.
     * @return `true` if successful.
     */
    function claimTreasuryFees(address token) external override returns (bool) {
        uint256 claimable = treasuryAmounts[token];
        treasuryAmounts[token] = 0;
        LpToken(token).safeTransfer(controller.addressProvider().getTreasury(), claimable);
        return true;
    }

    /**
     * @notice Prepare update of keeper fee (with time delay enforced).
     * @param newKeeperFee New keeper fee value.
     * @return `true` if successful.
     */
    function prepareKeeperFee(uint256 newKeeperFee) external onlyGovernance returns (bool) {
        require(newKeeperFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        return _prepare(_KEEPER_FEE_FRACTION_KEY, newKeeperFee);
    }

    /**
     * @notice Execute update of keeper fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New keeper fee.
     */
    function executeKeeperFee() external returns (uint256) {
        require(
            pendingUInts256[_TREASURY_FEE_FRACTION_KEY] +
                pendingUInts256[_KEEPER_FEE_FRACTION_KEY] <=
                ScaledMath.ONE,
            Error.INVALID_AMOUNT
        );
        return _executeUInt256(_KEEPER_FEE_FRACTION_KEY);
    }

    function resetKeeperFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_KEEPER_FEE_FRACTION_KEY);
    }

    function prepareKeeperGauge(address lpToken, address newKeeperGauge)
        external
        onlyGovernance
        returns (bool)
    {
        return _prepare(_getKeeperGaugeKey(lpToken), newKeeperGauge);
    }

    function executeKeeperGauge(address lpToken) external returns (address) {
        return _executeAddress(_getKeeperGaugeKey(lpToken));
    }

    function resetKeeperGauge(address lpToken) external onlyGovernance returns (bool) {
        return _resetAddressConfig(_getKeeperGaugeKey(lpToken));
    }

    /**
     * @notice Prepare update of treasury fee (with time delay enforced).
     * @param newTreasuryFee New treasury fee value.
     * @return `true` if successful.
     */
    function prepareTreasuryFee(uint256 newTreasuryFee) external onlyGovernance returns (bool) {
        require(newTreasuryFee <= ScaledMath.ONE, Error.INVALID_AMOUNT);
        return _prepare(_TREASURY_FEE_FRACTION_KEY, newTreasuryFee);
    }

    /**
     * @notice Execute update of treasury fee (with time delay enforced).
     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.
     * @return New treasury fee.
     */
    function executeTreasuryFee() external returns (uint256) {
        require(
            pendingUInts256[_TREASURY_FEE_FRACTION_KEY] +
                pendingUInts256[_KEEPER_FEE_FRACTION_KEY] <=
                ScaledMath.ONE,
            Error.INVALID_AMOUNT
        );
        return _executeUInt256(_TREASURY_FEE_FRACTION_KEY);
    }

    function resetTreasuryFee() external onlyGovernance returns (bool) {
        return _resetUInt256Config(_TREASURY_FEE_FRACTION_KEY);
    }

    function getKeeperFeeFraction() public view returns (uint256) {
        return currentUInts256[_KEEPER_FEE_FRACTION_KEY];
    }

    function getKeeperGauge(address lpToken) public view returns (address) {
        return currentAddresses[_getKeeperGaugeKey(lpToken)];
    }

    function getTreasuryFeeFraction() public view returns (uint256) {
        return currentUInts256[_TREASURY_FEE_FRACTION_KEY];
    }

    function _getKeeperGaugeKey(address lpToken) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_KEEPER_GAUGE_KEY, lpToken));
    }
}",2004
RealWorld_TA_112_Pausable_RealWorld_20240815084251.log,112,Pausable,39694,1357,41051,85.0,0.22561,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/Errors.sol"";

abstract contract Pausable {
    bool public isPaused;

    modifier notPaused() {
        require(!isPaused, Error.CONTRACT_PAUSED);
        _;
    }

    modifier onlyAuthorizedToPause() {
        require(_isAuthorizedToPause(msg.sender), Error.UNAUTHORIZED_PAUSE);
        _;
    }

    /**
     * @notice Pause the contract.
     * @return `true` if success.
     */
    function pause() external onlyAuthorizedToPause returns (bool) {
        isPaused = true;
        return true;
    }

    /**
     * @notice Unpause the contract.
     * @return `true` if success.
     */
    function unpause() external onlyAuthorizedToPause returns (bool) {
        isPaused = false;
        return true;
    }

    /**
     * @notice Returns true if `account` is authorized to pause the contract
     * @dev This should be implemented in contracts inheriting `Pausable`
     * to provide proper access control
     */
    function _isAuthorizedToPause(address account) internal view virtual returns (bool);
}",255
RealWorld_TA_112_InterestRateModel_RealWorld_20240815150239.log,112,InterestRateModel,45729,1256,46985,152.0,0.253765,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.9;

/**
 * @title Compound's InterestRateModel Interface
 * @author Compound
 */
abstract contract InterestRateModel {
    /// @notice Indicator that this is an InterestRateModel contract (for inspection)
    bool public constant isInterestRateModel = true;

    /**
     * @notice Calculates the current borrow interest rate per block
     * @param cash The total amount of cash the market has
     * @param borrows The total amount of borrows the market has outstanding
     * @param reserves The total amount of reserves the market has
     * @return The borrow rate per block (as a percentage, and scaled by 1e18)
     */
    function getBorrowRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves
    ) external view virtual returns (uint256);

    /**
     * @notice Calculates the current supply interest rate per block
     * @param cash The total amount of cash the market has
     * @param borrows The total amount of borrows the market has outstanding
     * @param reserves The total amount of reserves the market has
     * @param reserveFactorMantissa The current reserve factor the market has
     * @return The supply rate per block (as a percentage, and scaled by 1e18)
     */
    function getSupplyRate(
        uint256 cash,
        uint256 borrows,
        uint256 reserves,
        uint256 reserveFactorMantissa
    ) external view virtual returns (uint256);
}",329
RealWorld_TA_112_ChainlinkUsdWrapper_RealWorld_20240815082054.log,112,ChainlinkUsdWrapper,54323,2275,56598,92.0,0.317115,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""../../libraries/DecimalScale.sol"";

interface IChainlinkOracle {
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );

    function decimals() external view returns (uint8);
}

/**
 * Wrapper used for converting a Chainlink ETH Oracle to a USD Oracle.
 */
contract ChainlinkUsdWrapper is IChainlinkOracle {
    using DecimalScale for uint256;

    IChainlinkOracle private immutable _ethOracle =
        IChainlinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    IChainlinkOracle private immutable _oracle;
    uint8 private immutable _decimals;

    constructor(address oracle_) {
        _oracle = IChainlinkOracle(oracle_);
        _decimals = IChainlinkOracle(oracle_).decimals();
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        (
            uint80 roundId_,
            int256 answer_,
            uint256 startedAt_,
            uint256 updatedAt_,
            uint80 answeredInRound_
        ) = _oracle.latestRoundData();
        return (roundId_, (answer_ * _ethPrice()) / 1e8, startedAt_, updatedAt_, answeredInRound_);
    }

    function decimals() external view override returns (uint8) {
        return _decimals;
    }

    function _ethPrice() private view returns (int256) {
        (, int256 answer, , , ) = _ethOracle.latestRoundData();
        return answer;
    }
}",414
RealWorld_TA_112_Roles_RealWorld_20240815121847.log,112,Roles,30922,1138,32060,161.0,0.17737,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

// solhint-disable private-vars-leading-underscore

library Roles {
    bytes32 internal constant GOVERNANCE = ""governance"";
    bytes32 internal constant ADDRESS_PROVIDER = ""address_provider"";
    bytes32 internal constant POOL_FACTORY = ""pool_factory"";
    bytes32 internal constant CONTROLLER = ""controller"";
    bytes32 internal constant GAUGE_ZAP = ""gauge_zap"";
    bytes32 internal constant MAINTENANCE = ""maintenance"";
    bytes32 internal constant INFLATION_MANAGER = ""inflation_manager"";
    bytes32 internal constant POOL = ""pool"";
    bytes32 internal constant VAULT = ""vault"";
}",153
RealWorld_TA_113_LendingClubMock_RealWorld_20240815171708.log,113,LendingClubMock,70362,4413,74775,122.0,0.44007,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""../NFTPair.sol"";

// Minimal implementation to set up some tests.
contract LendingClubMock {
    INFTPair private immutable nftPair;
    address private immutable investor;

    constructor(INFTPair _nftPair, address _investor) public {
        nftPair = _nftPair;
        investor = _investor;
    }

    function init() public {
        nftPair.bentoBox().setMasterContractApproval(address(this), address(nftPair.masterContract()), true, 0, bytes32(0), bytes32(0));
    }

    function willLend(uint256 tokenId, TokenLoanParams memory requested) external view returns (bool) {
        if (msg.sender != address(nftPair)) {
            return false;
        }
        TokenLoanParams memory accepted = _lendingConditions(tokenId);
        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.

        return
            requested.valuation == accepted.valuation &&
            requested.duration <= accepted.duration &&
            requested.annualInterestBPS >= accepted.annualInterestBPS;
    }

    function _lendingConditions(uint256 tokenId) private pure returns (TokenLoanParams memory) {
        TokenLoanParams memory conditions;
        // No specific conditions given, but we'll take all even-numbered
        // ones at 100% APY:
        if (tokenId % 2 == 0) {
            // 256-bit addition fits by the above check.
            // Cast is.. relatively safe: this is a mock implementation,
            // production use is unlikely to follow this pattern for valuing
            // loans, and manipulating the token ID can only break the logic by
            // making the loan ""safer"" for the lender.
            conditions.valuation = uint128((tokenId + 1) * 10**18);
            conditions.duration = 365 days;
            conditions.annualInterestBPS = 10_000;
        }
        return conditions;
    }

    function lendingConditions(address _nftPair, uint256 tokenId) external view returns (TokenLoanParams memory) {
        if (_nftPair != address(nftPair)) {
            TokenLoanParams memory empty;
            return empty;
        } else {
            return _lendingConditions(tokenId);
        }
    }

    function seizeCollateral(uint256 tokenId) external {
        nftPair.removeCollateral(tokenId, investor);
    }

    function withdrawFunds(uint256 bentoShares) external {
        nftPair.bentoBox().transfer(nftPair.asset(), address(this), investor, bentoShares);
    }
}",592
RealWorld_TA_113_BentoBoxMock_RealWorld_20240815171912.log,113,BentoBoxMock,31950,4322,36272,127.0,0.24619,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""../BentoBoxFlat.sol"";

contract BentoBoxMock is BentoBoxV1 {
    constructor(IERC20 weth) public BentoBoxV1(weth) {
        return;
    }

    function addProfit(IERC20 token, uint256 amount) public {
        token.safeTransferFrom(msg.sender, address(this), amount);
        totals[token].addElastic(amount);
    }

    function takeLoss(IERC20 token, uint256 amount) public {
        token.safeTransfer(msg.sender, amount);
        totals[token].subElastic(amount);
    }
}",142
RealWorld_TA_113_IERC165_RealWorld_20240815173518.log,113,IERC165,35571,1184,36755,82.0,0.201535,"// SPDX-License-Identifier: MIT
// Taken from OpenZeppelin contracts v3

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}",209
RealWorld_TA_113_WETH9Mock_RealWorld_20240815171128.log,113,WETH9Mock,56759,2862,59621,120.0,0.341035,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.6.12;

contract WETH9Mock {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    /*fallback () external payable {
        deposit();
    }*/
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad, ""WETH9: Error"");
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad, ""WETH9: Error"");

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad, ""WETH9: Error"");
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",466
RealWorld_TA_113_SimpleStrategyMock_RealWorld_20240815173016.log,113,SimpleStrategyMock,55773,3031,58804,114.0,0.339485,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@sushiswap/bentobox-sdk/contracts/IStrategy.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";

// solhint-disable not-rely-on-time

contract SimpleStrategyMock is IStrategy {
    using BoringMath for uint256;
    using BoringERC20 for IERC20;

    IERC20 private immutable token;
    address private immutable bentoBox;

    modifier onlyBentoBox() {
        require(msg.sender == bentoBox, ""Ownable: caller is not the owner"");
        _;
    }

    constructor(address bentoBox_, IERC20 token_) public {
        bentoBox = bentoBox_;
        token = token_;
    }

    // Send the assets to the Strategy and call skim to invest them
    function skim(uint256) external override onlyBentoBox {
        // Leave the tokens on the contract
        return;
    }

    // Harvest any profits made converted to the asset and pass them to the caller
    function harvest(uint256 balance, address) external override onlyBentoBox returns (int256 amountAdded) {
        amountAdded = int256(token.balanceOf(address(this)).sub(balance));
        token.safeTransfer(bentoBox, uint256(amountAdded)); // Add as profit
    }

    // Withdraw assets. The returned amount can differ from the requested amount due to rounding or if the request was more than there is.
    function withdraw(uint256 amount) external override onlyBentoBox returns (uint256 actualAmount) {
        token.safeTransfer(bentoBox, uint256(amount)); // Add as profit
        actualAmount = amount;
    }

    // Withdraw all assets in the safest way possible. This shouldn't fail.
    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {
        amountAdded = 0;
        token.safeTransfer(bentoBox, balance);
    }
}",434
RealWorld_TA_113_NFTPair_RealWorld_20240815170323.log,113,NFTPair,696735,533,697268,150.0,3.494335,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPair
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPair is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPair public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral as the lender. The loan has to be
            // expired and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");
            require(
                // Addition is safe: both summands are smaller than 256 bits
                uint256(loan.startTime) + tokenLoanParams[tokenId].duration <= block.timestamp,
                ""NFTPair: not expired""
            );
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS,
            ""NFTPair: bad params""
        );

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x06bcca6f35b7c1b98f11abbb10957d273a681069ba90358de25404f49e2430f8;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xf2c9128b0fb8406af3168320897e5ff08f3bb536dd5f804c29ed276e93ec4336;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    nonce,
                    deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        require(block.timestamp <= deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                nonce,
                deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (
                    uint256 tokenId,
                    address borrower,
                    TokenLoanParams memory params,
                    bool skimFunds,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8144
RealWorld_TA_113_ERC721Mock_RealWorld_20240815172455.log,113,ERC721Mock,27199,2646,29845,98.0,0.188915,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/BoringMultipleNFT.sol"";

contract ERC721Mock is BoringMultipleNFT {
    function mint(address owner) public returns (uint256 id) {
        id = totalSupply;
        _mint(owner, 0);
    }

    function _tokenURI(uint256) internal view override returns (string memory) {
        return """";
    }
}",98
RealWorld_TA_113_RevertingERC20Mock_RealWorld_20240815172635.log,113,RevertingERC20Mock,58819,2829,61648,108.0,0.350675,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// RevertingERC20 reverts on errors
contract RevertingERC20Mock {
    string public symbol;
    string public name;
    uint8 public immutable decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 supply
    ) public {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
        totalSupply = supply;
        balanceOf[msg.sender] = supply;
    }

    function transfer(address to, uint256 amount) public returns (bool success) {
        require(balanceOf[msg.sender] >= amount, ""TokenB: balance too low"");
        require(amount >= 0, ""TokenB: amount should be > 0"");
        require(balanceOf[to] + amount >= balanceOf[to], ""TokenB: overflow detected"");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool success) {
        require(balanceOf[from] >= amount, ""TokenB: balance too low"");
        require(allowance[from][msg.sender] >= amount, ""TokenB: allowance too low"");
        require(amount >= 0, ""TokenB: amount should be >= 0"");
        require(balanceOf[to] + amount >= balanceOf[to], ""TokenB: overflow detected"");
        balanceOf[from] -= amount;
        allowance[from][msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool success) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
}",470
RealWorld_TA_113_SushiSwapPairMock_RealWorld_20240815171331.log,113,SushiSwapPairMock,24437,2526,26963,116.0,0.172705,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol"";

contract SushiSwapPairMock is UniswapV2Pair {
    constructor() public UniswapV2Pair() {
        return;
    }
}",71
RealWorld_TA_113_FreelyMintableERC20Mock_RealWorld_20240815170910.log,113,FreelyMintableERC20Mock,33714,4249,37963,135.0,0.25355,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""./ERC20Mock.sol"";

contract FreelyMintableERC20Mock is ERC20Mock {
    using BoringMath for uint256;

    constructor(uint256 initialSupply) public ERC20Mock(initialSupply) {}

    function mint(address to, uint256 amount) public {
        totalSupply = totalSupply.add(amount);
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }

    function burn(uint256 amount) public {
        require(amount <= balanceOf[msg.sender], ""MIM: not enough"");
        totalSupply -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}",167
RealWorld_TA_113_INFTOracle_RealWorld_20240815173343.log,113,INFTOracle,60243,1573,61816,93.0,0.332675,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.6.12;

interface INFTOracle {
    /// @notice Get the latest exchange rate.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function get(address pair, uint256 tokenId) external returns (bool success, uint256 rate);

    /// @notice Check the last exchange rate without any state changes.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function peek(address pair, uint256 tokenId) external view returns (bool success, uint256 rate);

    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return rate The rate of the requested asset / pair / pool.
    function peekSpot(address pair, uint256 tokenId) external view returns (uint256 rate);

    /// @notice Returns a human readable (short) name about this oracle.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return (string) A human readable symbol name about this oracle.
    function symbol(address pair, uint256 tokenId) external view returns (string memory);

    /// @notice Returns a human readable name about this oracle.
    /// @param pair address of the NFTPair calling the oracle
    /// @param tokenId tokenId of the NFT in question 
    /// @return (string) A human readable name about this oracle.
    function name(address pair, uint256 tokenId) external view returns (string memory);
}",487
RealWorld_TA_113_ISwapperGeneric_RealWorld_20240815173642.log,113,ISwapperGeneric,64765,1712,66477,97.0,0.358065,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.6.12;
interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}
interface ISwapperGeneric {
    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.
    /// Swaps it for at least 'amountToMin' of token 'to'.
    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.
    /// Returns the amount of tokens 'to' transferred to BentoBox.
    /// (The BentoBox skim function will be used by the caller to get the swapped funds).
    function swap(
        IERC20 fromToken,
        IERC20 toToken,
        address recipient,
        uint256 shareToMin,
        uint256 shareFrom
    ) external returns (uint256 extraShare, uint256 shareReturned);

    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),
    /// this should be less than or equal to amountFromMax.
    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.
    /// Swaps it for exactly 'exactAmountTo' of token 'to'.
    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.
    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).
    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).
    /// (The BentoBox skim function will be used by the caller to get the swapped funds).
    function swapExact(
        IERC20 fromToken,
        IERC20 toToken,
        address recipient,
        address refundTo,
        uint256 shareFromSupplied,
        uint256 shareToExact
    ) external returns (uint256 shareUsed, uint256 shareReturned);
}",564
RealWorld_TA_113_SushiSwapFactoryMock_RealWorld_20240815171529.log,113,SushiSwapFactoryMock,25896,1968,27864,96.0,0.16884,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol"";
import ""@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol"";

contract SushiSwapFactoryMock is UniswapV2Factory {
    constructor() public UniswapV2Factory(msg.sender) {
        return;
    }
}",97
RealWorld_TA_113_BentoBoxFlat_RealWorld_20240815170556.log,113,BentoBoxFlat,994334,1178,995512,192.0,4.99523,"// SPDX-License-Identifier: UNLICENSED
// The BentoBox

//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄
//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪
//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·
//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌
//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀

// This contract stores funds, handles their transfers, supports flash loans and strategies.

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to Keno for all his hard work and support

// Version 22-Mar-2021

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable not-rely-on-time
// solhint-disable no-inline-assembly

// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0
// License-Identifier: MIT

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// File contracts/interfaces/IFlashLoan.sol
// License-Identifier: MIT

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

interface IBatchFlashBorrower {
    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.
    /// @param amounts A one-to-one map to `tokens` that is loaned.
    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.
    /// @param data Additional data that was passed to the flashloan function.
    function onBatchFlashLoan(
        address sender,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        uint256[] calldata fees,
        bytes calldata data
    ) external;
}

// File contracts/interfaces/IWETH.sol
// License-Identifier: MIT

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}

// File contracts/interfaces/IStrategy.sol
// License-Identifier: MIT

interface IStrategy {
    /// @notice Send the assets to the Strategy and call skim to invest them.
    /// @param amount The amount of tokens to invest.
    function skim(uint256 amount) external;

    /// @notice Harvest any profits made converted to the asset and pass them to the caller.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);

    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.
    /// @dev The `actualAmount` should be very close to the amount.
    /// The difference should NOT be used to report a loss. That's what harvest is for.
    /// @param amount The requested amount the caller wants to withdraw.
    /// @return actualAmount The real amount that is withdrawn.
    function withdraw(uint256 amount) external returns (uint256 actualAmount);

    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function exit(uint256 balance) external returns (int256 amountAdded);
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0
// License-Identifier: MIT

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0
// License-Identifier: MIT

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0
// License-Identifier: MIT

struct Rebase {
    uint128 elastic;
    uint128 base;
}

/// @notice A rebasing library using overflow-/underflow-safe math.
library RebaseLibrary {
    using BoringMath for uint256;
    using BoringMath128 for uint128;

    /// @notice Calculates the base value in relationship to `elastic` and `total`.
    function toBase(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (uint256 base) {
        if (total.elastic == 0) {
            base = elastic;
        } else {
            base = elastic.mul(total.base) / total.elastic;
            if (roundUp && base.mul(total.elastic) / total.base < elastic) {
                base = base.add(1);
            }
        }
    }

    /// @notice Calculates the elastic value in relationship to `base` and `total`.
    function toElastic(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (uint256 elastic) {
        if (total.base == 0) {
            elastic = base;
        } else {
            elastic = base.mul(total.elastic) / total.base;
            if (roundUp && elastic.mul(total.base) / total.elastic < base) {
                elastic = elastic.add(1);
            }
        }
    }

    /// @notice Add `elastic` to `total` and doubles `total.base`.
    /// @return (Rebase) The new total.
    /// @return base in relationship to `elastic`.
    function add(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 base) {
        base = toBase(total, elastic, roundUp);
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return (total, base);
    }

    /// @notice Sub `base` from `total` and update `total.elastic`.
    /// @return (Rebase) The new total.
    /// @return elastic in relationship to `base`.
    function sub(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 elastic) {
        elastic = toElastic(total, base, roundUp);
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return (total, elastic);
    }

    /// @notice Add `elastic` and `base` to `total`.
    function add(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return total;
    }

    /// @notice Subtract `elastic` and `base` to `total`.
    function sub(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return total;
    }

    /// @notice Add `elastic` to `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.add(elastic.to128());
    }

    /// @notice Subtract `elastic` from `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.sub(elastic.to128());
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0
// License-Identifier: MIT

// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}

// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0
// License-Identifier: MIT

interface IMasterContract {
    /// @notice Init function that gets called from `BoringFactory.deploy`.
    /// Also kown as the constructor for cloned contracts.
    /// Any ETH send to `BoringFactory.deploy` ends up here.
    /// @param data Can be abi encoded arguments or anything else.
    function init(bytes calldata data) external payable;
}

// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0
// License-Identifier: MIT

contract BoringFactory {
    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);

    /// @notice Mapping from clone contracts to their masterContract.
    mapping(address => address) public masterContractOf;

    /// @notice Deploys a given master Contract as a clone.
    /// Any ETH transferred with this call is forwarded to the new clone.
    /// Emits `LogDeploy`.
    /// @param masterContract The address of the contract to clone.
    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
    /// @return cloneAddress Address of the created clone contract.
    function deploy(
        address masterContract,
        bytes calldata data,
        bool useCreate2
    ) public payable returns (address cloneAddress) {
        require(masterContract != address(0), ""BoringFactory: No masterContract"");
        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address

        if (useCreate2) {
            // each masterContract has different code already. So clones are distinguished by their data only.
            bytes32 salt = keccak256(data);

            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create2(0, clone, 0x37, salt)
            }
        } else {
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create(0, clone, 0x37)
            }
        }
        masterContractOf[cloneAddress] = masterContract;

        IMasterContract(cloneAddress).init{value: msg.value}(data);

        emit LogDeploy(masterContract, data, cloneAddress);
    }
}

// File contracts/MasterContractManager.sol
// License-Identifier: UNLICENSED

contract MasterContractManager is BoringOwnable, BoringFactory {
    event LogWhiteListMasterContract(address indexed masterContract, bool approved);
    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);
    event LogRegisterProtocol(address indexed protocol);

    /// @notice masterContract to user to approval state
    mapping(address => mapping(address => bool)) public masterContractApproved;
    /// @notice masterContract to whitelisted state for approval without signed message
    mapping(address => bool) public whitelistedMasterContracts;
    /// @notice user nonces for masterContract approvals
    mapping(address => uint256) public nonces;

    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH =
        keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DOMAIN_SEPARATOR;
    // solhint-disable-next-line var-name-mixedcase
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    constructor() public {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
    }

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this)));
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.
    function registerProtocol() public {
        masterContractOf[msg.sender] = msg.sender;
        emit LogRegisterProtocol(msg.sender);
    }

    /// @notice Enables or disables a contract for approval without signed message.
    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");

        // Effects
        whitelistedMasterContracts[masterContract] = approved;
        emit LogWhiteListMasterContract(masterContract, approved);
    }

    /// @notice Approves or revokes a `masterContract` access to `user` funds.
    /// @param user The address of the user that approves or revokes access.
    /// @param masterContract The address who gains or loses access.
    /// @param approved If True approves access. If False revokes access.
    /// @param v Part of the signature. (See EIP-191)
    /// @param r Part of the signature. (See EIP-191)
    /// @param s Part of the signature. (See EIP-191)
    // F4 - Check behaviour for all function arguments when wrong or extreme
    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.
    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails
    function setMasterContractApproval(
        address user,
        address masterContract,
        bool approved,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security

        // If no signature is provided, the fallback is executed
        if (r == 0 && s == 0 && v == 0) {
            require(user == msg.sender, ""MasterCMgr: user not sender"");
            require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");
            require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");
        } else {
            // Important for security - any address without masterContract has address(0) as masterContract
            // So approving address(0) would approve every address, leading to full loss of funds
            // Also, ecrecover returns address(0) on failure. So we check this:
            require(user != address(0), ""MasterCMgr: User cannot be 0"");

            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)
            // C10: nonce + chainId are used to prevent replays
            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)
            // C11: signature is EIP-712 compliant
            // C12 - abi.encodePacked can't contain variable length user input (SWC-133)
            // C12: abi.encodePacked has fixed length parameters
            bytes32 digest =
                keccak256(
                    abi.encodePacked(
                        EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                APPROVAL_SIGNATURE_HASH,
                                approved
                                    ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"")
                                    : keccak256(""Revoke access to BentoBox?""),
                                user,
                                masterContract,
                                approved,
                                nonces[user]++
                            )
                        )
                    )
                );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");
        }

        // Effects
        masterContractApproved[masterContract][user] = approved;
        emit LogSetMasterContractApproval(masterContract, user, approved);
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0
// License-Identifier: MIT

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}

// File contracts/BentoBox.sol
// License-Identifier: UNLICENSED

/// @title BentoBox
/// @author BoringCrypto, Keno
/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.
/// Yield from this will go to the token depositors.
/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.
/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.
contract BentoBoxV1 is MasterContractManager, BoringBatchable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;
    using RebaseLibrary for Rebase;

    // ************** //
    // *** EVENTS *** //
    // ************** //

    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);

    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);

    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);
    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategyInvest(IERC20 indexed token, uint256 amount);
    event LogStrategyDivest(IERC20 indexed token, uint256 amount);
    event LogStrategyProfit(IERC20 indexed token, uint256 amount);
    event LogStrategyLoss(IERC20 indexed token, uint256 amount);

    // *************** //
    // *** STRUCTS *** //
    // *************** //

    struct StrategyData {
        uint64 strategyStartDate;
        uint64 targetPercentage;
        uint128 balance; // the balance of the strategy that BentoBox thinks is in there
    }

    // ******************************** //
    // *** CONSTANTS AND IMMUTABLES *** //
    // ******************************** //

    // V2 - Can they be private?
    // V2: Private to save gas, to verify it's correct, check the constructor arguments
    IERC20 private immutable wethToken;

    IERC20 private constant USE_ETHEREUM = IERC20(0);
    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%
    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;
    uint256 private constant STRATEGY_DELAY = 2 weeks;
    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%
    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off

    // ***************** //
    // *** VARIABLES *** //
    // ***************** //

    // Balance per token per address/contract in shares
    mapping(IERC20 => mapping(address => uint256)) public balanceOf;

    // Rebase from amount to share
    mapping(IERC20 => Rebase) public totals;

    mapping(IERC20 => IStrategy) public strategy;
    mapping(IERC20 => IStrategy) public pendingStrategy;
    mapping(IERC20 => StrategyData) public strategyData;

    // ******************* //
    // *** CONSTRUCTOR *** //
    // ******************* //

    constructor(IERC20 wethToken_) public {
        wethToken = wethToken_;
    }

    // ***************** //
    // *** MODIFIERS *** //
    // ***************** //

    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.
    /// If 'from' is msg.sender, it's allowed.
    /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances
    /// can be taken by anyone.
    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.
    /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.
    modifier allowed(address from) {
        if (from != msg.sender && from != address(this)) {
            // From is sender or you are skimming
            address masterContract = masterContractOf[msg.sender];
            require(masterContract != address(0), ""BentoBox: no masterContract"");
            require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");
        }
        _;
    }

    // ************************** //
    // *** INTERNAL FUNCTIONS *** //
    // ************************** //

    /// @dev Returns the total balance of `token` this contracts holds,
    /// plus the total amount this contract thinks the strategy holds.
    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }

    // ************************ //
    // *** PUBLIC FUNCTIONS *** //
    // ************************ //

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        IERC20 token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share) {
        share = totals[token].toBase(amount, roundUp);
    }

    /// @dev Helper function represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        IERC20 token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount) {
        amount = totals[token].toElastic(share, roundUp);
    }

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];

        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.
        require(total.elastic != 0 || token.totalSupply() > 0, ""BentoBox: No tokens"");
        if (share == 0) {
            // value of the share may be lower than the amount due to rounding, that's ok
            share = total.toBase(amount, false);
            // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)
            if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {
                return (0, 0);
            }
        } else {
            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)
            amount = total.toElastic(share, true);
        }

        // In case of skimming, check that only the skimmable amount is taken.
        // For ETH, the full balance is available, so no need to check.
        // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.
        require(
            from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),
            ""BentoBox: Skim too much""
        );

        balanceOf[token][to] = balanceOf[token][to].add(share);
        total.base = total.base.add(share.to128());
        total.elastic = total.elastic.add(amount.to128());
        totals[token] = total;

        // Interactions
        // During the first deposit, we check that this token is 'real'
        if (token_ == USE_ETHEREUM) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)
            IWETH(address(wethToken)).deposit{value: amount}();
        } else if (from != address(this)) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.
            token.safeTransferFrom(from, address(this), amount);
        }
        emit LogDeposit(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];
        if (share == 0) {
            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)
            share = total.toBase(amount, true);
        } else {
            // amount may be lower than the value of share due to rounding, that's ok
            amount = total.toElastic(share, false);
        }

        balanceOf[token][from] = balanceOf[token][from].sub(share);
        total.elastic = total.elastic.sub(amount.to128());
        total.base = total.base.sub(share.to128());
        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)
        require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");
        totals[token] = total;

        // Interactions
        if (token_ == USE_ETHEREUM) {
            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.
            IWETH(address(wethToken)).withdraw(amount);
            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.
            (bool success, ) = to.call{value: amount}("""");
            require(success, ""BentoBox: ETH transfer failed"");
        } else {
            // X2, X3: A malicious token could block withdrawal of just THAT token.
            //         masterContracts may want to take care not to rely on withdraw always succeeding.
            token.safeTransfer(to, amount);
        }
        emit LogWithdraw(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    // Clones of master contracts can transfer from any account that has approved them
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transferMultiple for gas optimization
    function transfer(
        IERC20 token,
        address from,
        address to,
        uint256 share
    ) public allowed(from) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        balanceOf[token][from] = balanceOf[token][from].sub(share);
        balanceOf[token][to] = balanceOf[token][to].add(share);

        emit LogTransfer(token, from, to, share);
    }

    /// @notice Transfer shares from a user account to multiple other ones.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param tos The receivers of the tokens.
    /// @param shares The amount of `token` in shares for each receiver in `tos`.
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transfer for gas optimization
    function transferMultiple(
        IERC20 token,
        address from,
        address[] calldata tos,
        uint256[] calldata shares
    ) public allowed(from) {
        // Checks
        require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds

        // Effects
        uint256 totalAmount;
        uint256 len = tos.length;
        for (uint256 i = 0; i < len; i++) {
            address to = tos[i];
            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);
            totalAmount = totalAmount.add(shares[i]);
            emit LogTransfer(token, from, to, shares[i]);
        }
        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);
    }

    /// @notice Flashloan ability.
    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.
    /// @param receiver Address of the token receiver.
    /// @param token The address of the token to receive.
    /// @param amount of the tokens to receive.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) public {
        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
        token.safeTransfer(receiver, amount);

        borrower.onFlashLoan(msg.sender, token, amount, fee, data);

        require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");
        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);
    }

    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.
    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.
    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.
    /// @param tokens The addresses of the tokens.
    /// @param amounts of the tokens for each receiver.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function batchFlashLoan(
        IBatchFlashBorrower borrower,
        address[] calldata receivers,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) public {
        uint256[] memory fees = new uint256[](tokens.length);

        uint256 len = tokens.length;
        for (uint256 i = 0; i < len; i++) {
            uint256 amount = amounts[i];
            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;

            tokens[i].safeTransfer(receivers[i], amounts[i]);
        }

        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);

        for (uint256 i = 0; i < len; i++) {
            IERC20 token = tokens[i];
            require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");
            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);
        }
    }

    /// @notice Sets the target percentage of the strategy for `token`.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.
    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {
        // Checks
        require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");

        // Effects
        strategyData[token].targetPercentage = targetPercentage_;
        emit LogStrategyTargetPercentage(token, targetPercentage_);
    }

    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.
    /// Must be called twice with the same arguments.
    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param newStrategy The address of the contract that conforms to `IStrategy`.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // C4 - Use block.timestamp only for long intervals (SWC-116)
    // C4: block.timestamp is used for a period of 2 weeks, which is long enough
    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }

    /// @notice The actual process of yield farming. Executes the strategy of `token`.
    /// Optionally does housekeeping if `balance` is true.
    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.
    /// @param token The address of the token for which a strategy is deployed.
    /// @param balance True if housekeeping should be done.
    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?
    function harvest(
        IERC20 token,
        bool balance,
        uint256 maxChangeAmount
    ) public {
        StrategyData memory data = strategyData[token];
        IStrategy _strategy = strategy[token];
        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);
        if (balanceChange == 0 && !balance) {
            return;
        }

        uint256 totalElastic = totals[token].elastic;

        if (balanceChange > 0) {
            uint256 add = uint256(balanceChange);
            totalElastic = totalElastic.add(add);
            totals[token].elastic = totalElastic.to128();
            emit LogStrategyProfit(token, add);
        } else if (balanceChange < 0) {
            // C1 - All math done through BoringMath (SWC-101)
            // C1: balanceChange could overflow if it's max negative int128.
            // But tokens with balances that large are not supported by the BentoBox.
            uint256 sub = uint256(-balanceChange);
            totalElastic = totalElastic.sub(sub);
            totals[token].elastic = totalElastic.to128();
            data.balance = data.balance.sub(sub.to128());
            emit LogStrategyLoss(token, sub);
        }

        if (balance) {
            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;
            // if data.balance == targetBalance there is nothing to update
            if (data.balance < targetBalance) {
                uint256 amountOut = targetBalance.sub(data.balance);
                if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {
                    amountOut = maxChangeAmount;
                }
                token.safeTransfer(address(_strategy), amountOut);
                data.balance = data.balance.add(amountOut.to128());
                _strategy.skim(amountOut);
                emit LogStrategyInvest(token, amountOut);
            } else if (data.balance > targetBalance) {
                uint256 amountIn = data.balance.sub(targetBalance.to128());
                if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {
                    amountIn = maxChangeAmount;
                }

                uint256 actualAmountIn = _strategy.withdraw(amountIn);

                data.balance = data.balance.sub(actualAmountIn.to128());
                emit LogStrategyDivest(token, actualAmountIn);
            }
        }

        strategyData[token] = data;
    }

    // Contract should be able to receive ETH deposits to support deposit & skim
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}",11873
RealWorld_TA_113_ERC20Mock_RealWorld_20240815172252.log,113,ERC20Mock,27682,2891,30573,120.0,0.19623,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/ERC20.sol"";

contract ERC20Mock is ERC20 {
    uint256 public override totalSupply;

    constructor(uint256 _initialAmount) public {
        // Give the creator all initial tokens
        balanceOf[msg.sender] = _initialAmount;
        // Update total supply
        totalSupply = _initialAmount;
    }
}",95
RealWorld_TA_113_IERC721_RealWorld_20240815173212.log,113,IERC721,112055,1303,113358,89.0,0.586335,"// SPDX-License-Identifier: MIT
// Taken from OpenZeppelin contracts v3

pragma solidity >=0.6.2 <0.8.0;

import ""./IERC165.sol"";

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Transfers `tokenId` token from `from` to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 tokenId) external;

    /**
     * @dev Gives permission to `to` to transfer `tokenId` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - `tokenId` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Returns the account approved for `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Approve or remove `operator` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The `operator` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    /**
      * @dev Safely transfers `tokenId` token from `from` to `to`.
      *
      * Requirements:
      *
      * - `from` cannot be the zero address.
      * - `to` cannot be the zero address.
      * - `tokenId` token must exist and be owned by `from`.
      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
      *
      * Emits a {Transfer} event.
      */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}",1102
RealWorld_TA_113_ReturnFalseERC20Mock_RealWorld_20240815172825.log,113,ReturnFalseERC20Mock,82397,3247,85644,109.0,0.476925,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// solhint-disable no-inline-assembly
// solhint-disable not-rely-on-time

// ReturnFalseERC20 does not revert on errors, it just returns false
contract ReturnFalseERC20Mock {
    string public symbol;
    string public name;
    uint8 public immutable decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint256 supply
    ) public {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
        totalSupply = supply;
        balanceOf[msg.sender] = supply;
    }

    function transfer(address to, uint256 amount) public returns (bool success) {
        if (balanceOf[msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {
            balanceOf[msg.sender] -= amount;
            balanceOf[to] += amount;
            emit Transfer(msg.sender, to, amount);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool success) {
        if (balanceOf[from] >= amount && allowance[from][msg.sender] >= amount && balanceOf[to] + amount >= balanceOf[to]) {
            balanceOf[from] -= amount;
            allowance[from][msg.sender] -= amount;
            balanceOf[to] += amount;
            emit Transfer(from, to, amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address spender, uint256 amount) public returns (bool success) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return keccak256(abi.encode(keccak256(""EIP712Domain(uint256 chainId,address verifyingContract)""), chainId, address(this)));
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(block.timestamp < deadline, ""ReturnFalseERC20: Expired"");
        bytes32 digest =
            keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    DOMAIN_SEPARATOR(),
                    keccak256(
                        abi.encode(
                            0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,
                            owner,
                            spender,
                            value,
                            nonces[owner]++,
                            deadline
                        )
                    )
                )
            );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == owner, ""ReturnFalseERC20: Invalid Sig"");
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }
}",744
RealWorld_TA_113_NFTPairWithOracle_RealWorld_20240815170056.log,113,NFTPairWithOracle,719500,598,720098,144.0,3.60946,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8413
RealWorld_TA_113_ExternalFunctionMock_RealWorld_20240815172121.log,113,ExternalFunctionMock,25976,1467,27443,89.0,0.15922,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";

contract ExternalFunctionMock {
    using BoringMath for uint256;

    event Result(uint256 output);

    function sum(uint256 a, uint256 b) external returns (uint256 c) {
        c = a.add(b);
        emit Result(c);
    }
}",89
RealWorld_TA_114_ERC20Mintable_RealWorld_20240815174918.log,114,ERC20Mintable,43164,2955,46119,105.0,0.27492,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";

/**
 * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract ERC20Mintable is ERC20Permit {
  uint8 internal _decimals;

  constructor(
    string memory _name,
    string memory _symbol,
    uint8 decimals_
  ) ERC20(_name, _symbol) ERC20Permit(_name) {
    _decimals = decimals_;
  }

  function decimals() public view override returns (uint8) {
    return _decimals;
  }

  /**
   * @dev See {ERC20-_mint}.
   *
   * Requirements:
   *
   * - the caller must have the {MinterRole}.
   */
  function mint(address account, uint256 amount) public returns (bool) {
    _mint(account, amount);
    return true;
  }

  function burn(address account, uint256 amount) public returns (bool) {
    _burn(account, amount);
    return true;
  }
}",297
RealWorld_TA_114_SafeERC20Wrapper_RealWorld_20240815174715.log,114,SafeERC20Wrapper,69399,3525,72924,121.0,0.417495,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

// Mock implementation from OpenZeppelin modified for our usage in tests
// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/mocks/SafeERC20Helper.sol
contract ERC20ReturnTrueMock is ERC20 {
  mapping(address => uint256) private _allowances;

  // IERC20's functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,
  // we write to a dummy state variable.
  uint256 private _dummy;

  constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

  function transfer(address, uint256) public override returns (bool) {
    _dummy = 0;
    return true;
  }

  function transferFrom(
    address,
    address,
    uint256
  ) public override returns (bool) {
    _dummy = 0;
    return true;
  }

  function approve(address, uint256) public override returns (bool) {
    _dummy = 0;
    return true;
  }

  function setAllowance(uint256 allowance_) public {
    _allowances[_msgSender()] = allowance_;
  }

  function allowance(address owner, address) public view override returns (uint256) {
    return _allowances[owner];
  }

  uint256[48] private __gap;
}

contract SafeERC20Wrapper {
  using SafeERC20 for IERC20;

  IERC20 private _token;

  constructor(IERC20 token) {
    _token = token;
  }

  function balanceOf(address account) public view returns (uint256) {
    return _token.balanceOf(account);
  }

  function transfer(address recipient, uint256 amount) public {
    _token.safeTransfer(recipient, amount);
  }

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) public {
    _token.safeTransferFrom(sender, recipient, amount);
  }

  function approve(address spender, uint256 amount) public {
    _token.safeApprove(spender, amount);
  }

  function increaseAllowance(uint256 amount) public {
    _token.safeIncreaseAllowance(address(0), amount);
  }

  function decreaseAllowance(uint256 amount) public {
    _token.safeDecreaseAllowance(address(0), amount);
  }

  function setAllowance(uint256 allowance_) public {
    ERC20ReturnTrueMock(address(_token)).setAllowance(allowance_);
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return _token.allowance(owner, spender);
  }

  uint256[49] private __gap;
}",624
RealWorld_TA_114_AaveV3YieldSourceHarness_RealWorld_20240815175106.log,114,AaveV3YieldSourceHarness,43932,2339,46271,106.0,0.26644,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import ""../AaveV3YieldSource.sol"";

contract AaveV3YieldSourceHarness is AaveV3YieldSource {
  constructor(
    IAToken _aToken,
    IRewardsController _rewardsController,
    IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,
    string memory _name,
    string memory _symbol,
    uint8 _decimals,
    address _owner
  )
    AaveV3YieldSource(
      _aToken,
      _rewardsController,
      _poolAddressesProviderRegistry,
      _name,
      _symbol,
      _decimals,
      _owner
    )
  {}

  function mint(address account, uint256 amount) public returns (bool) {
    _mint(account, amount);
    return true;
  }

  function tokenToShares(uint256 tokens) external view returns (uint256) {
    return _tokenToShares(tokens);
  }

  function sharesToToken(uint256 shares) external view returns (uint256) {
    return _sharesToToken(shares);
  }

  function tokenAddress() external view returns (address) {
    return _tokenAddress();
  }

  function poolProvider() external view returns (IPoolAddressesProvider) {
    return _poolProvider();
  }

  function pool() external view returns (IPool) {
    return _pool();
  }
}",303
RealWorld_TA_114_AaveV3YieldSource_RealWorld_20240815174431.log,114,AaveV3YieldSource,328619,4943,333562,162.0,1.741955,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.10;

import { IAToken } from ""@aave/core-v3/contracts/interfaces/IAToken.sol"";
import { IPool } from ""@aave/core-v3/contracts/interfaces/IPool.sol"";
import { IPoolAddressesProvider } from ""@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol"";
import { IPoolAddressesProviderRegistry } from ""@aave/core-v3/contracts/interfaces/IPoolAddressesProviderRegistry.sol"";
import { IRewardsController } from ""@aave/periphery-v3/contracts/rewards/interfaces/IRewardsController.sol"";

import { ERC20 } from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { SafeMath } from ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

import { Manageable, Ownable } from ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

/**
 * @title Aave V3 Yield Source contract, implementing PoolTogether's generic yield source interface.
 * @dev This contract inherits from the ERC20 implementation to keep track of users deposits.
 * @notice Yield Source for a PoolTogether prize pool that generates yield by depositing into Aave V3.
 */
contract AaveV3YieldSource is ERC20, IYieldSource, Manageable, ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  /* ============ Events ============ */

  /**
   * @notice Emitted when the yield source is initialized.
   * @param aToken Aave aToken address
   * @param rewardsController Aave rewardsController address
   * @param poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address
   * @param name Token name for the underlying ERC20 shares
   * @param symbol Token symbol for the underlying ERC20 shares
   * @param decimals Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares.
   * @param owner Owner of this contract
   */
  event AaveV3YieldSourceInitialized(
    IAToken indexed aToken,
    IRewardsController rewardsController,
    IPoolAddressesProviderRegistry poolAddressesProviderRegistry,
    string name,
    string symbol,
    uint8 decimals,
    address owner
  );

  /**
   * @notice Emitted when asset tokens are supplied to the yield source.
   * @param from Address that supplied the tokens
   * @param shares Amount of shares minted to the user
   * @param amount Amount of tokens supplied
   * @param to Address that received the shares
   */
  event SuppliedTokenTo(address indexed from, uint256 shares, uint256 amount, address indexed to);

  /**
   * @notice Emitted when asset tokens are redeemed from the yield source.
   * @param from Address who redeemed the tokens
   * @param shares Amount of shares burnt
   * @param amount Amount of tokens redeemed
   */
  event RedeemedToken(address indexed from, uint256 shares, uint256 amount);

  /**
   * @notice Emitted when Aave rewards have been claimed.
   * @param from Address who claimed the rewards
   * @param to Address that received the rewards
   * @param rewardsList List of addresses of the reward tokens
   * @param claimedAmounts List that contains the claimed amount per reward token
   */
  event Claimed(
    address indexed from,
    address indexed to,
    address[] rewardsList,
    uint256[] claimedAmounts
  );

  /**
   * @notice Emitted when decreasing allowance of ERC20 tokens other than yield source's aToken.
   * @param from Address of the caller
   * @param spender Address of the spender
   * @param amount Amount of `token` to decrease allowance by
   * @param token Address of the ERC20 token to decrease allowance for
   */
  event DecreasedERC20Allowance(
    address indexed from,
    address indexed spender,
    uint256 amount,
    IERC20 indexed token
  );

  /**
   * @notice Emitted when increasing allowance of ERC20 tokens other than yield source's aToken.
   * @param from Address of the caller
   * @param spender Address of the spender
   * @param amount Amount of `token` to increase allowance by
   * @param token Address of the ERC20 token to increase allowance for
   */
  event IncreasedERC20Allowance(
    address indexed from,
    address indexed spender,
    uint256 amount,
    IERC20 indexed token
  );

  /**
   * @notice Emitted when ERC20 tokens other than yield source's aToken are withdrawn from the yield source.
   * @param from Address of the caller
   * @param to Address of the recipient
   * @param amount Amount of `token` transferred
   * @param token Address of the ERC20 token transferred
   */
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20 indexed token
  );

  /* ============ Variables ============ */

  /// @notice Yield-bearing Aave aToken address.
  IAToken public aToken;

  /// @notice Aave RewardsController address.
  IRewardsController public rewardsController;

  /// @notice Aave poolAddressesProviderRegistry address.
  IPoolAddressesProviderRegistry public poolAddressesProviderRegistry;

  /// @notice ERC20 token decimals.
  uint8 private immutable _decimals;

  /**
   * @dev Aave genesis market PoolAddressesProvider's ID.
   * @dev This variable could evolve in the future if we decide to support other markets.
   */
  uint256 private constant ADDRESSES_PROVIDER_ID = uint256(0);

  /// @dev PoolTogether's Aave Referral Code
  uint16 private constant REFERRAL_CODE = uint16(188);

  /* ============ Constructor ============ */

  /**
   * @notice Initializes the yield source with Aave aToken.
   * @param _aToken Aave aToken address
   * @param _rewardsController Aave rewardsController address
   * @param _poolAddressesProviderRegistry Aave poolAddressesProviderRegistry address
   * @param _name Token name for the underlying ERC20 shares
   * @param _symbol Token symbol for the underlying ERC20 shares
   * @param decimals_ Number of decimals the shares (inhereted ERC20) will have. Same as underlying asset to ensure sane exchange rates for shares.
   * @param _owner Owner of this contract
   */
  constructor(
    IAToken _aToken,
    IRewardsController _rewardsController,
    IPoolAddressesProviderRegistry _poolAddressesProviderRegistry,
    string memory _name,
    string memory _symbol,
    uint8 decimals_,
    address _owner
  ) Ownable(_owner) ERC20(_name, _symbol) ReentrancyGuard() {
    require(address(_aToken) != address(0), ""AaveV3YS/aToken-not-zero-address"");
    aToken = _aToken;

    require(address(_rewardsController) != address(0), ""AaveV3YS/RC-not-zero-address"");
    rewardsController = _rewardsController;

    require(address(_poolAddressesProviderRegistry) != address(0), ""AaveV3YS/PR-not-zero-address"");
    poolAddressesProviderRegistry = _poolAddressesProviderRegistry;

    require(_owner != address(0), ""AaveV3YS/owner-not-zero-address"");

    require(decimals_ > 0, ""AaveV3YS/decimals-gt-zero"");
    _decimals = decimals_;

    // Approve once for max amount
    IERC20(_tokenAddress()).safeApprove(address(_pool()), type(uint256).max);

    emit AaveV3YieldSourceInitialized(
      _aToken,
      _rewardsController,
      _poolAddressesProviderRegistry,
      _name,
      _symbol,
      decimals_,
      _owner
    );
  }

  /* ============ External Functions ============ */

  /**
   * @notice Returns user total balance (in asset tokens). This includes their deposit and interest.
   * @param _user Address of the user to get balance of token for
   * @return The underlying balance of asset tokens.
   */
  function balanceOfToken(address _user) external override returns (uint256) {
    return _sharesToToken(balanceOf(_user));
  }

  /**
   * @notice Returns the ERC20 asset token used for deposits.
   * @return The ERC20 asset token address.
   */
  function depositToken() public view override returns (address) {
    return _tokenAddress();
  }

  /**
   * @notice Returns the Yield Source ERC20 token decimals.
   * @dev This value should be equal to the decimals of the token used to deposit into the pool.
   * @return The number of decimals.
   */
  function decimals() public view virtual override returns (uint8) {
    return _decimals;
  }

  /**
   * @notice Supplies asset tokens to the yield source.
   * @dev Shares corresponding to the number of tokens supplied are minted to the user's balance.
   * @dev Asset tokens are supplied to the yield source, then deposited into Aave.
   * @param _depositAmount The amount of asset tokens to be supplied
   * @param _to The user whose balance will receive the tokens
   */
  function supplyTokenTo(uint256 _depositAmount, address _to) external override nonReentrant {
    uint256 _shares = _tokenToShares(_depositAmount);
    require(_shares > 0, ""AaveV3YS/shares-gt-zero"");

    address _underlyingAssetAddress = _tokenAddress();
    IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);
    _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);

    _mint(_to, _shares);

    emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);
  }

  /**
   * @notice Redeems asset tokens from the yield source.
   * @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance.
   * @dev Asset tokens are withdrawn from Aave, then transferred from the yield source to the user's wallet.
   * @param _redeemAmount The amount of asset tokens to be redeemed
   * @return The actual amount of asset tokens that were redeemed.
   */
  function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {
    address _underlyingAssetAddress = _tokenAddress();
    IERC20 _assetToken = IERC20(_underlyingAssetAddress);

    uint256 _shares = _tokenToShares(_redeemAmount);
    _burn(msg.sender, _shares);

    uint256 _beforeBalance = _assetToken.balanceOf(address(this));
    _pool().withdraw(_underlyingAssetAddress, _redeemAmount, address(this));
    uint256 _afterBalance = _assetToken.balanceOf(address(this));

    uint256 _balanceDiff = _afterBalance.sub(_beforeBalance);
    _assetToken.safeTransfer(msg.sender, _balanceDiff);

    emit RedeemedToken(msg.sender, _shares, _redeemAmount);
    return _balanceDiff;
  }

  /**
   * @notice Claims the accrued rewards for the aToken, accumulating any pending rewards.
   * @dev Only callable by the owner or manager.
   * @param _to Address where the claimed rewards will be sent
   * @return True if operation was successful.
   */
  function claimRewards(address _to) external onlyManagerOrOwner returns (bool) {
    require(_to != address(0), ""AaveV3YS/payee-not-zero-address"");

    address[] memory _assets = new address[](1);
    _assets[0] = address(aToken);

    (address[] memory _rewardsList, uint256[] memory _claimedAmounts) = rewardsController
      .claimAllRewards(_assets, _to);

    emit Claimed(msg.sender, _to, _rewardsList, _claimedAmounts);
    return true;
  }

  /**
   * @notice Decrease allowance of ERC20 tokens other than the aTokens held by this contract.
   * @dev This function is only callable by the owner or asset manager.
   * @dev Current allowance should be computed off-chain to avoid any underflow.
   * @param _token Address of the ERC20 token to decrease allowance for
   * @param _spender Address of the spender of the tokens
   * @param _amount Amount of tokens to decrease allowance by
   */
  function decreaseERC20Allowance(
    IERC20 _token,
    address _spender,
    uint256 _amount
  ) external onlyManagerOrOwner {
    _requireNotAToken(address(_token));
    _token.safeDecreaseAllowance(_spender, _amount);
    emit DecreasedERC20Allowance(msg.sender, _spender, _amount, _token);
  }

  /**
   * @notice Increase allowance of ERC20 tokens other than the aTokens held by this contract.
   * @dev This function is only callable by the owner or asset manager.
   * @dev Allows another contract or address to withdraw funds from the yield source.
   * @dev Current allowance should be computed off-chain to avoid any overflow.
   * @param _token Address of the ERC20 token to increase allowance for
   * @param _spender Address of the spender of the tokens
   * @param _amount Amount of tokens to increase allowance by
   */
  function increaseERC20Allowance(
    IERC20 _token,
    address _spender,
    uint256 _amount
  ) external onlyManagerOrOwner {
    _requireNotAToken(address(_token));
    _token.safeIncreaseAllowance(_spender, _amount);
    emit IncreasedERC20Allowance(msg.sender, _spender, _amount, _token);
  }

  /**
   * @notice Transfer ERC20 tokens other than the aTokens held by this contract to the recipient address.
   * @dev This function is only callable by the owner or asset manager.
   * @param _token Address of the ERC20 token to transfer
   * @param _to Address of the recipient of the tokens
   * @param _amount Amount of tokens to transfer
   */
  function transferERC20(
    IERC20 _token,
    address _to,
    uint256 _amount
  ) external onlyManagerOrOwner {
    require(address(_token) != address(aToken), ""AaveV3YS/forbid-aToken-transfer"");
    _token.safeTransfer(_to, _amount);
    emit TransferredERC20(msg.sender, _to, _amount, _token);
  }

  /* ============ Internal Functions ============ */

  /**
   * @notice Check that the token address passed is not the aToken address.
   * @param _token Address of the ERC20 token to check
   */
  function _requireNotAToken(address _token) internal view {
    require(_token != address(aToken), ""AaveV3YS/forbid-aToken-allowance"");
  }

  /**
   * @notice Calculates the number of shares that should be minted or burnt when a user deposit or withdraw.
   * @param _tokens Amount of asset tokens
   * @return Number of shares.
   */
  function _tokenToShares(uint256 _tokens) internal view returns (uint256) {
    uint256 _supply = totalSupply();

    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply
    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));
  }

  /**
   * @notice Calculates the number of asset tokens a user has in the yield source.
   * @param _shares Amount of shares
   * @return Number of asset tokens.
   */
  function _sharesToToken(uint256 _shares) internal view returns (uint256) {
    uint256 _supply = totalSupply();

    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares
    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);
  }

  /**
   * @notice Returns the underlying asset token address.
   * @return Underlying asset token address.
   */
  function _tokenAddress() internal view returns (address) {
    return aToken.UNDERLYING_ASSET_ADDRESS();
  }

  /**
   * @notice Retrieves Aave PoolAddressesProvider address.
   * @return A reference to PoolAddressesProvider interface.
   */
  function _poolProvider() internal view returns (IPoolAddressesProvider) {
    return
      IPoolAddressesProvider(
        poolAddressesProviderRegistry.getAddressesProvidersList()[ADDRESSES_PROVIDER_ID]
      );
  }

  /**
   * @notice Retrieves Aave Pool address.
   * @return A reference to Pool interface.
   */
  function _pool() internal view returns (IPool) {
    return IPool(_poolProvider().getPool());
  }
}",3727
RealWorld_TA_115_BalancerV2LPOracle_RealWorld_20240815205751.log,115,BalancerV2LPOracle,155438,2989,158427,120.0,0.83697,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IBalancerVault.sol"";
import ""../interfaces/IBalancerPool.sol"";
import ""../libraries/BNum.sol"";
import ""../libraries/MathPow.sol"";

contract BalancerV2LPOracle is AggregatorV3Interface, BNum {
  using SafeMath for uint256;

  string public override description;
  uint256 public override version = 3;
  uint8 public override decimals;

  bytes32 public poolId;
  IBalancerVault public vault;
  IBalancerPool public pool;
  AggregatorV3Interface public oracleA;
  AggregatorV3Interface public oracleB;

  constructor(
    uint8 _decimals,
    string memory _description,
    IBalancerVault _vault,
    bytes32 _poolId,
    AggregatorV3Interface _oracleA,
    AggregatorV3Interface _oracleB
  ) public {
    require(address(_vault) != address(0), ""C000"");
    require(address(_oracleA) != address(0), ""C000"");
    require(address(_oracleB) != address(0), ""C000"");

    vault = _vault;
    poolId = _poolId;
    (address _pool, IBalancerVault.PoolSpecialization tokensNum) = vault.getPool(poolId);
    require(tokensNum == IBalancerVault.PoolSpecialization.TWO_TOKEN, ""C001"");

    decimals = _decimals;
    description = _description;
    pool = IBalancerPool(_pool);
    oracleA = _oracleA;
    oracleB = _oracleB;
  }

  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    // Skip the implementation since it is not used by price feed
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    (address[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);
    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();
    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();

    uint256[] memory normalizedWeights = pool.getNormalizedWeights();

    uint256 pxA = uint256(answerA);
    uint256 pxB = uint256(answerB);
    (uint256 fairResA, uint256 fairResB) = _computeFairReserves(
      _getNormalizedBalance(tokens[0], balances[0]),
      _getNormalizedBalance(tokens[1], balances[1]),
      normalizedWeights[0],
      normalizedWeights[1],
      pxA,
      pxB
    );

    answer = int256(fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply()));
    updatedAt = assetUpdatedAtA;

    // use oldest timestamp for updatedAt
    if (assetUpdatedAtA > assetUpdatedAtB) {
      updatedAt = assetUpdatedAtB;
    }
  }

  function _getNormalizedBalance(address token, uint256 balance) internal view returns (uint256) {
    uint8 decimals = ERC20(token).decimals();
    return balance.mul(MathPow.pow(10, 18 - decimals));
  }

  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.
  /// @param resA Reserve of the first asset
  /// @param resB Reserve of the second asset
  /// @param wA Weight of the first asset
  /// @param wB Weight of the second asset
  /// @param pxA Fair price of the first asset
  /// @param pxB Fair price of the second asset
  function _computeFairReserves(
    uint256 resA,
    uint256 resB,
    uint256 wA,
    uint256 wB,
    uint256 pxA,
    uint256 pxB
  ) internal pure returns (uint256 fairResA, uint256 fairResB) {
    // NOTE: wA + wB = 1 (normalize weights)
    // constant product = resA^wA * resB^wB
    // constraints:
    // - fairResA^wA * fairResB^wB = constant product
    // - fairResA * pxA / wA = fairResB * pxB / wB
    // Solving equations:
    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product
    // --> fairResA / r1^wB = constant product
    // --> fairResA = resA^wA * resB^wB * r1^wB
    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB
    uint256 r0 = bdiv(resA, resB);
    uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));
    // fairResA = resA * (r1 / r0) ^ wB
    // fairResB = resB * (r0 / r1) ^ wA
    if (r0 > r1) {
      uint256 ratio = bdiv(r1, r0);
      fairResA = bmul(resA, bpow(ratio, wB));
      fairResB = bdiv(resB, bpow(ratio, wA));
    } else {
      uint256 ratio = bdiv(r0, r1);
      fairResA = bdiv(resA, bpow(ratio, wB));
      fairResB = bmul(resB, bpow(ratio, wA));
    }
  }
}",1611
RealWorld_TA_115_IGenericMiner_RealWorld_20240815202510.log,115,IGenericMiner,39697,1779,41476,140.0,0.234065,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../interfaces/IAddressProvider.sol"";
import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";

interface IGenericMiner {
  struct UserInfo {
    uint256 stake;
    uint256 accAmountPerShare; // User's accAmountPerShare
  }

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeIncreased(address indexed user, uint256 stake);

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeDecreased(address indexed user, uint256 stake);

  function releaseMIMO(address _user) external;

  function a() external view returns (IGovernanceAddressProvider);

  function stake(address _user) external view returns (uint256);

  function pendingMIMO(address _user) external view returns (uint256);

  function totalStake() external view returns (uint256);

  function userInfo(address _user) external view returns (UserInfo memory);
}",249
RealWorld_TA_115_VaultsCoreState_RealWorld_20240815203939.log,115,VaultsCoreState,119880,4016,123896,137.0,0.67972,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""../libraries/WadRayMath.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCoreState.sol"";
import ""../v1/interfaces/IVaultsCoreV1.sol"";

contract VaultsCoreState is IVaultsCoreState {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 internal constant _MAX_INT = 2**256 - 1;

  bool public override synced = false;
  IAddressProvider public override a;

  mapping(address => uint256) public override cumulativeRates;
  mapping(address => uint256) public override lastRefresh;

  modifier onlyConfig() {
    require(msg.sender == address(a.config()));
    _;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));
    _;
  }

  modifier notSynced() {
    require(!synced);
    _;
  }

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Calculate the available income
    @return available income that has not been minted yet.
  **/
  function availableIncome() public view override returns (uint256) {
    return a.vaultsData().debt().sub(a.stablex().totalSupply());
  }

  /**
    Refresh the cumulative rates and debts of all vaults and all collateral types.
    @dev anyone can call this.
  **/
  function refresh() public override {
    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      refreshCollateral(collateralType);
    }
  }

  /**
    Sync state with another instance. This is used during version upgrade to keep V2 in sync with V2.
    @dev This call will read the state via
      `cumulativeRates(address collateralType)` and `lastRefresh(address collateralType)`.
    @param _stateAddress address from which the state is to be copied.
  **/
  function syncState(IVaultsCoreState _stateAddress) public override onlyManager notSynced {
    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      cumulativeRates[collateralType] = _stateAddress.cumulativeRates(collateralType);
      lastRefresh[collateralType] = _stateAddress.lastRefresh(collateralType);
    }
    synced = true;
  }

  /**
    Sync state with v1 core. This is used during version upgrade to keep V2 in sync with V1.
    @dev This call will read the state via
      `cumulativeRates(address collateralType)` and `lastRefresh(address collateralType)`.
    @param _core address of core v1 from which the state is to be copied.
  **/
  function syncStateFromV1(IVaultsCoreV1 _core) public override onlyManager notSynced {
    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      cumulativeRates[collateralType] = _core.cumulativeRates(collateralType);
      lastRefresh[collateralType] = _core.lastRefresh(collateralType);
    }
    synced = true;
  }

  /**
    Initialize the cumulative rates to 1 for a new collateral type.
    @param _collateralType the address of the new collateral type to be initialized
  **/
  function initializeRates(address _collateralType) public override onlyConfig {
    require(_collateralType != address(0));
    lastRefresh[_collateralType] = block.timestamp;
    cumulativeRates[_collateralType] = WadRayMath.ray();
  }

  /**
    Refresh the cumulative rate of a collateraltype.
    @dev this updates the debt for all vaults with the specified collateral type.
    @param _collateralType the address of the collateral type to be refreshed.
  **/
  function refreshCollateral(address _collateralType) public override {
    require(_collateralType != address(0));
    require(a.config().collateralIds(_collateralType) != 0);
    uint256 timestamp = block.timestamp;
    uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);
    _refreshCumulativeRate(_collateralType, timeElapsed);
    lastRefresh[_collateralType] = timestamp;
  }

  /**
    Internal function to increase the cumulative rate over a specified time period
    @dev this updates the debt for all vaults with the specified collateral type.
    @param _collateralType the address of the collateral type to be updated
    @param _timeElapsed the amount of time in seconds to add to the cumulative rate
  **/
  function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {
    uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);
    uint256 oldCumulativeRate = cumulativeRates[_collateralType];
    cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(
      borrowRate,
      oldCumulativeRate,
      _timeElapsed
    );
    emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);
  }
}",1205
RealWorld_TA_115_DemandMiner_RealWorld_20240815194338.log,115,DemandMiner,47918,3134,51052,110.0,0.30227,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""./GenericMiner.sol"";
import ""./interfaces/IMIMO.sol"";
import ""./interfaces/IDemandMiner.sol"";

contract DemandMiner is IDemandMiner, GenericMiner {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  IERC20 public override token;

  constructor(IGovernanceAddressProvider _addresses, IERC20 _token) public GenericMiner(_addresses) {
    require(address(_token) != address(0));
    require(address(_token) != address(_addresses.mimo()));
    token = _token;
  }

  /**
    Deposit an ERC20 pool token for staking
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param amount the amount of tokens to be deposited. Unit is in WEI.
  **/
  function deposit(uint256 amount) public override {
    token.safeTransferFrom(msg.sender, address(this), amount);
    _increaseStake(msg.sender, amount);
  }

  /**
    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.
    @param amount the amount of tokens to be withdrawn. Unit is in WEI.
  **/
  function withdraw(uint256 amount) public override {
    token.safeTransfer(msg.sender, amount);
    _decreaseStake(msg.sender, amount);
  }
}",361
RealWorld_TA_115_DexAddressProvider_RealWorld_20240815220720.log,115,DexAddressProvider,54034,2176,56210,104.0,0.31369,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./interfaces/IDexAddressProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract DexAddressProvider is IDexAddressProvider {
  IAddressProvider private _a;
  mapping(uint256 => Dex) private _dexMapping;

  constructor(IAddressProvider a, Dex[] memory dexes) public {
    require(address(a) != address(0), ""LM000"");
    _a = a;
    for (uint256 i; i < dexes.length; i++) {
      _dexMapping[i] = Dex({ proxy: dexes[i].proxy, router: dexes[i].router });
    }
  }

  modifier onlyManager() {
    require(_a.controller().hasRole(_a.controller().MANAGER_ROLE(), msg.sender), ""LM010"");
    _;
  }

  /**
    Set the dex address for dexMapping
    @dev only manager or address(this) can call this method.
    @param _index the index for the dex.
    @param _proxy the address for the proxy.
    @param _router the address for the router.
  */
  function setDexMapping(
    uint256 _index,
    address _proxy,
    address _router
  ) external override onlyManager {
    require(_proxy != address(0), ""LM000"");
    require(_router != address(0), ""LM000"");
    _dexMapping[_index] = Dex({ proxy: _proxy, router: _router });
  }

  function parallel() public view override returns (IAddressProvider) {
    return _a;
  }

  /** 
    Returns proxy and router address for a specific dex index
    @param index the index for the dex
    @return (proxy address, router address)
  */
  function dexMapping(uint256 index) public view override returns (address, address) {
    return (_dexMapping[index].proxy, _dexMapping[index].router);
  }
}",419
RealWorld_TA_115_IInceptionVaultPriceFeed_RealWorld_20240815212447.log,115,IInceptionVaultPriceFeed,36042,1638,37680,84.0,0.21297,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../../chainlink/AggregatorV3Interface.sol"";
import ""../../interfaces/IAddressProvider.sol"";

interface IInceptionVaultPriceFeed {
  event PriceFeedAdded(uint16 _id, address _priceFeed);

  function initialize(
    IAddressProvider _addresses,
    address _inceptionCollateral,
    address _assetOracle,
    AggregatorV3Interface _eurOracle
  ) external;

  function a() external view returns (IAddressProvider);

  function inceptionCollateral() external view returns (ERC20);

  function assetOracle() external view returns (AggregatorV3Interface);

  function eurOracle() external view returns (AggregatorV3Interface);

  function getAssetPrice() external view returns (uint256);

  function convertFrom(uint256 _amount) external view returns (uint256);

  function convertTo(uint256 _amount) external view returns (uint256);
}",216
RealWorld_TA_115_RatesManager_RealWorld_20240815204820.log,115,RatesManager,68462,2022,70484,97.0,0.38275,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../interfaces/IRatesManager.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract RatesManager is IRatesManager {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 private constant _SECONDS_PER_YEAR = 365 days;

  IAddressProvider public override a;

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Calculate the annualized borrow rate from the specified borrowing rate.
    @param _borrowRate rate for a 1 second interval specified in RAY accuracy.
    @return annualized rate
  */
  function annualizedBorrowRate(uint256 _borrowRate) public pure override returns (uint256) {
    return _borrowRate.rayPow(_SECONDS_PER_YEAR);
  }

  /**
    Calculate the total debt from a specified base debt and cumulative rate.
    @param _baseDebt the base debt to be used. Can be a vault base debt or an aggregate base debt
    @param _cumulativeRate the cumulative rate in RAY accuracy.
    @return debt after applying the cumulative rate
  */
  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) public pure override returns (uint256 debt) {
    return _baseDebt.rayMul(_cumulativeRate);
  }

  /**
    Calculate the base debt from a specified total debt and cumulative rate.
    @param _debt the total debt to be used.
    @param _cumulativeRate the cumulative rate in RAY accuracy.
    @return baseDebt the new base debt
  */
  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) public pure override returns (uint256 baseDebt) {
    return _debt.rayDiv(_cumulativeRate);
  }

  /**
    Bring an existing cumulative rate forward in time
    @param _borrowRate rate for a 1 second interval specified in RAY accuracy to be applied
    @param _timeElapsed the time over whicht the borrow rate shall be applied
    @param _cumulativeRate the initial cumulative rate from which to apply the borrow rate
    @return new cumulative rate
  */
  function calculateCumulativeRate(
    uint256 _borrowRate,
    uint256 _cumulativeRate,
    uint256 _timeElapsed
  ) public view override returns (uint256) {
    if (_timeElapsed == 0) return _cumulativeRate;
    uint256 cumulativeElapsed = _borrowRate.rayPow(_timeElapsed);
    return _cumulativeRate.rayMul(cumulativeElapsed);
  }
}",607
RealWorld_TA_115_IVaultsDataProvider_RealWorld_20240815225956.log,115,IVaultsDataProvider,48150,2201,50351,116.0,0.28477,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;
import ""../interfaces/IAddressProvider.sol"";

interface IVaultsDataProvider {
  struct Vault {
    // borrowedType support USDX / PAR
    address collateralType;
    address owner;
    uint256 collateralBalance;
    uint256 baseDebt;
    uint256 createdAt;
  }

  //Write
  function createVault(address _collateralType, address _owner) external returns (uint256);

  function setCollateralBalance(uint256 _id, uint256 _balance) external;

  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;

  // Read
  function a() external view returns (IAddressProvider);

  function baseDebt(address _collateralType) external view returns (uint256);

  function vaultCount() external view returns (uint256);

  function vaults(uint256 _id) external view returns (Vault memory);

  function vaultOwner(uint256 _id) external view returns (address);

  function vaultCollateralType(uint256 _id) external view returns (address);

  function vaultCollateralBalance(uint256 _id) external view returns (uint256);

  function vaultBaseDebt(uint256 _id) external view returns (uint256);

  function vaultId(address _collateralType, address _owner) external view returns (uint256);

  function vaultExists(uint256 _id) external view returns (bool);

  function vaultDebt(uint256 _vaultId) external view returns (uint256);

  function debt() external view returns (uint256);

  function collateralDebt(address _collateralType) external view returns (uint256);
}",358
RealWorld_TA_115_BoringOwnable_RealWorld_20240815211146.log,115,BoringOwnable,60265,1752,62017,104.0,0.336365,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// Audit on 5-Jan-2021 by Keno and BoringCrypto
// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
  address public owner;
  address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /// @notice `owner` defaults to msg.sender on construction.
  constructor() public {
    owner = msg.sender;
    emit OwnershipTransferred(address(0), msg.sender);
  }

  /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
  /// Can only be invoked by the current `owner`.
  /// @param newOwner Address of the new owner.
  /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
  /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
  function transferOwnership(
    address newOwner,
    bool direct,
    bool renounce
  ) public onlyOwner {
    if (direct) {
      // Checks
      require(newOwner != address(0) || renounce, ""Ownable: zero address"");

      // Effects
      emit OwnershipTransferred(owner, newOwner);
      owner = newOwner;
      pendingOwner = address(0);
    } else {
      // Effects
      pendingOwner = newOwner;
    }
  }

  /// @notice Needs to be called by `pendingOwner` to claim ownership.
  function claimOwnership() public {
    address _pendingOwner = pendingOwner;

    // Checks
    require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

    // Effects
    emit OwnershipTransferred(owner, _pendingOwner);
    owner = _pendingOwner;
    pendingOwner = address(0);
  }

  /// @notice Only allows the `owner` to execute the function.
  modifier onlyOwner() {
    require(msg.sender == owner, ""Ownable: caller is not the owner"");
    _;
  }
}",499
RealWorld_TA_115_IAddressProvider_RealWorld_20240815223103.log,115,IAddressProvider,48737,1890,50627,98.0,0.281485,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IAccessController.sol"";
import ""./IConfigProvider.sol"";
import ""./ISTABLEX.sol"";
import ""./IPriceFeed.sol"";
import ""./IRatesManager.sol"";
import ""./ILiquidationManager.sol"";
import ""./IVaultsCore.sol"";
import ""./IVaultsDataProvider.sol"";
import ""./IFeeDistributor.sol"";

interface IAddressProvider {
  function setAccessController(IAccessController _controller) external;

  function setConfigProvider(IConfigProvider _config) external;

  function setVaultsCore(IVaultsCore _core) external;

  function setStableX(ISTABLEX _stablex) external;

  function setRatesManager(IRatesManager _ratesManager) external;

  function setPriceFeed(IPriceFeed _priceFeed) external;

  function setLiquidationManager(ILiquidationManager _liquidationManager) external;

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;

  function setFeeDistributor(IFeeDistributor _feeDistributor) external;

  function controller() external view returns (IAccessController);

  function config() external view returns (IConfigProvider);

  function core() external view returns (IVaultsCore);

  function stablex() external view returns (ISTABLEX);

  function ratesManager() external view returns (IRatesManager);

  function priceFeed() external view returns (IPriceFeed);

  function liquidationManager() external view returns (ILiquidationManager);

  function vaultsData() external view returns (IVaultsDataProvider);

  function feeDistributor() external view returns (IFeeDistributor);
}",357
RealWorld_TA_115_LiquidiationManagerV1_RealWorld_20240815190109.log,115,LiquidiationManagerV1,87746,3024,90770,116.0,0.49921,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""./interfaces/IAddressProviderV1.sol"";
import ""./interfaces/IConfigProviderV1.sol"";
import ""./interfaces/ILiquidationManagerV1.sol"";

contract LiquidationManagerV1 is ILiquidationManagerV1, ReentrancyGuard {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  IAddressProviderV1 public override a;

  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18; // 1
  uint256 public constant FULL_LIQUIDIATION_TRESHOLD = 100e18; // 100 USDX, vaults below 100 USDX can be liquidated in full

  constructor(IAddressProviderV1 _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Check if the health factor is above or equal to 1.
    @param _collateralType address of the collateral type
    @param _collateralValue value of the collateral in stableX currency
    @param _vaultDebt outstanding debt to which the collateral balance shall be compared
    @return boolean if the health factor is >= 1.
  */
  function isHealthy(
    address _collateralType,
    uint256 _collateralValue,
    uint256 _vaultDebt
  ) public view override returns (bool) {
    uint256 healthFactor = calculateHealthFactor(_collateralType, _collateralValue, _vaultDebt);
    return healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD;
  }

  /**
    Calculate the healthfactor of a debt balance
    @param _collateralType address of the collateral type
    @param _collateralValue value of the collateral in stableX currency
    @param _vaultDebt outstanding debt to which the collateral balance shall be compared
    @return healthFactor
  */
  function calculateHealthFactor(
    address _collateralType,
    uint256 _collateralValue,
    uint256 _vaultDebt
  ) public view override returns (uint256 healthFactor) {
    if (_vaultDebt == 0) return WadRayMath.wad();

    // CurrentCollateralizationRatio = deposited ETH in USD / debt in USD
    uint256 collateralizationRatio = _collateralValue.wadDiv(_vaultDebt);

    // Healthfactor = CurrentCollateralizationRatio / MinimumCollateralizationRatio

    uint256 collateralId = a.config().collateralIds(_collateralType);
    require(collateralId > 0, ""collateral not supported"");

    uint256 minRatio = a.config().collateralConfigs(collateralId).minCollateralRatio;
    if (minRatio > 0) {
      return collateralizationRatio.wadDiv(minRatio);
    }

    return 1e18; // 1
  }

  /**
    Calculate the liquidation bonus for a specified amount
    @param _amount amount for which the liquidation bonus shall be calculated
    @return bonus the liquidation bonus to pay out
  */
  function liquidationBonus(uint256 _amount) public view override returns (uint256 bonus) {
    return _amount.wadMul(IConfigProviderV1(address(a.config())).liquidationBonus());
  }

  /**
    Apply the liquidation bonus to a balance as a discount.
    @param _amount the balance on which to apply to liquidation bonus as a discount.
    @return discountedAmount
  */
  function applyLiquidationDiscount(uint256 _amount) public view override returns (uint256 discountedAmount) {
    return _amount.wadDiv(IConfigProviderV1(address(a.config())).liquidationBonus().add(WadRayMath.wad()));
  }
}",839
RealWorld_TA_115_IVaultsCoreState_RealWorld_20240815221539.log,115,IVaultsCoreState,37599,1427,39026,141.0,0.216535,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;
import ""./IAddressProvider.sol"";
import ""../v1/interfaces/IVaultsCoreV1.sol"";

interface IVaultsCoreState {
  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0

  function initializeRates(address _collateralType) external;

  function refresh() external;

  function refreshCollateral(address collateralType) external;

  function syncState(IVaultsCoreState _stateAddress) external;

  function syncStateFromV1(IVaultsCoreV1 _core) external;

  //Read only
  function a() external view returns (IAddressProvider);

  function availableIncome() external view returns (uint256);

  function cumulativeRates(address _collateralType) external view returns (uint256);

  function lastRefresh(address _collateralType) external view returns (uint256);

  function synced() external view returns (bool);
}",223
RealWorld_TA_115_InceptionVaultsDataProvider_RealWorld_20240815210932.log,115,InceptionVaultsDataProvider,133078,3175,136253,132.0,0.72889,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""./interfaces/IInceptionVaultsCore.sol"";
import ""./interfaces/IInceptionVaultsDataProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract InceptionVaultsDataProvider is IInceptionVaultsDataProvider, Initializable {
  using SafeMath for uint256;

  IAddressProvider private _a;
  IInceptionVaultsCore private _inceptionVaultsCore;

  uint256 private _inceptionVaultCount;

  uint256 private _baseDebt;

  mapping(uint256 => InceptionVault) private _vaults;
  mapping(address => uint256) private _vaultOwners;

  modifier onlyInceptionCore() {
    require(msg.sender == address(_inceptionVaultsCore), ""IV011"");
    _;
  }

  function initialize(IInceptionVaultsCore inceptionVaultsCore, IAddressProvider addressProvider)
    external
    override
    initializer
  {
    _inceptionVaultsCore = inceptionVaultsCore;
    _a = addressProvider;
  }

  /**
    Opens a new vault.
    @dev only the vaultsCore module can call this function
    @param _owner the owner of the new vault.
  */
  function createVault(address _owner) external override onlyInceptionCore returns (uint256) {
    uint256 newId = ++_inceptionVaultCount;
    InceptionVault memory v = InceptionVault({
      owner: _owner,
      collateralBalance: 0,
      baseDebt: 0,
      createdAt: block.timestamp
    });
    _vaults[newId] = v;
    _vaultOwners[_owner] = newId;
    return newId;
  }

  /**
    Set the collateral balance of a vault.
    @dev only the vaultsCore module can call this function
    @param _vaultId Vault ID of which the collateral balance will be updated
    @param _balance the new balance of the vault.
  */
  function setCollateralBalance(uint256 _vaultId, uint256 _balance) external override onlyInceptionCore {
    require(vaultExists(_vaultId), ""IV105"");
    InceptionVault storage v = _vaults[_vaultId];
    v.collateralBalance = _balance;
  }

  /**
   Set the base debt of a vault.
    @dev only the vaultsCore module can call this function
    @param _id Vault ID of which the base debt will be updated
    @param _newBaseDebt the new base debt of the vault.
  */
  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external override onlyInceptionCore {
    InceptionVault storage _vault = _vaults[_id];
    if (_newBaseDebt > _vault.baseDebt) {
      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);
      _baseDebt = _baseDebt.add(increase);
    } else {
      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);
      _baseDebt = _baseDebt.sub(decrease);
    }
    _vault.baseDebt = _newBaseDebt;
  }

  /**
    Get a vault by vault ID.
    @param _id The vault's ID to be retrieved
    @return struct InceptionVault {
      address owner;
      uint256 collateralBalance;
      uint256 baseDebt;
      uint256 createdAt;
    }
  */
  function vaults(uint256 _id) external view override returns (InceptionVault memory) {
    InceptionVault memory v = _vaults[_id];
    return v;
  }

  /**
    Get the owner of a vault.
    @param _id the ID of the vault
    @return owner of the vault
  */
  function vaultOwner(uint256 _id) external view override returns (address) {
    return _vaults[_id].owner;
  }

  /**
   Get the collateral balance of a vault.
@param _id the ID of the vault
    @return collateral balance of the vault
  */
  function vaultCollateralBalance(uint256 _id) external view override returns (uint256) {
    return _vaults[_id].collateralBalance;
  }

  /**
   Get the base debt of a vault.
@param _id the ID of the vault
    @return base debt of the vault
  */
  function vaultBaseDebt(uint256 _id) external view override returns (uint256) {
    return _vaults[_id].baseDebt;
  }

  /**
    Retrieve the vault id for a specified owner and collateral type.
    @dev returns 0 for non-existing vaults
    @param _owner address of the owner of the vault
    @return vault id of the vault or 0
  */
  function vaultId(address _owner) external view override returns (uint256) {
    return _vaultOwners[_owner];
  }

  /**
    Calculated the total outstanding debt for a specific vault.
    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`
    to make sure it's up to date.
    @param _vaultId the ID of the vault
    @return total debt of one vault
  */
  function vaultDebt(uint256 _vaultId) external view override returns (uint256) {
    InceptionVault memory v = _vaults[_vaultId];
    return _a.ratesManager().calculateDebt(v.baseDebt, _inceptionVaultsCore.cumulativeRate());
  }

  /**
    Checks if a specified vault exists.
    @param _id the ID of the vault
    @return boolean if the vault exists
  */
  function vaultExists(uint256 _id) public view override returns (bool) {
    InceptionVault memory v = _vaults[_id];
    return v.owner != address(0);
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function inceptionVaultsCore() public view override returns (IInceptionVaultsCore) {
    return _inceptionVaultsCore;
  }

  function inceptionVaultCount() public view override returns (uint256) {
    return _inceptionVaultCount;
  }

  function baseDebt() public view override returns (uint256) {
    return _baseDebt;
  }
}",1382
RealWorld_TA_115_IGovernanceAddressProvider_RealWorld_20240815220312.log,115,IGovernanceAddressProvider,42730,1356,44086,100.0,0.24077,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity >=0.6.12;

import ""./IGovernorAlpha.sol"";
import ""./ITimelock.sol"";
import ""./IVotingEscrow.sol"";
import ""../../interfaces/IAccessController.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../liquidityMining/interfaces/IMIMO.sol"";
import ""../../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IGovernanceAddressProvider {
  function setParallelAddressProvider(IAddressProvider _parallel) external;

  function setMIMO(IMIMO _mimo) external;

  function setDebtNotifier(IDebtNotifier _debtNotifier) external;

  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;

  function setTimelock(ITimelock _timelock) external;

  function setVotingEscrow(IVotingEscrow _votingEscrow) external;

  function controller() external view returns (IAccessController);

  function parallel() external view returns (IAddressProvider);

  function mimo() external view returns (IMIMO);

  function debtNotifier() external view returns (IDebtNotifier);

  function governorAlpha() external view returns (IGovernorAlpha);

  function timelock() external view returns (ITimelock);

  function votingEscrow() external view returns (IVotingEscrow);
}",291
RealWorld_TA_115_ISTABLEX_RealWorld_20240815222749.log,115,ISTABLEX,25651,2060,27711,96.0,0.169455,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../interfaces/IAddressProvider.sol"";

interface ISTABLEX is IERC20 {
  function mint(address account, uint256 amount) external;

  function burn(address account, uint256 amount) external;

  function a() external view returns (IAddressProvider);
}",87
RealWorld_TA_115_PolygonDistributor_RealWorld_20240815194755.log,115,PolygonDistributor,53889,3433,57322,116.0,0.338105,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/interfaces/IRootChainManager.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./BaseDistributor.sol"";

contract PolygonDistributor is BaseDistributor {
  using SafeMath for uint256;

  IRootChainManager public rootChainManager;
  address public erc20Predicate;

  constructor(
    IGovernanceAddressProvider _a,
    IRootChainManager _rootChainManager,
    address _erc20Predicate
  ) public {
    require(address(_a) != address(0));
    require(address(_rootChainManager) != address(0));
    require(_erc20Predicate != address(0));

    a = _a;
    rootChainManager = _rootChainManager;
    erc20Predicate = _erc20Predicate;
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view override returns (uint256) {
    return a.mimo().balanceOf(address(this));
  }

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {
    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);
    a.mimo().approve(erc20Predicate, payment);
    rootChainManager.depositFor(_payee, address(a.mimo()), abi.encode(payment));
  }
}",415
RealWorld_TA_115_IGenericMinerV2_RealWorld_20240815200916.log,115,IGenericMinerV2,51960,1855,53815,91.0,0.2969,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../../interfaces/IAddressProvider.sol"";
import ""../../../governance/interfaces/IGovernanceAddressProvider.sol"";

interface IGenericMinerV2 {
  struct UserInfo {
    uint256 stake;
    uint256 stakeWithBoost;
    uint256 accAmountPerShare;
    uint256 accParAmountPerShare;
  }

  struct BoostConfig {
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 d;
    uint256 e;
    uint256 maxBoost;
  }

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeIncreased(address indexed user, uint256 stake);

  /// @dev This emit when a users' productivity has changed
  /// It emits with the user's address and the the value after the change.
  event StakeDecreased(address indexed user, uint256 stake);

  event BoostConfigSet(BoostConfig);

  function releaseRewards(address _user) external;

  function stake(address _user) external view returns (uint256);

  function stakeWithBoost(address _user) external view returns (uint256);

  // Read only
  function a() external view returns (IGovernanceAddressProvider);

  function pendingMIMO(address _user) external view returns (uint256);

  function pendingPAR(address _user) external view returns (uint256);

  function par() external view returns (IERC20);

  function boostConfig() external view returns (BoostConfig memory);

  function totalStake() external view returns (uint256);

  function totalStakeWithBoost() external view returns (uint256);

  function userInfo(address _user) external view returns (UserInfo memory);
}",399
RealWorld_TA_115_GenericMiner_RealWorld_20240815194531.log,115,GenericMiner,144030,4357,148387,142.0,0.80729,"//SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""./interfaces/IGenericMiner.sol"";

/*
    GenericMiner is based on ERC2917. https://github.com/gnufoo/ERC2917-Proposal

    The Objective of GenericMiner is to implement a decentralized staking mechanism, which calculates _users' share
    by accumulating stake * time. And calculates _users revenue from anytime t0 to t1 by the formula below:

        user_accumulated_stake(time1) - user_accumulated_stake(time0)
       _____________________________________________________________________________  * (gross_stake(t1) - gross_stake(t0))
       total_accumulated_stake(time1) - total_accumulated_stake(time0)

*/
contract GenericMiner is IGenericMiner {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  mapping(address => UserInfo) internal _users;

  uint256 public override totalStake;
  IGovernanceAddressProvider public override a;

  uint256 internal _balanceTracker;
  uint256 internal _accAmountPerShare;

  constructor(IGovernanceAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Releases the outstanding MIMO balance to the user.
    @param _user the address of the user for which the MIMO tokens will be released.
  */
  function releaseMIMO(address _user) public virtual override {
    UserInfo storage userInfo = _users[_user];
    _refresh();
    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.accAmountPerShare = _accAmountPerShare;
    require(a.mimo().transfer(_user, pending));
  }

  /**
    Returns the number of tokens a user has staked.
    @param _user the address of the user.
    @return number of staked tokens
  */
  function stake(address _user) public view override returns (uint256) {
    return _users[_user].stake;
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`.
    @param _user the address of the user.
    @return number of MIMO tokens that the user can claim
  */
  function pendingMIMO(address _user) public view override returns (uint256) {
    uint256 currentBalance = a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_balanceTracker);
    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));

    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));
  }

  /**
    Returns the userInfo stored of a user.
    @param _user the address of the user.
    @return `struct UserInfo {
      uint256 stake;
      uint256 rewardDebt;
    }`
  **/
  function userInfo(address _user) public view override returns (UserInfo memory) {
    return _users[_user];
  }

  /**
    Refreshes the global state and subsequently decreases the stake a user has.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param value the amount by which the stake will be reduced
  */
  function _decreaseStake(address user, uint256 value) internal {
    require(value > 0, ""STAKE_MUST_BE_GREATER_THAN_ZERO""); //TODO cleanup error message

    UserInfo storage userInfo = _users[user];
    require(userInfo.stake >= value, ""INSUFFICIENT_STAKE_FOR_USER""); //TODO cleanup error message
    _refresh();
    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.stake = userInfo.stake.sub(value);
    userInfo.accAmountPerShare = _accAmountPerShare;
    totalStake = totalStake.sub(value);

    require(a.mimo().transfer(user, pending));
    emit StakeDecreased(user, value);
  }

  /**
    Refreshes the global state and subsequently increases a user's stake.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param value the amount by which the stake will be increased
  */
  function _increaseStake(address user, uint256 value) internal {
    require(value > 0, ""STAKE_MUST_BE_GREATER_THAN_ZERO""); //TODO cleanup error message

    UserInfo storage userInfo = _users[user];
    _refresh();

    uint256 pending;
    if (userInfo.stake > 0) {
      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
      _balanceTracker = _balanceTracker.sub(pending);
    }

    totalStake = totalStake.add(value);
    userInfo.stake = userInfo.stake.add(value);
    userInfo.accAmountPerShare = _accAmountPerShare;

    if (pending > 0) {
      require(a.mimo().transfer(user, pending));
    }

    emit StakeIncreased(user, value);
  }

  /**
    Refreshes the global state and subsequently updates a user's stake.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param stake the new amount of stake for the user
  */
  function _updateStake(address user, uint256 stake) internal returns (bool) {
    uint256 oldStake = _users[user].stake;
    if (stake > oldStake) {
      _increaseStake(user, stake.sub(oldStake));
    }
    if (stake < oldStake) {
      _decreaseStake(user, oldStake.sub(stake));
    }
  }

  /**
    Internal read function to calculate the number of MIMO tokens that
    have accumulated since the last token release.
    @dev This is an internal call and meant to be called within derivative contracts.
    @return newly accumulated token balance
  */
  function _newTokensReceived() internal view returns (uint256) {
    return a.mimo().balanceOf(address(this)).sub(_balanceTracker);
  }

  /**
    Updates the internal state variables after accounting for newly received MIMO tokens.
  */
  function _refresh() internal {
    if (totalStake == 0) {
      return;
    }
    uint256 currentBalance = a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_balanceTracker);
    _balanceTracker = currentBalance;

    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));
  }
}",1481
RealWorld_TA_115_ITimelock_RealWorld_20240815220454.log,115,ITimelock,46805,1517,48322,144.0,0.264365,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.6.12;

interface ITimelock {
  event NewAdmin(address indexed newAdmin);
  event NewPendingAdmin(address indexed newPendingAdmin);
  event NewDelay(uint256 indexed newDelay);
  event CancelTransaction(
    bytes32 indexed txHash,
    address indexed target,
    uint256 value,
    string signature,
    bytes data,
    uint256 eta
  );
  event ExecuteTransaction(
    bytes32 indexed txHash,
    address indexed target,
    uint256 value,
    string signature,
    bytes data,
    uint256 eta
  );
  event QueueTransaction(
    bytes32 indexed txHash,
    address indexed target,
    uint256 value,
    string signature,
    bytes data,
    uint256 eta
  );

  function acceptAdmin() external;

  function queueTransaction(
    address target,
    uint256 value,
    string calldata signature,
    bytes calldata data,
    uint256 eta
  ) external returns (bytes32);

  function cancelTransaction(
    address target,
    uint256 value,
    string calldata signature,
    bytes calldata data,
    uint256 eta
  ) external;

  function executeTransaction(
    address target,
    uint256 value,
    string calldata signature,
    bytes calldata data,
    uint256 eta
  ) external payable returns (bytes memory);

  function delay() external view returns (uint256);

  function GRACE_PERIOD() external view returns (uint256);

  function queuedTransactions(bytes32 hash) external view returns (bool);
}",326
RealWorld_TA_115_BNum_RealWorld_20240815213355.log,115,BNum,121716,1814,123530,102.0,0.64486,"// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

/* solhint-disable private-vars-leading-underscore */

pragma solidity 0.6.12;

import ""./BConst.sol"";

contract BNum is BConst {
  function btoi(uint256 a) internal pure returns (uint256) {
    return a / BONE;
  }

  function bfloor(uint256 a) internal pure returns (uint256) {
    return btoi(a) * BONE;
  }

  function badd(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a, ""ERR_ADD_OVERFLOW"");
    return c;
  }

  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {
    (uint256 c, bool flag) = bsubSign(a, b);
    require(!flag, ""ERR_SUB_UNDERFLOW"");
    return c;
  }

  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {
    if (a >= b) {
      return (a - b, false);
    } else {
      return (b - a, true);
    }
  }

  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c0 = a * b;
    require(a == 0 || c0 / a == b, ""ERR_MUL_OVERFLOW"");
    uint256 c1 = c0 + (BONE / 2);
    require(c1 >= c0, ""ERR_MUL_OVERFLOW"");
    uint256 c2 = c1 / BONE;
    return c2;
  }

  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0, ""ERR_DIV_ZERO"");
    uint256 c0 = a * BONE;
    require(a == 0 || c0 / a == BONE, ""ERR_DIV_INTERNAL""); // bmul overflow
    uint256 c1 = c0 + (b / 2);
    require(c1 >= c0, ""ERR_DIV_INTERNAL""); //  badd require
    uint256 c2 = c1 / b;
    return c2;
  }

  // DSMath.wpow
  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {
    uint256 z = n % 2 != 0 ? a : BONE;

    for (n /= 2; n != 0; n /= 2) {
      a = bmul(a, a);

      if (n % 2 != 0) {
        z = bmul(z, a);
      }
    }
    return z;
  }

  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).
  // Use `bpowi` for `b^e` and `bpowK` for k iterations
  // of approximation of b^0.w
  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {
    require(base >= MIN_BPOW_BASE, ""ERR_BPOW_BASE_TOO_LOW"");
    require(base <= MAX_BPOW_BASE, ""ERR_BPOW_BASE_TOO_HIGH"");

    uint256 whole = bfloor(exp);
    uint256 remain = bsub(exp, whole);

    uint256 wholePow = bpowi(base, btoi(whole));

    if (remain == 0) {
      return wholePow;
    }

    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);
    return bmul(wholePow, partialResult);
  }

  function bpowApprox(
    uint256 base,
    uint256 exp,
    uint256 precision
  ) internal pure returns (uint256) {
    // term 0:
    uint256 a = exp;
    (uint256 x, bool xneg) = bsubSign(base, BONE);
    uint256 term = BONE;
    uint256 sum = term;
    bool negative = false;

    // term(k) = numer / denom
    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)
    // each iteration, multiply previous term by (a-(k-1)) * x / k
    // continue until term is less than precision
    for (uint256 i = 1; term >= precision; i++) {
      uint256 bigK = i * BONE;
      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));
      term = bmul(term, bmul(c, x));
      term = bdiv(term, bigK);
      if (term == 0) break;

      if (xneg) negative = !negative;
      if (cneg) negative = !negative;
      if (negative) {
        sum = bsub(sum, term);
      } else {
        sum = badd(sum, term);
      }
    }

    return sum;
  }
}",1220
RealWorld_TA_115_AddressProviderV1_RealWorld_20240815190622.log,115,AddressProviderV1,72256,1806,74062,100.0,0.3974,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IAccessController.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""../interfaces/IPriceFeed.sol"";
import ""../interfaces/IRatesManager.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";
import ""./interfaces/IConfigProviderV1.sol"";
import ""./interfaces/ILiquidationManagerV1.sol"";
import ""./interfaces/IVaultsCoreV1.sol"";

contract AddressProviderV1 is IAddressProvider {
  IAccessController public override controller;
  IConfigProvider public override config;
  IVaultsCore public override core;

  ISTABLEX public override stablex;
  IRatesManager public override ratesManager;
  IPriceFeed public override priceFeed;
  ILiquidationManager public override liquidationManager;
  IVaultsDataProvider public override vaultsData;
  IFeeDistributor public override feeDistributor;

  constructor(IAccessController _controller) public {
    controller = _controller;
  }

  modifier onlyManager() {
    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  function setAccessController(IAccessController _controller) public override onlyManager {
    require(address(_controller) != address(0));
    controller = _controller;
  }

  function setConfigProvider(IConfigProvider _config) public override onlyManager {
    require(address(_config) != address(0));
    config = _config;
  }

  function setVaultsCore(IVaultsCore _core) public override onlyManager {
    require(address(_core) != address(0));
    core = _core;
  }

  function setStableX(ISTABLEX _stablex) public override onlyManager {
    require(address(_stablex) != address(0));
    stablex = _stablex;
  }

  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {
    require(address(_ratesManager) != address(0));
    ratesManager = _ratesManager;
  }

  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {
    require(address(_liquidationManager) != address(0));
    liquidationManager = _liquidationManager;
  }

  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {
    require(address(_priceFeed) != address(0));
    priceFeed = _priceFeed;
  }

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {
    require(address(_vaultsData) != address(0));
    vaultsData = _vaultsData;
  }

  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {
    require(address(_feeDistributor) != address(0));
    feeDistributor = _feeDistributor;
  }
}",640
RealWorld_TA_115_IInceptionVaultFactory_RealWorld_20240815211732.log,115,IInceptionVaultFactory,60809,2134,62943,103.0,0.346725,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IAdminInceptionVault.sol"";
import ""./IInceptionVaultsCore.sol"";
import ""./IInceptionVaultsDataProvider.sol"";
import ""./IInceptionVaultPriceFeed.sol"";
import ""../../interfaces/IWETH.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IInceptionVaultFactory {
  struct InceptionVault {
    address owner;
    IAdminInceptionVault adminInceptionVault;
    IInceptionVaultsCore inceptionVaultsCore;
    IInceptionVaultsDataProvider inceptionVaultsDataProvider;
    IInceptionVaultPriceFeed inceptionVaultPriceFeed;
    bool isCustomPriceFeed;
  }

  event InceptionVaultDeployed(
    address owner,
    IAdminInceptionVault adminInceptionVault,
    IInceptionVaultsCore inceptionVaultsCore,
    IInceptionVaultsDataProvider inceptionVaultsDataProvider,
    IInceptionVaultPriceFeed inceptionVaultPriceFeed
  );

  event PriceFeedAdded(uint16 _id, address _address);

  function cloneInceptionVault(
    IInceptionVaultsCore.VaultConfig calldata _vaultConfig,
    IERC20 _inceptionCollateral,
    address _inceptionVaultPriceFeed,
    address _assetOracle
  ) external;

  function addPriceFeed(address _address) external;

  // Read only
  function a() external view returns (IAddressProvider);

  function debtNotifier() external view returns (IDebtNotifier);

  function weth() external view returns (IWETH);

  function mimo() external view returns (IERC20);

  function adminInceptionVaultBase() external view returns (address);

  function inceptionVaultsCoreBase() external view returns (address);

  function inceptionVaultsDataProviderBase() external view returns (address);

  function inceptionVaultCount() external view returns (uint256);

  function priceFeedCount() external view returns (uint8);

  function inceptionVaults(uint256 _id) external view returns (InceptionVault memory);

  function priceFeeds(uint8 _id) external view returns (address);

  function priceFeedIds(address _priceFeed) external view returns (uint16);
}",498
RealWorld_TA_115_InceptionVaultFactory_RealWorld_20240815211333.log,115,InceptionVaultFactory,155560,3818,159378,130.0,0.85416,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";

import ""./BoringOwnable.sol"";
import ""./interfaces/IInceptionVaultFactory.sol"";
import ""./interfaces/IAdminInceptionVault.sol"";
import ""./interfaces/IInceptionVaultsCore.sol"";
import ""./interfaces/IInceptionVaultsDataProvider.sol"";
import ""./interfaces/IInceptionVaultPriceFeed.sol"";
import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IWETH.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../liquidityMining/interfaces/IGenericMiner.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";

contract InceptionVaultFactory is IInceptionVaultFactory, BoringOwnable {
  using Clones for address;

  IAddressProvider private immutable _a;
  IDebtNotifier private immutable _debtNotifier;
  IWETH private immutable _weth;
  IERC20 private immutable _mimo;
  address private immutable _adminInceptionVaultBase;
  address private immutable _inceptionVaultsCoreBase;
  address private immutable _inceptionVaultsDataProviderBase;

  uint8 private _priceFeedCount;
  uint256 private _inceptionVaultCount;

  mapping(uint256 => InceptionVault) private _inceptionVaults;
  mapping(uint8 => address) private _priceFeeds;
  mapping(address => uint8) private _priceFeedIds;

  constructor(
    address adminInceptionVaultBase,
    address inceptionVaultsCoreBase,
    address inceptionVaultsDataProviderBase,
    IAddressProvider addressProvider,
    IDebtNotifier debtNotifier,
    IWETH weth,
    IERC20 mimo
  ) public {
    require(adminInceptionVaultBase != address(0), ""IV000"");
    require(inceptionVaultsCoreBase != address(0), ""IV000"");
    require(inceptionVaultsDataProviderBase != address(0), ""IV000"");
    require(address(addressProvider) != address(0), ""IV000"");
    require(address(debtNotifier) != address(0), ""IV000"");
    require(address(weth) != address(0), ""IV000"");
    require(address(mimo) != address(0), ""IV000"");
    _adminInceptionVaultBase = adminInceptionVaultBase;
    _inceptionVaultsCoreBase = inceptionVaultsCoreBase;
    _inceptionVaultsDataProviderBase = inceptionVaultsDataProviderBase;
    _a = addressProvider;
    _debtNotifier = debtNotifier;
    _weth = weth;
    _mimo = mimo;
  }

  /**
    Clones and initializes all 3 Inception Vault contracts : AdminInceptionVault, InceptionVaultsCore, InceptionVaultsDataProvider.
    @param _vaultConfig the inception vault configuration paramaters, see {IInceptionVaultFactory - VaultConfig}.
    @param _inceptionCollateral the address of the ERC20 token that will be set as inceptionCollateral
  */
  function cloneInceptionVault(
    IInceptionVaultsCore.VaultConfig calldata _vaultConfig,
    IERC20 _inceptionCollateral,
    address _inceptionVaultPriceFeed,
    address _assetOracle
  ) external override {
    require(address(_inceptionCollateral) != address(0), ""IV000"");
    require(_inceptionVaultPriceFeed != address(0), ""IV000"");
    IAdminInceptionVault adminInceptionVault = IAdminInceptionVault(_adminInceptionVaultBase.clone());
    IInceptionVaultsCore inceptionVaultsCore = IInceptionVaultsCore(_inceptionVaultsCoreBase.clone());
    IInceptionVaultsDataProvider inceptionVaultsDataProvider = IInceptionVaultsDataProvider(
      _inceptionVaultsDataProviderBase.clone()
    );
    IInceptionVaultPriceFeed inceptionVaultPriceFeed;
    bool isCustomPriceFeed;

    if (_priceFeedIds[_inceptionVaultPriceFeed] != 0) {
      require(address(_assetOracle) != address(0), ""IV000"");
      inceptionVaultPriceFeed = IInceptionVaultPriceFeed(_inceptionVaultPriceFeed.clone());
      inceptionVaultPriceFeed.initialize(_a, address(_inceptionCollateral), _assetOracle, _a.priceFeed().eurOracle());
    } else {
      require(address(_assetOracle) == address(0), ""IV001"");
      inceptionVaultPriceFeed = IInceptionVaultPriceFeed(_inceptionVaultPriceFeed);
      isCustomPriceFeed = true;
    }

    adminInceptionVault.initialize(msg.sender, _a, _debtNotifier, _weth, _mimo, inceptionVaultsCore);

    inceptionVaultsCore.initialize(
      msg.sender,
      _vaultConfig,
      _inceptionCollateral,
      _a,
      adminInceptionVault,
      inceptionVaultsDataProvider,
      inceptionVaultPriceFeed
    );

    inceptionVaultsDataProvider.initialize(inceptionVaultsCore, _a);

    uint256 newId = ++_inceptionVaultCount;
    InceptionVault memory v = InceptionVault({
      owner: msg.sender,
      adminInceptionVault: adminInceptionVault,
      inceptionVaultsCore: inceptionVaultsCore,
      inceptionVaultsDataProvider: inceptionVaultsDataProvider,
      inceptionVaultPriceFeed: inceptionVaultPriceFeed,
      isCustomPriceFeed: isCustomPriceFeed
    });

    _inceptionVaults[newId] = v;

    emit InceptionVaultDeployed(
      msg.sender,
      adminInceptionVault,
      inceptionVaultsCore,
      inceptionVaultsDataProvider,
      inceptionVaultPriceFeed
    );
  }

  function addPriceFeed(address _address) external override onlyOwner {
    require(_address != address(0), ""IV000"");
    require(_priceFeedIds[_address] == 0, ""IV002"");
    uint8 newId = ++_priceFeedCount;
    _priceFeeds[newId] = _address;
    _priceFeedIds[_address] = newId;
    emit PriceFeedAdded(newId, _address);
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function debtNotifier() public view override returns (IDebtNotifier) {
    return _debtNotifier;
  }

  function weth() public view override returns (IWETH) {
    return _weth;
  }

  function mimo() public view override returns (IERC20) {
    return _mimo;
  }

  function adminInceptionVaultBase() public view override returns (address) {
    return _adminInceptionVaultBase;
  }

  function inceptionVaultsCoreBase() public view override returns (address) {
    return _inceptionVaultsCoreBase;
  }

  function inceptionVaultsDataProviderBase() public view override returns (address) {
    return _inceptionVaultsDataProviderBase;
  }

  function inceptionVaultCount() public view override returns (uint256) {
    return _inceptionVaultCount;
  }

  function priceFeedCount() public view override returns (uint8) {
    return _priceFeedCount;
  }

  function inceptionVaults(uint256 _id) public view override returns (InceptionVault memory) {
    return _inceptionVaults[_id];
  }

  function priceFeeds(uint8 _id) public view override returns (address) {
    return _priceFeeds[_id];
  }

  function priceFeedIds(address _priceFeed) public view override returns (uint16) {
    return _priceFeedIds[_priceFeed];
  }
}",1622
RealWorld_TA_115_MockERC20_RealWorld_20240815183121.log,115,MockERC20,29690,2395,32085,140.0,0.19635,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20 {
  constructor(
    string memory _name,
    string memory _symbol,
    uint8 _decimals
  ) public ERC20(_name, _symbol) {
    super._setupDecimals(_decimals);
  }

  function mint(address account, uint256 amount) public {
    _mint(account, amount);
  }

  function burn(address account, uint256 amount) public {
    _burn(account, amount);
  }
}",129
RealWorld_TA_115_IRootChainManager_RealWorld_20240815214300.log,115,IRootChainManager,30358,2377,32735,99.0,0.19933,"pragma solidity 0.6.12;

interface IRootChainManager {
  event TokenMapped(address indexed rootToken, address indexed childToken, bytes32 indexed tokenType);

  event PredicateRegistered(bytes32 indexed tokenType, address indexed predicateAddress);

  function registerPredicate(bytes32 tokenType, address predicateAddress) external;

  function mapToken(
    address rootToken,
    address childToken,
    bytes32 tokenType
  ) external;

  function depositEtherFor(address user) external payable;

  function depositFor(
    address user,
    address rootToken,
    bytes calldata depositData
  ) external;

  function exit(bytes calldata inputData) external;
}",137
RealWorld_TA_115_MockBuggyERC20_RealWorld_20240815182751.log,115,MockBuggyERC20,104832,2867,107699,104.0,0.5815,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

/**
    Buggy ERC20 implementation without the return bool on `transfer`, `transferFrom` and `approve` for testing purposes
*/

contract MockBuggyERC20 is Context {
  using SafeMath for uint256;

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);

  mapping(address => uint256) private _balances;

  mapping(address => mapping(address => uint256)) private _allowances;

  uint256 private _totalSupply;

  string private _name;
  string private _symbol;
  uint8 private _decimals;

  constructor(string memory name_, string memory symbol_) public {
    _name = name_;
    _symbol = symbol_;
    _decimals = 18;
  }

  function name() public view returns (string memory) {
    return _name;
  }

  function symbol() public view returns (string memory) {
    return _symbol;
  }

  function decimals() public view returns (uint8) {
    return _decimals;
  }

  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function balanceOf(address account) public view returns (uint256) {
    return _balances[account];
  }

  function transfer(address recipient, uint256 amount) public virtual {
    _transfer(_msgSender(), recipient, amount);
  }

  function allowance(address owner, address spender) public view virtual returns (uint256) {
    return _allowances[owner][spender];
  }

  function approve(address spender, uint256 amount) public virtual {
    _approve(_msgSender(), spender, amount);
  }

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) public virtual {
    _transfer(sender, recipient, amount);
    _approve(
      sender,
      _msgSender(),
      _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance"")
    );
  }

  function mint(address account, uint256 amount) public {
    _mint(account, amount);
  }

  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
    return true;
  }

  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
    _approve(
      _msgSender(),
      spender,
      _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero"")
    );
    return true;
  }

  function _transfer(
    address sender,
    address recipient,
    uint256 amount
  ) internal virtual {
    require(sender != address(0), ""ERC20: transfer from the zero address"");
    require(recipient != address(0), ""ERC20: transfer to the zero address"");

    _beforeTokenTransfer(sender, recipient, amount);

    _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
    _balances[recipient] = _balances[recipient].add(amount);
    emit Transfer(sender, recipient, amount);
  }

  function _mint(address account, uint256 amount) internal virtual {
    require(account != address(0), ""ERC20: mint to the zero address"");

    _beforeTokenTransfer(address(0), account, amount);

    _totalSupply = _totalSupply.add(amount);
    _balances[account] = _balances[account].add(amount);
    emit Transfer(address(0), account, amount);
  }

  function _burn(address account, uint256 amount) internal virtual {
    require(account != address(0), ""ERC20: burn from the zero address"");

    _beforeTokenTransfer(account, address(0), amount);

    _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
    _totalSupply = _totalSupply.sub(amount);
    emit Transfer(account, address(0), amount);
  }

  function _approve(
    address owner,
    address spender,
    uint256 amount
  ) internal virtual {
    require(owner != address(0), ""ERC20: approve from the zero address"");
    require(spender != address(0), ""ERC20: approve to the zero address"");

    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
  }

  function _setupDecimals(uint8 decimals_) internal {
    _decimals = decimals_;
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 amount
  ) internal virtual {}
}",1023
RealWorld_TA_115_IAdminInceptionVault_RealWorld_20240815212118.log,115,IAdminInceptionVault,52776,2499,55275,101.0,0.31386,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IInceptionVaultsCore.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../interfaces/IWETH.sol"";
import ""../../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IAdminInceptionVault {
  function initialize(
    address owner,
    IAddressProvider _addressProvider,
    IDebtNotifier _debtNotifier,
    IWETH _WETH,
    IERC20 _mimo,
    IInceptionVaultsCore _inceptionVaultsCore
  ) external;

  function depositETH() external payable;

  function depositETHAndBorrow(uint256 _borrowAmount) external payable;

  function deposit(address _collateralType, uint256 _amount) external;

  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _vaultId
  ) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function claimMimo() external;

  function lendPAR(uint256 _amoutn, address _to) external;

  function transferMimo(uint256 _amount, address _to) external;

  function transferPar(uint256 _amount, address _to) external;

  function inceptionCore() external view returns (IInceptionVaultsCore);

  function collateralCount() external view returns (uint8);

  function collaterals(uint8 _id) external view returns (address);

  function collateralId(address _collateral) external view returns (uint8);

  // Read only
  function a() external view returns (IAddressProvider);

  function debtNotifier() external view returns (IDebtNotifier);

  function weth() external view returns (IWETH);

  function mimo() external view returns (IERC20);
}",416
RealWorld_TA_115_TInceptionVaultUnhealthy_RealWorld_20240815224418.log,115,TInceptionVaultUnhealthy,111262,4876,116138,156.0,0.65383,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""./TIVSetup.sol"";

contract TInceptionVaultUnhealthy is TIVSetup {
  IInceptionVaultsCore internal _inceptionVaultsCore;
  IInceptionVaultsDataProvider internal _inceptionVaultsDataProvider;
  IAdminInceptionVault internal _adminInceptionVault;
  IInceptionVaultPriceFeed internal _inceptionVaultPriceFeed;

  event AssertionFailed(uint256);

  uint256 internal _adminDepositAmount = 10000000000000000000;
  uint256 internal _adminBorrowAmount = 11000000000000000000000;
  uint256 internal _userDepositAmount = 1000000000000000000000;
  uint256 internal _userBorrowAmount = 7000000000000000000000;

  uint256 internal constant _TEST_VAULT_ID = 1;

  bool internal _exist;

  constructor() public TIVSetup() {
    (
      ,
      IAdminInceptionVault a,
      IInceptionVaultsCore v,
      IInceptionVaultsDataProvider d,
      IInceptionVaultPriceFeed p,

    ) = _inceptionVaultFactory.inceptionVaults(_TEST_VAULT_ID);
    _inceptionVaultsCore = v;
    _inceptionVaultsDataProvider = d;
    _inceptionVaultPriceFeed = p;
    _weth.mint(_echidna_caller, _adminDepositAmount);
    _weth.approve(address(a), _adminDepositAmount);

    // Deposit 10 WETH and borrow 11k PAR
    a.depositAndBorrow(address(_weth), _adminDepositAmount, _adminBorrowAmount);

    _link.mint(_echidna_caller, _userDepositAmount);
    _link.approve(address(v), _userDepositAmount);

    // Deposit 1000k LINK and borrow 7k PAR
    v.depositAndBorrow(_userDepositAmount, _userBorrowAmount);

    // Update LINK price to $8 to make vault unhealthy
    _linkAggregator.setLatestPrice(800000000);

    // Approve PAR for liquidation
    _par.approve(address(_inceptionVaultsCore), _MAX_INT);
  }

  /// @notice Chekcs that calling liquidate() on unhealthy vault never reverts
  function echidna_unhealthy_vault_should_always_be_open_to_liquidation() public returns (bool) {
    try _inceptionVaultsCore.liquidate(_TEST_VAULT_ID)  {
      return true;
    } catch {
      return false;
    }
  }

  /// @notice Checks that calling borrow() on unhealthy vault always reverts
  function echidna_user_should_never_be_able_to_borrow_from_unhealthy_vault() public returns (bool) {
    try _inceptionVaultsCore.borrow(1, 1)  {
      return false;
    } catch {
      return true;
    }
  }

  /// @notice Checks that calling withdraw() on unhealthy vault always reverts
  function echidna_user_should_never_be_able_to_withdraw_from_unhealthy_vault() public returns (bool) {
    try _inceptionVaultsCore.withdraw(_TEST_VAULT_ID, 1)  {
      return false;
    } catch {
      return true;
    }
  }

  /**
  @notice Checks that calling liquidatePartial() on unhealthy vault never reverts
  @param amount Liquidation amount
   */
  function unhealthy_vault_should_always_be_open_to_liquidation(uint256 amount) public {
    uint256 vaultDebt = _inceptionVaultsDataProvider.vaultBaseDebt(_TEST_VAULT_ID);
    if (vaultDebt > 0) {
      try _inceptionVaultsCore.liquidatePartial(_TEST_VAULT_ID, amount)  {} catch {
        assert(false);
      }
    }
  }

  /**
  @notice Checks that calling borrow() on unheathy vault always reverts
  @param amount Borrow amount
   */
  function user_should_never_be_able_to_borrow_from_unhealthy_vault(uint256 amount) public {
    uint256 vaultDebt = _inceptionVaultsDataProvider.vaultBaseDebt(_TEST_VAULT_ID);
    if (vaultDebt > 0) {
      try _inceptionVaultsCore.borrow(_TEST_VAULT_ID, amount)  {
        assert(false);
      } catch {}
    }
  }

  /**
  @notice Checks that calling withdraw() on unhealthy vault always reverts
  @param amount Withdraw amount
   */
  function user_should_never_be_able_to_withdraw_from_unhealthy_vault(uint256 amount) public {
    uint256 vaultDebt = _inceptionVaultsDataProvider.vaultBaseDebt(_TEST_VAULT_ID);
    if (vaultDebt > 0) {
      try _inceptionVaultsCore.withdraw(_TEST_VAULT_ID, amount)  {
        assert(false);
      } catch {}
    }
  }
}",1085
RealWorld_TA_115_IVault_RealWorld_20240815214121.log,115,IVault,74782,1643,76425,96.0,0.40677,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

interface IAsset {
  // solhint-disable-previous-line no-empty-blocks
}

interface IVault {
  enum SwapKind { GIVEN_IN, GIVEN_OUT }

  /**
   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on
   * the `kind` value.
   *
   * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).
   * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.
   *
   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be
   * used to extend swap behavior.
   */
  struct SingleSwap {
    bytes32 poolId;
    SwapKind kind;
    IAsset assetIn;
    IAsset assetOut;
    uint256 amount;
    bytes userData;
  }

  /**
   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the
   * `recipient` account.
   *
   * If the caller is not `sender`, it must be an authorized relayer for them.
   *
   * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20
   * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`
   * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of
   * `joinPool`.
   *
   * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of
   * transferred. This matches the behavior of `exitPool`.
   *
   * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a
   * revert.
   */
  struct FundManagement {
    address sender;
    bool fromInternalBalance;
    address payable recipient;
    bool toInternalBalance;
  }

  /**
   * @dev Performs a swap with a single Pool.
   *
   * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens
   * taken from the Pool, which must be greater than or equal to `limit`.
   *
   * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens
   * sent to the Pool, which must be less than or equal to `limit`.
   *
   * Internal Balance usage and the recipient are determined by the `funds` struct.
   *
   * Emits a `Swap` event.
   */
  function swap(
    SingleSwap memory singleSwap,
    FundManagement memory funds,
    uint256 limit,
    uint256 deadline
  ) external payable returns (uint256);
}",673
RealWorld_TA_115_IFeeDistributorV1_RealWorld_20240815190942.log,115,IFeeDistributorV1,31428,1525,32953,93.0,0.18764,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IAddressProviderV1.sol"";

interface IFeeDistributorV1 {
  event PayeeAdded(address indexed account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  function release() external;

  function changePayees(address[] memory _payees, uint256[] memory _shares) external;

  function a() external view returns (IAddressProviderV1);

  function lastReleasedAt() external view returns (uint256);

  function getPayees() external view returns (address[] memory);

  function totalShares() external view returns (uint256);

  function shares(address payee) external view returns (uint256);
}",154
RealWorld_TA_115_MerkleDistributor_RealWorld_20240815203751.log,115,MerkleDistributor,69693,3002,72695,105.0,0.408505,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/cryptography/MerkleProof.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""../interfaces/IMerkleDistributor.sol"";

contract MerkleDistributor is IMerkleDistributor, Ownable {
  address public immutable override token;
  bytes32 public immutable override merkleRoot;
  uint256 public immutable override endTime;

  // This is a packed array of booleans.
  mapping(uint256 => uint256) private _claimedBitMap;

  constructor(
    address _token,
    bytes32 _merkleRoot,
    uint256 _endTime
  ) public {
    token = _token;
    merkleRoot = _merkleRoot;
    require(block.timestamp < _endTime, ""Invalid endTime"");
    endTime = _endTime;
  }

  /** @dev Modifier to check that claim period is active.*/
  modifier whenActive() {
    require(isActive(), ""Claim period has ended"");
    _;
  }

  function claim(
    uint256 _index,
    address _account,
    uint256 _amount,
    bytes32[] calldata merkleProof
  ) external override whenActive {
    require(!isClaimed(_index), ""Drop already claimed"");

    // Verify the merkle proof.
    bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));
    require(MerkleProof.verify(merkleProof, merkleRoot, node), ""Invalid proof"");

    // Mark it claimed and send the token.
    _setClaimed(_index);
    require(IERC20(token).transfer(_account, _amount), ""Transfer failed"");

    emit Claimed(_index, _account, _amount);
  }

  function isClaimed(uint256 _index) public view override returns (bool) {
    uint256 claimedWordIndex = _index / 256;
    uint256 claimedBitIndex = _index % 256;
    uint256 claimedWord = _claimedBitMap[claimedWordIndex];
    uint256 mask = (1 << claimedBitIndex);
    return claimedWord & mask == mask;
  }

  function isActive() public view override returns (bool) {
    return block.timestamp < endTime;
  }

  function recoverERC20(address _tokenAddress, uint256 _tokenAmount) public onlyOwner {
    IERC20(_tokenAddress).transfer(owner(), _tokenAmount);
  }

  function _setClaimed(uint256 _index) private {
    uint256 claimedWordIndex = _index / 256;
    uint256 claimedBitIndex = _index % 256;
    _claimedBitMap[claimedWordIndex] = _claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);
  }
}",607
RealWorld_TA_115_PreUseAirdrop_RealWorld_20240815203536.log,115,PreUseAirdrop,168942,4520,173462,133.0,0.93511,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../token/MIMO.sol"";

import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../liquidityMining/interfaces/IMIMODistributor.sol"";

contract PreUseAirdrop {
  using SafeERC20 for IERC20;

  struct Payout {
    address recipient;
    uint256 amount;
  }

  Payout[] public payouts;

  IGovernanceAddressProvider public ga;
  IMIMODistributor public mimoDistributor;

  modifier onlyManager() {
    require(ga.controller().hasRole(ga.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  constructor(IGovernanceAddressProvider _ga, IMIMODistributor _mimoDistributor) public {
    require(address(_ga) != address(0));
    require(address(_mimoDistributor) != address(0));

    ga = _ga;
    mimoDistributor = _mimoDistributor;

    payouts.push(Payout(0xBBd92c75C6f8B0FFe9e5BCb2e56a5e2600871a10, 271147720731494841509243076));
    payouts.push(Payout(0xcc8793d5eB95fAa707ea4155e09b2D3F44F33D1E, 210989402066696530434956148));
    payouts.push(Payout(0x185f19B43d818E10a31BE68f445ef8EDCB8AFB83, 22182938994846641176273320));
    payouts.push(Payout(0xDeD9F901D40A96C3Ee558E6885bcc7eFC51ad078, 13678603288816593264718593));
    payouts.push(Payout(0x0B3890bbF2553Bd098B45006aDD734d6Fbd6089E, 8416873402881706143143730));
    payouts.push(Payout(0x3F41a1CFd3C8B8d9c162dE0f42307a0095A6e5DF, 7159719590701445955473554));
    payouts.push(Payout(0x9115BaDce4873d58fa73b08279529A796550999a, 5632453715407980754075398));
    payouts.push(Payout(0x7BC8C0B66d7f0E2193ED11eeCAAfE7c1837b926f, 5414893264683531027764823));
    payouts.push(Payout(0xE7809aaaaa78E5a24E059889E561f598F3a4664c, 4712320945661497844704387));
    payouts.push(Payout(0xf4D3566729f257edD0D4bF365d8f0Db7bF56e1C6, 2997276841876706895655431));
    payouts.push(Payout(0x6Cf9AA65EBaD7028536E353393630e2340ca6049, 2734992792750385321760387));
    payouts.push(Payout(0x74386381Cb384CC0FBa0Ac669d22f515FfC147D2, 1366427847282177615773594));
    payouts.push(Payout(0x9144b150f28437E06Ab5FF5190365294eb1E87ec, 1363226310703652991601514));
    payouts.push(Payout(0x5691d53685e8e219329bD8ADf62b1A0A17df9D11, 702790464733701088417744));
    payouts.push(Payout(0x2B91B4f5223a0a1f5c7e1D139dDdD6B5B57C7A51, 678663683269882192090830));
    payouts.push(Payout(0x8ddBad507F3b20239516810C308Ba4f3BaeAf3a1, 635520835923336863138335));
    payouts.push(Payout(0xc3874A2C59b9779A75874Be6B5f0b578120A8701, 488385391000796390198744));
    payouts.push(Payout(0x0A22C160f7E57F2e7d88b2fa1B1B03571bdE6128, 297735186117080365383063));
    payouts.push(Payout(0x0a1aa2b65832fC0c71f2Ba488c84BeE0b9DB9692, 132688033756581498940995));
    payouts.push(Payout(0xAf7b7AbC272a3aE6dD6dA41b9832C758477a85f2, 130254714680714068405131));
    payouts.push(Payout(0xCDb17d9bCbA8E3bab6F68D59065efe784700Bee1, 71018627162763037055295));
    payouts.push(Payout(0x4Dec19003F9Bb01A4c0D089605618b2d76deE30d, 69655357581389001902516));
    payouts.push(Payout(0x31AacA1940C82130c2D4407E609e626E87A7BC18, 21678478730854029506989));
    payouts.push(Payout(0xBc77AB8dd8BAa6ddf0D0c241d31b2e30bcEC127d, 21573657481017931484432));
    payouts.push(Payout(0x1c25cDD83Cd7106C3dcB361230eC9E6930Aadd30, 14188368728356337446426));
    payouts.push(Payout(0xf1B78ed53fa2f9B8cFfa677Ad8023aCa92109d08, 13831474058511281838532));
    payouts.push(Payout(0xd27962455de27561e62345a516931F2392997263, 6968208393315527988941));
    payouts.push(Payout(0xD8A4411C623aD361E98bC9D98cA33eE1cF308Bca, 4476771187861728227997));
    payouts.push(Payout(0x1f06fA59809ee23Ee06e533D67D29C6564fC1964, 3358338614042115121460));
    payouts.push(Payout(0xeDccc1501e3BCC8b3973B9BE33f6Bd7072d28388, 2328788070517256560738));
    payouts.push(Payout(0xD738A884B2aFE625d372260E57e86E3eB4d5e1D7, 466769668474372743140));
    payouts.push(Payout(0x6942b1b6526Fa05035d47c09B419039c00Ef7545, 442736084997163005698));
  }

  function airdrop() public onlyManager {
    MIMO mimo = MIMO(address(ga.mimo()));
    for (uint256 i = 0; i < payouts.length; i++) {
      Payout memory payout = payouts[i];
      mimo.mint(payout.recipient, payout.amount);
    }
    require(mimoDistributor.mintableTokens() > 0);

    bytes32 MIMO_MINTER_ROLE = mimo.MIMO_MINTER_ROLE();
    ga.controller().renounceRole(MIMO_MINTER_ROLE, address(this));
  }
}",1787
RealWorld_TA_115_PARMiner_RealWorld_20240815192831.log,115,PARMiner,220510,5761,226271,163.0,1.21777,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""./interfaces/IMIMO.sol"";
import ""./interfaces/IGenericMiner.sol"";

contract PARMiner {
  using SafeMath for uint256;
  using WadRayMath for uint256;
  using SafeERC20 for IERC20;

  struct UserInfo {
    uint256 stake;
    uint256 accAmountPerShare;
    uint256 accParAmountPerShare;
  }

  event StakeIncreased(address indexed user, uint256 stake);
  event StakeDecreased(address indexed user, uint256 stake);

  IERC20 public par;

  mapping(address => UserInfo) internal _users;

  uint256 public totalStake;
  IGovernanceAddressProvider public a;

  uint256 internal _balanceTracker;
  uint256 internal _accAmountPerShare;

  uint256 internal _parBalanceTracker;
  uint256 internal _accParAmountPerShare;

  constructor(IGovernanceAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;

    par = IERC20(_addresses.parallel().stablex());
  }

  /**
    Deposit an ERC20 pool token for staking
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param amount the amount of tokens to be deposited. Unit is in WEI.
  **/
  function deposit(uint256 amount) public {
    par.safeTransferFrom(msg.sender, address(this), amount);
    _increaseStake(msg.sender, amount);
  }

  /**
    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked.
    @param amount the amount of tokens to be withdrawn. Unit is in WEI.
  **/
  function withdraw(uint256 amount) public {
    par.safeTransfer(msg.sender, amount);
    _decreaseStake(msg.sender, amount);
  }

  /**
    Releases the outstanding MIMO balance to the user.
    @param _user the address of the user for which the MIMO tokens will be released.
  */
  function releaseMIMO(address _user) public virtual {
    UserInfo storage userInfo = _users[_user];
    _refresh();
    _refreshPAR(totalStake);
    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.accAmountPerShare = _accAmountPerShare;
    require(a.mimo().transfer(_user, pending));
  }

  /**
    Releases the outstanding PAR reward balance to the user.
    @param _user the address of the user for which the PAR tokens will be released.
  */
  function releasePAR(address _user) public virtual {
    UserInfo storage userInfo = _users[_user];
    _refresh();
    _refreshPAR(totalStake);
    uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));
    _parBalanceTracker = _parBalanceTracker.sub(pending);
    userInfo.accParAmountPerShare = _accParAmountPerShare;
    require(par.transfer(_user, pending));
  }

  /**
    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake
    @param _user the address of the user for which the PAR tokens will be restaked.
  */
  function restakePAR(address _user) public virtual {
    UserInfo storage userInfo = _users[_user];
    _refresh();
    _refreshPAR(totalStake);
    uint256 pending = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));
    _parBalanceTracker = _parBalanceTracker.sub(pending);
    userInfo.accParAmountPerShare = _accParAmountPerShare;

    _increaseStake(_user, pending);
  }

  /**
    Returns the number of tokens a user has staked.
    @param _user the address of the user.
    @return number of staked tokens
  */
  function stake(address _user) public view returns (uint256) {
    return _users[_user].stake;
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`.
    @param _user the address of the user.
    @return number of MIMO tokens that the user can claim
  */
  function pendingMIMO(address _user) public view returns (uint256) {
    uint256 currentBalance = a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_balanceTracker);
    uint256 accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));

    return _users[_user].stake.rayMul(accAmountPerShare.sub(_users[_user].accAmountPerShare));
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @param _user the address of the user.
    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking
  */
  function pendingPAR(address _user) public view returns (uint256) {
    uint256 currentBalance = par.balanceOf(address(this)).sub(totalStake);
    uint256 reward = currentBalance.sub(_parBalanceTracker);
    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(totalStake));

    return _users[_user].stake.rayMul(accParAmountPerShare.sub(_users[_user].accParAmountPerShare));
  }

  /**
    Returns the userInfo stored of a user.
    @param _user the address of the user.
    @return `struct UserInfo {
      uint256 stake;
      uint256 rewardDebt;
    }`
  **/
  function userInfo(address _user) public view returns (UserInfo memory) {
    return _users[_user];
  }

  /**
    Refreshes the global state and subsequently decreases the stake a user has.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param value the amount by which the stake will be reduced
  */
  function _decreaseStake(address user, uint256 value) internal {
    require(value > 0, ""STAKE_MUST_BE_GREATER_THAN_ZERO""); //TODO cleanup error message

    UserInfo storage userInfo = _users[user];
    require(userInfo.stake >= value, ""INSUFFICIENT_STAKE_FOR_USER""); //TODO cleanup error message
    _refresh();
    uint256 newTotalStake = totalStake.sub(value);
    _refreshPAR(newTotalStake);

    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.accAmountPerShare = _accAmountPerShare;

    uint256 pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));

    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    userInfo.accParAmountPerShare = _accParAmountPerShare;

    userInfo.stake = userInfo.stake.sub(value);
    totalStake = newTotalStake;

    if (pending > 0) {
      require(a.mimo().transfer(user, pending));
    }
    if (pendingPAR > 0) {
      require(par.transfer(user, pendingPAR));
    }

    emit StakeDecreased(user, value);
  }

  /**
    Refreshes the global state and subsequently increases a user's stake.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param value the amount by which the stake will be increased
  */
  function _increaseStake(address user, uint256 value) internal {
    require(value > 0, ""STAKE_MUST_BE_GREATER_THAN_ZERO""); //TODO cleanup error message

    UserInfo storage userInfo = _users[user];

    _refresh();

    uint256 newTotalStake = totalStake.add(value);
    _refreshPAR(newTotalStake);

    uint256 pending;
    uint256 pendingPAR;
    if (userInfo.stake > 0) {
      pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
      _balanceTracker = _balanceTracker.sub(pending);

      // maybe we should add the accumulated PAR to the stake of the user instead?
      pendingPAR = userInfo.stake.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));
      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    }

    totalStake = newTotalStake;
    userInfo.stake = userInfo.stake.add(value);

    userInfo.accAmountPerShare = _accAmountPerShare;
    userInfo.accParAmountPerShare = _accParAmountPerShare;

    if (pendingPAR > 0) {
      // add pendingPAR balance to stake and totalStake instead of sending it back
      userInfo.stake = userInfo.stake.add(pendingPAR);
      totalStake = totalStake.add(pendingPAR);
    }
    if (pending > 0) {
      require(a.mimo().transfer(user, pending));
    }

    emit StakeIncreased(user, value.add(pendingPAR));
  }

  /**
    Refreshes the global state and subsequently updates a user's stake.
    This is an internal call and meant to be called within derivative contracts.
    @param user the address of the user
    @param stake the new amount of stake for the user
  */
  function _updateStake(address user, uint256 stake) internal returns (bool) {
    uint256 oldStake = _users[user].stake;
    if (stake > oldStake) {
      _increaseStake(user, stake.sub(oldStake));
    }
    if (stake < oldStake) {
      _decreaseStake(user, oldStake.sub(stake));
    }
  }

  /**
    Updates the internal state variables after accounting for newly received MIMO tokens.
  */
  function _refresh() internal {
    if (totalStake == 0) {
      return;
    }
    uint256 currentBalance = a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_balanceTracker);
    _balanceTracker = currentBalance;
    _accAmountPerShare = _accAmountPerShare.add(reward.rayDiv(totalStake));
  }

  /**
    Updates the internal state variables after accounting for newly received PAR tokens.
  */
  function _refreshPAR(uint256 newTotalStake) internal {
    if (totalStake == 0) {
      return;
    }
    uint256 currentParBalance = par.balanceOf(address(this)).sub(newTotalStake);
    uint256 parReward = currentParBalance.sub(_parBalanceTracker);

    _parBalanceTracker = currentParBalance;
    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(totalStake));
  }
}",2394
RealWorld_TA_115_IFeeDistributor_RealWorld_20240815222251.log,115,IFeeDistributor,31072,1576,32648,92.0,0.18688,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface IFeeDistributor {
  event PayeeAdded(address indexed account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  function release() external;

  function changePayees(address[] memory _payees, uint256[] memory _shares) external;

  function a() external view returns (IAddressProvider);

  function lastReleasedAt() external view returns (uint256);

  function getPayees() external view returns (address[] memory);

  function totalShares() external view returns (uint256);

  function shares(address payee) external view returns (uint256);
}",149
RealWorld_TA_115_MIMODistributorV2_RealWorld_20240815192613.log,115,MIMODistributorV2,97112,4737,101849,135.0,0.5803,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IMIMODistributor.sol"";
import ""./BaseDistributor.sol"";

contract MIMODistributorV2 is BaseDistributor, IMIMODistributorExtension {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 private constant _SECONDS_PER_YEAR = 365 days;
  uint256 private constant _SECONDS_PER_WEEK = 7 days;
  uint256 private constant _WEEKLY_R = 986125e21; // -1.3875% per week (-5.55% / 4)
  uint256 private _FIRST_WEEK_TOKENS;

  uint256 public override startTime;
  uint256 public alreadyMinted;

  constructor(
    IGovernanceAddressProvider _a,
    uint256 _startTime,
    IMIMODistributor _mimoDistributor
  ) public {
    require(address(_a) != address(0));
    require(address(_mimoDistributor) != address(0));

    a = _a;
    startTime = _startTime;
    alreadyMinted = _mimoDistributor.totalSupplyAt(startTime);

    uint256 weeklyIssuanceV1 = _mimoDistributor.weeklyIssuanceAt(startTime);
    _FIRST_WEEK_TOKENS = weeklyIssuanceV1 / 4; // reduce weeky issuance by 4
  }

  /**
    Get current monthly issuance of new MIMO tokens.
    @return number of monthly issued tokens currently`.
  */
  function currentIssuance() public view override returns (uint256) {
    return weeklyIssuanceAt(now);
  }

  /**
    Get monthly issuance of new MIMO tokens at `timestamp`.
    @dev invalid for timestamps before deployment
    @param timestamp for which to calculate the monthly issuance
    @return number of monthly issued tokens at `timestamp`.
  */
  function weeklyIssuanceAt(uint256 timestamp) public view override returns (uint256) {
    uint256 elapsedSeconds = timestamp.sub(startTime);
    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);
    return _WEEKLY_R.rayPow(elapsedWeeks).rayMul(_FIRST_WEEK_TOKENS);
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view override returns (uint256) {
    return totalSupplyAt(now).sub(a.mimo().totalSupply());
  }

  /**
    Calculates the totalSupply for any point after `startTime`
    @param timestamp for which to calculate the totalSupply
    @return totalSupply at timestamp.
  */
  function totalSupplyAt(uint256 timestamp) public view override returns (uint256) {
    uint256 elapsedSeconds = timestamp.sub(startTime);
    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);
    uint256 lastWeekSeconds = elapsedSeconds % _SECONDS_PER_WEEK;
    uint256 one = WadRayMath.ray();
    uint256 fullWeeks = one.sub(_WEEKLY_R.rayPow(elapsedWeeks)).rayMul(_FIRST_WEEK_TOKENS).rayDiv(one.sub(_WEEKLY_R));
    uint256 currentWeekIssuance = weeklyIssuanceAt(timestamp);
    uint256 partialWeek = currentWeekIssuance.mul(lastWeekSeconds).div(_SECONDS_PER_WEEK);
    return alreadyMinted.add(fullWeeks.add(partialWeek));
  }

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {
    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);
    a.mimo().mint(_payee, payment);
  }
}",915
RealWorld_TA_115_IDexAddressProvider_RealWorld_20240815220907.log,115,IDexAddressProvider,28438,2055,30493,96.0,0.18329,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../interfaces/IAddressProvider.sol"";

interface IDexAddressProvider {
  event DexSet(uint8);

  struct Dex {
    address proxy;
    address router;
  }

  function setDexMapping(
    uint256 _index,
    address _proxy,
    address _dex
  ) external;

  function parallel() external view returns (IAddressProvider);

  function dexMapping(uint256 index) external view returns (address, address);
}",115
RealWorld_TA_115_IVotingMiner_RealWorld_20240815201743.log,115,IVotingMiner,20934,1707,22641,87.0,0.13881,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

interface IVotingMiner {}",30
RealWorld_TA_115_IVotingMinerV2_RealWorld_20240815201229.log,115,IVotingMinerV2,21931,1486,23417,83.0,0.139375,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

interface IVotingMinerV2 {
  function syncStake(address user) external;
}",43
RealWorld_TA_115_MinerPayer_RealWorld_20240815193742.log,115,MinerPayer,102538,4724,107262,121.0,0.60717,"pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";

/*
@title Miner Payer
@notice A tool for sending MIMO tokens to a set of miners
*/
contract MinerPayer {
  event PayeeAdded(address account, uint256 shares);
  event TokensReleased(uint256 newTokens, uint256 releasedAt);
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 public totalShares;
  IGovernanceAddressProvider public a;
  bytes32 public constant KEEPER_ROLE = keccak256(""KEEPER_ROLE"");
  mapping(address => uint256) public shares;
  address[] public payees;

  modifier onlyKeeper() {
    require(a.controller().hasRole(KEEPER_ROLE, msg.sender), ""Caller is not a Keeper"");
    _;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a manager"");
    _;
  }

  constructor(IGovernanceAddressProvider _a) public {
    require(address(_a) != address(0), ""Governance address can't be 0 address"");
    a = _a;
  }

  /*
  @notice Sends a total amount of MIMO tokens held by this contract to a set of miners, distributing the total amount as per the shares array stored in the contract
  @param totalAmount The total amount to send all of the miners
  */
  function release(uint256 totalAmount) public onlyKeeper {
    require(totalAmount <= a.mimo().balanceOf(address(this)), ""Contract doesn't hold enough MIMO to distribute"");
    require(totalAmount > 0, ""newTokens is 0"");
    // Send MIMO to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(totalAmount, payee);
    }
    emit TokensReleased(totalAmount, now);
  }

  /**
    Updates the payee configuration to a new one.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }

    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view returns (address[] memory) {
    return payees;
  }

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @dev same as _release in BaseDistributor
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal {
    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);
    a.mimo().transfer(_payee, payment);
  }

  /**
    Internal function to add a new payee. 
    @dev will update totalShares and therefore reduce the relative share of all other payees. 
    @dev Same as _addPayee in BaseDistributor.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""Payee is the zero address"");
    require(_shares > 0, ""Shares are 0"");
    require(shares[_payee] == 0, ""Payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }
}",984
RealWorld_TA_115_Stabilizer_RealWorld_20240815213945.log,115,Stabilizer,32660,1889,34549,94.0,0.20108,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

interface Stabilizer {
  function refreshAndRelease() external;

  function withdraw(
    address tokenAddress,
    uint256 amount,
    address destination
  ) external;

  function withdrawAll(address destination) external;

  function liquidate(uint256 vaultId) external;

  function WETH() external view returns (address);

  function PAR() external view returns (address);

  function pool() external view returns (address);

  function demandMiner() external view returns (address);

  function mimoDistributor() external view returns (address);

  function a() external view returns (address);

  function AUTOMATOR_ADDRESS() external view returns (address);

  function owner() external view returns (address);
}",169
RealWorld_TA_115_MIMODistributor_RealWorld_20240815193328.log,115,MIMODistributor,94669,3583,98252,113.0,0.545005,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IMIMODistributor.sol"";
import ""./BaseDistributor.sol"";

/*
  	Distribution Formula:
  	55.5m MIMO in first week
  	-5.55% redution per week

  	total(timestamp) = _SECONDS_PER_WEEK * ( (1-_WEEKLY_R^(timestamp/_SECONDS_PER_WEEK)) / (1-_WEEKLY_R) )
  		+ timestamp % _SECONDS_PER_WEEK * (1-_WEEKLY_R^(timestamp/_SECONDS_PER_WEEK)
  */

contract MIMODistributor is BaseDistributor, IMIMODistributorExtension {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 private constant _SECONDS_PER_YEAR = 365 days;
  uint256 private constant _SECONDS_PER_WEEK = 7 days;
  uint256 private constant _WEEKLY_R = 9445e23; //-5.55%
  uint256 private constant _FIRST_WEEK_TOKENS = 55500000 ether; //55.5m

  uint256 public override startTime;

  constructor(IGovernanceAddressProvider _a, uint256 _startTime) public {
    require(address(_a) != address(0));

    a = _a;
    startTime = _startTime;
  }

  /**
    Get current monthly issuance of new MIMO tokens.
    @return number of monthly issued tokens currently`.
  */
  function currentIssuance() public view override returns (uint256) {
    return weeklyIssuanceAt(now);
  }

  /**
    Get monthly issuance of new MIMO tokens at `timestamp`.
    @dev invalid for timestamps before deployment
    @param timestamp for which to calculate the monthly issuance
    @return number of monthly issued tokens at `timestamp`.
  */
  function weeklyIssuanceAt(uint256 timestamp) public view override returns (uint256) {
    uint256 elapsedSeconds = timestamp.sub(startTime);
    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);
    return _WEEKLY_R.rayPow(elapsedWeeks).rayMul(_FIRST_WEEK_TOKENS);
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view override returns (uint256) {
    return totalSupplyAt(now).sub(a.mimo().totalSupply());
  }

  /**
    Calculates the totalSupply for any point after `startTime`
    @param timestamp for which to calculate the totalSupply
    @return totalSupply at timestamp.
  */
  function totalSupplyAt(uint256 timestamp) public view override returns (uint256) {
    uint256 elapsedSeconds = timestamp.sub(startTime);
    uint256 elapsedWeeks = elapsedSeconds.div(_SECONDS_PER_WEEK);
    uint256 lastWeekSeconds = elapsedSeconds % _SECONDS_PER_WEEK;
    uint256 one = WadRayMath.ray();
    uint256 fullWeeks = one.sub(_WEEKLY_R.rayPow(elapsedWeeks)).rayMul(_FIRST_WEEK_TOKENS).rayDiv(one.sub(_WEEKLY_R));
    uint256 currentWeekIssuance = weeklyIssuanceAt(timestamp);
    uint256 partialWeek = currentWeekIssuance.mul(lastWeekSeconds).div(_SECONDS_PER_WEEK);
    return fullWeeks.add(partialWeek);
  }

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {
    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);
    a.mimo().mint(_payee, payment);
  }
}",900
RealWorld_TA_115_IConfigProvider_RealWorld_20240815223414.log,115,IConfigProvider,78268,2869,81137,112.0,0.44872,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface IConfigProvider {
  struct CollateralConfig {
    address collateralType;
    uint256 debtLimit;
    uint256 liquidationRatio;
    uint256 minCollateralRatio;
    uint256 borrowRate;
    uint256 originationFee;
    uint256 liquidationBonus;
    uint256 liquidationFee;
  }

  event CollateralUpdated(
    address indexed collateralType,
    uint256 debtLimit,
    uint256 liquidationRatio,
    uint256 minCollateralRatio,
    uint256 borrowRate,
    uint256 originationFee,
    uint256 liquidationBonus,
    uint256 liquidationFee
  );
  event CollateralRemoved(address indexed collateralType);

  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _liquidationRatio,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee,
    uint256 _liquidationBonus,
    uint256 _liquidationFee
  ) external;

  function removeCollateral(address _collateralType) external;

  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;

  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;

  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;

  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;

  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;

  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;

  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;

  function setMinVotingPeriod(uint256 _minVotingPeriod) external;

  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;

  function setVotingQuorum(uint256 _votingQuorum) external;

  function setProposalThreshold(uint256 _proposalThreshold) external;

  function a() external view returns (IAddressProvider);

  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);

  function collateralIds(address _collateralType) external view returns (uint256);

  function numCollateralConfigs() external view returns (uint256);

  function minVotingPeriod() external view returns (uint256);

  function maxVotingPeriod() external view returns (uint256);

  function votingQuorum() external view returns (uint256);

  function proposalThreshold() external view returns (uint256);

  function collateralDebtLimit(address _collateralType) external view returns (uint256);

  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);

  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);

  function collateralBorrowRate(address _collateralType) external view returns (uint256);

  function collateralOriginationFee(address _collateralType) external view returns (uint256);

  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);

  function collateralLiquidationFee(address _collateralType) external view returns (uint256);
}",732
RealWorld_TA_115_EthereumDistributor_RealWorld_20240815195136.log,115,EthereumDistributor,47282,3295,50577,118.0,0.30231,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import { SafeERC20, IERC20 } from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./BaseDistributor.sol"";

contract EthereumDistributor is BaseDistributor {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  constructor(IGovernanceAddressProvider _a) public {
    require(address(_a) != address(0));

    a = _a;
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view override returns (uint256) {
    return a.mimo().balanceOf(address(this));
  }

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal override {
    uint256 payment = _totalnewTokensReceived.mul(shares[_payee]).div(totalShares);
    IERC20(a.mimo()).safeTransfer(_payee, payment);
  }
}",341
RealWorld_TA_115_VaultsDataProviderV1_RealWorld_20240815185639.log,115,VaultsDataProviderV1,155500,3338,158838,128.0,0.84426,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IVaultsDataProviderV1.sol"";
import ""./interfaces/IAddressProviderV1.sol"";

contract VaultsDataProviderV1 is IVaultsDataProviderV1 {
  using SafeMath for uint256;

  IAddressProviderV1 public override a;

  uint256 public override vaultCount = 0;

  mapping(address => uint256) public override baseDebt;

  mapping(uint256 => Vault) private _vaults;
  mapping(address => mapping(address => uint256)) private _vaultOwners;

  modifier onlyVaultsCore() {
    require(msg.sender == address(a.core()), ""Caller is not VaultsCore"");
    _;
  }

  constructor(IAddressProviderV1 _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Opens a new vault.
    @dev only the vaultsCore module can call this function
    @param _collateralType address to the collateral asset e.g. WETH
    @param _owner the owner of the new vault.
  */
  function createVault(address _collateralType, address _owner) public override onlyVaultsCore returns (uint256) {
    require(_collateralType != address(0));
    require(_owner != address(0));
    uint256 newId = ++vaultCount;
    require(_collateralType != address(0), ""collateralType unknown"");
    Vault memory v = Vault({
      collateralType: _collateralType,
      owner: _owner,
      collateralBalance: 0,
      baseDebt: 0,
      createdAt: block.timestamp
    });
    _vaults[newId] = v;
    _vaultOwners[_owner][_collateralType] = newId;
    return newId;
  }

  /**
    Set the collateral balance of a vault.
    @dev only the vaultsCore module can call this function
    @param _id Vault ID of which the collateral balance will be updated
    @param _balance the new balance of the vault.
  */
  function setCollateralBalance(uint256 _id, uint256 _balance) public override onlyVaultsCore {
    require(vaultExists(_id), ""Vault not found."");
    Vault storage v = _vaults[_id];
    v.collateralBalance = _balance;
  }

  /**
    Set the base debt of a vault.
    @dev only the vaultsCore module can call this function
    @param _id Vault ID of which the base debt will be updated
    @param _newBaseDebt the new base debt of the vault.
  */
  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) public override onlyVaultsCore {
    Vault storage _vault = _vaults[_id];
    if (_newBaseDebt > _vault.baseDebt) {
      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);
      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].add(increase);
    } else {
      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);
      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].sub(decrease);
    }
    _vault.baseDebt = _newBaseDebt;
  }

  /**
    Get a vault by vault ID.
    @param _id The vault's ID to be retrieved
  */
  function vaults(uint256 _id) public view override returns (Vault memory) {
    Vault memory v = _vaults[_id];
    return v;
  }

  /**
    Get the owner of a vault.
    @param _id the ID of the vault
    @return owner of the vault
  */
  function vaultOwner(uint256 _id) public view override returns (address) {
    return _vaults[_id].owner;
  }

  /**
    Get the collateral type of a vault.
    @param _id the ID of the vault
    @return address for the collateral type of the vault
  */
  function vaultCollateralType(uint256 _id) public view override returns (address) {
    return _vaults[_id].collateralType;
  }

  /**
    Get the collateral balance of a vault.
    @param _id the ID of the vault
    @return collateral balance of the vault
  */
  function vaultCollateralBalance(uint256 _id) public view override returns (uint256) {
    return _vaults[_id].collateralBalance;
  }

  /**
    Get the base debt of a vault.
    @param _id the ID of the vault
    @return base debt of the vault
  */
  function vaultBaseDebt(uint256 _id) public view override returns (uint256) {
    return _vaults[_id].baseDebt;
  }

  /**
    Retrieve the vault id for a specified owner and collateral type.
    @dev returns 0 for non-existing vaults
    @param _collateralType address of the collateral type (Eg: WETH)
    @param _owner address of the owner of the vault
    @return vault id of the vault or 0
  */
  function vaultId(address _collateralType, address _owner) public view override returns (uint256) {
    return _vaultOwners[_owner][_collateralType];
  }

  /**
    Checks if a specified vault exists.
    @param _id the ID of the vault
    @return boolean if the vault exists
  */
  function vaultExists(uint256 _id) public view override returns (bool) {
    Vault memory v = _vaults[_id];
    return v.collateralType != address(0);
  }

  /**
    Calculated the total outstanding debt for all vaults and all collateral types.
    @dev uses the existing cumulative rate. Call `refresh()` on `VaultsCore`
    to make sure it's up to date.
    @return total debt of the platform
  */
  function debt() public view override returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      total = total.add(collateralDebt(collateralType));
    }
    return total;
  }

  /**
    Calculated the total outstanding debt for all vaults of a specific collateral type.
    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`
    to make sure it's up to date.
    @param _collateralType address of the collateral type (Eg: WETH)
    @return total debt of the platform of one collateral type
  */
  function collateralDebt(address _collateralType) public view override returns (uint256) {
    return a.ratesManager().calculateDebt(baseDebt[_collateralType], a.core().cumulativeRates(_collateralType));
  }

  /**
    Calculated the total outstanding debt for a specific vault.
    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`
    to make sure it's up to date.
    @param _vaultId the ID of the vault
    @return total debt of one vault
  */
  function vaultDebt(uint256 _vaultId) public view override returns (uint256) {
    IVaultsDataProviderV1.Vault memory v = vaults(_vaultId);
    return a.ratesManager().calculateDebt(v.baseDebt, a.core().cumulativeRates(v.collateralType));
  }
}",1649
RealWorld_TA_115_IPriceFeed_RealWorld_20240815230639.log,115,IPriceFeed,30678,2949,33627,120.0,0.21237,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.10;

interface IPriceFeed {
  event OracleUpdated(address indexed asset, address oracle, address sender);
  event EurOracleUpdated(address oracle, address sender);

  function setAssetOracle(address _asset, address _oracle) external;

  function setEurOracle(address _oracle) external;

  function getAssetPrice(address _asset) external view returns (uint256);

  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);

  function convertTo(address _asset, uint256 _amount) external view returns (uint256);
}",130
RealWorld_TA_115_MockBalancerVault_RealWorld_20240815183343.log,115,MockBalancerVault,42064,3595,45659,121.0,0.28222,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../interfaces/IBalancerVault.sol"";

contract MockBalancerVault is IBalancerVault {
  address[2] public tokens;
  uint256[2] public balances;
  address public pool;

  constructor(address[2] memory _tokens, address _pool) public {
    tokens = _tokens;
    pool = _pool;
  }

  function setBalances(uint256[2] memory _balances) public {
    balances = _balances;
  }

  function getPool(bytes32 poolId) external view override returns (address, PoolSpecialization) {
    return (pool, IBalancerVault.PoolSpecialization.TWO_TOKEN);
  }

  function getPoolTokens(bytes32 poolId)
    external
    view
    override
    returns (
      address[] memory _tokens,
      uint256[] memory _balances,
      uint256
    )
  {
    _tokens = new address[](2);
    _tokens[0] = tokens[0];
    _tokens[1] = tokens[1];

    _balances = new uint256[](2);
    _balances[0] = balances[0];
    _balances[1] = balances[1];
  }
}",262
RealWorld_TA_115_SuperVault_RealWorld_20240815225453.log,115,SuperVault,347962,6397,354359,204.0,1.86775,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import { IPool } from ""@aave/core-v3/contracts/interfaces/IPool.sol"";

import ""./interfaces/IAddressProvider.sol"";
import ""./interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IVaultsCore.sol"";
import ""./interfaces/IGenericMiner.sol"";
import ""./interfaces/IDexAddressProvider.sol"";

/// @title A parallel protocol vault with added functionality
/// @notice You can use this for collateral rebalancing
/// @dev This contract should be cloned and initialized with a SuperVaultFactory contract
contract SuperVault is AccessControl, Initializable {
  enum Operation {
    LEVERAGE,
    REBALANCE,
    EMPTY
  }

  struct AggregatorRequest {
    uint256 parToSell;
    bytes dexTxData;
    uint dexIndex;
  }

  IAddressProvider public a;
  IGovernanceAddressProvider public ga;
  IPool public lendingPool;
  IDexAddressProvider internal _dexAP;

  modifier onlyOwner() {
    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""SV001"");
    _;
  }

  ///@notice Initializes the Supervault contract
  ///@dev This replaces the constructor function as in the factory design pattern
  ///@param _a The address of the protocol's AddressProvider
  ///@param _ga The address of the protocol's GovernanceAddressProvider
  ///@param _lendingPool The address of the lendingPool from where flashLoans are taken
  ///@param _owner The owner of this SuperVault contract
  function initialize(
    IAddressProvider _a,
    IGovernanceAddressProvider _ga,
    IPool _lendingPool,
    address _owner,
    IDexAddressProvider dexAP
  ) external initializer {
    require(address(_a) != address(0));
    require(address(_ga) != address(0));
    require(address(_lendingPool) != address(0));
    require(address(dexAP) != address(0));

    a = _a;
    ga = _ga;
    lendingPool = _lendingPool;
    _dexAP = dexAP;

    _setupRole(DEFAULT_ADMIN_ROLE, _owner);
  }

  ///@notice Routes a call from a flashloan pool to a leverage or rebalance operation
  ///@dev This Integrates with AAVE V2 flashLoans
  ///@dev This function is called by the lendingPool during execution of the leverage function
  ///@param assets An address array with one element corresponding to the address of the leveraged or rebalanced asset
  ///@param amounts A uint array with one element corresponding to the amount of the leveraged or rebalanced asset
  ///@param premiums A uint array with one element corresponding to the flashLoan fees
  ///@param params Bytes sent by the leverage or rebalance function that contains information on the aggregator swap
  function executeOperation(
    address[] calldata assets,
    uint256[] calldata amounts,
    uint256[] calldata premiums,
    address,
    bytes calldata params
  ) external returns (bool) {
    require(msg.sender == address(lendingPool), ""SV002"");
    (Operation operation, bytes memory operationParams) = abi.decode(params, (Operation, bytes));
    IERC20 asset = IERC20(assets[0]);
    uint256 flashloanRepayAmount = amounts[0] + premiums[0];
    if (operation == Operation.LEVERAGE) {
      leverageOperation(asset, flashloanRepayAmount, operationParams);
    }
    if (operation == Operation.REBALANCE) {
      rebalanceOperation(asset, amounts[0], flashloanRepayAmount, operationParams);
    }
    if (operation == Operation.EMPTY) {
      emptyVaultOperation(asset, amounts[0], flashloanRepayAmount, operationParams);
    }

    asset.approve(address(lendingPool), flashloanRepayAmount);
    return true;
  }

  ///@notice Used by executeOperation to call an aggregator to swap and deposit the swapped asset into a vault
  function leverageOperation(
    IERC20 token,
    uint256 flashloanRepayAmount,
    bytes memory params
  ) internal {
    leverageSwap(params, token);

    require(token.balanceOf(address(this)) >= flashloanRepayAmount, ""SV101"");
    a.core().deposit(address(token), token.balanceOf(address(this)) - flashloanRepayAmount);
  }

  ///@notice Leverage an asset using a flashloan to balance collateral
  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation
  ///@param asset The address of the asset to leverage
  ///@param depositAmount The initial starting amount, e.g. 1 ETH
  ///@param borrowAmount The amount to be borrowed, e.g. 2 ETH, bringing the total to 3 ETH
  ///@param parToSell The amount of PAR we'll borrow so we can repay the leverage
  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap
  ///@param dexIndex DexAddressProvider index of the aggregator to be used for selling PAR, either OneInch or Paraswap
  function leverage(
    address asset,
    uint256 depositAmount, //
    uint256 borrowAmount, //
    uint256 parToSell, //
    bytes calldata dexTxData,
    uint dexIndex 
  ) external onlyOwner {
    IERC20(asset).transferFrom(msg.sender, address(this), depositAmount);
    bytes memory leverageParams = abi.encode(parToSell, dexTxData, dexIndex);
    bytes memory params = abi.encode(Operation.LEVERAGE, leverageParams);
    takeFlashLoan(asset, borrowAmount, params);
    checkAndSendMIMO();
  }

  ///@notice Used by executeOperation to flashloan an asset, call an aggregator to swap for toAsset, and then rebalance the vault
  function rebalanceOperation(
    IERC20 fromCollateral,
    uint256 amount,
    uint256 flashloanRepayAmount,
    bytes memory params
  ) internal {
    (uint256 vaultId, address toCollateral, uint256 parAmount, bytes memory dexTxData, uint dexIndex) = abi
      .decode(params, (uint256, address, uint256, bytes, uint ));
    aggregatorSwap(dexIndex, fromCollateral, amount, dexTxData);

    uint256 depositAmount = IERC20(toCollateral).balanceOf(address(this));

    IERC20(toCollateral).approve(address(a.core()), depositAmount);

    a.core().depositAndBorrow(toCollateral, depositAmount, parAmount);
    a.core().repay(vaultId, parAmount);

    a.core().withdraw(vaultId, flashloanRepayAmount);

    require(fromCollateral.balanceOf(address(this)) >= flashloanRepayAmount, ""SV101"");
  }

  ///@notice Uses a flashloan to exchange one collateral type for another, e.g. to hold less volatile collateral
  ///@notice Both collateral vaults must have been created by this contract using the depositToVault or depositAndBorrowFromVault functions
  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation
  ///@param vaultId The Id of the vault to reduce the collateral of
  ///@param toCollateral Address of the collateral to rebalance to
  ///@param fromCollateral Address of the starting collateral that will be reduced
  ///@param fromCollateralAmount Amount of starting collateral to deleverage
  ///@param parAmount Amount of par that will be deposited to exchange for
  ///@param dexTxData Bytes that will be passed to executeOperation that encodes args for the aggregator Swap
  ///@param dexIndex DexAddressProvider index representing the aggregator to be used for selling PAR, either OneInch or Paraswap
  function rebalance(
    uint256 vaultId, // vaultId to deleverage
    address toCollateral,
    address fromCollateral, // save some gas by just passing in collateral type instead of querying VaultsDataProvider for it
    uint256 fromCollateralAmount, // amount of collateral to reduce in main vault and borrow from Aave first
    uint256 parAmount, // amount of PAR to repay and deleverage
    bytes calldata dexTxData,
    uint dexIndex 
  ) external onlyOwner {
    bytes memory rebalanceParams = abi.encode(vaultId, toCollateral, parAmount, dexTxData, dexIndex);
    bytes memory params = abi.encode(Operation.REBALANCE, rebalanceParams);

    takeFlashLoan(fromCollateral, fromCollateralAmount, params);
    checkAndSendMIMO();
  }

  ///@notice Used by executeOperation to repay all debt for a vault, withdraw collateral from the vault, and send the collateral back to the user
  ///@notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user
  function emptyVaultOperation(
    IERC20 vaultCollateral,
    uint256 amount,
    uint256 flashloanRepayAmount,
    bytes memory params
  ) internal {
    // Use par to repay debt
    (uint256 vaultId, bytes memory dexTxData, uint dexIndex) = abi.decode(params, (uint256, bytes, uint));

    aggregatorSwap(dexIndex, vaultCollateral, amount, dexTxData); // swap assets for par to repay back loan

    IERC20 par = IERC20(a.stablex());
    par.approve(address(a.core()), par.balanceOf(address(this)));

    // Repay the par debt
    a.core().repayAll(vaultId);
    uint256 vaultBalance = a.vaultsData().vaultCollateralBalance(vaultId);
    // Withdraw all collateral
    a.core().withdraw(vaultId, vaultBalance);

    require(vaultCollateral.balanceOf(address(this)) >= flashloanRepayAmount, ""SV101"");
  }

  ///@notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner
  ///@notice This vault must have been created by this contract
  ///@dev This uses an AAVE V2 flashLoan that will call executeOperation
  ///@param vaultId The Id of the vault to empty
  ///@param collateralType Address of the collateral of the vault
  ///@param repayAmount Amount of par that needs to be repaid before all collateral can be withdrawn
  ///@param dexTxData Bytes that contain the low-level call to swap the vault asset for par to repay the vault loan
  ///@param dexIndex Index to use for swapping the vault collateral for par
  function emptyVault(
    uint256 vaultId,
    address collateralType,
    uint256 repayAmount, // Amount, in collateral type, needed to borrow to repay current vault debt
    bytes calldata dexTxData,
    uint dexIndex 
  ) external onlyOwner {
    // Flashloan collateral and swap for par to repay any outstanding vault debt
    bytes memory emptyVaultParams = abi.encode(vaultId, dexTxData, dexIndex);
    bytes memory params = abi.encode(Operation.EMPTY, emptyVaultParams);
    takeFlashLoan(collateralType, repayAmount, params);

    checkAndSendMIMO();

    // Send remaining par, mimo, and collateral back to the owner
    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));
    checkAndSendMIMO();

    IERC20 collateral = IERC20(collateralType);
    collateral.transfer(msg.sender, collateral.balanceOf(address(this)));
  }

  ///@notice Withdraw collateral from a vault
  ///@notice Vault must have been created through leverage, depositToVault, or depositAndBorrowFromVault from this contract
  ///@param vaultId The ID of the vault to withdraw from
  ///@param amount The amount of collateral to withdraw
  function withdrawFromVault(uint256 vaultId, uint256 amount) external onlyOwner {
    a.core().withdraw(vaultId, amount);
    IERC20 asset = IERC20(a.vaultsData().vaultCollateralType(vaultId));
    require(asset.transfer(msg.sender, amount));
  }

  ///@notice Borrow PAR from a vault
  ///@param vaultId The ID of the vault to borrow from
  ///@param amount The amount of PAR to borrow
  function borrowFromVault(uint256 vaultId, uint256 amount) external onlyOwner {
    a.core().borrow(vaultId, amount);
    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this))));
    checkAndSendMIMO();
  }

  ///@notice Withdraw all of one type of collateral from this contract
  ///@notice Can only be used on vaults which have been created by this contract
  ///@param asset The address of the collateral type
  function withdrawAsset(address asset) external onlyOwner {
    IERC20 token = IERC20(asset);
    require(token.transfer(msg.sender, token.balanceOf(address(this))));
  }

  ///@notice Deposit collateral into a vault
  ///@notice Requires approval of asset for amount before calling
  ///@param asset Address of the collateral type
  ///@param amount Amount to deposit
  function depositToVault(address asset, uint256 amount) external {
    IERC20 token = IERC20(asset);
    token.approve(address(a.core()), amount);
    token.transferFrom(msg.sender, address(this), amount);
    a.core().deposit(asset, amount);
  }

  ///@notice Deposit collateral into a vault and borrow PAR
  ///@notice Requires approval of asset for amount before calling
  ///@param asset Address of the collateral type
  ///@param depositAmount Amount to deposit
  ///@param borrowAmount Amount of PAR to borrow after depositing
  function depositAndBorrowFromVault(
    address asset,
    uint256 depositAmount,
    uint256 borrowAmount
  ) external onlyOwner {
    IERC20 token = IERC20(asset);
    token.approve(address(a.core()), depositAmount);
    token.transferFrom(msg.sender, address(this), depositAmount);
    a.core().depositAndBorrow(asset, depositAmount, borrowAmount);
    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par
    checkAndSendMIMO();
  }

  ///@notice Release MIMO from a MIMO miner to the owner
  ///@param minerAddress The address of the MIMO miner
  function releaseMIMO(address minerAddress) external payable onlyOwner {
    IGenericMiner miner = IGenericMiner(minerAddress);
    miner.releaseMIMO(address(this));
    checkAndSendMIMO();
  }

  ///@notice Wrap ETH and deposit WETH as collateral into a vault
  function depositETHToVault() external payable {
    a.core().depositETH{ value: msg.value }();
  }

  ///@notice Wrap ETH and deposit WETH as collateral into a vault, then borrow PAR from vault
  ///@param borrowAmount The amount of PAR to borrow after depositing ETH
  function depositETHAndBorrowFromVault(uint256 borrowAmount) external payable onlyOwner {
    a.core().depositETHAndBorrow{ value: msg.value }(borrowAmount);
    require(IERC20(a.stablex()).transfer(msg.sender, IERC20(a.stablex()).balanceOf(address(this)))); //par
    checkAndSendMIMO();
  }

  ///@notice Helper function to call an aggregator to swap PAR for a leveraged asset
  ///@dev This helper function is used to limit the number of local variables in the leverageOperation function
  ///@param params The params passed from the leverageOperation function for the aggregator call
  ///@param token The leveraged asset to swap PAR for
  function leverageSwap(bytes memory params, IERC20 token) internal {
    (uint256 parToSell, bytes memory dexTxData, uint dexIndex) = abi.decode(
      params,
      (uint256, bytes, uint )
    );
    token.approve(address(a.core()), 2**256 - 1);
    a.core().depositAndBorrow(address(token), token.balanceOf(address(this)), parToSell);
    IERC20 par = IERC20(a.stablex());
    aggregatorSwap(dexIndex, par, parToSell, dexTxData);
  }

  ///@notice Helper function to approve and swap an asset using an aggregator
  ///@param dexIndex The DexAddressProvider index of aggregator to use to swap
  ///@param token The starting token to swap for another asset
  ///@param amount The amount of starting token to swap for
  ///@param dexTxData The low-level data to call the aggregator with
  function aggregatorSwap(
    uint256 dexIndex,
    IERC20 token,
    uint256 amount,
    bytes memory dexTxData
  ) internal {
    (address proxy, address router) = _dexAP.dexMapping(dexIndex);
    require(proxy != address(0) && router != address(0), ""SV201""); 
    token.approve(proxy, amount);
    router.call(dexTxData);
  }

  ///@notice Helper function to format arguments to take a flashloan
  ///@dev The flashloan call will call the executeOperation function on this contract
  ///@param asset The address of the asset to loan
  ///@param amount The amount to borrow
  ///@param params The params that will be sent to executeOperation after the asset is borrowed
  function takeFlashLoan(
    address asset,
    uint256 amount,
    bytes memory params
  ) internal {
    uint8 referralCode;
    address[] memory assets = new address[](1);
    uint256[] memory amounts = new uint256[](1);
    uint256[] memory modes = new uint256[](1);
    (assets[0], amounts[0]) = (asset, amount);
    lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), params, referralCode);
  }

  ///@notice Helper function to transfer all MIMO owned by this contract to the Owner
  function checkAndSendMIMO() internal {
    if (ga.mimo().balanceOf(address(this)) > 0) {
      require(ga.mimo().transfer(msg.sender, ga.mimo().balanceOf(address(this))));
    }
  }
}",3973
RealWorld_TA_115_IVaultsCore_RealWorld_20240815225819.log,115,IVaultsCore,55179,1721,56900,94.0,0.310315,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

interface IVaultsCore {
  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);
  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Liquidated(
    uint256 indexed vaultId,
    uint256 debtRepaid,
    uint256 collateralLiquidated,
    address indexed owner,
    address indexed sender
  );

  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);

  function deposit(address _collateralType, uint256 _amount) external;

  function depositETH() external payable;

  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;

  function depositETHByVaultId(uint256 _vaultId) external payable;

  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _borrowAmount
  ) external;

  function depositETHAndBorrow(uint256 _borrowAmount) external payable;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function withdrawETH(uint256 _vaultId, uint256 _amount) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function repayAll(uint256 _vaultId) external;

  function repay(uint256 _vaultId, uint256 _amount) external;

  function liquidate(uint256 _vaultId) external;

  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;

  function upgrade(address payable _newVaultsCore) external;

  function acceptUpgrade(address payable _oldVaultsCore) external;

  function cumulativeRates(address _collateralType) external view returns (uint256);
}",437
RealWorld_TA_115_VotingMinerV2_RealWorld_20240815200538.log,115,VotingMinerV2,75324,3969,79293,112.0,0.456,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./GenericMinerV2.sol"";
import ""./interfaces/IVotingMinerV2.sol"";
import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../../governance/interfaces/IVotingEscrow.sol"";

contract VotingMinerV2 is IVotingMinerV2, GenericMinerV2 {
  using SafeMath for uint256;

  constructor(IGovernanceAddressProvider _addresses, BoostConfig memory _boostConfig)
    public
    GenericMinerV2(_addresses, _boostConfig)
  {}

  /**
    Releases the outstanding MIMO balance to the user
    @param _user the address of the user for which the MIMO tokens will be released
  */
  function releaseMIMO(address _user) external {
    UserInfo memory _userInfo = _users[_user];
    _refresh();

    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
    uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);

    if (_userInfo.stakeWithBoost > 0) {
      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);
      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    }

    _syncStake(_user, _userInfo);

    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;

    _updateBoost(_user, _userInfo);

    if (pendingMIMO > 0) {
      require(_a.mimo().transfer(_user, pendingMIMO), ""LM100"");
    }
    if (pendingPAR > 0) {
      require(_par.transfer(_user, pendingPAR), ""LM100"");
    }
  }

  /**
    Updates user stake based on current user baseDebt
    @dev this method is for upgradability purposes from an older VotingMiner to a newer one so the user doesn't have to call releaseMIMO() to set their stake in this VotingMiner
    @param _user address of the user
  */
  function syncStake(address _user) public override {
    UserInfo memory _userInfo = _users[_user];
    _syncStake(_user, _userInfo);
    _updateBoost(_user, _userInfo);
  }

  /**
    Updates user stake based on current user baseDebt
    @dev internal function to perform stake sync with VotingEscrow for both upgradability and relaseMIMO logic
    @param _user address of the user
  */
  function _syncStake(address _user, UserInfo memory _userInfo) internal {
    uint256 votingPower = _a.votingEscrow().balanceOf(_user);
    _totalStake = _totalStake.add(votingPower).sub(_userInfo.stake);
    _userInfo.stake = votingPower;
  }
}",655
RealWorld_TA_115_DistributorManager_RealWorld_20240815195337.log,115,DistributorManager,42944,4084,47028,119.0,0.2964,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IBaseDistributor.sol"";

contract DistributorManager {
  using SafeMath for uint256;

  IGovernanceAddressProvider public a;
  IBaseDistributor public mimmoDistributor;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(IGovernanceAddressProvider _a, IBaseDistributor _mimmoDistributor) public {
    require(address(_a) != address(0));
    require(address(_mimmoDistributor) != address(0));

    a = _a;
    mimmoDistributor = _mimmoDistributor;
  }

  /**
    Public function to release the accumulated new MIMO tokens to the payees.
    @dev anyone can call this.
  */
  function releaseAll() public {
    mimmoDistributor.release();
    address[] memory distributors = mimmoDistributor.getPayees();
    for (uint256 i = 0; i < distributors.length; i++) {
      IBaseDistributor(distributors[i]).release();
    }
  }
}",290
RealWorld_TA_115_ABDKMath64x64_RealWorld_20240815212613.log,115,ABDKMath64x64,738061,68,738129,152.0,3.691665,"// SPDX-License-Identifier: BSD-4-Clause
/*
 * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.
 * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>
 */
pragma solidity 0.6.12;

/**
 * Smart contract library of mathematical functions operating with signed
 * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is
 * basically a simple fraction whose numerator is signed 128-bit integer and
 * denominator is 2^64.  As long as denominator is always the same, there is no
 * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are
 * represented by int128 type holding only the numerator.
 */
library ABDKMath64x64 {
  /*
   * Minimum value signed 64.64-bit fixed point number may have.
   */
  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;

  /*
   * Maximum value signed 64.64-bit fixed point number may have.
   */
  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

  /**
   * Convert signed 256-bit integer number into signed 64.64-bit fixed point
   * number.  Revert on overflow.
   *
   * @param x signed 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function fromInt(int256 x) internal pure returns (int128) {
    require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);
    return int128(x << 64);
  }

  /**
   * Convert signed 64.64 fixed point number into signed 64-bit integer number
   * rounding down.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64-bit integer number
   */
  function toInt(int128 x) internal pure returns (int64) {
    return int64(x >> 64);
  }

  /**
   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point
   * number.  Revert on overflow.
   *
   * @param x unsigned 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function fromUInt(uint256 x) internal pure returns (int128) {
    require(x <= 0x7FFFFFFFFFFFFFFF);
    return int128(x << 64);
  }

  /**
   * Convert signed 64.64 fixed point number into unsigned 64-bit integer
   * number rounding down.  Revert on underflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return unsigned 64-bit integer number
   */
  function toUInt(int128 x) internal pure returns (uint64) {
    require(x >= 0);
    return uint64(x >> 64);
  }

  /**
   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point
   * number rounding down.  Revert on overflow.
   *
   * @param x signed 128.128-bin fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function from128x128(int256 x) internal pure returns (int128) {
    int256 result = x >> 64;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Convert signed 64.64 fixed point number into signed 128.128 fixed point
   * number.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 128.128 fixed point number
   */
  function to128x128(int128 x) internal pure returns (int256) {
    return int256(x) << 64;
  }

  /**
   * Calculate x + y.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function add(int128 x, int128 y) internal pure returns (int128) {
    int256 result = int256(x) + y;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x - y.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function sub(int128 x, int128 y) internal pure returns (int128) {
    int256 result = int256(x) - y;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x * y rounding down.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function mul(int128 x, int128 y) internal pure returns (int128) {
    int256 result = (int256(x) * y) >> 64;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point
   * number and y is signed 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64 fixed point number
   * @param y signed 256-bit integer number
   * @return signed 256-bit integer number
   */
  function muli(int128 x, int256 y) internal pure returns (int256) {
    if (x == MIN_64x64) {
      require(
        y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&
          y <= 0x1000000000000000000000000000000000000000000000000
      );
      return -y << 63;
    } else {
      bool negativeResult = false;
      if (x < 0) {
        x = -x;
        negativeResult = true;
      }
      if (y < 0) {
        y = -y; // We rely on overflow behavior here
        negativeResult = !negativeResult;
      }
      uint256 absoluteResult = mulu(x, uint256(y));
      if (negativeResult) {
        require(absoluteResult <= 0x8000000000000000000000000000000000000000000000000000000000000000);
        return -int256(absoluteResult); // We rely on overflow behavior here
      } else {
        require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
        return int256(absoluteResult);
      }
    }
  }

  /**
   * Calculate x * y rounding down, where x is signed 64.64 fixed point number
   * and y is unsigned 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64 fixed point number
   * @param y unsigned 256-bit integer number
   * @return unsigned 256-bit integer number
   */
  function mulu(int128 x, uint256 y) internal pure returns (uint256) {
    if (y == 0) return 0;

    require(x >= 0);

    uint256 lo = (uint256(x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;
    uint256 hi = uint256(x) * (y >> 128);

    require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
    hi <<= 64;

    require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);
    return hi + lo;
  }

  /**
   * Calculate x / y rounding towards zero.  Revert on overflow or when y is
   * zero.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function div(int128 x, int128 y) internal pure returns (int128) {
    require(y != 0);
    int256 result = (int256(x) << 64) / y;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are signed 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x signed 256-bit integer number
   * @param y signed 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function divi(int256 x, int256 y) internal pure returns (int128) {
    require(y != 0);

    bool negativeResult = false;
    if (x < 0) {
      x = -x; // We rely on overflow behavior here
      negativeResult = true;
    }
    if (y < 0) {
      y = -y; // We rely on overflow behavior here
      negativeResult = !negativeResult;
    }
    uint128 absoluteResult = divuu(uint256(x), uint256(y));
    if (negativeResult) {
      require(absoluteResult <= 0x80000000000000000000000000000000);
      return -int128(absoluteResult); // We rely on overflow behavior here
    } else {
      require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
      return int128(absoluteResult); // We rely on overflow behavior here
    }
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x unsigned 256-bit integer number
   * @param y unsigned 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function divu(uint256 x, uint256 y) internal pure returns (int128) {
    require(y != 0);
    uint128 result = divuu(x, y);
    require(result <= uint128(MAX_64x64));
    return int128(result);
  }

  /**
   * Calculate -x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function neg(int128 x) internal pure returns (int128) {
    require(x != MIN_64x64);
    return -x;
  }

  /**
   * Calculate |x|.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function abs(int128 x) internal pure returns (int128) {
    require(x != MIN_64x64);
    return x < 0 ? -x : x;
  }

  /**
   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is
   * zero.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function inv(int128 x) internal pure returns (int128) {
    require(x != 0);
    int256 result = int256(0x100000000000000000000000000000000) / x;
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function avg(int128 x, int128 y) internal pure returns (int128) {
    return int128((int256(x) + int256(y)) >> 1);
  }

  /**
   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.
   * Revert on overflow or in case x * y is negative.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function gavg(int128 x, int128 y) internal pure returns (int128) {
    int256 m = int256(x) * int256(y);
    require(m >= 0);
    require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);
    return int128(sqrtu(uint256(m)));
  }

  /**
   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number
   * and y is unsigned 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y uint256 value
   * @return signed 64.64-bit fixed point number
   */
  function pow(int128 x, uint256 y) internal pure returns (int128) {
    bool negative = x < 0 && y & 1 == 1;

    uint256 absX = uint128(x < 0 ? -x : x);
    uint256 absResult;
    absResult = 0x100000000000000000000000000000000;

    if (absX <= 0x10000000000000000) {
      absX <<= 63;
      while (y != 0) {
        if (y & 0x1 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        if (y & 0x2 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        if (y & 0x4 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        if (y & 0x8 != 0) {
          absResult = (absResult * absX) >> 127;
        }
        absX = (absX * absX) >> 127;

        y >>= 4;
      }

      absResult >>= 64;
    } else {
      uint256 absXShift = 63;
      if (absX < 0x1000000000000000000000000) {
        absX <<= 32;
        absXShift -= 32;
      }
      if (absX < 0x10000000000000000000000000000) {
        absX <<= 16;
        absXShift -= 16;
      }
      if (absX < 0x1000000000000000000000000000000) {
        absX <<= 8;
        absXShift -= 8;
      }
      if (absX < 0x10000000000000000000000000000000) {
        absX <<= 4;
        absXShift -= 4;
      }
      if (absX < 0x40000000000000000000000000000000) {
        absX <<= 2;
        absXShift -= 2;
      }
      if (absX < 0x80000000000000000000000000000000) {
        absX <<= 1;
        absXShift -= 1;
      }

      uint256 resultShift = 0;
      while (y != 0) {
        require(absXShift < 64);

        if (y & 0x1 != 0) {
          absResult = (absResult * absX) >> 127;
          resultShift += absXShift;
          if (absResult > 0x100000000000000000000000000000000) {
            absResult >>= 1;
            resultShift += 1;
          }
        }
        absX = (absX * absX) >> 127;
        absXShift <<= 1;
        if (absX >= 0x100000000000000000000000000000000) {
          absX >>= 1;
          absXShift += 1;
        }

        y >>= 1;
      }

      require(resultShift < 64);
      absResult >>= 64 - resultShift;
    }
    int256 result = negative ? -int256(absResult) : int256(absResult);
    require(result >= MIN_64x64 && result <= MAX_64x64);
    return int128(result);
  }

  /**
   * Calculate sqrt (x) rounding down.  Revert if x < 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function sqrt(int128 x) internal pure returns (int128) {
    require(x >= 0);
    return int128(sqrtu(uint256(x) << 64));
  }

  /**
   * Calculate binary logarithm of x.  Revert if x <= 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function log_2(int128 x) internal pure returns (int128) {
    require(x > 0);

    int256 msb = 0;
    int256 xc = x;
    if (xc >= 0x10000000000000000) {
      xc >>= 64;
      msb += 64;
    }
    if (xc >= 0x100000000) {
      xc >>= 32;
      msb += 32;
    }
    if (xc >= 0x10000) {
      xc >>= 16;
      msb += 16;
    }
    if (xc >= 0x100) {
      xc >>= 8;
      msb += 8;
    }
    if (xc >= 0x10) {
      xc >>= 4;
      msb += 4;
    }
    if (xc >= 0x4) {
      xc >>= 2;
      msb += 2;
    }
    if (xc >= 0x2) msb += 1; // No need to shift xc anymore

    int256 result = (msb - 64) << 64;
    uint256 ux = uint256(x) << uint256(127 - msb);
    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {
      ux *= ux;
      uint256 b = ux >> 255;
      ux >>= 127 + b;
      result += bit * int256(b);
    }

    return int128(result);
  }

  /**
   * Calculate natural logarithm of x.  Revert if x <= 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function ln(int128 x) internal pure returns (int128) {
    require(x > 0);

    return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128);
  }

  /**
   * Calculate binary exponent of x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function exp_2(int128 x) internal pure returns (int128) {
    require(x < 0x400000000000000000); // Overflow

    if (x < -0x400000000000000000) return 0; // Underflow

    uint256 result = 0x80000000000000000000000000000000;

    if (x & 0x8000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;
    if (x & 0x4000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;
    if (x & 0x2000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;
    if (x & 0x1000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;
    if (x & 0x800000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;
    if (x & 0x400000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;
    if (x & 0x200000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;
    if (x & 0x100000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;
    if (x & 0x80000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;
    if (x & 0x40000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;
    if (x & 0x20000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;
    if (x & 0x10000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;
    if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;
    if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;
    if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;
    if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;
    if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;
    if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;
    if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;
    if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;
    if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;
    if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;
    if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;
    if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;
    if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;
    if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;
    if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;
    if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;
    if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;
    if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;
    if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;
    if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;
    if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;
    if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;
    if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;
    if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;
    if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;
    if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;
    if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;
    if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;
    if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;
    if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;
    if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;
    if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;
    if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;
    if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;
    if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;
    if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;
    if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;
    if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;
    if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;
    if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;
    if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;
    if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;
    if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;
    if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;
    if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;
    if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;
    if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;
    if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;
    if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;
    if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;
    if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;
    if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;

    result >>= uint256(63 - (x >> 64));
    require(result <= uint256(MAX_64x64));

    return int128(result);
  }

  /**
   * Calculate natural exponent of x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function exp(int128 x) internal pure returns (int128) {
    require(x < 0x400000000000000000); // Overflow

    if (x < -0x400000000000000000) return 0; // Underflow

    return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x unsigned 256-bit integer number
   * @param y unsigned 256-bit integer number
   * @return unsigned 64.64-bit fixed point number
   */
  function divuu(uint256 x, uint256 y) private pure returns (uint128) {
    require(y != 0);

    uint256 result;

    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;
    else {
      uint256 msb = 192;
      uint256 xc = x >> 192;
      if (xc >= 0x100000000) {
        xc >>= 32;
        msb += 32;
      }
      if (xc >= 0x10000) {
        xc >>= 16;
        msb += 16;
      }
      if (xc >= 0x100) {
        xc >>= 8;
        msb += 8;
      }
      if (xc >= 0x10) {
        xc >>= 4;
        msb += 4;
      }
      if (xc >= 0x4) {
        xc >>= 2;
        msb += 2;
      }
      if (xc >= 0x2) msb += 1; // No need to shift xc anymore

      result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);
      require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

      uint256 hi = result * (y >> 128);
      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

      uint256 xh = x >> 192;
      uint256 xl = x << 64;

      if (xl < lo) xh -= 1;
      xl -= lo; // We rely on overflow behavior here
      lo = hi << 128;
      if (xl < lo) xh -= 1;
      xl -= lo; // We rely on overflow behavior here

      assert(xh == hi >> 128);

      result += xl / y;
    }

    require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
    return uint128(result);
  }

  /**
   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer
   * number.
   *
   * @param x unsigned 256-bit integer number
   * @return unsigned 128-bit integer number
   */
  function sqrtu(uint256 x) private pure returns (uint128) {
    if (x == 0) return 0;
    else {
      uint256 xx = x;
      uint256 r = 1;
      if (xx >= 0x100000000000000000000000000000000) {
        xx >>= 128;
        r <<= 64;
      }
      if (xx >= 0x10000000000000000) {
        xx >>= 64;
        r <<= 32;
      }
      if (xx >= 0x100000000) {
        xx >>= 32;
        r <<= 16;
      }
      if (xx >= 0x10000) {
        xx >>= 16;
        r <<= 8;
      }
      if (xx >= 0x100) {
        xx >>= 8;
        r <<= 4;
      }
      if (xx >= 0x10) {
        xx >>= 4;
        r <<= 2;
      }
      if (xx >= 0x8) {
        r <<= 1;
      }
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1;
      r = (r + x / r) >> 1; // Seven iterations should be enough
      uint256 r1 = x / r;
      return uint128(r < r1 ? r : r1);
    }
  }
}",8578
RealWorld_TA_115_TInceptionVaultUnhealthyAssertion_RealWorld_20240815224200.log,115,TInceptionVaultUnhealthyAssertion,95229,4624,99853,136.0,0.568625,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""./TIVSetup.sol"";

contract TInceptionVaultUnhealthy is TIVSetup {
  IInceptionVaultsCore internal _inceptionVaultsCore;
  IInceptionVaultsDataProvider internal _inceptionVaultsDataProvider;
  IAdminInceptionVault internal _adminInceptionVault;
  IInceptionVaultPriceFeed internal _inceptionVaultPriceFeed;

  event AssertionFailed(uint256);
  event vaultConfig(uint256, uint256, uint256);

  uint256 internal _adminDepositAmount = 10000000000000000000;
  uint256 internal _adminBorrowAmount = 11000000000000000000000;
  uint256 internal _userDepositAmount = 1000000000000000000000;
  uint256 internal _userBorrowAmount = 7000000000000000000000;

  uint256 internal constant _TEST_VAULT_ID = 1;

  bool internal _exist;

  constructor() public TIVSetup() {
    IInceptionVaultFactory.InceptionVault memory iv = _inceptionVaultFactory.inceptionVaults(_TEST_VAULT_ID);
    IAdminInceptionVault a = iv.adminInceptionVault;
    IInceptionVaultsCore v = iv.inceptionVaultsCore;
    IInceptionVaultsDataProvider d = iv.inceptionVaultsDataProvider;
    IInceptionVaultPriceFeed p = iv.inceptionVaultPriceFeed;

    _inceptionVaultsCore = v;
    _inceptionVaultsDataProvider = d;
    _inceptionVaultPriceFeed = p;
    _weth.mint(_echidna_caller, _adminDepositAmount);
    _weth.approve(address(a), _adminDepositAmount);

    // Deposit 10 WETH and borrow 11k PAR
    a.depositAndBorrow(address(_weth), _adminDepositAmount, _adminBorrowAmount);

    _link.mint(_echidna_caller, _userDepositAmount);
    _link.approve(address(v), _userDepositAmount);

    // Deposit 1000k LINK and borrow 7k PAR
    v.depositAndBorrow(_userDepositAmount, _userBorrowAmount);

    // Update LINK price to $8 to make vault unhealthy
    _linkAggregator.setLatestPrice(800000000);

    // Approve PAR for liquidation
    _par.approve(address(_inceptionVaultsCore), _MAX_INT);
  }

  /**
  @notice Checks that calling liquidatePartial() on unhealthy vault never reverts
  @param amount Liquidation amount
   */
  function unhealthy_vault_should_always_be_open_to_liquidation(uint256 amount) public {
    uint256 vaultDebt = _inceptionVaultsDataProvider.vaultBaseDebt(_TEST_VAULT_ID);
    if (vaultDebt > 0) {
      try _inceptionVaultsCore.liquidatePartial(_TEST_VAULT_ID, amount)  {} catch {
        assert(false);
      }
    }
  }

  /**
  @notice Checks that calling borrow() on unheathy vault always reverts
  @param amount Borrow amount
   */
  function user_should_never_be_able_to_borrow_from_unhealthy_vault(uint256 amount) public {
    uint256 vaultDebt = _inceptionVaultsDataProvider.vaultBaseDebt(_TEST_VAULT_ID);
    if (vaultDebt > 0) {
      try _inceptionVaultsCore.borrow(_TEST_VAULT_ID, amount)  {
        assert(false);
      } catch {}
    }
  }

  /**
  @notice Checks that calling withdraw() on unhealthy vault always reverts
  @param amount Withdraw amount
   */
  function user_should_never_be_able_to_withdraw_from_unhealthy_vault(uint256 amount) public {
    uint256 vaultDebt = _inceptionVaultsDataProvider.vaultBaseDebt(_TEST_VAULT_ID);
    if (vaultDebt > 0) {
      try _inceptionVaultsCore.withdraw(_TEST_VAULT_ID, amount)  {
        assert(false);
      } catch {}
    }
  }
}",893
RealWorld_TA_115_TInceptionVaultUnhealthyProperty_RealWorld_20240815224908.log,115,TInceptionVaultUnhealthyProperty,89511,4522,94033,134.0,0.537995,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""./TIVSetup.sol"";

contract TInceptionVaultUnhealthy is TIVSetup {
  IInceptionVaultsCore internal _inceptionVaultsCore;
  IInceptionVaultsDataProvider internal _inceptionVaultsDataProvider;
  IAdminInceptionVault internal _adminInceptionVault;
  IInceptionVaultPriceFeed internal _inceptionVaultPriceFeed;

  event AssertionFailed(uint256);

  uint256 internal _adminDepositAmount = 10000000000000000000;
  uint256 internal _adminBorrowAmount = 11000000000000000000000;
  uint256 internal _userDepositAmount = 1000000000000000000000;
  uint256 internal _userBorrowAmount = 7000000000000000000000;

  uint256 internal constant _TEST_VAULT_ID = 1;

  bool internal _exist;

  constructor() public TIVSetup() {
    IInceptionVaultFactory.InceptionVault memory iv = _inceptionVaultFactory.inceptionVaults(_TEST_VAULT_ID);
    IAdminInceptionVault a = iv.adminInceptionVault;
    IInceptionVaultsCore v = iv.inceptionVaultsCore;
    IInceptionVaultsDataProvider d = iv.inceptionVaultsDataProvider;
    IInceptionVaultPriceFeed p = iv.inceptionVaultPriceFeed;

    _inceptionVaultsCore = v;
    _inceptionVaultsDataProvider = d;
    _inceptionVaultPriceFeed = p;
    _weth.mint(_echidna_caller, _adminDepositAmount);
    _weth.approve(address(a), _adminDepositAmount);

    // Deposit 10 WETH and borrow 11k PAR
    a.depositAndBorrow(address(_weth), _adminDepositAmount, _adminBorrowAmount);

    _link.mint(_echidna_caller, _userDepositAmount);
    _link.approve(address(v), _userDepositAmount);

    // Deposit 1000k LINK and borrow 7k PAR
    v.depositAndBorrow(_userDepositAmount, _userBorrowAmount);

    // Update LINK price to $8 to make vault unhealthy
    _linkAggregator.setLatestPrice(800000000);

    // Approve PAR for liquidation
    _par.approve(address(_inceptionVaultsCore), _MAX_INT);
  }

  /// @notice Chekcs that calling liquidate() on unhealthy vault never reverts
  function echidna_unhealthy_vault_should_always_be_open_to_liquidation() public returns (bool) {
    require(_inceptionVaultsDataProvider.vaultDebt(1) > 0);
    try _inceptionVaultsCore.liquidate(_TEST_VAULT_ID)  {
      return true;
      // return true;
    } catch {
      return false;
    }
  }

  /// @notice Checks that calling borrow() on unhealthy vault always reverts
  function echidna_user_should_never_be_able_to_borrow_from_unhealthy_vault() public returns (bool) {
    require(_inceptionVaultsDataProvider.vaultDebt(1) > 0);
    try _inceptionVaultsCore.borrow(1, 1)  {
      return false;
    } catch {
      return true;
    }
  }

  /// @notice Checks that calling withdraw() on unhealthy vault always reverts
  function echidna_user_should_never_be_able_to_withdraw_from_unhealthy_vault() public returns (bool) {
    require(_inceptionVaultsDataProvider.vaultDebt(1) > 0);
    try _inceptionVaultsCore.withdraw(_TEST_VAULT_ID, 1)  {
      return false;
    } catch {
      return true;
    }
  }
}",822
RealWorld_TA_115_IBaseDistributor_RealWorld_20240815202114.log,115,IBaseDistributor,40307,1838,42145,104.0,0.238295,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";

interface IBaseDistributor {
  event PayeeAdded(address account, uint256 shares);
  event TokensReleased(uint256 newTokens, uint256 releasedAt);

  /**
    Public function to release the accumulated new MIMO tokens to the payees.
    @dev anyone can call this.
  */
  function release() external;

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) external;

  function totalShares() external view returns (uint256);

  function shares(address) external view returns (uint256);

  function a() external view returns (IGovernanceAddressProvider);

  function mintableTokens() external view returns (uint256);

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() external view returns (address[] memory);
}",261
RealWorld_TA_115_IRatesManager_RealWorld_20240815223609.log,115,IRatesManager,36117,1726,37843,94.0,0.215105,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface IRatesManager {
  function a() external view returns (IAddressProvider);

  //current annualized borrow rate
  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);

  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0
  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);

  //uses current cumulative rate to calculate baseDebt at time T0
  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);

  //calculate a new cumulative rate
  function calculateCumulativeRate(
    uint256 _borrowRate,
    uint256 _cumulativeRate,
    uint256 _timeElapsed
  ) external view returns (uint256);
}",215
RealWorld_TA_115_IMerkleDistributor_RealWorld_20240815221945.log,115,IMerkleDistributor,39515,1578,41093,90.0,0.229135,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

// Allows anyone to claim a token if they exist in a merkle root.
interface IMerkleDistributor {
  // This event is triggered whenever a call to #claim succeeds.
  event Claimed(uint256 index, address account, uint256 amount);

  // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.
  function claim(
    uint256 index,
    address account,
    uint256 amount,
    bytes32[] calldata merkleProof
  ) external;

  // Returns the address of the token distributed by this contract.
  function token() external view returns (address);

  // Returns the merkle root of the merkle tree containing account balances available to claim.
  function merkleRoot() external view returns (bytes32);

  // Returns true if the index has been marked claimed.
  function isClaimed(uint256 index) external view returns (bool);

  // Returns the block timestamp when claims will end
  function endTime() external view returns (uint256);

  // Returns true if the claim period has not ended.
  function isActive() external view returns (bool);
}",249
RealWorld_TA_115_MockBPT_RealWorld_20240815183734.log,115,MockBPT,24379,2008,26387,91.0,0.162055,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockBPT is ERC20(""Balancer Pool Token"", ""BPT"") {
  function mint(address account, uint256 amount) public {
    _mint(account, amount);
  }
}",71
RealWorld_TA_115_IInceptionVaultsCore_RealWorld_20240815211918.log,115,IInceptionVaultsCore,69439,3292,72731,117.0,0.413035,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""./IInceptionVaultsDataProvider.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""./IAdminInceptionVault.sol"";
import ""./IInceptionVaultPriceFeed.sol"";

interface IInceptionVaultsCore {
  struct VaultConfig {
    uint256 liquidationRatio;
    uint256 minCollateralRatio;
    uint256 borrowRate;
    uint256 originationFee;
    uint256 liquidationBonus;
    uint256 liquidationFee;
  }

  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);

  event Withdrawn(uint256 indexed vautlId, uint256 amount, address indexed sender);

  event CumulativeRateUpdated(uint256 elapsedTime, uint256 newCumulativeRate);

  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);

  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);

  event Liquidated(
    uint256 indexed vaultId,
    uint256 debtRepaid,
    uint256 collateralLiquidated,
    address indexed owner,
    address indexed sender
  );

  function initialize(
    address _owner,
    VaultConfig calldata vaultConfig,
    IERC20 _inceptionCollateral,
    IAddressProvider _addressProvider,
    IAdminInceptionVault _adminInceptionVault,
    IInceptionVaultsDataProvider _inceptionVaultsDataProvider,
    IInceptionVaultPriceFeed _inceptionPriceFeed
  ) external;

  function deposit(uint256 _amount) external;

  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;

  function depositAndBorrow(uint256 _depositAmount, uint256 _borrowAmount) external;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function repayAll(uint256 _vaultId) external;

  function repay(uint256 _vaultId, uint256 _amount) external;

  function liquidate(uint256 _vaultId) external;

  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;

  // Read only
  function a() external view returns (IAddressProvider);

  function cumulativeRate() external view returns (uint256);

  function lastRefresh() external view returns (uint256);

  function vaultConfig() external view returns (VaultConfig memory);

  function adminInceptionVault() external view returns (IAdminInceptionVault);

  function inceptionVaultsData() external view returns (IInceptionVaultsDataProvider);

  function inceptionCollateral() external view returns (IERC20);

  function inceptionPriceFeed() external view returns (IInceptionVaultPriceFeed);
}",603
RealWorld_TA_115_IGUniPool_RealWorld_20240815221400.log,115,IGUniPool,25083,1606,26689,96.0,0.157535,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IGUniPool {
  function token0() external view returns (address);

  function token1() external view returns (address);

  function totalSupply() external view returns (uint256);

  function getUnderlyingBalancesAtPrice(uint160) external view returns (uint256, uint256);
}",78
RealWorld_TA_115_ISupplyMiner_RealWorld_20240815201529.log,115,ISupplyMiner,22309,1735,24044,131.0,0.146245,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

interface ISupplyMiner {
  function baseDebtChanged(address user, uint256 newBaseDebt) external;
}",49
RealWorld_TA_115_GovernorAlpha_RealWorld_20240815215239.log,115,GovernorAlpha,206020,5420,211440,156.0,1.1385,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IGovernorAlpha.sol"";
import ""./interfaces/IGovernanceAddressProvider.sol"";
import ""../libraries/WadRayMath.sol"";

contract GovernorAlpha is IGovernorAlpha {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  /// @notice The maximum number of actions that can be included in a proposal
  function proposalMaxOperations() public pure returns (uint256) {
    return 10;
  } // 10 actions

  IGovernanceAddressProvider public a;

  /// @notice The address of the Governor Guardian
  address public guardian;

  /// @notice The total number of proposals
  uint256 public proposalCount;

  /// @notice The official record of all proposals ever proposed
  mapping(uint256 => Proposal) public proposals;

  /// @notice The latest proposal for each proposer
  mapping(address => uint256) public latestProposalIds;

  constructor(IGovernanceAddressProvider _addresses, address _guardian) public {
    require(address(_addresses) != address(0));
    require(address(_guardian) != address(0));

    a = _addresses;
    guardian = _guardian;
  }

  function propose(
    address[] memory targets,
    uint256[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description,
    uint256 endTime
  ) public override returns (uint256) {
    uint256 votingDuration = endTime.sub(block.timestamp);
    require(votingDuration >= a.parallel().config().minVotingPeriod(), ""Proposal end-time too early"");
    require(votingDuration <= a.parallel().config().maxVotingPeriod(), ""Proposal end-time too late"");

    require(
      a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),
      ""GovernorAlpha::propose: proposer votes below proposal threshold""
    );
    require(
      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,
      ""GovernorAlpha::propose: proposal function information arity mismatch""
    );
    require(targets.length != 0, ""GovernorAlpha::propose: must provide actions"");
    require(targets.length <= proposalMaxOperations(), ""GovernorAlpha::propose: too many actions"");

    uint256 latestProposalId = latestProposalIds[msg.sender];
    if (latestProposalId != 0) {
      ProposalState proposersLatestProposalState = state(latestProposalId);
      require(
        proposersLatestProposalState != ProposalState.Active,
        ""GovernorAlpha::propose: one live proposal per proposer, found an already active proposal""
      );
    }

    proposalCount++;
    Proposal memory newProposal = Proposal({
      id: proposalCount,
      proposer: msg.sender,
      eta: 0,
      targets: targets,
      values: values,
      signatures: signatures,
      calldatas: calldatas,
      startTime: block.timestamp,
      endTime: endTime,
      forVotes: 0,
      againstVotes: 0,
      canceled: false,
      executed: false
    });

    proposals[newProposal.id] = newProposal;
    latestProposalIds[newProposal.proposer] = newProposal.id;

    emit ProposalCreated(
      newProposal.id,
      msg.sender,
      targets,
      values,
      signatures,
      calldatas,
      block.timestamp,
      endTime,
      description
    );
    return newProposal.id;
  }

  function queue(uint256 proposalId) public override {
    require(
      state(proposalId) == ProposalState.Succeeded,
      ""GovernorAlpha::queue: proposal can only be queued if it is succeeded""
    );
    Proposal storage proposal = proposals[proposalId];
    uint256 eta = block.timestamp.add(a.timelock().delay());
    for (uint256 i = 0; i < proposal.targets.length; i++) {
      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);
    }
    proposal.eta = eta;
    emit ProposalQueued(proposalId, eta);
  }

  function execute(uint256 proposalId) public payable override {
    require(
      state(proposalId) == ProposalState.Queued,
      ""GovernorAlpha::execute: proposal can only be executed if it is queued""
    );
    Proposal storage proposal = proposals[proposalId];
    proposal.executed = true;
    for (uint256 i = 0; i < proposal.targets.length; i++) {
      a.timelock().executeTransaction{ value: proposal.values[i] }(
        proposal.targets[i],
        proposal.values[i],
        proposal.signatures[i],
        proposal.calldatas[i],
        proposal.eta
      );
    }
    emit ProposalExecuted(proposalId);
  }

  function cancel(uint256 proposalId) public override {
    ProposalState state = state(proposalId);
    require(state != ProposalState.Executed, ""GovernorAlpha::cancel: cannot cancel executed proposal"");

    Proposal storage proposal = proposals[proposalId];
    require(msg.sender == guardian, ""Only Guardian can cancel"");

    proposal.canceled = true;
    for (uint256 i = 0; i < proposal.targets.length; i++) {
      a.timelock().cancelTransaction(
        proposal.targets[i],
        proposal.values[i],
        proposal.signatures[i],
        proposal.calldatas[i],
        proposal.eta
      );
    }

    emit ProposalCanceled(proposalId);
  }

  function castVote(uint256 proposalId, bool support) public override {
    require(state(proposalId) == ProposalState.Active, ""GovernorAlpha::_castVote: voting is closed"");
    Proposal storage proposal = proposals[proposalId];
    Receipt storage receipt = proposal.receipts[msg.sender];
    require(receipt.hasVoted == false, ""GovernorAlpha::_castVote: voter already voted"");
    uint256 votes = a.votingEscrow().balanceOfAt(msg.sender, proposal.endTime);

    if (support) {
      proposal.forVotes = proposal.forVotes.add(votes);
    } else {
      proposal.againstVotes = proposal.againstVotes.add(votes);
    }

    receipt.hasVoted = true;
    receipt.support = support;
    receipt.votes = votes;

    emit VoteCast(msg.sender, proposalId, support, votes);
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __acceptAdmin() public {
    require(msg.sender == guardian, ""GovernorAlpha::__acceptAdmin: sender must be gov guardian"");
    a.timelock().acceptAdmin();
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __abdicate() public {
    require(msg.sender == guardian, ""GovernorAlpha::__abdicate: sender must be gov guardian"");
    guardian = address(0);
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {
    require(msg.sender == guardian, ""GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian"");
    a.timelock().queueTransaction(
      address(a.timelock()),
      0,
      ""setPendingAdmin(address)"",
      abi.encode(newPendingAdmin),
      eta
    );
  }

  // solhint-disable-next-line private-vars-leading-underscore
  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {
    require(msg.sender == guardian, ""GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian"");
    a.timelock().executeTransaction(
      address(a.timelock()),
      0,
      ""setPendingAdmin(address)"",
      abi.encode(newPendingAdmin),
      eta
    );
  }

  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed
  function quorumVotes() public view override returns (uint256) {
    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().votingQuorum());
  }

  /// @notice The number of votes required in order for a voter to become a proposer
  function proposalThreshold() public view override returns (uint256) {
    return a.votingEscrow().stakingToken().totalSupply().wadMul(a.parallel().config().proposalThreshold());
  }

  function getActions(uint256 proposalId)
    public
    view
    override
    returns (
      address[] memory targets,
      uint256[] memory values,
      string[] memory signatures,
      bytes[] memory calldatas
    )
  {
    Proposal storage p = proposals[proposalId];
    return (p.targets, p.values, p.signatures, p.calldatas);
  }

  function getReceipt(uint256 proposalId, address voter) public view override returns (Receipt memory) {
    return proposals[proposalId].receipts[voter];
  }

  function state(uint256 proposalId) public view override returns (ProposalState) {
    require(proposalCount >= proposalId && proposalId > 0, ""GovernorAlpha::state: invalid proposal id"");
    Proposal storage proposal = proposals[proposalId];
    if (proposal.canceled) {
      return ProposalState.Canceled;
    } else if (block.timestamp <= proposal.endTime) {
      return ProposalState.Active;
    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {
      return ProposalState.Defeated;
    } else if (proposal.eta == 0) {
      return ProposalState.Succeeded;
    } else if (proposal.executed) {
      return ProposalState.Executed;
    } else if (block.timestamp >= a.timelock().GRACE_PERIOD().add(proposal.endTime)) {
      return ProposalState.Expired;
    } else {
      return ProposalState.Queued;
    }
  }

  function _queueOrRevert(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  ) internal {
    require(
      !a.timelock().queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),
      ""GovernorAlpha::_queueOrRevert: proposal action already queued at eta""
    );
    a.timelock().queueTransaction(target, value, signature, data, eta);
  }
}",2229
RealWorld_TA_115_IDemandMinerV2_RealWorld_20240815200733.log,115,IDemandMinerV2,33567,2495,36062,100.0,0.217735,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IDemandMinerV2 {
  event FeeCollectorSet(address feeCollector);

  event FeeConfigSet(FeeConfig);

  event DepositFeeReleased(uint256 income);

  event WithdrawFeeReleased(uint256 income);

  struct FeeConfig {
    uint256 depositFee;
    uint256 withdrawFee;
  }

  function setFeeCollector(address feeCollector) external;

  function setFeeConfig(FeeConfig memory newFeeConfig) external;

  function deposit(uint256 amount) external;

  function withdraw(uint256 amount) external;

  function token() external view returns (IERC20);

  function feeCollector() external view returns (address);

  function feeConfig() external view returns (FeeConfig memory);
}",185
RealWorld_TA_115_Upgrade_RealWorld_20240815203319.log,115,Upgrade,116897,4741,121638,134.0,0.679305,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../v1/interfaces/IConfigProviderV1.sol"";
import ""../v1/interfaces/IVaultsCoreV1.sol"";
import ""../v1/interfaces/IFeeDistributorV1.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IVaultsCoreState.sol"";
import ""../interfaces/ILiquidationManager.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/IFeeDistributor.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";

contract Upgrade {
  using SafeMath for uint256;

  uint256 public constant LIQUIDATION_BONUS = 5e16; // 5%

  IAddressProvider public a;
  IVaultsCore public core;
  IVaultsCoreState public coreState;
  ILiquidationManager public liquidationManager;
  IConfigProvider public config;
  IFeeDistributor public feeDistributor;
  IDebtNotifier public debtNotifier;
  IPriceFeed public priceFeed;
  address public bpool;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));
    _;
  }

  constructor(
    IAddressProvider _addresses,
    IVaultsCore _core,
    IVaultsCoreState _coreState,
    ILiquidationManager _liquidationManager,
    IConfigProvider _config,
    IFeeDistributor _feeDistributor,
    IDebtNotifier _debtNotifier,
    IPriceFeed _priceFeed,
    address _bpool
  ) public {
    require(address(_addresses) != address(0));
    require(address(_core) != address(0));
    require(address(_coreState) != address(0));
    require(address(_liquidationManager) != address(0));
    require(address(_config) != address(0));
    require(address(_feeDistributor) != address(0));
    require(address(_debtNotifier) != address(0));
    require(address(_priceFeed) != address(0));
    require(_bpool != address(0));

    a = _addresses;
    core = _core;
    coreState = _coreState;
    liquidationManager = _liquidationManager;
    config = _config;
    feeDistributor = _feeDistributor;
    debtNotifier = _debtNotifier;
    priceFeed = _priceFeed;
    bpool = _bpool;
  }

  function upgrade() public onlyManager {
    IConfigProviderV1 oldConfig = IConfigProviderV1(address(a.config()));
    IPriceFeed oldPriceFeed = IPriceFeed(address(a.priceFeed()));
    IVaultsCoreV1 oldCore = IVaultsCoreV1(address(a.core()));
    IFeeDistributorV1 oldFeeDistributor = IFeeDistributorV1(address(a.feeDistributor()));

    bytes32 MINTER_ROLE = a.controller().MINTER_ROLE();
    bytes32 MANAGER_ROLE = a.controller().MANAGER_ROLE();
    bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;
    a.controller().grantRole(MANAGER_ROLE, address(this));
    a.controller().grantRole(MINTER_ROLE, address(core));
    a.controller().grantRole(MINTER_ROLE, address(feeDistributor));

    oldCore.refresh();
    if (oldCore.availableIncome() > 0) {
      oldFeeDistributor.release();
    }

    a.controller().revokeRole(MINTER_ROLE, address(a.core()));
    a.controller().revokeRole(MINTER_ROLE, address(a.feeDistributor()));

    oldCore.upgrade(payable(address(core)));

    a.setVaultsCore(core);
    a.setConfigProvider(config);
    a.setLiquidationManager(liquidationManager);
    a.setFeeDistributor(feeDistributor);
    a.setPriceFeed(priceFeed);

    priceFeed.setEurOracle(address(oldPriceFeed.eurOracle()));

    uint256 numCollateralConfigs = oldConfig.numCollateralConfigs();
    for (uint256 i = 1; i <= numCollateralConfigs; i++) {
      IConfigProviderV1.CollateralConfig memory collateralConfig = oldConfig.collateralConfigs(i);

      config.setCollateralConfig(
        collateralConfig.collateralType,
        collateralConfig.debtLimit,
        collateralConfig.minCollateralRatio,
        collateralConfig.minCollateralRatio,
        collateralConfig.borrowRate,
        collateralConfig.originationFee,
        LIQUIDATION_BONUS,
        0
      );

      priceFeed.setAssetOracle(
        collateralConfig.collateralType,
        address(oldPriceFeed.assetOracles(collateralConfig.collateralType))
      );
    }

    coreState.syncStateFromV1(oldCore);
    core.acceptUpgrade(payable(address(oldCore)));
    core.setDebtNotifier(debtNotifier);
    debtNotifier.a().setDebtNotifier(debtNotifier);

    address[] memory payees = new address[](2);
    payees[0] = bpool;
    payees[1] = address(core);
    uint256[] memory shares = new uint256[](2);
    shares[0] = uint256(90);
    shares[1] = uint256(10);
    feeDistributor.changePayees(payees, shares);

    a.controller().revokeRole(MANAGER_ROLE, address(this));
    a.controller().revokeRole(DEFAULT_ADMIN_ROLE, address(this));
  }
}",1176
RealWorld_TA_115_ConfigProviderV1_RealWorld_20240815185421.log,115,ConfigProviderV1,179132,3575,182707,136.0,0.96716,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../libraries/WadRayMath.sol"";
import ""./interfaces/IConfigProviderV1.sol"";
import ""./interfaces/IAddressProviderV1.sol"";
import ""./interfaces/IVaultsCoreV1.sol"";

contract ConfigProviderV1 is IConfigProviderV1 {
  IAddressProviderV1 public override a;

  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1
  mapping(address => uint256) public override collateralIds;

  uint256 public override numCollateralConfigs;
  uint256 public override liquidationBonus = 5e16; // 5%

  constructor(IAddressProviderV1 _addresses) public {
    a = _addresses;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
    Creates or overwrites an existing config for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the debt ceiling for the collateral type
    @param _minCollateralRatio the minimum ratio to maintain to avoid liquidation
    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.
    @param _originationFee an optional origination fee for newly created debt. Can be 0.
  */
  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee
  ) public override onlyManager {
    require(address(_collateralType) != address(0));
    if (collateralIds[_collateralType] == 0) {
      //new collateral
      IVaultsCoreV1(address(a.core())).initializeRates(_collateralType);
      CollateralConfig memory config = CollateralConfig({
        collateralType: _collateralType,
        debtLimit: _debtLimit,
        minCollateralRatio: _minCollateralRatio,
        borrowRate: _borrowRate,
        originationFee: _originationFee
      });

      numCollateralConfigs++;
      _collateralConfigs[numCollateralConfigs] = config;
      collateralIds[_collateralType] = numCollateralConfigs;
    } else {
      // Update collateral config
      IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);
      uint256 id = collateralIds[_collateralType];

      _collateralConfigs[id].collateralType = _collateralType;
      _collateralConfigs[id].debtLimit = _debtLimit;
      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;
      _collateralConfigs[id].borrowRate = _borrowRate;
      _collateralConfigs[id].originationFee = _originationFee;
    }
    emit CollateralUpdated(_collateralType, _debtLimit, _minCollateralRatio, _borrowRate, _originationFee);
  }

  function _emitUpdateEvent(address _collateralType) internal {
    emit CollateralUpdated(
      _collateralType,
      _collateralConfigs[collateralIds[_collateralType]].debtLimit,
      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,
      _collateralConfigs[collateralIds[_collateralType]].borrowRate,
      _collateralConfigs[collateralIds[_collateralType]].originationFee
    );
  }

  /**
    Remove the config for a collateral type
    @param _collateralType address of the collateral type
  */
  function removeCollateral(address _collateralType) public override onlyManager {
    uint256 id = collateralIds[_collateralType];
    require(id != 0, ""collateral does not exist"");

    collateralIds[_collateralType] = 0;

    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward
    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry
    delete _collateralConfigs[numCollateralConfigs];
    numCollateralConfigs--;

    emit CollateralRemoved(_collateralType);
  }

  /**
    Sets the debt limit for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the new debt limit
  */
  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the minimum collateralization ratio for a collateral type
    @dev this is the liquidation treshold under which a vault is considered open for liquidation.
    @param _collateralType address of the collateral type
    @param _minCollateralRatio the new minimum collateralization ratio
  */
  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)
    public
    override
    onlyManager
  {
    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
    @param _borrowRate the new borrowing rate for a 1 sec interval
  */
  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {
    IVaultsCoreV1(address(a.core())).refreshCollateral(_collateralType);
    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
    @param _originationFee new origination fee in WAD
  */
  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Get the debt limit for a collateral type
    @dev this is a platform wide limit for new debt issuance against a specific collateral type
    @param _collateralType address of the collateral type
  */
  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;
  }

  /**
    Get the minimum collateralization ratio for a collateral type
    @dev this is the liquidation treshold under which a vault is considered open for liquidation.
    @param _collateralType address of the collateral type
  */
  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;
  }

  /**
    Get the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
  */
  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;
  }

  /**
    Get the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].originationFee;
  }

  /**
    Set the platform wide incentive for liquidations.
    @dev the liquidation bonus is specified in WAD
    @param _bonus the liquidation bonus to be paid to liquidators
  */
  function setLiquidationBonus(uint256 _bonus) public override onlyManager {
    liquidationBonus = _bonus;
  }

  /**
    Retreives the entire config for a specific config id.
    @param _id the ID of the conifg to be returned
  */
  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {
    require(_id <= numCollateralConfigs, ""Invalid config id"");
    return _collateralConfigs[_id];
  }
}",1938
RealWorld_TA_115_MockMIMO_RealWorld_20240815182937.log,115,MockMIMO,24534,2645,27179,101.0,0.17557,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockMIMO is ERC20(""MIMO Token"", ""MIMO"") {
  function mint(address account, uint256 amount) public {
    _mint(account, amount);
  }
}",71
RealWorld_TA_115_IPriceFeed_RealWorld_20240815222603.log,115,IPriceFeed,35201,2130,37331,104.0,0.218605,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IAddressProvider.sol"";

interface IPriceFeed {
  event OracleUpdated(address indexed asset, address oracle, address sender);
  event EurOracleUpdated(address oracle, address sender);

  function setAssetOracle(address _asset, address _oracle) external;

  function setEurOracle(address _oracle) external;

  function a() external view returns (IAddressProvider);

  function assetOracles(address _asset) external view returns (AggregatorV3Interface);

  function eurOracle() external view returns (AggregatorV3Interface);

  function getAssetPrice(address _asset) external view returns (uint256);

  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);

  function convertTo(address _asset, uint256 _amount) external view returns (uint256);
}",197
RealWorld_TA_115_MockChainlinkAggregator_RealWorld_20240815184239.log,115,MockChainlinkAggregator,103066,3659,106725,121.0,0.58851,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../chainlink/AggregatorV3Interface.sol"";

contract MockChainlinkAggregator is AggregatorV3Interface {
  uint256 private _latestPrice;
  uint256 private _updatedAt;
  string public override description;
  uint256 public override version = 3;

  uint8 public override decimals;

  constructor(
    uint8 _decimals,
    uint256 _price,
    string memory _description
  ) public {
    decimals = _decimals;
    _latestPrice = _price;
    description = _description;
    _updatedAt = now;
  }

  function setLatestPrice(uint256 price) public {
    _latestPrice = price;
  }

  function setUpdatedAt(uint256 updatedAt) public {
    _updatedAt = updatedAt;
  }

  /**
   * @notice get data about a round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @param _roundId the requested round ID as presented through the proxy, this
   * is made up of the aggregator's round ID with the phase ID encoded in the
   * two highest order bytes
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    roundId = uint80(_roundId);
    answer = int256(_latestPrice);
    startedAt = uint256(1597422127);
    updatedAt = uint256(1597695228);
    answeredInRound = uint80(_roundId);
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    uint256 latestRound = 101;
    roundId = uint80(latestRound);
    answer = int256(_latestPrice);
    startedAt = uint256(1597422127);
    updatedAt = _updatedAt;
    answeredInRound = uint80(latestRound);
  }
}",972
RealWorld_TA_115_AdminInceptionVault_RealWorld_20240815210656.log,115,AdminInceptionVault,175454,4358,179812,154.0,0.96443,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""./BoringOwnable.sol"";
import ""./interfaces/IAdminInceptionVault.sol"";
import ""./interfaces/IInceptionVaultsCore.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";
import ""../interfaces/IWETH.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";
import ""../liquidityMining/interfaces/IGenericMiner.sol"";

contract AdminInceptionVault is IAdminInceptionVault, BoringOwnable, Initializable {
  using SafeERC20 for IERC20;

  IAddressProvider private _a;
  IDebtNotifier private _debtNotifier;
  IWETH private _weth;
  IERC20 private _mimo;
  IInceptionVaultsCore private _inceptionCore;

  uint8 private _collateralCount;
  mapping(uint8 => address) private _collaterals;
  mapping(address => uint8) private _collateralId;

  modifier onlyInceptionVaultsCore() {
    require(address(_inceptionCore) == msg.sender, ""IV011"");
    _;
  }

  function initialize(
    address _owner,
    IAddressProvider addressProvider,
    IDebtNotifier debtNotifier,
    IWETH weth,
    IERC20 mimo,
    IInceptionVaultsCore inceptionVaultsCore
  ) external override initializer {
    _a = addressProvider;
    _debtNotifier = debtNotifier;
    _weth = weth;
    _mimo = mimo;
    _inceptionCore = inceptionVaultsCore;
    owner = _owner;
  }

  /**
    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral
    @dev A new vault is created if no WETH vault exists
  **/
  function depositETH() external payable override onlyOwner {
    _a.core().depositETH{ value: msg.value }();
  }

  /**
    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see depositETH() and borrow()
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositETHAndBorrow(uint256 _borrowAmount) external payable override onlyOwner {
    _a.core().depositETHAndBorrow{ value: msg.value }(_borrowAmount);
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see deposit() and borrow()
    @param _collateralType the address of the collateral type to be deposited
    @param _depositAmount the amount of tokens to be deposited in WEI.
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _borrowAmount
  ) external override onlyOwner {
    IERC20 asset = IERC20(_collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _depositAmount);
    asset.safeIncreaseAllowance(address(_a.core()), _depositAmount);
    _a.core().depositAndBorrow(_collateralType, _depositAmount, _borrowAmount);
    if (_collateralId[_collateralType] == 0) {
      uint8 newId = ++_collateralCount;
      _collateralId[_collateralType] = newId;
      _collaterals[newId] = _collateralType;
    }
  }

  /**
    Withdraws ERC20 tokens from a vault.
    @dev Only the owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to withdraw the collateral.
    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.
  **/
  function withdraw(uint256 _vaultId, uint256 _amount) external override onlyOwner {
    _a.core().withdraw(_vaultId, _amount);
    IERC20 asset = IERC20(_a.vaultsData().vaultCollateralType(_vaultId));
    asset.safeTransfer(msg.sender, _amount);
  }

  /**
    Releases the outstanding MIMO balance.
  */
  function claimMimo() external override {
    for (uint8 i = 1; i < _collateralCount + 1; i++) {
      IGenericMiner supplyMiner = IGenericMiner(address(_debtNotifier.collateralSupplyMinerMapping(_collaterals[i])));
      if (supplyMiner.pendingMIMO(address(this)) != 0) {
        supplyMiner.releaseMIMO(address(this));
      }
    }
  }

  /**
    Lends PAR to inceptionVault user. 
    @dev This function cn only be called by the InceptionVaultsCore.
    @param _amount the amount of PAR to be lended.
    @param _to the address of the inceptionVault user.
  */
  function lendPAR(uint256 _amount, address _to) external override onlyInceptionVaultsCore() {
    IERC20 stablex = IERC20(_a.stablex());
    stablex.safeTransfer(_to, _amount);
  }

  /**
    @dev See {IERC20-transfer}.
  */
  function transferMimo(uint256 _amount, address _to) external override onlyOwner {
    _mimo.safeTransfer(_to, _amount);
  }

  /**
    @dev See {IERC20-transfer}.
  */
  function transferPar(uint256 _amount, address _to) external override onlyOwner {
    IERC20 par = IERC20(address(_a.stablex()));
    par.safeTransfer(_to, _amount);
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral
    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.
    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _collateralType the address of the collateral type to be deposited
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function deposit(address _collateralType, uint256 _amount) public override onlyOwner {
    IERC20 asset = IERC20(_collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _amount);
    asset.safeIncreaseAllowance(address(_a.core()), _amount);
    _a.core().deposit(_collateralType, _amount);
  }

  /**
    Borrow new PAR tokens from a vault.
    @dev Only the owner of a vault can borrow from it.
    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.
     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to borrow.
    @param _amount the amount of borrowed PAR tokens in WEI.
  **/
  function borrow(uint256 _vaultId, uint256 _amount) public override onlyOwner {
    _a.core().borrow(_vaultId, _amount);
    IVaultsDataProvider vaultsData = IVaultsDataProvider(_a.vaultsData());
    address vaultCollateral = vaultsData.vaultCollateralType(_vaultId);
    if (_collateralId[vaultCollateral] == 0) {
      uint8 newId = ++_collateralCount;
      _collateralId[vaultCollateral] = newId;
      _collaterals[newId] = vaultCollateral;
    }
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function debtNotifier() public view override returns (IDebtNotifier) {
    return _debtNotifier;
  }

  function weth() public view override returns (IWETH) {
    return _weth;
  }

  function mimo() public view override returns (IERC20) {
    return _mimo;
  }

  function inceptionCore() public view override returns (IInceptionVaultsCore) {
    return _inceptionCore;
  }

  function collateralCount() public view override returns (uint8) {
    return _collateralCount;
  }

  function collaterals(uint8 _id) public view override returns (address) {
    return _collaterals[_id];
  }

  function collateralId(address _collateral) public view override returns (uint8) {
    return _collateralId[_collateral];
  }
}",1894
RealWorld_TA_115_BConst_RealWorld_20240815212847.log,115,BConst,53592,1196,54788,93.0,0.29188,"// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity 0.6.12;

contract BConst {
  uint256 public constant BONE = 10**18;

  uint256 public constant MIN_BOUND_TOKENS = 2;
  uint256 public constant MAX_BOUND_TOKENS = 8;

  uint256 public constant MIN_FEE = BONE / 10**6;
  uint256 public constant MAX_FEE = BONE / 10;
  uint256 public constant EXIT_FEE = 0;

  uint256 public constant MIN_WEIGHT = BONE;
  uint256 public constant MAX_WEIGHT = BONE * 50;
  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;
  uint256 public constant MIN_BALANCE = BONE / 10**12;

  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;

  uint256 public constant MIN_BPOW_BASE = 1 wei;
  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;
  uint256 public constant BPOW_PRECISION = BONE / 10**10;

  uint256 public constant MAX_IN_RATIO = BONE / 2;
  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;
}",421
RealWorld_TA_115_MIMODeployment_RealWorld_20240815203115.log,115,MIMODeployment,100293,3586,103879,122.0,0.573185,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../liquidityMining/interfaces/IMIMO.sol"";
import ""../liquidityMining/interfaces/IMIMODistributor.sol"";
import ""../liquidityMining/interfaces/ISupplyMiner.sol"";
import ""../liquidityMining/interfaces/IDemandMiner.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../governance/interfaces/IVotingEscrow.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract MIMODeployment {
  IGovernanceAddressProvider public ga;
  IMIMO public mimo;
  IMIMODistributor public mimoDistributor;
  ISupplyMiner public wethSupplyMiner;
  ISupplyMiner public wbtcSupplyMiner;
  ISupplyMiner public usdcSupplyMiner;
  IDemandMiner public demandMiner;
  IDebtNotifier public debtNotifier;
  IVotingEscrow public votingEscrow;

  address public weth;
  address public wbtc;
  address public usdc;

  modifier onlyManager() {
    require(ga.controller().hasRole(ga.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(
    IGovernanceAddressProvider _ga,
    IMIMO _mimo,
    IMIMODistributor _mimoDistributor,
    ISupplyMiner _wethSupplyMiner,
    ISupplyMiner _wbtcSupplyMiner,
    ISupplyMiner _usdcSupplyMiner,
    IDemandMiner _demandMiner,
    IDebtNotifier _debtNotifier,
    IVotingEscrow _votingEscrow,
    address _weth,
    address _wbtc,
    address _usdc
  ) public {
    require(address(_ga) != address(0));
    require(address(_mimo) != address(0));
    require(address(_mimoDistributor) != address(0));
    require(address(_wethSupplyMiner) != address(0));
    require(address(_wbtcSupplyMiner) != address(0));
    require(address(_usdcSupplyMiner) != address(0));
    require(address(_demandMiner) != address(0));
    require(address(_debtNotifier) != address(0));
    require(address(_votingEscrow) != address(0));
    require(_weth != address(0));
    require(_wbtc != address(0));
    require(_usdc != address(0));

    ga = _ga;
    mimo = _mimo;
    mimoDistributor = _mimoDistributor;
    wethSupplyMiner = _wethSupplyMiner;
    wbtcSupplyMiner = _wbtcSupplyMiner;
    usdcSupplyMiner = _usdcSupplyMiner;
    demandMiner = _demandMiner;
    debtNotifier = _debtNotifier;
    votingEscrow = _votingEscrow;

    weth = _weth;
    wbtc = _wbtc;
    usdc = _usdc;
  }

  function setup() public onlyManager {
    //IAddressProvider parallel = a.parallel();

    //bytes32 MIMO_MINTER_ROLE = keccak256(""MIMO_MINTER_ROLE"");
    //bytes32 DEFAULT_ADMIN_ROLE = 0x0000000000000000000000000000000000000000000000000000000000000000;

    ga.setMIMO(mimo);
    ga.setVotingEscrow(votingEscrow);

    debtNotifier.setCollateralSupplyMiner(weth, wethSupplyMiner);
    debtNotifier.setCollateralSupplyMiner(wbtc, wbtcSupplyMiner);
    debtNotifier.setCollateralSupplyMiner(usdc, usdcSupplyMiner);

    address[] memory payees = new address[](4);
    payees[0] = address(wethSupplyMiner);
    payees[1] = address(wbtcSupplyMiner);
    payees[2] = address(usdcSupplyMiner);
    payees[3] = address(demandMiner);
    uint256[] memory shares = new uint256[](4);
    shares[0] = uint256(20);
    shares[1] = uint256(25);
    shares[2] = uint256(5);
    shares[3] = uint256(50);
    mimoDistributor.changePayees(payees, shares);

    bytes32 MANAGER_ROLE = ga.controller().MANAGER_ROLE();
    ga.controller().renounceRole(MANAGER_ROLE, address(this));
  }
}",1008
RealWorld_TA_115_ISupplyMinerV2_RealWorld_20240815201050.log,115,ISupplyMinerV2,25644,1858,27502,97.0,0.16538,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface ISupplyMinerV2 {
  function baseDebtChanged(address user, uint256 newBaseDebt) external;

  function syncStake(address user) external;

  // Read only
  function collateral() external view returns (IERC20);
}",95
RealWorld_TA_115_WadRayMath_RealWorld_20240815213208.log,115,WadRayMath,74042,2268,76310,104.0,0.41557,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

/******************
@title WadRayMath library
@author Aave
@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)
 */

library WadRayMath {
  using SafeMath for uint256;

  uint256 internal constant _WAD = 1e18;
  uint256 internal constant _HALF_WAD = _WAD / 2;

  uint256 internal constant _RAY = 1e27;
  uint256 internal constant _HALF_RAY = _RAY / 2;

  uint256 internal constant _WAD_RAY_RATIO = 1e9;

  function ray() internal pure returns (uint256) {
    return _RAY;
  }

  function wad() internal pure returns (uint256) {
    return _WAD;
  }

  function halfRay() internal pure returns (uint256) {
    return _HALF_RAY;
  }

  function halfWad() internal pure returns (uint256) {
    return _HALF_WAD;
  }

  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {
    return _HALF_WAD.add(a.mul(b)).div(_WAD);
  }

  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 halfB = b / 2;

    return halfB.add(a.mul(_WAD)).div(b);
  }

  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {
    return _HALF_RAY.add(a.mul(b)).div(_RAY);
  }

  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 halfB = b / 2;

    return halfB.add(a.mul(_RAY)).div(b);
  }

  function rayToWad(uint256 a) internal pure returns (uint256) {
    uint256 halfRatio = _WAD_RAY_RATIO / 2;

    return halfRatio.add(a).div(_WAD_RAY_RATIO);
  }

  function wadToRay(uint256 a) internal pure returns (uint256) {
    return a.mul(_WAD_RAY_RATIO);
  }

  /**
   * @dev calculates x^n, in ray. The code uses the ModExp precompile
   * @param x base
   * @param n exponent
   * @return z = x^n, in ray
   */
  function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {
    z = n % 2 != 0 ? x : _RAY;

    for (n /= 2; n != 0; n /= 2) {
      x = rayMul(x, x);

      if (n % 2 != 0) {
        z = rayMul(z, x);
      }
    }
  }
}",650
RealWorld_TA_115_AccessController_RealWorld_20240815205954.log,115,AccessController,26525,1489,28014,102.0,0.162405,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/access/AccessControl.sol"";

contract AccessController is AccessControl {
  bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
  bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

  constructor() public {
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _setupRole(MANAGER_ROLE, msg.sender);
  }
}",101
RealWorld_TA_115_IConfigProviderV1_RealWorld_20240815191444.log,115,IConfigProviderV1,55392,2382,57774,120.0,0.3246,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IAddressProviderV1.sol"";

interface IConfigProviderV1 {
  struct CollateralConfig {
    address collateralType;
    uint256 debtLimit;
    uint256 minCollateralRatio;
    uint256 borrowRate;
    uint256 originationFee;
  }

  event CollateralUpdated(
    address indexed collateralType,
    uint256 debtLimit,
    uint256 minCollateralRatio,
    uint256 borrowRate,
    uint256 originationFee
  );
  event CollateralRemoved(address indexed collateralType);

  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee
  ) external;

  function removeCollateral(address _collateralType) external;

  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;

  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;

  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;

  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;

  function setLiquidationBonus(uint256 _bonus) external;

  function a() external view returns (IAddressProviderV1);

  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);

  function collateralIds(address _collateralType) external view returns (uint256);

  function numCollateralConfigs() external view returns (uint256);

  function liquidationBonus() external view returns (uint256);

  function collateralDebtLimit(address _collateralType) external view returns (uint256);

  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);

  function collateralBorrowRate(address _collateralType) external view returns (uint256);

  function collateralOriginationFee(address _collateralType) external view returns (uint256);
}",454
RealWorld_TA_115_LiquidiationManager_RealWorld_20240815204158.log,115,LiquidiationManager,81722,3080,84802,110.0,0.47021,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../interfaces/ILiquidationManager.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract LiquidationManager is ILiquidationManager, ReentrancyGuard {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  IAddressProvider public override a;

  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18; // 1

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Check if the health factor is above or equal to 1.
    @param _collateralValue value of the collateral in PAR
    @param _vaultDebt outstanding debt to which the collateral balance shall be compared
    @param _minRatio min ratio to calculate health factor
    @return boolean if the health factor is >= 1.
  */
  function isHealthy(
    uint256 _collateralValue,
    uint256 _vaultDebt,
    uint256 _minRatio
  ) public view override returns (bool) {
    uint256 healthFactor = calculateHealthFactor(_collateralValue, _vaultDebt, _minRatio);
    return healthFactor >= HEALTH_FACTOR_LIQUIDATION_THRESHOLD;
  }

  /**
    Calculate the healthfactor of a debt balance
    @param _collateralValue value of the collateral in PAR currency
    @param _vaultDebt outstanding debt to which the collateral balance shall be compared
    @param _minRatio min ratio to calculate health factor
    @return healthFactor
  */
  function calculateHealthFactor(
    uint256 _collateralValue,
    uint256 _vaultDebt,
    uint256 _minRatio
  ) public view override returns (uint256 healthFactor) {
    if (_vaultDebt == 0) return WadRayMath.wad();

    // CurrentCollateralizationRatio = value(deposited ETH) / debt
    uint256 collateralizationRatio = _collateralValue.wadDiv(_vaultDebt);

    // Healthfactor = CurrentCollateralizationRatio / MinimumCollateralizationRatio
    if (_minRatio > 0) {
      return collateralizationRatio.wadDiv(_minRatio);
    }

    return 1e18; // 1
  }

  /**
    Calculate the liquidation bonus for a specified amount
    @param _collateralType address of the collateral type
    @param _amount amount for which the liquidation bonus shall be calculated
    @return bonus the liquidation bonus to pay out
  */
  function liquidationBonus(address _collateralType, uint256 _amount) public view override returns (uint256 bonus) {
    return _amount.wadMul(a.config().collateralLiquidationBonus(_collateralType));
  }

  /**
    Apply the liquidation bonus to a balance as a discount.
    @param _collateralType address of the collateral type
    @param _amount the balance on which to apply to liquidation bonus as a discount.
    @return discountedAmount
  */
  function applyLiquidationDiscount(address _collateralType, uint256 _amount)
    public
    view
    override
    returns (uint256 discountedAmount)
  {
    return _amount.wadDiv(a.config().collateralLiquidationBonus(_collateralType).add(WadRayMath.wad()));
  }
}",767
RealWorld_TA_115_IVaultsDataProviderV1_RealWorld_20240815191117.log,115,IVaultsDataProviderV1,48741,2418,51159,99.0,0.292065,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;
import ""./IAddressProviderV1.sol"";

interface IVaultsDataProviderV1 {
  struct Vault {
    // borrowedType support USDX / PAR
    address collateralType;
    address owner;
    uint256 collateralBalance;
    uint256 baseDebt;
    uint256 createdAt;
  }

  //Write
  function createVault(address _collateralType, address _owner) external returns (uint256);

  function setCollateralBalance(uint256 _id, uint256 _balance) external;

  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;

  function a() external view returns (IAddressProviderV1);

  // Read
  function baseDebt(address _collateralType) external view returns (uint256);

  function vaultCount() external view returns (uint256);

  function vaults(uint256 _id) external view returns (Vault memory);

  function vaultOwner(uint256 _id) external view returns (address);

  function vaultCollateralType(uint256 _id) external view returns (address);

  function vaultCollateralBalance(uint256 _id) external view returns (uint256);

  function vaultBaseDebt(uint256 _id) external view returns (uint256);

  function vaultId(address _collateralType, address _owner) external view returns (uint256);

  function vaultExists(uint256 _id) external view returns (bool);

  function vaultDebt(uint256 _vaultId) external view returns (uint256);

  function debt() external view returns (uint256);

  function collateralDebt(address _collateralType) external view returns (uint256);
}",363
RealWorld_TA_115_IDebtNotifier_RealWorld_20240815202733.log,115,IDebtNotifier,28250,1893,30143,91.0,0.17911,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./ISupplyMiner.sol"";

interface IDebtNotifier {
  function debtChanged(uint256 _vaultId) external;

  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) external;

  function a() external view returns (IGovernanceAddressProvider);

  function collateralSupplyMinerMapping(address collateral) external view returns (ISupplyMiner);
}",119
RealWorld_TA_115_IGovernanceAddressProvider_RealWorld_20240815230155.log,115,IGovernanceAddressProvider,22241,1287,23528,88.0,0.136945,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;

pragma solidity 0.8.10;

import ""./IMIMO.sol"";

interface IGovernanceAddressProvider {
  function mimo() external view returns (IMIMO);
}",50
RealWorld_TA_115_GovernanceAddressProvider_RealWorld_20240815214814.log,115,GovernanceAddressProvider,82610,1887,84497,106.0,0.45079,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IGovernorAlpha.sol"";
import ""./interfaces/ITimelock.sol"";
import ""./interfaces/IVotingEscrow.sol"";
import ""../interfaces/IAccessController.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";
import ""../liquidityMining/interfaces/IMIMO.sol"";

contract GovernanceAddressProvider is IGovernanceAddressProvider {
  IAddressProvider public override parallel;
  IMIMO public override mimo;
  IDebtNotifier public override debtNotifier;
  IGovernorAlpha public override governorAlpha;
  ITimelock public override timelock;
  IVotingEscrow public override votingEscrow;

  constructor(IAddressProvider _parallel) public {
    require(address(_parallel) != address(0));
    parallel = _parallel;
  }

  modifier onlyManager() {
    require(controller().hasRole(controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
    Update the `AddressProvider` address that points to main AddressProvider
    used in the Parallel Protocol
    @dev only manager can call this.
    @param _parallel the address of the new `AddressProvider` address.
  */
  function setParallelAddressProvider(IAddressProvider _parallel) public override onlyManager {
    require(address(_parallel) != address(0));
    parallel = _parallel;
  }

  /**
    Update the `MIMO` ERC20 token address
    @dev only manager can call this.
    @param _mimo the address of the new `MIMO` token address.
  */
  function setMIMO(IMIMO _mimo) public override onlyManager {
    require(address(_mimo) != address(0));
    mimo = _mimo;
  }

  /**
    Update the `DebtNotifier` address
    @dev only manager can call this.
    @param _debtNotifier the address of the new `DebtNotifier`.
  */
  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {
    require(address(_debtNotifier) != address(0));
    debtNotifier = _debtNotifier;
  }

  /**
    Update the `GovernorAlpha` address
    @dev only manager can call this.
    @param _governorAlpha the address of the new `GovernorAlpha`.
  */
  function setGovernorAlpha(IGovernorAlpha _governorAlpha) public override onlyManager {
    require(address(_governorAlpha) != address(0));
    governorAlpha = _governorAlpha;
  }

  /**
    Update the `Timelock` address
    @dev only manager can call this.
    @param _timelock the address of the new `Timelock`.
  */
  function setTimelock(ITimelock _timelock) public override onlyManager {
    require(address(_timelock) != address(0));
    timelock = _timelock;
  }

  /**
    Update the `VotingEscrow` address
    @dev only manager can call this.
    @param _votingEscrow the address of the new `VotingEscrow`.
  */
  function setVotingEscrow(IVotingEscrow _votingEscrow) public override onlyManager {
    require(address(_votingEscrow) != address(0));
    votingEscrow = _votingEscrow;
  }

  function controller() public view override returns (IAccessController) {
    return parallel.controller();
  }
}",770
RealWorld_TA_115_MockGenericMinerV2_RealWorld_20240815184057.log,115,MockGenericMinerV2,31674,2710,34384,100.0,0.21257,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../liquidityMining/v2/GenericMinerV2.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";

contract MockGenericMinerV2 is GenericMinerV2 {
  constructor(IGovernanceAddressProvider _addresses, BoostConfig memory _boostConfig)
    public
    GenericMinerV2(_addresses, _boostConfig)
  {}

  function increaseStake(address user, uint256 value) public {
    _increaseStake(user, value);
  }

  function decreaseStake(address user, uint256 value) public {
    _decreaseStake(user, value);
  }
}",155
RealWorld_TA_115_IAddressProvider_RealWorld_20240815230842.log,115,IAddressProvider,27417,1436,28853,86.0,0.165805,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""./IVaultsCore.sol"";
import ""./IPriceFeed.sol"";
import ""./IVaultsDataProvider.sol"";

interface IAddressProvider {
  function core() external view returns (IVaultsCore);

  function priceFeed() external view returns (IPriceFeed);

  function vaultsData() external view returns (IVaultsDataProvider);

  function stablex() external view returns (address);
}",105
RealWorld_TA_115_TestTimelock_RealWorld_20240815215738.log,115,TestTimelock,29429,3581,33010,120.0,0.218765,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.6.12;

import ""../Timelock.sol"";

// Test timelock contract with admin helpers
contract TestTimelock is Timelock {
  constructor(address admin_, uint256 delay_) public Timelock(admin_, 2 days) {
    delay = delay_;
  }

  function harnessSetPendingAdmin(address pendingAdmin_) public {
    pendingAdmin = pendingAdmin_;
  }

  function harnessSetAdmin(address admin_) public {
    admin = admin_;
  }
}",112
RealWorld_TA_115_MockWBTC_RealWorld_20240815183546.log,115,MockWBTC,24335,2719,27054,105.0,0.176055,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockWBTC is ERC20(""Wrapped Bitcoin"", ""WBTC"") {
  function mint(address account, uint256 amount) public {
    _mint(account, amount);
  }
}",70
RealWorld_TA_115_GenericMinerV2_RealWorld_20240815195538.log,115,GenericMinerV2,291259,5897,297156,175.0,1.574235,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IGenericMinerV2.sol"";
import ""../../libraries/WadRayMath.sol"";
import ""../../libraries/ABDKMath64x64.sol"";

/*
    GenericMiner is based on ERC2917. https://github.com/gnufoo/ERC2917-Proposal

    The Objective of GenericMiner is to implement a decentralized staking mechanism, which calculates _users' share
    by accumulating stake * time. And calculates _users revenue from anytime t0 to t1 by the formula below:

        user_accumulated_stake(time1) - user_accumulated_stake(time0)
       _____________________________________________________________________________  * (gross_stake(t1) - gross_stake(t0))
       total_accumulated_stake(time1) - total_accumulated_stake(time0)

    The boost feature reuses the same principle and applies a multiplier to the stake.

    The boost multiplier formula is the following : a + b / (c + e^-((veMIMO / d) - e))
*/

contract GenericMinerV2 is IGenericMinerV2 {
  using ABDKMath64x64 for int128;
  using ABDKMath64x64 for uint256;
  using SafeMath for uint256;
  using WadRayMath for uint256;

  IERC20 internal immutable _par;
  IGovernanceAddressProvider internal immutable _a;

  BoostConfig internal _boostConfig;

  mapping(address => UserInfo) internal _users;

  uint256 internal _totalStake;
  uint256 internal _totalStakeWithBoost;

  uint256 internal _mimoBalanceTracker;
  uint256 internal _accMimoAmountPerShare;

  uint256 internal _parBalanceTracker;
  uint256 internal _accParAmountPerShare;

  modifier onlyManager {
    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), ""LM010"");
    _;
  }

  constructor(IGovernanceAddressProvider _addresses, BoostConfig memory boostConfig) public {
    require(address(_addresses) != address(0), ""LM000"");
    _a = _addresses;
    _par = IERC20(_addresses.parallel().stablex());
    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, ""LM004"");
    _boostConfig = boostConfig;

    emit BoostConfigSet(_boostConfig);
  }

  /**
    Sets new boost config
    @dev can only be called by protocol manager
    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}
   */
  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {
    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, ""LM004"");
    _boostConfig = newBoostConfig;

    emit BoostConfigSet(_boostConfig);
  }

  /**
    Releases outstanding rewards balances to the user
    @param _user the address of the user for which the reward tokens will be released
  */
  function releaseRewards(address _user) public virtual override {
    UserInfo memory _userInfo = _users[_user];
    _releaseRewards(_user, _userInfo);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(_user, _userInfo);
  }

  /**
    Reapplies the boost of the user, useful if a whale's vMIMO has decreased but their boost is still the original value
  */
  function updateBoost(address _user) public {
    UserInfo memory userInfo = _users[_user];
    _updateBoost(_user, userInfo);
  }

  /**
    Returns the number of tokens a user has staked
    @param _user the address of the user
    @return number of staked tokens
  */
  function stake(address _user) public view override returns (uint256) {
    return _users[_user].stake;
  }

  /**
    Returns the number of tokens a user has staked with the boost
    @param _user the address of the user
    @return number of staked tokens with boost
  */
  function stakeWithBoost(address _user) public view override returns (uint256) {
    return _users[_user].stakeWithBoost;
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`
    @param _user the address of the user
    @return number of MIMO tokens that the user can claim
  */
  function pendingMIMO(address _user) public view override returns (uint256) {
    UserInfo memory _userInfo = _users[_user];
    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @param _user the address of the user
    @return number of PAR tokens that will be sent automatically when staking/unstaking
  */
  function pendingPAR(address _user) public view override returns (uint256) {
    UserInfo memory _userInfo = _users[_user];
    return _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
  }

  function par() public view override returns (IERC20) {
    return _par;
  }

  function a() public view override returns (IGovernanceAddressProvider) {
    return _a;
  }

  function boostConfig() public view override returns (BoostConfig memory) {
    return _boostConfig;
  }

  function totalStake() public view override returns (uint256) {
    return _totalStake;
  }

  function totalStakeWithBoost() public view override returns (uint256) {
    return _totalStakeWithBoost;
  }

  /**
    Returns the userInfo stored of a user
    @param _user the address of the user
    @return `struct UserInfo {
      uint256 stake;
      uint256 stakeWithBoost;
      uint256 accAmountPerShare;
      uint256 accParAmountPerShare;
    }`
  **/
  function userInfo(address _user) public view override returns (UserInfo memory) {
    return _users[_user];
  }

  /**
    Refreshes the global state and subsequently increases a user's stake
    This is an internal call and meant to be called within derivative contracts
    @param user the address of the user
    @param value the amount by which the stake will be increased
  */
  function _increaseStake(address user, uint256 value) internal {
    require(value > 0, ""LM101"");
    UserInfo memory _userInfo = _users[user];

    _releaseRewards(user, _userInfo);
    _totalStake = _totalStake.add(value);
    _userInfo.stake = _userInfo.stake.add(value);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(user, _userInfo);

    emit StakeIncreased(user, value);
  }

  /**
    Refreshes the global state and subsequently decreases the stake a user has
    This is an internal call and meant to be called within derivative contracts
    @param user the address of the user
    @param value the amount by which the stake will be reduced
  */
  function _decreaseStake(address user, uint256 value) internal {
    require(value > 0, ""LM101"");
    UserInfo memory _userInfo = _users[user];
    require(_userInfo.stake >= value, ""LM102"");

    _releaseRewards(user, _userInfo);
    _totalStake = _totalStake.sub(value);
    _userInfo.stake = _userInfo.stake.sub(value);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(user, _userInfo);

    emit StakeDecreased(user, value);
  }

  function _releaseRewards(address _user, UserInfo memory _userInfo) internal {
    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
    uint256 pendingPAR = _pendingPAR(_userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
    _refresh();

    if (_userInfo.stakeWithBoost > 0) {
      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);
      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    }

    if (pendingMIMO > 0) {
      require(_a.mimo().transfer(_user, pendingMIMO), ""LM100"");
    }
    if (pendingPAR > 0) {
      require(_par.transfer(_user, pendingPAR), ""LM100"");
    }
  }

  /**
    Updates the internal state variables based on user's veMIMO hodlings
    @param _user the address of the user
   */
  function _updateBoost(address _user, UserInfo memory _userInfo) internal {
    // if user had a boost already, first remove it from the totalStakeWithBoost
    if (_userInfo.stakeWithBoost > 0) {
      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);
    }
    uint256 multiplier = _getBoostMultiplier(_user);
    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);
    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);
    _users[_user] = _userInfo;
  }

  /**
    Refreshes the global state and subsequently updates a user's stake
    This is an internal call and meant to be called within derivative contracts
    @param user the address of the user
    @param stake the new amount of stake for the user
  */
  function _updateStake(address user, uint256 stake) internal returns (bool) {
    uint256 oldStake = _users[user].stake;
    if (stake > oldStake) {
      _increaseStake(user, stake.sub(oldStake));
    }
    if (stake < oldStake) {
      _decreaseStake(user, oldStake.sub(stake));
    }
  }

  /**
    Updates the internal state variables after accounting for newly received MIMO and PAR reward tokens
  */
  function _refresh() internal {
    if (_totalStake == 0) {
      return;
    }
    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));
    uint256 currentParBalance = _par.balanceOf(address(this));
    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);
    uint256 parReward = currentParBalance.sub(_parBalanceTracker);

    _mimoBalanceTracker = currentMimoBalance;
    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));
    _parBalanceTracker = currentParBalance;
    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`
    @return number of MIMO tokens that the user can claim
  */
  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {
    if (_totalStakeWithBoost == 0) {
      return 0;
    }
    uint256 currentBalance = _a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_mimoBalanceTracker);
    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));
    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @return number of PAR tokens that will be sent automatically when staking/unstaking
  */
  function _pendingPAR(uint256 _userStakeWithBoost, uint256 _userAccParAmountPerShare) internal view returns (uint256) {
    if (_totalStakeWithBoost == 0) {
      return 0;
    }
    uint256 currentBalance = _par.balanceOf(address(this));
    uint256 reward = currentBalance.sub(_parBalanceTracker);
    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));

    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));
  }

  /**
    Returns the boost multiplier the user is eligible for
    @param _user the address of the user
    @return the boost multiplier based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))
   */
  function _getBoostMultiplier(address _user) internal view returns (uint256) {
    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);

    if (veMIMO == 0) return 1e18;

    // Convert boostConfig variables to signed 64.64-bit fixed point numbers
    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);
    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);
    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);
    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);
    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);

    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000
    int128 e2 = e1.sub(e); // x/25000 - 6
    int128 e3 = e2.neg(); // -(x/25000 - 6)
    int128 e4 = e3.exp(); // e^-(x/25000 - 6)
    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)
    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))
    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64
    uint256 multiplier = uint256(e7); // convert to uint256

    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, ""LM103"");

    return multiplier;
  }
}",3234
RealWorld_TA_115_AggregatorV3Interface_RealWorld_20240815214647.log,115,AggregatorV3Interface,31738,1348,33086,84.0,0.18565,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.12;

interface AggregatorV3Interface {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}",156
RealWorld_TA_115_MIMOBuyBack_RealWorld_20240815193523.log,115,MIMOBuyBack,69196,5162,74358,136.0,0.44922,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../libraries/interfaces/IVault.sol"";

contract MIMOBuyback {
  bytes32 public constant KEEPER_ROLE = keccak256(""KEEPER_ROLE"");

  IAddressProvider public a;
  IERC20 public PAR;
  IERC20 public MIMO;
  uint256 public lockExpiry;
  bytes32 public poolID;
  IVault public balancer;

  bool public whitelistEnabled = false;

  constructor(
    uint256 _lockExpiry,
    bytes32 _poolID,
    address _a,
    address _mimo,
    address _balancer
  ) public {
    lockExpiry = _lockExpiry;
    poolID = _poolID;
    a = IAddressProvider(_a);
    MIMO = IERC20(_mimo);
    PAR = a.stablex();
    balancer = IVault(_balancer);

    PAR.approve(address(balancer), 2**256 - 1);
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  modifier onlyKeeper() {
    require(!whitelistEnabled || a.controller().hasRole(KEEPER_ROLE, msg.sender), ""Caller is not a Keeper"");
    _;
  }

  function withdrawMIMO(address destination) public onlyManager {
    require(block.timestamp > lockExpiry, ""lock not expired yet"");
    require(MIMO.transfer(destination, MIMO.balanceOf(address(this))));
  }

  function buyMIMO() public onlyKeeper {
    a.core().state().refresh();
    a.feeDistributor().release();

    bytes memory userData = abi.encode();
    IVault.SingleSwap memory singleSwap = IVault.SingleSwap(
      poolID,
      IVault.SwapKind.GIVEN_IN,
      IAsset(address(PAR)), // swap in
      IAsset(address(MIMO)), // swap out
      PAR.balanceOf(address(this)), // all PAR of this contract
      userData
    );

    IVault.FundManagement memory fundManagement = IVault.FundManagement(
      address(this), // sender
      false, // useInternalBalance
      payable(address(this)), // recipient
      false // // useInternalBalance
    );

    balancer.swap(
      singleSwap,
      fundManagement,
      0, // limit, could be frontrun?
      2**256 - 1 // deadline
    );
  }

  function setWhitelistEnabled(bool _status) public onlyManager {
    whitelistEnabled = _status;
  }
}",582
RealWorld_TA_115_ChainlinkInceptionPriceFeed_RealWorld_20240815211546.log,115,ChainlinkInceptionPriceFeed,97196,2785,99981,104.0,0.54168,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""../interfaces/IInceptionVaultPriceFeed.sol"";
import ""../../chainlink/AggregatorV3Interface.sol"";
import ""../../interfaces/IAddressProvider.sol"";
import ""../../libraries/MathPow.sol"";
import ""../../libraries/WadRayMath.sol"";

contract ChainlinkInceptionPriceFeed is IInceptionVaultPriceFeed, Initializable {
  using SafeMath for uint256;
  using SafeMath for uint8;
  using WadRayMath for uint256;

  uint256 private constant _PRICE_ORACLE_STALE_THRESHOLD = 1 days;

  IAddressProvider private _a;

  ERC20 private _inceptionCollateral;

  AggregatorV3Interface private _assetOracle;

  AggregatorV3Interface private _eurOracle;

  function initialize(
    IAddressProvider _addresses,
    address inceptionCollateral,
    address assetOracle,
    AggregatorV3Interface eurOracle
  ) external override initializer {
    _a = _addresses;
    _inceptionCollateral = ERC20(inceptionCollateral);
    _assetOracle = AggregatorV3Interface(assetOracle);
    _eurOracle = eurOracle;
  }

  /**
   * @notice Converts asset balance into stablecoin balance at current price
   * @param _amount amount of collateral
   */
  function convertFrom(uint256 _amount) external view override returns (uint256) {
    uint256 price = getAssetPrice();
    uint8 collateralDecimals = ERC20(_inceptionCollateral).decimals();
    uint8 parDecimals = ERC20(address(_a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()
    uint8 oracleDecimals = _assetOracle.decimals();
    uint256 parAccuracy = MathPow.pow(10, parDecimals);
    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));
    return _amount.mul(price).mul(parAccuracy).div(collateralAccuracy);
  }

  /**
   * @notice Converts stablecoin balance into collateral balance at current price
   * @param _amount amount of stablecoin
   */
  function convertTo(uint256 _amount) external view override returns (uint256) {
    uint256 price = getAssetPrice();
    uint8 collateralDecimals = ERC20(_inceptionCollateral).decimals();
    uint8 parDecimals = ERC20(address(_a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()
    uint8 oracleDecimals = _assetOracle.decimals();
    uint256 parAccuracy = MathPow.pow(10, parDecimals);
    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));
    return _amount.mul(collateralAccuracy).div(price).div(parAccuracy);
  }

  /**
   * Gets the asset price in EUR (PAR)
   * @dev returned value has matching decimals to the asset oracle (not the EUR oracle)
   */
  function getAssetPrice() public view override returns (uint256 price) {
    (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = _eurOracle.latestRoundData();
    require(eurAnswer > 0, ""EUR price data not valid"");
    require(block.timestamp - eurUpdatedAt < _PRICE_ORACLE_STALE_THRESHOLD, ""EUR price data is stale"");

    (, int256 answer, , uint256 assetUpdatedAt, ) = _assetOracle.latestRoundData();
    require(answer > 0, ""Price data not valid"");
    require(block.timestamp - assetUpdatedAt < _PRICE_ORACLE_STALE_THRESHOLD, ""Price data is stale"");

    uint8 eurDecimals = _eurOracle.decimals();
    uint256 eurAccuracy = MathPow.pow(10, eurDecimals);
    return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function inceptionCollateral() public view override returns (ERC20) {
    return _inceptionCollateral;
  }

  function assetOracle() public view override returns (AggregatorV3Interface) {
    return _assetOracle;
  }

  function eurOracle() public view override returns (AggregatorV3Interface) {
    return _eurOracle;
  }
}",964
RealWorld_TA_115_PAR_RealWorld_20240815192036.log,115,PAR,37772,1978,39750,103.0,0.22842,"// solium-disable security/no-block-members
// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/ISTABLEX.sol"";

/**
 * @title  PAR
 * @notice  Stablecoin which can be minted against collateral in a vault
 */
contract PAR is ISTABLEX, ERC20(""PAR Stablecoin"", ""PAR"") {
  IAddressProvider public override a;

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  function mint(address account, uint256 amount) public override onlyMinter {
    _mint(account, amount);
  }

  function burn(address account, uint256 amount) public override onlyMinter {
    _burn(account, amount);
  }

  modifier onlyMinter() {
    require(a.controller().hasRole(a.controller().MINTER_ROLE(), msg.sender), ""Caller is not a minter"");
    _;
  }
}",234
RealWorld_TA_115_IVaultsCoreV1_RealWorld_20240815191646.log,115,IVaultsCoreV1,55889,2812,58701,122.0,0.335685,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;
import ""./IAddressProviderV1.sol"";

interface IVaultsCoreV1 {
  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);
  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Liquidated(
    uint256 indexed vaultId,
    uint256 debtRepaid,
    uint256 collateralLiquidated,
    address indexed owner,
    address indexed sender
  );

  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0

  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);

  function deposit(address _collateralType, uint256 _amount) external;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function withdrawAll(uint256 _vaultId) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function repayAll(uint256 _vaultId) external;

  function repay(uint256 _vaultId, uint256 _amount) external;

  function liquidate(uint256 _vaultId) external;

  //Refresh
  function initializeRates(address _collateralType) external;

  function refresh() external;

  function refreshCollateral(address collateralType) external;

  //upgrade
  function upgrade(address _newVaultsCore) external;

  //Read only

  function a() external view returns (IAddressProviderV1);

  function availableIncome() external view returns (uint256);

  function cumulativeRates(address _collateralType) external view returns (uint256);

  function lastRefresh(address _collateralType) external view returns (uint256);
}",437
RealWorld_TA_115_IGenericMiner_RealWorld_20240815231010.log,115,IGenericMiner,23925,1546,25471,89.0,0.150545,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""./IGovernanceAddressProvider.sol"";

interface IGenericMiner {
  function a() external view returns (IGovernanceAddressProvider);

  function releaseMIMO(address _user) external;
}",65
RealWorld_TA_115_SuperVaultFactory_RealWorld_20240815225257.log,115,SuperVaultFactory,32416,2638,35054,114.0,0.21484,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

contract SuperVaultFactory {
  using Address for address;
  using Clones for address;

  event NewSuperVaultContract(address indexed owner, address superVaultContract);

  address public base;

  constructor(address _base) public {
    require(address(_base) != address(0));

    base = _base;
  }

  function clone(bytes calldata _initdata) public {
    address superVaultContract = base.clone();
    superVaultContract.functionCall(_initdata);
  
    emit NewSuperVaultContract(msg.sender, superVaultContract);
  }
}",163
RealWorld_TA_115_MIMOBuybackUniswapV2_RealWorld_20240815193116.log,115,MIMOBuybackUniswapV2,63115,5066,68181,130.0,0.416895,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../libraries/interfaces/IUniswapV2Router02.sol"";

contract MIMOBuybackUniswapV2 {
  bytes32 public constant KEEPER_ROLE = keccak256(""KEEPER_ROLE"");

  IAddressProvider public a;
  IERC20 public PAR;
  IERC20 public MIMO;
  uint256 public lockExpiry;

  IUniswapV2Router02 public router;

  bool public whitelistEnabled = false;

  constructor(
    uint256 _lockExpiry,
    address _router,
    address _a,
    address _mimo
  ) public {
    lockExpiry = _lockExpiry;
    a = IAddressProvider(_a);
    MIMO = IERC20(_mimo);
    PAR = a.stablex();

    router = IUniswapV2Router02(_router);

    PAR.approve(address(router), 2**256 - 1);
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  modifier onlyKeeper() {
    require(!whitelistEnabled || a.controller().hasRole(KEEPER_ROLE, msg.sender), ""Caller is not a Keeper"");
    _;
  }

  function withdrawMIMO(address destination) public onlyManager {
    require(block.timestamp > lockExpiry, ""lock not expired yet"");
    require(MIMO.transfer(destination, MIMO.balanceOf(address(this))));
  }

  function buyMIMO() public onlyKeeper {
    a.core().state().refresh();
    a.feeDistributor().release();

    address[] memory path = new address[](2);
    path[0] = address(PAR); // tokenIn
    path[1] = address(MIMO); // tokenOut

    router.swapExactTokensForTokens(
      PAR.balanceOf(address(this)), // amountIn
      0, // amountOutMin: we can skip computing this number because the math is tested
      path,
      address(this), // receive address
      2**256 - 1 // deadline
    );
  }

  function setWhitelistEnabled(bool _status) public onlyManager {
    whitelistEnabled = _status;
  }
}",514
RealWorld_TA_115_TInceptionVaultFactory_RealWorld_20240815223745.log,115,TInceptionVaultFactory,39195,3867,43062,118.0,0.273315,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""./TIVSetup.sol"";

contract TInceptionVaultFactory is TIVSetup {
  constructor() public TIVSetup() {}

  /// @notice Checks that inceptionVaults cannot be deleted from mapping
  function echidna_inceptionVault_isListed() public view returns (bool) {
    for (uint256 i = 1; i <= _inceptionVaultFactory.inceptionVaultCount(); i++) {
      address owner = _inceptionVaultFactory.inceptionVaults(i).owner;
      return owner != address(0);
    }
  }

  /// @notice Checks that priceFeeds cannot be deleted from mapping
  function echidna_priceFeed_isListed() public view returns (bool) {
    for (uint8 i = 1; i <= _inceptionVaultFactory.priceFeedCount(); i++) {
      address priceFeed = _inceptionVaultFactory.priceFeeds(i);
      return _inceptionVaultFactory.priceFeedIds(priceFeed) != 0;
    }
  }
}",234
RealWorld_TA_115_MockInceptionAggregator_RealWorld_20240815184442.log,115,MockInceptionAggregator,100751,3278,104029,121.0,0.569315,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../chainlink/AggregatorV3Interface.sol"";

contract MockInceptionAggregator is AggregatorV3Interface {
  uint256 private _latestPrice;
  uint256 private _updatedAt;
  uint256 private _startedAt;
  string public override description;
  uint256 public override version = 3;

  uint8 public override decimals;

  constructor(
    uint8 _decimals,
    uint256 _price,
    string memory _description
  ) public {
    decimals = _decimals;
    _latestPrice = _price;
    description = _description;
    _updatedAt = now;
    _startedAt = now;
  }

  function setLatestPrice(uint256 price) public {
    _latestPrice = price;
  }

  /**
   * @notice get data about a round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @param _roundId the requested round ID as presented through the proxy, this
   * is made up of the aggregator's round ID with the phase ID encoded in the
   * two highest order bytes
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    roundId = uint80(_roundId);
    answer = int256(_latestPrice);
    startedAt = _startedAt;
    updatedAt = now;
    answeredInRound = uint80(_roundId);
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    uint256 latestRound = 101;
    roundId = uint80(latestRound);
    answer = int256(_latestPrice);
    startedAt = _startedAt;
    updatedAt = now;
    answeredInRound = uint80(latestRound);
  }
}",954
RealWorld_TA_115_FeeDistributor_RealWorld_20240815210139.log,115,FeeDistributor,99612,4851,104463,139.0,0.59508,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""../interfaces/IFeeDistributor.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract FeeDistributor is IFeeDistributor, ReentrancyGuard {
  using SafeMath for uint256;

  event PayeeAdded(address account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  uint256 public override lastReleasedAt;
  IAddressProvider public override a;

  uint256 public override totalShares;
  mapping(address => uint256) public override shares;
  address[] public payees;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Public function to release the accumulated fee income to the payees.
    @dev anyone can call this.
  */
  function release() public override nonReentrant {
    uint256 income = a.core().state().availableIncome();
    require(income > 0, ""income is 0"");
    require(payees.length > 0, ""Payees not configured yet"");
    lastReleasedAt = now;

    // Mint USDX to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(income, payee);
    }
    emit FeeReleased(income, lastReleasedAt);
  }

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");
    require(_payees.length > 0, ""No payees"");

    uint256 income = a.core().state().availableIncome();
    if (income > 0 && payees.length > 0) {
      release();
    }

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }
    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view override returns (address[] memory) {
    return payees;
  }

  /**
    Internal function to release a percentage of income to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalIncomeReceived Total income for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalIncomeReceived, address _payee) internal {
    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);
    a.stablex().mint(_payee, payment);
  }

  /**
    Internal function to add a new payee.
    @dev will update totalShares and therefore reduce the relative share of all other payees.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""payee is the zero address"");
    require(_shares > 0, ""shares are 0"");
    require(shares[_payee] == 0, ""payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }
}",952
RealWorld_TA_115_DemandMinerV2_RealWorld_20240815200035.log,115,DemandMinerV2,88264,3111,91375,109.0,0.50354,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./GenericMinerV2.sol"";
import ""./interfaces/IDemandMinerV2.sol"";
import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../../libraries/WadRayMath.sol"";

contract DemandMinerV2 is IDemandMinerV2, GenericMinerV2 {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;
  using WadRayMath for uint256;

  address private _feeCollector;
  IERC20 private immutable _token;

  FeeConfig private _feeConfig;

  constructor(
    IGovernanceAddressProvider _addresses,
    IERC20 token,
    address feeCollector,
    BoostConfig memory _boostConfig,
    FeeConfig memory feeConfig
  ) public GenericMinerV2(_addresses, _boostConfig) {
    require(address(token) != address(0), ""LM000"");
    require(address(token) != address(_addresses.mimo()), ""LM001"");
    require(feeCollector != address(0), ""LM000"");
    _token = token;
    _feeCollector = feeCollector;
    _feeConfig = feeConfig;
    emit FeeCollectorSet(feeCollector);
    emit FeeConfigSet(feeConfig);
  }

  /**
    Sets new _feeCollector
    @dev can only be called by protocol manager
    @param feeCollector new feeCollector address
   */
  function setFeeCollector(address feeCollector) external override onlyManager {
    _feeCollector = feeCollector;
    emit FeeCollectorSet(feeCollector);
  }

  /**
    Sets new _feeConfig
    @dev can only be called by protocol manager
    @param newFeeConfig new FeeConfig struct see {IDemandMinerV2.FeeConfig}
   */
  function setFeeConfig(FeeConfig memory newFeeConfig) external override onlyManager {
    _feeConfig = newFeeConfig;
    emit FeeConfigSet(newFeeConfig);
  }

  /**
    Deposit an ERC20 pool token for staking
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20
    @param amount the amount of tokens to be deposited. Unit is in WEI
  **/
  function deposit(uint256 amount) public override {
    _token.safeTransferFrom(msg.sender, address(this), amount);
    uint256 depositAmount = amount;
    if (_feeConfig.depositFee > 0) {
      uint256 fee = amount.wadMul(_feeConfig.depositFee);
      depositAmount = depositAmount.sub(fee);
      _token.safeTransfer(_feeCollector, fee);
      emit DepositFeeReleased(fee);
    }
    _increaseStake(msg.sender, depositAmount);
  }

  /**
    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked
    @param amount the amount of tokens to be withdrawn. Unit is in WEI
  **/
  function withdraw(uint256 amount) public override {
    uint256 withdrawAmount = amount;
    if (_feeConfig.withdrawFee > 0) {
      uint256 fee = amount.wadMul(_feeConfig.withdrawFee);
      withdrawAmount = withdrawAmount.sub(fee);
      _token.safeTransfer(_feeCollector, fee);
      emit WithdrawFeeReleased(fee);
    }
    _token.safeTransfer(msg.sender, withdrawAmount);
    _decreaseStake(msg.sender, amount);
  }

  function token() public view override returns (IERC20) {
    return _token;
  }

  function feeCollector() public view override returns (address) {
    return _feeCollector;
  }

  function feeConfig() public view override returns (FeeConfig memory) {
    return _feeConfig;
  }
}",847
RealWorld_TA_115_ConfigProvider_RealWorld_20240815205357.log,115,ConfigProvider,283925,3220,287145,127.0,1.484025,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../libraries/WadRayMath.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract ConfigProvider is IConfigProvider {
  IAddressProvider public override a;

  mapping(uint256 => CollateralConfig) private _collateralConfigs; //indexing starts at 1
  mapping(address => uint256) public override collateralIds;

  uint256 public override numCollateralConfigs;
  /// @notice The minimum duration of voting on a proposal, in seconds
  uint256 public override minVotingPeriod = 3 days;
  /// @notice The max duration of voting on a proposal, in seconds
  uint256 public override maxVotingPeriod = 2 weeks;
  /// @notice The percentage of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed
  uint256 public override votingQuorum = 1e16; // 1%
  /// @notice The percentage of votes required in order for a voter to become a proposer
  uint256 public override proposalThreshold = 2e14; // 0.02%

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));

    a = _addresses;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
    Creates or overwrites an existing config for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the debt ceiling for the collateral type
    @param _liquidationRatio the minimum ratio to maintain to avoid liquidation
    @param _minCollateralRatio the minimum ratio to maintain to borrow new money or withdraw collateral
    @param _borrowRate the borrowing rate specified in 1 second interval in RAY accuracy.
    @param _originationFee an optional origination fee for newly created debt. Can be 0.
    @param _liquidationBonus the liquidation bonus to be paid to liquidators.
    @param _liquidationFee an optional fee for liquidation debt. Can be 0.
  */
  function setCollateralConfig(
    address _collateralType,
    uint256 _debtLimit,
    uint256 _liquidationRatio,
    uint256 _minCollateralRatio,
    uint256 _borrowRate,
    uint256 _originationFee,
    uint256 _liquidationBonus,
    uint256 _liquidationFee
  ) public override onlyManager {
    require(address(_collateralType) != address(0));
    require(_minCollateralRatio >= _liquidationRatio);
    if (collateralIds[_collateralType] == 0) {
      // Initialize new collateral
      a.core().state().initializeRates(_collateralType);
      CollateralConfig memory config = CollateralConfig({
        collateralType: _collateralType,
        debtLimit: _debtLimit,
        liquidationRatio: _liquidationRatio,
        minCollateralRatio: _minCollateralRatio,
        borrowRate: _borrowRate,
        originationFee: _originationFee,
        liquidationBonus: _liquidationBonus,
        liquidationFee: _liquidationFee
      });

      numCollateralConfigs++;
      _collateralConfigs[numCollateralConfigs] = config;
      collateralIds[_collateralType] = numCollateralConfigs;
    } else {
      // Update collateral config
      a.core().state().refreshCollateral(_collateralType);
      uint256 id = collateralIds[_collateralType];

      _collateralConfigs[id].collateralType = _collateralType;
      _collateralConfigs[id].debtLimit = _debtLimit;
      _collateralConfigs[id].liquidationRatio = _liquidationRatio;
      _collateralConfigs[id].minCollateralRatio = _minCollateralRatio;
      _collateralConfigs[id].borrowRate = _borrowRate;
      _collateralConfigs[id].originationFee = _originationFee;
      _collateralConfigs[id].liquidationBonus = _liquidationBonus;
      _collateralConfigs[id].liquidationFee = _liquidationFee;
    }
    emit CollateralUpdated(
      _collateralType,
      _debtLimit,
      _liquidationRatio,
      _minCollateralRatio,
      _borrowRate,
      _originationFee,
      _liquidationBonus,
      _liquidationFee
    );
  }

  function _emitUpdateEvent(address _collateralType) internal {
    emit CollateralUpdated(
      _collateralType,
      _collateralConfigs[collateralIds[_collateralType]].debtLimit,
      _collateralConfigs[collateralIds[_collateralType]].liquidationRatio,
      _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio,
      _collateralConfigs[collateralIds[_collateralType]].borrowRate,
      _collateralConfigs[collateralIds[_collateralType]].originationFee,
      _collateralConfigs[collateralIds[_collateralType]].liquidationBonus,
      _collateralConfigs[collateralIds[_collateralType]].liquidationFee
    );
  }

  /**
    Remove the config for a collateral type
    @param _collateralType address of the collateral type
  */
  function removeCollateral(address _collateralType) public override onlyManager {
    uint256 id = collateralIds[_collateralType];
    require(id != 0, ""collateral does not exist"");

    _collateralConfigs[id] = _collateralConfigs[numCollateralConfigs]; //move last entry forward
    collateralIds[_collateralConfigs[id].collateralType] = id; //update id for last entry
    delete _collateralConfigs[numCollateralConfigs]; // delete last entry
    delete collateralIds[_collateralType];

    numCollateralConfigs--;

    emit CollateralRemoved(_collateralType);
  }

  /**
    Sets the debt limit for a collateral type
    @param _collateralType address of the collateral type
    @param _debtLimit the new debt limit
  */
  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].debtLimit = _debtLimit;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the minimum liquidation ratio for a collateral type
    @dev this is the liquidation treshold under which a vault is considered open for liquidation.
    @param _collateralType address of the collateral type
    @param _liquidationRatio the new minimum collateralization ratio
  */
  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio)
    public
    override
    onlyManager
  {
    require(_liquidationRatio <= _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio);
    _collateralConfigs[collateralIds[_collateralType]].liquidationRatio = _liquidationRatio;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the minimum ratio for a collateral type for new borrowing or collateral withdrawal
    @param _collateralType address of the collateral type
    @param _minCollateralRatio the new minimum open ratio
  */
  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio)
    public
    override
    onlyManager
  {
    require(_minCollateralRatio >= _collateralConfigs[collateralIds[_collateralType]].liquidationRatio);
    _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio = _minCollateralRatio;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
    @param _borrowRate the new borrowing rate for a 1 sec interval
  */
  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {
    a.core().state().refreshCollateral(_collateralType);
    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
    @param _originationFee new origination fee in WAD
  */
  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) public override onlyManager {
    _collateralConfigs[collateralIds[_collateralType]].originationFee = _originationFee;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the liquidation bonus for a collateral type
    @dev the liquidation bonus is specified in WAD
    @param _collateralType address of the collateral type
    @param _liquidationBonus the liquidation bonus to be paid to liquidators.
  */
  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus)
    public
    override
    onlyManager
  {
    _collateralConfigs[collateralIds[_collateralType]].liquidationBonus = _liquidationBonus;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Sets the liquidation fee for a collateral type
    @dev this rate is applied as a fee for liquidation and is specified in WAD
    @param _collateralType address of the collateral type
    @param _liquidationFee new liquidation fee in WAD
  */
  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) public override onlyManager {
    require(_liquidationFee < 1e18); // fee < 100%
    _collateralConfigs[collateralIds[_collateralType]].liquidationFee = _liquidationFee;
    _emitUpdateEvent(_collateralType);
  }

  /**
    Set the min voting period for a gov proposal.
    @param _minVotingPeriod the min voting period for a gov proposal
  */
  function setMinVotingPeriod(uint256 _minVotingPeriod) public override onlyManager {
    minVotingPeriod = _minVotingPeriod;
  }

  /**
    Set the max voting period for a gov proposal.
    @param _maxVotingPeriod the max voting period for a gov proposal
  */
  function setMaxVotingPeriod(uint256 _maxVotingPeriod) public override onlyManager {
    maxVotingPeriod = _maxVotingPeriod;
  }

  /**
    Set the voting quora for a gov proposal.
    @param _votingQuorum the voting quora for a gov proposal
  */
  function setVotingQuorum(uint256 _votingQuorum) public override onlyManager {
    require(_votingQuorum < 1e18);
    votingQuorum = _votingQuorum;
  }

  /**
    Set the proposal threshold for a gov proposal.
    @param _proposalThreshold the proposal threshold for a gov proposal
  */
  function setProposalThreshold(uint256 _proposalThreshold) public override onlyManager {
    require(_proposalThreshold < 1e18);
    proposalThreshold = _proposalThreshold;
  }

  /**
    Get the debt limit for a collateral type
    @dev this is a platform wide limit for new debt issuance against a specific collateral type
    @param _collateralType address of the collateral type
  */
  function collateralDebtLimit(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].debtLimit;
  }

  /**
    Get the liquidation ratio that needs to be maintained for a collateral type to avoid liquidation.
    @param _collateralType address of the collateral type
  */
  function collateralLiquidationRatio(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].liquidationRatio;
  }

  /**
    Get the minimum collateralization ratio for a collateral type for new borrowing or collateral withdrawal.
    @param _collateralType address of the collateral type
  */
  function collateralMinCollateralRatio(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].minCollateralRatio;
  }

  /**
    Get the borrowing rate for a collateral type
    @dev borrowing rate is specified for a 1 sec interval and accurancy is in RAY.
    @param _collateralType address of the collateral type
  */
  function collateralBorrowRate(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].borrowRate;
  }

  /**
    Get the origiation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralOriginationFee(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].originationFee;
  }

  /**
    Get the liquidation bonus for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralLiquidationBonus(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].liquidationBonus;
  }

  /**
    Get the liquidation fee for a collateral type
    @dev this rate is applied as a one time fee for new borrowing and is specified in WAD
    @param _collateralType address of the collateral type
  */
  function collateralLiquidationFee(address _collateralType) public view override returns (uint256) {
    return _collateralConfigs[collateralIds[_collateralType]].liquidationFee;
  }

  /**
    Retreives the entire config for a specific config id.
    @param _id the ID of the conifg to be returned
  */
  function collateralConfigs(uint256 _id) public view override returns (CollateralConfig memory) {
    require(_id <= numCollateralConfigs, ""Invalid config id"");
    return _collateralConfigs[_id];
  }
}",3182
RealWorld_TA_115_BPool_RealWorld_20240815214441.log,115,BPool,65384,2508,67892,124.0,0.37708,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface BPool is IERC20 {
  function gulp(address token) external;

  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;

  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;

  function swapExactAmountIn(
    address tokenIn,
    uint256 tokenAmountIn,
    address tokenOut,
    uint256 minAmountOut,
    uint256 maxPrice
  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);

  function swapExactAmountOut(
    address tokenIn,
    uint256 maxAmountIn,
    address tokenOut,
    uint256 tokenAmountOut,
    uint256 maxPrice
  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);

  function joinswapExternAmountIn(
    address tokenIn,
    uint256 tokenAmountIn,
    uint256 minPoolAmountOut
  ) external returns (uint256 poolAmountOut);

  function joinswapPoolAmountOut(
    address tokenIn,
    uint256 poolAmountOut,
    uint256 maxAmountIn
  ) external returns (uint256 tokenAmountIn);

  function exitswapPoolAmountIn(
    address tokenOut,
    uint256 poolAmountIn,
    uint256 minAmountOut
  ) external returns (uint256 tokenAmountOut);

  function exitswapExternAmountOut(
    address tokenOut,
    uint256 tokenAmountOut,
    uint256 maxPoolAmountIn
  ) external returns (uint256 poolAmountIn);

  function calcPoolOutGivenSingleIn(
    uint256 tokenBalanceIn,
    uint256 tokenWeightIn,
    uint256 poolSupply,
    uint256 totalWeight,
    uint256 tokenAmountIn,
    uint256 swapFee
  ) external pure returns (uint256 poolAmountOut);

  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);

  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);

  function getSwapFee() external view returns (uint256);

  function getBalance(address token) external view returns (uint256);

  function getDenormalizedWeight(address token) external view returns (uint256);

  function getTotalDenormalizedWeight() external view returns (uint256);

  function getNormalizedWeight(address token) external view returns (uint256);

  function isPublicSwap() external view returns (bool);

  function isFinalized() external view returns (bool);
}",568
RealWorld_TA_115_MathPow_RealWorld_20240815225125.log,115,MathPow,28320,1540,29860,89.0,0.1724,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

library MathPow {
  function pow(uint256 x, uint256 n) internal pure returns (uint256 z) {
    z = n % 2 != 0 ? x : 1;

    for (n /= 2; n != 0; n /= 2) {
      x = x*x; 

      if (n % 2 != 0) {
        z = z*x;
      }
    }
  }
}",121
RealWorld_TA_115_USDX_RealWorld_20240815192222.log,115,USDX,38260,2092,40352,108.0,0.23314,"// solium-disable security/no-block-members
// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/ISTABLEX.sol"";

/**
 * @title   USDX
 * @notice  Stablecoin which can be minted against collateral in a vault
 */
contract USDX is ISTABLEX, ERC20(""USD Stablecoin"", ""USDX"") {
  IAddressProvider public override a;

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  function mint(address account, uint256 amount) public override onlyMinter {
    _mint(account, amount);
  }

  function burn(address account, uint256 amount) public override onlyMinter {
    _burn(account, amount);
  }

  modifier onlyMinter() {
    require(a.controller().hasRole(a.controller().MINTER_ROLE(), msg.sender), ""Caller is not a minter"");
    _;
  }
}",237
RealWorld_TA_115_RepayVault_RealWorld_20240815202907.log,115,RepayVault,52530,4118,56648,126.0,0.34501,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";
import ""../interfaces/IVaultsCore.sol"";

contract RepayVault {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;

  uint256 public constant REPAY_PER_VAULT = 10 ether;

  IAddressProvider public a;

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));

    a = _addresses;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  function repay() public onlyManager {
    IVaultsCore core = a.core();
    IVaultsDataProvider vaultsData = a.vaultsData();
    uint256 vaultCount = a.vaultsData().vaultCount();

    for (uint256 vaultId = 1; vaultId <= vaultCount; vaultId++) {
      uint256 baseDebt = vaultsData.vaultBaseDebt(vaultId);

      //if (vaultId==28 || vaultId==29 || vaultId==30 || vaultId==31 || vaultId==32 || vaultId==33 || vaultId==35){
      //  continue;
      //}

      if (baseDebt == 0) {
        continue;
      }

      core.repay(vaultId, REPAY_PER_VAULT);
    }

    IERC20 par = IERC20(a.stablex());
    par.safeTransfer(msg.sender, par.balanceOf(address(this)));
  }
}",405
RealWorld_TA_115_PARMinerV2_RealWorld_20240815200226.log,115,PARMinerV2,361015,5429,366444,190.0,1.913655,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IGenericMinerV2.sol"";
import ""../../dex/interfaces/IDexAddressProvider.sol"";
import ""../../interfaces/IVaultsDataProvider.sol"";
import ""../../libraries/ABDKMath64x64.sol"";
import ""../../libraries/WadRayMath.sol"";

contract PARMinerV2 is IGenericMinerV2 {
  using ABDKMath64x64 for int128;
  using ABDKMath64x64 for uint256;
  using SafeMath for uint256;
  using SafeERC20 for IERC20;
  using WadRayMath for uint256;

  IERC20 internal _par;
  IGovernanceAddressProvider internal _a;
  IDexAddressProvider internal immutable _dexAP;

  BoostConfig internal _boostConfig;

  mapping(address => UserInfo) internal _users;

  uint256 internal _totalStake;
  uint256 internal _totalStakeWithBoost;
  uint256 internal _liquidateCallerReward;

  uint256 internal _mimoBalanceTracker;
  uint256 internal _accMimoAmountPerShare;

  uint256 internal _parBalanceTracker;
  uint256 internal _accParAmountPerShare;

  modifier onlyManager {
    require(_a.parallel().controller().hasRole(_a.parallel().controller().MANAGER_ROLE(), msg.sender), ""LM010"");
    _;
  }

  constructor(
    IGovernanceAddressProvider govAP,
    IDexAddressProvider dexAP,
    BoostConfig memory boostConfig
  ) public {
    require(address(govAP) != address(0), ""LM000"");
    require(address(dexAP) != address(0), ""LM000"");
    require(boostConfig.a >= 1 && boostConfig.d > 0 && boostConfig.maxBoost >= 1, ""LM004"");
    _a = govAP;
    _dexAP = dexAP;
    _liquidateCallerReward = 200 ether;

    _par = IERC20(govAP.parallel().stablex());
    _par.approve(address(_a.parallel().core()), uint256(-1));

    _boostConfig = boostConfig;

    emit BoostConfigSet(boostConfig);
  }

  /**
    Sets new boost config
    @dev can only be called by protocol manager
    @param newBoostConfig contains all boost multiplier parameters, see {IGenericMinerV2 - BoostConfig}
   */
  function setBoostConfig(BoostConfig memory newBoostConfig) external onlyManager {
    require(newBoostConfig.a >= 1 && newBoostConfig.d > 0 && newBoostConfig.maxBoost >= 1, ""LM004"");
    _boostConfig = newBoostConfig;

    emit BoostConfigSet(_boostConfig);
  }

  /**
    Sets liquidation call reward amount
    @dev can only be called by protocol manager
    @param amount the amount to reward liquidate method callers with
   */
  function setLiquidateCallerReward(uint256 amount) external onlyManager {
    _liquidateCallerReward = amount;
  }

  /**
    Deposit an ERC20 pool token for staking
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20
    @param amount the amount of tokens to be deposited. Unit is in WEI
  **/
  function deposit(uint256 amount) public {
    _par.safeTransferFrom(msg.sender, address(this), amount);
    _increaseStake(msg.sender, amount);
  }

  /**
    Withdraw staked ERC20 pool tokens. Will fail if user does not have enough tokens staked
    @param amount the amount of tokens to be withdrawn. Unit is in WEI
  **/
  function withdraw(uint256 amount) public {
    _par.safeTransfer(msg.sender, amount);
    _decreaseStake(msg.sender, amount);
  }

  /**
    Liquidate a vault with a specific amount, and sell collaterall back to PAR
    @param vaultId the ID of the vault to be liquidated
    @param amount the amount of debt+liquidationFee to repay
    @param dexIndex the index of dex in dex address provider mapping
    @param dexTxData the tx data used to sell collateral back to PAR
  **/
  function liquidate(
    uint256 vaultId,
    uint256 amount,
    uint256 dexIndex,
    bytes calldata dexTxData
  ) public {
    uint256 parBalanceBefore = _par.balanceOf(address(this));

    IVaultsDataProvider.Vault memory vault = _a.parallel().vaultsData().vaults(vaultId);
    IERC20 collateralToken = IERC20(vault.collateralType);
    _a.parallel().core().liquidatePartial(vaultId, amount);

    (address proxy, address router) = _dexAP.dexMapping(dexIndex);
    collateralToken.approve(proxy, collateralToken.balanceOf(address(this)));
    router.call(dexTxData);
    _par.safeTransfer(msg.sender, _liquidateCallerReward);
    require(_par.balanceOf(address(this)) > parBalanceBefore, ""LM104"");
    _refreshPAR(_totalStake);
  }

  /**
    Releases outstanding rewards balances to the user
    @param _user the address of the user for which the reward tokens will be released
  */
  function releaseRewards(address _user) public override {
    UserInfo memory _userInfo = _users[_user];
    _releaseRewards(_user, _userInfo, _totalStake, false);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(_user, _userInfo);
  }

  /**
    Restakes the outstanding PAR reward balance to the user. Instead of sending the PAR to the user, it will be added to their stake
    @param _user the address of the user for which the PAR tokens will be restaked
  */
  function restakePAR(address _user) public {
    UserInfo storage userInfo = _users[_user];
    _refresh();
    _refreshPAR(_totalStake);
    uint256 pendingPAR = userInfo.stakeWithBoost.rayMul(_accParAmountPerShare.sub(userInfo.accParAmountPerShare));
    _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    userInfo.accParAmountPerShare = _accParAmountPerShare;

    _increaseStake(_user, pendingPAR);
  }

  /**
    Reapplies the boost of the user, useful a whale's vMIMO has decreased but their boost is still the original value
  */
  function updateBoost(address _user) public {
    UserInfo memory userInfo = _users[_user];
    _updateBoost(_user, userInfo);
  }

  /**
    Returns the number of tokens a user has staked
    @param _user the address of the user
    @return number of staked tokens
  */
  function stake(address _user) public view override returns (uint256) {
    return _users[_user].stake;
  }

  /**
    Returns the number of tokens a user has staked with the boost
    @param _user the address of the user
    @return number of staked tokens with boost
  */
  function stakeWithBoost(address _user) public view override returns (uint256) {
    return _users[_user].stakeWithBoost;
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`
    @param _user the address of the user
    @return number of MIMO tokens that the user can claim
  */
  function pendingMIMO(address _user) public view override returns (uint256) {
    UserInfo memory _userInfo = _users[_user];
    return _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @param _user the address of the user
    @return nnumber of PAR tokens that will be sent automatically when staking/unstaking
  */
  function pendingPAR(address _user) public view override returns (uint256) {
    UserInfo memory _userInfo = _users[_user];
    uint256 currentBalance = _par.balanceOf(address(this)).sub(_totalStake);
    uint256 reward = currentBalance.sub(_parBalanceTracker);
    uint256 accParAmountPerShare = _accParAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));

    return _pendingPAR(accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
  }

  function par() public view override returns (IERC20) {
    return _par;
  }

  function a() public view override returns (IGovernanceAddressProvider) {
    return _a;
  }

  function boostConfig() public view override returns (BoostConfig memory) {
    return _boostConfig;
  }

  function totalStake() public view override returns (uint256) {
    return _totalStake;
  }

  function totalStakeWithBoost() public view override returns (uint256) {
    return _totalStakeWithBoost;
  }

  function liquidateCallerReward() public view returns (uint256) {
    return _liquidateCallerReward;
  }

  /**
    Returns the userInfo stored of a user
    @param _user the address of the user
    @return `struct UserInfo {
      uint256 stake;
      uint256 stakeWithBoost;
      uint256 accAmountPerShare;
      uint256 accParAmountPerShare;
    }`
  **/
  function userInfo(address _user) public view override returns (UserInfo memory) {
    return _users[_user];
  }

  /**
    Refreshes the global state and subsequently increases a user's stake
    This is an internal call and meant to be called within derivative contracts
    @param _user the address of the user
    @param _value the amount by which the stake will be increased
  */
  function _increaseStake(address _user, uint256 _value) internal {
    require(_value > 0, ""LM101"");

    UserInfo memory _userInfo = _users[_user];

    uint256 newTotalStake = _totalStake.add(_value);

    _releaseRewards(_user, _userInfo, newTotalStake, true);
    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
    _totalStake = newTotalStake;
    _userInfo.stake = _userInfo.stake.add(_value);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;

    if (pendingPAR > 0) {
      _userInfo.stake = _userInfo.stake.add(pendingPAR);
      _totalStake = _totalStake.add(pendingPAR);
    }

    _updateBoost(_user, _userInfo);

    emit StakeIncreased(_user, _value.add(pendingPAR));
  }

  /**
    Refreshes the global state and subsequently decreases the stake a user has
    This is an internal call and meant to be called within derivative contracts
    @param _user the address of the user
    @param _value the amount by which the stake will be reduced
  */
  function _decreaseStake(address _user, uint256 _value) internal {
    require(_value > 0, ""LM101"");
    UserInfo memory _userInfo = _users[_user];
    require(_userInfo.stake >= _value, ""LM102"");

    uint256 newTotalStake = _totalStake.sub(_value);

    _releaseRewards(_user, _userInfo, newTotalStake, false);
    _totalStake = newTotalStake;
    _userInfo.stake = _userInfo.stake.sub(_value);
    _userInfo.accAmountPerShare = _accMimoAmountPerShare;
    _userInfo.accParAmountPerShare = _accParAmountPerShare;
    _updateBoost(_user, _userInfo);

    emit StakeDecreased(_user, _value);
  }

  /**
    Releases outstanding rewards balances to the user
    @param _user the address of the user for which the reward tokens will be released
  */
  function _releaseRewards(
    address _user,
    UserInfo memory _userInfo,
    uint256 _newTotalStake,
    bool _restakePAR
  ) internal {
    uint256 pendingMIMO = _pendingMIMO(_userInfo.stakeWithBoost, _userInfo.accAmountPerShare);
    _refresh();
    _refreshPAR(_newTotalStake);
    uint256 pendingPAR = _pendingPAR(_accParAmountPerShare, _userInfo.stakeWithBoost, _userInfo.accParAmountPerShare);
    if (_userInfo.stakeWithBoost > 0) {
      _mimoBalanceTracker = _mimoBalanceTracker.sub(pendingMIMO);
      _parBalanceTracker = _parBalanceTracker.sub(pendingPAR);
    }

    if (pendingPAR > 0 && !_restakePAR) {
      require(_par.transfer(_user, pendingPAR), ""LM100"");
    }
    if (pendingMIMO > 0) {
      require(_a.mimo().transfer(_user, pendingMIMO), ""LM100"");
    }
  }

  /**
    Updates the internal state variables based on user's veMIMO hodlings
    @param _user the address of the user
   */
  function _updateBoost(address _user, UserInfo memory _userInfo) internal {
    // if user had a boost already, first remove it from the totalStakeWithBoost
    if (_userInfo.stakeWithBoost > 0) {
      _totalStakeWithBoost = _totalStakeWithBoost.sub(_userInfo.stakeWithBoost);
    }
    uint256 multiplier = _getBoostMultiplier(_user);
    _userInfo.stakeWithBoost = _userInfo.stake.wadMul(multiplier);
    _totalStakeWithBoost = _totalStakeWithBoost.add(_userInfo.stakeWithBoost);
    _users[_user] = _userInfo;
  }

  /**
    Updates the internal state variables after accounting for newly received MIMO tokens
  */
  function _refresh() internal {
    if (_totalStake == 0) {
      return;
    }
    uint256 currentMimoBalance = _a.mimo().balanceOf(address(this));
    uint256 mimoReward = currentMimoBalance.sub(_mimoBalanceTracker);
    _mimoBalanceTracker = currentMimoBalance;
    _accMimoAmountPerShare = _accMimoAmountPerShare.add(mimoReward.rayDiv(_totalStakeWithBoost));
  }

  /**
    Updates the internal state variables after accounting for newly received PAR tokens
    @dev need to pass updated stake as arg because reward token and stake token are the same
    @param newTotalStake updated total stake in PAR tokens
  */
  function _refreshPAR(uint256 newTotalStake) internal {
    if (_totalStake == 0) {
      return;
    }
    uint256 currentParBalance = _par.balanceOf(address(this)).sub(newTotalStake);
    uint256 parReward = currentParBalance.sub(_parBalanceTracker);

    _parBalanceTracker = currentParBalance;
    _accParAmountPerShare = _accParAmountPerShare.add(parReward.rayDiv(_totalStakeWithBoost));
  }

  /**
    Returns the number of tokens a user can claim via `releaseMIMO`
    @return number of MIMO tokens that the user can claim
  */
  function _pendingMIMO(uint256 _userStakeWithBoost, uint256 _userAccAmountPerShare) internal view returns (uint256) {
    if (_totalStakeWithBoost == 0) {
      return 0;
    }
    uint256 currentBalance = _a.mimo().balanceOf(address(this));
    uint256 reward = currentBalance.sub(_mimoBalanceTracker);
    uint256 accMimoAmountPerShare = _accMimoAmountPerShare.add(reward.rayDiv(_totalStakeWithBoost));
    return _userStakeWithBoost.rayMul(accMimoAmountPerShare.sub(_userAccAmountPerShare));
  }

  /**
    Returns the number of PAR tokens the user has earned as a reward
    @return number of PAR tokens that will be sent automatically when staking/unstaking
  */
  function _pendingPAR(
    uint256 accParAmountPerShare,
    uint256 _userStakeWithBoost,
    uint256 _userAccParAmountPerShare
  ) internal view returns (uint256) {
    if (_totalStakeWithBoost == 0) {
      return 0;
    }
    return _userStakeWithBoost.rayMul(accParAmountPerShare.sub(_userAccParAmountPerShare));
  }

  /**
    Returns the boost multiplier the user is eligible for
    @param _user the address of the user
    @return the boost multuplie based on the user's veMIMO per the boost formula : a + b / (c + e^-((veMIMO / d) - e))
   */
  function _getBoostMultiplier(address _user) internal view returns (uint256) {
    uint256 veMIMO = _a.votingEscrow().balanceOf(_user);

    if (veMIMO == 0) return 1e18;

    // Convert boostConfig variables to signed 64.64-bit fixed point numbers
    int128 a = ABDKMath64x64.fromUInt(_boostConfig.a);
    int128 b = ABDKMath64x64.fromUInt(_boostConfig.b);
    int128 c = ABDKMath64x64.fromUInt(_boostConfig.c);
    int128 e = ABDKMath64x64.fromUInt(_boostConfig.e);
    int128 DECIMALS = ABDKMath64x64.fromUInt(1e18);

    int128 e1 = veMIMO.divu(_boostConfig.d); // x/25000
    int128 e2 = e1.sub(e); // x/25000 - 6
    int128 e3 = e2.neg(); // -(x/25000 - 6)
    int128 e4 = e3.exp(); // e^-(x/25000 - 6)
    int128 e5 = e4.add(c); // 1 + e^-(x/25000 - 6)
    int128 e6 = b.div(e5).add(a); // 1 + 3/(1 + e^-(x/25000 - 6))
    uint64 e7 = e6.mul(DECIMALS).toUInt(); // convert back to uint64
    uint256 multiplier = uint256(e7); // convert to uint256

    require(multiplier >= 1e18 && multiplier <= _boostConfig.maxBoost, ""LM103"");

    return multiplier;
  }
}",4068
RealWorld_TA_115_VotingMiner_RealWorld_20240815192412.log,115,VotingMiner,45867,3576,49443,118.0,0.300855,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./GenericMiner.sol"";
import ""./interfaces/IVotingMiner.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../governance/interfaces/IVotingEscrow.sol"";

contract VotingMiner is IVotingMiner, GenericMiner {
  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}

  /**
    Releases the outstanding MIMO balance to the user.
    @param _user the address of the user for which the MIMO tokens will be released.
  */
  function releaseMIMO(address _user) public override {
    IVotingEscrow votingEscrow = a.votingEscrow();
    require((msg.sender == _user) || (msg.sender == address(votingEscrow)));

    UserInfo storage userInfo = _users[_user];
    _refresh();
    uint256 pending = userInfo.stake.rayMul(_accAmountPerShare.sub(userInfo.accAmountPerShare));
    _balanceTracker = _balanceTracker.sub(pending);
    userInfo.accAmountPerShare = _accAmountPerShare;

    uint256 votingPower = votingEscrow.balanceOf(_user);
    totalStake = totalStake.add(votingPower).sub(userInfo.stake);
    userInfo.stake = votingPower;

    if (pending > 0) {
      require(a.mimo().transfer(_user, pending));
    }
  }
}",311
RealWorld_TA_115_Timelock_RealWorld_20240815215518.log,115,Timelock,102099,5037,107136,138.0,0.611235,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/ITimelock.sol"";

contract Timelock is ITimelock {
  using SafeMath for uint256;

  uint256 public constant MINIMUM_DELAY = 2 days;
  uint256 public constant MAXIMUM_DELAY = 30 days;
  uint256 public constant override GRACE_PERIOD = 14 days;

  address public admin;
  address public pendingAdmin;
  uint256 public override delay;

  mapping(bytes32 => bool) public override queuedTransactions;

  constructor(address _admin, uint256 _delay) public {
    require(address(_admin) != address(0));
    require(_delay >= MINIMUM_DELAY, ""Timelock::constructor: Delay must exceed minimum delay."");
    require(_delay <= MAXIMUM_DELAY, ""Timelock::setDelay: Delay must not exceed maximum delay."");

    admin = _admin;
    delay = _delay;
  }

  receive() external payable {}

  fallback() external payable {}

  function setDelay(uint256 _delay) public {
    require(msg.sender == address(this), ""Timelock::setDelay: Call must come from Timelock."");
    require(_delay >= MINIMUM_DELAY, ""Timelock::setDelay: Delay must exceed minimum delay."");
    require(_delay <= MAXIMUM_DELAY, ""Timelock::setDelay: Delay must not exceed maximum delay."");
    delay = _delay;

    emit NewDelay(delay);
  }

  function acceptAdmin() public override {
    require(msg.sender == pendingAdmin, ""Timelock::acceptAdmin: Call must come from pendingAdmin."");
    admin = msg.sender;
    pendingAdmin = address(0);

    emit NewAdmin(admin);
  }

  function setPendingAdmin(address _pendingAdmin) public {
    require(msg.sender == address(this), ""Timelock::setPendingAdmin: Call must come from Timelock."");
    pendingAdmin = _pendingAdmin;

    emit NewPendingAdmin(pendingAdmin);
  }

  function queueTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  ) public override returns (bytes32) {
    require(msg.sender == admin, ""Timelock::queueTransaction: Call must come from admin."");
    require(
      eta >= block.timestamp.add(delay),
      ""Timelock::queueTransaction: Estimated execution block must satisfy delay.""
    );

    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
    queuedTransactions[txHash] = true;

    emit QueueTransaction(txHash, target, value, signature, data, eta);
    return txHash;
  }

  function cancelTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  ) public override {
    require(msg.sender == admin, ""Timelock::cancelTransaction: Call must come from admin."");

    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
    queuedTransactions[txHash] = false;

    emit CancelTransaction(txHash, target, value, signature, data, eta);
  }

  function executeTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  ) public payable override returns (bytes memory) {
    require(msg.sender == admin, ""Timelock::executeTransaction: Call must come from admin."");

    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
    require(queuedTransactions[txHash], ""Timelock::executeTransaction: Transaction hasn't been queued."");
    require(block.timestamp >= eta, ""Timelock::executeTransaction: Transaction hasn't surpassed time lock."");
    require(block.timestamp <= eta.add(GRACE_PERIOD), ""Timelock::executeTransaction: Transaction is stale."");

    queuedTransactions[txHash] = false;

    bytes memory callData;

    if (bytes(signature).length == 0) {
      callData = data;
    } else {
      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
    }

    // solium-disable-next-line security/no-call-value
    (bool success, bytes memory returnData) = target.call{ value: value }(callData);
    require(success, ""Timelock::executeTransaction: Transaction execution reverted."");

    emit ExecuteTransaction(txHash, target, value, signature, data, eta);

    return returnData;
  }
}",967
RealWorld_TA_115_IVaultsDataProvider_RealWorld_20240815221803.log,115,IVaultsDataProvider,48272,2237,50509,100.0,0.2861,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;
import ""../interfaces/IAddressProvider.sol"";

interface IVaultsDataProvider {
  struct Vault {
    // borrowedType support USDX / PAR
    address collateralType;
    address owner;
    uint256 collateralBalance;
    uint256 baseDebt;
    uint256 createdAt;
  }

  //Write
  function createVault(address _collateralType, address _owner) external returns (uint256);

  function setCollateralBalance(uint256 _id, uint256 _balance) external;

  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;

  // Read
  function a() external view returns (IAddressProvider);

  function baseDebt(address _collateralType) external view returns (uint256);

  function vaultCount() external view returns (uint256);

  function vaults(uint256 _id) external view returns (Vault memory);

  function vaultOwner(uint256 _id) external view returns (address);

  function vaultCollateralType(uint256 _id) external view returns (address);

  function vaultCollateralBalance(uint256 _id) external view returns (uint256);

  function vaultBaseDebt(uint256 _id) external view returns (uint256);

  function vaultId(address _collateralType, address _owner) external view returns (uint256);

  function vaultExists(uint256 _id) external view returns (bool);

  function vaultDebt(uint256 _vaultId) external view returns (uint256);

  function debt() external view returns (uint256);

  function collateralDebt(address _collateralType) external view returns (uint256);
}",358
RealWorld_TA_115_AddressProvider_RealWorld_20240815204350.log,115,AddressProvider,71368,2240,73608,94.0,0.40164,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IAccessController.sol"";
import ""../interfaces/IConfigProvider.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""../interfaces/IPriceFeed.sol"";
import ""../interfaces/IRatesManager.sol"";
import ""../interfaces/ILiquidationManager.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";

contract AddressProvider is IAddressProvider {
  IAccessController public override controller;
  IConfigProvider public override config;
  IVaultsCore public override core;

  ISTABLEX public override stablex;
  IRatesManager public override ratesManager;
  IPriceFeed public override priceFeed;
  ILiquidationManager public override liquidationManager;
  IVaultsDataProvider public override vaultsData;
  IFeeDistributor public override feeDistributor;

  constructor(IAccessController _controller) public {
    controller = _controller;
  }

  modifier onlyManager() {
    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  function setAccessController(IAccessController _controller) public override onlyManager {
    require(address(_controller) != address(0));
    controller = _controller;
  }

  function setConfigProvider(IConfigProvider _config) public override onlyManager {
    require(address(_config) != address(0));
    config = _config;
  }

  function setVaultsCore(IVaultsCore _core) public override onlyManager {
    require(address(_core) != address(0));
    core = _core;
  }

  function setStableX(ISTABLEX _stablex) public override onlyManager {
    require(address(_stablex) != address(0));
    stablex = _stablex;
  }

  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {
    require(address(_ratesManager) != address(0));
    ratesManager = _ratesManager;
  }

  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {
    require(address(_liquidationManager) != address(0));
    liquidationManager = _liquidationManager;
  }

  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {
    require(address(_priceFeed) != address(0));
    priceFeed = _priceFeed;
  }

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {
    require(address(_vaultsData) != address(0));
    vaultsData = _vaultsData;
  }

  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {
    require(address(_feeDistributor) != address(0));
    feeDistributor = _feeDistributor;
  }
}",624
RealWorld_TA_115_GUniLPOracle_RealWorld_20240815205607.log,115,GUniLPOracle,109056,2573,111629,102.0,0.59674,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../chainlink/AggregatorV3Interface.sol"";
import ""../interfaces/IGUniPool.sol"";
import ""../libraries/MathPow.sol"";

contract GUniLPOracle is AggregatorV3Interface {
  using SafeMath for uint256;

  string public override description;
  uint256 public override version = 3;
  uint8 public override decimals;

  IGUniPool public immutable pool;
  AggregatorV3Interface public immutable oracleA;
  AggregatorV3Interface public immutable oracleB;

  uint256 private immutable _tokenDecimalsUnitA;
  uint256 private immutable _tokenDecimalsOffsetA;
  uint256 private immutable _tokenDecimalsUnitB;
  uint256 private immutable _tokenDecimalsOffsetB;

  constructor(
    uint8 _decimals,
    string memory _description,
    IGUniPool _pool,
    AggregatorV3Interface _oracleA,
    AggregatorV3Interface _oracleB
  ) public {
    require(address(_pool) != address(0), ""C000"");
    require(address(_oracleA) != address(0), ""C000"");
    require(address(_oracleB) != address(0), ""C000"");

    decimals = _decimals;
    description = _description;
    pool = _pool;
    oracleA = _oracleA;
    oracleB = _oracleB;

    uint256 decimalsA = ERC20(_pool.token0()).decimals();
    _tokenDecimalsUnitA = 10**decimalsA;
    _tokenDecimalsOffsetA = 10**(18 - decimalsA);

    uint256 decimalsB = ERC20(_pool.token1()).decimals();
    _tokenDecimalsUnitB = 10**decimalsB;
    _tokenDecimalsOffsetB = 10**(18 - decimalsB);
  }

  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    // Skip the implementation since it is not used by price feed
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    (, int256 answerA, , uint256 assetUpdatedAtA, ) = oracleA.latestRoundData();
    (, int256 answerB, , uint256 assetUpdatedAtB, ) = oracleB.latestRoundData();
    uint256 priceA = uint256(answerA);
    uint256 priceB = uint256(answerB);
    uint160 sqrtPriceX96 = uint160(
      MathPow.sqrt((priceA.mul(_tokenDecimalsUnitB).mul(1 << 96)) / (priceB.mul(_tokenDecimalsUnitA))) << 48
    );

    (uint256 rA, uint256 rB) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);
    require(rA > 0 || rB > 0, ""C100"");
    uint256 totalSupply = pool.totalSupply();
    require(totalSupply >= 1e9, ""C101"");

    answer = int256(
      priceA.mul(rA.mul(_tokenDecimalsOffsetA)).add(priceB.mul(rB.mul(_tokenDecimalsOffsetB))).div(totalSupply)
    );
    updatedAt = assetUpdatedAtA;

    // use ealier time for updateAt
    if (assetUpdatedAtA > assetUpdatedAtB) {
      updatedAt = assetUpdatedAtB;
    }
  }
}",1080
RealWorld_TA_115_VaultsDataProvider_RealWorld_20240815205145.log,115,VaultsDataProvider,157649,3510,161159,129.0,0.858445,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";
import ""../interfaces/IAddressProvider.sol"";

contract VaultsDataProvider is IVaultsDataProvider {
  using SafeMath for uint256;

  IAddressProvider public override a;

  uint256 public override vaultCount = 0;

  mapping(address => uint256) public override baseDebt;

  mapping(uint256 => Vault) private _vaults;
  mapping(address => mapping(address => uint256)) private _vaultOwners;

  modifier onlyVaultsCore() {
    require(msg.sender == address(a.core()), ""Caller is not VaultsCore"");
    _;
  }

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Opens a new vault.
    @dev only the vaultsCore module can call this function
    @param _collateralType address to the collateral asset e.g. WETH
    @param _owner the owner of the new vault.
  */
  function createVault(address _collateralType, address _owner) public override onlyVaultsCore returns (uint256) {
    require(_collateralType != address(0));
    require(_owner != address(0));
    uint256 newId = ++vaultCount;
    require(_collateralType != address(0), ""collateralType unknown"");
    Vault memory v = Vault({
      collateralType: _collateralType,
      owner: _owner,
      collateralBalance: 0,
      baseDebt: 0,
      createdAt: block.timestamp
    });
    _vaults[newId] = v;
    _vaultOwners[_owner][_collateralType] = newId;
    return newId;
  }

  /**
    Set the collateral balance of a vault.
    @dev only the vaultsCore module can call this function
    @param _id Vault ID of which the collateral balance will be updated
    @param _balance the new balance of the vault.
  */
  function setCollateralBalance(uint256 _id, uint256 _balance) public override onlyVaultsCore {
    require(vaultExists(_id), ""Vault not found."");
    Vault storage v = _vaults[_id];
    v.collateralBalance = _balance;
  }

  /**
    Set the base debt of a vault.
    @dev only the vaultsCore module can call this function
    @param _id Vault ID of which the base debt will be updated
    @param _newBaseDebt the new base debt of the vault.
  */
  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) public override onlyVaultsCore {
    Vault storage _vault = _vaults[_id];
    if (_newBaseDebt > _vault.baseDebt) {
      uint256 increase = _newBaseDebt.sub(_vault.baseDebt);
      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].add(increase);
    } else {
      uint256 decrease = _vault.baseDebt.sub(_newBaseDebt);
      baseDebt[_vault.collateralType] = baseDebt[_vault.collateralType].sub(decrease);
    }
    _vault.baseDebt = _newBaseDebt;
  }

  /**
    Get a vault by vault ID.
    @param _id The vault's ID to be retrieved
    @return struct Vault {
      address collateralType;
      address owner;
      uint256 collateralBalance;
      uint256 baseDebt;
      uint256 createdAt;
    }
  */
  function vaults(uint256 _id) public view override returns (Vault memory) {
    Vault memory v = _vaults[_id];
    return v;
  }

  /**
    Get the owner of a vault.
    @param _id the ID of the vault
    @return owner of the vault
  */
  function vaultOwner(uint256 _id) public view override returns (address) {
    return _vaults[_id].owner;
  }

  /**
    Get the collateral type of a vault.
    @param _id the ID of the vault
    @return address for the collateral type of the vault
  */
  function vaultCollateralType(uint256 _id) public view override returns (address) {
    return _vaults[_id].collateralType;
  }

  /**
    Get the collateral balance of a vault.
    @param _id the ID of the vault
    @return collateral balance of the vault
  */
  function vaultCollateralBalance(uint256 _id) public view override returns (uint256) {
    return _vaults[_id].collateralBalance;
  }

  /**
    Get the base debt of a vault.
    @param _id the ID of the vault
    @return base debt of the vault
  */
  function vaultBaseDebt(uint256 _id) public view override returns (uint256) {
    return _vaults[_id].baseDebt;
  }

  /**
    Retrieve the vault id for a specified owner and collateral type.
    @dev returns 0 for non-existing vaults
    @param _collateralType address of the collateral type (Eg: WETH)
    @param _owner address of the owner of the vault
    @return vault id of the vault or 0
  */
  function vaultId(address _collateralType, address _owner) public view override returns (uint256) {
    return _vaultOwners[_owner][_collateralType];
  }

  /**
    Checks if a specified vault exists.
    @param _id the ID of the vault
    @return boolean if the vault exists
  */
  function vaultExists(uint256 _id) public view override returns (bool) {
    Vault memory v = _vaults[_id];
    return v.collateralType != address(0);
  }

  /**
    Calculated the total outstanding debt for all vaults and all collateral types.
    @dev uses the existing cumulative rate. Call `refresh()` on `VaultsCore`
    to make sure it's up to date.
    @return total debt of the platform
  */
  function debt() public view override returns (uint256) {
    uint256 total = 0;
    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      total = total.add(collateralDebt(collateralType));
    }
    return total;
  }

  /**
    Calculated the total outstanding debt for all vaults of a specific collateral type.
    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`
    to make sure it's up to date.
    @param _collateralType address of the collateral type (Eg: WETH)
    @return total debt of the platform of one collateral type
  */
  function collateralDebt(address _collateralType) public view override returns (uint256) {
    return a.ratesManager().calculateDebt(baseDebt[_collateralType], a.core().cumulativeRates(_collateralType));
  }

  /**
    Calculated the total outstanding debt for a specific vault.
    @dev uses the existing cumulative rate. Call `refreshCollateral()` on `VaultsCore`
    to make sure it's up to date.
    @param _vaultId the ID of the vault
    @return total debt of one vault
  */
  function vaultDebt(uint256 _vaultId) public view override returns (uint256) {
    IVaultsDataProvider.Vault memory v = _vaults[_vaultId];
    return a.ratesManager().calculateDebt(v.baseDebt, a.core().cumulativeRates(v.collateralType));
  }
}",1671
RealWorld_TA_115_FeeDistributorV1_RealWorld_20240815185850.log,115,FeeDistributorV1,100610,4762,105372,136.0,0.59829,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../interfaces/ISTABLEX.sol"";
import ""./interfaces/IFeeDistributorV1.sol"";
import ""./interfaces/IAddressProviderV1.sol"";

contract FeeDistributorV1 is IFeeDistributorV1, ReentrancyGuard {
  using SafeMath for uint256;

  event PayeeAdded(address account, uint256 shares);
  event FeeReleased(uint256 income, uint256 releasedAt);

  uint256 public override lastReleasedAt;
  IAddressProviderV1 public override a;

  uint256 public override totalShares;
  mapping(address => uint256) public override shares;
  address[] public payees;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  constructor(IAddressProviderV1 _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /**
    Public function to release the accumulated fee income to the payees.
    @dev anyone can call this.
  */
  function release() public override nonReentrant {
    uint256 income = a.core().availableIncome();
    require(income > 0, ""income is 0"");
    require(payees.length > 0, ""Payees not configured yet"");
    lastReleasedAt = now;

    // Mint USDX to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(income, payee);
    }
    emit FeeReleased(income, lastReleasedAt);
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view override returns (address[] memory) {
    return payees;
  }

  /**
    Internal function to release a percentage of income to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalIncomeReceived Total income for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalIncomeReceived, address _payee) internal {
    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);
    a.stablex().mint(_payee, payment);
  }

  /**
    Internal function to add a new payee.
    @dev will update totalShares and therefore reduce the relative share of all other payees.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""payee is the zero address"");
    require(_shares > 0, ""shares are 0"");
    require(shares[_payee] == 0, ""payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");
    require(_payees.length > 0, ""No payees"");

    uint256 income = a.core().availableIncome();
    if (income > 0 && payees.length > 0) {
      release();
    }

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }
    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }
}",960
RealWorld_TA_115_TInceptionVaultHealthy_RealWorld_20240815224656.log,115,TInceptionVaultHealthy,93747,3815,97562,129.0,0.545035,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""./TIVSetup.sol"";

contract TInceptionVaultHealthy is TIVSetup {
  using SafeMath for uint256;

  IInceptionVaultsCore internal _inceptionVaultsCore;
  IInceptionVaultsDataProvider internal _inceptionVaultsDataProvider;
  IAdminInceptionVault internal _adminInceptionVault;
  IInceptionVaultPriceFeed internal _inceptionVaultPriceFeed;

  uint256 internal _initialBaseDebt;
  uint256 internal _adminDepositAmount = 10000000000000000000;
  uint256 internal _adminBorrowAmount = 11000000000000000000000;
  uint256 internal _userDepositAmount = 1000000000000000000000;
  uint256 internal _userBorrowAmount = 7000000000000000000000;

  uint256 internal constant _TEST_VAULT_ID = 1;

  constructor() public TIVSetup() {
    IInceptionVaultFactory.InceptionVault memory iv = _inceptionVaultFactory.inceptionVaults(_TEST_VAULT_ID);
    IAdminInceptionVault a = iv.adminInceptionVault;
    IInceptionVaultsCore v = iv.inceptionVaultsCore;
    IInceptionVaultsDataProvider d = iv.inceptionVaultsDataProvider;
    IInceptionVaultPriceFeed p = iv.inceptionVaultPriceFeed;
    _inceptionVaultsCore = v;
    _inceptionVaultsDataProvider = d;
    _inceptionVaultPriceFeed = p;
    _weth.mint(_echidna_caller, _adminDepositAmount);
    _weth.approve(address(a), _adminDepositAmount);

    // Deposit 10 WETH and borrow 11k PAR
    a.depositAndBorrow(address(_weth), _adminDepositAmount, _adminBorrowAmount);

    _link.mint(_echidna_caller, _userDepositAmount);
    _link.approve(address(v), _userDepositAmount);

    // Deposit 1000k LINK and borrow 7k PAR
    v.depositAndBorrow(_userDepositAmount, _userBorrowAmount);

    _initialBaseDebt = d.vaultBaseDebt(_TEST_VAULT_ID);

    // Approve PAR for liquidation
    _par.approve(address(_inceptionVaultsCore), _MAX_INT);
  }

  /// @notice Checks that a user vault base debt cannot be overwritten
  function echidna_user_base_debt_should_not_change() public view returns (bool) {
    uint256 vaultBaseDebt = _inceptionVaultsDataProvider.vaultBaseDebt(1);
    return vaultBaseDebt == _initialBaseDebt;
  }

  /// @notice Checks that user vault collateral balance cannot be overwritten
  function echidna_user_collateral_balance_should_not_change() public view returns (bool) {
    uint256 collateralBalance = _inceptionVaultsDataProvider.vaultCollateralBalance(1);
    return collateralBalance == _userDepositAmount;
  }

  /// @notice Checks that vault owner cannot be overwritten
  function echidna_vault_owner_should_not_change() public view returns (bool) {
    address vaultOwner = _inceptionVaultsDataProvider.vaultOwner(1);
    return vaultOwner == _echidna_caller;
  }

  /// @notice Checks that an calling liquidate() on unhealthy vault always fails
  function echidna_healthy_vault_should_never_be_open_to_liquidation() public returns (bool) {
    try _inceptionVaultsCore.liquidate(_TEST_VAULT_ID)  {
      return false;
    } catch {
      return true;
    }
  }

  /**
  @notice Checks that an calling liquidatePartial() on unhealthy vault always fails
  @param amount liquidation amount
   */
  function healthy_vault_should_never_be_open_to_liquidation(uint256 amount) public {
    try _inceptionVaultsCore.liquidatePartial(_TEST_VAULT_ID, amount)  {
      assert(false);
    } catch {}
  }
}",881
RealWorld_TA_115_SupplyMinerV2_RealWorld_20240815195835.log,115,SupplyMinerV2,55278,2403,57681,118.0,0.32445,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./GenericMinerV2.sol"";
import ""./interfaces/ISupplyMinerV2.sol"";
import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";

contract SupplyMinerV2 is ISupplyMinerV2, GenericMinerV2 {
  IERC20 private immutable _collateral;

  constructor(
    IGovernanceAddressProvider _addresses,
    BoostConfig memory _boostConfig,
    IERC20 collateral
  ) public GenericMinerV2(_addresses, _boostConfig) {
    require(address(collateral) != address(0), ""LM000"");
    _collateral = collateral;
  }

  modifier onlyNotifier() {
    require(msg.sender == address(_a.debtNotifier()), ""LM020"");
    _;
  }

  /**
    Updates user stake based on current user baseDebt
    @dev this method is for upgradability purposes from an older SupplyMiner to a newer one so the user doesn't have to repay/borrow to set their stake in this SupplyMiner
    @param user address of the user
  */
  function syncStake(address user) external override {
    uint256 vaultId = _a.parallel().vaultsData().vaultId(address(_collateral), user);
    IVaultsDataProvider.Vault memory v = _a.parallel().vaultsData().vaults(vaultId);
    _updateStake(user, v.baseDebt);
  }

  /**
    Gets called by the `DebtNotifier` and will update the stake of the user
    to match his current outstanding debt by using his baseDebt
    @param user address of the user
    @param newBaseDebt the new baseDebt and therefore stake for the user
  */
  function baseDebtChanged(address user, uint256 newBaseDebt) public override onlyNotifier {
    _updateStake(user, newBaseDebt);
  }

  function collateral() public view override returns (IERC20) {
    return _collateral;
  }
}",460
RealWorld_TA_115_IDemandMiner_RealWorld_20240815202300.log,115,IDemandMiner,24454,1782,26236,127.0,0.15791,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IDemandMiner {
  function deposit(uint256 amount) external;

  function withdraw(uint256 amount) external;

  function token() external view returns (IERC20);
}",78
RealWorld_TA_115_MockBalancerPool_RealWorld_20240815183908.log,115,MockBalancerPool,37438,2773,40211,107.0,0.24265,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../interfaces/IBalancerPool.sol"";

contract MockBalancerPool is IBalancerPool {
  address public tokenA;
  address public tokenB;
  uint256 public override totalSupply;
  mapping(address => uint256) public tokenBalances;
  mapping(address => uint256) public tokenWeights;

  constructor(address _tokenA, address _tokenB) public {
    tokenA = _tokenA;
    tokenB = _tokenB;
  }

  function setNormalizedWeight(address token, uint256 weight) public {
    tokenWeights[token] = weight;
  }

  function setTotalSupply(uint256 supply) public {
    totalSupply = supply;
  }

  function getNormalizedWeights() external view override returns (uint256[] memory) {
    uint256[] memory weights = new uint256[](2);
    weights[0] = tokenWeights[tokenA];
    weights[1] = tokenWeights[tokenB];

    return weights;
  }
}",213
RealWorld_TA_115_MockGenericMiner_RealWorld_20240815185053.log,115,MockGenericMiner,29856,2745,32601,99.0,0.20418,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../liquidityMining/GenericMiner.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";

contract MockGenericMiner is GenericMiner {
  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}

  function increaseStake(address user, uint256 value) public {
    _increaseStake(user, value);
  }

  function decreaseStake(address user, uint256 value) public {
    _decreaseStake(user, value);
  }
}",130
RealWorld_TA_115_IWETH_RealWorld_20240815230326.log,115,IWETH,26824,1718,28542,93.0,0.16848,"pragma solidity 0.8.10;

interface IWETH {
  function balanceOf(address user) external view returns (uint256);

  function deposit() external payable;

  function transfer(address to, uint256 value) external returns (bool);

  function approve(address to, uint256 value) external returns (bool);

  function withdraw(uint256) external;

  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) external returns (bool);
}",98
RealWorld_TA_115_IWETH_RealWorld_20240815222118.log,115,IWETH,24810,1863,26673,91.0,0.16131,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

interface IWETH {
  function deposit() external payable;

  function transfer(address to, uint256 value) external returns (bool);

  function withdraw(uint256 wad) external;

  function approve(address guy, uint256 wad) external returns (bool);
}",77
RealWorld_TA_115_SupplyMiner_RealWorld_20240815193946.log,115,SupplyMiner,37497,2078,39575,103.0,0.229045,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./GenericMiner.sol"";
import ""./interfaces/ISupplyMiner.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";

contract SupplyMiner is ISupplyMiner, GenericMiner {
  using SafeMath for uint256;

  constructor(IGovernanceAddressProvider _addresses) public GenericMiner(_addresses) {}

  modifier onlyNotifier() {
    require(msg.sender == address(a.debtNotifier()), ""Caller is not DebtNotifier"");
    _;
  }

  /**
    Gets called by the `DebtNotifier` and will update the stake of the user
    to match his current outstanding debt by using his baseDebt.
    @param user address of the user.
    @param newBaseDebt the new baseDebt and therefore stake for the user.
  */
  function baseDebtChanged(address user, uint256 newBaseDebt) public override onlyNotifier {
    _updateStake(user, newBaseDebt);
  }
}",239
RealWorld_TA_115_ILiquidationManagerV1_RealWorld_20240815191258.log,115,ILiquidationManagerV1,32428,1392,33820,104.0,0.18998,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IAddressProviderV1.sol"";

interface ILiquidationManagerV1 {
  function a() external view returns (IAddressProviderV1);

  function calculateHealthFactor(
    address _collateralType,
    uint256 _collateralValue,
    uint256 _vaultDebt
  ) external view returns (uint256 healthFactor);

  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);

  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);

  function isHealthy(
    address _collateralType,
    uint256 _collateralValue,
    uint256 _vaultDebt
  ) external view returns (bool);
}",170
RealWorld_TA_115_MockChainlinkFeed_RealWorld_20240815184646.log,115,MockChainlinkFeed,103547,3152,106699,118.0,0.580775,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""../chainlink/AggregatorV3Interface.sol"";

contract MockChainlinkFeed is AggregatorV3Interface, Ownable {
  uint256 private _latestPrice;
  string public override description;
  uint256 public override version = 3;

  uint8 public override decimals;

  constructor(
    uint8 _decimals,
    uint256 _price,
    string memory _description
  ) public {
    decimals = _decimals;
    _latestPrice = _price;
    description = _description;
  }

  function setLatestPrice(uint256 price) public onlyOwner {
    require(price > 110033500); // > 1.1 USD
    require(price < 130033500); // > 1.3 USD
    _latestPrice = price;
  }

  /**
   * @notice get data about a round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @param _roundId the requested round ID as presented through the proxy, this
   * is made up of the aggregator's round ID with the phase ID encoded in the
   * two highest order bytes
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function getRoundData(uint80 _roundId)
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    roundId = uint80(_roundId);
    answer = int256(_latestPrice);
    startedAt = uint256(1597422127);
    updatedAt = uint256(1597695228);
    answeredInRound = uint80(_roundId);
  }

  /**
   * @notice get data about the latest round. Consumers are encouraged to check
   * that they're receiving fresh data by inspecting the updatedAt and
   * answeredInRound return values.
   * Note that different underlying implementations of AggregatorV3Interface
   * have slightly different semantics for some of the return values. Consumers
   * should determine what implementations they expect to receive
   * data from and validate that they can properly handle return data from all
   * of them.
   * @return roundId is the round ID from the aggregator for which the data was
   * retrieved combined with an phase to ensure that round IDs get larger as
   * time moves forward.
   * @return answer is the answer for the given round
   * @return startedAt is the timestamp when the round was started.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @return updatedAt is the timestamp when the round last was updated (i.e.
   * answer was last computed)
   * @return answeredInRound is the round ID of the round in which the answer
   * was computed.
   * (Only some AggregatorV3Interface implementations return meaningful values)
   * @dev Note that answer and updatedAt may change between queries.
   */
  function latestRoundData()
    public
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    uint256 latestRound = 101;
    roundId = uint80(latestRound);
    answer = int256(_latestPrice);
    startedAt = uint256(1597422127);
    updatedAt = now;
    answeredInRound = uint80(latestRound);
  }
}",991
RealWorld_TA_115_MIMO_RealWorld_20240815191850.log,115,MIMO,39171,1740,40911,104.0,0.230655,"// solium-disable security/no-block-members
// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";

/**
 * @title  MIMO
 * @notice  MIMO Governance token
 */
contract MIMO is ERC20(""MIMO Parallel Governance Token"", ""MIMO"") {
  IGovernanceAddressProvider public a;

  bytes32 public constant MIMO_MINTER_ROLE = keccak256(""MIMO_MINTER_ROLE"");

  constructor(IGovernanceAddressProvider _a) public {
    require(address(_a) != address(0));

    a = _a;
  }

  modifier onlyMIMOMinter() {
    require(a.controller().hasRole(MIMO_MINTER_ROLE, msg.sender), ""Caller is not MIMO Minter"");
    _;
  }

  function mint(address account, uint256 amount) public onlyMIMOMinter {
    _mint(account, amount);
  }

  function burn(address account, uint256 amount) public onlyMIMOMinter {
    _burn(account, amount);
  }
}",253
RealWorld_TA_115_InceptionVaultsCore_RealWorld_20240815210400.log,115,InceptionVaultsCore,310342,5743,316085,174.0,1.66657,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";

import ""./BoringOwnable.sol"";
import ""./interfaces/IInceptionVaultsCore.sol"";
import ""./interfaces/IAdminInceptionVault.sol"";
import ""./interfaces/IInceptionVaultsDataProvider.sol"";
import ""./interfaces/IInceptionVaultPriceFeed.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../libraries/WadRayMath.sol"";

contract InceptionVaultsCore is IInceptionVaultsCore, BoringOwnable, ReentrancyGuard, Initializable {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;
  using WadRayMath for uint256;

  uint256 internal constant _MAX_INT = 2**256 - 1;

  uint256 private _cumulativeRate;
  uint256 private _lastRefresh;
  VaultConfig private _vaultConfig;

  IAddressProvider private _a;
  IERC20 private _inceptionCollateral;
  IAdminInceptionVault private _adminInceptionVault;
  IInceptionVaultsDataProvider private _inceptionVaultsData;
  IInceptionVaultPriceFeed private _inceptionPriceFeed;

  modifier onlyVaultOwner(uint256 _vaultId) {
    require(_inceptionVaultsData.vaultOwner(_vaultId) == msg.sender, ""IV010"");
    _;
  }

  function initialize(
    address _owner,
    VaultConfig memory vaultConfig,
    IERC20 inceptionCollateral,
    IAddressProvider addressProvider,
    IAdminInceptionVault adminInceptionVault,
    IInceptionVaultsDataProvider inceptionVaultsDataProvider,
    IInceptionVaultPriceFeed inceptionPriceFeed
  ) external override initializer {
    _vaultConfig = vaultConfig;
    _inceptionCollateral = inceptionCollateral;
    _lastRefresh = block.timestamp;
    _cumulativeRate = WadRayMath.ray();
    _a = addressProvider;
    _adminInceptionVault = adminInceptionVault;
    _inceptionVaultsData = inceptionVaultsDataProvider;
    owner = _owner;
    _inceptionPriceFeed = inceptionPriceFeed;
  }

  /**
    Deposit inceptionCollateral ERC20 token into the specified vault as collateral
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _vaultId the ID of the vault in which to deposit the inceptioCollateral.
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function depositByVaultId(uint256 _vaultId, uint256 _amount) external override {
    _inceptionCollateral.safeTransferFrom(msg.sender, address(this), _amount);

    _addCollateralToVaultById(_vaultId, _amount);
  }

  /**
    Deposit inceptionCollateral ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see deposit() and borrow()
    @param _depositAmount the amount of inceptionCollateral to be deposited in WEI.
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositAndBorrow(uint256 _depositAmount, uint256 _borrowAmount) external override {
    deposit(_depositAmount);
    uint256 vaultId = _inceptionVaultsData.vaultId(msg.sender);
    borrow(vaultId, _borrowAmount);
  }

  /**
    Withdraws inceptionCollateral ERC20 token from a vault.
    @dev Only the owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to withdraw the inceptionCollateral.
    @param _amount the amount of inceptionCollateral ERC20 tokens to be withdrawn in WEI.
  **/
  function withdraw(uint256 _vaultId, uint256 _amount) external override onlyVaultOwner(_vaultId) nonReentrant {
    _removeCollateralFromVault(_vaultId, _amount);
    _inceptionCollateral.safeTransfer(msg.sender, _amount);
  }

  /**
    Convenience function to repay all debt of a vault
    @dev `repayAll()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the debt.
  **/
  function repayAll(uint256 _vaultId) external override {
    repay(_vaultId, _MAX_INT);
  }

  /**
    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.
    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. `liquidate()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
  **/
  function liquidate(uint256 _vaultId) external override {
    liquidatePartial(_vaultId, _MAX_INT);
  }

  /**
    Deposit inceptionCollateral ERC20 token into the vault of the msg.sender as collateral
    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.
    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function deposit(uint256 _amount) public override {
    require(_amount > 0, ""IV100"");
    _inceptionCollateral.safeTransferFrom(msg.sender, address(this), _amount);

    _addCollateralToVault(_amount);
  }

  /**
    Borrow new PAR tokens from a vault.
    @dev Only the owner of a vault can borrow from it.
    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.
     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to borrow.
    @param _amount the amount of borrowed inceptionCollateral tokens in WEI.
  **/
  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    IERC20 stablex = IERC20(_a.stablex());
    require(_amount <= stablex.balanceOf(address(_adminInceptionVault)), ""IV104"");
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);

    // Make sure current rate is up to date
    _refreshCumulativeRate();

    uint256 newDebt = _amount;
    if (_vaultConfig.originationFee > 0) {
      newDebt = newDebt.add(_amount.wadMul(_vaultConfig.originationFee));
    }

    // Increment vault borrow balance

    uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(newDebt, _cumulativeRate);

    _inceptionVaultsData.setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));

    uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);
    uint256 newVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);

    bool isHealthy = _a.liquidationManager().isHealthy(collateralValue, newVaultDebt, _vaultConfig.minCollateralRatio);

    require(isHealthy, ""IV102"");

    _adminInceptionVault.lendPAR(_amount, msg.sender);

    emit Borrowed(_vaultId, _amount, msg.sender);
  }

  /**
    Repay an outstanding PAR balance to a vault.
    @dev `repay()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.
    @param _amount the amount of PAR tokens in WEI to be repaid.
  **/
  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    // Make sure current rate is up to date
    _refreshCumulativeRate();

    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);
    // Decrement vault borrow balance
    if (_amount >= currentVaultDebt) {
      // Full repayment
      _amount = currentVaultDebt; //only pay back what's outstanding
    }
    _reduceVaultDebt(_vaultId, _amount);
    // This will require a user allowance first
    IERC20 stablex = IERC20(_a.stablex());
    stablex.safeTransferFrom(msg.sender, address(_adminInceptionVault), _amount);
    emit Repaid(_vaultId, _amount, msg.sender);
  }

  /**
    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.
    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.
    This means that the change in outstanding debt can be smaller than the repaid amount.
    `liquidatePartial()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
    @param _amount the amount of debt+liquidationFee to repay.
  **/
  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);
    _refreshCumulativeRate();
    uint256 collateralValue = _inceptionPriceFeed.convertFrom(v.collateralBalance);
    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);
    require(
      !_a.liquidationManager().isHealthy(collateralValue, currentVaultDebt, _vaultConfig.liquidationRatio),
      ""IV103""
    );
    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(_vaultConfig.liquidationFee);
    uint256 maxLiquidationCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);
    uint256 repayAmount;
    if (_amount > maxLiquidationCost) {
      _amount = maxLiquidationCost;
      repayAmount = currentVaultDebt;
    } else {
      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);
    }
    uint256 collateralValueToReceive = _amount.add(_amount.wadMul(_vaultConfig.liquidationBonus));
    uint256 insuranceAmount = 0;
    if (collateralValueToReceive >= collateralValue) {
      // Not enough collateral for debt & liquidation bonus
      collateralValueToReceive = collateralValue;
      uint256 discountedCollateralValue = collateralValue.wadDiv(_vaultConfig.liquidationBonus.add(WadRayMath.wad()));
      if (currentVaultDebt > discountedCollateralValue) {
        // Not enough collateral for debt alone
        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);
        require(_a.stablex().balanceOf(address(_adminInceptionVault)) >= insuranceAmount, ""IV104"");
      }
      repayAmount = currentVaultDebt.sub(insuranceAmount);
      _amount = discountedCollateralValue;
    }
    // Reduce the vault debt by repayAmount
    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));
    IERC20 stablex = IERC20(_a.stablex());
    stablex.safeTransferFrom(msg.sender, address(this), _amount);
    stablex.safeTransfer(address(_adminInceptionVault), _amount);
    // Send the claimed collateral to the liquidator
    uint256 collateralToReceive = _inceptionPriceFeed.convertTo(collateralValueToReceive);
    _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));
    _inceptionCollateral.safeTransfer(msg.sender, collateralToReceive);
    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);
  }

  function cumulativeRate() public view override returns (uint256) {
    return _cumulativeRate;
  }

  function lastRefresh() public view override returns (uint256) {
    return _lastRefresh;
  }

  function vaultConfig() public view override returns (VaultConfig memory) {
    return _vaultConfig;
  }

  function a() public view override returns (IAddressProvider) {
    return _a;
  }

  function inceptionCollateral() public view override returns (IERC20) {
    return _inceptionCollateral;
  }

  function adminInceptionVault() public view override returns (IAdminInceptionVault) {
    return _adminInceptionVault;
  }

  function inceptionVaultsData() public view override returns (IInceptionVaultsDataProvider) {
    return _inceptionVaultsData;
  }

  function inceptionPriceFeed() public view override returns (IInceptionVaultPriceFeed) {
    return _inceptionPriceFeed;
  }

  function _addCollateralToVault(uint256 _amount) internal {
    uint256 vaultId = _inceptionVaultsData.vaultId(msg.sender);
    if (vaultId == 0) {
      vaultId = _inceptionVaultsData.createVault(msg.sender);
    }
    _addCollateralToVaultById(vaultId, _amount);
  }

  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);
    require(_amount <= v.collateralBalance, ""IV101"");
    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);
    _inceptionVaultsData.setCollateralBalance(_vaultId, newCollateralBalance);
    if (v.baseDebt > 0) {
      _refreshCumulativeRate();
      uint256 newCollateralValue = _inceptionPriceFeed.convertFrom(newCollateralBalance);
      require(
        _a.liquidationManager().isHealthy(
          newCollateralValue,
          _inceptionVaultsData.vaults(_vaultId).baseDebt,
          _vaultConfig.minCollateralRatio
        ),
        ""IV102""
      );
    }

    emit Withdrawn(_vaultId, _amount, msg.sender);
  }

  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {
    IInceptionVaultsDataProvider.InceptionVault memory v = _inceptionVaultsData.vaults(_vaultId);
    _inceptionVaultsData.setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));
    emit Deposited(_vaultId, _amount, msg.sender);
  }

  function _refreshCumulativeRate() internal {
    uint256 timestamp = block.timestamp;
    uint256 _timeElapsed = block.timestamp.sub(_lastRefresh);
    _cumulativeRate = _a.ratesManager().calculateCumulativeRate(_vaultConfig.borrowRate, _cumulativeRate, _timeElapsed);
    _lastRefresh = timestamp;
    emit CumulativeRateUpdated(_timeElapsed, _cumulativeRate);
  }

  /**
    Internal helper function to reduce the debt of a vault.
    @dev assumes cumulative rates for the vault's collateral type are up to date.
    please call `refreshCollateral()` before calling this function.
    @param _vaultId the ID of the vault for which to reduce the debt.
    @param _amount the amount of debt to be reduced.
  **/
  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {
    uint256 currentVaultDebt = _inceptionVaultsData.vaultDebt(_vaultId);
    uint256 remainder = currentVaultDebt.sub(_amount);

    if (remainder == 0) {
      _inceptionVaultsData.setBaseDebt(_vaultId, 0);
    } else {
      uint256 newBaseDebt = _a.ratesManager().calculateBaseDebt(remainder, _cumulativeRate);
      _inceptionVaultsData.setBaseDebt(_vaultId, newBaseDebt);
    }
  }
}",3535
RealWorld_TA_115_VotingEscrow_RealWorld_20240815215003.log,115,VotingEscrow,183244,4119,187363,153.0,0.9986,"// SPDX-License-Identifier: AGPL-3.0
/* solium-disable security/no-block-members */
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import { SafeERC20, IERC20 } from ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import { SafeMath } from ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./interfaces/IVotingEscrow.sol"";
import ""./interfaces/IGovernanceAddressProvider.sol"";
import ""../liquidityMining/interfaces/IGenericMiner.sol"";

/**
 * @title  VotingEscrow
 * @notice Lockup GOV, receive vGOV (voting weight that decays over time)
 * @dev    Supports:
 *            1) Tracking MIMO Locked up
 *            2) Decaying voting weight lookup
 *            3) Closure of contract
 */
contract VotingEscrow is IVotingEscrow, ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  uint256 public constant MAXTIME = 1460 days; // 365 * 4 years
  uint256 public minimumLockTime = 1 days;
  bool public expired = false;
  IERC20 public override stakingToken;

  mapping(address => LockedBalance) public locked;

  string public override name;
  string public override symbol;
  // solhint-disable-next-line
  uint256 public constant override decimals = 18;

  // AddressProvider
  IGovernanceAddressProvider public a;
  IGenericMiner public miner;

  constructor(
    IERC20 _stakingToken,
    IGovernanceAddressProvider _a,
    IGenericMiner _miner,
    string memory _name,
    string memory _symbol
  ) public {
    require(address(_stakingToken) != address(0));
    require(address(_a) != address(0));
    require(address(_miner) != address(0));

    stakingToken = _stakingToken;
    a = _a;
    miner = _miner;

    name = _name;
    symbol = _symbol;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /** @dev Modifier to ensure contract has not yet expired */
  modifier contractNotExpired() {
    require(!expired, ""Contract is expired"");
    _;
  }

  /**
   * @dev Creates a new lock
   * @param _value Total units of StakingToken to lockup
   * @param _unlockTime Time at which the stake should unlock
   */
  function createLock(uint256 _value, uint256 _unlockTime) external override nonReentrant contractNotExpired {
    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });

    require(_value > 0, ""Must stake non zero amount"");
    require(locked_.amount == 0, ""Withdraw old tokens first"");
    require(_unlockTime > block.timestamp, ""Can only lock until time in the future"");
    require(_unlockTime.sub(block.timestamp) > minimumLockTime, ""Lock duration should be larger than minimum locktime"");

    _depositFor(msg.sender, _value, _unlockTime, locked_, LockAction.CREATE_LOCK);
  }

  /**
   * @dev Increases amount of stake thats locked up & resets decay
   * @param _value Additional units of StakingToken to add to exiting stake
   */
  function increaseLockAmount(uint256 _value) external override nonReentrant contractNotExpired {
    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });

    require(_value > 0, ""Must stake non zero amount"");
    require(locked_.amount > 0, ""No existing lock found"");
    require(locked_.end > block.timestamp, ""Cannot add to expired lock. Withdraw"");

    _depositFor(msg.sender, _value, 0, locked_, LockAction.INCREASE_LOCK_AMOUNT);
  }

  /**
   * @dev Increases length of lockup & resets decay
   * @param _unlockTime New unlocktime for lockup
   */
  function increaseLockLength(uint256 _unlockTime) external override nonReentrant contractNotExpired {
    LockedBalance memory locked_ = LockedBalance({ amount: locked[msg.sender].amount, end: locked[msg.sender].end });

    require(locked_.amount > 0, ""Nothing is locked"");
    require(locked_.end > block.timestamp, ""Lock expired"");
    require(_unlockTime > locked_.end, ""Can only increase lock time"");
    require(_unlockTime.sub(locked_.end) > minimumLockTime, ""Lock duration should be larger than minimum locktime"");

    _depositFor(msg.sender, 0, _unlockTime, locked_, LockAction.INCREASE_LOCK_TIME);
  }

  /**
   * @dev Withdraws all the senders stake, providing lockup is over
   */
  function withdraw() external override {
    _withdraw(msg.sender);
  }

  /**
   * @dev Ends the contract, unlocking all stakes.
   * No more staking can happen. Only withdraw.
   */
  function expireContract() external override onlyManager contractNotExpired {
    expired = true;
    emit Expired();
  }

  /**
   * @dev Set miner address.
   * @param _miner new miner contract address
   */
  function setMiner(IGenericMiner _miner) external override onlyManager contractNotExpired {
    miner = _miner;
  }

  /**
   * @dev Set minimumLockTime.
   * @param _minimumLockTime minimum lockTime
   */
  function setMinimumLockTime(uint256 _minimumLockTime) external override onlyManager contractNotExpired {
    minimumLockTime = _minimumLockTime;
  }

  /***************************************
                    GETTERS
    ****************************************/

  /**
   * @dev Gets the user's votingWeight at the current time.
   * @param _owner User for which to return the votingWeight
   * @return uint256 Balance of user
   */
  function balanceOf(address _owner) public view override returns (uint256) {
    return balanceOfAt(_owner, block.timestamp);
  }

  /**
   * @dev Gets a users votingWeight at a given block timestamp
   * @param _owner User for which to return the balance
   * @param _blockTime Timestamp for which to calculate balance. Can not be in the past
   * @return uint256 Balance of user
   */
  function balanceOfAt(address _owner, uint256 _blockTime) public view override returns (uint256) {
    require(_blockTime >= block.timestamp, ""Must pass block timestamp in the future"");

    LockedBalance memory currentLock = locked[_owner];

    if (currentLock.end <= _blockTime) return 0;
    uint256 remainingLocktime = currentLock.end.sub(_blockTime);
    if (remainingLocktime > MAXTIME) {
      remainingLocktime = MAXTIME;
    }

    return currentLock.amount.mul(remainingLocktime).div(MAXTIME);
  }

  /**
   * @dev Deposits or creates a stake for a given address
   * @param _addr User address to assign the stake
   * @param _value Total units of StakingToken to lockup
   * @param _unlockTime Time at which the stake should unlock
   * @param _oldLocked Previous amount staked by this user
   * @param _action See LockAction enum
   */
  function _depositFor(
    address _addr,
    uint256 _value,
    uint256 _unlockTime,
    LockedBalance memory _oldLocked,
    LockAction _action
  ) internal {
    LockedBalance memory newLocked = LockedBalance({ amount: _oldLocked.amount, end: _oldLocked.end });

    // Adding to existing lock, or if a lock is expired - creating a new one
    newLocked.amount = newLocked.amount.add(_value);
    if (_unlockTime != 0) {
      newLocked.end = _unlockTime;
    }
    locked[_addr] = newLocked;

    if (_value != 0) {
      stakingToken.safeTransferFrom(_addr, address(this), _value);
    }

    miner.releaseMIMO(_addr);

    emit Deposit(_addr, _value, newLocked.end, _action, block.timestamp);
  }

  /**
   * @dev Withdraws a given users stake, providing the lockup has finished
   * @param _addr User for which to withdraw
   */
  function _withdraw(address _addr) internal nonReentrant {
    LockedBalance memory oldLock = LockedBalance({ end: locked[_addr].end, amount: locked[_addr].amount });
    require(block.timestamp >= oldLock.end || expired, ""The lock didn't expire"");
    require(oldLock.amount > 0, ""Must have something to withdraw"");

    uint256 value = uint256(oldLock.amount);

    LockedBalance memory currentLock = LockedBalance({ end: 0, amount: 0 });
    locked[_addr] = currentLock;

    stakingToken.safeTransfer(_addr, value);
    miner.releaseMIMO(_addr);

    emit Withdraw(_addr, value, block.timestamp);
  }
}",1975
RealWorld_TA_115_IGovernorAlpha_RealWorld_20240815220123.log,115,IGovernorAlpha,86081,1992,88073,106.0,0.470245,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

interface IGovernorAlpha {
  /// @notice Possible states that a proposal may be in
  enum ProposalState { Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }

  struct Proposal {
    // Unique id for looking up a proposal
    uint256 id;
    // Creator of the proposal
    address proposer;
    // The timestamp that the proposal will be available for execution, set once the vote succeeds
    uint256 eta;
    // the ordered list of target addresses for calls to be made
    address[] targets;
    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made
    uint256[] values;
    // The ordered list of function signatures to be called
    string[] signatures;
    // The ordered list of calldata to be passed to each call
    bytes[] calldatas;
    // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp
    uint256 startTime;
    // The timestamp at which voting ends: votes must be cast prior to this timestamp
    uint256 endTime;
    // Current number of votes in favor of this proposal
    uint256 forVotes;
    // Current number of votes in opposition to this proposal
    uint256 againstVotes;
    // Flag marking whether the proposal has been canceled
    bool canceled;
    // Flag marking whether the proposal has been executed
    bool executed;
    // Receipts of ballots for the entire set of voters
    mapping(address => Receipt) receipts;
  }

  /// @notice Ballot receipt record for a voter
  struct Receipt {
    // Whether or not a vote has been cast
    bool hasVoted;
    // Whether or not the voter supports the proposal
    bool support;
    // The number of votes the voter had, which were cast
    uint256 votes;
  }

  /// @notice An event emitted when a new proposal is created
  event ProposalCreated(
    uint256 id,
    address proposer,
    address[] targets,
    uint256[] values,
    string[] signatures,
    bytes[] calldatas,
    uint256 startTime,
    uint256 endTime,
    string description
  );

  /// @notice An event emitted when a vote has been cast on a proposal
  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);

  /// @notice An event emitted when a proposal has been canceled
  event ProposalCanceled(uint256 id);

  /// @notice An event emitted when a proposal has been queued in the Timelock
  event ProposalQueued(uint256 id, uint256 eta);

  /// @notice An event emitted when a proposal has been executed in the Timelock
  event ProposalExecuted(uint256 id);

  function propose(
    address[] memory targets,
    uint256[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description,
    uint256 endTime
  ) external returns (uint256);

  function queue(uint256 proposalId) external;

  function execute(uint256 proposalId) external payable;

  function cancel(uint256 proposalId) external;

  function castVote(uint256 proposalId, bool support) external;

  function getActions(uint256 proposalId)
    external
    view
    returns (
      address[] memory targets,
      uint256[] memory values,
      string[] memory signatures,
      bytes[] memory calldatas
    );

  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);

  function state(uint256 proposalId) external view returns (ProposalState);

  function quorumVotes() external view returns (uint256);

  function proposalThreshold() external view returns (uint256);
}",803
RealWorld_TA_115_IVotingEscrow_RealWorld_20240815215940.log,115,IVotingEscrow,44226,2427,46653,101.0,0.26967,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../liquidityMining/interfaces/IGenericMiner.sol"";

interface IVotingEscrow {
  enum LockAction { CREATE_LOCK, INCREASE_LOCK_AMOUNT, INCREASE_LOCK_TIME }

  struct LockedBalance {
    uint256 amount;
    uint256 end;
  }

  /** Shared Events */
  event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);
  event Withdraw(address indexed provider, uint256 value, uint256 ts);
  event Expired();

  function createLock(uint256 _value, uint256 _unlockTime) external;

  function increaseLockAmount(uint256 _value) external;

  function increaseLockLength(uint256 _unlockTime) external;

  function withdraw() external;

  function expireContract() external;

  function setMiner(IGenericMiner _miner) external;

  function setMinimumLockTime(uint256 _minimumLockTime) external;

  function name() external view returns (string memory);

  function symbol() external view returns (string memory);

  function decimals() external view returns (uint256);

  function balanceOf(address _owner) external view returns (uint256);

  function balanceOfAt(address _owner, uint256 _blockTime) external view returns (uint256);

  function stakingToken() external view returns (IERC20);
}",312
RealWorld_TA_115_ILiquidationManager_RealWorld_20240815222425.log,115,ILiquidationManager,33479,1456,34935,96.0,0.196515,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";

interface ILiquidationManager {
  function a() external view returns (IAddressProvider);

  function calculateHealthFactor(
    uint256 _collateralValue,
    uint256 _vaultDebt,
    uint256 _minRatio
  ) external view returns (uint256 healthFactor);

  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);

  function applyLiquidationDiscount(address _collateralType, uint256 _amount)
    external
    view
    returns (uint256 discountedAmount);

  function isHealthy(
    uint256 _collateralValue,
    uint256 _vaultDebt,
    uint256 _minRatio
  ) external view returns (bool);
}",182
RealWorld_TA_115_IUniswapV2Router01_RealWorld_20240815213540.log,115,IUniswapV2Router01,93274,1703,94977,150.0,0.50043,"pragma solidity 0.6.12;

interface IUniswapV2Router01 {
  function factory() external pure returns (address);

  function WETH() external pure returns (address);

  function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  )
    external
    returns (
      uint256 amountA,
      uint256 amountB,
      uint256 liquidity
    );

  function addLiquidityETH(
    address token,
    uint256 amountTokenDesired,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  )
    external
    payable
    returns (
      uint256 amountToken,
      uint256 amountETH,
      uint256 liquidity
    );

  function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETH(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountToken, uint256 amountETH);

  function removeLiquidityWithPermit(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountA, uint256 amountB);

  function removeLiquidityETHWithPermit(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountToken, uint256 amountETH);

  function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapTokensForExactTokens(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactETHForTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function swapTokensForExactETH(
    uint256 amountOut,
    uint256 amountInMax,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapExactTokensForETH(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  function swapETHForExactTokens(
    uint256 amountOut,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  function quote(
    uint256 amountA,
    uint256 reserveA,
    uint256 reserveB
  ) external pure returns (uint256 amountB);

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountOut);

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) external pure returns (uint256 amountIn);

  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
}",907
RealWorld_TA_115_PriceFeed_RealWorld_20240815204959.log,115,PriceFeed,109629,2506,112135,104.0,0.598265,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../interfaces/IPriceFeed.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../chainlink/AggregatorV3Interface.sol"";
import ""../libraries/MathPow.sol"";
import ""../libraries/WadRayMath.sol"";

contract PriceFeed is IPriceFeed {
  using SafeMath for uint256;
  using SafeMath for uint8;
  using WadRayMath for uint256;

  uint256 public constant PRICE_ORACLE_STALE_THRESHOLD = 1 days;

  IAddressProvider public override a;

  mapping(address => AggregatorV3Interface) public override assetOracles;

  AggregatorV3Interface public override eurOracle;

  constructor(IAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not a Manager"");
    _;
  }

  /**
   * @notice Sets the oracle for the given asset,
   * @param _asset address to the collateral asset e.g. WETH
   * @param _oracle address to the oracel, this oracle should implement the AggregatorV3Interface
   */
  function setAssetOracle(address _asset, address _oracle) public override onlyManager {
    require(_asset != address(0));
    require(_oracle != address(0));
    assetOracles[_asset] = AggregatorV3Interface(_oracle);
    emit OracleUpdated(_asset, _oracle, msg.sender);
  }

  /**
   * @notice Sets the oracle for EUR, this oracle should provide EUR-USD prices
   * @param _oracle address to the oracle, this oracle should implement the AggregatorV3Interface
   */
  function setEurOracle(address _oracle) public override onlyManager {
    require(_oracle != address(0));
    eurOracle = AggregatorV3Interface(_oracle);
    emit EurOracleUpdated(_oracle, msg.sender);
  }

  /**
   * Gets the asset price in EUR (PAR)
   * @dev returned value has matching decimals to the asset oracle (not the EUR oracle)
   * @param _asset address to the collateral asset e.g. WETH
   */
  function getAssetPrice(address _asset) public view override returns (uint256 price) {
    (, int256 eurAnswer, , uint256 eurUpdatedAt, ) = eurOracle.latestRoundData();
    require(eurAnswer > 0, ""EUR price data not valid"");
    require(block.timestamp - eurUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, ""EUR price data is stale"");

    (, int256 answer, , uint256 assetUpdatedAt, ) = assetOracles[_asset].latestRoundData();
    require(answer > 0, ""Price data not valid"");
    require(block.timestamp - assetUpdatedAt < PRICE_ORACLE_STALE_THRESHOLD, ""Price data is stale"");

    uint8 eurDecimals = eurOracle.decimals();
    uint256 eurAccuracy = MathPow.pow(10, eurDecimals);
    return uint256(answer).mul(eurAccuracy).div(uint256(eurAnswer));
  }

  /**
   * @notice Converts asset balance into stablecoin balance at current price
   * @param _asset address to the collateral asset e.g. WETH
   * @param _amount amount of collateral
   */
  function convertFrom(address _asset, uint256 _amount) public view override returns (uint256) {
    uint256 price = getAssetPrice(_asset);
    uint8 collateralDecimals = ERC20(_asset).decimals();
    uint8 parDecimals = ERC20(address(a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()
    uint8 oracleDecimals = assetOracles[_asset].decimals();
    uint256 parAccuracy = MathPow.pow(10, parDecimals);
    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));
    return _amount.mul(price).mul(parAccuracy).div(collateralAccuracy);
  }

  /**
   * @notice Converts stablecoin balance into collateral balance at current price
   * @param _asset address to the collateral asset e.g. WETH
   * @param _amount amount of stablecoin
   */
  function convertTo(address _asset, uint256 _amount) public view override returns (uint256) {
    uint256 price = getAssetPrice(_asset);
    uint8 collateralDecimals = ERC20(_asset).decimals();
    uint8 parDecimals = ERC20(address(a.stablex())).decimals(); // Needs re-casting because ISTABLEX does not expose decimals()
    uint8 oracleDecimals = assetOracles[_asset].decimals();
    uint256 parAccuracy = MathPow.pow(10, parDecimals);
    uint256 collateralAccuracy = MathPow.pow(10, oracleDecimals.add(collateralDecimals));
    return _amount.mul(collateralAccuracy).div(price).div(parAccuracy);
  }
}",1107
RealWorld_TA_115_VaultsCore_RealWorld_20240815204527.log,115,VaultsCore,387184,5025,392209,171.0,2.03642,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""../libraries/WadRayMath.sol"";
import ""../interfaces/IVaultsCore.sol"";
import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IWETH.sol"";
import ""../interfaces/IVaultsCoreState.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";

contract VaultsCore is IVaultsCore, ReentrancyGuard {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 internal constant _MAX_INT = 2**256 - 1;

  IAddressProvider public override a;
  IWETH public override WETH;
  IVaultsCoreState public override state;
  IDebtNotifier public override debtNotifier;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));
    _;
  }

  modifier onlyVaultOwner(uint256 _vaultId) {
    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);
    _;
  }

  constructor(
    IAddressProvider _addresses,
    IWETH _IWETH,
    IVaultsCoreState _vaultsCoreState
  ) public {
    require(address(_addresses) != address(0));
    require(address(_IWETH) != address(0));
    require(address(_vaultsCoreState) != address(0));
    a = _addresses;
    WETH = _IWETH;
    state = _vaultsCoreState;
  }

  // For a contract to receive ETH, it needs to have a payable fallback function
  // https://ethereum.stackexchange.com/a/47415
  receive() external payable {
    require(msg.sender == address(WETH));
  }

  /*
    Allow smooth upgrading of the vaultscore.
    @dev this function approves token transfers to the new vaultscore of
    both stablex and all configured collateral types
    @param _newVaultsCore address of the new vaultscore
  */
  function upgrade(address payable _newVaultsCore) public override onlyManager {
    require(address(_newVaultsCore) != address(0));
    require(a.stablex().approve(_newVaultsCore, _MAX_INT));

    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      IERC20 asset = IERC20(collateralType);
      asset.safeApprove(_newVaultsCore, _MAX_INT);
    }
  }

  /*
    Allow smooth upgrading of the VaultsCore.
    @dev this function transfers both PAR and all configured collateral
    types to the new vaultscore.
  */
  function acceptUpgrade(address payable _oldVaultsCore) public override onlyManager {
    IERC20 stableX = IERC20(a.stablex());
    stableX.safeTransferFrom(_oldVaultsCore, address(this), stableX.balanceOf(_oldVaultsCore));

    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      IERC20 asset = IERC20(collateralType);
      asset.safeTransferFrom(_oldVaultsCore, address(this), asset.balanceOf(_oldVaultsCore));
    }
  }

  /**
    Configure the debt notifier.
    @param _debtNotifier the new DebtNotifier module address.
  **/
  function setDebtNotifier(IDebtNotifier _debtNotifier) public override onlyManager {
    require(address(_debtNotifier) != address(0));
    debtNotifier = _debtNotifier;
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral
    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.
    this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _collateralType the address of the collateral type to be deposited
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function deposit(address _collateralType, uint256 _amount) public override {
    require(a.config().collateralIds(_collateralType) != 0);

    IERC20 asset = IERC20(_collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _amount);

    _addCollateralToVault(_collateralType, _amount);
  }

  /**
    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral
    @dev A new vault is created if no WETH vault exists
  **/
  function depositETH() public payable override {
    WETH.deposit{ value: msg.value }();
    _addCollateralToVault(address(WETH), msg.value);
  }

  /**
    Deposit an ERC20 token into the specified vault as collateral
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _vaultId the address of the collateral type to be deposited
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function depositByVaultId(uint256 _vaultId, uint256 _amount) public override {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);
    require(v.collateralType != address(0));

    IERC20 asset = IERC20(v.collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _amount);

    _addCollateralToVaultById(_vaultId, _amount);
  }

  /**
    Wraps ETH and deposits WETH into the specified vault as collateral
    @dev this function uses `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _vaultId the address of the collateral type to be deposited
  **/
  function depositETHByVaultId(uint256 _vaultId) public payable override {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);
    require(v.collateralType == address(WETH));

    WETH.deposit{ value: msg.value }();

    _addCollateralToVaultById(_vaultId, msg.value);
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see deposit() and borrow()
    @param _collateralType the address of the collateral type to be deposited
    @param _depositAmount the amount of tokens to be deposited in WEI.
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _borrowAmount
  ) public override {
    deposit(_collateralType, _depositAmount);
    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);
    borrow(vaultId, _borrowAmount);
  }

  /**
    Wraps ETH and deposits WETH into the vault of the msg.sender as collateral and borrows the specified amount of tokens in WEI
    @dev see depositETH() and borrow()
    @param _borrowAmount the amount of borrowed StableX tokens in WEI.
  **/
  function depositETHAndBorrow(uint256 _borrowAmount) public payable override {
    depositETH();
    uint256 vaultId = a.vaultsData().vaultId(address(WETH), msg.sender);
    borrow(vaultId, _borrowAmount);
  }

  function _addCollateralToVault(address _collateralType, uint256 _amount) internal {
    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);
    if (vaultId == 0) {
      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);
    }

    _addCollateralToVaultById(vaultId, _amount);
  }

  function _addCollateralToVaultById(uint256 _vaultId, uint256 _amount) internal {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.add(_amount));

    emit Deposited(_vaultId, _amount, msg.sender);
  }

  /**
    Withdraws ERC20 tokens from a vault.
    @dev Only the owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to withdraw the collateral.
    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.
  **/
  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    _removeCollateralFromVault(_vaultId, _amount);
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    IERC20 asset = IERC20(v.collateralType);
    asset.safeTransfer(msg.sender, _amount);
  }

  /**
    Withdraws ETH from a WETH vault.
    @dev Only the owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to withdraw the collateral.
    @param _amount the amount of ETH to be withdrawn in WEI.
  **/
  function withdrawETH(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    _removeCollateralFromVault(_vaultId, _amount);
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    require(v.collateralType == address(WETH));

    WETH.withdraw(_amount);
    msg.sender.transfer(_amount);
  }

  function _removeCollateralFromVault(uint256 _vaultId, uint256 _amount) internal {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);
    require(_amount <= v.collateralBalance);
    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);
    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);
    if (v.baseDebt > 0) {
      // Save gas cost when withdrawing from 0 debt vault
      state.refreshCollateral(v.collateralType);
      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);
      require(
        a.liquidationManager().isHealthy(
          newCollateralValue,
          a.vaultsData().vaultDebt(_vaultId),
          a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio
        )
      );
    }

    emit Withdrawn(_vaultId, _amount, msg.sender);
  }

  /**
    Borrow new PAR tokens from a vault.
    @dev Only the owner of a vault can borrow from it.
    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.
     `borrow()` will fail if it would bring the vault below the minimum collateralization treshold.
    @param _vaultId the ID of the vault from which to borrow.
    @param _amount the amount of borrowed PAR tokens in WEI.
  **/
  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    // Make sure current rate is up to date
    state.refreshCollateral(v.collateralType);

    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);
    uint256 newDebt = _amount;
    if (originationFeePercentage > 0) {
      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));
    }

    // Increment vault borrow balance
    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates(v.collateralType));

    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));

    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);
    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);

    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));

    bool isHealthy = a.liquidationManager().isHealthy(
      collateralValue,
      newVaultDebt,
      a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).minCollateralRatio
    );
    require(isHealthy);

    a.stablex().mint(msg.sender, _amount);
    debtNotifier.debtChanged(_vaultId);
    emit Borrowed(_vaultId, _amount, msg.sender);
  }

  /**
    Convenience function to repay all debt of a vault
    @dev `repayAll()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the debt.
  **/
  function repayAll(uint256 _vaultId) public override {
    repay(_vaultId, _MAX_INT);
  }

  /**
    Repay an outstanding PAR balance to a vault.
    @dev `repay()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.
    @param _amount the amount of PAR tokens in WEI to be repaid.
  **/
  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);

    // Make sure current rate is up to date
    state.refreshCollateral(collateralType);

    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);
    // Decrement vault borrow balance
    if (_amount >= currentVaultDebt) {
      //full repayment
      _amount = currentVaultDebt; //only pay back what's outstanding
    }
    _reduceVaultDebt(_vaultId, _amount);
    a.stablex().burn(msg.sender, _amount);
    debtNotifier.debtChanged(_vaultId);
    emit Repaid(_vaultId, _amount, msg.sender);
  }

  /**
    Internal helper function to reduce the debt of a vault.
    @dev assumes cumulative rates for the vault's collateral type are up to date.
    please call `refreshCollateral()` before calling this function.
    @param _vaultId the ID of the vault for which to reduce the debt.
    @param _amount the amount of debt to be reduced.
  **/
  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {
    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);

    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);
    uint256 remainder = currentVaultDebt.sub(_amount);
    uint256 cumulativeRate = cumulativeRates(collateralType);

    if (remainder == 0) {
      a.vaultsData().setBaseDebt(_vaultId, 0);
    } else {
      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);
      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);
    }
  }

  /**
    Liquidate a vault that is below the liquidation treshold by repaying its outstanding debt.
    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. `liquidate()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
  **/
  function liquidate(uint256 _vaultId) public override {
    liquidatePartial(_vaultId, _MAX_INT);
  }

  /**
    Liquidate a vault partially that is below the liquidation treshold by repaying part of its outstanding debt.
    @dev `liquidatePartial()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. A LiquidationFee will be applied to the borrower during the liquidation.
    This means that the change in outstanding debt can be smaller than the repaid amount.
    `liquidatePartial()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
    @param _amount the amount of debt+liquidationFee to repay.
  **/
  function liquidatePartial(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    state.refreshCollateral(v.collateralType);

    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);
    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);

    require(
      !a.liquidationManager().isHealthy(
        collateralValue,
        currentVaultDebt,
        a.config().collateralConfigs(a.config().collateralIds(v.collateralType)).liquidationRatio
      )
    );

    uint256 repaymentAfterLiquidationFeeRatio = WadRayMath.wad().sub(
      a.config().collateralLiquidationFee(v.collateralType)
    );
    uint256 maxLiquiditionCost = currentVaultDebt.wadDiv(repaymentAfterLiquidationFeeRatio);

    uint256 repayAmount;

    if (_amount > maxLiquiditionCost) {
      _amount = maxLiquiditionCost;
      repayAmount = currentVaultDebt;
    } else {
      repayAmount = _amount.wadMul(repaymentAfterLiquidationFeeRatio);
    }

    // collateral value to be received by the liquidator is based on the total amount repaid (including the liquidationFee).
    uint256 collateralValueToReceive = _amount.add(a.liquidationManager().liquidationBonus(v.collateralType, _amount));
    uint256 insuranceAmount = 0;
    if (collateralValueToReceive >= collateralValue) {
      // Not enough collateral for debt & liquidation fee
      collateralValueToReceive = collateralValue;
      uint256 discountedCollateralValue = a.liquidationManager().applyLiquidationDiscount(
        v.collateralType,
        collateralValue
      );

      if (currentVaultDebt > discountedCollateralValue) {
        // Not enough collateral for debt alone
        insuranceAmount = currentVaultDebt.sub(discountedCollateralValue);
        require(a.stablex().balanceOf(address(this)) >= insuranceAmount);
        a.stablex().burn(address(this), insuranceAmount); // Insurance uses local reserves to pay down debt
        emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);
      }

      repayAmount = currentVaultDebt.sub(insuranceAmount);
      _amount = discountedCollateralValue;
    }

    // reduce the vault debt by repayAmount
    _reduceVaultDebt(_vaultId, repayAmount.add(insuranceAmount));
    a.stablex().burn(msg.sender, _amount);

    // send the claimed collateral to the liquidator
    uint256 collateralToReceive = a.priceFeed().convertTo(v.collateralType, collateralValueToReceive);
    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));
    IERC20 asset = IERC20(v.collateralType);
    asset.safeTransfer(msg.sender, collateralToReceive);

    debtNotifier.debtChanged(_vaultId);

    emit Liquidated(_vaultId, repayAmount, collateralToReceive, v.owner, msg.sender);
  }

  /**
    Returns the cumulativeRate of a collateral type. This function exists for
    backwards compatibility with the VaultsDataProvider.
    @param _collateralType the address of the collateral type.
  **/
  function cumulativeRates(address _collateralType) public view override returns (uint256) {
    return state.cumulativeRates(_collateralType);
  }
}",4457
RealWorld_TA_115_MathPow_RealWorld_20240815213023.log,115,MathPow,37706,2372,40078,102.0,0.23597,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

library MathPow {
  function pow(uint256 x, uint256 n) internal pure returns (uint256 z) {
    z = n % 2 != 0 ? x : 1;

    for (n /= 2; n != 0; n /= 2) {
      x = SafeMath.mul(x, x);

      if (n % 2 != 0) {
        z = SafeMath.mul(z, x);
      }
    }
  }

  function sqrt(uint256 y) internal pure returns (uint256 z) {
    if (y > 3) {
      z = y;
      uint256 x = y / 2 + 1;
      while (x < z) {
        z = x;
        x = (y / x + x) / 2;
      }
    } else if (y != 0) {
      z = 1;
    }
  }
}",220
RealWorld_TA_115_TIVSetup_RealWorld_20240815223945.log,115,TIVSetup,221888,3086,224974,132.0,1.17116,"//SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

import ""../contracts/mocks/MockERC20.sol"";
import ""../contracts/mocks/MockWETH.sol"";
import ""../contracts/mocks/MockMIMO.sol"";
import ""../contracts/mocks/MockInceptionAggregator.sol"";
import ""../contracts/access/AccessController.sol"";
import ""../contracts/core/AddressProvider.sol"";
import ""../contracts/core/ConfigProvider.sol"";
import ""../contracts/core/PriceFeed.sol"";
import ""../contracts/core/RatesManager.sol"";
import ""../contracts/core/LiquidiationManager.sol"";
import ""../contracts/fees/FeeDistributor.sol"";
import ""../contracts/core/VaultsDataProvider.sol"";
import ""../contracts/core/VaultsCoreState.sol"";
import ""../contracts/core/VaultsCore.sol"";
import ""../contracts/token/PAR.sol"";
import ""../contracts/governance/GovernanceAddressProvider.sol"";
import ""../contracts/liquidityMining/DebtNotifier.sol"";
import ""../contracts/liquidityMining/SupplyMiner.sol"";
import ""../contracts/inception/InceptionVaultFactory.sol"";
import ""../contracts/inception/AdminInceptionVault.sol"";
import ""../contracts/inception/InceptionVaultsCore.sol"";
import ""../contracts/inception/InceptionVaultsDataProvider.sol"";
import ""../contracts/inception/priceFeed/ChainlinkInceptionPriceFeed.sol"";

import ""../contracts/interfaces/IAddressProvider.sol"";
import ""../contracts/interfaces/IAccessController.sol"";
import ""../contracts/interfaces/IConfigProvider.sol"";
import ""../contracts/interfaces/IPriceFeed.sol"";
import ""../contracts/interfaces/IRatesManager.sol"";
import ""../contracts/interfaces/ILiquidationManager.sol"";
import ""../contracts/interfaces/IFeeDistributor.sol"";
import ""../contracts/interfaces/IVaultsDataProvider.sol"";
import ""../contracts/interfaces/IVaultsCoreState.sol"";
import ""../contracts/interfaces/IVaultsCore.sol"";
import ""../contracts/interfaces/IWETH.sol"";
import ""../contracts/interfaces/ISTABLEX.sol"";
import ""../contracts/interfaces/IFeeDistributor.sol"";
import ""../contracts/chainlink/AggregatorV3Interface.sol"";
import ""../contracts/governance/interfaces/IGovernanceAddressProvider.sol"";
import ""../contracts/liquidityMining/interfaces/IDebtNotifier.sol"";
import ""../contracts/liquidityMining/interfaces/ISupplyMiner.sol"";
import ""../contracts/liquidityMining/interfaces/IMIMO.sol"";
import ""../contracts/inception/interfaces/IInceptionVaultPriceFeed.sol"";

contract TIVSetup {
  MockERC20 internal _wbtc;
  MockERC20 internal _usdc;
  MockERC20 internal _link;
  MockWETH internal _weth;
  MockMIMO internal _mimo;
  PAR internal _par;
  MockInceptionAggregator internal _wbtcAggregator;
  MockInceptionAggregator internal _wethAggregator;
  MockInceptionAggregator internal _usdcAggregator;
  MockInceptionAggregator internal _eurUsdAggregator;
  MockInceptionAggregator internal _linkAggregator;

  AccessController internal _accessController;
  AddressProvider internal _addressProvider;
  ConfigProvider internal _configProvider;
  PriceFeed internal _priceFeed;
  RatesManager internal _ratesManager;
  LiquidationManager internal _liquidationManager;
  FeeDistributor internal _feeDistributor;
  VaultsDataProvider internal _vaultsDataProvider;
  VaultsCoreState internal _vaultsCoreState;
  VaultsCore internal _vaultsCore;
  GovernanceAddressProvider internal _governanceAddressProvider;
  DebtNotifier internal _debtNotifier;
  SupplyMiner internal _wbtcSupplyMiner;
  SupplyMiner internal _wethSupplyMiner;
  SupplyMiner internal _usdcSupplyMiner;
  InceptionVaultFactory internal _inceptionVaultFactory;
  AdminInceptionVault internal _baseAdminInceptionVault;
  InceptionVaultsCore internal _baseInceptionVaultsCore;
  InceptionVaultsDataProvider internal _baseInceptionVaultsDataProvider;
  ChainlinkInceptionPriceFeed internal _baseChainlinkInceptionPriceFeed;

  uint256 internal constant _MAX_INT = 2**256 - 1;
  address internal _echidna_caller = 0x00a329c0648769A73afAc7F9381E08FB43dBEA72;

  constructor() public payable {
    // Deploy Mock Contracts
    _wbtc = new MockERC20(""Wrapped BTC"", ""WBTC"", 18);
    _usdc = new MockERC20(""USD Coin"", ""USDC"", 6);
    _link = new MockERC20(""Link Token"", ""LINK"", 18);
    _mimo = new MockMIMO();
    _weth = new MockWETH();
    _wbtcAggregator = new MockInceptionAggregator(8, 3600000000000, ""WBTC / USD"");
    _wethAggregator = new MockInceptionAggregator(8, 250000000000, ""WETH / USD"");
    _usdcAggregator = new MockInceptionAggregator(8, 100000000, ""USDC / USD"");
    _eurUsdAggregator = new MockInceptionAggregator(8, 113224640, ""EUR / USD"");
    _linkAggregator = new MockInceptionAggregator(8, 1400000000, ""LINK/ USD"");

    // Deploy Core
    _accessController = new AccessController();
    _addressProvider = new AddressProvider(IAccessController(address(_accessController)));
    _configProvider = new ConfigProvider(IAddressProvider(address(_addressProvider)));
    _priceFeed = new PriceFeed(IAddressProvider(address(_addressProvider)));
    _ratesManager = new RatesManager(IAddressProvider(address(_addressProvider)));
    _liquidationManager = new LiquidationManager(IAddressProvider(address(_addressProvider)));
    _feeDistributor = new FeeDistributor(IAddressProvider(address(_addressProvider)));
    _vaultsDataProvider = new VaultsDataProvider(IAddressProvider(address(_addressProvider)));
    _vaultsCoreState = new VaultsCoreState(IAddressProvider(address(_addressProvider)));
    _vaultsCore = new VaultsCore(
      IAddressProvider(address(_addressProvider)),
      IWETH(address(_weth)),
      IVaultsCoreState(address(_vaultsCoreState))
    );
    _par = new PAR(IAddressProvider(address(_addressProvider)));
    _addressProvider.setAccessController(IAccessController(address(_accessController)));

    // Set Core Providers
    _addressProvider.setConfigProvider(IConfigProvider(address(_configProvider)));
    _addressProvider.setVaultsCore(IVaultsCore(address(_vaultsCore)));
    _addressProvider.setStableX(ISTABLEX(address(_par)));
    _addressProvider.setRatesManager(IRatesManager(address(_ratesManager)));
    _addressProvider.setPriceFeed(IPriceFeed(address(_priceFeed)));
    _addressProvider.setLiquidationManager(ILiquidationManager(address(_liquidationManager)));
    _addressProvider.setFeeDistributor(IFeeDistributor(address(_feeDistributor)));
    _addressProvider.setVaultsDataProvider(IVaultsDataProvider(address(_vaultsDataProvider)));

    // Set Price Feed
    _priceFeed.setAssetOracle(address(_weth), address(_wethAggregator));
    _priceFeed.setAssetOracle(address(_wbtc), address(_wbtcAggregator));
    _priceFeed.setAssetOracle(address(_usdc), address(_usdcAggregator));
    _priceFeed.setEurOracle(address(_eurUsdAggregator));

    // Set Access
    _accessController.grantRole(_accessController.MINTER_ROLE(), address(_feeDistributor));
    _accessController.grantRole(_accessController.MINTER_ROLE(), address(_vaultsCore));

    // Set Fees
    address[] memory payees = new address[](1);
    uint256[] memory shares = new uint256[](1);
    payees[0] = address(_vaultsCore);
    shares[0] = 100;
    _feeDistributor.changePayees(payees, shares);

    // Set Collateral Configs
    _configProvider.setCollateralConfig(
      address(_weth),
      17000000000000000000000000,
      1300000000000000000,
      1300000000000000000,
      1000000000937303470807876290,
      3000000000000000,
      50000000000000000,
      0
    );
    _configProvider.setCollateralConfig(
      address(_wbtc),
      6000000000000000000000000,
      1300000000000000000,
      1300000000000000000,
      1000000000937303470807876290,
      3000000000000000,
      50000000000000000,
      0
    );
    _configProvider.setCollateralConfig(
      address(_usdc),
      4000000000000000000000000,
      1100000000000000000,
      1100000000000000000,
      1000000000937303470807876290,
      3000000000000000,
      50000000000000000,
      0
    );

    // Deploy Governance
    _governanceAddressProvider = new GovernanceAddressProvider(IAddressProvider(address(_addressProvider)));
    _debtNotifier = new DebtNotifier(IGovernanceAddressProvider(address(_governanceAddressProvider)));
    _wbtcSupplyMiner = new SupplyMiner(IGovernanceAddressProvider(address(_governanceAddressProvider)));
    _wethSupplyMiner = new SupplyMiner(IGovernanceAddressProvider(address(_governanceAddressProvider)));
    _usdcSupplyMiner = new SupplyMiner(IGovernanceAddressProvider(address(_governanceAddressProvider)));

    // Set Governance
    _vaultsCore.setDebtNotifier(IDebtNotifier(address(_debtNotifier)));
    _governanceAddressProvider.setParallelAddressProvider(IAddressProvider(address(_addressProvider)));
    _governanceAddressProvider.setMIMO(IMIMO(address(_mimo)));
    _governanceAddressProvider.setDebtNotifier(IDebtNotifier(address(_debtNotifier)));

    // Deploy Inception
    _baseAdminInceptionVault = new AdminInceptionVault();
    _baseInceptionVaultsCore = new InceptionVaultsCore();
    _baseInceptionVaultsDataProvider = new InceptionVaultsDataProvider();
    _inceptionVaultFactory = new InceptionVaultFactory(
      address(_baseAdminInceptionVault),
      address(_baseInceptionVaultsCore),
      address(_baseInceptionVaultsDataProvider),
      IAddressProvider(address(_addressProvider)),
      IDebtNotifier(address(_debtNotifier)),
      IWETH(address(_weth)),
      IMIMO(address(_mimo))
    );
    _baseChainlinkInceptionPriceFeed = new ChainlinkInceptionPriceFeed();
    _inceptionVaultFactory.addPriceFeed(address(_baseChainlinkInceptionPriceFeed));
    IInceptionVaultsCore.VaultConfig memory v = IInceptionVaultsCore.VaultConfig({
      liquidationRatio: 1300000000000000000,
      minCollateralRatio: 1500000000000000000,
      borrowRate: 1000000000534535675765102250,
      originationFee: 3000000000000000,
      liquidationBonus: 50000000000000000,
      liquidationFee: 0
    });
    _inceptionVaultFactory.cloneInceptionVault(
      v,
      _link,
      address(_baseChainlinkInceptionPriceFeed),
      address(_linkAggregator)
    );
  }
}",2455
RealWorld_TA_115_IDexAddressProvider_RealWorld_20240815231141.log,115,IDexAddressProvider,28225,2002,30227,98.0,0.181165,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.8.10;

import ""./IAddressProvider.sol"";

interface IDexAddressProvider {
  event DexSet(uint8);

  struct Dex {
    address proxy;
    address router;
  }

  function setDexMapping(
    uint256 _index,
    address _proxy,
    address _dex
  ) external;

  function parallel() external view returns (IAddressProvider);

  function dexMapping(uint256 index) external view returns (address, address);
}",114
RealWorld_TA_115_IMIMO_RealWorld_20240815201913.log,115,IMIMO,23805,1988,25793,119.0,0.158785,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IMIMO is IERC20 {
  function burn(address account, uint256 amount) external;

  function mint(address account, uint256 amount) external;
}",66
RealWorld_TA_115_IAddressProviderV1_RealWorld_20240815190804.log,115,IAddressProviderV1,51917,1653,53570,96.0,0.292645,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""./IConfigProviderV1.sol"";
import ""./ILiquidationManagerV1.sol"";
import ""./IVaultsCoreV1.sol"";
import ""../../interfaces/IVaultsCore.sol"";
import ""../../interfaces/IAccessController.sol"";
import ""../../interfaces/ISTABLEX.sol"";
import ""../../interfaces/IPriceFeed.sol"";
import ""../../interfaces/IRatesManager.sol"";
import ""../../interfaces/IVaultsDataProvider.sol"";
import ""../../interfaces/IFeeDistributor.sol"";

interface IAddressProviderV1 {
  function setAccessController(IAccessController _controller) external;

  function setConfigProvider(IConfigProviderV1 _config) external;

  function setVaultsCore(IVaultsCoreV1 _core) external;

  function setStableX(ISTABLEX _stablex) external;

  function setRatesManager(IRatesManager _ratesManager) external;

  function setPriceFeed(IPriceFeed _priceFeed) external;

  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;

  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;

  function setFeeDistributor(IFeeDistributor _feeDistributor) external;

  function controller() external view returns (IAccessController);

  function config() external view returns (IConfigProviderV1);

  function core() external view returns (IVaultsCoreV1);

  function stablex() external view returns (ISTABLEX);

  function ratesManager() external view returns (IRatesManager);

  function priceFeed() external view returns (IPriceFeed);

  function liquidationManager() external view returns (ILiquidationManagerV1);

  function vaultsData() external view returns (IVaultsDataProvider);

  function feeDistributor() external view returns (IFeeDistributor);
}",398
RealWorld_TA_115_IMIMO_RealWorld_20240815230502.log,115,IMIMO,23817,2018,25835,94.0,0.159445,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IMIMO is IERC20 {
  function burn(address account, uint256 amount) external;

  function mint(address account, uint256 amount) external;
}",66
RealWorld_TA_115_VaultsCoreV1_RealWorld_20240815190307.log,115,VaultsCoreV1,294739,5794,300533,193.0,1.589575,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""../libraries/WadRayMath.sol"";
import ""./interfaces/IVaultsCoreV1.sol"";
import ""./interfaces/ILiquidationManagerV1.sol"";
import ""./interfaces/IAddressProviderV1.sol"";

contract VaultsCoreV1 is IVaultsCoreV1, ReentrancyGuard {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 public constant MAX_INT = 2**256 - 1;

  mapping(address => uint256) public override cumulativeRates;
  mapping(address => uint256) public override lastRefresh;

  IAddressProviderV1 public override a;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));
    _;
  }

  modifier onlyVaultOwner(uint256 _vaultId) {
    require(a.vaultsData().vaultOwner(_vaultId) == msg.sender);
    _;
  }

  modifier onlyConfig() {
    require(msg.sender == address(a.config()));
    _;
  }

  constructor(IAddressProviderV1 _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  /*
    Allow smooth upgrading of the vaultscore.
    @dev this function approves token transfers to the new vaultscore of
    both stablex and all configured collateral types
    @param _newVaultsCore address of the new vaultscore
  */
  function upgrade(address _newVaultsCore) public override onlyManager {
    require(address(_newVaultsCore) != address(0));
    require(a.stablex().approve(_newVaultsCore, MAX_INT));

    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      IERC20 asset = IERC20(collateralType);
      asset.safeApprove(_newVaultsCore, MAX_INT);
    }
  }

  /**
    Calculate the available income
    @return available income that has not been minted yet.
  **/
  function availableIncome() public view override returns (uint256) {
    return a.vaultsData().debt().sub(a.stablex().totalSupply());
  }

  /**
    Refresh the cumulative rates and debts of all vaults and all collateral types.
  **/
  function refresh() public override {
    for (uint256 i = 1; i <= a.config().numCollateralConfigs(); i++) {
      address collateralType = a.config().collateralConfigs(i).collateralType;
      refreshCollateral(collateralType);
    }
  }

  /**
    Initialize the cumulative rates to 1 for a new collateral type.
    @param _collateralType the address of the new collateral type to be initialized
  **/
  function initializeRates(address _collateralType) public override onlyConfig {
    require(_collateralType != address(0));
    lastRefresh[_collateralType] = now;
    cumulativeRates[_collateralType] = WadRayMath.ray();
  }

  /**
    Refresh the cumulative rate of a collateraltype.
    @dev this updates the debt for all vaults with the specified collateral type.
    @param _collateralType the address of the collateral type to be refreshed.
  **/
  function refreshCollateral(address _collateralType) public override {
    require(_collateralType != address(0));
    require(a.config().collateralIds(_collateralType) != 0);
    uint256 timestamp = now;
    uint256 timeElapsed = timestamp.sub(lastRefresh[_collateralType]);
    _refreshCumulativeRate(_collateralType, timeElapsed);
    lastRefresh[_collateralType] = timestamp;
  }

  /**
    Internal function to increase the cumulative rate over a specified time period
    @dev this updates the debt for all vaults with the specified collateral type.
    @param _collateralType the address of the collateral type to be updated
    @param _timeElapsed the amount of time in seconds to add to the cumulative rate
  **/
  function _refreshCumulativeRate(address _collateralType, uint256 _timeElapsed) internal {
    uint256 borrowRate = a.config().collateralBorrowRate(_collateralType);
    uint256 oldCumulativeRate = cumulativeRates[_collateralType];
    cumulativeRates[_collateralType] = a.ratesManager().calculateCumulativeRate(
      borrowRate,
      oldCumulativeRate,
      _timeElapsed
    );
    emit CumulativeRateUpdated(_collateralType, _timeElapsed, cumulativeRates[_collateralType]);
  }

  /**
    Deposit an ERC20 token into the vault of the msg.sender as collateral
    @dev A new vault is created if no vault exists for the `msg.sender` with the specified collateral type.
    this function used `transferFrom()` and requires pre-approval via `approve()` on the ERC20.
    @param _collateralType the address of the collateral type to be deposited
    @param _amount the amount of tokens to be deposited in WEI.
  **/
  function deposit(address _collateralType, uint256 _amount) public override {
    require(a.config().collateralIds(_collateralType) != 0);
    uint256 vaultId = a.vaultsData().vaultId(_collateralType, msg.sender);
    if (vaultId == 0) {
      vaultId = a.vaultsData().createVault(_collateralType, msg.sender);
    }
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(vaultId);
    a.vaultsData().setCollateralBalance(vaultId, v.collateralBalance.add(_amount));

    IERC20 asset = IERC20(v.collateralType);
    asset.safeTransferFrom(msg.sender, address(this), _amount);

    emit Deposited(vaultId, _amount, msg.sender);
  }

  /**
    Withdraws ERC20 tokens from a vault.
    @dev Only te owner of a vault can withdraw collateral from it.
    `withdraw()` will fail if it would bring the vault below the liquidation treshold.
    @param _vaultId the ID of the vault from which to withdraw the collateral.
    @param _amount the amount of ERC20 tokens to be withdrawn in WEI.
  **/
  function withdraw(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);
    require(_amount <= v.collateralBalance);
    uint256 newCollateralBalance = v.collateralBalance.sub(_amount);
    a.vaultsData().setCollateralBalance(_vaultId, newCollateralBalance);
    if (v.baseDebt > 0) {
      //save gas cost when withdrawing from 0 debt vault
      refreshCollateral(v.collateralType);
      uint256 newCollateralValue = a.priceFeed().convertFrom(v.collateralType, newCollateralBalance);
      bool _isHealthy = ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(
        v.collateralType,
        newCollateralValue,
        a.vaultsData().vaultDebt(_vaultId)
      );
      require(_isHealthy);
    }

    IERC20 asset = IERC20(v.collateralType);
    asset.safeTransfer(msg.sender, _amount);
    emit Withdrawn(_vaultId, _amount, msg.sender);
  }

  /**
    Convenience function to withdraw all collateral of a vault
    @dev Only te owner of a vault can withdraw collateral from it.
    `withdrawAll()` will fail if the vault has any outstanding debt attached to it.
    @param _vaultId the ID of the vault from which to withdraw the collateral.
  **/
  function withdrawAll(uint256 _vaultId) public override onlyVaultOwner(_vaultId) {
    uint256 collateralBalance = a.vaultsData().vaultCollateralBalance(_vaultId);
    withdraw(_vaultId, collateralBalance);
  }

  /**
    Borrow new StableX (Eg: PAR) tokens from a vault.
    @dev Only te owner of a vault can borrow from it.
    `borrow()` will update the outstanding vault debt to the current time before attempting the withdrawal.
     and will fail if it would bring the vault below the liquidation treshold.
    @param _vaultId the ID of the vault from which to borrow.
    @param _amount the amount of borrowed StableX tokens in WEI.
  **/
  function borrow(uint256 _vaultId, uint256 _amount) public override onlyVaultOwner(_vaultId) nonReentrant {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    //make sure current rate is up to date
    refreshCollateral(v.collateralType);

    uint256 originationFeePercentage = a.config().collateralOriginationFee(v.collateralType);
    uint256 newDebt = _amount;
    if (originationFeePercentage > 0) {
      newDebt = newDebt.add(_amount.wadMul(originationFeePercentage));
    }

    // Increment vault borrow balance
    uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(newDebt, cumulativeRates[v.collateralType]);

    a.vaultsData().setBaseDebt(_vaultId, v.baseDebt.add(newBaseDebt));

    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);
    uint256 newVaultDebt = a.vaultsData().vaultDebt(_vaultId);

    require(a.vaultsData().collateralDebt(v.collateralType) <= a.config().collateralDebtLimit(v.collateralType));

    bool isHealthy = ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(
      v.collateralType,
      collateralValue,
      newVaultDebt
    );
    require(isHealthy);

    a.stablex().mint(msg.sender, _amount);
    emit Borrowed(_vaultId, _amount, msg.sender);
  }

  /**
    Convenience function to repay all debt of a vault
    @dev `repayAll()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the debt.
  **/
  function repayAll(uint256 _vaultId) public override {
    repay(_vaultId, 2**256 - 1);
  }

  /**
    Repay an outstanding StableX balance to a vault.
    @dev `repay()` will update the outstanding vault debt to the current time.
    @param _vaultId the ID of the vault for which to repay the outstanding debt balance.
    @param _amount the amount of StableX tokens in WEI to be repaid.
  **/
  function repay(uint256 _vaultId, uint256 _amount) public override nonReentrant {
    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);

    // Make sure current rate is up to date
    refreshCollateral(collateralType);

    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);
    // Decrement vault borrow balance
    if (_amount >= currentVaultDebt) {
      //full repayment
      _amount = currentVaultDebt; //only pay back what's outstanding
    }
    _reduceVaultDebt(_vaultId, _amount);
    a.stablex().burn(msg.sender, _amount);

    emit Repaid(_vaultId, _amount, msg.sender);
  }

  /**
    Internal helper function to reduce the debt of a vault.
    @dev assumes cumulative rates for the vault's collateral type are up to date.
    please call `refreshCollateral()` before calling this function.
    @param _vaultId the ID of the vault for which to reduce the debt.
    @param _amount the amount of debt to be reduced.
  **/
  function _reduceVaultDebt(uint256 _vaultId, uint256 _amount) internal {
    address collateralType = a.vaultsData().vaultCollateralType(_vaultId);

    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);
    uint256 remainder = currentVaultDebt.sub(_amount);
    uint256 cumulativeRate = cumulativeRates[collateralType];

    if (remainder == 0) {
      a.vaultsData().setBaseDebt(_vaultId, 0);
    } else {
      uint256 newBaseDebt = a.ratesManager().calculateBaseDebt(remainder, cumulativeRate);
      a.vaultsData().setBaseDebt(_vaultId, newBaseDebt);
    }
  }

  /**
    Liquidate a vault that is below the liquidation treshold by repaying it's outstanding debt.
    @dev `liquidate()` will update the outstanding vault debt to the current time and pay a `liquidationBonus`
    to the liquidator. `liquidate()` can be called by anyone.
    @param _vaultId the ID of the vault to be liquidated.
  **/
  function liquidate(uint256 _vaultId) public override nonReentrant {
    IVaultsDataProvider.Vault memory v = a.vaultsData().vaults(_vaultId);

    refreshCollateral(v.collateralType);

    uint256 collateralValue = a.priceFeed().convertFrom(v.collateralType, v.collateralBalance);
    uint256 currentVaultDebt = a.vaultsData().vaultDebt(_vaultId);

    require(
      !ILiquidationManagerV1(address(a.liquidationManager())).isHealthy(
        v.collateralType,
        collateralValue,
        currentVaultDebt
      )
    );

    uint256 discountedValue = ILiquidationManagerV1(address(a.liquidationManager())).applyLiquidationDiscount(
      collateralValue
    );
    uint256 collateralToReceive;
    uint256 stableXToPay = currentVaultDebt;

    if (discountedValue < currentVaultDebt) {
      //Insurance Case
      uint256 insuranceAmount = currentVaultDebt.sub(discountedValue);
      require(a.stablex().balanceOf(address(this)) >= insuranceAmount);
      a.stablex().burn(address(this), insuranceAmount);
      emit InsurancePaid(_vaultId, insuranceAmount, msg.sender);
      collateralToReceive = v.collateralBalance;
      stableXToPay = currentVaultDebt.sub(insuranceAmount);
    } else {
      collateralToReceive = a.priceFeed().convertTo(v.collateralType, currentVaultDebt);
      collateralToReceive = collateralToReceive.add(
        ILiquidationManagerV1(address(a.liquidationManager())).liquidationBonus(collateralToReceive)
      );
    }
    // reduce the vault debt to 0
    _reduceVaultDebt(_vaultId, currentVaultDebt);
    a.stablex().burn(msg.sender, stableXToPay);

    // send the collateral to the liquidator
    a.vaultsData().setCollateralBalance(_vaultId, v.collateralBalance.sub(collateralToReceive));
    IERC20 asset = IERC20(v.collateralType);
    asset.safeTransfer(msg.sender, collateralToReceive);

    emit Liquidated(_vaultId, stableXToPay, collateralToReceive, v.owner, msg.sender);
  }
}",3344
RealWorld_TA_115_IInceptionVaultsDataProvider_RealWorld_20240815212301.log,115,IInceptionVaultsDataProvider,47126,2577,49703,103.0,0.28717,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""./IInceptionVaultsCore.sol"";
import ""../../interfaces/IAddressProvider.sol"";

interface IInceptionVaultsDataProvider {
  struct InceptionVault {
    address owner;
    uint256 collateralBalance;
    uint256 baseDebt;
    uint256 createdAt;
  }

  //Write
  function initialize(IInceptionVaultsCore _inceptionVaultsCore, IAddressProvider _addressProvider) external;

  function createVault(address _owner) external returns (uint256);

  function setCollateralBalance(uint256 _id, uint256 _balance) external;

  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;

  // Read
  function a() external view returns (IAddressProvider);

  function inceptionVaultsCore() external view returns (IInceptionVaultsCore);

  function inceptionVaultCount() external view returns (uint256);

  function baseDebt() external view returns (uint256);

  function vaults(uint256 _id) external view returns (InceptionVault memory);

  function vaultOwner(uint256 _id) external view returns (address);

  function vaultCollateralBalance(uint256 _id) external view returns (uint256);

  function vaultBaseDebt(uint256 _id) external view returns (uint256);

  function vaultId(address _owner) external view returns (uint256);

  function vaultExists(uint256 _id) external view returns (bool);

  function vaultDebt(uint256 _vaultId) external view returns (uint256);
}",340
RealWorld_TA_115_MockGUniPool_RealWorld_20240815185235.log,115,MockGUniPool,35832,2717,38549,104.0,0.2335,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../interfaces/IGUniPool.sol"";

contract MockGUniPool is IGUniPool {
  address public override token0;
  address public override token1;
  uint256 public override totalSupply;
  uint256 public balance0;
  uint256 public balance1;

  constructor(address _token0, address _token1) public {
    token0 = _token0;
    token1 = _token1;
  }

  function setBalance(uint256 _balance0, uint256 _balance1) public {
    balance0 = _balance0;
    balance1 = _balance1;
  }

  function setTotalSupply(uint256 supply) public {
    totalSupply = supply;
  }

  function getUnderlyingBalancesAtPrice(uint160) external view override returns (uint256, uint256) {
    return (balance0, balance1);
  }
}",194
RealWorld_TA_115_IVaultsCore_RealWorld_20240815221218.log,115,IVaultsCore,64841,2302,67143,100.0,0.370245,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../interfaces/IAddressProvider.sol"";
import ""../interfaces/IVaultsCoreState.sol"";
import ""../interfaces/IWETH.sol"";
import ""../liquidityMining/interfaces/IDebtNotifier.sol"";

interface IVaultsCore {
  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);
  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);
  event Liquidated(
    uint256 indexed vaultId,
    uint256 debtRepaid,
    uint256 collateralLiquidated,
    address indexed owner,
    address indexed sender
  );

  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);

  function deposit(address _collateralType, uint256 _amount) external;

  function depositETH() external payable;

  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;

  function depositETHByVaultId(uint256 _vaultId) external payable;

  function depositAndBorrow(
    address _collateralType,
    uint256 _depositAmount,
    uint256 _borrowAmount
  ) external;

  function depositETHAndBorrow(uint256 _borrowAmount) external payable;

  function withdraw(uint256 _vaultId, uint256 _amount) external;

  function withdrawETH(uint256 _vaultId, uint256 _amount) external;

  function borrow(uint256 _vaultId, uint256 _amount) external;

  function repayAll(uint256 _vaultId) external;

  function repay(uint256 _vaultId, uint256 _amount) external;

  function liquidate(uint256 _vaultId) external;

  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;

  function upgrade(address payable _newVaultsCore) external;

  function acceptUpgrade(address payable _oldVaultsCore) external;

  function setDebtNotifier(IDebtNotifier _debtNotifier) external;

  //Read only
  function a() external view returns (IAddressProvider);

  function WETH() external view returns (IWETH);

  function debtNotifier() external view returns (IDebtNotifier);

  function state() external view returns (IVaultsCoreState);

  function cumulativeRates(address _collateralType) external view returns (uint256);
}",551
RealWorld_TA_115_IUniswapV2Router02_RealWorld_20240815213812.log,115,IUniswapV2Router02,43295,1906,45201,91.0,0.254595,"pragma solidity 0.6.12;

import ""./IUniswapV2Router01.sol"";

interface IUniswapV2Router02 is IUniswapV2Router01 {
  function removeLiquidityETHSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountETH);

  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
    address token,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline,
    bool approveMax,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external returns (uint256 amountETH);

  function swapExactTokensForTokensSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;

  function swapExactETHForTokensSupportingFeeOnTransferTokens(
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external payable;

  function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    address[] calldata path,
    address to,
    uint256 deadline
  ) external;
}",312
RealWorld_TA_115_IBalancerPool_RealWorld_20240815223243.log,115,IBalancerPool,22786,1475,24261,89.0,0.14343,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IBalancerPool {
  function getNormalizedWeights() external view returns (uint256[] memory);

  function totalSupply() external view returns (uint256);
}",50
RealWorld_TA_115_IBalancerVault_RealWorld_20240815222928.log,115,IBalancerVault,44732,1343,46075,92.0,0.25052,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IBalancerVault {
  enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }

  /**
   * @dev Returns a Pool's contract address and specialization setting.
   */
  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);

  /**
   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of
   * the tokens' `balances` changed.
   *
   * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all
   * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.
   *
   * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same
   * order as passed to `registerTokens`.
   *
   * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are
   * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`
   * instead.
   */
  function getPoolTokens(bytes32 poolId)
    external
    view
    returns (
      address[] memory tokens,
      uint256[] memory balances,
      uint256 lastChangeBlock
    );
}",314
RealWorld_TA_115_IAccessController_RealWorld_20240815221045.log,115,IAccessController,36522,1288,37810,90.0,0.20837,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IAccessController {
  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

  function grantRole(bytes32 role, address account) external;

  function revokeRole(bytes32 role, address account) external;

  function renounceRole(bytes32 role, address account) external;

  function MANAGER_ROLE() external view returns (bytes32);

  function MINTER_ROLE() external view returns (bytes32);

  function hasRole(bytes32 role, address account) external view returns (bool);

  function getRoleMemberCount(bytes32 role) external view returns (uint256);

  function getRoleMember(bytes32 role, uint256 index) external view returns (address);

  function getRoleAdmin(bytes32 role) external view returns (bytes32);
}",216
RealWorld_TA_115_MockWETH_RealWorld_20240815184846.log,115,MockWETH,29623,4577,34200,124.0,0.239655,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract MockWETH is ERC20(""Wrapped Ether"", ""WETH"") {
  function mint(address account, uint256 amount) public {
    _mint(account, amount);
  }

  function deposit() public payable {
    _mint(msg.sender, msg.value);
  }

  function withdraw(uint256 wad) public {
    _burn(msg.sender, wad);
    msg.sender.transfer(wad);
  }
}",116
RealWorld_TA_115_IMIMODistributor_RealWorld_20240815201354.log,115,IMIMODistributor,29597,1580,31177,92.0,0.179585,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./IBaseDistributor.sol"";

interface IMIMODistributorExtension {
  function startTime() external view returns (uint256);

  function currentIssuance() external view returns (uint256);

  function weeklyIssuanceAt(uint256 timestamp) external view returns (uint256);

  function totalSupplyAt(uint256 timestamp) external view returns (uint256);
}

interface IMIMODistributor is IBaseDistributor, IMIMODistributorExtension {}",130
RealWorld_TA_115_DebtNotifier_RealWorld_20240815194954.log,115,DebtNotifier,57473,2524,59997,99.0,0.337845,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/ISupplyMiner.sol"";
import ""../interfaces/IVaultsDataProvider.sol"";

contract DebtNotifier is IDebtNotifier {
  IGovernanceAddressProvider public override a;
  mapping(address => ISupplyMiner) public override collateralSupplyMinerMapping;

  constructor(IGovernanceAddressProvider _addresses) public {
    require(address(_addresses) != address(0));
    a = _addresses;
  }

  modifier onlyVaultsCore() {
    require(msg.sender == address(a.parallel().core()), ""Caller is not VaultsCore"");
    _;
  }

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender));
    _;
  }

  /**
    Notifies the correct supplyMiner of a change in debt.
    @dev Only the vaultsCore can call this.
    `debtChanged` will silently return if collateralType is not known to prevent any problems in vaultscore.
    @param _vaultId the ID of the vault of which the debt has changed.
  **/
  function debtChanged(uint256 _vaultId) public override onlyVaultsCore {
    IVaultsDataProvider.Vault memory v = a.parallel().vaultsData().vaults(_vaultId);

    ISupplyMiner supplyMiner = collateralSupplyMinerMapping[v.collateralType];
    if (address(supplyMiner) == address(0)) {
      // not throwing error so VaultsCore keeps working
      return;
    }
    supplyMiner.baseDebtChanged(v.owner, v.baseDebt);
  }

  /**
    Updates the collateral to supplyMiner mapping.
    @dev Manager role in the AccessController is required to call this.
    @param collateral the address of the collateralType.
    @param supplyMiner the address of the supplyMiner which will be notified on debt changes for this collateralType.
  **/
  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) public override onlyManager {
    collateralSupplyMinerMapping[collateral] = supplyMiner;
  }
}",471
RealWorld_TA_115_BaseDistributor_RealWorld_20240815194132.log,115,BaseDistributor,100183,4573,104756,124.0,0.592375,"// SPDX-License-Identifier: MIT

pragma experimental ABIEncoderV2;
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""../libraries/WadRayMath.sol"";
import ""../governance/interfaces/IGovernanceAddressProvider.sol"";
import ""./interfaces/IBaseDistributor.sol"";

/*
  	Distribution Formula:
  	55.5m MIMO in first week
  	-5.55% redution per week

  	total(timestamp) = _SECONDS_PER_WEEK * ( (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)) / (1-weeklyR) )
  		+ timestamp % _SECONDS_PER_WEEK * (1-weeklyR^(timestamp/_SECONDS_PER_WEEK)
  */

abstract contract BaseDistributor is IBaseDistributor {
  using SafeMath for uint256;
  using WadRayMath for uint256;

  uint256 public override totalShares;
  mapping(address => uint256) public override shares;
  address[] public payees;

  IGovernanceAddressProvider public override a;

  modifier onlyManager() {
    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), ""Caller is not Manager"");
    _;
  }

  /**
    Public function to release the accumulated new MIMO tokens to the payees.
    @dev anyone can call this.
  */
  function release() public override {
    uint256 newTokens = mintableTokens();
    require(newTokens > 0, ""newTokens is 0"");
    require(payees.length > 0, ""Payees not configured yet"");
    // Mint MIMO to all receivers
    for (uint256 i = 0; i < payees.length; i++) {
      address payee = payees[i];
      _release(newTokens, payee);
    }
    emit TokensReleased(newTokens, now);
  }

  /**
    Updates the payee configuration to a new one.
    @dev will release existing fees before the update.
    @param _payees Array of payees
    @param _shares Array of shares for each payee
  */
  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {
    require(_payees.length == _shares.length, ""Payees and shares mismatched"");
    require(_payees.length > 0, ""No payees"");

    if (payees.length > 0 && mintableTokens() > 0) {
      release();
    }

    for (uint256 i = 0; i < payees.length; i++) {
      delete shares[payees[i]];
    }
    delete payees;
    totalShares = 0;

    for (uint256 i = 0; i < _payees.length; i++) {
      _addPayee(_payees[i], _shares[i]);
    }
  }

  /**
    Get current configured payees.
    @return array of current payees.
  */
  function getPayees() public view override returns (address[] memory) {
    return payees;
  }

  /**
    Calculates how many MIMO tokens can be minted since the last time tokens were minted
    @return number of mintable tokens available right now.
  */
  function mintableTokens() public view virtual override returns (uint256);

  /**
    Internal function to release a percentage of newTokens to a specific payee
    @dev uses totalShares to calculate correct share
    @param _totalnewTokensReceived Total newTokens for all payees, will be split according to shares
    @param _payee The address of the payee to whom to distribute the fees.
  */
  function _release(uint256 _totalnewTokensReceived, address _payee) internal virtual;

  /**
    Internal function to add a new payee.
    @dev will update totalShares and therefore reduce the relative share of all other payees.
    @param _payee The address of the payee to add.
    @param _shares The number of shares owned by the payee.
  */
  function _addPayee(address _payee, uint256 _shares) internal {
    require(_payee != address(0), ""payee is the zero address"");
    require(_shares > 0, ""shares are 0"");
    require(shares[_payee] == 0, ""payee already has shares"");

    payees.push(_payee);
    shares[_payee] = _shares;
    totalShares = totalShares.add(_shares);
    emit PayeeAdded(_payee, _shares);
  }
}",967
RealWorld_TA_123_PoolManagerV3_RealWorld_20240815234735.log,123,PoolManagerV3,77953,4203,82156,123.0,0.473825,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""./interfaces/IGaugeController.sol"";

/** 
 * @title   PoolManagerV3
 * @author  ConvexFinance
 * @notice  Pool Manager v3
 *          PoolManagerV3 calls addPool on PoolManagerShutdownProxy which calls
 *          addPool on PoolManagerProxy which calls addPool on Booster. 
 *          PoolManager-ception
 * @dev     Add pools to the Booster contract
 */
contract PoolManagerV3{

    address public immutable pools;
    address public immutable gaugeController;
    address public operator;

    bool public protectAddPool;
    
    /**
     * @param _pools            Currently PoolManagerSecondaryProxy
     * @param _gaugeController  Curve gauge controller e.g: (0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB)
     * @param _operator         Convex multisig
     */
    constructor(
        address _pools, 
        address _gaugeController, 
        address _operator
    ) public {
        pools = _pools;
        gaugeController = _gaugeController;
        operator = _operator;
        protectAddPool = true;
    }

    function setOperator(address _operator) external {
        require(msg.sender == operator, ""!auth"");
        operator = _operator;
    }
  
    /**
     * @notice set if addPool is only callable by operator
     */
    function setProtectPool(bool _protectAddPool) external {
        require(msg.sender == operator, ""!auth"");
        protectAddPool = _protectAddPool;
    }

    /**
     * @notice Add a new curve pool to the system. (default stash to v3)
     */
    function addPool(address _gauge) external returns(bool){
        _addPool(_gauge,3);
        return true;
    }

    /**
     * @notice Add a new curve pool to the system
     */
    function addPool(address _gauge, uint256 _stashVersion) external returns(bool){
        _addPool(_gauge,_stashVersion);
        return true;
    }

    function _addPool(address _gauge, uint256 _stashVersion) internal{
        if(protectAddPool) {
            require(msg.sender == operator, ""!auth"");
        }
        //get lp token from gauge
        address lptoken = ICurveGauge(_gauge).lp_token();

        //gauge/lptoken address checks will happen in the next call
        IPools(pools).addPool(lptoken,_gauge,_stashVersion);
    }

    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool){
        require(msg.sender==operator, ""!auth"");
        
        //force add pool without weight checks (can only be used on new token and gauge addresses)
        return IPools(pools).forceAddPool(_lptoken, _gauge, _stashVersion);
    }

    function shutdownPool(uint256 _pid) external returns(bool){
        require(msg.sender==operator, ""!auth"");

        IPools(pools).shutdownPool(_pid);
        return true;
    }

}",685
RealWorld_TA_123_BaseRewardPool_RealWorld_20240816000012.log,123,BaseRewardPool,258282,5227,263509,150.0,1.39595,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
/**
 *Submitted for verification at Etherscan.io on 2020-07-17
 */

/*
   ____            __   __        __   _
  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __
 _\ \ / // // _ \/ __// _ \/ -_)/ __// / \ \ /
/___/ \_, //_//_/\__//_//_/\__/ \__//_/ /_\_\
     /___/

* Synthetix: BaseRewardPool.sol
*
* Docs: https://docs.synthetix.io/
*
*
* MIT License
* ===========
*
* Copyright (c) 2020 Synthetix
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the ""Software""), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*/

import ""./Interfaces.sol"";
import ""./interfaces/MathUtil.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";


/**
 * @title   BaseRewardPool
 * @author  Synthetix -> ConvexFinance
 * @notice  Unipool rewards contract that is re-deployed from rFactory for each staking pool.
 * @dev     Changes made here by ConvexFinance are to do with the delayed reward allocation. Curve is queued for
 *          rewards and the distribution only begins once the new rewards are sufficiently large, or the epoch
 *          has ended. Additionally, enables hooks for `extraRewards` that can be enabled at any point to
 *          distribute a child reward token (i.e. a secondary one from Curve, or a seperate one).
 */
contract BaseRewardPool {
     using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable rewardToken;
    IERC20 public immutable stakingToken;
    uint256 public constant duration = 7 days;

    address public immutable operator;
    address public immutable rewardManager;

    uint256 public immutable pid;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    uint256 public queuedRewards = 0;
    uint256 public currentRewards = 0;
    uint256 public historicalRewards = 0;
    uint256 public constant newRewardRatio = 830;
    uint256 private _totalSupply;
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;
    mapping(address => uint256) private _balances;

    address[] public extraRewards;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);

    /**
     * @dev This is called directly from RewardFactory
     * @param pid_           Effectively the pool identifier - used in the Booster
     * @param stakingToken_  Pool LP token
     * @param rewardToken_   Crv
     * @param operator_      Booster
     * @param rewardManager_ RewardFactory
     */
    constructor(
        uint256 pid_,
        address stakingToken_,
        address rewardToken_,
        address operator_,
        address rewardManager_
    ) public {
        pid = pid_;
        stakingToken = IERC20(stakingToken_);
        rewardToken = IERC20(rewardToken_);
        operator = operator_;
        rewardManager = rewardManager_;
    }

    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    function extraRewardsLength() external view returns (uint256) {
        return extraRewards.length;
    }

    function addExtraReward(address _reward) external returns(bool){
        require(msg.sender == rewardManager, ""!authorized"");
        require(_reward != address(0),""!reward setting"");

        extraRewards.push(_reward);
        return true;
    }
    function clearExtraRewards() external{
        require(msg.sender == rewardManager, ""!authorized"");
        delete extraRewards;
    }

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return MathUtil.min(block.timestamp, periodFinish);
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalSupply() == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable()
                    .sub(lastUpdateTime)
                    .mul(rewardRate)
                    .mul(1e18)
                    .div(totalSupply())
            );
    }

    function earned(address account) public view returns (uint256) {
        return
            balanceOf(account)
                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))
                .div(1e18)
                .add(rewards[account]);
    }

    function stake(uint256 _amount)
        public 
        returns(bool)
    {
        _processStake(_amount, msg.sender);

        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        emit Staked(msg.sender, _amount);

        return true;
    }

    function stakeAll() external returns(bool){
        uint256 balance = stakingToken.balanceOf(msg.sender);
        stake(balance);
        return true;
    }

    function stakeFor(address _for, uint256 _amount)
        public
        returns(bool)
    {
        _processStake(_amount, _for);

        //take away from sender
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        emit Staked(_for, _amount);
        
        return true;
    }

    /**
     * @dev Generic internal staking function that basically does 3 things: update rewards based
     *      on previous balance, trigger also on any child contracts, then update balances.
     * @param _amount    Units to add to the users balance
     * @param _receiver  Address of user who will receive the stake
     */
    function _processStake(uint256 _amount, address _receiver) internal updateReward(_receiver) {
        require(_amount > 0, 'RewardPool : Cannot stake 0');
        
        //also stake to linked rewards
        for(uint i=0; i < extraRewards.length; i++){
            IRewards(extraRewards[i]).stake(_receiver, _amount);
        }

        _totalSupply = _totalSupply.add(_amount);
        _balances[_receiver] = _balances[_receiver].add(_amount);
    }

    function withdraw(uint256 amount, bool claim)
        public
        updateReward(msg.sender)
        returns(bool)
    {
        require(amount > 0, 'RewardPool : Cannot withdraw 0');

        //also withdraw from linked rewards
        for(uint i=0; i < extraRewards.length; i++){
            IRewards(extraRewards[i]).withdraw(msg.sender, amount);
        }

        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);

        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
     
        if(claim){
            getReward(msg.sender,true);
        }

        return true;
    }

    function withdrawAll(bool claim) external{
        withdraw(_balances[msg.sender],claim);
    }

    function withdrawAndUnwrap(uint256 amount, bool claim) public returns(bool){
        _withdrawAndUnwrapTo(amount, msg.sender, msg.sender);
        //get rewards too
        if(claim){
            getReward(msg.sender,true);
        }
        return true;
    }

    function _withdrawAndUnwrapTo(uint256 amount, address from, address receiver) internal updateReward(from) returns(bool){
        //also withdraw from linked rewards
        for(uint i=0; i < extraRewards.length; i++){
            IRewards(extraRewards[i]).withdraw(from, amount);
        }
        
        _totalSupply = _totalSupply.sub(amount);
        _balances[from] = _balances[from].sub(amount);

        //tell operator to withdraw from here directly to user
        IDeposit(operator).withdrawTo(pid,amount,receiver);
        emit Withdrawn(from, amount);

        return true;
    }

    function withdrawAllAndUnwrap(bool claim) external{
        withdrawAndUnwrap(_balances[msg.sender],claim);
    }

    /**
     * @dev Gives a staker their rewards, with the option of claiming extra rewards
     * @param _account     Account for which to claim
     * @param _claimExtras Get the child rewards too?
     */
    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){
        uint256 reward = earned(_account);
        if (reward > 0) {
            rewards[_account] = 0;
            rewardToken.safeTransfer(_account, reward);
            IDeposit(operator).rewardClaimed(pid, _account, reward);
            emit RewardPaid(_account, reward);
        }

        //also get rewards from linked rewards
        if(_claimExtras){
            for(uint i=0; i < extraRewards.length; i++){
                IRewards(extraRewards[i]).getReward(_account);
            }
        }
        return true;
    }

    /**
     * @dev Called by a staker to get their allocated rewards
     */
    function getReward() external returns(bool){
        getReward(msg.sender,true);
        return true;
    }

    /**
     * @dev Donate some extra rewards to this contract
     */
    function donate(uint256 _amount) external returns(bool){
        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);
        queuedRewards = queuedRewards.add(_amount);
    }

    /**
     * @dev Processes queued rewards in isolation, providing the period has finished.
     *      This allows a cheaper way to trigger rewards on low value pools.
     */
    function processIdleRewards() external {
        if (block.timestamp >= periodFinish && queuedRewards > 0) {
            notifyRewardAmount(queuedRewards);
            queuedRewards = 0;
        }
    }

    /**
     * @dev Called by the booster to allocate new Crv rewards to this pool
     *      Curve is queued for rewards and the distribution only begins once the new rewards are sufficiently
     *      large, or the epoch has ended.
     */
    function queueNewRewards(uint256 _rewards) external returns(bool){
        require(msg.sender == operator, ""!authorized"");

        _rewards = _rewards.add(queuedRewards);

        if (block.timestamp >= periodFinish) {
            notifyRewardAmount(_rewards);
            queuedRewards = 0;
            return true;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);

        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);
        if(queuedRatio < newRewardRatio){
            notifyRewardAmount(_rewards);
            queuedRewards = 0;
        }else{
            queuedRewards = _rewards;
        }
        return true;
    }

    function notifyRewardAmount(uint256 reward)
        internal
        updateReward(address(0))
    {
        historicalRewards = historicalRewards.add(reward);
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(duration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            reward = reward.add(leftover);
            rewardRate = reward.div(duration);
        }
        currentRewards = reward;
        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(duration);
        emit RewardAdded(reward);
    }
}",2891
RealWorld_TA_123_PoolManagerSecondaryProxy_RealWorld_20240815235745.log,123,PoolManagerSecondaryProxy,109317,5300,114617,145.0,0.652585,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""./interfaces/IGaugeController.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";

/**
 * @title   PoolManagerSecondaryProxy
 * @author  ConvexFinance
 * @notice  Basically a PoolManager that has a better shutdown and calls addPool on PoolManagerProxy. 
 *          Immutable pool manager proxy to enforce that when a  pool is shutdown, the proper number
 *          of lp tokens are returned to the booster contract for withdrawal.
 */
contract PoolManagerSecondaryProxy{
    using SafeMath for uint256;

    address public immutable gaugeController;
    address public immutable pools;
    address public immutable booster;
    address public owner;
    address public operator;
    bool public isShutdown;

    mapping(address => bool) public usedMap;

    /**
     * @param _gaugeController Curve Gauge controller (0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB)
     * @param _pools PoolManagerProxy (0x5F47010F230cE1568BeA53a06eBAF528D05c5c1B)
     * @param _booster Booster
     * @param _owner Executoor
     */
    constructor(
        address _gaugeController,
        address _pools,
        address _booster,
        address _owner
    ) public {
        gaugeController = _gaugeController;
        pools = _pools;
        booster = _booster;
        owner = _owner; 
        operator = msg.sender;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""!owner"");
        _;
    }

    modifier onlyOperator() {
        require(operator == msg.sender, ""!op"");
        _;
    }

    //set owner - only OWNER
    function setOwner(address _owner) external onlyOwner{
        owner = _owner;
    }

    //set operator - only OWNER
    function setOperator(address _operator) external onlyOwner{
        operator = _operator;
    }

    //manual set an address to used state
    function setUsedAddress(address[] memory usedList) external onlyOwner{
        for(uint i=0; i < usedList.length; i++){
            usedMap[usedList[i]] = true;
        }
    }

    //shutdown pool management and disallow new pools. change is immutable
    function shutdownSystem() external onlyOwner{
        isShutdown = true;
    }

    /**
     * @notice  Shutdown a pool - only OPERATOR
     * @dev     Shutdowns a pool and ensures all the LP tokens are properly
     *          withdrawn to the Booster contract 
     */
    function shutdownPool(uint256 _pid) external onlyOperator returns(bool){
        //get pool info
        (address lptoken, address depositToken,,,,bool isshutdown) = IPools(booster).poolInfo(_pid);
        require(!isshutdown, ""already shutdown"");

        //shutdown pool and get before and after amounts
        uint256 beforeBalance = IERC20(lptoken).balanceOf(booster);
        IPools(pools).shutdownPool(_pid);
        uint256 afterBalance = IERC20(lptoken).balanceOf(booster);

        //check that proper amount of tokens were withdrawn(will also fail if already shutdown)
        require( afterBalance.sub(beforeBalance) >= IERC20(depositToken).totalSupply(), ""supply mismatch"");

        return true;
    }

    //add a new pool if it has weight on the gauge controller - only OPERATOR
    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){
        //check that the pool as weight
        uint256 weight = IGaugeController(gaugeController).get_gauge_weight(_gauge);
        require(weight > 0, ""must have weight"");

        return _addPool(_lptoken, _gauge, _stashVersion);
    }

    //force add a new pool, but only for addresses that have never been used before - only OPERATOR
    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){
        require(!usedMap[_lptoken] && !usedMap[_gauge], ""cant force used pool"");

        return _addPool(_lptoken, _gauge, _stashVersion);
    }

    //internal add pool and updated used list
    function _addPool(address _lptoken, address _gauge, uint256 _stashVersion) internal returns(bool){
        require(!isShutdown, ""shutdown"");

        usedMap[_lptoken] = true;
        usedMap[_gauge] = true;

        return IPools(pools).addPool(_lptoken,_gauge,_stashVersion);
    }
}",1062
RealWorld_TA_123_AuraClaimZap_RealWorld_20240816004208.log,123,AuraClaimZap,204673,4995,209668,154.0,1.123265,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { AuraMath } from ""./AuraMath.sol"";
import { IAuraLocker, ICrvDepositorWrapper } from ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";

interface IBasicRewards {
    function getReward(address _account, bool _claimExtras) external;

    function getReward(address _account) external;

    function getReward(address _account, address _token) external;

    function stakeFor(address, uint256) external;
}

/**
 * @title   ClaimZap
 * @author  ConvexFinance -> AuraFinance
 * @notice  Claim zap to bundle various reward claims
 * @dev     Claims from all pools, and stakes cvxCrv and CVX if wanted.
 *          v2:
 *           - change exchange to use curve pool
 *           - add getReward(address,token) type
 *           - add option to lock cvx
 *           - add option use all funds in wallet
 */
contract AuraClaimZap {
    using SafeERC20 for IERC20;
    using AuraMath for uint256;

    address public immutable crv;
    address public immutable cvx;
    address public immutable cvxCrv;
    address public immutable crvDepositWrapper;
    address public immutable cvxCrvRewards;
    address public immutable locker;
    address public immutable owner;

    enum Options {
        ClaimCvxCrv, //1
        ClaimLockedCvx, //2
        ClaimLockedCvxStake, //4
        LockCrvDeposit, //8
        UseAllWalletFunds, //16
        LockCvx //32
    }

    /**
     * @param _crv                CRV token (0xD533a949740bb3306d119CC777fa900bA034cd52);
     * @param _cvx                CVX token (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
     * @param _cvxCrv             cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);
     * @param _crvDepositWrapper  crvDepositWrapper (0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae);
     * @param _cvxCrvRewards      cvxCrvRewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
     * @param _locker             vlCVX (0xD18140b4B819b895A3dba5442F959fA44994AF50);
     */
    constructor(
        address _crv,
        address _cvx,
        address _cvxCrv,
        address _crvDepositWrapper,
        address _cvxCrvRewards,
        address _locker
    ) {
        crv = _crv;
        cvx = _cvx;
        cvxCrv = _cvxCrv;
        crvDepositWrapper = _crvDepositWrapper;
        cvxCrvRewards = _cvxCrvRewards;
        locker = _locker;
        owner = msg.sender;
    }

    function getName() external pure returns (string memory) {
        return ""ClaimZap V2.0"";
    }

    /**
     * @notice Approve spending of:
     *          crv     -> crvDepositor
     *          cvxCrv  -> cvxCrvRewards
     *          cvx     -> Locker
     */
    function setApprovals() external {
        require(msg.sender == owner, ""!auth"");

        IERC20(crv).safeApprove(crvDepositWrapper, 0);
        IERC20(crv).safeApprove(crvDepositWrapper, type(uint256).max);

        IERC20(cvxCrv).safeApprove(cvxCrvRewards, 0);
        IERC20(cvxCrv).safeApprove(cvxCrvRewards, type(uint256).max);

        IERC20(cvx).safeApprove(locker, 0);
        IERC20(cvx).safeApprove(locker, type(uint256).max);
    }

    /**
     * @notice Use bitmask to check if option flag is set
     */
    function _checkOption(uint256 _mask, uint256 _flag) internal pure returns (bool) {
        return (_mask & (1 << _flag)) != 0;
    }

    /**
     * @notice Claim all the rewards
     * @param rewardContracts       Array of addresses for LP token rewards
     * @param extraRewardContracts  Array of addresses for extra rewards
     * @param tokenRewardContracts  Array of addresses for token rewards e.g vlCvxExtraRewardDistribution
     * @param tokenRewardTokens     Array of token reward addresses to use with tokenRewardContracts
     * @param depositCrvMaxAmount   The max amount of CRV to deposit if converting to crvCvx
     * @param minAmountOut          The min amount out for crv:cvxCrv swaps if swapping. Set this to zero if you
     *                              want to use CrvDepositor instead of balancer swap
     * @param depositCvxMaxAmount   The max amount of CVX to deposit if locking CVX
     * @param options               Claim options
     */
    function claimRewards(
        address[] calldata rewardContracts,
        address[] calldata extraRewardContracts,
        address[] calldata tokenRewardContracts,
        address[] calldata tokenRewardTokens,
        uint256 depositCrvMaxAmount,
        uint256 minAmountOut,
        uint256 depositCvxMaxAmount,
        uint256 options
    ) external {
        require(tokenRewardContracts.length == tokenRewardTokens.length, ""!parity"");

        uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);
        uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);

        //claim from main curve LP pools
        for (uint256 i = 0; i < rewardContracts.length; i++) {
            IBasicRewards(rewardContracts[i]).getReward(msg.sender, true);
        }
        //claim from extra rewards
        for (uint256 i = 0; i < extraRewardContracts.length; i++) {
            IBasicRewards(extraRewardContracts[i]).getReward(msg.sender);
        }
        //claim from multi reward token contract
        for (uint256 i = 0; i < tokenRewardContracts.length; i++) {
            IBasicRewards(tokenRewardContracts[i]).getReward(msg.sender, tokenRewardTokens[i]);
        }

        // claim others/deposit/lock/stake
        _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);
    }

    /**
     * @notice  Claim additional rewards from:
     *          - cvxCrvRewards
     *          - cvxLocker
     * @param depositCrvMaxAmount see claimRewards
     * @param minAmountOut        see claimRewards
     * @param depositCvxMaxAmount see claimRewards
     * @param removeCrvBalance    crvBalance to ignore and not redeposit (starting Crv balance)
     * @param removeCvxBalance    cvxBalance to ignore and not redeposit (starting Cvx balance)
     * @param options             see claimRewards
     */
    // prettier-ignore
    function _claimExtras( // solhint-disable-line 
        uint256 depositCrvMaxAmount,
        uint256 minAmountOut,
        uint256 depositCvxMaxAmount,
        uint256 removeCrvBalance,
        uint256 removeCvxBalance,
        uint256 options
    ) internal {
        //claim from cvxCrv rewards
        if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {
            IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);
        }

        //claim from locker
        if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {
            IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));
        }

        //reset remove balances if we want to also stake/lock funds already in our wallet
        if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {
            removeCrvBalance = 0;
            removeCvxBalance = 0;
        }

        //lock upto given amount of crv and stake
        if (depositCrvMaxAmount > 0) {
            uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);
            crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);

            if (crvBalance > 0) {
                //pull crv
                IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);
                //deposit
                ICrvDepositorWrapper(crvDepositWrapper).deposit(
                    crvBalance,
                    minAmountOut,
                    _checkOption(options, uint256(Options.LockCrvDeposit)),
                    address(0)
                );

                uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));
                //stake for msg.sender
                IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);
            }
        }

        //stake up to given amount of cvx
        if (depositCvxMaxAmount > 0) {
            uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);
            cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);
            if (cvxBalance > 0) {
                //pull cvx
                IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);
                if (_checkOption(options, uint256(Options.LockCvx))) {
                    IAuraLocker(locker).lock(msg.sender, cvxBalance);
                }
            }
        }
    }
}",2234
RealWorld_TA_123_MockWalletChecker_RealWorld_20240816010501.log,123,MockWalletChecker,25064,1909,26973,95.0,0.1635,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

contract MockWalletChecker {
    mapping(address => bool) public wallets;

    function approveWallet(address wallet) external {
        wallets[wallet] = true;
    }

    function check(address wallet) external view returns (bool) {
        return wallets[wallet];
    }
}",71
RealWorld_TA_123_ProxyFactory_RealWorld_20240815233542.log,123,ProxyFactory,38776,1687,40463,86.0,0.22762,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

/**
 * @title  ProxyFactory
 * @author Optionality
 * @notice Simply clones a smart contract at a given address
 * @dev    Original code https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol
 */
contract ProxyFactory {
    function clone(address target) external returns (address result) {
        bytes20 targetBytes = bytes20(target);
        assembly {
            let clone := mload(0x40)
            mstore(
                clone,
                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000
            )
            mstore(add(clone, 0x14), targetBytes)
            mstore(
                add(clone, 0x28),
                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000
            )
            result := create(0, clone, 0x37)
        }
    }
}",240
RealWorld_TA_123_AuraPenaltyForwarder_RealWorld_20240816002250.log,123,AuraPenaltyForwarder,52568,2791,55359,97.0,0.31866,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";

/**
 * @title AuraPenaltyForwarder
 * @dev Receives a given token and forwards it on to a distribution contract. Used during
 *      the bootstrapping period to forward AURA rewards to the extra rewards distributor.
 */
contract AuraPenaltyForwarder {
    using SafeERC20 for IERC20;

    IExtraRewardsDistributor public immutable distributor;
    IERC20 public immutable token;

    uint256 public immutable distributionDelay;
    uint256 public lastDistribution;

    event Forwarded(uint256 amount);

    /**
     * @dev During deployment approves the distributor to spend all tokens
     * @param _distributor  Contract that will distribute tokens
     * @param _token        Token to be distributed
     * @param _delay        Delay between each distribution trigger
     */
    constructor(
        address _distributor,
        address _token,
        uint256 _delay
    ) {
        distributor = IExtraRewardsDistributor(_distributor);
        token = IERC20(_token);
        distributionDelay = _delay;

        lastDistribution = block.timestamp;

        token.safeApprove(address(distributor), type(uint256).max);
    }

    /**
     * @dev Forwards the complete balance of token in this contract to the distributor
     */
    function forward() public {
        require(block.timestamp > lastDistribution + distributionDelay, ""!elapsed"");
        lastDistribution = block.timestamp;

        uint256 bal = token.balanceOf(address(this));
        require(bal > 0, ""!empty"");

        distributor.addReward(address(token), bal);

        emit Forwarded(bal);
    }
}",416
RealWorld_TA_123_IERC20Metadata_RealWorld_20240816001102.log,123,IERC20Metadata,31318,1477,32795,115.0,0.18613,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import { IERC20 } from ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}",160
RealWorld_TA_123_ArbitartorVault_RealWorld_20240815234122.log,123,ArbitartorVault,61676,4268,65944,120.0,0.39374,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

/**
 * @title   ArbitratorVault
 * @author  ConvexFinance
 * @notice  Hold extra reward tokens on behalf of pools that have the same token as a reward (e.g. stkAAVE fro multiple aave pools)
 * @dev     Sits on top of the STASH to basically handle the re-distribution of rewards to multiple stashes.
 *          Because anyone can call gauge.claim_rewards(address) for the convex staking contract, rewards
 *          could be forced to the wrong pool. Hold tokens here and distribute fairly(or at least more fairly),
 *          to both pools at a later timing.
 */
contract ArbitratorVault{
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public operator;
    address public immutable depositor;


    /**
     * @param  _depositor Booster address
     */
    constructor(address _depositor)public
    {
        operator = msg.sender;
        depositor = _depositor;
    }

    function setOperator(address _op) external {
        require(msg.sender == operator, ""!auth"");
        operator = _op;
    }

    /**
    * @notice  Permissioned fn to distribute any accrued rewards to a relevant stash
    * @dev     Only called by operator: ConvexMultisig
    */
    function distribute(address _token, uint256[] calldata _toPids, uint256[] calldata _amounts) external {
       require(msg.sender == operator, ""!auth"");

       for(uint256 i = 0; i < _toPids.length; i++){
        //get stash from pid
        (,,,,address stashAddress,bool shutdown) = IDeposit(depositor).poolInfo(_toPids[i]);

        //if sent to a shutdown pool, could get trapped
        require(shutdown==false,""pool closed"");

        //transfer
        IERC20(_token).safeTransfer(stashAddress, _amounts[i]);
       }
    }

}",515
RealWorld_TA_123_AuraLocker_RealWorld_20240816002826.log,123,AuraLocker,666790,5141,671931,196.0,3.43677,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}

/**
 * @title   AuraLocker
 * @author  ConvexFinance
 * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available
 *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes
 *          to depositors.
 * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.
 */
contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ==========     STRUCTS     ========== */

    struct RewardData {
        /// Timestamp for current period finish
        uint32 periodFinish;
        /// Last time any user took action
        uint32 lastUpdateTime;
        /// RewardRate for the rest of the period
        uint96 rewardRate;
        /// Ever increasing rewardPerToken rate, based on % of total supply
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; //epoch start date
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    /* ========== STATE VARIABLES ========== */

    // Rewards
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    //     Core reward data
    mapping(address => RewardData) public rewardData;
    //     Reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    //     User -> reward token -> amount
    mapping(address => mapping(address => UserData)) public userData;
    //     Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    //     Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // Balances
    //     Supplies and historic supply
    uint256 public lockedSupply;
    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply
    Epoch[] public epochs;
    //     Mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    // Voting
    //     Stored delegations
    mapping(address => address) private _delegates;
    //     Checkpointed votes
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    //     Delegatee balances (user -> unlock timestamp -> amount)
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    // Config
    //     Tokens
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    //     Denom for calcs
    uint256 public constant denominator = 10000;
    //     Staking cvxCrv
    address public immutable cvxcrvStaking;
    //     Incentives
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    //     Shutdown
    bool public isShutdown = false;

    // Basic token data
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== EVENTS ========== */

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    /***************************************
                    CONSTRUCTOR
    ****************************************/

    /**
     * @param _nameArg          Token name, simples
     * @param _symbolArg        Token symbol
     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)
     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)
     */
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    /***************************************
                    MODIFIER
    ****************************************/

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    /***************************************
                    ADMIN
    ****************************************/

    // Add a new reward token to be distributed to stakers
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    // Set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    /***************************************
                    ACTIONS
    ****************************************/

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

    //lock tokens
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps until the next epoch date.
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    /***************************************
            DELEGATION & VOTE BALANCE
    ****************************************/

    /**
     * @dev Delegate votes from the sender to `newDelegatee`.
     */
    function delegate(address newDelegatee) external virtual nonReentrant {
        // Step 1: Get lock data
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        // Step 2: Update delegatee storage
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        // Step 3: Move balances around
        //         Delegate for the upcoming epoch
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        // Step 3.1: Add future unlocks and sum balances
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        // Step 3.2: Checkpoint old delegatee
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        // Step 3.3: Checkpoint new delegatee
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        // This would only skip on first checkpointing
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired
                // e.g. week 1 + 17 <= 18
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    // Should be maximum 18 iterations
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    /**
     * @dev Get the address `account` is currently delegating to.
     */
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    /**
     * @dev Gets the current votes balance for `account`
     */
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    /**
     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.
     */
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    /**
     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.
     * It is but NOT the sum of all the delegated votes!
     */
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     *      Copied from oz/ERC20Votes.sol
     */
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    /***************************************
                VIEWS - BALANCES
    ****************************************/

    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    // Balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    // Supply of all properly locked balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    // Supply of all properly locked balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    // Get an epoch index based on timestamp
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    /***************************************
                VIEWS - GENERAL
    ****************************************/

    // Number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /***************************************
                VIEWS - REWARDS
    ****************************************/

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    /***************************************
                REWARD FUNDING
    ****************************************/

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",7734
RealWorld_TA_123_MockAuraMath_RealWorld_20240816005225.log,123,MockAuraMath,62411,1122,63533,80.0,0.334495,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""../AuraMath.sol"";

// solhint-disable func-name-mixedcase
contract MockAuraMath {
    constructor() {}

    function AuraMath_min(uint256 a, uint256 b) external pure returns (uint256) {
        return AuraMath.min(a, b);
    }

    function AuraMath_add(uint256 a, uint256 b) external pure returns (uint256) {
        return AuraMath.add(a, b);
    }

    function AuraMath_sub(uint256 a, uint256 b) external pure returns (uint256) {
        return AuraMath.sub(a, b);
    }

    function AuraMath_mul(uint256 a, uint256 b) external pure returns (uint256) {
        return AuraMath.mul(a, b);
    }

    function AuraMath_div(uint256 a, uint256 b) external pure returns (uint256) {
        return AuraMath.div(a, b);
    }

    function AuraMath_average(uint256 a, uint256 b) external pure returns (uint256) {
        return AuraMath.average(a, b);
    }

    function AuraMath_to224(uint256 a) external pure returns (uint224) {
        return AuraMath.to224(a);
    }

    function AuraMath_to128(uint256 a) external pure returns (uint128) {
        return AuraMath.to128(a);
    }

    function AuraMath_to112(uint256 a) external pure returns (uint112) {
        return AuraMath.to112(a);
    }

    function AuraMath_to96(uint256 a) external pure returns (uint96) {
        return AuraMath.to96(a);
    }

    function AuraMath_to32(uint256 a) external pure returns (uint32) {
        return AuraMath.to32(a);
    }

    function AuraMath32_sub(uint32 a, uint32 b) external pure returns (uint32) {
        return AuraMath32.sub(a, b);
    }

    function AuraMath112_add(uint112 a, uint112 b) external pure returns (uint112) {
        return AuraMath112.add(a, b);
    }

    function AuraMath112_sub(uint112 a, uint112 b) external pure returns (uint112) {
        return AuraMath112.sub(a, b);
    }

    function AuraMath224_add(uint224 a, uint224 b) external pure returns (uint224) {
        return AuraMath224.add(a, b);
    }
}",527
RealWorld_TA_123_BoringMath_RealWorld_20240816000612.log,123,BoringMath,137047,1337,138384,90.0,0.711975,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }

    function to40(uint256 a) internal pure returns (uint40 c) {
        require(a <= uint40(-1), ""BoringMath: uint40 Overflow"");
        c = uint40(a);
    }

    function to112(uint256 a) internal pure returns (uint112 c) {
        require(a <= uint112(-1), ""BoringMath: uint112 Overflow"");
        c = uint112(a);
    }

    function to224(uint256 a) internal pure returns (uint224 c) {
        require(a <= uint224(-1), ""BoringMath: uint224 Overflow"");
        c = uint224(a);
    }

    function to208(uint256 a) internal pure returns (uint208 c) {
        require(a <= uint208(-1), ""BoringMath: uint208 Overflow"");
        c = uint208(a);
    }

    function to216(uint256 a) internal pure returns (uint216 c) {
        require(a <= uint216(-1), ""BoringMath: uint216 Overflow"");
        c = uint216(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint32 a, uint32 b) internal pure returns (uint32) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }
}


/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint112.
library BoringMath112 {
    function add(uint112 a, uint112 b) internal pure returns (uint112 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint112 a, uint112 b) internal pure returns (uint112 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint112 a, uint112 b) internal pure returns (uint112 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }
    
    function div(uint112 a, uint112 b) internal pure returns (uint112) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint224.
library BoringMath224 {
    function add(uint224 a, uint224 b) internal pure returns (uint224 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint224 a, uint224 b) internal pure returns (uint224 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint224 a, uint224 b) internal pure returns (uint224 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }
    
    function div(uint224 a, uint224 b) internal pure returns (uint224) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }
}",1417
RealWorld_TA_123_MockCurveGauge_RealWorld_20240816005536.log,123,MockCurveGauge,46164,4159,50323,122.0,0.314,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

contract MockCurveGauge is ERC20 {
    address public lp_token;

    // V2 gauge
    address[] public reward_tokens;

    constructor(
        string memory _name,
        string memory _symbol,
        address _lptoken,
        address[] memory _rewardTokens
    ) ERC20(_name, _symbol) {
        lp_token = _lptoken;
        reward_tokens = _rewardTokens;
    }

    function deposit(uint256 amount) external {
        _mint(msg.sender, amount);
        IERC20(lp_token).transferFrom(msg.sender, address(this), amount);
    }

    function withdraw(uint256 amount) external {
        _burn(msg.sender, amount);
        IERC20(lp_token).transfer(msg.sender, amount);
    }

    function claim_rewards() external {
        uint256 amount = balanceOf(msg.sender);

        for (uint256 i = 0; i < reward_tokens.length; i++) {
            IERC20(reward_tokens[i]).transfer(msg.sender, amount);
        }
    }

    function claimable_reward(address, address) external view returns (uint256) {
        return 0;
    }

    function deposit_reward_token(address, uint256) external {}

    function add_reward(address _reward_token, address _distributor) external {}
}",321
RealWorld_TA_123_MockBalancerVault_RealWorld_20240816011025.log,123,MockBalancerVault,64677,5289,69966,138.0,0.429165,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import ""./MockBalancerPoolToken.sol"";
import ""../../Interfaces.sol"";

interface IBalancerVault {
    function joinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        JoinPoolRequest memory request
    ) external payable;

    struct JoinPoolRequest {
        address[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }
}

contract MockBalancerVault {
    address public pool;

    address public poolToken;

    address public tokenA;

    address public tokenB;

    constructor(address _poolToken) {
        poolToken = _poolToken;
    }

    function setTokens(address _tokenA, address _tokenB) external {
        tokenA = _tokenA;
        tokenB = _tokenB;
    }

    function getPool(bytes32) external view returns (address, IVault.PoolSpecialization) {
        return (poolToken, IVault.PoolSpecialization.GENERAL);
    }

    function joinPool(
        bytes32, /* poolId */
        address, /* sender */
        address recipient,
        IVault.JoinPoolRequest memory request
    ) external payable {
        uint256 amount = request.maxAmountsIn[0];
        uint256 price = MockBalancerPoolToken(poolToken).price();
        MockBalancerPoolToken(poolToken).mint(recipient, (amount * 1e18) / price);
    }

    function swap(
        IVault.SingleSwap memory singleSwap,
        IVault.FundManagement memory funds,
        uint256, /* limit */
        uint256 /* deadline */
    ) external returns (uint256 amountCalculated) {
        require(address(singleSwap.assetOut) == tokenA || address(singleSwap.assetOut) == tokenB, ""!token"");

        if (address(singleSwap.assetOut) == tokenA) {
            // send tokenA
            IERC20(tokenB).transferFrom(funds.sender, address(this), singleSwap.amount);
            IERC20(tokenA).transfer(funds.recipient, singleSwap.amount);
        } else if (address(singleSwap.assetOut) == tokenB) {
            // send tokenB
            IERC20(tokenA).transferFrom(funds.sender, address(this), singleSwap.amount);
            IERC20(tokenB).transfer(funds.recipient, singleSwap.amount);
        }
    }
}",519
RealWorld_TA_123_IProxyFactory_RealWorld_20240816001259.log,123,IProxyFactory,21018,1176,22194,87.0,0.12861,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IProxyFactory {
    function clone(address _target) external returns(address);
}",33
RealWorld_TA_123_AuraMerkleDrop_RealWorld_20240816004444.log,123,AuraMerkleDrop,122210,4583,126793,132.0,0.70271,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { MerkleProof } from ""@openzeppelin/contracts-0.8/utils/cryptography/MerkleProof.sol"";
import { IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   AuraMerkleDrop
 * @dev     Forked from convex-platform/contracts/contracts/MerkleAirdrop.sol. Changes:
 *            - solc 0.8.11 & OpenZeppelin MerkleDrop
 *            - Delayed start w/ trigger
 *            - EndTime for withdrawal to treasuryDAO
 *            - Penalty on claim & AuraLocker lock (only if address(auraLocker) != 0)
 *            - Non custodial (cannot change root)
 */
contract AuraMerkleDrop {
    using SafeERC20 for IERC20;

    address public dao;
    bytes32 public merkleRoot;

    IERC20 public immutable aura;
    IAuraLocker public auraLocker;

    address public immutable penaltyForwarder;
    uint256 public pendingPenalty = 0;

    uint256 public startTime;
    uint256 public immutable expiryTime;

    mapping(address => bool) public hasClaimed;

    event DaoSet(address newDao);
    event RootSet(bytes32 newRoot);
    event StartedEarly();
    event ExpiredWithdrawn(uint256 amount);
    event LockerSet(address newLocker);
    event Claimed(address addr, uint256 amt, bool locked);
    event PenaltyForwarded(uint256 amount);

    /**
     * @param _dao              The Aura Dao
     * @param _merkleRoot       Merkle root
     * @param _aura             Aura token
     * @param _auraLocker       Aura locker contract
     * @param _penaltyForwarder PenaltyForwarded contract
     * @param _startDelay       Delay until claim is live
     * @param _expiresAfter     Timestamp claim expires
     */
    constructor(
        address _dao,
        bytes32 _merkleRoot,
        address _aura,
        address _auraLocker,
        address _penaltyForwarder,
        uint256 _startDelay,
        uint256 _expiresAfter
    ) {
        dao = _dao;
        merkleRoot = _merkleRoot;
        aura = IERC20(_aura);
        auraLocker = IAuraLocker(_auraLocker);
        penaltyForwarder = _penaltyForwarder;
        startTime = block.timestamp + _startDelay;

        require(_expiresAfter > 2 weeks, ""!expiry"");
        expiryTime = startTime + _expiresAfter;
    }

    /***************************************
                    CONFIG
    ****************************************/

    function setDao(address _newDao) external {
        require(msg.sender == dao, ""!auth"");
        dao = _newDao;
        emit DaoSet(_newDao);
    }

    function setRoot(bytes32 _merkleRoot) external {
        require(msg.sender == dao, ""!auth"");
        require(merkleRoot == bytes32(0), ""already set"");
        merkleRoot = _merkleRoot;
        emit RootSet(_merkleRoot);
    }

    function startEarly() external {
        require(msg.sender == dao, ""!auth"");
        startTime = block.timestamp;
        emit StartedEarly();
    }

    function withdrawExpired() external {
        require(msg.sender == dao, ""!auth"");
        require(block.timestamp > expiryTime, ""!expired"");
        uint256 amt = aura.balanceOf(address(this));
        aura.safeTransfer(dao, amt);
        emit ExpiredWithdrawn(amt);
    }

    function setLocker(address _newLocker) external {
        require(msg.sender == dao, ""!auth"");
        auraLocker = IAuraLocker(_newLocker);
        emit LockerSet(_newLocker);
    }

    /***************************************
                    CLAIM
    ****************************************/

    function claim(
        bytes32[] calldata _proof,
        uint256 _amount,
        bool _lock
    ) public returns (bool) {
        require(merkleRoot != bytes32(0), ""!root"");
        require(block.timestamp > startTime, ""!started"");
        require(block.timestamp < expiryTime, ""!active"");
        require(_amount > 0, ""!amount"");
        require(hasClaimed[msg.sender] == false, ""already claimed"");

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));
        require(MerkleProof.verify(_proof, merkleRoot, leaf), ""invalid proof"");

        hasClaimed[msg.sender] = true;

        if (_lock) {
            aura.safeApprove(address(auraLocker), 0);
            aura.safeApprove(address(auraLocker), _amount);
            auraLocker.lock(msg.sender, _amount);
        } else {
            // If there is an address for auraLocker, and not locking, apply 20% penalty
            uint256 penalty = address(auraLocker) == address(0) ? 0 : (_amount * 2) / 10;
            pendingPenalty += penalty;
            aura.safeTransfer(msg.sender, _amount - penalty);
        }

        emit Claimed(msg.sender, _amount, _lock);
        return true;
    }

    /***************************************
                    FORWARD
    ****************************************/

    function forwardPenalty() public {
        uint256 toForward = pendingPenalty;
        pendingPenalty = 0;
        require(penaltyForwarder != address(0), ""!forwarder"");
        aura.safeTransfer(penaltyForwarder, toForward);
        emit PenaltyForwarded(toForward);
    }
}",1223
RealWorld_TA_123_PoolManagerProxy_RealWorld_20240815233710.log,123,PoolManagerProxy,66083,2933,69016,111.0,0.389075,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";

/**
 * @title   PoolManagerProxy
 * @author  ConvexFinance
 * @notice  Immutable pool manager proxy to enforce that there are no multiple pools of the same gauge
 *          as well as new lp tokens are not gauge tokens
 * @dev     Called by PoolManagerShutdownProxy 
 */
contract PoolManagerProxy{

    address public immutable pools;
    address public owner;
    address public operator;

    /**
     * @param _pools      Contract can call addPool currently Booster
     * @param _owner      Contract owner currently multisig
     */
    constructor(
      address _pools, 
      address _owner
    ) public {
        pools = _pools;
        owner = _owner;
        operator = msg.sender;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""!owner"");
        _;
    }

    modifier onlyOperator() {
        require(operator == msg.sender, ""!op"");
        _;
    }

    //set owner - only OWNER
    function setOwner(address _owner) external onlyOwner{
        owner = _owner;
    }

    //set operator - only OWNER
    function setOperator(address _operator) external onlyOwner{
        operator = _operator;
    }

    // sealed to be immutable
    // function revertControl() external{
    // }

    //shutdown a pool - only OPERATOR
    function shutdownPool(uint256 _pid) external onlyOperator returns(bool){
        return IPools(pools).shutdownPool(_pid);
    }

    /**
     * @notice  Add pool to system
     * @dev     Only callable by the operator looks up the gauge from the gaugeMap in Booster to ensure
     *          it hasn't already been added
     */
    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){

        require(_gauge != address(0),""gauge is 0"");
        require(_lptoken != address(0),""lp token is 0"");

        //check if a pool with this gauge already exists
        bool gaugeExists = IPools(pools).gaugeMap(_gauge);
        require(!gaugeExists, ""already registered gauge"");

        //must also check that the lp token is not a registered gauge
        //because curve gauges are tokenized
        gaugeExists = IPools(pools).gaugeMap(_lptoken);
        require(!gaugeExists, ""already registered lptoken"");

        return IPools(pools).addPool(_lptoken,_gauge,_stashVersion);
    }
}",560
RealWorld_TA_123_MockStablePoolFactory_RealWorld_20240816011733.log,123,MockStablePoolFactory,25565,1714,27279,88.0,0.162105,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

interface IStablePoolFactory {
    function create(
        string memory name,
        string memory symbol,
        IERC20[] memory tokens,
        uint256 amplificationParameter,
        uint256 swapFeePercentage,
        address owner
    ) external returns (address);
}",92
RealWorld_TA_123_BalLiquidityProvider_RealWorld_20240816004659.log,123,BalLiquidityProvider,84889,4083,88972,117.0,0.506105,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IVault } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";

/**
 * @title   BalLiquidityProvider
 * @notice  Provides initial liquidity to a Balancer pool on behalf of a given DAO
 */
contract BalLiquidityProvider {
    using SafeERC20 for IERC20;

    IERC20 public immutable startToken;
    IERC20 public immutable pairToken;
    uint256 public minPairAmount;

    address private immutable provider;
    address public immutable dao;

    IVault public immutable bVault;

    event LiquidityProvided(uint256[] input, uint256 output);
    event MinPairAmountChanged(uint256 oldMinPairAmount, uint256 newMinPairAmount);

    constructor(
        address _startToken,
        address _pairToken,
        uint256 _minPairAmount,
        address _dao,
        address _bVault
    ) {
        startToken = IERC20(_startToken);
        pairToken = IERC20(_pairToken);
        minPairAmount = _minPairAmount;
        provider = msg.sender;
        dao = _dao;
        bVault = IVault(_bVault);
    }

    /**
     * @dev Provides liquidity on behalf of the dao, in a non-custodial manner.
     *      Has protections in place to ensure that no erroneous liquidity data gets added.
     */
    function provideLiquidity(bytes32 _poolId, IVault.JoinPoolRequest memory _request) public {
        require(msg.sender == provider, ""!auth"");
        require(_request.assets.length == 2 && _request.maxAmountsIn.length == 2, ""!valid"");
        require(pairToken.balanceOf(address(this)) > minPairAmount, ""!minLiq"");

        for (uint256 i = 0; i < 2; i++) {
            address asset = address(_request.assets[i]);
            require(asset == address(startToken) || asset == address(pairToken), ""!asset"");

            IERC20 tkn = IERC20(asset);
            uint256 bal = tkn.balanceOf(address(this));
            require(bal > 0 && bal == _request.maxAmountsIn[i], ""!bal"");

            tkn.safeApprove(address(bVault), 0);
            tkn.safeApprove(address(bVault), bal);
        }

        (address pool, ) = bVault.getPool(_poolId);
        uint256 supplyBefore = IERC20(pool).totalSupply();
        require(supplyBefore == 0, ""!init"");

        bVault.joinPool(_poolId, address(this), dao, _request);

        uint256 balAfter = IERC20(pool).balanceOf(dao);
        require(balAfter > 0, ""!mint"");

        emit LiquidityProvided(_request.maxAmountsIn, balAfter);
    }

    /**
     * @dev Allows the DAO to change the minimum amount of the pair token that must be added as liquidity
     */
    function changeMinPairAmount(uint256 _newAmount) external {
        require(msg.sender == dao, ""!auth"");
        emit MinPairAmountChanged(minPairAmount, _newAmount);
        minPairAmount = _newAmount;
    }

    /**
     * @dev Rescues a given token from the contract.
     * Only provider or DAO can call this function.
     */
    function rescueToken(address _erc20) external {
        require(msg.sender == provider || msg.sender == dao, ""!auth"");
        IERC20 tkn = IERC20(_erc20);
        tkn.safeTransfer(dao, tkn.balanceOf(address(this)));
    }
}",805
RealWorld_TA_123_RewardFactory_RealWorld_20240815234324.log,123,RewardFactory,84595,3007,87602,109.0,0.483115,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""./BaseRewardPool4626.sol"";
import ""./VirtualBalanceRewardPool.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";


/**
 * @title   RewardFactory
 * @author  ConvexFinance
 * @notice  Used to deploy reward pools when a new pool is added to the Booster
 *          contract. This contract deploys two types of reward pools:
 *          - BaseRewardPool handles CRV rewards for guages
 *          - VirtualBalanceRewardPool for extra rewards
 */
contract RewardFactory {
    using Address for address;

    address public immutable operator;
    address public immutable crv;

    mapping (address => bool) private rewardAccess;
    mapping(address => uint256[]) public rewardActiveList;


    event RewardPoolCreated(address rewardPool, uint256 _pid, address depositToken);
    event TokenRewardPoolCreated(address rewardPool, address token, address mainRewards, address operator);

    event AccessChanged(address stash, bool hasAccess);

    /**
     * @param _operator   Contract operator is Booster
     * @param _crv        CRV token address
     */
    constructor(address _operator, address _crv) public {
        operator = _operator;
        crv = _crv;
    }

    //stash contracts need access to create new Virtual balance pools for extra gauge incentives(ex. snx)
    function setAccess(address _stash, bool _status) external{
        require(msg.sender == operator, ""!auth"");
        rewardAccess[_stash] = _status;

        emit AccessChanged(_stash, _status);
    }

    /**
     * @notice Create a Managed Reward Pool to handle distribution of all crv mined in a pool
     */
    function CreateCrvRewards(uint256 _pid, address _depositToken, address _lptoken) external returns (address) {
        require(msg.sender == operator, ""!auth"");

        //operator = booster(deposit) contract so that new crv can be added and distributed
        //reward manager = this factory so that extra incentive tokens(ex. snx) can be linked to the main managed reward pool
        BaseRewardPool4626 rewardPool = new BaseRewardPool4626(_pid,_depositToken,crv,operator, address(this), _lptoken);

        emit RewardPoolCreated(address(rewardPool), _pid, _depositToken);
        return address(rewardPool);
    }

    /**
     * @notice  Create a virtual balance reward pool that mimics the balance of a pool's main reward contract
     *          used for extra incentive tokens(ex. snx) as well as vecrv fees
     */
    function CreateTokenRewards(address _token, address _mainRewards, address _operator) external returns (address) {
        require(msg.sender == operator || rewardAccess[msg.sender] == true, ""!auth"");

        //create new pool, use main pool for balance lookup
        VirtualBalanceRewardPool rewardPool = new VirtualBalanceRewardPool(_mainRewards,_token,_operator);
        address rAddress = address(rewardPool);
        //add the new pool to main pool's list of extra rewards, assuming this factory has ""reward manager"" role
        IRewards(_mainRewards).addExtraReward(rAddress);

        emit TokenRewardPoolCreated(rAddress, _token, _mainRewards, _operator);
        //return new pool's address
        return rAddress;
    }
}",793
RealWorld_TA_123_MockBalInvestor_RealWorld_20240816005033.log,123,MockBalInvestor,38160,3258,41418,110.0,0.25596,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import ""../CrvDepositorWrapper.sol"";

contract MockBalInvestor is BalInvestor {
    constructor(
        IVault _balancerVault,
        address _bal,
        address _weth,
        bytes32 _balETHPoolId
    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {}

    function approveToken() external {
        _setApprovals();
    }

    function getBptPrice() external view returns (uint256) {
        return _getBptPrice();
    }

    function getMinOut(uint256 _amount, uint256 _outputBps) public view returns (uint256) {
        return _getMinOut(_amount, _outputBps);
    }

    function addBalToPool(uint256 amount, uint256 _minOut) external {
        _investBalToPool(amount, _minOut);
    }
}",228
RealWorld_TA_123_CrvDepositorWrapper_RealWorld_20240816002429.log,123,CrvDepositorWrapper,130044,3927,133971,121.0,0.72876,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { IVault, IPriceOracle, ICrvDepositorWrapper, IAsset } from ""./Interfaces.sol"";
import { IVault } from ""./Interfaces.sol"";

interface ICrvDepositor {
    function depositFor(
        address to,
        uint256 _amount,
        bool _lock,
        address _stakeAddress
    ) external;
}

/**
 * @title   BalInvestor
 * @notice  Deposits $BAL into a BAL/WETH BPT. Hooks into TWAP to determine minOut.
 * @dev     Abstract contract for depositing BAL -> balBPT -> auraBAL via crvDepositor
 */
abstract contract BalInvestor {
    using SafeERC20 for IERC20;

    IVault public immutable BALANCER_VAULT;
    address public immutable BAL;
    address public immutable WETH;
    address public immutable BALANCER_POOL_TOKEN;
    bytes32 public immutable BAL_ETH_POOL_ID;

    constructor(
        IVault _balancerVault,
        address _bal,
        address _weth,
        bytes32 _balETHPoolId
    ) {
        (
            address poolAddress, /* */

        ) = _balancerVault.getPool(_balETHPoolId);
        require(poolAddress != address(0), ""!poolAddress"");

        BALANCER_VAULT = _balancerVault;
        BAL = _bal;
        WETH = _weth;
        BALANCER_POOL_TOKEN = poolAddress;
        BAL_ETH_POOL_ID = _balETHPoolId;
    }

    function _setApprovals() internal {
        IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);
        IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);
    }

    function _getBptPrice() internal view returns (uint256) {
        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);

        queries[0].variable = IPriceOracle.Variable.BPT_PRICE;
        queries[0].secs = 3600; // last hour
        queries[0].ago = 0; // now

        // Gets the balancer time weighted average price denominated in BAL
        return IPriceOracle(BALANCER_POOL_TOKEN).getTimeWeightedAverage(queries)[0];
    }

    function _getMinOut(uint256 amount, uint256 minOutBps) internal view returns (uint256) {
        // Gets the balancer time weighted average price denominated in BAL
        // e.g.  if 1 BAL == 0.4 BPT, bptOraclePrice == 2.5
        uint256 bptOraclePrice = _getBptPrice();
        // e.g. minOut = (((100e18 * 1e18) / 2.5e18) * 9980) / 10000;
        // e.g. minout = 39.92e18
        uint256 minOut = (((amount * 1e18) / bptOraclePrice) * minOutBps) / 10000;
        return minOut;
    }

    function _investBalToPool(uint256 amount, uint256 minOut) internal {
        IERC20(BAL).safeTransferFrom(msg.sender, address(this), amount);
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(BAL);
        assets[1] = IAsset(WETH);
        uint256[] memory maxAmountsIn = new uint256[](2);
        maxAmountsIn[0] = amount;
        maxAmountsIn[1] = 0;

        BALANCER_VAULT.joinPool(
            BAL_ETH_POOL_ID,
            address(this),
            address(this),
            IVault.JoinPoolRequest(
                assets,
                maxAmountsIn,
                abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),
                false // Don't use internal balances
            )
        );
    }
}

/**
 * @title   CrvDepositorWrapper
 * @notice  Converts BAL -> balBPT and then wraps to auraBAL via the crvDepositor
 */
contract CrvDepositorWrapper is ICrvDepositorWrapper, BalInvestor {
    address public immutable crvDeposit;

    constructor(
        address _crvDeposit,
        IVault _balancerVault,
        address _bal,
        address _weth,
        bytes32 _balETHPoolId
    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {
        crvDeposit = _crvDeposit;
    }

    function setApprovals() external {
        _setApprovals();
        require(IERC20(BALANCER_POOL_TOKEN).approve(crvDeposit, type(uint256).max), ""!approval"");
    }

    /**
     * @dev Gets minimum output based on BPT oracle price
     * @param _amount Units of BAL to deposit
     * @param _outputBps Multiplier where 100% == 10000, 99.5% == 9950 and 98% == 9800
     * @return minOut Units of BPT to expect as output
     */
    function getMinOut(uint256 _amount, uint256 _outputBps) external view returns (uint256) {
        return _getMinOut(_amount, _outputBps);
    }

    function deposit(
        uint256 _amount,
        uint256 _minOut,
        bool _lock,
        address _stakeAddress
    ) external {
        _investBalToPool(_amount, _minOut);
        uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));
        ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);
    }
}",1336
RealWorld_TA_123_cCrv_RealWorld_20240815231802.log,123,cCrv,52510,2160,54670,100.0,0.30575,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/ERC20.sol"";


/**
 * @title   cvxCrvToken
 * @author  ConvexFinance
 * @notice  Dumb ERC20 token that allows the operator (crvDepositor) to mint and burn tokens
 */
contract cvxCrvToken is ERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public operator;

    constructor(string memory _nameArg, string memory _symbolArg)
        public
        ERC20(
            _nameArg,
            _symbolArg
        )
    {
        operator = msg.sender;
    }

    /**
     * @notice Allows the initial operator (deployer) to set the operator.
     *         Note - crvDepositor has no way to change this back, so it's effectively immutable
     */
    function setOperator(address _operator) external {
        require(msg.sender == operator, ""!auth"");
        operator = _operator;
    }

    /**
     * @notice Allows the crvDepositor to mint
     */
    function mint(address _to, uint256 _amount) external {
        require(msg.sender == operator, ""!authorized"");
        
        _mint(_to, _amount);
    }

    /**
     * @notice Allows the crvDepositor to burn
     */
    function burn(address _from, uint256 _amount) external {
        require(msg.sender == operator, ""!authorized"");
        
        _burn(_from, _amount);
    }

}",424
RealWorld_TA_123_IERC4626_RealWorld_20240816001556.log,123,IERC4626,106694,2251,108945,107.0,0.57849,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import { IERC20Metadata } from ""./IERC20Metadata.sol"";

/// @title ERC4626 interface
/// See: https://eips.ethereum.org/EIPS/eip-4626

abstract contract IERC4626 is IERC20Metadata {

    /*////////////////////////////////////////////////////////
                      Events
    ////////////////////////////////////////////////////////*/

    /// @notice `caller` has exchanged `assets` for `shares`, and transferred those `shares` to `owner`
    event Deposit(
        address indexed caller,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    /// @notice `caller` has exchanged `shares`, owned by `owner`, for
    ///         `assets`, and transferred those `assets` to `receiver`.
    event Withdraw(
        address indexed caller,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    /*////////////////////////////////////////////////////////
                      Vault properties
    ////////////////////////////////////////////////////////*/

    /// @notice The address of the underlying ERC20 token used for
    /// the Vault for accounting, depositing, and withdrawing.
    function asset() external view virtual returns(address);

    /// @notice Total amount of the underlying asset that
    /// is ""managed"" by Vault.
    function totalAssets() external view virtual returns(uint256);

    /*////////////////////////////////////////////////////////
                      Deposit/Withdrawal Logic
    ////////////////////////////////////////////////////////*/

    /// @notice Mints `shares` Vault shares to `receiver` by
    /// depositing exactly `assets` of underlying tokens.
    function deposit(uint256 assets, address receiver) external virtual returns(uint256 shares);

    /// @notice Mints exactly `shares` Vault shares to `receiver`
    /// by depositing `assets` of underlying tokens.
    function mint(uint256 shares, address receiver) external virtual returns(uint256 assets);

    /// @notice Redeems `shares` from `owner` and sends `assets`
    /// of underlying tokens to `receiver`.
    function withdraw(uint256 assets, address receiver, address owner) external virtual returns(uint256 shares);

    /// @notice Redeems `shares` from `owner` and sends `assets`
    /// of underlying tokens to `receiver`.
    function redeem(uint256 shares, address receiver, address owner) external virtual returns(uint256 assets);

    /*////////////////////////////////////////////////////////
                      Vault Accounting Logic
    ////////////////////////////////////////////////////////*/

    /// @notice The amount of shares that the vault would
    /// exchange for the amount of assets provided, in an
    /// ideal scenario where all the conditions are met.
    function convertToShares(uint256 assets) external view virtual returns(uint256 shares);

    /// @notice The amount of assets that the vault would
    /// exchange for the amount of shares provided, in an
    /// ideal scenario where all the conditions are met.
    function convertToAssets(uint256 shares) external view virtual returns(uint256 assets);

    /// @notice Total number of underlying assets that can
    /// be deposited by `owner` into the Vault, where `owner`
    /// corresponds to the input parameter `receiver` of a
    /// `deposit` call.
    function maxDeposit(address owner) external view virtual returns(uint256 maxAssets);

    /// @notice Allows an on-chain or off-chain user to simulate
    /// the effects of their deposit at the current block, given
    /// current on-chain conditions.
    function previewDeposit(uint256 assets) external view virtual returns(uint256 shares);

    /// @notice Total number of underlying shares that can be minted
    /// for `owner`, where `owner` corresponds to the input
    /// parameter `receiver` of a `mint` call.
    function maxMint(address owner) external view virtual returns(uint256 maxShares);

    /// @notice Allows an on-chain or off-chain user to simulate
    /// the effects of their mint at the current block, given
    /// current on-chain conditions.
    function previewMint(uint256 shares) external view virtual returns(uint256 assets);

    /// @notice Total number of underlying assets that can be
    /// withdrawn from the Vault by `owner`, where `owner`
    /// corresponds to the input parameter of a `withdraw` call.
    function maxWithdraw(address owner) external view virtual returns(uint256 maxAssets);

    /// @notice Allows an on-chain or off-chain user to simulate
    /// the effects of their withdrawal at the current block,
    /// given current on-chain conditions.
    function previewWithdraw(uint256 assets) external view virtual returns(uint256 shares);

    /// @notice Total number of underlying shares that can be
    /// redeemed from the Vault by `owner`, where `owner` corresponds
    /// to the input parameter of a `redeem` call.
    function maxRedeem(address owner) external view virtual returns(uint256 maxShares);

    /// @notice Allows an on-chain or off-chain user to simulate
    /// the effects of their redeemption at the current block,
    /// given current on-chain conditions.
    function previewRedeem(uint256 shares) external view virtual returns(uint256 assets);
}",1059
RealWorld_TA_123_DepositToken_RealWorld_20240815235437.log,123,DepositToken,52478,2349,54827,95.0,0.30937,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/ERC20.sol"";


/**
 * @title   DepositToken
 * @author  ConvexFinance
 * @notice  Simply creates a token that can be minted and burned from the operator
 */
contract DepositToken is ERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public operator;

    /**
     * @param _operator         Booster
     * @param _lptoken          Underlying LP token for deposits
     * @param _namePostfix      Postfixes lpToken name
     * @param _symbolPrefix     Prefixed lpToken symbol
     */
    constructor(
        address _operator,
        address _lptoken,
        string memory _namePostfix,
        string memory _symbolPrefix
    )
        public
        ERC20(
             string(
                abi.encodePacked(ERC20(_lptoken).name(), _namePostfix)
            ),
            string(abi.encodePacked(_symbolPrefix, ERC20(_lptoken).symbol()))
        )
    {
        operator =  _operator;
    }
    
    function mint(address _to, uint256 _amount) external {
        require(msg.sender == operator, ""!authorized"");
        
        _mint(_to, _amount);
    }

    function burn(address _from, uint256 _amount) external {
        require(msg.sender == operator, ""!authorized"");
        
        _burn(_from, _amount);
    }

}",418
RealWorld_TA_123_CrvDepositor_RealWorld_20240815232151.log,123,CrvDepositor,180465,5379,185844,166.0,1.009905,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";


/**
 * @title   CrvDepositor
 * @author  ConvexFinance
 * @notice  This is the entry point for CRV > cvxCRV wrapping. It accepts CRV, sends to 'staler'
 *          for depositing into Curves VotingEscrow, and then mints cvxCRV at 1:1 via the 'minter' (cCrv) minus
 *          the lockIncentive (initially 1%) which is used to basically compensate users who call the `lock` function on Curves
 *          system (larger depositors would likely want to lock).
 */
contract CrvDepositor{
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public immutable crvBpt;
    address public immutable escrow;
    uint256 private constant MAXTIME = 1 * 364 * 86400;
    uint256 private constant WEEK = 7 * 86400;

    uint256 public lockIncentive = 10; //incentive to users who spend gas to lock crvBpt
    uint256 public constant FEE_DENOMINATOR = 10000;

    address public feeManager;
    address public daoOperator;
    address public immutable staker;
    address public immutable minter;
    uint256 public incentiveCrv = 0;
    uint256 public unlockTime;

    bool public cooldown;

    /**
     * @param _staker   CVX VoterProxy (0x989AEb4d175e16225E39E87d0D97A3360524AD80)
     * @param _minter   cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _crvBpt   crvBPT for veCRV deposits
     * @param _escrow   CRV VotingEscrow (0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2)
     */
    constructor(
        address _staker,
        address _minter,
        address _crvBpt,
        address _escrow,
        address _daoOperator
    ) public {
        staker = _staker;
        minter = _minter;
        crvBpt = _crvBpt;
        escrow = _escrow;
        feeManager = msg.sender;
        daoOperator = _daoOperator;
    }

    function setFeeManager(address _feeManager) external {
        require(msg.sender == feeManager, ""!auth"");
        feeManager = _feeManager;
    }

    function setDaoOperator(address _daoOperator) external {
        require(msg.sender == daoOperator, ""!auth"");
        daoOperator = _daoOperator;
    }

    function setFees(uint256 _lockIncentive) external{
        require(msg.sender==feeManager, ""!auth"");

        if(_lockIncentive >= 0 && _lockIncentive <= 30){
            lockIncentive = _lockIncentive;
       }
    }

    function setCooldown(bool _cooldown) external {
      require(msg.sender == daoOperator, ""!auth"");
      cooldown = _cooldown;
    }

    /**
     * @notice Called once to deposit the balance of CRV in this contract to the VotingEscrow
     */
    function initialLock() external{
        require(!cooldown, ""cooldown"");
        require(msg.sender==feeManager, ""!auth"");

        uint256 vecrv = IERC20(escrow).balanceOf(staker);
        if(vecrv == 0){
            uint256 unlockAt = block.timestamp + MAXTIME;
            uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;

            //release old lock if exists
            IStaker(staker).release();
            //create new lock
            uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);
            IStaker(staker).createLock(crvBalanceStaker, unlockAt);
            unlockTime = unlockInWeeks;
        }
    }

    //lock curve
    function _lockCurve() internal {
        if(cooldown) {
          return;
        }

        uint256 crvBalance = IERC20(crvBpt).balanceOf(address(this));
        if(crvBalance > 0){
            IERC20(crvBpt).safeTransfer(staker, crvBalance);
        }
        
        //increase ammount
        uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker);
        if(crvBalanceStaker == 0){
            return;
        }
        
        //increase amount
        IStaker(staker).increaseAmount(crvBalanceStaker);
        

        uint256 unlockAt = block.timestamp + MAXTIME;
        uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;

        //increase time too if over 2 week buffer
        if(unlockInWeeks.sub(unlockTime) > 2){
            IStaker(staker).increaseTime(unlockAt);
            unlockTime = unlockInWeeks;
        }
    }

    /**
     * @notice Locks the balance of CRV, and gives out an incentive to the caller
     */
    function lockCurve() external {
        require(!cooldown, ""cooldown"");
        _lockCurve();

        //mint incentives
        if(incentiveCrv > 0){
            ITokenMinter(minter).mint(msg.sender,incentiveCrv);
            incentiveCrv = 0;
        }
    }

    /**
     * @notice Deposit crvBpt for cvxCrv on behalf of another user
     * @dev    See depositFor(address, uint256, bool, address) 
     */
    function deposit(uint256 _amount, bool _lock, address _stakeAddress) public {
        depositFor(msg.sender, _amount, _lock, _stakeAddress);
    }

    /**
     * @notice Deposit crvBpt for cvxCrv
     * @dev    Can locking immediately or defer locking to someone else by paying a fee.
     *         while users can choose to lock or defer, this is mostly in place so that
     *         the cvx reward contract isnt costly to claim rewards.
     * @param _amount        Units of CRV to deposit
     * @param _lock          Lock now? or pay ~1% to the locker
     * @param _stakeAddress  Stake in cvxCrv staking?
     */
    function depositFor(address to, uint256 _amount, bool _lock, address _stakeAddress) public {
        require(_amount > 0,""!>0"");
        
        if(_lock){
            //lock immediately, transfer directly to staker to skip an erc20 transfer
            IERC20(crvBpt).safeTransferFrom(msg.sender, staker, _amount);
            _lockCurve();
            if(incentiveCrv > 0){
                //add the incentive tokens here so they can be staked together
                _amount = _amount.add(incentiveCrv);
                incentiveCrv = 0;
            }
        }else{
            //move tokens here
            IERC20(crvBpt).safeTransferFrom(msg.sender, address(this), _amount);
            //defer lock cost to another user
            uint256 callIncentive = _amount.mul(lockIncentive).div(FEE_DENOMINATOR);
            _amount = _amount.sub(callIncentive);

            //add to a pool for lock caller
            incentiveCrv = incentiveCrv.add(callIncentive);
        }

        bool depositOnly = _stakeAddress == address(0);
        if(depositOnly){
            //mint for to
            ITokenMinter(minter).mint(to,_amount);
        }else{
            //mint here 
            ITokenMinter(minter).mint(address(this),_amount);
            //stake for to
            IERC20(minter).safeApprove(_stakeAddress,0);
            IERC20(minter).safeApprove(_stakeAddress,_amount);
            IRewards(_stakeAddress).stakeFor(to,_amount);
        }
    }

    function deposit(uint256 _amount, bool _lock) external {
        deposit(_amount,_lock,address(0));
    }

    function depositAll(bool _lock, address _stakeAddress) external{
        uint256 crvBal = IERC20(crvBpt).balanceOf(msg.sender);
        deposit(crvBal,_lock,_stakeAddress);
    }
}",1937
RealWorld_TA_123_VoterProxy_RealWorld_20240815232439.log,123,VoterProxy,271732,7149,278881,177.0,1.50164,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

/**
 * @title   VoterProxy
 * @author  ConvexFinance
 * @notice  VoterProxy whitelisted in the curve SmartWalletWhitelist that
 *          participates in Curve governance. Also handles all deposits since this is 
 *          the address that has the voting power.
 */
contract VoterProxy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public mintr;
    address public immutable crv;
    address public immutable crvBpt;

    address public immutable escrow;
    address public gaugeController;
    address public rewardDeposit;
    address public withdrawer;

    address public owner;
    address public operator;
    address public depositor;
    
    mapping (address => bool) private stashPool;
    mapping (address => bool) private protectedTokens;
    mapping (bytes32 => bool) private votes;

    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x1626ba7e;

    event VoteSet(bytes32 hash, bool valid);

    /**
     * @param _mintr            CRV minter
     * @param _crv              CRV Token address
     * @param _crvBpt           CRV:ETH 80-20 BPT Token address
     * @param _escrow           Curve Voting escrow contract
     * @param _gaugeController  Curve Gauge Controller
     *                          Controls liquidity gauges and the issuance of coins through the gauges
     */
    constructor(
        address _mintr,
        address _crv,
        address _crvBpt,
        address _escrow,
        address _gaugeController
    ) public {
        mintr = _mintr; 
        crv = _crv;
        crvBpt = _crvBpt;
        escrow = _escrow;
        gaugeController = _gaugeController;
        owner = msg.sender;

        protectedTokens[_crv] = true;
        protectedTokens[_crvBpt] = true;
    }

    function getName() external pure returns (string memory) {
        return ""BalancerVoterProxy"";
    }

    function setOwner(address _owner) external {
        require(msg.sender == owner, ""!auth"");
        owner = _owner;
    }

    /**
     * @notice Allows dao to set the reward withdrawal address
     * @param _withdrawer Whitelisted withdrawer
     * @param _rewardDeposit Distributor address
     */
    function setRewardDeposit(address _withdrawer, address _rewardDeposit) external {
        require(msg.sender == owner, ""!auth"");
        withdrawer = _withdrawer;
        rewardDeposit = _rewardDeposit;
    }

    /**
     * @notice Allows dao to set the external system config, should it change in the future
     * @param _gaugeController External gauge controller address
     * @param _mintr Token minter address for claiming rewards
     */
    function setSystemConfig(address _gaugeController, address _mintr) external returns (bool) {
        require(msg.sender == owner, ""!auth"");
        gaugeController = _gaugeController;
        mintr = _mintr;
        return true;
    }

    /**
     * @notice Set the operator of the VoterProxy
     * @param _operator Address of the operator (Booster)
     */
    function setOperator(address _operator) external {
        require(msg.sender == owner, ""!auth"");
        require(operator == address(0) || IDeposit(operator).isShutdown() == true, ""needs shutdown"");
        
        operator = _operator;
    }

    /**
     * @notice Set the depositor of the VoterProxy
     * @param _depositor Address of the depositor (CrvDepositor)
     */
    function setDepositor(address _depositor) external {
        require(msg.sender == owner, ""!auth"");

        depositor = _depositor;
    }

    function setStashAccess(address _stash, bool _status) external returns(bool){
        require(msg.sender == operator, ""!auth"");
        if(_stash != address(0)){
            stashPool[_stash] = _status;
        }
        return true;
    }

    /**
     * @notice Save a vote hash so when snapshot.org asks this contract if 
     *          a vote signature is valid we are able to check for a valid hash
     *          and return the appropriate response inline with EIP 1721
     * @param _hash  Hash of vote signature that was sent to snapshot.org
     * @param _valid Is the hash valid
     */
    function setVote(bytes32 _hash, bool _valid) external {
        require(msg.sender == operator, ""!auth"");
        votes[_hash] = _valid;
        emit VoteSet(_hash, _valid);
    }

    /**
     * @notice  Verifies that the hash is valid
     * @dev     Snapshot Hub will call this function when a vote is submitted using
     *          snapshot.js on behalf of this contract. Snapshot Hub will call this
     *          function with the hash and the signature of the vote that was cast.
     * @param _hash Hash of the message that was sent to Snapshot Hub to cast a vote
     * @return EIP1271 magic value if the signature is value 
     */
    function isValidSignature(bytes32 _hash, bytes memory) public view returns (bytes4) {
        if(votes[_hash]) {
            return EIP1271_MAGIC_VALUE;
        } else {
            return 0xffffffff;
        }  
    }

    /**
     * @notice  Deposit tokens into the Curve Gauge
     * @dev     Only can be called by the operator (Booster) once this contract has been
     *          whitelisted by the Curve DAO
     * @param _token  Deposit LP token address
     * @param _gauge  Gauge contract to deposit to 
     */ 
    function deposit(address _token, address _gauge) external returns(bool){
        require(msg.sender == operator, ""!auth"");
        if(protectedTokens[_token] == false){
            protectedTokens[_token] = true;
        }
        if(protectedTokens[_gauge] == false){
            protectedTokens[_gauge] = true;
        }
        uint256 balance = IERC20(_token).balanceOf(address(this));
        if (balance > 0) {
            IERC20(_token).safeApprove(_gauge, 0);
            IERC20(_token).safeApprove(_gauge, balance);
            ICurveGauge(_gauge).deposit(balance);
        }
        return true;
    }

    /**
     * @notice  Withdraw ERC20 tokens that have been distributed as extra rewards
     * @dev     Tokens shouldn't end up here if they can help it. However, dao can
     *          set a withdrawer that can process these to some ExtraRewardDistribution.
     */
    function withdraw(IERC20 _asset) external returns (uint256 balance) {
        require(msg.sender == withdrawer, ""!auth"");
        require(protectedTokens[address(_asset)] == false, ""protected"");

        balance = _asset.balanceOf(address(this));
        _asset.safeApprove(rewardDeposit, 0);
        _asset.safeApprove(rewardDeposit, balance);
        IRewardDeposit(rewardDeposit).addReward(address(_asset), balance);
        return balance;
    }

    /**
     * @notice  Withdraw LP tokens from a gauge 
     * @dev     Only callable by the operator 
     * @param _token    LP token address
     * @param _gauge    Gauge for this LP token
     * @param _amount   Amount of LP token to withdraw
     */
    function withdraw(address _token, address _gauge, uint256 _amount) public returns(bool){
        require(msg.sender == operator, ""!auth"");
        uint256 _balance = IERC20(_token).balanceOf(address(this));
        if (_balance < _amount) {
            _amount = _withdrawSome(_gauge, _amount.sub(_balance));
            _amount = _amount.add(_balance);
        }
        IERC20(_token).safeTransfer(msg.sender, _amount);
        return true;
    }

    /**
     * @notice  Withdraw all LP tokens from a gauge 
     * @dev     Only callable by the operator 
     * @param _token  LP token address
     * @param _gauge  Gauge for this LP token
     */
    function withdrawAll(address _token, address _gauge) external returns(bool){
        require(msg.sender == operator, ""!auth"");
        uint256 amount = balanceOfPool(_gauge).add(IERC20(_token).balanceOf(address(this)));
        withdraw(_token, _gauge, amount);
        return true;
    }

    function _withdrawSome(address _gauge, uint256 _amount) internal returns (uint256) {
        ICurveGauge(_gauge).withdraw(_amount);
        return _amount;
    }
    
    
    /**
     * @notice  Lock CRV in curves voting escrow contract
     * @dev     Called by the CrvDepositor contract
     * @param _value      Amount of crv to lock
     * @param _unlockTime Timestamp to unlock (max is 4 years)
     */
    function createLock(uint256 _value, uint256 _unlockTime) external returns(bool){
        require(msg.sender == depositor, ""!auth"");
        IERC20(crvBpt).safeApprove(escrow, 0);
        IERC20(crvBpt).safeApprove(escrow, _value);
        ICurveVoteEscrow(escrow).create_lock(_value, _unlockTime);
        return true;
    }
  
    /**
     * @notice Called by the CrvDepositor to increase amount of locked curve
     */
    function increaseAmount(uint256 _value) external returns(bool){
        require(msg.sender == depositor, ""!auth"");
        IERC20(crvBpt).safeApprove(escrow, 0);
        IERC20(crvBpt).safeApprove(escrow, _value);
        ICurveVoteEscrow(escrow).increase_amount(_value);
        return true;
    }

    /**
     * @notice Called by the CrvDepositor to increase unlocked time of curve
     * @param _value Timestamp to increase locking to
     */
    function increaseTime(uint256 _value) external returns(bool){
        require(msg.sender == depositor, ""!auth"");
        ICurveVoteEscrow(escrow).increase_unlock_time(_value);
        return true;
    }

    /**
     * @notice  Withdraw all CRV from Curve's voting escrow contract
     * @dev     Only callable by CrvDepositor and can only withdraw if lock has expired
     */
    function release() external returns(bool){
        require(msg.sender == depositor, ""!auth"");
        ICurveVoteEscrow(escrow).withdraw();
        return true;
    }

    /**
     * @notice Vote on CRV DAO for proposal
     */
    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){
        require(msg.sender == operator, ""!auth"");
        IVoting(_votingAddress).vote(_voteId,_support,false);
        return true;
    }

    /**
     * @notice Vote for a single gauge weight via the controller
     */
    function voteGaugeWeight(address _gauge, uint256 _weight) external returns(bool){
        require(msg.sender == operator, ""!auth"");

        //vote
        IVoting(gaugeController).vote_for_gauge_weights(_gauge, _weight);
        return true;
    }

    /**
     * @notice  Claim CRV from Curve
     * @dev     Claim CRV for LP token staking from the CRV minter contract
     */
    function claimCrv(address _gauge) external returns (uint256){
        require(msg.sender == operator, ""!auth"");
        
        uint256 _balance = 0;
        try IMinter(mintr).mint(_gauge){
            _balance = IERC20(crv).balanceOf(address(this));
            IERC20(crv).safeTransfer(operator, _balance);
        }catch{}

        return _balance;
    }

    /**
     * @notice  Claim extra rewards from gauge
     * @dev     Called by operator (Booster) to claim extra rewards 
     */
    function claimRewards(address _gauge) external returns(bool){
        require(msg.sender == operator, ""!auth"");
        ICurveGauge(_gauge).claim_rewards();
        return true;
    }

    /**
     * @notice  Claim fees (3crv) from staking lp tokens
     * @dev     Only callable by the operator Booster
     * @param _distroContract   Fee distribution contract
     * @param _token            LP token to claim fees for
     */
    function claimFees(address _distroContract, address _token) external returns (uint256){
        require(msg.sender == operator, ""!auth"");
        IFeeDistributor(_distroContract).claimToken(address(this), _token);
        uint256 _balance = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransfer(operator, _balance);
        return _balance;
    }    

    function balanceOfPool(address _gauge) public view returns (uint256) {
        return ICurveGauge(_gauge).balanceOf(address(this));
    }

    function execute(
        address _to,
        uint256 _value,
        bytes calldata _data
    ) external returns (bool, bytes memory) {
        require(msg.sender == operator,""!auth"");

        (bool success, bytes memory result) = _to.call{value:_value}(_data);
        require(success, ""!success"");

        return (success, result);
    }

}",3025
RealWorld_TA_123_MockBalancerPoolToken_RealWorld_20240816010638.log,123,MockBalancerPoolToken,40693,2905,43598,102.0,0.261565,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol"";

contract MockBalancerPoolToken is ERC20(""MockBPT"", ""MockBPT"") {
    struct OracleAverageQuery {
        Variable variable;
        uint256 secs;
        uint256 ago;
    }

    enum Variable {
        PAIR_PRICE,
        BPT_PRICE,
        INVARIANT
    }

    uint8 dec;

    uint256 public price;

    constructor(
        uint8 _decimals,
        address _initialRecipient,
        uint256 _initialMint
    ) {
        dec = _decimals;
        _mint(_initialRecipient, _initialMint * (10**uint256(_decimals)));
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function setPrice(uint256 _price) external {
        price = _price;
    }

    function getTimeWeightedAverage(OracleAverageQuery[] memory) external view returns (uint256[] memory) {
        uint256[] memory results = new uint256[](1);
        results[0] = price;
        return results;
    }
}",256
RealWorld_TA_123_MockFeeDistro_RealWorld_20240816010822.log,123,MockFeeDistro,51665,3675,55340,121.0,0.331825,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

interface IFeeDistributor {
    function claimToken(address user, IERC20 token) external returns (uint256);

    function claimTokens(address user, IERC20[] calldata tokens) external returns (uint256[] memory);

    function getTokenTimeCursor(IERC20 token) external view returns (uint256);
}

// @dev - Must be funded by transferring crv to this contract post deployment, as opposed to minting directly
contract MockFeeDistributor is IFeeDistributor {
    mapping(address => uint256) private tokenRates;

    constructor(address[] memory _tokens, uint256[] memory _rates) {
        for (uint256 i = 0; i < _tokens.length; i++) {
            tokenRates[_tokens[i]] = _rates[i];
        }
    }

    function claimToken(address user, IERC20 token) external returns (uint256) {
        return _claimToken(user, token);
    }

    function _claimToken(address user, IERC20 token) internal returns (uint256) {
        uint256 rate = tokenRates[address(token)];
        if (rate > 0) {
            token.transfer(user, rate);
        }
        return rate;
    }

    function claimTokens(address user, IERC20[] calldata tokens) external returns (uint256[] memory) {
        uint256[] memory rates = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            rates[i] = _claimToken(user, tokens[i]);
        }
        return rates;
    }

    function getTokenTimeCursor(IERC20 token) external view returns (uint256) {
        return 1;
    }
}",393
RealWorld_TA_123_BaseRewardPool4626_RealWorld_20240815234940.log,123,BaseRewardPool4626,214256,4229,218485,140.0,1.15586,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import { BaseRewardPool, IDeposit } from ""./BaseRewardPool.sol"";
import { IERC4626, IERC20Metadata } from ""./interfaces/IERC4626.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.6/utils/ReentrancyGuard.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

/**
 * @title   BaseRewardPool4626
 * @notice  Simply wraps the BaseRewardPool with the new IERC4626 Vault standard functions.
 * @dev     See https://github.com/fei-protocol/ERC4626/blob/main/src/interfaces/IERC4626.sol#L58
 *          This is not so much a vault as a Reward Pool, therefore asset:share ratio is always 1:1.
 *          To create most utility for this RewardPool, the ""asset"" has been made to be the crvLP token,
 *          as opposed to the cvxLP token. Therefore, users can easily deposit crvLP, and it will first
 *          go to the Booster and mint the cvxLP before performing the normal staking function.
 */
contract BaseRewardPool4626 is BaseRewardPool, ReentrancyGuard, IERC4626 {
    using SafeERC20 for IERC20;

    /**
     * @notice The address of the underlying ERC20 token used for
     * the Vault for accounting, depositing, and withdrawing.
     */
    address public override asset;

    mapping (address => mapping (address => uint256)) private _allowances;

    /**
     * @dev See BaseRewardPool.sol
     */
    constructor(
        uint256 pid_,
        address stakingToken_,
        address rewardToken_,
        address operator_,
        address rewardManager_,
        address lptoken_
    ) public BaseRewardPool(pid_, stakingToken_, rewardToken_, operator_, rewardManager_) {
        asset = lptoken_;
        IERC20(asset).safeApprove(operator_, type(uint256).max);
    }

    /**
     * @notice Total amount of the underlying asset that is ""managed"" by Vault.
     */
    function totalAssets() external view virtual override returns(uint256){
        return totalSupply();
    }

    /**
     * @notice Mints `shares` Vault shares to `receiver`.
     * @dev Because `asset` is not actually what is collected here, first wrap to required token in the booster.
     */
    function deposit(uint256 assets, address receiver) public virtual override nonReentrant returns (uint256) {
        // Transfer ""asset"" (crvLP) from sender
        IERC20(asset).safeTransferFrom(msg.sender, address(this), assets);

        // Convert crvLP to cvxLP through normal booster deposit process, but don't stake
        uint256 balBefore = stakingToken.balanceOf(address(this));
        IDeposit(operator).deposit(pid, assets, false);
        uint256 balAfter = stakingToken.balanceOf(address(this));

        require(balAfter - balBefore >= assets, ""!deposit"");

        // Perform stake manually, now that the funds have been received
        _processStake(assets, receiver);

        emit Deposit(msg.sender, receiver, assets, assets);
        emit Staked(receiver, assets);
        return assets;
    }

    /**
     * @notice Mints exactly `shares` Vault shares to `receiver`
     * by depositing `assets` of underlying tokens.
     */
    function mint(uint256 shares, address receiver) external virtual override returns (uint256) {
        return deposit(shares, receiver);
    }

    /**
     * @notice Redeems `shares` from `owner` and sends `assets`
     * of underlying tokens to `receiver`.
     */
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public virtual override nonReentrant returns (uint256) {
        if (msg.sender != owner) {
            _approve(owner, msg.sender, _allowances[owner][msg.sender].sub(assets, ""ERC4626: withdrawal amount exceeds allowance""));
        }
        
        _withdrawAndUnwrapTo(assets, owner, receiver);

        emit Withdraw(msg.sender, receiver, owner, assets, assets);
        return assets;
    }

    /**
     * @notice Redeems `shares` from `owner` and sends `assets`
     * of underlying tokens to `receiver`.
     */
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external virtual override returns (uint256) {
        return withdraw(shares, receiver, owner);
    }

    /**
     * @notice The amount of shares that the vault would
     * exchange for the amount of assets provided, in an
     * ideal scenario where all the conditions are met.
     */
    function convertToShares(uint256 assets) public view virtual override returns (uint256) {
        return assets;
    }

    /**
     * @notice The amount of assets that the vault would
     * exchange for the amount of shares provided, in an
     * ideal scenario where all the conditions are met.
     */
    function convertToAssets(uint256 shares) public view virtual override returns (uint256) {
        return shares;
    }

    /**
     * @notice Total number of underlying assets that can
     * be deposited by `owner` into the Vault, where `owner`
     * corresponds to the input parameter `receiver` of a
     * `deposit` call.
     */
    function maxDeposit(address /* owner */) public view virtual override returns (uint256) {
        return type(uint256).max;
    }

    /**
     * @notice Allows an on-chain or off-chain user to simulate
     * the effects of their deposit at the current block, given
     * current on-chain conditions.
     */    
    function previewDeposit(uint256 assets) external view virtual override returns(uint256){
        return convertToShares(assets);
    }

    /**
     * @notice Total number of underlying shares that can be minted
     * for `owner`, where `owner` corresponds to the input
     * parameter `receiver` of a `mint` call.
     */
    function maxMint(address owner) external view virtual override returns (uint256) {
        return maxDeposit(owner);
    }

    /**    
     * @notice Allows an on-chain or off-chain user to simulate
     * the effects of their mint at the current block, given
     * current on-chain conditions.
     */
    function previewMint(uint256 shares) external view virtual override returns(uint256){
        return convertToAssets(shares);
    }

    /**
     * @notice Total number of underlying assets that can be
     * withdrawn from the Vault by `owner`, where `owner`
     * corresponds to the input parameter of a `withdraw` call.
     */
    function maxWithdraw(address owner) public view virtual override returns (uint256) {
        return balanceOf(owner);
    }

    /**    
     * @notice Allows an on-chain or off-chain user to simulate
     * the effects of their withdrawal at the current block,
     * given current on-chain conditions.
     */
    function previewWithdraw(uint256 assets) public view virtual override returns(uint256 shares){
        return convertToShares(assets);
    }

    /**
     * @notice Total number of underlying shares that can be
     * redeemed from the Vault by `owner`, where `owner` corresponds
     * to the input parameter of a `redeem` call.
     */
    function maxRedeem(address owner) external view virtual override returns (uint256) {
        return maxWithdraw(owner);
    }
    /**    
     * @notice Allows an on-chain or off-chain user to simulate
     * the effects of their redeemption at the current block,
     * given current on-chain conditions.
     */
    function previewRedeem(uint256 shares) external view virtual override returns(uint256){
        return previewWithdraw(shares);
    }


    /* ========== IERC20 ========== */

    /**
     * @dev Returns the name of the token.
     */
    function name() external view override returns (string memory) {
        return string(
            abi.encodePacked(IERC20Metadata(address(stakingToken)).name(), "" Vault"")
        );
    }

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view override returns (string memory) {
        return string(
            abi.encodePacked(IERC20Metadata(address(stakingToken)).symbol(), ""-vault"")
        );
    }

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view override returns (uint8) {
        return 18;
    }

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() public view override(BaseRewardPool, IERC20) returns (uint256) {
        return BaseRewardPool.totalSupply();
    }

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) public view override(BaseRewardPool, IERC20) returns (uint256) {
        return BaseRewardPool.balanceOf(account);
    }

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address /* recipient */, uint256 /* amount */) external override returns (bool) {
        revert(""ERC4626: Not supported"");
    }


    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC4626: approve from the zero address"");
        require(spender != address(0), ""ERC4626: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     */
    function transferFrom(address /* sender */, address /* recipient */, uint256 /* amount */) external override returns (bool) {
        revert(""ERC4626: Not supported"");
    }
}",2353
RealWorld_TA_123_RewardHook_RealWorld_20240815232738.log,123,RewardHook,48238,2288,50526,96.0,0.28695,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";


/**
 * @title   RewardHook
 * @author  ConvexFinance
 * @notice  Example Reward hook for stash
 * @dev     ExtraRewardStash contracts call this hook if it is set. This hook
 *          can be used to pull rewards during a claim. For example pulling
 *          rewards from master chef.
 */
contract RewardHook{
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;


    address public immutable stash;
    address public immutable rewardToken;


    /**
     * @param _stash    Address of the reward stash
     * @param _reward   Reward token
     */
    constructor(address _stash, address _reward) public {
        stash = _stash;
        rewardToken = _reward;
    }


    /**
     * @dev Called when claimRewards is called in ExtraRewardStash can implement
     *      logic to pull rewards i.e from a master chef contract. This is just an example
     *      and assumes rewards are just sent directly to this hook contract
     */
    function onRewardClaim() external{

        //get balance
        uint256 bal = IERC20(rewardToken).balanceOf(address(this));

        //send
        IERC20(rewardToken).safeTransfer(stash,bal);
    }
}",367
RealWorld_TA_123_TokenFactory_RealWorld_20240815235615.log,123,TokenFactory,47662,1656,49318,88.0,0.27143,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""./DepositToken.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

/**
 * @title   TokenFactory
 * @author  ConvexFinance
 * @notice  Token factory used to create Deposit Tokens. These are the tokenized
 *          pool deposit tokens e.g cvx3crv
 */
contract TokenFactory {
    using Address for address;

    address public immutable operator;
    string public namePostfix;
    string public symbolPrefix;

    event DepositTokenCreated(address token, address lpToken);

    /**
     * @param _operator         Operator is Booster
     * @param _namePostfix      Postfixes lpToken name
     * @param _symbolPrefix     Prefixed lpToken symbol
     */
    constructor(
        address _operator,
        string memory _namePostfix,
        string memory _symbolPrefix
    ) public {
        operator = _operator;
        namePostfix = _namePostfix;
        symbolPrefix = _symbolPrefix;
    }

    function CreateDepositToken(address _lptoken) external returns(address){
        require(msg.sender == operator, ""!authorized"");

        DepositToken dtoken = new DepositToken(operator,_lptoken,namePostfix,symbolPrefix);
        emit DepositTokenCreated(address(dtoken), _lptoken);
        return address(dtoken);
    }
}",358
RealWorld_TA_123_AuraMinter_RealWorld_20240816002633.log,123,AuraMinter,43721,1854,45575,111.0,0.255685,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { AuraToken } from ""./Aura.sol"";

/**
 * @title   AuraMinter
 * @notice  Wraps the AuraToken minterMint function and protects from inflation until
 *          4 years have passed.
 * @dev     Ownership initially owned by the DAO, but likely transferred to smart contract
 *          wrapper or additional value system at some stage as directed by token holders.
 */
contract AuraMinter is Ownable {
    /// @dev Aura token
    AuraToken public immutable aura;
    /// @dev Timestamp upon which minting will be possible
    uint256 public immutable inflationProtectionTime;

    constructor(address _aura, address _dao) Ownable() {
        aura = AuraToken(_aura);
        _transferOwnership(_dao);
        inflationProtectionTime = block.timestamp + 156 weeks;
    }

    /**
     * @dev Mint function allows the owner of the contract to inflate AURA post protection time
     * @param _to Recipient address
     * @param _amount Amount of tokens
     */
    function mint(address _to, uint256 _amount) external onlyOwner {
        require(block.timestamp > inflationProtectionTime, ""Inflation protected for now"");
        aura.minterMint(_to, _amount);
    }
}",298
RealWorld_TA_123_VirtualBalanceRewardPool_RealWorld_20240815234516.log,123,VirtualBalanceRewardPool,185189,4454,189643,137.0,1.015025,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
/**
 *Submitted for verification at Etherscan.io on 2020-07-17
 */

/*
   ____            __   __        __   _
  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __
 _\ \ / // // _ \/ __// _ \/ -_)/ __// / \ \ /
/___/ \_, //_//_/\__//_//_/\__/ \__//_/ /_\_\
     /___/

* Synthetix: VirtualBalanceRewardPool.sol
*
* Docs: https://docs.synthetix.io/
*
*
* MIT License
* ===========
*
* Copyright (c) 2020 Synthetix
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the ""Software""), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*/

import ""./Interfaces.sol"";
import ""./interfaces/MathUtil.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";


abstract contract VirtualBalanceWrapper {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IDeposit public immutable deposits;

    constructor(address deposit_) internal {
        deposits = IDeposit(deposit_);
    }

    function totalSupply() public view returns (uint256) {
        return deposits.totalSupply();
    }

    function balanceOf(address account) public view returns (uint256) {
        return deposits.balanceOf(account);
    }
}

/**
 * @title   VirtualBalanceRewardPool
 * @author  ConvexFinance
 * @notice  Reward pool used for ExtraRewards in Booster lockFees (3crv) and
 *          Extra reward stashes
 * @dev     The rewards are sent to this contract for distribution to stakers. This
 *          contract does not hold any of the staking tokens it just maintains a virtual
 *          balance of what a user has staked in the staking pool (BaseRewardPool).
 *          For example the Booster sends veCRV fees (3Crv) to a VirtualBalanceRewardPool
 *          which tracks the virtual balance of cxvCRV stakers and distributes their share
 *          of 3Crv rewards
 */
contract VirtualBalanceRewardPool is VirtualBalanceWrapper {
    using SafeERC20 for IERC20;
    
    IERC20 public immutable rewardToken;
    uint256 public constant duration = 7 days;

    address public immutable operator;

    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    uint256 public queuedRewards = 0;
    uint256 public currentRewards = 0;
    uint256 public historicalRewards = 0;
    uint256 public constant newRewardRatio = 830;
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);

    /**
     * @param deposit_  Parent deposit pool e.g cvxCRV staking in BaseRewardPool
     * @param reward_   The rewards token e.g 3Crv
     * @param op_       Operator contract (Booster)
     */
    constructor(
        address deposit_,
        address reward_,
        address op_
    ) public VirtualBalanceWrapper(deposit_) {
        rewardToken = IERC20(reward_);
        operator = op_;
    }


    /**
     * @notice Update rewards earned by this account
     */
    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return MathUtil.min(block.timestamp, periodFinish);
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalSupply() == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable()
                    .sub(lastUpdateTime)
                    .mul(rewardRate)
                    .mul(1e18)
                    .div(totalSupply())
            );
    }

    function earned(address account) public view returns (uint256) {
        return
            balanceOf(account)
                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))
                .div(1e18)
                .add(rewards[account]);
    }

    /**
     * @notice  Update reward, emit, call linked reward's stake
     * @dev     Callable by the deposits address which is the BaseRewardPool
     *          this updates the virtual balance of this user as this contract doesn't
     *          actually hold any staked tokens it just diributes reward tokens
     */
    function stake(address _account, uint256 amount)
        external
        updateReward(_account)
    {
        require(msg.sender == address(deposits), ""!authorized"");
       // require(amount > 0, 'VirtualDepositRewardPool: Cannot stake 0');
        emit Staked(_account, amount);
    }

    /**
     * @notice  Withdraw stake and update reward, emit, call linked reward's stake
     * @dev     See stake
     */
    function withdraw(address _account, uint256 amount)
        public
        updateReward(_account)
    {
        require(msg.sender == address(deposits), ""!authorized"");
        //require(amount > 0, 'VirtualDepositRewardPool : Cannot withdraw 0');

        emit Withdrawn(_account, amount);
    }

    /**
     * @notice  Get rewards for this account
     * @dev     This can be called directly but it is usually called by the
     *          BaseRewardPool getReward when the BaseRewardPool loops through
     *          it's extraRewards array calling getReward on all of them
     */
    function getReward(address _account) public updateReward(_account){
        uint256 reward = earned(_account);
        if (reward > 0) {
            rewards[_account] = 0;
            rewardToken.safeTransfer(_account, reward);
            emit RewardPaid(_account, reward);
        }
    }

    function getReward() external{
        getReward(msg.sender);
    }

    function donate(uint256 _amount) external returns(bool){
        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);
        queuedRewards = queuedRewards.add(_amount);
    }

    function queueNewRewards(uint256 _rewards) external{
        require(msg.sender == operator, ""!authorized"");

        _rewards = _rewards.add(queuedRewards);

        if (block.timestamp >= periodFinish) {
            notifyRewardAmount(_rewards);
            queuedRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if(queuedRatio < newRewardRatio){
            notifyRewardAmount(_rewards);
            queuedRewards = 0;
        }else{
            queuedRewards = _rewards;
        }
    }

    function notifyRewardAmount(uint256 reward)
        internal
        updateReward(address(0))
    {
        historicalRewards = historicalRewards.add(reward);
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(duration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            reward = reward.add(leftover);
            rewardRate = reward.div(duration);
        }
        currentRewards = reward;
        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(duration);
        emit RewardAdded(reward);
    }
}",1999
RealWorld_TA_123_AuraBalRewardPool_RealWorld_20240816003529.log,123,AuraBalRewardPool,159915,3791,163706,131.0,0.875395,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { AuraMath } from ""./AuraMath.sol"";
import { SafeMath } from ""@openzeppelin/contracts-0.8/utils/math/SafeMath.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";

import { IAuraLocker } from ""./Interfaces.sol"";

/**
 * @title   AuraBalRewardPool
 * @author  Synthetix -> ConvexFinance -> adapted
 * @notice  This AuraBalRewardPool is deployed to support auraBAL deposits during the first 2
 *          weeks of system operation. After which, the BaseRewardPool hooked into the Booster (lockRewards)
 *          will be used for auraBAL farming.
 * @dev     Modifications from convex-platform/contracts/contracts/BaseRewardPool.sol:
 *            - Delayed start (tokens transferred then delay is enforced before notification)
 *            - One time duration of 14 days
 *            - Remove child reward contracts
 *            - Penalty on claim at 20%
 */
contract AuraBalRewardPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable rewardToken;
    IERC20 public immutable stakingToken;
    uint256 public constant duration = 14 days;

    address public immutable rewardManager;

    IAuraLocker public immutable auraLocker;
    address public immutable penaltyForwarder;
    uint256 public pendingPenalty = 0;
    uint256 public immutable startTime;

    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    uint256 private _totalSupply;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;
    mapping(address => uint256) private _balances;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward, bool locked);
    event PenaltyForwarded(uint256 amount);

    /**
     * @dev Simple constructoor
     * @param _stakingToken  Pool LP token
     * @param _rewardToken   $AURA
     * @param _rewardManager Depositor
     * @param _auraLocker    $AURA lock contract
     * @param _penaltyForwarder Address to which penalties are sent
     */
    constructor(
        address _stakingToken,
        address _rewardToken,
        address _rewardManager,
        address _auraLocker,
        address _penaltyForwarder,
        uint256 _startDelay
    ) {
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
        rewardManager = _rewardManager;
        auraLocker = IAuraLocker(_auraLocker);
        penaltyForwarder = _penaltyForwarder;
        rewardToken.safeApprove(_auraLocker, type(uint256).max);

        require(_startDelay < 2 weeks, ""!delay"");
        startTime = block.timestamp + _startDelay;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return AuraMath.min(block.timestamp, periodFinish);
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalSupply() == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())
            );
    }

    function earned(address account) public view returns (uint256) {
        return
            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(
                rewards[account]
            );
    }

    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {
        require(_amount > 0, ""RewardPool : Cannot stake 0"");

        _totalSupply = _totalSupply.add(_amount);
        _balances[msg.sender] = _balances[msg.sender].add(_amount);

        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        emit Staked(msg.sender, _amount);

        return true;
    }

    function stakeAll() external returns (bool) {
        uint256 balance = stakingToken.balanceOf(msg.sender);
        stake(balance);
        return true;
    }

    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {
        require(_amount > 0, ""RewardPool : Cannot stake 0"");

        //give to _for
        _totalSupply = _totalSupply.add(_amount);
        _balances[_for] = _balances[_for].add(_amount);

        //take away from sender
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);
        emit Staked(_for, _amount);

        return true;
    }

    function withdraw(
        uint256 amount,
        bool claim,
        bool lock
    ) public updateReward(msg.sender) returns (bool) {
        require(amount > 0, ""RewardPool : Cannot withdraw 0"");

        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);

        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);

        if (claim) {
            getReward(lock);
        }

        return true;
    }

    /**
     * @dev Gives a staker their rewards
     * @param _lock Lock the rewards? If false, takes a 20% haircut
     */
    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            if (_lock) {
                auraLocker.lock(msg.sender, reward);
            } else {
                uint256 penalty = (reward * 2) / 10;
                pendingPenalty += penalty;
                rewardToken.safeTransfer(msg.sender, reward - penalty);
            }
            emit RewardPaid(msg.sender, reward, _lock);
        }
        return true;
    }

    /**
     * @dev Forwards to the penalty forwarder for distro to Aura Lockers
     */
    function forwardPenalty() public {
        uint256 toForward = pendingPenalty;
        pendingPenalty = 0;
        rewardToken.safeTransfer(penaltyForwarder, toForward);
        emit PenaltyForwarded(toForward);
    }

    /**
     * @dev Called once to initialise the rewards based on balance of stakeToken
     */
    function initialiseRewards() external returns (bool) {
        require(msg.sender == rewardManager || block.timestamp > startTime, ""!authorized"");
        require(rewardRate == 0, ""!one time"");

        uint256 rewardsAvailable = rewardToken.balanceOf(address(this));
        require(rewardsAvailable > 0, ""!balance"");

        rewardRate = rewardsAvailable.div(duration);

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(duration);

        emit RewardAdded(rewardsAvailable);

        return true;
    }
}",1688
RealWorld_TA_123_MockCurveMinter_RealWorld_20240816010318.log,123,MockCurveMinter,31445,2579,34024,101.0,0.208805,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

interface IMinter {
    function mint(address) external;
}

// @dev - Must be funded by transferring crv to this contract post deployment, as opposed to minting directly
contract MockCurveMinter is IMinter {
    IERC20 public immutable crv;
    uint256 public rate;

    constructor(address _crv, uint256 _rate) {
        crv = IERC20(_crv);
        rate = _rate;
    }

    function mint(address) external {
        crv.transfer(msg.sender, rate);
    }
}",154
RealWorld_TA_123_StashFactoryV2_RealWorld_20240815231944.log,123,StashFactoryV2,103838,4256,108094,125.0,0.60431,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""./interfaces/IProxyFactory.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

/**
 * @title   StashFactoryV2
 * @author  ConvexFinance
 * @notice  Factory to deploy reward stash contracts that handle extra rewards
 */
contract StashFactoryV2 {
    using Address for address;

    bytes4 private constant rewarded_token = 0x16fa50b1; //rewarded_token()
    bytes4 private constant reward_tokens = 0x54c49fe9; //reward_tokens(uint256)
    bytes4 private constant rewards_receiver = 0x01ddabf1; //rewards_receiver(address)

    address public immutable operator;
    address public immutable rewardFactory;
    address public immutable proxyFactory;

    address public v1Implementation;
    address public v2Implementation;
    address public v3Implementation;

    event StashCreated(address stash, uint256 stashVersion);

    /**
     * @param _operator       Operator is Booster
     * @param _rewardFactory  Factory that creates reward contract that are 
     *                        VirtualBalanceRewardPool's used for extra pool rewards
     * @param _proxyFactory   Deploy proxies with stash implementation
     */
    constructor(address _operator, address _rewardFactory, address _proxyFactory) public {
        operator = _operator;
        rewardFactory = _rewardFactory;
        proxyFactory = _proxyFactory;
    }

    function setImplementation(address _v1, address _v2, address _v3) external{
        require(msg.sender == IDeposit(operator).owner(),""!auth"");

        v1Implementation = _v1;
        v2Implementation = _v2;
        v3Implementation = _v3;
    }

    //Create a stash contract for the given gauge.
    //function calls are different depending on the version of curve gauges so determine which stash type is needed
    function CreateStash(uint256 _pid, address _gauge, address _staker, uint256 _stashVersion) external returns(address){
        require(msg.sender == operator, ""!authorized"");

        if(_stashVersion == uint256(3) && IsV3(_gauge)){
            //v3
            require(v3Implementation!=address(0),""0 impl"");
            address stash = IProxyFactory(proxyFactory).clone(v3Implementation);
            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);
            emit StashCreated(stash, _stashVersion);
            return stash;
        }else if(_stashVersion == uint256(1) && IsV1(_gauge)){
            //v1
            require(v1Implementation!=address(0),""0 impl"");
            address stash = IProxyFactory(proxyFactory).clone(v1Implementation);
            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);
            emit StashCreated(stash, _stashVersion);
            return stash;
        }else if(_stashVersion == uint256(2) && !IsV3(_gauge) && IsV2(_gauge)){
            //v2
            require(v2Implementation!=address(0),""0 impl"");
            address stash = IProxyFactory(proxyFactory).clone(v2Implementation);
            IStash(stash).initialize(_pid,operator,_staker,_gauge,rewardFactory);
            emit StashCreated(stash, _stashVersion);
            return stash;
        }
        bool isV1 = IsV1(_gauge);
        bool isV2 = IsV2(_gauge);
        bool isV3 = IsV3(_gauge);
        require(!isV1 && !isV2 && !isV3,""stash version mismatch"");
        return address(0);
    }

    function IsV1(address _gauge) private returns(bool){
        bytes memory data = abi.encode(rewarded_token);
        (bool success,) = _gauge.call(data);
        return success;
    }

    function IsV2(address _gauge) private returns(bool){
        bytes memory data = abi.encodeWithSelector(reward_tokens,uint256(0));
        (bool success,) = _gauge.call(data);
        return success;
    }

    function IsV3(address _gauge) private returns(bool){
        bytes memory data = abi.encodeWithSelector(rewards_receiver,address(0));
        (bool success,) = _gauge.call(data);
        return success;
    }
}",1008
RealWorld_TA_123_ExtraRewardStashV3_RealWorld_20240815233252.log,123,ExtraRewardStashV3,166686,6952,173638,167.0,0.97247,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""./interfaces/IRewardHook.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";


/**
 * @title   ExtraRewardStashV3
 * @author  ConvexFinance
 * @notice  ExtraRewardStash for pools added to the Booster to handle extra rewards
 *          that aren't CRV that can be claimed from a gauge.
 *          - v3.0: Support for curve gauge reward redirect
 *            The Booster contract has a function called setGaugeRedirect. This function calls set_rewards_receiver
 *            On the Curve Guage. This tells the Gauge where to send rewards. The Booster crafts the calldata for this
 *            transaction and then calls execute on the VoterProxy which executes this transaction on the Curve Gauge
 *          - v3.1: Support for arbitrary token rewards outside of gauge rewards add 
 *            reward hook to pull rewards during claims
 *          - v3.2: Move constuctor to init function for proxy creation
 */
contract ExtraRewardStashV3 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public immutable crv;
    uint256 private constant maxRewards = 8;

    uint256 public pid;
    address public operator;
    address public staker;
    address public gauge;
    address public rewardFactory;
   
    mapping(address => uint256) public historicalRewards;
    bool public hasRedirected;
    bool public hasCurveRewards;

    struct TokenInfo {
        address token;
        address rewardAddress;
    }

    //use mapping+array so that we dont have to loop check each time setToken is called
    mapping(address => TokenInfo) public tokenInfo;
    address[] public tokenList;

    //address to call for reward pulls
    address public rewardHook;
  
    /**
     * @param _crv CRV token address
     */
    constructor(address _crv) public {
      crv = _crv;
    }

    /**
     * @param _pid        Pool ID
     * @param _operator   Operator (Booster)
     * @param _staker     Staker (VoterProxy)
     * @param _gauge      Gauge
     * @param _rFactory   Reward factory
     */
    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rFactory) external {
        require(gauge == address(0),""!init"");
        pid = _pid;
        operator = _operator;
        staker = _staker;
        gauge = _gauge;
        rewardFactory = _rFactory;
    }

    function getName() external pure returns (string memory) {
        return ""ExtraRewardStashV3.2"";
    }

    function tokenCount() external view returns (uint256){
        return tokenList.length;
    }

    /**
     * @notice  Claim rewards from the gauge
     * @dev     The Stash's claimRewards function calls claimRewards on the Booster contract
     *          which calls claimRewards on the VoterProxy which calls claim_rewards on the gauge
     *          If a RewardHook is set onRewardClaim is also called on that
     *          Called by Booster earmarkRewards
     *          Guage rewards are sent directly to this stash even though the Curve method claim_rewards
     *          is being called by the VoterProxy. This is because Curves guages have the ability to redirect
     *          rewards to somewhere other than msg.sender. This is setup in Booster setGaugeRedirect
     */
    function claimRewards() external returns (bool) {
        require(msg.sender == operator, ""!operator"");

        //this is updateable from v2 gauges now so must check each time.
        checkForNewRewardTokens();

        //make sure we're redirected
        if(!hasRedirected){
            IDeposit(operator).setGaugeRedirect(pid);
            hasRedirected = true;
        }

        if(hasCurveRewards){
            //claim rewards on gauge for staker
            //using reward_receiver so all rewards will be moved to this stash
            IDeposit(operator).claimRewards(pid,gauge);
        }

        //hook for reward pulls
        if(rewardHook != address(0)){
            try IRewardHook(rewardHook).onRewardClaim(){
            }catch{}
        }
        return true;
    }
   

    //check if gauge rewards have changed
    function checkForNewRewardTokens() internal {
        for(uint256 i = 0; i < maxRewards; i++){
            address token = ICurveGauge(gauge).reward_tokens(i);
            if (token == address(0)) {
                break;
            }
            if(!hasCurveRewards){
                hasCurveRewards = true;
            }
            setToken(token);
        }
    }

    //register an extra reward token to be handled
    // (any new incentive that is not directly on curve gauges)
    function setExtraReward(address _token) external{
        //owner of booster can set extra rewards
        require(IDeposit(operator).owner() == msg.sender, ""!owner"");
        setToken(_token);
    }

    function setRewardHook(address _hook) external{
        //owner of booster can set reward hook
        require(IDeposit(operator).owner() == msg.sender, ""!owner"");
        rewardHook = _hook;
    }


    /**
     * @notice  Add a reward token to the token list so it can be claimed
     * @dev     For each token that is added as a claimable reward a VirtualRewardsPool
     *          is deployed to handle virtual distribution of tokens 
     */
    function setToken(address _token) internal {
        TokenInfo storage t = tokenInfo[_token];

        if(t.token == address(0)){
            //set token address
            t.token = _token;

            //check if crv
            if(_token != crv){
                //create new reward contract (for NON-crv tokens only)
                (,,,address mainRewardContract,,) = IDeposit(operator).poolInfo(pid);
                address rewardContract = IRewardFactory(rewardFactory).CreateTokenRewards(
                    _token,
                    mainRewardContract,
                    address(this));
                
                t.rewardAddress = rewardContract;
            }
            //add token to list of known rewards
            tokenList.push(_token);
        }
    }

    //pull assigned tokens from staker to stash
    function stashRewards() external pure returns(bool){

        //after depositing/withdrawing, extra incentive tokens are claimed
        //but from v3 this is default to off, and this stash is the reward receiver too.

        return true;
    }

    /**
     * @notice  Distribute rewards
     * @dev     Send all CRV to the Booster contract and send all extra token
     *          rewards to the rewardContract VirtualRewardsPool
     *          Called by Booster earmarkRewards
     */
    function processStash() external returns(bool){
        require(msg.sender == operator, ""!operator"");

        uint256 tCount = tokenList.length;
        for(uint i=0; i < tCount; i++){
            TokenInfo storage t = tokenInfo[tokenList[i]];
            address token = t.token;
            if(token == address(0)) continue;
            
            uint256 amount = IERC20(token).balanceOf(address(this));
            if (amount > 0) {
                historicalRewards[token] = historicalRewards[token].add(amount);
                if(token == crv){
                    //if crv, send back to booster to distribute
                    IERC20(token).safeTransfer(operator, amount);
                    continue;
                }
            	//add to reward contract
            	address rewards = t.rewardAddress;
            	if(rewards == address(0)) continue;
            	IERC20(token).safeTransfer(rewards, amount);
            	IRewards(rewards).queueNewRewards(amount);
            }
        }
        return true;
    }

}",1768
RealWorld_TA_123_AuraStakingProxy_RealWorld_20240816001745.log,123,AuraStakingProxy,166176,4789,170965,157.0,0.92666,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { Address } from ""@openzeppelin/contracts-0.8/utils/Address.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { SafeMath } from ""@openzeppelin/contracts-0.8/utils/math/SafeMath.sol"";
import { IAuraLocker, ICrvDepositorWrapper } from ""./Interfaces.sol"";

/**
 * @title   AuraStakingProxy
 * @author  adapted from ConvexFinance
 * @notice  Receives CRV from the Booster as overall reward, then convers to cvxCRV and distributes to vlCVX holders.
 * @dev     From CVX:
 *           - receive tokens to stake
 *           - get current staked balance
 *           - withdraw staked tokens
 *           - send rewards back to owner(cvx locker)
 *           - register token types that can be distributed
 */
contract AuraStakingProxy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    //tokens
    address public immutable crv;
    address public immutable cvx;
    address public immutable cvxCrv;

    address public keeper;
    address public crvDepositorWrapper;
    uint256 public outputBps;
    uint256 public constant denominator = 10000;

    address public rewards;

    address public owner;
    address public pendingOwner;
    uint256 public callIncentive = 25;

    event RewardsDistributed(address indexed token, uint256 amount);
    event CallIncentiveChanged(uint256 incentive);

    /* ========== CONSTRUCTOR ========== */

    /**
     * @param _rewards       vlCVX
     * @param _crv           CRV token
     * @param _cvx           CVX token
     * @param _cvxCrv        cvxCRV token
     * @param _crvDepositorWrapper    Wrapper that converts CRV to CRVBPT and deposits
     * @param _outputBps     Configurable output bps where 100% == 10000
     */
    constructor(
        address _rewards,
        address _crv,
        address _cvx,
        address _cvxCrv,
        address _crvDepositorWrapper,
        uint256 _outputBps
    ) {
        rewards = _rewards;
        owner = msg.sender;
        crv = _crv;
        cvx = _cvx;
        cvxCrv = _cvxCrv;
        crvDepositorWrapper = _crvDepositorWrapper;
        outputBps = _outputBps;
    }

    /**
     * @notice Set CrvDepositorWrapper
     * @param   _crvDepositorWrapper CrvDepositorWrapper address
     * @param   _outputBps Min output base points
     */
    function setCrvDepositorWrapper(address _crvDepositorWrapper, uint256 _outputBps) external {
        require(msg.sender == owner, ""!auth"");
        require(_outputBps > 9000 && _outputBps < 10000, ""Invalid output bps"");

        crvDepositorWrapper = _crvDepositorWrapper;
        outputBps = _outputBps;
    }

    /**
     * @notice Set keeper
     */
    function setKeeper(address _keeper) external {
        require(msg.sender == owner, ""!auth"");
        keeper = _keeper;
    }

    /**
     * @notice Set pending owner
     */
    function setPendingOwner(address _po) external {
        require(msg.sender == owner, ""!auth"");
        pendingOwner = _po;
    }

    /**
     * @notice Apply pending owner
     */
    function applyPendingOwner() external {
        require(msg.sender == owner, ""!auth"");
        require(pendingOwner != address(0), ""invalid owner"");

        owner = pendingOwner;
        pendingOwner = address(0);
    }

    /**
     * @notice Set call incentive
     * @param _incentive Incentive base points
     */
    function setCallIncentive(uint256 _incentive) external {
        require(msg.sender == owner, ""!auth"");
        require(_incentive <= 100, ""too high"");
        callIncentive = _incentive;
        emit CallIncentiveChanged(_incentive);
    }

    /**
     * @notice Set reward address
     */
    function setRewards(address _rewards) external {
        require(msg.sender == owner, ""!auth"");
        rewards = _rewards;
    }

    /**
     * @notice  Approve crvDepositorWrapper to transfer contract CRV
     *          and rewards to transfer cvxCrv
     */
    function setApprovals() external {
        IERC20(crv).safeApprove(crvDepositorWrapper, 0);
        IERC20(crv).safeApprove(crvDepositorWrapper, type(uint256).max);

        IERC20(cvxCrv).safeApprove(rewards, 0);
        IERC20(cvxCrv).safeApprove(rewards, type(uint256).max);
    }

    /**
     * @notice Transfer stuck ERC20 tokens to `_to`
     */
    function rescueToken(address _token, address _to) external {
        require(msg.sender == owner, ""!auth"");
        require(_token != crv && _token != cvx && _token != cvxCrv, ""not allowed"");

        uint256 bal = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransfer(_to, bal);
    }

    /**
     * @dev Collects cvxCRV rewards from cvxRewardPool, converts any CRV deposited directly from
     *      the booster, and then applies the rewards to the cvxLocker, rewarding the caller in the process.
     */
    function distribute() external {
        // If keeper enabled, require
        if (keeper != address(0)) {
            require(msg.sender == keeper, ""!auth"");
        }

        //convert crv to cvxCrv
        uint256 crvBal = IERC20(crv).balanceOf(address(this));
        if (crvBal > 0) {
            uint256 minOut = ICrvDepositorWrapper(crvDepositorWrapper).getMinOut(crvBal, outputBps);
            ICrvDepositorWrapper(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));
        }

        //distribute cvxcrv
        uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));

        if (cvxCrvBal > 0) {
            uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);
            cvxCrvBal = cvxCrvBal.sub(incentiveAmount);

            //send incentives
            IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);

            //update rewards
            IAuraLocker(rewards).queueNewRewards(cvxCrvBal);

            emit RewardsDistributed(cvxCrv, cvxCrvBal);
        }
    }

    /**
     * @notice Allow generic token distribution in case a new reward is ever added
     */
    function distributeOther(IERC20 _token) external {
        require(address(_token) != crv && address(_token) != cvxCrv, ""not allowed"");

        uint256 bal = _token.balanceOf(address(this));

        if (bal > 0) {
            uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);
            bal = bal.sub(incentiveAmount);

            //send incentives
            _token.safeTransfer(msg.sender, incentiveAmount);

            //approve
            _token.safeApprove(rewards, 0);
            _token.safeApprove(rewards, type(uint256).max);

            //update rewards
            IAuraLocker(rewards).notifyRewardAmount(address(_token), bal);

            emit RewardsDistributed(address(_token), bal);
        }
    }
}",1758
RealWorld_TA_123_IGaugeController_RealWorld_20240816000745.log,123,IGaugeController,26180,2044,28224,100.0,0.17178,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IGaugeController {
    function get_gauge_weight(address _gauge) external view returns(uint256);
    function vote_user_slopes(address,address) external view returns(uint256,uint256,uint256);//slope,power,end
    function vote_for_gauge_weights(address,uint256) external;
    function add_gauge(address,int128,uint256) external;
}",90
RealWorld_TA_123_ExtraRewardsDistributor_RealWorld_20240816002025.log,123,ExtraRewardsDistributor,218315,4355,222670,143.0,1.178675,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   ExtraRewardsDistributor
 * @author  adapted from ConvexFinance
 * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.
 */
contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    // token -> epoch -> amount
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    // token -> epochList
    mapping(address => uint256[]) public rewardEpochs;
    // token -> account -> last claimed epoch index
    mapping(address => mapping(address => uint256)) public userClaims;

    /* ========== EVENTS ========== */

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    /**
     * @dev Simple constructoor
     * @param _auraLocker Aura Locker address
     */
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    /* ========== ADD REWARDS ========== */

    /**
     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokenπ
     */
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    /**
     * @notice Add reward token to a specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens to add
     * @param _epoch    Which epoch to add to (must be less than the previous epoch)
     */
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    /**
     * @notice  Transfer reward tokens from sender to contract for vlCVX holders
     * @dev     Add reward token for specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens
     * @param _epoch    Epoch to add tokens to
     */
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }

    /* ========== GET REWARDS ========== */

    /**
     * @notice Claim rewards for a specific token since the first epoch.
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account      Address of vlCVX holder
     * @param _token        Reward token address
     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from
     */
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        //get claimable tokens
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            //set claim checkpoint
            userClaims[_token][_account] = index;

            //send
            IERC20(_token).safeTransfer(_account, claimableTokens);

            //event
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    /**
     * @notice  Allow a user to set their claimed index forward without claiming rewards
     *          Because claims cycle through all periods that a specific reward was given
     *          there becomes a situation where, for example, a new user could lock
     *          2 years from now and try to claim a token that was given out every week prior.
     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)
     * @param _token  Reward token to forfeit
     * @param _index  Epoch index to forfeit from
     */
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        //set claim checkpoint. next claim starts from index+1
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    /* ========== VIEW REWARDS ========== */

    /**
     * @notice Get claimable rewards (rewardToken) for vlCVX holder
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    /**
     * @notice  Get all claimable rewards by looping through each epoch starting with the latest
     *          saved epoch the user last claimed from
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        // e.g. tokenEpochs = 31, 21
        uint256 tokenEpochs = rewardEpochs[_token].length;

        // e.g. epochIndex = 0
        uint256 epochIndex = userClaims[_token][_account];
        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            //only claimable after rewards are ""locked in""
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                //return index user claims should be set to
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        //get balance and calc share
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    /**
     * @notice Simply gets the current epoch count for a given reward token
     * @param _token    Reward token address
     * @return _epochs  Number of epochs
     */
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",2365
RealWorld_TA_123_MockVoting_RealWorld_20240816005920.log,123,MockVoting,43970,2854,46824,109.0,0.27693,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

contract MockVoting {
    mapping(address => uint256) public gaugeWeights;

    mapping(uint256 => uint256) public votesFor;

    mapping(uint256 => uint256) public votesAgainst;

    struct VotedSlope {
        uint256 slope;
        uint256 power;
        uint256 end;
    }

    function vote(
        uint256 voteId,
        bool support,
        bool
    ) external {
        if (support) {
            votesFor[voteId]++;
        } else {
            votesAgainst[voteId]++;
        }
    }

    function vote_for_gauge_weights(address gauge, uint256 weight) external {
        gaugeWeights[gauge] += weight;
    }

    function get_gauge_weight(address gauge) external view returns (uint256) {
        return gaugeWeights[gauge];
    }

    function vote_user_slopes(address user, address gauge) external view returns (VotedSlope memory) {
        return VotedSlope(0, 0, 0);
    }

    // Total vote power used by user
    function vote_user_power(address user) external view returns (uint256) {
        return 0;
    }

    // Last user vote's timestamp for each gauge address
    function last_user_vote(address user, address gauge) external view returns (uint256) {
        return 0;
    }
}",294
RealWorld_TA_123_MathUtil_RealWorld_20240816000928.log,123,MathUtil,25128,1247,26375,91.0,0.15058,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library MathUtil {
    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}",82
RealWorld_TA_123_MockWeightedPool2TokensFactory_RealWorld_20240816011548.log,123,MockWeightedPool2TokensFactory,26406,1966,28372,102.0,0.17135,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

interface IWeightedPool2TokensFactory {
    function create(
        string memory name,
        string memory symbol,
        IERC20[] memory tokens,
        uint256[] memory weights,
        uint256 swapFeePercentage,
        bool oracleEnabled,
        address owner
    ) external returns (address);
}",99
RealWorld_TA_123_Interfaces_RealWorld_20240816000245.log,123,Interfaces,126287,2608,128895,115.0,0.683595,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;



interface ICurveGauge {
    function deposit(uint256) external;
    function balanceOf(address) external view returns (uint256);
    function withdraw(uint256) external;
    function claim_rewards() external;
    function reward_tokens(uint256) external view returns(address);//v2
    function rewarded_token() external view returns(address);//v1
    function lp_token() external view returns(address);
}

interface ICurveVoteEscrow {
    function create_lock(uint256, uint256) external;
    function increase_amount(uint256) external;
    function increase_unlock_time(uint256) external;
    function withdraw() external;
    function smart_wallet_checker() external view returns (address);
    function commit_smart_wallet_checker(address) external;
    function apply_smart_wallet_checker() external;
}

interface IWalletChecker {
    function check(address) external view returns (bool);
    function approveWallet(address) external;
    function dao() external view returns (address);
}

interface IVoting{
    function vote(uint256, bool, bool) external; //voteId, support, executeIfDecided
    function getVote(uint256) external view returns(bool,bool,uint64,uint64,uint64,uint64,uint256,uint256,uint256,bytes memory); 
    function vote_for_gauge_weights(address,uint256) external;
}

interface IMinter{
    function mint(address) external;
}

interface IStaker{
    function deposit(address, address) external returns (bool);
    function withdraw(address) external returns (uint256);
    function withdraw(address, address, uint256) external returns (bool);
    function withdrawAll(address, address) external returns (bool);
    function createLock(uint256, uint256) external returns(bool);
    function increaseAmount(uint256) external returns(bool);
    function increaseTime(uint256) external returns(bool);
    function release() external returns(bool);
    function claimCrv(address) external returns (uint256);
    function claimRewards(address) external returns(bool);
    function claimFees(address,address) external returns (uint256);
    function setStashAccess(address, bool) external returns (bool);
    function vote(uint256,address,bool) external returns(bool);
    function voteGaugeWeight(address,uint256) external returns(bool);
    function balanceOfPool(address) external view returns (uint256);
    function operator() external view returns (address);
    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);
    function setVote(bytes32 hash, bool valid) external;
    function migrate(address to) external;
}

interface IRewards{
    function stake(address, uint256) external;
    function stakeFor(address, uint256) external;
    function withdraw(address, uint256) external;
    function exit(address) external;
    function getReward(address) external;
    function queueNewRewards(uint256) external;
    function notifyRewardAmount(uint256) external;
    function addExtraReward(address) external;
    function stakingToken() external view returns (address);
    function rewardToken() external view returns(address);
    function earned(address account) external view returns (uint256);
}

interface IStash{
    function stashRewards() external returns (bool);
    function processStash() external returns (bool);
    function claimRewards() external returns (bool);
    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rewardFactory) external;
}

interface IFeeDistributor {
    function claimToken(address user, address token) external returns (uint256);
    function claimTokens(address user, address[] calldata tokens) external returns (uint256[] memory);
    function getTokenTimeCursor(address token) external view returns (uint256);
}

interface ITokenMinter{
    function mint(address,uint256) external;
    function burn(address,uint256) external;
}

interface IDeposit{
    function isShutdown() external view returns(bool);
    function balanceOf(address _account) external view returns(uint256);
    function totalSupply() external view returns(uint256);
    function poolInfo(uint256) external view returns(address,address,address,address,address, bool);
    function rewardClaimed(uint256,address,uint256) external;
    function withdrawTo(uint256,uint256,address) external;
    function claimRewards(uint256,address) external returns(bool);
    function rewardArbitrator() external returns(address);
    function setGaugeRedirect(uint256 _pid) external returns(bool);
    function owner() external returns(address);
    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns(bool);
}

interface ICrvDeposit{
    function deposit(uint256, bool) external;
    function lockIncentive() external view returns(uint256);
}

interface IRewardFactory{
    function setAccess(address,bool) external;
    function CreateCrvRewards(uint256,address,address) external returns(address);
    function CreateTokenRewards(address,address,address) external returns(address);
    function activeRewardCount(address) external view returns(uint256);
    function addActiveReward(address,uint256) external returns(bool);
    function removeActiveReward(address,uint256) external returns(bool);
}

interface IStashFactory{
    function CreateStash(uint256,address,address,uint256) external returns(address);
}

interface ITokenFactory{
    function CreateDepositToken(address) external returns(address);
}

interface IPools{
    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);
    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);
    function shutdownPool(uint256 _pid) external returns(bool);
    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);
    function poolLength() external view returns (uint256);
    function gaugeMap(address) external view returns(bool);
    function setPoolManager(address _poolM) external;
}

interface IVestedEscrow{
    function fund(address[] calldata _recipient, uint256[] calldata _amount) external returns(bool);
}

interface IRewardDeposit {
    function addReward(address, uint256) external;
}",1286
RealWorld_TA_123_Interfaces_RealWorld_20240816004858.log,123,Interfaces,82663,1787,84450,93.0,0.449055,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;
pragma abicoder v2;

interface IPriceOracle {
    struct OracleAverageQuery {
        Variable variable;
        uint256 secs;
        uint256 ago;
    }
    enum Variable {
        PAIR_PRICE,
        BPT_PRICE,
        INVARIANT
    }

    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)
        external
        view
        returns (uint256[] memory results);
}

interface IVault {
    enum PoolSpecialization {
        GENERAL,
        MINIMAL_SWAP_INFO,
        TWO_TOKEN
    }
    enum JoinKind {
        INIT,
        EXACT_TOKENS_IN_FOR_BPT_OUT,
        TOKEN_IN_FOR_EXACT_BPT_OUT,
        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT
    }

    enum SwapKind {
        GIVEN_IN,
        GIVEN_OUT
    }

    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        IAsset assetIn;
        IAsset assetOut;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);

    function getPoolTokens(bytes32 poolId)
        external
        view
        returns (
            address[] memory tokens,
            uint256[] memory balances,
            uint256 lastChangeBlock
        );

    function joinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        JoinPoolRequest memory request
    ) external payable;

    function swap(
        SingleSwap memory singleSwap,
        FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external returns (uint256 amountCalculated);

    function exitPool(
        bytes32 poolId,
        address sender,
        address payable recipient,
        ExitPoolRequest memory request
    ) external;

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }
    enum ExitKind {
        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
        EXACT_BPT_IN_FOR_TOKENS_OUT,
        BPT_IN_FOR_EXACT_TOKENS_OUT,
        MANAGEMENT_FEE_TOKENS_OUT // for ManagedPool
    }
}

interface IAsset {
    // solhint-disable-previous-line no-empty-blocks
}

interface IAuraLocker {
    function lock(address _account, uint256 _amount) external;

    function checkpointEpoch() external;

    function epochCount() external view returns (uint256);

    function balanceAtEpochOf(uint256 _epoch, address _user) external view returns (uint256 amount);

    function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply);

    function queueNewRewards(uint256 _rewards) external;

    function notifyRewardAmount(address _rewardsToken, uint256 reward) external;

    function getReward(address _account, bool _stake) external;

    function getReward(address _account) external;
}

interface IExtraRewardsDistributor {
    function addReward(address _token, uint256 _amount) external;
}

interface ICrvDepositorWrapper {
    function getMinOut(uint256, uint256) external view returns (uint256);

    function deposit(
        uint256,
        uint256,
        bool,
        address _stakeAddress
    ) external;
}",761
RealWorld_TA_123_BoosterOwner_RealWorld_20240815233904.log,123,BoosterOwner,172287,4112,176399,136.0,0.943675,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;


interface IOwner {
    //booster
    function setFactories(address _rfactory, address _sfactory, address _tfactory) external;
    function setArbitrator(address _arb) external;
    function setFeeInfo(address _feeToken, address _feeDistro) external;
    function updateFeeInfo(address _feeToken, bool _active) external;
    function shutdownSystem() external;
    function isShutdown() external view returns(bool);
    function poolLength() external view returns(uint256);
    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);
    function setVoteDelegate(address _voteDelegate) external;
    function setFeeManager(address _feeM) external;
    function setOwner(address _owner) external;

    //rescue
    function setDistribution(address _distributor, address _rewardDeposit, address _treasury) external;
    function setExtraReward(address _token, uint256 _option) external;

    //stash
    function setExtraReward(address _token) external;
    function setRewardHook(address _hook) external;

    //stash factory
    function setImplementation(address _v1, address _v2, address _v3) external;

    //vote extension
    function revertControl() external;
}

/**
 * @title   Booster
 * @author  ConvexFinance
 * @notice  Immutable booster owner that requires all pools to be shutdown before shutting down the entire convex system
 * @dev     A timelock is required if forcing a shutdown if there is a bugged pool that can not be withdrawn from.
 *          Allow arbitrary calls to other contracts, but limit how calls are made to Booster.
 */
contract BoosterOwner{

    address public immutable poolManager;
    address public immutable booster;
    address public immutable stashFactory;
    address public immutable rescueStash;
    address public owner;
    address public pendingowner;
    bool public isSealed;

    uint256 public constant FORCE_DELAY = 30 days;

    bool public isForceTimerStarted;
    uint256 public forceTimestamp;

    event ShutdownStarted(uint256 executableTimestamp);
    event ShutdownExecuted();
    event TransferOwnership(address pendingOwner);
    event AcceptedOwnership(address newOwner);
    event OwnershipSealed();

    /**
     * @param _owner         Owner (e.g. CVX multisig)
     * @param _poolManager   PoolManager (e.g. PoolManagerSecondaryProxy or 0xD20904e5916113D11414F083229e9C8C6F91D1e1)
     * @param _booster       The booster (e.g. 0xF403C135812408BFbE8713b5A23a04b3D48AAE31)
     * @param _stashFactory  Creates stashes (e.g. 0x884da067B66677e72530df91eabb6e3CE69c2bE4)
     * @param _rescueStash   Rescues tokens for subsequent vlCVX redistribution (e.g. 0x01140351069af98416cC08b16424b9E765436531)
     */
    constructor(
        address _owner,
        address _poolManager,
        address _booster,
        address _stashFactory,
        address _rescueStash,
        bool _seal
    ) public {
        owner = _owner;
        poolManager = _poolManager;
        booster = _booster;
        stashFactory = _stashFactory;
        rescueStash = _rescueStash;
        isSealed = _seal;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""!owner"");
        _;
    }

    function transferOwnership(address _owner) external onlyOwner{
        pendingowner = _owner;
        emit TransferOwnership(_owner);
    }

    function acceptOwnership() external {
        require(pendingowner == msg.sender, ""!pendingowner"");
        owner = pendingowner;
        pendingowner = address(0);
        emit AcceptedOwnership(owner);
    }

    function sealOwnership() external onlyOwner{
        isSealed = true;
        emit OwnershipSealed();
    }

    function setBoosterOwner() external onlyOwner{
        //allow reverting ownership until sealed
        require(!isSealed, ""ownership sealed"");

        //transfer booster ownership to this owner
        IOwner(booster).setOwner(owner);
    }

    function setFactories(address _rfactory, address _sfactory, address _tfactory) external onlyOwner{
        IOwner(booster).setFactories(_rfactory, _sfactory, _tfactory);
    }

    function setArbitrator(address _arb) external onlyOwner{
        IOwner(booster).setArbitrator(_arb);
    }

    function setFeeInfo(address _feeToken, address _feeDistro) external onlyOwner{
        IOwner(booster).setFeeInfo(_feeToken, _feeDistro);
    }

    function updateFeeInfo(address _feeToken, bool _active) external onlyOwner{
        IOwner(booster).updateFeeInfo(_feeToken, _active);
    }

    function setFeeManager(address _feeM) external onlyOwner{
        IOwner(booster).setFeeManager(_feeM);
    }

    function setVoteDelegate(address _voteDelegate) external onlyOwner{
        IOwner(booster).setVoteDelegate(_voteDelegate);
    }

    function shutdownSystem() external onlyOwner{
        require(IOwner(poolManager).isShutdown(),""!poolMgrShutdown"");

        //check that all pools are already shutdown
        uint256 poolCount = IOwner(booster).poolLength();
        for(uint256 i = 0; i < poolCount; i++){
            (,,,,,bool isshutdown) = IOwner(booster).poolInfo(i);
            require(isshutdown, ""!poolShutdown"");
        }

        //complete the shutdown process
        IOwner(booster).shutdownSystem();
        emit ShutdownExecuted();
    }


    //queue a forced shutdown that does not require pools to already be shutdown
    //this should only be needed if a pool is broken and withdrawAll() does not
    //correctly return enough lp tokens
    function queueForceShutdown() external onlyOwner{
        require(IOwner(poolManager).isShutdown(),""!poolMgrShutdown"");
        require(!isForceTimerStarted, ""already started"");
    
        isForceTimerStarted = true;
        forceTimestamp = block.timestamp + FORCE_DELAY;

        emit ShutdownStarted(forceTimestamp);
    }

    //force shutdown the system after timer has expired
    function forceShutdownSystem() external onlyOwner{
        require(isForceTimerStarted, ""!timer start"");
        require(block.timestamp > forceTimestamp, ""!timer finish"");

        IOwner(booster).shutdownSystem();
        emit ShutdownExecuted();
    }


    //allow arbitrary calls to any contract other than the booster, as some contracts
    //may use ownership as booster.owner() instead of local variable
    function execute(
        address _to,
        uint256 _value,
        bytes calldata _data
    ) external onlyOwner returns (bool, bytes memory) {
        require(_to != booster, ""!invalid target"");

        (bool success, bytes memory result) = _to.call{value:_value}(_data);

        return (success, result);
    }


    // --- Helper functions for other systems, could also just use execute() ---

    //TokenRescue setDistribution
    function setRescueTokenDistribution(address _distributor, address _rewardDeposit, address _treasury) external onlyOwner{
        IOwner(rescueStash).setDistribution(_distributor, _rewardDeposit, _treasury);
    }

    //TokenRescue setExtraReward
    function setRescueTokenReward(address _token, uint256 _option) external onlyOwner{
        IOwner(rescueStash).setExtraReward(_token, _option);
    }

    //stash v3 - set extra reward
    function setStashExtraReward(address _stash, address _token) external onlyOwner{
        IOwner(_stash).setExtraReward(_token);
    }

    //stash v3 - set reward hook
    function setStashRewardHook(address _stash, address _hook) external onlyOwner{
        IOwner(_stash).setRewardHook(_hook);
    }

    //stash factory - set implementation
    function setStashFactoryImplementation(address _v1, address _v2, address _v3) external onlyOwner{
        IOwner(stashFactory).setImplementation(_v1, _v2, _v3);
    }
}",1822
RealWorld_TA_123_ClaimFeesHelper_RealWorld_20240816004000.log,123,ClaimFeesHelper,66251,4510,70761,126.0,0.421455,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { IFeeDistributor } from ""./mocks/balancer/MockFeeDistro.sol"";

interface IBooster {
    function earmarkFees(address _feeDistro) external returns (bool);
}

/**
 * @title   ClaimFeesHelper
 * @author  ConvexFinance
 * @notice  Claim vecrv fees and distribute
 * @dev     Allows anyone to call `claimFees` that will basically collect any 3crv and distribute to cvxCrv
 *          via the booster.
 */
contract ClaimFeesHelper {
    IBooster public immutable booster;
    address public immutable voterProxy;

    mapping(address => uint256) public lastTokenTimes;
    IFeeDistributor public feeDistro;

    /**
     * @param _booster      Booster.sol, e.g. 0xF403C135812408BFbE8713b5A23a04b3D48AAE31
     * @param _voterProxy   CVX VoterProxy e.g. 0x989AEb4d175e16225E39E87d0D97A3360524AD80
     * @param _feeDistro    FeeDistro e.g. 0xA464e6DCda8AC41e03616F95f4BC98a13b8922Dc
     */
    constructor(
        address _booster,
        address _voterProxy,
        address _feeDistro
    ) {
        booster = IBooster(_booster);
        voterProxy = _voterProxy;
        feeDistro = IFeeDistributor(_feeDistro);
    }

    /**
     * @dev Claims fees from fee claimer, and pings the booster to distribute
     */
    function claimFees(IERC20 _token) external {
        uint256 tokenTime = feeDistro.getTokenTimeCursor(_token);
        require(tokenTime > lastTokenTimes[address(_token)], ""not time yet"");

        uint256 bal = IERC20(_token).balanceOf(voterProxy);
        feeDistro.claimToken(voterProxy, _token);

        // Loop through until something is transferred
        while (IERC20(_token).balanceOf(voterProxy) <= bal) {
            feeDistro.claimToken(voterProxy, _token);
        }

        booster.earmarkFees(address(_token));
        lastTokenTimes[address(_token)] = tokenTime;
    }
}",558
RealWorld_TA_123_AuraVestedEscrow_RealWorld_20240816003742.log,123,AuraVestedEscrow,136810,4391,141201,135.0,0.77187,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath } from ""./AuraMath.sol"";

/**
 * @title   AuraVestedEscrow
 * @author  adapted from ConvexFinance (convex-platform/contracts/contracts/VestedEscrow)
 * @notice  Vests tokens over a given timeframe to an array of recipients. Allows locking of
 *          these tokens directly to staking contract.
 * @dev     Adaptations:
 *           - One time initialisation
 *           - Consolidation of fundAdmin/admin
 *           - Lock in AuraLocker by default
 *           - Start and end time
 */
contract AuraVestedEscrow is ReentrancyGuard {
    using SafeERC20 for IERC20;

    IERC20 public immutable rewardToken;

    address public admin;
    IAuraLocker public auraLocker;

    uint256 public immutable startTime;
    uint256 public immutable endTime;
    uint256 public immutable totalTime;

    bool public initialised = false;

    mapping(address => uint256) public totalLocked;
    mapping(address => uint256) public totalClaimed;

    event Funded(address indexed recipient, uint256 reward);
    event Cancelled(address indexed recipient);
    event Claim(address indexed user, uint256 amount, bool locked);

    /**
     * @param rewardToken_    Reward token (AURA)
     * @param admin_          Admin to cancel rewards
     * @param auraLocker_     Contract where rewardToken can be staked
     * @param starttime_      Timestamp when claim starts
     * @param endtime_        When vesting ends
     */
    constructor(
        address rewardToken_,
        address admin_,
        address auraLocker_,
        uint256 starttime_,
        uint256 endtime_
    ) {
        require(starttime_ >= block.timestamp, ""start must be future"");
        require(endtime_ > starttime_, ""end must be greater"");

        rewardToken = IERC20(rewardToken_);
        admin = admin_;
        auraLocker = IAuraLocker(auraLocker_);

        startTime = starttime_;
        endTime = endtime_;
        totalTime = endTime - startTime;
        require(totalTime >= 16 weeks, ""!short"");
    }

    /***************************************
                    SETUP
    ****************************************/

    /**
     * @notice Change contract admin
     * @param _admin New admin address
     */
    function setAdmin(address _admin) external {
        require(msg.sender == admin, ""!auth"");
        admin = _admin;
    }

    /**
     * @notice Change locker contract address
     * @param _auraLocker Aura Locker address
     */
    function setLocker(address _auraLocker) external {
        require(msg.sender == admin, ""!auth"");
        auraLocker = IAuraLocker(_auraLocker);
    }

    /**
     * @notice Fund recipients with rewardTokens
     * @param _recipient  Array of recipients to vest rewardTokens for
     * @param _amount     Arrary of amount of rewardTokens to vest
     */
    function fund(address[] calldata _recipient, uint256[] calldata _amount) external nonReentrant {
        require(!initialised, ""initialised already"");

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < _recipient.length; i++) {
            uint256 amount = _amount[i];

            totalLocked[_recipient[i]] += amount;
            totalAmount += amount;

            emit Funded(_recipient[i], amount);
        }
        rewardToken.safeTransferFrom(msg.sender, address(this), totalAmount);
        initialised = true;
    }

    /**
     * @notice Cancel recipients vesting rewardTokens
     * @param _recipient Recipient address
     */
    function cancel(address _recipient) external nonReentrant {
        require(msg.sender == admin, ""!auth"");
        require(totalLocked[_recipient] > 0, ""!funding"");

        _claim(_recipient, false);

        uint256 delta = remaining(_recipient);
        rewardToken.safeTransfer(admin, delta);

        totalLocked[_recipient] = 0;

        emit Cancelled(_recipient);
    }

    /***************************************
                    VIEWS
    ****************************************/

    /**
     * @notice Available amount to claim
     * @param _recipient Recipient to lookup
     */
    function available(address _recipient) public view returns (uint256) {
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);
        return vested - totalClaimed[_recipient];
    }

    /**
     * @notice Total remaining vested amount
     * @param _recipient Recipient to lookup
     */
    function remaining(address _recipient) public view returns (uint256) {
        uint256 vested = _totalVestedOf(_recipient, block.timestamp);
        return totalLocked[_recipient] - vested;
    }

    /**
     * @notice Get total amount vested for this timestamp
     * @param _recipient  Recipient to lookup
     * @param _time       Timestamp to check vesting amount for
     */
    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256 total) {
        if (_time < startTime) {
            return 0;
        }
        uint256 locked = totalLocked[_recipient];
        uint256 elapsed = _time - startTime;
        total = AuraMath.min((locked * elapsed) / totalTime, locked);
    }

    /***************************************
                    CLAIM
    ****************************************/

    function claim(bool _lock) external nonReentrant {
        _claim(msg.sender, _lock);
    }

    /**
     * @dev Claim reward token (Aura) and lock it.
     * @param _recipient  Address to receive rewards.
     * @param _lock       Lock rewards immediately.
     */
    function _claim(address _recipient, bool _lock) internal {
        uint256 claimable = available(_recipient);

        totalClaimed[_recipient] += claimable;

        if (_lock) {
            require(address(auraLocker) != address(0), ""!auraLocker"");
            rewardToken.safeApprove(address(auraLocker), claimable);
            auraLocker.lock(_recipient, claimable);
        } else {
            rewardToken.safeTransfer(_recipient, claimable);
        }

        emit Claim(_recipient, claimable, _lock);
    }
}",1393
RealWorld_TA_123_Booster_RealWorld_20240815232917.log,123,Booster,516080,7709,523789,212.0,2.73458,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./Interfaces.sol"";
import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Address.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

/**
 * @title   Booster
 * @author  ConvexFinance
 * @notice  Main deposit contract; keeps track of pool info & user deposits; distributes rewards.
 * @dev     They say all paths lead to Rome, and the cvxBooster is no different. This is where it all goes down.
 *          It is responsible for tracking all the pools, it collects rewards from all pools and redirects it.
 */
contract Booster{
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public immutable crv;
    address public immutable voteOwnership;
    address public immutable voteParameter;

    uint256 public lockIncentive = 825; //incentive to crv stakers
    uint256 public stakerIncentive = 825; //incentive to native token stakers
    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls
    uint256 public platformFee = 0; //possible fee to build treasury
    uint256 public constant MaxFees = 2500;
    uint256 public constant FEE_DENOMINATOR = 10000;

    address public owner;
    address public feeManager;
    address public poolManager;
    address public immutable staker;
    address public immutable minter;
    address public rewardFactory;
    address public stashFactory;
    address public tokenFactory;
    address public rewardArbitrator;
    address public voteDelegate;
    address public treasury;
    address public stakerRewards; //cvx rewards
    address public lockRewards; //cvxCrv rewards(crv)

    mapping(address => FeeDistro) public feeTokens;
    struct FeeDistro {
        address distro;
        address rewards;
        bool active;
    }

    bool public isShutdown;

    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    //index(pid) -> pool
    PoolInfo[] public poolInfo;
    mapping(address => bool) public gaugeMap;

    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);
    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);

    event PoolAdded(address lpToken, address gauge, address token, address rewardPool, address stash, uint256 pid);
    event PoolShutdown(uint256 poolId);

    event OwnerUpdated(address newOwner);
    event FeeManagerUpdated(address newFeeManager);
    event PoolManagerUpdated(address newPoolManager);
    event FactoriesUpdated(address rewardFactory, address stashFactory, address tokenFactory);
    event ArbitratorUpdated(address newArbitrator);
    event VoteDelegateUpdated(address newVoteDelegate);
    event RewardContractsUpdated(address lockRewards, address stakerRewards);
    event FeesUpdated(uint256 lockIncentive, uint256 stakerIncentive, uint256 earmarkIncentive, uint256 platformFee);
    event TreasuryUpdated(address newTreasury);
    event FeeInfoUpdated(address feeDistro, address lockFees, address feeToken);
    event FeeInfoChanged(address feeDistro, bool active);

    /**
     * @dev Constructor doing what constructors do. It is noteworthy that
     *      a lot of basic config is set to 0 - expecting subsequent calls to setFeeInfo etc.
     * @param _staker                 VoterProxy (locks the crv and adds to all gauges)
     * @param _minter                 CVX token, or the thing that mints it
     * @param _crv                    CRV
     * @param _voteOwnership          Address of the Curve DAO responsible for ownership stuff
     * @param _voteParameter          Address of the Curve DAO responsible for param updates
     */
    constructor(
        address _staker,
        address _minter,
        address _crv,
        address _voteOwnership,
        address _voteParameter
    ) public {
        staker = _staker;
        minter = _minter;
        crv = _crv;
        voteOwnership = _voteOwnership;
        voteParameter = _voteParameter;
        isShutdown = false;

        owner = msg.sender;
        voteDelegate = msg.sender;
        feeManager = msg.sender;
        poolManager = msg.sender;
        treasury = address(0);

        emit OwnerUpdated(msg.sender);
        emit VoteDelegateUpdated(msg.sender);
        emit FeeManagerUpdated(msg.sender);
        emit PoolManagerUpdated(msg.sender);
    }


    /// SETTER SECTION ///

    /**
     * @notice Owner is responsible for setting initial config, updating vote delegate and shutting system
     */
    function setOwner(address _owner) external {
        require(msg.sender == owner, ""!auth"");
        owner = _owner;

        emit OwnerUpdated(_owner);
    }

    /**
     * @notice Fee Manager can update the fees (lockIncentive, stakeIncentive, earmarkIncentive, platformFee)
     */
    function setFeeManager(address _feeM) external {
        require(msg.sender == feeManager, ""!auth"");
        feeManager = _feeM;

        emit FeeManagerUpdated(_feeM);
    }

    /**
     * @notice Pool manager is responsible for adding new pools
     */
    function setPoolManager(address _poolM) external {
        require(msg.sender == poolManager, ""!auth"");
        poolManager = _poolM;

        emit PoolManagerUpdated(_poolM);
    }

    /**
     * @notice Factories are used when deploying new pools. Only the stash factory is mutable after init
     */
    function setFactories(address _rfactory, address _sfactory, address _tfactory) external {
        require(msg.sender == owner, ""!auth"");

        //stash factory should be considered more safe to change
        //updating may be required to handle new types of gauges
        stashFactory = _sfactory;

        //reward factory only allow this to be called once even if owner
        //removes ability to inject malicious staking contracts
        //token factory can also be immutable
        if(rewardFactory == address(0)){
            rewardFactory = _rfactory;
            tokenFactory = _tfactory;

            emit FactoriesUpdated(_rfactory, _sfactory, _tfactory);
        } else {
            emit FactoriesUpdated(address(0), _sfactory, address(0));
        }
    }

    /**
     * @notice Arbitrator handles tokens that are used as secondary rewards across multiple pools
     */
    function setArbitrator(address _arb) external {
        require(msg.sender==owner, ""!auth"");
        rewardArbitrator = _arb;

        emit ArbitratorUpdated(_arb);
    }

    /**
     * @notice Vote Delegate has the rights to cast votes on the VoterProxy via the Booster
     */
    function setVoteDelegate(address _voteDelegate) external {
        require(msg.sender==voteDelegate, ""!auth"");
        voteDelegate = _voteDelegate;

        emit VoteDelegateUpdated(_voteDelegate);
    }

    /**
     * @notice Only called once, to set the addresses of cvxCrv (lockRewards) and cvx staking (stakerRewards)
     */
    function setRewardContracts(address _rewards, address _stakerRewards) external {
        require(msg.sender == owner, ""!auth"");
        
        //reward contracts are immutable or else the owner
        //has a means to redeploy and mint cvx via rewardClaimed()
        if(lockRewards == address(0)){
            lockRewards = _rewards;
            stakerRewards = _stakerRewards;
            emit RewardContractsUpdated(_rewards, _stakerRewards);
        }
    }

    /**
     * @notice Set reward token and claim contract
     * @dev    This creates a secondary (VirtualRewardsPool) rewards contract for the vcxCrv staking contract
     */
    function setFeeInfo(address _feeToken, address _feeDistro) external {
        require(msg.sender == owner, ""!auth"");
        require(!isShutdown, ""shutdown"");
        require(lockRewards != address(0) && rewardFactory != address(0), ""!initialised"");

        require(_feeToken != address(0) && _feeDistro != address(0), ""!addresses"");
        require(IFeeDistributor(_feeDistro).getTokenTimeCursor(_feeToken) > 0, ""!distro"");

        if(feeTokens[_feeToken].distro == address(0)){
            require(!gaugeMap[_feeToken], ""!token"");

            // Distributed directly
            if(_feeToken == crv){
                feeTokens[crv] = FeeDistro({
                    distro: _feeDistro,
                    rewards: lockRewards,
                    active: true
                });
                emit FeeInfoUpdated(_feeDistro, lockRewards, crv);
            } else {
                //create a new reward contract for the new token
                address rewards = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken, lockRewards, address(this));
                feeTokens[_feeToken] = FeeDistro({
                    distro: _feeDistro,
                    rewards: rewards,
                    active: true
                });
                emit FeeInfoUpdated(_feeDistro, rewards, _feeToken);
            }
        } else {
            feeTokens[_feeToken].distro = _feeDistro;
            emit FeeInfoUpdated(_feeDistro, address(0), _feeToken);
        }
    }

    /**
     * @notice Allows turning off or on for fee distro
     */
    function updateFeeInfo(address _feeToken, bool _active) external {
        require(msg.sender==owner, ""!auth"");

        require(feeTokens[_feeToken].distro != address(0), ""Fee doesn't exist"");

        feeTokens[_feeToken].active = _active;

        emit FeeInfoChanged(_feeToken, _active);
    }

    /**
     * @notice Fee manager can set all the relevant fees
     * @param _lockFees     % for cvxCrv stakers where 1% == 100
     * @param _stakerFees   % for CVX stakers where 1% == 100
     * @param _callerFees   % for whoever calls the claim where 1% == 100
     * @param _platform     % for ""treasury"" or vlCVX where 1% == 100
     */
    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external{
        require(msg.sender==feeManager, ""!auth"");

        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform);
        require(total <= MaxFees, "">MaxFees"");

        require(_lockFees >= 300 && _lockFees <= 1500, ""!lockFees"");
        require(_stakerFees >= 300 && _stakerFees <= 1500, ""!stakerFees"");
        require(_callerFees >= 10 && _callerFees <= 100, ""!callerFees"");
        require(_platform <= 200, ""!platform"");

        lockIncentive = _lockFees;
        stakerIncentive = _stakerFees;
        earmarkIncentive = _callerFees;
        platformFee = _platform;

        emit FeesUpdated(_lockFees, _stakerFees, _callerFees, _platform);
    }

    /**
     * @notice Set the address of the treasury (i.e. vlCVX)
     */
    function setTreasury(address _treasury) external {
        require(msg.sender==feeManager, ""!auth"");
        treasury = _treasury;

        emit TreasuryUpdated(_treasury);
    }

    /// END SETTER SECTION ///


    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    /**
     * @notice Called by the PoolManager (i.e. PoolManagerProxy) to add a new pool - creates all the required
     *         contracts (DepositToken, RewardPool, Stash) and then adds to the list!
     */
    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool){
        require(msg.sender==poolManager && !isShutdown, ""!add"");
        require(_gauge != address(0) && _lptoken != address(0),""!param"");
        require(feeTokens[_gauge].distro == address(0), ""!gauge"");

        //the next pool's pid
        uint256 pid = poolInfo.length;

        //create a tokenized deposit
        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);
        //create a reward contract for crv rewards
        address newRewardPool = IRewardFactory(rewardFactory).CreateCrvRewards(pid,token,_lptoken);
        //create a stash to handle extra incentives
        address stash = IStashFactory(stashFactory).CreateStash(pid,_gauge,staker,_stashVersion);

        //add the new pool
        poolInfo.push(
            PoolInfo({
                lptoken: _lptoken,
                token: token,
                gauge: _gauge,
                crvRewards: newRewardPool,
                stash: stash,
                shutdown: false
            })
        );
        gaugeMap[_gauge] = true;
        //give stashes access to rewardfactory and voteproxy
        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards
        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge
        if(stash != address(0)){
            poolInfo[pid].stash = stash;
            IStaker(staker).setStashAccess(stash,true);
            IRewardFactory(rewardFactory).setAccess(stash,true);
        }

        emit PoolAdded(_lptoken, _gauge, token, newRewardPool, stash, pid);
        return true;
    }

    /**
     * @notice Shuts down the pool by withdrawing everything from the gauge to here (can later be
     *         claimed from depositors by using the withdraw fn) and marking it as shut down
     */
    function shutdownPool(uint256 _pid) external returns(bool){
        require(msg.sender==poolManager, ""!auth"");
        PoolInfo storage pool = poolInfo[_pid];

        //withdraw from gauge
        try IStaker(staker).withdrawAll(pool.lptoken,pool.gauge){
        }catch{}

        pool.shutdown = true;
        gaugeMap[pool.gauge] = false;

        emit PoolShutdown(_pid);
        return true;
    }

    /**
     * @notice Shuts down the WHOLE SYSTEM by withdrawing all the LP tokens ot here and then allowing
     *         for subsequent withdrawal by any depositors.
     */
    function shutdownSystem() external{
        require(msg.sender == owner, ""!auth"");
        isShutdown = true;

        for(uint i=0; i < poolInfo.length; i++){
            PoolInfo storage pool = poolInfo[i];
            if (pool.shutdown) continue;

            address token = pool.lptoken;
            address gauge = pool.gauge;

            //withdraw from gauge
            try IStaker(staker).withdrawAll(token,gauge){
                pool.shutdown = true;
            }catch{}
        }
    }

    /**
     * @notice  Deposits an ""_amount"" to a given gauge (specified by _pid), mints a `DepositToken`
     *          and subsequently stakes that on Convex BaseRewardPool
     */
    function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){
        require(!isShutdown,""shutdown"");
        PoolInfo storage pool = poolInfo[_pid];
        require(pool.shutdown == false, ""pool is closed"");

        //send to proxy to stake
        address lptoken = pool.lptoken;
        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);

        //stake
        address gauge = pool.gauge;
        require(gauge != address(0),""!gauge setting"");
        IStaker(staker).deposit(lptoken,gauge);

        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim
        address stash = pool.stash;
        if(stash != address(0)){
            IStash(stash).stashRewards();
        }

        address token = pool.token;
        if(_stake){
            //mint here and send to rewards on user behalf
            ITokenMinter(token).mint(address(this),_amount);
            address rewardContract = pool.crvRewards;
            IERC20(token).safeApprove(rewardContract,0);
            IERC20(token).safeApprove(rewardContract,_amount);
            IRewards(rewardContract).stakeFor(msg.sender,_amount);
        }else{
            //add user balance directly
            ITokenMinter(token).mint(msg.sender,_amount);
        }

        
        emit Deposited(msg.sender, _pid, _amount);
        return true;
    }

    /**
     * @notice  Deposits all a senders balance to a given gauge (specified by _pid), mints a `DepositToken`
     *          and subsequently stakes that on Convex BaseRewardPool
     */
    function depositAll(uint256 _pid, bool _stake) external returns(bool){
        address lptoken = poolInfo[_pid].lptoken;
        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);
        deposit(_pid,balance,_stake);
        return true;
    }

    /**
     * @notice  Withdraws LP tokens from a given PID (& user).
     *          1. Burn the cvxLP balance from ""_from"" (implicit balance check)
     *          2. If pool !shutdown.. withdraw from gauge
     *          3. If stash, stash rewards
     *          4. Transfer out the LP tokens
     */
    function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {
        PoolInfo storage pool = poolInfo[_pid];
        address lptoken = pool.lptoken;
        address gauge = pool.gauge;

        //remove lp balance
        address token = pool.token;
        ITokenMinter(token).burn(_from,_amount);

        //pull from gauge if not shutdown
        // if shutdown tokens will be in this contract
        if (!pool.shutdown) {
            IStaker(staker).withdraw(lptoken,gauge, _amount);
        }

        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim
        //do not call if shutdown since stashes wont have access
        address stash = pool.stash;
        if(stash != address(0) && !isShutdown && !pool.shutdown){
            IStash(stash).stashRewards();
        }
        
        //return lp tokens
        IERC20(lptoken).safeTransfer(_to, _amount);

        emit Withdrawn(_to, _pid, _amount);
    }

    /**
     * @notice  Withdraw a given amount from a pool (must already been unstaked from the Convex Reward Pool -
     *          BaseRewardPool uses withdrawAndUnwrap to get around this)
     */
    function withdraw(uint256 _pid, uint256 _amount) public returns(bool){
        _withdraw(_pid,_amount,msg.sender,msg.sender);
        return true;
    }

    /**
     * @notice  Withdraw all the senders LP tokens from a given gauge
     */
    function withdrawAll(uint256 _pid) public returns(bool){
        address token = poolInfo[_pid].token;
        uint256 userBal = IERC20(token).balanceOf(msg.sender);
        withdraw(_pid, userBal);
        return true;
    }

    /**
     * @notice Allows the actual BaseRewardPool to withdraw and send directly to the user
     */
    function withdrawTo(uint256 _pid, uint256 _amount, address _to) external returns(bool){
        address rewardContract = poolInfo[_pid].crvRewards;
        require(msg.sender == rewardContract,""!auth"");

        _withdraw(_pid,_amount,msg.sender,_to);
        return true;
    }

    /**
     * @notice set valid vote hash on VoterProxy 
     */
    function setVote(bytes32 _hash, bool valid) external returns(bool){
        require(msg.sender == voteDelegate, ""!auth"");
        
        IStaker(staker).setVote(_hash, valid);
        return true;
    }

    /**
     * @notice Delegate address votes on dao via VoterProxy
     */
    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){
        require(msg.sender == voteDelegate, ""!auth"");
        require(_votingAddress == voteOwnership || _votingAddress == voteParameter, ""!voteAddr"");
        
        IStaker(staker).vote(_voteId,_votingAddress,_support);
        return true;
    }

    /**
     * @notice Delegate address votes on gauge weight via VoterProxy
     */
    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){
        require(msg.sender == voteDelegate, ""!auth"");

        for(uint256 i = 0; i < _gauge.length; i++){
            IStaker(staker).voteGaugeWeight(_gauge[i],_weight[i]);
        }
        return true;
    }

    /**
     * @notice Allows a stash to claim secondary rewards from a gauge
     */
    function claimRewards(uint256 _pid, address _gauge) external returns(bool){
        address stash = poolInfo[_pid].stash;
        require(msg.sender == stash,""!auth"");

        IStaker(staker).claimRewards(_gauge);
        return true;
    }

    /**
     * @notice Tells the Curve gauge to redirect any accrued rewards to the given stash via the VoterProxy
     */
    function setGaugeRedirect(uint256 _pid) external returns(bool){
        address stash = poolInfo[_pid].stash;
        require(msg.sender == stash,""!auth"");
        address gauge = poolInfo[_pid].gauge;
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256(""set_rewards_receiver(address)"")), stash);
        IStaker(staker).execute(gauge,uint256(0),data);
        return true;
    }

    /**
     * @notice Basically a hugely pivotal function.
     *         Repsonsible for collecting the crv from gauge, and then redistributing to the correct place.
     *         Pays the caller a fee to process this.
     */
    function _earmarkRewards(uint256 _pid) internal {
        PoolInfo storage pool = poolInfo[_pid];
        require(pool.shutdown == false, ""pool is closed"");

        address gauge = pool.gauge;

        //claim crv
        IStaker(staker).claimCrv(gauge);

        //check if there are extra rewards
        address stash = pool.stash;
        if(stash != address(0)){
            //claim extra rewards
            IStash(stash).claimRewards();
            //process extra rewards
            IStash(stash).processStash();
        }

        //crv balance
        uint256 crvBal = IERC20(crv).balanceOf(address(this));

        if (crvBal > 0) {
            // LockIncentive = cvxCrv stakers (currently 10%)
            uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);
            // StakerIncentive = cvx stakers (currently 5%)
            uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);
            // CallIncentive = caller of this contract (currently 1%)
            uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);
            
            // Treasury = vlCVX (currently 1%)
            if(treasury != address(0) && treasury != address(this) && platformFee > 0){
                //only subtract after address condition check
                uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);
                crvBal = crvBal.sub(_platform);
                IERC20(crv).safeTransfer(treasury, _platform);
            }

            //remove incentives from balance
            crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);

            //send incentives for calling
            IERC20(crv).safeTransfer(msg.sender, _callIncentive);          

            //send crv to lp provider reward contract
            address rewardContract = pool.crvRewards;
            IERC20(crv).safeTransfer(rewardContract, crvBal);
            IRewards(rewardContract).queueNewRewards(crvBal);

            //send lockers' share of crv to reward contract
            IERC20(crv).safeTransfer(lockRewards, _lockIncentive);
            IRewards(lockRewards).queueNewRewards(_lockIncentive);

            //send stakers's share of crv to reward contract
            IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);
        }
    }

    /**
     * @notice Basically a hugely pivotal function.
     *         Repsonsible for collecting the crv from gauge, and then redistributing to the correct place.
     *         Pays the caller a fee to process this.
     */
    function earmarkRewards(uint256 _pid) external returns(bool){
        require(!isShutdown,""shutdown"");
        _earmarkRewards(_pid);
        return true;
    }

    /**
     * @notice Claim fees from curve distro contract, put in lockers' reward contract.
     *         lockFees is the secondary reward contract that uses the virtual balances from cvxCrv
     */
    function earmarkFees(address _feeToken) external returns(bool){
        require(!isShutdown,""shutdown"");
        FeeDistro memory feeDistro = feeTokens[_feeToken];
        
        require(feeDistro.active, ""Inactive distro"");
        require(!gaugeMap[_feeToken], ""Invalid token"");

        //claim fee rewards
        uint256 tokenBalanceBefore = IERC20(_feeToken).balanceOf(address(this));
        IStaker(staker).claimFees(feeDistro.distro, _feeToken);
        uint256 tokenBalanceAfter = IERC20(_feeToken).balanceOf(address(this));
        uint256 feesClaimed = tokenBalanceAfter.sub(tokenBalanceBefore);

        //send fee rewards to reward contract
        IERC20(_feeToken).safeTransfer(feeDistro.rewards, feesClaimed);
        IRewards(feeDistro.rewards).queueNewRewards(feesClaimed);

        return true;
    }

    /**
     * @notice Callback from reward contract when crv is received.
     * @dev    Goes off and mints a relative amount of `CVX` based on the distribution schedule.
     */
    function rewardClaimed(uint256 _pid, address _address, uint256 _amount) external returns(bool){
        address rewardContract = poolInfo[_pid].crvRewards;
        require(msg.sender == rewardContract || msg.sender == lockRewards, ""!auth"");

        //mint reward tokens
        ITokenMinter(minter).mint(_address,_amount);
        
        return true;
    }

}",6006
RealWorld_TA_123_AuraMath_RealWorld_20240816003145.log,123,AuraMath,79561,1726,81287,105.0,0.432325,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library AuraMath {
    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute.
        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);
    }

    function to224(uint256 a) internal pure returns (uint224 c) {
        require(a <= type(uint224).max, ""AuraMath: uint224 Overflow"");
        c = uint224(a);
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= type(uint128).max, ""AuraMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to112(uint256 a) internal pure returns (uint112 c) {
        require(a <= type(uint112).max, ""AuraMath: uint112 Overflow"");
        c = uint112(a);
    }

    function to96(uint256 a) internal pure returns (uint96 c) {
        require(a <= type(uint96).max, ""AuraMath: uint96 Overflow"");
        c = uint96(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= type(uint32).max, ""AuraMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library AuraMath32 {
    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        c = a - b;
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint112.
library AuraMath112 {
    function add(uint112 a, uint112 b) internal pure returns (uint112 c) {
        c = a + b;
    }

    function sub(uint112 a, uint112 b) internal pure returns (uint112 c) {
        c = a - b;
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint224.
library AuraMath224 {
    function add(uint224 a, uint224 b) internal pure returns (uint224 c) {
        c = a + b;
    }
}",727
RealWorld_TA_123_ConvexMasterChef_RealWorld_20240815235202.log,123,ConvexMasterChef,242230,4992,247222,152.0,1.31099,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2667
RealWorld_TA_123_IRewardHook_RealWorld_20240816001428.log,123,IRewardHook,21022,1459,22481,86.0,0.13429,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IRewardHook {
    function onRewardClaim() external;
}",30
RealWorld_TA_123_MockVoteStorage_RealWorld_20240816005347.log,123,MockVoteStorage,63584,2560,66144,107.0,0.36912,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

contract MockVoteStorage {
    struct Vote {
        uint256 timestamp;
        uint256 choice;
        string version;
        string space;
        string voteType;
    }

    mapping(string => Vote) public proposals;

    function setProposal(
        uint256 choice,
        uint256 timestamp,
        string memory version,
        string memory proposal,
        string memory space,
        string memory voteType
    ) external {
        Vote memory vote = Vote(timestamp, choice, version, space, voteType);
        proposals[proposal] = vote;
    }

    function hash(string memory proposal) public view returns (bytes32) {
        Vote memory vote = proposals[proposal];

        // prettier-ignore
        return hashStr(string(abi.encodePacked(
            ""{"",
                '""version"":""', vote.version, '"",',
                '""timestamp"":""', uint2str(vote.timestamp), '"",',
                '""space"":""', vote.space, '"",',
                '""type"":""', vote.voteType, '"",',
                payloadStr(proposal, vote.choice),
           ""}""
        )));
    }

    function payloadStr(string memory proposal, uint256 choice) internal pure returns (string memory) {
        // prettier-ignore
        return string(abi.encodePacked(
          '""payload"":', ""{"",
              '""proposal"":', '""', proposal, '"",',
              '""choice"":', uint2str(choice), "",""
              '""metadata"":', '""{}""',
          ""}""
        ));
    }

    function hashStr(string memory str) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n"", uint2str(bytes(str).length), str));
    }

    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return ""0"";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}",524
RealWorld_TA_123_MockInvestmentPoolFactory_RealWorld_20240816011419.log,123,MockInvestmentPoolFactory,31263,1710,32973,87.0,0.190515,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

interface IInvestmentPoolFactory {
    function create(
        string memory name,
        string memory symbol,
        IERC20[] memory tokens,
        uint256[] memory weights,
        uint256 swapFeePercentage,
        address owner,
        bool swapEnabledOnStart,
        uint256 managementSwapFeePercentage
    ) external returns (address);
}

interface IInvestmentPool {
    function setSwapEnabled(bool swapEnabled) external;

    function updateWeightsGradually(
        uint256 startTime,
        uint256 endTime,
        uint256[] memory endWeights
    ) external;
}",154
RealWorld_TA_123_MockBalancerPool_RealWorld_20240816011245.log,123,MockBalancerPool,25496,1748,27244,92.0,0.16244,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";

interface IBalancerPool {
    function getPoolId() external view returns (bytes32);

    function getNormalizedWeights() external view returns (uint256[] memory);

    function getSwapEnabled() external view returns (bool);
}",84
RealWorld_TA_123_MockCurveVoteEscrow_RealWorld_20240816010111.log,123,MockCurveVoteEscrow,70150,3618,73768,125.0,0.42311,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol"";
import ""./MockWalletChecker.sol"";

contract MockCurveVoteEscrow is ERC20(""MockVE"", ""MockVE"") {
    address public smart_wallet_checker;

    address public token;

    mapping(address => uint256) public lockAmounts;

    mapping(address => uint256) public lockTimes;

    uint256 public constant MAX_LEN = 365 days;

    constructor(address _smart_wallet_checker, address _token) {
        smart_wallet_checker = _smart_wallet_checker;
        token = _token;
    }

    function transfer(
        address, /* recipient */
        uint256 /* amount */
    ) public virtual override returns (bool) {
        revert(""Not transferrable"");
    }

    function transferFrom(
        address, /* sender */
        address, /* recipient */
        uint256 /* amount */
    ) public virtual override returns (bool) {
        revert(""Not transferrable"");
    }

    function create_lock(uint256 amount, uint256 unlockTime) external {
        require(MockWalletChecker(smart_wallet_checker).check(msg.sender), ""!contracts"");
        require(lockAmounts[msg.sender] == 0, ""Withdraw old tokens first"");
        require(unlockTime < block.timestamp + MAX_LEN, ""Lock too long"");
        require(amount > 0, ""!amount"");

        lockAmounts[msg.sender] = amount;
        lockTimes[msg.sender] = unlockTime;

        IERC20(token).transferFrom(msg.sender, address(this), amount);
        _mint(msg.sender, amount);
    }

    function increase_amount(uint256 amount) external {
        require(lockAmounts[msg.sender] > 0, ""Must have a lock"");
        require(lockTimes[msg.sender] > block.timestamp, ""Current lock expired"");
        require(amount > 0, ""!amount"");
        lockAmounts[msg.sender] += amount;

        IERC20(token).transferFrom(msg.sender, address(this), amount);
        _mint(msg.sender, amount);
    }

    function increase_unlock_time(uint256 time) external {
        require(lockAmounts[msg.sender] > 0, ""Must have a lock"");
        require(lockTimes[msg.sender] > block.timestamp, ""Current lock expired"");
        require(time > lockTimes[msg.sender], ""Future time must be greater"");
        require(time < block.timestamp + MAX_LEN, ""Lock too long"");
        lockTimes[msg.sender] = time;
    }

    function withdraw() external {
        require(lockTimes[msg.sender] < block.timestamp, ""!unlocked"");

        uint256 amount = balanceOf(msg.sender);

        lockAmounts[msg.sender] = 0;
        lockTimes[msg.sender] = 0;

        IERC20(token).transfer(msg.sender, amount);
        _burn(msg.sender, amount);
    }
}",614
RealWorld_TA_123_IRewarder_RealWorld_20240816000442.log,123,IRewarder,28696,1490,30186,88.0,0.17328,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";

interface IRewarder {
    using SafeERC20 for IERC20;
    function onReward(uint256 pid, address user, address recipient, uint256 sushiAmount, uint256 newLpAmount) external;
    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external view returns (IERC20[] memory, uint256[] memory);
}",133
RealWorld_TA_123_MockERC20_RealWorld_20240816005740.log,123,MockERC20,32414,2411,34825,98.0,0.21029,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

import ""@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol"";

contract MockERC20 is ERC20 {
    uint8 dec;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _initialRecipient,
        uint256 _initialMint
    ) ERC20(_name, _symbol) {
        dec = _decimals;
        _mint(_initialRecipient, _initialMint * (10**uint256(_decimals)));
    }

    function decimals() public view override returns (uint8) {
        return dec;
    }

    function mint(uint256 amount) public {
        _mint(msg.sender, amount);
    }
}",165
RealWorld_TA_123_Aura_RealWorld_20240816003332.log,123,Aura,125703,3290,128993,114.0,0.694315,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { ERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/ERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Address } from ""@openzeppelin/contracts-0.8/utils/Address.sol"";
import { AuraMath } from ""./AuraMath.sol"";

interface IStaker {
    function operator() external view returns (address);
}

/**
 * @title   AuraToken
 * @notice  Basically an ERC20 with minting functionality operated by the ""operator"" of the VoterProxy (Booster).
 * @dev     The minting schedule is based on the amount of CRV earned through staking and is
 *          distirbuted along a supply curve (cliffs etc). Fork of ConvexToken.
 */
contract AuraToken is ERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using AuraMath for uint256;

    address public operator;
    address public immutable vecrvProxy;

    uint256 public constant EMISSIONS_MAX_SUPPLY = 5e25; // 50m
    uint256 public constant totalCliffs = 500;
    uint256 public immutable reductionPerCliff;

    address public minter;
    uint256 private minterMinted = type(uint256).max;

    /* ========== EVENTS ========== */

    event Initialised();
    event OperatorChanged(address indexed previousOperator, address indexed newOperator);

    /**
     * @param _proxy        CVX VoterProxy
     * @param _nameArg      Token name
     * @param _symbolArg    Token symbol
     */
    constructor(
        address _proxy,
        string memory _nameArg,
        string memory _symbolArg
    ) ERC20(_nameArg, _symbolArg) {
        operator = msg.sender;
        vecrvProxy = _proxy;
        reductionPerCliff = EMISSIONS_MAX_SUPPLY.div(totalCliffs);
    }

    /**
     * @dev Initialise and mints initial supply of tokens.
     * @param _to        Target address to mint.
     * @param _amount    Amount of tokens to mint.
     * @param _minter    The minter address.
     */
    function init(
        address _to,
        uint256 _amount,
        address _minter
    ) external {
        require(msg.sender == operator, ""Only operator"");
        require(totalSupply() == 0, ""Only once"");
        require(_amount > 0, ""Must mint something"");
        require(_minter != address(0), ""Invalid minter"");

        _mint(_to, _amount);
        updateOperator();
        minter = _minter;
        minterMinted = 0;

        emit Initialised();
    }

    /**
     * @dev This can be called if the operator of the voterProxy somehow changes.
     */
    function updateOperator() public {
        address newOperator = IStaker(vecrvProxy).operator();
        emit OperatorChanged(operator, newOperator);
        operator = newOperator;
    }

    /**
     * @dev Mints AURA to a given user based on the BAL supply schedule.
     */
    function mint(address _to, uint256 _amount) external {
        require(totalSupply() != 0, ""Not initialised"");

        if (msg.sender != operator) {
            // dont error just return. if a shutdown happens, rewards on old system
            // can still be claimed, just wont mint cvx
            return;
        }

        // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;
        uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;
        // e.g. reductionPerCliff = 5e25 / 500 = 1e23
        // e.g. cliff = 1e25 / 1e23 = 100
        uint256 cliff = emissionsMinted.div(reductionPerCliff);

        // e.g. 100 < 500
        if (cliff < totalCliffs) {
            // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;
            // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;
            // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;
            uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);
            // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;
            // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;
            // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;
            uint256 amount = _amount.mul(reduction).div(totalCliffs);
            // e.g. amtTillMax = 5e25 - 1e25 = 4e25
            uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);
            if (amount > amtTillMax) {
                amount = amtTillMax;
            }
            _mint(_to, amount);
        }
    }

    /**
     * @dev Allows minter to mint to a specific address
     */
    function minterMint(address _to, uint256 _amount) external {
        require(msg.sender == minter, ""Only minter"");
        minterMinted += _amount;
        _mint(_to, _amount);
    }
}",1278
RealWorld_TA_125_ConvexCurveLPVault_RealWorld_20240816065817.log,125,ConvexCurveLPVault,170840,5103,175943,142.0,0.95626,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {GeneralVault} from '../../GeneralVault.sol';
import {IERC20} from '../../../../dependencies/openzeppelin/contracts/IERC20.sol';
import {SafeERC20} from '../../../../dependencies/openzeppelin/contracts/SafeERC20.sol';
import {IERC20Detailed} from '../../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';
import {IConvexBooster} from '../../../../interfaces/IConvexBooster.sol';
import {IConvexBaseRewardPool} from '../../../../interfaces/IConvexBaseRewardPool.sol';
import {TransferHelper} from '../../../libraries/helpers/TransferHelper.sol';
import {Errors} from '../../../libraries/helpers/Errors.sol';
import {SturdyInternalAsset} from '../../../tokenization/SturdyInternalAsset.sol';

interface IRewards {
  function rewardToken() external view returns (address);
}

/**
 * @title ConvexCurveLPVault
 * @notice Curve LP Token Vault by using Convex on Ethereum
 * @author Sturdy
 **/
contract ConvexCurveLPVault is GeneralVault {
  using SafeERC20 for IERC20;

  address public convexBooster;
  address internal curveLPToken;
  address internal internalAssetToken;
  uint256 internal convexPoolId;

  /**
   * @dev The function to set parameters related to convex/curve
   * @param _lpToken The address of Curve LP Token which will be used in vault
   * @param _poolId  The convex pool Id for Curve LP Token
   */
  function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {
    require(internalAssetToken == address(0), Errors.VT_INVALID_CONFIGURATION);

    convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;
    curveLPToken = _lpToken;
    convexPoolId = _poolId;
    SturdyInternalAsset _interalToken = new SturdyInternalAsset(
      string(abi.encodePacked('Sturdy ', IERC20Detailed(_lpToken).symbol())),
      string(abi.encodePacked('c', IERC20Detailed(_lpToken).symbol())),
      IERC20Detailed(_lpToken).decimals()
    );
    internalAssetToken = address(_interalToken);
  }

  /**
   * @dev The function to get internal asset address
   */
  function getInternalAsset() external view returns (address) {
    return internalAssetToken;
  }

  /**
   * @dev The function to get rewards token address
   */
  function getBaseRewardPool() internal view returns (address) {
    IConvexBooster.PoolInfo memory poolInfo = IConvexBooster(convexBooster).poolInfo(convexPoolId);
    return poolInfo.crvRewards;
  }

  /**
   * @dev The function to send rewards to YieldManager & Treasury
   * @param _asset The rewards token address
   */
  function _transferYield(address _asset) internal {
    require(_asset != address(0), Errors.VT_PROCESS_YIELD_INVALID);
    uint256 yieldAmount = IERC20(_asset).balanceOf(address(this));

    // transfer to treasury
    if (_vaultFee > 0) {
      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);
      yieldAmount = yieldAmount.sub(treasuryAmount);
    }

    // transfer to yieldManager
    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');
    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);

    emit ProcessYield(_asset, yieldAmount);
  }

  function processYield() external override onlyAdmin {
    // Claim Rewards(CRV, CVX, Extra incentive tokens)
    address baseRewardPool = getBaseRewardPool();
    IConvexBaseRewardPool(baseRewardPool).getReward();

    // Transfer CRV to YieldManager
    address _token = _addressesProvider.getAddress('CRV');
    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();
    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);
    _transferYield(_token);

    // Transfer CVX to YieldManager
    _token = _addressesProvider.getAddress('CVX');
    _tokenFromConvex = IConvexBooster(convexBooster).minter();
    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);
    _transferYield(_token);

    // Transfer extra incentive token to YieldManager
    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();
    for (uint256 i = 0; i < extraRewardsLength; i++) {
      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);
      address _rewardToken = IRewards(_extraReward).rewardToken();
      _transferYield(_rewardToken);
    }
  }

  /**
   * @dev Get yield amount based on strategy
   */
  function getYieldAmount() external view returns (uint256) {
    return _getYieldAmount(internalAssetToken);
  }

  /**
   * @dev Get price per share based on yield strategy
   */
  function pricePerShare() external view override returns (uint256) {
    uint256 decimals = IERC20Detailed(internalAssetToken).decimals();
    return 10**decimals;
  }

  /**
   * @dev Deposit to yield pool based on strategy and mint internal asset
   */
  function _depositToYieldPool(address _asset, uint256 _amount)
    internal
    override
    returns (address, uint256)
  {
    // receive Curve LP Token from user
    require(_asset == curveLPToken, Errors.VT_COLLATERAL_DEPOSIT_INVALID);
    TransferHelper.safeTransferFrom(curveLPToken, msg.sender, address(this), _amount);

    // deposit Curve LP Token to Convex
    IERC20(curveLPToken).safeApprove(convexBooster, _amount);
    IConvexBooster(convexBooster).deposit(convexPoolId, _amount, true);

    // mint
    SturdyInternalAsset(internalAssetToken).mint(address(this), _amount);
    IERC20(internalAssetToken).safeApprove(address(_addressesProvider.getLendingPool()), _amount);

    return (internalAssetToken, _amount);
  }

  /**
   * @dev Get Withdrawal amount of Curve LP Token based on strategy
   */
  function _getWithdrawalAmount(address _asset, uint256 _amount)
    internal
    view
    override
    returns (address, uint256)
  {
    // In this vault, return same amount of asset.
    return (internalAssetToken, _amount);
  }

  function _withdraw(uint256 _amount, address _to) internal returns (uint256) {
    // Withdraw from Convex
    address baseRewardPool = getBaseRewardPool();
    IConvexBaseRewardPool(baseRewardPool).withdrawAndUnwrap(_amount, true);

    // Deliver Curve LP Token
    TransferHelper.safeTransfer(curveLPToken, _to, _amount);

    // Burn
    SturdyInternalAsset(internalAssetToken).burn(address(this), _amount);

    return _amount;
  }

  function withdrawOnLiquidation(address _asset, uint256 _amount)
    external
    override
    returns (uint256)
  {
    require(_asset == curveLPToken, Errors.LP_LIQUIDATION_CALL_FAILED);
    require(msg.sender == _addressesProvider.getLendingPool(), Errors.LP_LIQUIDATION_CALL_FAILED);

    return _withdraw(_amount, msg.sender);
  }

  /**
   * @dev Withdraw from yield pool based on strategy and deliver asset
   */
  function _withdrawFromYieldPool(
    address _asset,
    uint256 _amount,
    address _to
  ) internal override returns (uint256) {
    require(_asset == curveLPToken, Errors.VT_COLLATERAL_WITHDRAW_INVALID);

    return _withdraw(_amount, _to);
  }

  /**
   * @dev Move some yield(CRV) to treasury
   */
  function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {
    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);
    IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);
    return treasuryAmount;
  }
}",1821
RealWorld_TA_125_GeneralVault_RealWorld_20240816070217.log,125,GeneralVault,213126,5681,218807,163.0,1.17925,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {ILendingPool} from '../../interfaces/ILendingPool.sol';
import {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';
import {PercentageMath} from '../libraries/math/PercentageMath.sol';
import {Errors} from '../libraries/helpers/Errors.sol';
import {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';
import {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';
import {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';
import {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';

/**
 * @title GeneralVault
 * @notice Basic feature of vault
 * @author Sturdy
 **/

contract GeneralVault is VersionedInitializable {
  using SafeMath for uint256;
  using PercentageMath for uint256;

  event ProcessYield(address indexed collateralAsset, uint256 yieldAmount);
  event DepositCollateral(address indexed collateralAsset, address indexed from, uint256 amount);
  event WithdrawCollateral(address indexed collateralAsset, address indexed to, uint256 amount);
  event SetTreasuryInfo(address indexed treasuryAddress, uint256 fee);

  modifier onlyAdmin() {
    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);
    _;
  }

  modifier onlyYieldProcessor() {
    require(
      _addressesProvider.getAddress('YIELD_PROCESSOR') == msg.sender,
      Errors.CALLER_NOT_POOL_ADMIN
    );
    _;
  }

  struct AssetYield {
    address asset;
    uint256 amount;
  }

  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

  ILendingPoolAddressesProvider internal _addressesProvider;

  // vault fee 20%
  uint256 internal _vaultFee;
  address internal _treasuryAddress;

  uint256 public constant VAULT_REVISION = 0x1;

  /**
   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.
   * @param _provider The address of the provider
   **/
  function initialize(ILendingPoolAddressesProvider _provider) public initializer {
    _addressesProvider = _provider;
  }

  function getRevision() internal pure override returns (uint256) {
    return VAULT_REVISION;
  }

  /**
   * @dev Deposits an `amount` of asset as collateral to borrow other asset.
   * @param _asset The asset address for collateral
   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral
   * @param _amount The deposit amount
   */
  function depositCollateral(address _asset, uint256 _amount) external payable virtual {
    // Deposit asset to vault and receive stAsset
    // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido
    (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);

    // Deposit stAsset to lendingPool, then user will get aToken of stAsset
    ILendingPool(_addressesProvider.getLendingPool()).deposit(
      _stAsset,
      _stAssetAmount,
      msg.sender,
      0
    );

    emit DepositCollateral(_asset, msg.sender, _amount);
  }

  /**
   * @dev Withdraw an `amount` of asset used as collateral to user.
   * @param _asset The asset address for collateral
   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral
   * @param _amount The amount to be withdrawn
   * @param _to Address that will receive the underlying, same as msg.sender if the user
   *   wants to receive it on his own wallet, or a different address if the beneficiary is a
   *   different wallet
   */
  function withdrawCollateral(
    address _asset,
    uint256 _amount,
    address _to
  ) external virtual {
    // Before withdraw from lending pool, get the stAsset address and withdrawal amount
    // Ex: In Lido vault, it will return stETH address and same amount
    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);

    // withdraw from lendingPool, it will convert user's aToken to stAsset
    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(
      _stAsset,
      _stAssetAmount,
      msg.sender,
      address(this)
    );

    // Withdraw from vault, it will convert stAsset to asset and send to user
    // Ex: In Lido vault, it will return ETH or stETH to user
    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);

    if (_amount == type(uint256).max) {
      uint256 decimal = IERC20Detailed(_asset).decimals();
      _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);
    }
    require(withdrawAmount >= _amount.percentMul(99_00), Errors.VT_WITHDRAW_AMOUNT_MISMATCH);

    emit WithdrawCollateral(_asset, _to, _amount);
  }

  /**
   * @dev Withdraw an `amount` of asset used as collateral to user on liquidation.
   * @param _asset The asset address for collateral
   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral
   * @param _amount The amount to be withdrawn
   */
  function withdrawOnLiquidation(address _asset, uint256 _amount)
    external
    virtual
    returns (uint256)
  {
    return _amount;
  }

  // /**
  //  * @dev Convert an `amount` of asset used as collateral to swappable asset on liquidation.
  //  * @param _amountIn The amount of collateral asset
  //  */
  // function convertOnLiquidation(address _assetOut, uint256 _amountIn) external virtual {}

  /**
   * @dev Get yield based on strategy and re-deposit
   */
  function processYield() external virtual {}

  /**
   * @dev Get price per share based on yield strategy
   */
  function pricePerShare() external view virtual returns (uint256) {}

  /**
   * @dev Set treasury address and vault fee
   * @param _treasury The treasury address
   * @param _fee The vault fee which has more two decimals, ex: 100% = 100_00
   */
  function setTreasuryInfo(address _treasury, uint256 _fee) external onlyAdmin {
    require(_treasury != address(0), Errors.VT_TREASURY_INVALID);
    require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);
    _treasuryAddress = _treasury;
    _vaultFee = _fee;

    emit SetTreasuryInfo(_treasury, _fee);
  }

  /**
   * @dev Get yield based on strategy and re-deposit
   */
  function _getYield(address _stAsset) internal returns (uint256) {
    uint256 yieldStAsset = _getYieldAmount(_stAsset);
    require(yieldStAsset > 0, Errors.VT_PROCESS_YIELD_INVALID);

    ILendingPool(_addressesProvider.getLendingPool()).getYield(_stAsset, yieldStAsset);
    return yieldStAsset;
  }

  /**
   * @dev Get yield amount based on strategy
   */
  function _getYieldAmount(address _stAsset) internal view returns (uint256) {
    (uint256 stAssetBalance, uint256 aTokenBalance) = ILendingPool(
      _addressesProvider.getLendingPool()
    ).getTotalBalanceOfAssetPair(_stAsset);

    // when deposit for collateral, stAssetBalance = aTokenBalance
    // But stAssetBalance should increase overtime, so vault can grab yield from lendingPool.
    // yield = stAssetBalance - aTokenBalance
    if (stAssetBalance >= aTokenBalance) return stAssetBalance.sub(aTokenBalance);

    return 0;
  }

  /**
   * @dev Get the list of asset and asset's yield amount
   **/
  function _getAssetYields(uint256 _WETHAmount) internal view returns (AssetYield[] memory) {
    // Get total borrowing asset volume and volumes and assets
    (
      uint256 totalVolume,
      uint256[] memory volumes,
      address[] memory assets,
      uint256 length
    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();

    if (totalVolume == 0) return new AssetYield[](0);

    AssetYield[] memory assetYields = new AssetYield[](length);
    uint256 extraWETHAmount = _WETHAmount;

    for (uint256 i = 0; i < length; i++) {
      assetYields[i].asset = assets[i];
      if (i != length - 1) {
        // Distribute wethAmount based on percent of asset volume
        assetYields[i].amount = _WETHAmount.percentMul(
          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)
        );
        extraWETHAmount = extraWETHAmount.sub(assetYields[i].amount);
      } else {
        // without calculation, set remained extra amount
        assetYields[i].amount = extraWETHAmount;
      }
    }

    return assetYields;
  }

  function _depositYield(address _asset, uint256 _amount) internal {
    ILendingPool(_addressesProvider.getLendingPool()).depositYield(_asset, _amount);
  }

  /**
   * @dev Deposit to yield pool based on strategy and receive stAsset
   */
  function _depositToYieldPool(address _asset, uint256 _amount)
    internal
    virtual
    returns (address, uint256)
  {}

  /**
   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset
   */
  function _withdrawFromYieldPool(
    address _asset,
    uint256 _amount,
    address _to
  ) internal virtual returns (uint256) {}

  /**
   * @dev Get Withdrawal amount of stAsset based on strategy
   */
  function _getWithdrawalAmount(address _asset, uint256 _amount)
    internal
    view
    virtual
    returns (address, uint256)
  {}
}",2320
RealWorld_TA_125_YieldManager_RealWorld_20240816065545.log,125,YieldManager,182691,4721,187412,150.0,1.007875,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {Errors} from '../libraries/helpers/Errors.sol';
import {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';
import {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';
import {ILendingPool} from '../../interfaces/ILendingPool.sol';
import {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';
import {ISwapRouter} from '../../interfaces/ISwapRouter.sol';
import {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';
import {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';
import {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol';
import {PercentageMath} from '../libraries/math/PercentageMath.sol';
import {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';
import {TransferHelper} from '../libraries/helpers/TransferHelper.sol';
import {UniswapAdapter} from '../libraries/swap/UniswapAdapter.sol';
import {CurveswapAdapter} from '../libraries/swap/CurveswapAdapter.sol';

/**
 * @title YieldManager
 * @notice yield distributor by swapping from assets to stable coin
 * @author Sturdy
 **/

contract YieldManager is VersionedInitializable, Ownable {
  using SafeMath for uint256;
  using PercentageMath for uint256;

  struct AssetYield {
    address asset;
    uint256 amount;
  }

  // the list of the available reserves, structured as a mapping for gas savings reasons
  mapping(uint256 => address) internal _assetsList;
  uint256 internal _assetsCount;

  ILendingPoolAddressesProvider internal _addressesProvider;

  uint256 public constant VAULT_REVISION = 0x1;

  address public _exchangeToken;

  // tokenIn -> tokenOut -> Curve Pool Address
  mapping(address => mapping(address => address)) internal _curvePools;

  uint256 public constant UNISWAP_FEE = 10000; // 1%
  uint256 public constant SLIPPAGE = 500; // 5%

  modifier onlyAdmin() {
    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);
    _;
  }

  /**
   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.
   * @param _provider The address of the provider
   **/
  function initialize(ILendingPoolAddressesProvider _provider) public initializer {
    _addressesProvider = _provider;
  }

  function setExchangeToken(address _token) external onlyAdmin {
    require(_token != address(0), Errors.VT_INVALID_CONFIGURATION);
    _exchangeToken = _token;
  }

  function getRevision() internal pure override returns (uint256) {
    return VAULT_REVISION;
  }

  function registerAsset(address _asset) external onlyAdmin {
    _assetsList[_assetsCount] = _asset;
    _assetsCount = _assetsCount + 1;
  }

  function getAssetCount() external view returns (uint256) {
    return _assetsCount;
  }

  function getAssetInfo(uint256 _index) external view returns (address) {
    return _assetsList[_index];
  }

  /**
   * @dev Function to set Curve Pool address for the swap
   * @param _tokenIn The address of token being exchanged
   * @param _tokenOut The address of token being received
   * @param _pool The address of the Curve pool to use for the swap
   */
  function setCurvePool(
    address _tokenIn,
    address _tokenOut,
    address _pool
  ) external onlyAdmin {
    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);
    _curvePools[_tokenIn][_tokenOut] = _pool;
  }

  /**
   * @dev Function to get Curve Pool address for the swap
   * @param _tokenIn The address of token being sent
   * @param _tokenOut The address of token being received
   */
  function getCurvePool(address _tokenIn, address _tokenOut) external view returns (address) {
    return _curvePools[_tokenIn][_tokenOut];
  }

  /**
   * @dev Distribute the yield of assets to suppliers.
   *      1. convert asset to exchange token(for now it's USDC) via Uniswap
   *      2. convert exchange token to other stables via Curve
   *      3. deposit to pool for suppliers
   * @param _offset assets array's start offset.
   * @param _count assets array's count when perform distribution.
   **/
  function distributeYield(uint256 _offset, uint256 _count) external onlyAdmin {
    // 1. convert from asset to exchange token via uniswap
    for (uint256 i = 0; i < _count; i++) {
      address asset = _assetsList[_offset + i];
      require(asset != address(0), Errors.UL_INVALID_INDEX);
      uint256 _amount = IERC20Detailed(asset).balanceOf(address(this));
      _convertAssetToExchangeToken(asset, _amount);
    }
    uint256 exchangedAmount = IERC20Detailed(_exchangeToken).balanceOf(address(this));

    // 2. convert from exchange token to other stable assets via curve swap
    AssetYield[] memory assetYields = _getAssetYields(exchangedAmount);
    for (uint256 i = 0; i < assetYields.length; i++) {
      if (assetYields[i].amount > 0) {
        uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount);
        // 3. deposit Yield to pool for suppliers
        _depositYield(assetYields[i].asset, _amount);
      }
    }
  }

  /**
   * @dev Get the list of asset and asset's yield amount
   **/
  function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {
    // Get total borrowing asset volume and volumes and assets
    (
      uint256 totalVolume,
      uint256[] memory volumes,
      address[] memory assets,
      uint256 length
    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();

    if (totalVolume == 0) return new AssetYield[](0);

    AssetYield[] memory assetYields = new AssetYield[](length);
    uint256 extraYieldAmount = _totalYieldAmount;

    for (uint256 i = 0; i < length; i++) {
      assetYields[i].asset = assets[i];
      if (i != length - 1) {
        // Distribute yieldAmount based on percent of asset volume
        assetYields[i].amount = _totalYieldAmount.percentMul(
          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)
        );
        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);
      } else {
        // without calculation, set remained extra amount
        assetYields[i].amount = extraYieldAmount;
      }
    }

    return assetYields;
  }

  /**
   * @dev Convert asset to exchange token via Uniswap
   * @param asset The address of asset being exchanged
   * @param amount The amount of asset being exchanged
   */
  function _convertAssetToExchangeToken(address asset, uint256 amount) internal {
    UniswapAdapter.swapExactTokensForTokens(
      _addressesProvider,
      asset,
      _exchangeToken,
      amount,
      UNISWAP_FEE,
      SLIPPAGE
    );
  }

  /**
   * @dev The function to convert from exchange token to stable coin via Curve
   * @param _tokenOut The address of stable coin
   * @param _amount The amount of exchange token being sent
   * @return receivedAmount The amount of stable coin converted
   */
  function _convertToStableCoin(address _tokenOut, uint256 _amount)
    internal
    returns (uint256 receivedAmount)
  {
    if (_tokenOut == _exchangeToken) {
      return _amount;
    }
    address _pool = _curvePools[_exchangeToken][_tokenOut];
    require(_pool != address(0), Errors.VT_INVALID_CONFIGURATION);
    receivedAmount = CurveswapAdapter.swapExactTokensForTokens(
      _addressesProvider,
      _pool,
      _exchangeToken,
      _tokenOut,
      _amount,
      SLIPPAGE
    );
  }

  /**
   * @dev The function to deposit yield to pool for suppliers
   * @param _asset The address of yield asset
   * @param _amount The mount of asset
   */
  function _depositYield(address _asset, uint256 _amount) internal {
    address _lendingPool = _addressesProvider.getLendingPool();
    IERC20(_asset).approve(_lendingPool, _amount);
    ILendingPool(_lendingPool).depositYield(_asset, _amount);
  }
}",1977
RealWorld_TA_125_CollateralAdapter_RealWorld_20240816070041.log,125,CollateralAdapter,55599,2077,57676,95.0,0.319535,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {Errors} from '../libraries/helpers/Errors.sol';
import {ILendingPool} from '../../interfaces/ILendingPool.sol';
import {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';
import {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';

/**
 * @title CollateralAdapter
 * @notice CollateralToVault mapping adapter
 * @author Sturdy
 **/

contract CollateralAdapter is VersionedInitializable {
  modifier onlyAdmin() {
    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);
    _;
  }

  uint256 public constant VAULT_REVISION = 0x1;

  ILendingPoolAddressesProvider internal _addressesProvider;

  // External collateral asset -> vault
  mapping(address => address) internal _assetToVaults;
  // External collateral asset -> internal collateral asset
  mapping(address => address) internal _collateralAssets;

  /**
   * @dev Function is invoked by the proxy contract when the Adapter contract is deployed.
   * @param _provider The address of the provider
   **/
  function initialize(ILendingPoolAddressesProvider _provider) public initializer {
    _addressesProvider = _provider;
  }

  function getRevision() internal pure override returns (uint256) {
    return VAULT_REVISION;
  }

  function addCollateralAsset(
    address _externalAsset,
    address _internalAsset,
    address _acceptVault
  ) external onlyAdmin {
    _assetToVaults[_externalAsset] = _acceptVault;
    _collateralAssets[_externalAsset] = _internalAsset;
  }

  function getAcceptableVault(address _externalAsset) external view returns (address) {
    return _assetToVaults[_externalAsset];
  }

  function getInternalCollateralAsset(address _externalAsset) external view returns (address) {
    return _collateralAssets[_externalAsset];
  }
}",441
RealWorld_TA_125_LidoVault_RealWorld_20240816070502.log,125,LidoVault,127785,5201,132986,127.0,0.742945,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {GeneralVault} from '../GeneralVault.sol';
import {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';
import {IWETH} from '../../../misc/interfaces/IWETH.sol';
import {Errors} from '../../libraries/helpers/Errors.sol';
import {TransferHelper} from '../../libraries/helpers/TransferHelper.sol';
import {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';
import {CurveswapAdapter} from '../../libraries/swap/CurveswapAdapter.sol';

/**
 * @title LidoVault
 * @notice stETH/ETH Vault by using Lido, Uniswap, Curve
 * @author Sturdy
 **/
contract LidoVault is GeneralVault {
  using SafeERC20 for IERC20;

  /**
   * @dev Receive Ether
   */
  receive() external payable {}

  /**
   * @dev Grab excess stETH which was from rebasing on Lido
   *  And convert stETH -> ETH -> asset, deposit to pool
   */
  function processYield() external override onlyAdmin {
    // Get yield from lendingPool
    address LIDO = _addressesProvider.getAddress('LIDO');
    uint256 yieldStETH = _getYield(LIDO);

    // move yield to treasury
    if (_vaultFee > 0) {
      uint256 treasuryStETH = _processTreasury(yieldStETH);
      yieldStETH = yieldStETH.sub(treasuryStETH);
    }

    // Exchange stETH -> ETH via Curve
    uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(
      _addressesProvider,
      _addressesProvider.getAddress('STETH_ETH_POOL'),
      LIDO,
      ETH,
      yieldStETH,
      200
    );

    // ETH -> WETH
    address weth = _addressesProvider.getAddress('WETH');
    IWETH(weth).deposit{value: receivedETHAmount}();

    // transfer WETH to yieldManager
    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');
    TransferHelper.safeTransfer(weth, yieldManager, receivedETHAmount);

    emit ProcessYield(_addressesProvider.getAddress('WETH'), receivedETHAmount);
  }

  /**
   * @dev Get yield amount based on strategy
   */
  function getYieldAmount() external view returns (uint256) {
    return _getYieldAmount(_addressesProvider.getAddress('LIDO'));
  }

  /**
   * @dev Get price per share based on yield strategy
   */
  function pricePerShare() external view override returns (uint256) {
    return 1e18;
  }

  /**
   * @dev Deposit to yield pool based on strategy and receive stAsset
   */
  function _depositToYieldPool(address _asset, uint256 _amount)
    internal
    override
    returns (address, uint256)
  {
    address LIDO = _addressesProvider.getAddress('LIDO');
    uint256 assetAmount = _amount;
    if (_asset == address(0)) {
      // Case of ETH deposit from user, user has to send ETH
      require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);

      // Deposit ETH to Lido and receive stETH
      (bool sent, bytes memory data) = LIDO.call{value: msg.value}('');
      require(sent, Errors.VT_COLLATERAL_DEPOSIT_INVALID);

      assetAmount = msg.value;
    } else {
      // Case of stETH deposit from user, receive stETH from user
      require(_asset == LIDO, Errors.VT_COLLATERAL_DEPOSIT_INVALID);
      IERC20(LIDO).safeTransferFrom(msg.sender, address(this), _amount);
    }

    // Make lendingPool to transfer required amount
    IERC20(LIDO).safeApprove(address(_addressesProvider.getLendingPool()), assetAmount);
    return (LIDO, assetAmount);
  }

  /**
   * @dev Get Withdrawal amount of stAsset based on strategy
   */
  function _getWithdrawalAmount(address _asset, uint256 _amount)
    internal
    view
    override
    returns (address, uint256)
  {
    // In this vault, return same amount of asset.
    return (_addressesProvider.getAddress('LIDO'), _amount);
  }

  /**
   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset
   */
  function _withdrawFromYieldPool(
    address _asset,
    uint256 _amount,
    address _to
  ) internal override returns (uint256) {
    address LIDO = _addressesProvider.getAddress('LIDO');
    if (_asset == address(0)) {
      // Case of ETH withdraw request from user, so exchange stETH -> ETH via curve
      uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(
        _addressesProvider,
        _addressesProvider.getAddress('STETH_ETH_POOL'),
        LIDO,
        ETH,
        _amount,
        200
      );

      // send ETH to user
      (bool sent, bytes memory data) = address(_to).call{value: receivedETHAmount}('');
      return receivedETHAmount;
      require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID);
    } else {
      // Case of stETH withdraw request from user, so directly send
      require(_asset == LIDO, Errors.VT_COLLATERAL_WITHDRAW_INVALID);
      IERC20(LIDO).safeTransfer(_to, _amount);
    }
    return _amount;
  }

  /**
   * @dev Move some yield to treasury
   */
  function _processTreasury(uint256 _yieldAmount) internal returns (uint256) {
    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);
    IERC20(_addressesProvider.getAddress('LIDO')).safeTransfer(_treasuryAddress, treasuryAmount);
    return treasuryAmount;
  }
}",1272
RealWorld_TA_192_TradingExtension_RealWorld_20240816221100.log,192,TradingExtension,209682,5510,215192,263.0,1.15861,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./utils/TradingLibrary.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";

contract TradingExtension is Ownable{
    uint constant private DIVISION_CONSTANT = 1e10; // 100%

    address public trading;
    uint256 public validSignatureTimer;
    bool public chainlinkEnabled;

    mapping(address => bool) private isNode;
    mapping(address => uint) public minPositionSize;
    mapping(address => bool) public allowedMargin;
    bool public paused;

    IPairsContract private pairsContract;
    IReferrals private referrals;
    IPosition private position;

    uint public maxGasPrice = 1000000000000; // 1000 gwei

    constructor(
        address _trading,
        address _pairsContract,
        address _ref,
        address _position
    )
    {
        trading = _trading;
        pairsContract = IPairsContract(_pairsContract);
        referrals = IReferrals(_ref);
        position = IPosition(_position);
    }

    /**
    * @notice returns the minimum position size per collateral asset
    * @param _asset address of the asset
    */
    function minPos(
        address _asset
    ) external view returns(uint) {
        return minPositionSize[_asset];
    }

    /**
    * @notice closePosition helper
    * @dev only callable by trading contract
    * @param _id id of the position NFT
    * @param _price current asset price
    * @param _percent close percentage
    * @return _trade returns the trade struct from NFT contract
    * @return _positionSize size of the position
    * @return _payout amount of payout to the trader after closing
    */
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external onlyProtocol returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) {
        _trade = position.trades(_id);
        (_positionSize, _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);

        unchecked {
            if (_trade.direction) {
                modifyLongOi(_trade.asset, _trade.tigAsset, false, (_trade.margin*_trade.leverage/1e18)*_percent/DIVISION_CONSTANT);
            } else {
                modifyShortOi(_trade.asset, _trade.tigAsset, false, (_trade.margin*_trade.leverage/1e18)*_percent/DIVISION_CONSTANT);     
            }
        }
    }

    /**
    * @notice limitClose helper
    * @dev only callable by trading contract
    * @param _id id of the position NFT
    * @param _tp true if long, else short
    * @param _priceData price data object came from the price oracle
    * @param _signature to verify the oracle
    * @return _limitPrice price of sl or tp returned from positions contract
    * @return _tigAsset address of the position collateral asset
    */
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external view returns(uint _limitPrice, address _tigAsset) {
        _checkGas();
        IPosition.Trade memory _trade = position.trades(_id);
        _tigAsset = _trade.tigAsset;

        getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        uint256 _price = _priceData.price;

        if (_trade.orderType != 0) revert(""4""); //IsLimit

        if (_tp) {
            if (_trade.tpPrice == 0) revert(""7""); //LimitNotSet
            if (_trade.direction) {
                if (_trade.tpPrice > _price) revert(""6""); //LimitNotMet
            } else {
                if (_trade.tpPrice < _price) revert(""6""); //LimitNotMet
            }
            _limitPrice = _trade.tpPrice;
        } else {
            if (_trade.slPrice == 0) revert(""7""); //LimitNotSet
            if (_trade.direction) {
                if (_trade.slPrice < _price) revert(""6""); //LimitNotMet
            } else {
                if (_trade.slPrice > _price) revert(""6""); //LimitNotMet
            }
            _limitPrice = _trade.slPrice;
        }
    }

    function _checkGas() public view {
        if (tx.gasprice > maxGasPrice) revert(""1""); //GasTooHigh
    }

    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) public onlyProtocol {
        pairsContract.modifyShortOi(_asset, _tigAsset, _onOpen, _size);
    }

    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) public onlyProtocol {
        pairsContract.modifyLongOi(_asset, _tigAsset, _onOpen, _size);
    }

    function setMaxGasPrice(uint _maxGasPrice) external onlyOwner {
        maxGasPrice = _maxGasPrice;
    }

    function getRef(
        address _trader
    ) external view returns(address) {
        return referrals.getReferral(referrals.getReferred(_trader));
    }

    /**
    * @notice verifies the signed price and returns it
    * @param _asset id of position asset
    * @param _priceData price data object came from the price oracle
    * @param _signature to verify the oracle
    * @param _withSpreadIsLong 0, 1, or 2 - to specify if we need the price returned to be after spread
    * @return _price price after verification and with spread if _withSpreadIsLong is 1 or 2
    * @return _spread spread after verification
    */
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) 
        public view
        returns(uint256 _price, uint256 _spread) 
    {
        TradingLibrary.verifyPrice(
            validSignatureTimer,
            _asset,
            chainlinkEnabled,
            pairsContract.idToAsset(_asset).chainlinkFeed,
            _priceData,
            _signature,
            isNode
        );
        _price = _priceData.price;
        _spread = _priceData.spread;

        if(_withSpreadIsLong == 1) 
            _price += _price * _spread / DIVISION_CONSTANT;
        else if(_withSpreadIsLong == 2) 
            _price -= _price * _spread / DIVISION_CONSTANT;
    }

    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external onlyProtocol {
        
        if (_referral != bytes32(0)) {
            if (referrals.getReferral(_referral) != address(0)) {
                if (referrals.getReferred(_trader) == bytes32(0)) {
                    referrals.setReferred(_trader, _referral);
                }
            }
        }
    }

    /**
     * @dev validates the inputs of trades
     * @param _asset asset id
     * @param _tigAsset margin asset
     * @param _margin margin
     * @param _leverage leverage
     */
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view {
        unchecked {
            IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
            if (!allowedMargin[_tigAsset]) revert(""!margin"");
            if (paused) revert(""paused"");
            if (!pairsContract.allowedAsset(_asset)) revert(""!allowed"");
            if (_leverage < asset.minLeverage || _leverage > asset.maxLeverage) revert(""!lev"");
            if (_margin*_leverage/1e18 < minPositionSize[_tigAsset]) revert(""!size"");
        }
    }

    function setValidSignatureTimer(
        uint _validSignatureTimer
    )
        external
        onlyOwner
    {
        validSignatureTimer = _validSignatureTimer;
    }

    function setChainlinkEnabled(bool _bool) external onlyOwner {
        chainlinkEnabled = _bool;
    }

    /**
     * @dev whitelists a node
     * @param _node node address
     * @param _bool bool
     */
    function setNode(address _node, bool _bool) external onlyOwner {
        isNode[_node] = _bool;
    }

    /**
     * @dev Allows a tigAsset to be used
     * @param _tigAsset tigAsset
     * @param _bool bool
     */
    function setAllowedMargin(
        address _tigAsset,
        bool _bool
    ) 
        external
        onlyOwner
    {
        allowedMargin[_tigAsset] = _bool;
    }

    /**
     * @dev changes the minimum position size
     * @param _tigAsset tigAsset
     * @param _min minimum position size 18 decimals
     */
    function setMinPositionSize(
        address _tigAsset,
        uint _min
    ) 
        external
        onlyOwner
    {
        minPositionSize[_tigAsset] = _min;
    }

    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }

    modifier onlyProtocol { 
        require(msg.sender == trading, ""!protocol"");
        _;
    }
}",2124
RealWorld_TA_192_NFTSale_RealWorld_20240816215747.log,192,NFTSale,59464,5415,64879,154.0,0.40562,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";

interface IERC721 {
    function balanceOf(address) external view returns (uint256);
    function safeTransferMany(address, uint[] memory) external;
    function claim(address) external;
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint) external;
    function transferFrom(address, address, uint) external;
}

contract NFTSale is Ownable {

    uint public price;
    IERC721 public nft;
    IERC20 public token;

    uint[] public availableIds;

    constructor (IERC721 _nft, IERC20 _token) {
        nft = _nft;
        token = _token;
    }


    function setPrice(uint _price) external onlyOwner {
        price = _price;
    }

    function available() external view returns (uint) {
        return nft.balanceOf(address(this));
    }

    function buy(uint _amount) external {
        require(_amount <= availableIds.length, ""Not enough for sale"");
        uint _tokenAmount = _amount*price;
        token.transferFrom(msg.sender, owner(), _tokenAmount);
        uint[] memory _sold = new uint[](_amount);
        for (uint i=0; i<_amount; i++) {
            _sold[i] = availableIds[(availableIds.length-i) - 1];
        }
        for (uint i=0; i<_amount; i++) {
            availableIds.pop();
        }
        nft.safeTransferMany(msg.sender, _sold);
    }

    function recovertoken() external {
        token.transfer(owner(), token.balanceOf(address(this)));
    }

    function recoverNft() external onlyOwner {
        nft.safeTransferMany(owner(), availableIds);
        availableIds = new uint[](0);
    }

    function setIds(uint[] calldata _ids) external onlyOwner {
        availableIds = _ids;
    }

    function claimPendingRev(address _tigAsset) external {
        nft.claim(_tigAsset);
        IERC20(_tigAsset).transfer(owner(), IERC20(_tigAsset).balanceOf(address(this)));
    }
}",479
RealWorld_TA_192_Lock_RealWorld_20240816215531.log,192,Lock,105624,4138,109762,134.0,0.61088,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IBondNFT.sol"";
import ""./interfaces/IGovNFT.sol"";

contract Lock is Ownable{

    uint public constant minPeriod = 7;
    uint public constant maxPeriod = 365;

    IBondNFT public immutable bondNFT;
    IGovNFT public immutable govNFT;

    mapping(address => bool) public allowedAssets;
    mapping(address => uint) public totalLocked;

    constructor(
        address _bondNFTAddress,
        address _govNFT
    ) {
        bondNFT = IBondNFT(_bondNFTAddress);
        govNFT = IGovNFT(_govNFT);
    }

    /**
     * @notice Claim pending rewards from a bond
     * @param _id Bond NFT id
     * @return address claimed tigAsset address
     */
    function claim(
        uint256 _id
    ) public returns (address) {
        claimGovFees();
        (uint _amount, address _tigAsset) = bondNFT.claim(_id, msg.sender);
        IERC20(_tigAsset).transfer(msg.sender, _amount);
        return _tigAsset;
    }

    /**
     * @notice Claim pending rewards left over from a bond transfer
     * @param _tigAsset token address being claimed
     */
    function claimDebt(
        address _tigAsset
    ) external {
        claimGovFees();
        uint amount = bondNFT.claimDebt(msg.sender, _tigAsset);
        IERC20(_tigAsset).transfer(msg.sender, amount);
    }

    /**
     * @notice Lock up tokens to create a bond
     * @param _asset tigAsset being locked
     * @param _amount tigAsset amount
     * @param _period number of days to be locked for
     */
    function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Reset the lock time and extend the period and/or token amount
     * @param _id Bond id being extended
     * @param _amount tigAsset amount being added
     * @param _period number of days being added
     */
    function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

    /**
     * @notice Release the bond once it's expired
     * @param _id Bond id being released
     */
    function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }

    /**
     * @notice Claim rewards from gov nfts and distribute them to bonds
     */
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }

    /**
     * @notice Whitelist an asset
     * @param _tigAsset tigAsset token address
     * @param _isAllowed set tigAsset as allowed
     */
    function editAsset(
        address _tigAsset,
        bool _isAllowed
    ) external onlyOwner() {
        allowedAssets[_tigAsset] = _isAllowed;
    }

    /**
     * @notice Owner can retreive Gov NFTs
     * @param _ids array of gov nft ids
     */
    function sendNFTs(
        uint[] memory _ids
    ) external onlyOwner() {
        govNFT.safeTransferMany(msg.sender, _ids);
    }
}",1088
RealWorld_TA_192_Timelock_RealWorld_20240816220656.log,192,Timelock,25976,1747,27723,118.0,0.16482,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/governance/TimelockController.sol"";

contract Timelock is TimelockController {
    constructor(address[] memory _proposers, address[] memory _executors, uint256 _time) TimelockController(_time, _proposers, _executors, address(0)) {}
}",88
RealWorld_TA_192_BondNFT_RealWorld_20240816220323.log,192,BondNFT,290811,7898,298709,211.0,1.612015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

contract BondNFT is ERC721Enumerable, Ownable {
    
    uint constant private DAY = 24 * 60 * 60;

    struct Bond {
        uint id;
        address owner;
        address asset;
        uint amount;
        uint mintEpoch;
        uint mintTime;
        uint expireEpoch;
        uint pending;
        uint shares;
        uint period;
        bool expired;
    }

    mapping(address => uint256) public epoch;
    uint private totalBonds;
    string public baseURI;
    address public manager;
    address[] public assets;

    mapping(address => bool) public allowedAsset;
    mapping(address => uint) private assetsIndex;
    mapping(uint256 => mapping(address => uint256)) private bondPaid;
    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare
    mapping(uint => Bond) private _idToBond;
    mapping(address => uint) public totalShares;
    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount

    constructor(
        string memory _setBaseURI,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
    }

    /**
     * @notice Create a bond
     * @dev Should only be called by a manager contract
     * @param _asset tigAsset token to lock
     * @param _amount tigAsset amount
     * @param _period time to lock for in days
     * @param _owner address to receive the bond
     * @return id ID of the minted bond
     */
    function createLock(
        address _asset,
        uint _amount,
        uint _period,
        address _owner
    ) external onlyManager() returns(uint id) {
        require(allowedAsset[_asset], ""!Asset"");
        unchecked {
            uint shares = _amount * _period / 365;
            uint expireEpoch = epoch[_asset] + _period;
            id = ++totalBonds;
            totalShares[_asset] += shares;
            Bond memory _bond = Bond(
                id,             // id
                address(0),     // owner
                _asset,         // tigAsset token
                _amount,        // tigAsset amount
                epoch[_asset],  // mint epoch
                block.timestamp,// mint timestamp
                expireEpoch,    // expire epoch
                0,              // pending
                shares,         // linearly scaling share of rewards
                _period,        // lock period
                false           // is expired boolean
            );
            _idToBond[id] = _bond;
            _mint(_owner, _bond);
        }
        emit Lock(_asset, _amount, _period, _owner, id);
    }

    /** 
     * @notice Extend the lock period and/or amount of a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _asset tigAsset token address
     * @param _amount amount of tigAsset being added
     * @param _period days being added to the bond
     * @param _sender address extending the bond
     */
    function extendLock(
        uint _id,
        address _asset,
        uint _amount,
        uint _period,
        address _sender
    ) external onlyManager() {
        Bond memory bond = idToBond(_id);
        Bond storage _bond = _idToBond[_id];
        require(bond.owner == _sender, ""!owner"");
        require(!bond.expired, ""Expired"");
        require(bond.asset == _asset, ""!BondAsset"");
        require(bond.pending == 0);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(bond.period+_period <= 365, ""MAX PERIOD"");
        unchecked {
            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;
            uint expireEpoch = block.timestamp/DAY + bond.period + _period;
            totalShares[bond.asset] += shares-bond.shares;
            _bond.shares = shares;
            _bond.amount += _amount;
            _bond.expireEpoch = expireEpoch;
            _bond.period += _period;
            _bond.mintTime = block.timestamp;
            _bond.mintEpoch = epoch[bond.asset];
            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;
        }
        emit ExtendLock(_period, _amount, _sender,  _id);
    }

    /**
     * @notice Release a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond
     * @param _releaser address initiating the release of the bond
     * @return amount amount of tigAsset returned
     * @return lockAmount amount of tigAsset locked in the bond
     * @return asset tigAsset token released
     * @return _owner bond owner
     */
    function release(
        uint _id,
        address _releaser
    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {
        Bond memory bond = idToBond(_id);
        require(bond.expired, ""!expire"");
        if (_releaser != bond.owner) {
            unchecked {
                require(bond.expireEpoch + 7 < epoch[bond.asset], ""Bond owner priority"");
            }
        }
        amount = bond.amount;
        unchecked {
            totalShares[bond.asset] -= bond.shares;
            (uint256 _claimAmount,) = claim(_id, bond.owner);
            amount += _claimAmount;
        }
        asset = bond.asset;
        lockAmount = bond.amount;
        _owner = bond.owner;
        _burn(_id);
        emit Release(asset, lockAmount, _owner, _id);
    }
    /**
     * @notice Claim rewards from a bond
     * @dev Should only be called by a manager contract
     * @param _id ID of the bond to claim rewards from
     * @param _claimer address claiming rewards
     * @return amount amount of tigAsset claimed
     * @return tigAsset tigAsset token address
     */
    function claim(
        uint _id,
        address _claimer
    ) public onlyManager() returns(uint amount, address tigAsset) {
        Bond memory bond = idToBond(_id);
        require(_claimer == bond.owner, ""!owner"");
        amount = bond.pending;
        tigAsset = bond.asset;
        unchecked {
            if (bond.expired) {
                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);
                if (totalShares[bond.asset] > 0) {
                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];
                }
            }
            bondPaid[_id][bond.asset] += amount;
        }
        IERC20(tigAsset).transfer(manager, amount);
        emit ClaimFees(tigAsset, amount, _claimer, _id);
    }

    /**
     * @notice Claim user debt left from bond transfer
     * @dev Should only be called by a manager contract
     * @param _user user address
     * @param _tigAsset tigAsset token address
     * @return amount amount of tigAsset claimed
     */
    function claimDebt(
        address _user,
        address _tigAsset
    ) public onlyManager() returns(uint amount) {
        amount = userDebt[_user][_tigAsset];
        userDebt[_user][_tigAsset] = 0;
        IERC20(_tigAsset).transfer(manager, amount);
        emit ClaimDebt(_tigAsset, amount, _user);
    }

    /**
     * @notice Distribute rewards to bonds
     * @param _tigAsset tigAsset token address
     * @param _amount tigAsset amount
     */
    function distribute(
        address _tigAsset,
        uint _amount
    ) external {
        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;
        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);
        unchecked {
            uint aEpoch = block.timestamp / DAY;
            if (aEpoch > epoch[_tigAsset]) {
                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {
                    epoch[_tigAsset] += 1;
                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];
                }
            }
            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];
        }
        emit Distribution(_tigAsset, _amount);
    }

    /**
     * @notice Get all data for a bond
     * @param _id ID of the bond
     * @return bond Bond object
     */
    function idToBond(uint256 _id) public view returns (Bond memory bond) {
        bond = _idToBond[_id];
        bond.owner = ownerOf(_id);
        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;
        unchecked {
            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];
            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];
        }
    }

    /*
     * @notice Get expired boolean for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function isExpired(uint256 _id) public view returns (bool) {
        Bond memory bond = _idToBond[_id];
        return bond.expireEpoch <= epoch[bond.asset] ? true : false;
    }

    /*
     * @notice Get pending rewards for a bond
     * @param _id ID of the bond
     * @return bool true if bond is expired
     */
    function pending(
        uint256 _id
    ) public view returns (uint256) {
        return idToBond(_id).pending;
    }

    function totalAssets() public view returns (uint256) {
        return assets.length;
    }

    /*
     * @notice Gets an array of all whitelisted token addresses
     * @return address array of addresses
     */
    function getAssets() public view returns (address[] memory) {
        return assets;
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function safeTransferMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _transfer(_msgSender(), _to, _ids[i]);
            }
        }
    }

    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                safeTransferFrom(_from, _to, _ids[i]);
            }
        }
    }

    function approveMany(address _to, uint[] calldata _ids) external {
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                approve(_to, _ids[i]);
            }
        }
    }

    function _mint(
        address to,
        Bond memory bond
    ) internal {
        unchecked {
            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;
        }
        _mint(to, bond.id);
    }

    function _burn(
        uint256 _id
    ) internal override {
        delete _idToBond[_id];
        super._burn(_id);
    }

    function _transfer(
        address from,
        address to,
        uint256 _id
    ) internal override {
        Bond memory bond = idToBond(_id);
        require(epoch[bond.asset] == block.timestamp/DAY, ""Bad epoch"");
        require(!bond.expired, ""Expired!"");
        unchecked {
            require(block.timestamp > bond.mintTime + 300, ""Recent update"");
            userDebt[from][bond.asset] += bond.pending;
            bondPaid[_id][bond.asset] += bond.pending;
        }
        super._transfer(from, to, _id);
    }

    function balanceIds(address _user) public view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        unchecked {
            for (uint i=0; i<_ids.length; i++) {
                _ids[i] = tokenOfOwnerByIndex(_user, i);
            }
        }
        return _ids;
    }

    function addAsset(address _asset) external onlyOwner {
        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, ""Already added"");
        assetsIndex[_asset] = assets.length;
        assets.push(_asset);
        allowedAsset[_asset] = true;
        epoch[_asset] = block.timestamp/DAY;
    }

    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {
        require(assets[assetsIndex[_asset]] == _asset, ""Not added"");
        allowedAsset[_asset] = _bool;
    }

    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    function setManager(
        address _manager
    ) public onlyOwner() {
        manager = _manager;
    }

    modifier onlyManager() {
        require(msg.sender == manager, ""!manager"");
        _;
    }

    event Distribution(address _tigAsset, uint256 _amount);
    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);
    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);
    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);
    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);
    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);
}",3270
RealWorld_TA_192_Forwarder_RealWorld_20240816220856.log,192,Forwarder,21543,1552,23095,122.0,0.138755,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/metatx/MinimalForwarder.sol"";

contract Forwarder is MinimalForwarder {}",41
RealWorld_TA_192_Trading_RealWorld_20240816220023.log,192,Trading,785491,1239,786730,177.0,3.952235,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/MetaContext.sol"";
import ""./interfaces/ITrading.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./interfaces/IPairsContract.sol"";
import ""./interfaces/IReferrals.sol"";
import ""./interfaces/IPosition.sol"";
import ""./interfaces/IGovNFT.sol"";
import ""./interfaces/IStableVault.sol"";
import ""./utils/TradingLibrary.sol"";

interface ITradingExtension {
    function getVerifiedPrice(
        uint _asset,
        PriceData calldata _priceData,
        bytes calldata _signature,
        uint _withSpreadIsLong
    ) external returns(uint256 _price, uint256 _spread);
    function getRef(
        address _trader
    ) external pure returns(address);
    function _setReferral(
        bytes32 _referral,
        address _trader
    ) external;
    function validateTrade(uint _asset, address _tigAsset, uint _margin, uint _leverage) external view;
    function isPaused() external view returns(bool);
    function minPos(address) external view returns(uint);
    function modifyLongOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function modifyShortOi(
        uint _asset,
        address _tigAsset,
        bool _onOpen,
        uint _size
    ) external;
    function paused() external returns(bool);
    function _limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    ) external returns(uint _limitPrice, address _tigAsset);
    function _checkGas() external view;
    function _closePosition(
        uint _id,
        uint _price,
        uint _percent
    ) external returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout);
}

interface IStable is IERC20 {
    function burnFrom(address account, uint amount) external;
    function mintFor(address account, uint amount) external;
}

interface ExtendedIERC20 is IERC20 {
    function decimals() external view returns (uint);
}

interface ERC20Permit is IERC20 {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract Trading is MetaContext, ITrading {

    error LimitNotSet(); //7
    error NotLiquidatable();
    error TradingPaused();
    error BadDeposit();
    error BadWithdraw();
    error ValueNotEqualToMargin();
    error BadLeverage();
    error NotMargin();
    error NotAllowedPair();
    error BelowMinPositionSize();
    error BadClosePercent();
    error NoPrice();
    error LiqThreshold();

    uint constant private DIVISION_CONSTANT = 1e10; // 100%
    uint private constant liqPercent = 9e9; // 90%

    struct Fees {
        uint daoFees;
        uint burnFees;
        uint referralFees;
        uint botFees;
    }
    Fees public openFees = Fees(
        0,
        0,
        0,
        0
    );
    Fees public closeFees = Fees(
        0,
        0,
        0,
        0
    );
    uint public limitOrderPriceRange = 1e8; // 1%

    uint public maxWinPercent;
    uint public vaultFundingPercent;

    IPairsContract private pairsContract;
    IPosition private position;
    IGovNFT private gov;
    ITradingExtension private tradingExtension;

    struct Delay {
        uint delay; // Block number where delay ends
        bool actionType; // True for open, False for close
    }
    mapping(uint => Delay) public blockDelayPassed; // id => Delay
    uint public blockDelay;
    mapping(uint => uint) public limitDelay; // id => block.timestamp

    mapping(address => bool) public allowedVault;

    struct Proxy {
        address proxy;
        uint256 time;
    }

    mapping(address => Proxy) public proxyApprovals;

    constructor(
        address _position,
        address _gov,
        address _pairsContract
    )
    {
        position = IPosition(_position);
        gov = IGovNFT(_gov);
        pairsContract = IPairsContract(_pairsContract);
    }

    // ===== END-USER FUNCTIONS =====

    /**
     * @param _tradeInfo Trade info
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateMarketOrder(
        TradeInfo calldata _tradeInfo,
        PriceData calldata _priceData,
        bytes calldata _signature,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(position.getCount(), true);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
        uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        uint256 _isLong = _tradeInfo.direction ? 1 : 2;
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_tradeInfo.asset, _priceData, _signature, _isLong);
        IPosition.MintTrade memory _mintTrade = IPosition.MintTrade(
            _trader,
            _marginAfterFees,
            _tradeInfo.leverage,
            _tradeInfo.asset,
            _tradeInfo.direction,
            _price,
            _tradeInfo.tpPrice,
            _tradeInfo.slPrice,
            0,
            _tigAsset
        );
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        unchecked {
            if (_tradeInfo.direction) {
                tradingExtension.modifyLongOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_tradeInfo.asset, _tigAsset, true, _positionSize);
            }
        }
        _updateFunding(_tradeInfo.asset, _tigAsset);
        position.mint(
            _mintTrade
        );
        unchecked {
            emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);
        }   
    }

    /**
     * @dev initiate closing position
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed in BP
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _outputToken Token received upon closing trade
     * @param _trader address the trade is initiated for
     */
    function initiateCloseOrder(
        uint _id,
        uint _percent,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _outputToken,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkDelay(_id, false);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit        
        (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);

        if (_percent > DIVISION_CONSTANT || _percent == 0) revert BadClosePercent();
        _closePosition(_id, _percent, _price, _stableVault, _outputToken, false); 
    }

    /**
     * @param _id position id
     * @param _addMargin margin amount used to add to the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _stableVault StableVault address
     * @param _marginAsset Token being used to add to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }

    /**
     * @param _tradeInfo Trade info
     * @param _orderType type of limit order used to open the position
     * @param _price limit price
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function initiateLimitOrder(
        TradeInfo calldata _tradeInfo,
        uint256 _orderType, // 1 limit, 2 stop
        uint256 _price,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();
        tradingExtension.validateTrade(_tradeInfo.asset, _tigAsset, _tradeInfo.margin, _tradeInfo.leverage);
        _checkVault(_tradeInfo.stableVault, _tradeInfo.marginAsset);
        if (_orderType == 0) revert(""5"");
        if (_price == 0) revert NoPrice();
        tradingExtension._setReferral(_tradeInfo.referral, _trader);
        _handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
        _checkSl(_tradeInfo.slPrice, _tradeInfo.direction, _price);
        uint256 _id = position.getCount();
        position.mint(
            IPosition.MintTrade(
                _trader,
                _tradeInfo.margin,
                _tradeInfo.leverage,
                _tradeInfo.asset,
                _tradeInfo.direction,
                _price,
                _tradeInfo.tpPrice,
                _tradeInfo.slPrice,
                _orderType,
                _tigAsset
            )
        );
        limitDelay[_id] = block.timestamp + 4;
        emit PositionOpened(_tradeInfo, _orderType, _price, _id, _trader, _tradeInfo.margin);
    }

    /**
     * @param _id position ID
     * @param _trader address the trade is initiated for
     */
    function cancelLimitOrder(
        uint256 _id,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType == 0) revert();
        IStable(_trade.tigAsset).mintFor(_trader, _trade.margin);
        position.burn(_id);
        emit LimitCancelled(_id, _trader);
    }

    /**
     * @param _id position id
     * @param _marginAsset Token being used to add to the position
     * @param _stableVault StableVault address
     * @param _addMargin margin amount being added to the position
     * @param _permitData data and signature needed for token approval
     * @param _trader address the trade is initiated for
     */
    function addMargin(
        uint256 _id,
        address _marginAsset,
        address _stableVault,
        uint256 _addMargin,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _marginAsset);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        _handleDeposit(_trade.tigAsset, _marginAsset, _addMargin, _stableVault, _permitData, _trader);
        unchecked {
            uint256 _newMargin = _trade.margin + _addMargin;
            uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
            if (_newLeverage < asset.minLeverage) revert(""!lev"");
            position.modifyMargin(_id, _newMargin, _newLeverage);
            emit MarginModified(_id, _newMargin, _newLeverage, true, _trader);
        }
    }

    /**
     * @param _id position id
     * @param _stableVault StableVault address
     * @param _outputToken token the trader will receive
     * @param _removeMargin margin amount being removed from the position
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function removeMargin(
        uint256 _id,
        address _stableVault,
        address _outputToken,
        uint256 _removeMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkVault(_stableVault, _outputToken);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(); //IsLimit
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_trade.asset);
        uint256 _newMargin = _trade.margin - _removeMargin;
        uint256 _newLeverage = _trade.margin * _trade.leverage / _newMargin;
        if (_newLeverage > asset.maxLeverage) revert(""!lev"");
        (uint _assetPrice,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
        (,int256 _payout) = TradingLibrary.pnl(_trade.direction, _assetPrice, _trade.price, _newMargin, _newLeverage, _trade.accInterest);
        unchecked {
            if (_payout <= int256(_newMargin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert LiqThreshold();
        }
        position.modifyMargin(_trade.id, _newMargin, _newLeverage);
        _handleWithdraw(_trade, _stableVault, _outputToken, _removeMargin);
        emit MarginModified(_trade.id, _newMargin, _newLeverage, false, _trader);
    }

    /**
     * @param _type true for TP, false for SL
     * @param _id position id
     * @param _limitPrice TP/SL trigger price
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     * @param _trader address the trade is initiated for
     */
    function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

    /**
     * @param _id position id
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function executeLimitOrder(
        uint _id, 
        PriceData calldata _priceData,
        bytes calldata _signature
    ) 
        external
    {
        unchecked {
            _checkDelay(_id, true);
            tradingExtension._checkGas();
            if (tradingExtension.paused()) revert TradingPaused();
            require(block.timestamp >= limitDelay[_id]);
            IPosition.Trade memory trade = position.trades(_id);
            uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);
            (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);
            if (trade.orderType == 0) revert(""5"");
            if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(""6""); //LimitNotMet
            if (trade.direction && trade.orderType == 1) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 1) {
                if (trade.price > _price) revert(""6""); //LimitNotMet
            } else if (!trade.direction && trade.orderType == 2) {
                if (trade.price < _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } else {
                if (trade.price > _price) revert(""6""); //LimitNotMet
                trade.price = _price;
            } 
            if(trade.direction) {
                trade.price += trade.price * _spread / DIVISION_CONSTANT;
            } else {
                trade.price -= trade.price * _spread / DIVISION_CONSTANT;
            }
            if (trade.direction) {
                tradingExtension.modifyLongOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            } else {
                tradingExtension.modifyShortOi(trade.asset, trade.tigAsset, true, trade.margin*trade.leverage/1e18);
            }
            _updateFunding(trade.asset, trade.tigAsset);
            position.executeLimitOrder(_id, trade.price, trade.margin - _fee);
            emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());
        }
    }

    /**
     * @notice liquidate position
     * @param _id id of the position NFT
     * @param _priceData verifiable off-chain data
     * @param _signature node signature
     */
    function liquidatePosition(
        uint _id,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        unchecked {
            tradingExtension._checkGas();
            IPosition.Trade memory _trade = position.trades(_id);
            if (_trade.orderType != 0) revert(""4""); //IsLimit

            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            (uint256 _positionSizeAfterPrice, int256 _payout) = TradingLibrary.pnl(_trade.direction, _price, _trade.price, _trade.margin, _trade.leverage, _trade.accInterest);
            uint256 _positionSize = _trade.margin*_trade.leverage/1e18;
            if (_payout > int256(_trade.margin*(DIVISION_CONSTANT-liqPercent)/DIVISION_CONSTANT)) revert NotLiquidatable();
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, false, _positionSize);
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _handleCloseFees(_trade.asset, type(uint).max, _trade.tigAsset, _positionSizeAfterPrice, _trade.trader, true);
            position.burn(_id);
            emit PositionLiquidated(_id, _trade.trader, _msgSender());
        }
    }

    /**
     * @dev close position at a pre-set price
     * @param _id id of the position NFT
     * @param _tp true if take profit
     * @param _priceData verifiable off-chain price data
     * @param _signature node signature
     */
    function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }

    /**
     * @notice Trader can approve a proxy wallet address for it to trade on its behalf. Can also provide proxy wallet with gas.
     * @param _proxy proxy wallet address
     * @param _timestamp end timestamp of approval period
     */
    function approveProxy(address _proxy, uint256 _timestamp) external payable {
        proxyApprovals[_msgSender()] = Proxy(
            _proxy,
            _timestamp
        );
        payable(_proxy).transfer(msg.value);
    }

    // ===== INTERNAL FUNCTIONS =====

    /**
     * @dev close the initiated position.
     * @param _id id of the position NFT
     * @param _percent percent of the position being closed
     * @param _price pair price
     * @param _stableVault StableVault address
     * @param _outputToken Token that trader will receive
     * @param _isBot false if closed via market order
     */
    function _closePosition(
        uint _id,
        uint _percent,
        uint _price,
        address _stableVault,
        address _outputToken,
        bool _isBot
    )
        internal
    {
        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);
        position.setAccInterest(_id);
        _updateFunding(_trade.asset, _trade.tigAsset);
        if (_percent < DIVISION_CONSTANT) {
            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(""!size"");
            position.reducePosition(_id, _percent);
        } else {
            position.burn(_id);
        }
        uint256 _toMint;
        if (_payout > 0) {
            unchecked {
                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);
                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {
                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;
                }
            }
            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);
        }
        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);
    }

    /**
     * @dev handle stablevault deposits for different trading functions
     * @param _tigAsset tigAsset token address
     * @param _marginAsset token being deposited into stablevault
     * @param _margin amount being deposited
     * @param _stableVault StableVault address
     * @param _permitData Data for approval via permit
     * @param _trader Trader address to take tokens from
     */
    function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {
        IStable tigAsset = IStable(_tigAsset);
        if (_tigAsset != _marginAsset) {
            if (_permitData.usePermit) {
                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);
            }
            uint256 _balBefore = tigAsset.balanceOf(address(this));
            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());
            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);
            IERC20(_marginAsset).approve(_stableVault, type(uint).max);
            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);
            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();
            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));
        } else {
            tigAsset.burnFrom(_trader, _margin);
        }        
    }

    /**
     * @dev handle stablevault withdrawals for different trading functions
     * @param _trade Position info
     * @param _stableVault StableVault address
     * @param _outputToken Output token address
     * @param _toMint Amount of tigAsset minted to be used for withdrawal
     */
    function _handleWithdraw(IPosition.Trade memory _trade, address _stableVault, address _outputToken, uint _toMint) internal {
        IStable(_trade.tigAsset).mintFor(address(this), _toMint);
        if (_outputToken == _trade.tigAsset) {
            IERC20(_outputToken).transfer(_trade.trader, _toMint);
        } else {
            uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));
            IStableVault(_stableVault).withdraw(_outputToken, _toMint);
            if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();
            IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);
        }        
    }

    /**
     * @dev handle fees distribution for opening
     * @param _asset asset id
     * @param _positionSize position size
     * @param _trader trader address
     * @param _tigAsset tigAsset address
     * @param _isBot false if opened via market order
     * @return _feePaid total fees paid during opening
     */
    function _handleOpenFees(
        uint _asset,
        uint _positionSize,
        address _trader,
        address _tigAsset,
        bool _isBot
    )
        internal
        returns (uint _feePaid)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = openFees;
        unchecked {
            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;
            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;
        }
        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _referrer,
                    _positionSize
                    * _fees.referralFees // get referral fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;
        }
        if (_isBot) {
            unchecked {
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _positionSize
                    * _fees.botFees // get bot fee%
                    / DIVISION_CONSTANT // divide by 100%
                );
            }
            _fees.daoFees = _fees.daoFees - _fees.botFees;
        } else {
            _fees.botFees = 0;
        }
        unchecked {
            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;
            _feePaid =
                _positionSize
                * (_fees.burnFees + _fees.botFees) // get total fee%
                / DIVISION_CONSTANT // divide by 100%
                + _daoFeesPaid;
            emit FeesDistributed(
                _tigAsset,
                _daoFeesPaid,
                _positionSize * _fees.burnFees / DIVISION_CONSTANT,
                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,
                _positionSize * _fees.botFees / DIVISION_CONSTANT,
                _referrer
            );
            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        }
        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));
    }

    /**
     * @dev handle fees distribution for closing
     * @param _asset asset id
     * @param _payout payout to trader before fees
     * @param _tigAsset margin asset
     * @param _positionSize position size
     * @param _trader trader address
     * @param _isBot false if closed via market order
     * @return payout_ payout to trader after fees
     */
    function _handleCloseFees(
        uint _asset,
        uint _payout,
        address _tigAsset,
        uint _positionSize,
        address _trader,
        bool _isBot
    )
        internal
        returns (uint payout_)
    {
        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);
        Fees memory _fees = closeFees;
        uint _daoFeesPaid;
        uint _burnFeesPaid;
        uint _referralFeesPaid;
        unchecked {
            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
        }
        uint _botFeesPaid;
        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));
        if (_referrer != address(0)) {
            unchecked {
                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
            }
            IStable(_tigAsset).mintFor(
                _referrer,
                _referralFeesPaid
            );
             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;
        }
        if (_isBot) {
            unchecked {
                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;
                IStable(_tigAsset).mintFor(
                    _msgSender(),
                    _botFeesPaid
                );
            }
            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;
        }
        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);
        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;
        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);
        IStable(_tigAsset).approve(address(gov), type(uint).max);
        gov.distribute(_tigAsset, _daoFeesPaid);
        return payout_;
    }

    /**
     * @dev update funding rates after open interest changes
     * @param _asset asset id
     * @param _tigAsset tigAsset used for OI
     */
    function _updateFunding(uint256 _asset, address _tigAsset) internal {
        position.updateFunding(
            _asset,
            _tigAsset,
            pairsContract.idToOi(_asset, _tigAsset).longOi,
            pairsContract.idToOi(_asset, _tigAsset).shortOi,
            pairsContract.idToAsset(_asset).baseFundingRate,
            vaultFundingPercent
        );
    }

    /**
     * @dev check that SL price is valid compared to market price
     * @param _sl SL price
     * @param _direction long/short
     * @param _price market price
     */
    function _checkSl(uint _sl, bool _direction, uint _price) internal pure {
        if (_direction) {
            if (_sl > _price) revert(""3""); //BadStopLoss
        } else {
            if (_sl < _price && _sl != 0) revert(""3""); //BadStopLoss
        }
    }

    /**
     * @dev check that trader address owns the position
     * @param _id position id
     * @param _trader trader address
     */
    function _checkOwner(uint _id, address _trader) internal view {
        if (position.ownerOf(_id) != _trader) revert(""2""); //NotPositionOwner   
    }

    /**
     * @notice Check that sufficient time has passed between opening and closing
     * @dev This is to prevent profitable opening and closing in the same tx with two different prices in the ""valid signature pool"".
     * @param _id position id
     * @param _type true for opening, false for closing
     */
    function _checkDelay(uint _id, bool _type) internal {
        unchecked {
            Delay memory _delay = blockDelayPassed[_id];
            if (_delay.actionType == _type) {
                blockDelayPassed[_id].delay = block.number + blockDelay;
            } else {
                if (block.number < _delay.delay) revert(""0""); //Wait
                blockDelayPassed[_id].delay = block.number + blockDelay;
                blockDelayPassed[_id].actionType = _type;
            }
        }
    }

    /**
     * @dev Check that the stablevault input is whitelisted and the margin asset is whitelisted in the vault
     * @param _stableVault StableVault address
     * @param _token Margin asset token address
     */
    function _checkVault(address _stableVault, address _token) internal view {
        require(allowedVault[_stableVault], ""Unapproved stablevault"");
        require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), ""Token not approved in vault"");
    }

    /**
     * @dev Check that the trader has approved the proxy address to trade for it
     * @param _trader Trader address
     */
    function _validateProxy(address _trader) internal view {
        if (_trader != _msgSender()) {
            Proxy memory _proxy = proxyApprovals[_trader];
            require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, ""Proxy not approved"");
        }
    }

    // ===== GOVERNANCE-ONLY =====

    /**
     * @dev Sets block delay between opening and closing
     * @notice In blocks not seconds
     * @param _blockDelay delay amount
     */
    function setBlockDelay(
        uint _blockDelay
    )
        external
        onlyOwner
    {
        blockDelay = _blockDelay;
    }

    /**
     * @dev Whitelists a stablevault contract address
     * @param _stableVault StableVault address
     * @param _bool true if allowed
     */
    function setAllowedVault(
        address _stableVault,
        bool _bool
    )
        external
        onlyOwner
    {
        allowedVault[_stableVault] = _bool;
    }

    /**
     * @dev Sets max payout % compared to margin
     * @param _maxWinPercent payout %
     */
    function setMaxWinPercent(
        uint _maxWinPercent
    )
        external
        onlyOwner
    {
        maxWinPercent = _maxWinPercent;
    }

    /**
     * @dev Sets executable price range for limit orders
     * @param _range price range in %
     */
    function setLimitOrderPriceRange(uint _range) external onlyOwner {
        limitOrderPriceRange = _range;
    }

    /**
     * @dev Sets the fees for the trading protocol
     * @param _open True if open fees are being set
     * @param _daoFees Fees distributed to the DAO
     * @param _burnFees Fees which get burned
     * @param _referralFees Fees given to referrers
     * @param _botFees Fees given to bots that execute limit orders
     * @param _percent Percent of earned funding fees going to StableVault
     */
    function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {
        unchecked {
            require(_daoFees >= _botFees+_referralFees*2);
            if (_open) {
                openFees.daoFees = _daoFees;
                openFees.burnFees = _burnFees;
                openFees.referralFees = _referralFees;
                openFees.botFees = _botFees;
            } else {
                closeFees.daoFees = _daoFees;
                closeFees.burnFees = _burnFees;
                closeFees.referralFees = _referralFees;
                closeFees.botFees = _botFees;                
            }
            require(_percent <= DIVISION_CONSTANT);
            vaultFundingPercent = _percent;
        }
    }

    /**
     * @dev Sets the extension contract address for trading
     * @param _ext extension contract address
     */
    function setTradingExtension(
        address _ext
    ) external onlyOwner() {
        tradingExtension = ITradingExtension(_ext);
    }

    // ===== EVENTS =====

    event PositionOpened(
        TradeInfo _tradeInfo,
        uint _orderType,
        uint _price,
        uint _id,
        address _trader,
        uint _marginAfterFees
    );

    event PositionClosed(
        uint _id,
        uint _closePrice,
        uint _percent,
        uint _payout,
        address _trader,
        address _executor
    );

    event PositionLiquidated(
        uint _id,
        address _trader,
        address _executor
    );

    event LimitOrderExecuted(
        uint _asset,
        bool _direction,
        uint _openPrice,
        uint _lev,
        uint _margin,
        uint _id,
        address _trader,
        address _executor
    );

    event UpdateTPSL(
        uint _id,
        bool _isTp,
        uint _price,
        address _trader
    );

    event LimitCancelled(
        uint _id,
        address _trader
    );

    event MarginModified(
        uint _id,
        uint _newMargin,
        uint _newLeverage,
        bool _isMarginAdded,
        address _trader
    );

    event AddToPosition(
        uint _id,
        uint _newMargin,
        uint _newPrice,
        address _trader
    );

    event FeesDistributed(
        address _tigAsset,
        uint _daoFees,
        uint _burnFees,
        uint _refFees,
        uint _botFees,
        address _referrer
    );
}",9443
RealWorld_TA_192_Position_RealWorld_20240816215221.log,192,Position,342060,6767,348827,187.0,1.84564,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/utils/Counters.sol"";
import ""./utils/MetaContext.sol"";
import ""./interfaces/IPosition.sol"";

contract Position is ERC721Enumerable, MetaContext, IPosition {

    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {
        return ERC721.ownerOf(_id);
    }

    using Counters for Counters.Counter;
    uint constant public DIVISION_CONSTANT = 1e10; // 100%

    mapping(uint => mapping(address => uint)) public vaultFundingPercent;

    mapping(address => bool) private _isMinter; // Trading contract should be minter
    mapping(uint256 => Trade) private _trades; // NFT id to Trade

    uint256[] private _openPositions;
    mapping(uint256 => uint256) private _openPositionsIndexes;

    mapping(uint256 => uint256[]) private _assetOpenPositions;
    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;

    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset
    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index

    // Funding
    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;
    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;
    mapping(uint256 => mapping(address => uint256)) private lastUpdate;
    mapping(uint256 => int256) private initId;
    mapping(uint256 => mapping(address => uint256)) private longOi;
    mapping(uint256 => mapping(address => uint256)) private shortOi;

    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }
    function trades(uint _id) public view returns (Trade memory) {
        Trade memory _trade = _trades[_id];
        _trade.trader = ownerOf(_id);
        if (_trade.orderType > 0) return _trade;
        
        int256 _pendingFunding;
        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {
            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);
            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {
                _pendingFunding = -_pendingFunding;
            } else {
                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;
            }
        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {
            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);
            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {
                _pendingFunding = -_pendingFunding;
            } else {
                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;
            }
        }
        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];
        
        return _trade;
    }
    function openPositions() public view returns (uint256[] memory) { return _openPositions; }
    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }
    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }
    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }
    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }
    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }

    Counters.Counter private _tokenIds;
    string public baseURI;

    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {
        baseURI = _setBaseURI;
        _tokenIds.increment();
    }

    function _baseURI() internal override view returns (string memory) {
        return baseURI;
    }

    function setBaseURI(string memory _newBaseURI) external onlyOwner {
        baseURI = _newBaseURI;
    }

    /**
    * @notice Update funding rate after open interest change
    * @dev only callable by minter
    * @param _asset pair id
    * @param _tigAsset tigAsset token address
    * @param _longOi long open interest
    * @param _shortOi short open interest
    * @param _baseFundingRate base funding rate of a pair
    * @param _vaultFundingPercent percent of earned funding going to the stablevault
    */
    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {
        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {
            if (longOi[_asset][_tigAsset] > 0) {
                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;
            }
            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);

        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {
            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);
            if (shortOi[_asset][_tigAsset] > 0) {
                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;
            }
        }
        lastUpdate[_asset][_tigAsset] = block.timestamp;
        int256 _oiDelta;
        if (_longOi > _shortOi) {
            _oiDelta = int256(_longOi)-int256(_shortOi);
        } else {
            _oiDelta = int256(_shortOi)-int256(_longOi);
        }
        
        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;
        longOi[_asset][_tigAsset] = _longOi;
        shortOi[_asset][_tigAsset] = _shortOi;
        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;
    }

    /**
    * @notice mint a new position nft
    * @dev only callable by minter
    * @param _mintTrade New trade params in struct
    */
    function mint(
        MintTrade memory _mintTrade
    ) external onlyMinter {
        uint newTokenID = _tokenIds.current();

        Trade storage newTrade = _trades[newTokenID];
        newTrade.margin = _mintTrade.margin;
        newTrade.leverage = _mintTrade.leverage;
        newTrade.asset = _mintTrade.asset;
        newTrade.direction = _mintTrade.direction;
        newTrade.price = _mintTrade.price;
        newTrade.tpPrice = _mintTrade.tp;
        newTrade.slPrice = _mintTrade.sl;
        newTrade.orderType = _mintTrade.orderType;
        newTrade.id = newTokenID;
        newTrade.tigAsset = _mintTrade.tigAsset;

        _safeMint(_mintTrade.account, newTokenID);
        if (_mintTrade.orderType > 0) {
            _limitOrders[_mintTrade.asset].push(newTokenID);
            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;
        } else {
            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;
            _openPositions.push(newTokenID);
            _openPositionsIndexes[newTokenID] = _openPositions.length-1;

            _assetOpenPositions[_mintTrade.asset].push(newTokenID);
            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;
        }
        _tokenIds.increment();
    }

    /**
     * @param _id id of the position NFT
     * @param _price price used for execution
     * @param _newMargin margin after fees
     */
    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {
        Trade storage _trade = _trades[_id];
        if (_trade.orderType == 0) {
            return;
        }
        _trade.orderType = 0;
        _trade.price = _price;
        _trade.margin = _newMargin;
        uint _asset = _trade.asset;
        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];
        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];
        delete _limitOrderIndexes[_asset][_id];
        _limitOrders[_asset].pop();

        _openPositions.push(_id);
        _openPositionsIndexes[_id] = _openPositions.length-1;
        _assetOpenPositions[_asset].push(_id);
        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;

        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;
    }

    /**
    * @notice modifies margin and leverage
    * @dev only callable by minter
    * @param _id position id
    * @param _newMargin new margin amount
    * @param _newLeverage new leverage amount
    */
    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {
        _trades[_id].margin = _newMargin;
        _trades[_id].leverage = _newLeverage;
    }

    /**
    * @notice modifies margin and entry price
    * @dev only callable by minter
    * @param _id position id
    * @param _newMargin new margin amount
    * @param _newPrice new entry price
    */
    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {
        _trades[_id].margin = _newMargin;
        _trades[_id].price = _newPrice;
        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;
    }

    /**
    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding
    * @dev only callable by minter
    * @param _id position id
    */
    function setAccInterest(uint256 _id) external onlyMinter {
        _trades[_id].accInterest = trades(_id).accInterest;
    }

    /**
    * @notice Reduces position size by %
    * @dev only callable by minter
    * @param _id position id
    * @param _percent percent of a position being closed
    */
    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {
        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);
        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;
        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;
    }

    /**
    * @notice change a position tp price
    * @dev only callable by minter
    * @param _id position id
    * @param _tpPrice tp price
    */
    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {
        _trades[_id].tpPrice = _tpPrice;
    }

    /**
    * @notice change a position sl price
    * @dev only callable by minter
    * @param _id position id
    * @param _slPrice sl price
    */
    function modifySl(uint _id, uint _slPrice) external onlyMinter {
        _trades[_id].slPrice = _slPrice;
    }

    /**
    * @dev Burns an NFT and it's data
    * @param _id ID of the trade
    */
    function burn(uint _id) external onlyMinter {
        _burn(_id);
        uint _asset = _trades[_id].asset;
        if (_trades[_id].orderType > 0) {
            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];
            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];
            delete _limitOrderIndexes[_asset][_id];
            _limitOrders[_asset].pop();            
        } else {
            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];
            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];
            delete _assetOpenPositionsIndexes[_asset][_id];
            _assetOpenPositions[_asset].pop();  

            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];
            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];
            delete _openPositionsIndexes[_id];
            _openPositions.pop();              
        }
        delete _trades[_id];
    }

    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {
        return _assetOpenPositions[_asset].length;
    }

    function limitOrdersLength(uint _asset) external view returns (uint256) {
        return _limitOrders[_asset].length;
    }

    function getCount() external view returns (uint) {
        return _tokenIds.current();
    }

    function userTrades(address _user) external view returns (uint[] memory) {
        uint[] memory _ids = new uint[](balanceOf(_user));
        for (uint i=0; i<_ids.length; i++) {
            _ids[i] = tokenOfOwnerByIndex(_user, i);
        }
        return _ids;
    }

    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {
        uint[] memory _ids = new uint[](_to-_from);
        for (uint i=0; i<_ids.length; i++) {
            _ids[i] = _openPositions[i+_from];
        }
        return _ids;
    }

    function setMinter(address _minter, bool _bool) external onlyOwner {
        _isMinter[_minter] = _bool;
    }    

    modifier onlyMinter() {
        require(_isMinter[_msgSender()], ""!Minter"");
        _;
    }

    // META-TX
    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {
        return MetaContext._msgSender();
    }
    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {
        return MetaContext._msgData();
    }
}",3879
RealWorld_TA_193_AddBuySellRemove.t_RealWorld_20240816084415.log,193,AddBuySellRemove.t,58791,2476,61267,93.0,0.343475,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract AddBuySellRemoveTest is Fixture {
    function testItAddsBuysSellsRemovesCorrectAmount(
        uint256 addBaseTokenAmount,
        uint256 addFractionalTokenAmount,
        uint256 buyTokenAmount
    ) public {
        addBaseTokenAmount = bound(addBaseTokenAmount, 100, type(uint96).max);
        addFractionalTokenAmount = bound(addFractionalTokenAmount, 2, 10_000_000 * 1e18);
        buyTokenAmount = bound(buyTokenAmount, 1, addFractionalTokenAmount - 1);

        // add liquidity
        deal(address(usd), address(this), addBaseTokenAmount, true);
        deal(address(p), address(this), addFractionalTokenAmount, true);
        uint256 lpTokenAmount = Math.sqrt(addBaseTokenAmount * addFractionalTokenAmount);
        usd.approve(address(p), type(uint256).max);
        p.add(addBaseTokenAmount, addFractionalTokenAmount, lpTokenAmount);

        // buy some amount
        uint256 baseTokenBuyAmount = p.buyQuote(buyTokenAmount);
        deal(address(usd), address(this), baseTokenBuyAmount, true);
        p.buy(buyTokenAmount, baseTokenBuyAmount);

        // remove some fraction of liquidity
        uint256 removeLpTokenAmount = lpTokenAmount / 10;
        uint256 expectedBaseTokenAmount = p.baseTokenReserves() * removeLpTokenAmount / lpToken.totalSupply();
        uint256 expectedFractionalTokenAmount =
            p.fractionalTokenReserves() * removeLpTokenAmount / lpToken.totalSupply();
        (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount) = p.remove(removeLpTokenAmount, 0, 0);

        assertEq(baseTokenOutputAmount, expectedBaseTokenAmount, ""Should have removed correct base token amount"");
        assertEq(
            fractionalTokenOutputAmount,
            expectedFractionalTokenAmount,
            ""Should have removed correct fractional token amount""
        );
    }
}",477
RealWorld_TA_193_MockERC721_RealWorld_20240816081551.log,193,MockERC721,27901,2684,30585,100.0,0.193185,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""solmate/tokens/ERC721.sol"";

contract MockERC721 is ERC721 {
    string public baseURI = ""yeet"";

    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}

    function mint(address to, uint256 id) public {
        _mint(to, id);
    }

    function tokenURI(uint256) public view override returns (string memory) {
        return baseURI;
    }
}",107
RealWorld_TA_193_CreateFakeBeanz.s_RealWorld_20240816084745.log,193,CreateFakeBeanz.s,41182,2515,43697,96.0,0.25621,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeBeanz is ERC721A {
    constructor() ERC721A(""Fake Beanz"", ""BEANZ"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(
            abi.encodePacked(
                ""https://ikzttp.mypinata.cloud/ipfs/QmPZKyuRw4nQTD6S6R5HaNAXwoQVMj8YydDmad3rC985WZ/"", _toString(tokenId)
            )
        );
    }
}

contract CreateFakeBeanzScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeBeanz fakeBeanz = new FakeBeanz();
        console.log(""fake Beanz:"", address(fakeBeanz));

        fakeBeanz.mint(msg.sender, 250);
        fakeBeanz.mint(msg.sender, 250);
    }
}",261
RealWorld_TA_193_Destroy.t_RealWorld_20240816081907.log,193,Destroy.t,61833,1846,63679,94.0,0.346085,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../shared/Fixture.t.sol"";

contract DestroyTest is Fixture {
    using stdStorage for StdStorage;

    event Destroy(address indexed nft, address indexed baseToken, bytes32 indexed merkleRoot);

    address public prankedAddress;

    function setUp() public {
        prankedAddress = address(0xbabe);

        // forgefmt: disable-next-item
        stdstore
            .target(address(c))
            .sig(""pairs(address,address,bytes32)"")
            .with_key(address(this))
            .with_key(address(this))
            .with_key(bytes32(0))
            .checked_write(prankedAddress);
    }

    function testItRemovesPairFromMapping() public {
        // act
        vm.prank(prankedAddress);
        c.destroy(address(this), address(this), bytes32(0));

        // assert
        assertEq(c.pairs(address(this), address(this), bytes32(0)), address(0), ""Should have removed pair"");
    }

    function testOnlyPairCanRemoveItself() public {
        // act
        vm.expectRevert(""Only pair can destroy itself"");
        c.destroy(address(this), address(this), bytes32(0));
    }

    function testItEmitsDestroyEvent() public {
        // arrange
        vm.expectEmit(true, true, true, true);
        emit Destroy(address(this), address(this), bytes32(0));

        // act
        vm.prank(prankedAddress);
        c.destroy(address(this), address(this), bytes32(0));
    }

    function testItRemovesPairFromMapping(address nft, address baseToken, bytes32 merkleRoot, address _prankedAddress)
        public
    {
        // arrange
        // forgefmt: disable-next-item
        stdstore
            .target(address(c))
            .sig(""pairs(address,address,bytes32)"")
            .with_key(nft)
            .with_key(baseToken)
            .with_key(merkleRoot)
            .depth(0)
            .checked_write(_prankedAddress);

        // act
        vm.prank(_prankedAddress);
        c.destroy(nft, baseToken, merkleRoot);

        // assert
        assertEq(c.pairs(nft, baseToken, merkleRoot), address(0), ""Should have removed pair"");
    }
}",511
RealWorld_TA_193_Sell.t_RealWorld_20240816083143.log,193,Sell.t,90233,3300,93533,113.0,0.517165,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract SellTest is Fixture {
    event Sell(uint256 inputAmount, uint256 outputAmount);

    uint256 public inputAmount = 0.337e18;
    uint256 public minOutputAmount;

    function setUp() public {
        uint256 baseTokenAmount = 30.123e18;
        uint256 fractionalTokenAmount = 99.99e18;

        deal(address(usd), address(this), baseTokenAmount, true);
        deal(address(p), address(this), fractionalTokenAmount, true);

        usd.approve(address(p), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        minOutputAmount =
            (inputAmount * 997 * p.baseTokenReserves()) / ((p.fractionalTokenReserves() * 1000 + inputAmount * 997));
        deal(address(p), address(this), inputAmount, true);

        deal(address(ethPair), address(this), fractionalTokenAmount, true);
        ethPair.add{value: baseTokenAmount}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
        deal(address(ethPair), address(this), inputAmount, true);
    }

    function testItReturnsOutputAmount() public {
        // arrange
        uint256 expectedOutputAmount = minOutputAmount;

        // act
        uint256 outputAmount = p.sell(inputAmount, expectedOutputAmount);

        // assert
        assertEq(outputAmount, expectedOutputAmount, ""Should have returned output amount"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 balanceBefore = usd.balanceOf(address(p));
        uint256 thisBalanceBefore = usd.balanceOf(address(this));

        // act
        p.sell(inputAmount, minOutputAmount);

        // assert
        assertEq(
            balanceBefore - usd.balanceOf(address(p)), minOutputAmount, ""Should have transferred base tokens from pair""
        );
        assertEq(
            usd.balanceOf(address(this)) - thisBalanceBefore,
            minOutputAmount,
            ""Should have transferred base tokens to sender""
        );
    }

    function testItTransfersFractionalTokens() public {
        // arrange
        uint256 balanceBefore = p.balanceOf(address(p));
        uint256 thisBalanceBefore = p.balanceOf(address(this));

        // act
        p.sell(inputAmount, minOutputAmount);

        // assert
        assertEq(
            thisBalanceBefore - p.balanceOf(address(this)),
            inputAmount,
            ""Should have transferred fractional tokens from sender""
        );
        assertEq(
            p.balanceOf(address(p)) - balanceBefore, inputAmount, ""Should have transferred fractional tokens to pair""
        );
    }

    function testItRevertsSlippageOnSell() public {
        // arrange
        minOutputAmount += 1; // add 1 to cause revert

        // act
        vm.expectRevert(""Slippage: amount out"");
        p.sell(inputAmount, minOutputAmount);
    }

    function testItTransfersEther() public {
        // arrange
        uint256 balanceBefore = address(ethPair).balance;
        uint256 thisBalanceBefore = address(this).balance;

        // act
        ethPair.sell(inputAmount, minOutputAmount);

        // assert
        assertEq(balanceBefore - address(ethPair).balance, minOutputAmount, ""Should have transferred ether from pair"");
        assertEq(address(this).balance - thisBalanceBefore, minOutputAmount, ""Should have transferred ether to sender"");
    }

    function testItEmitsSellEvent() public {
        // act
        vm.expectEmit(true, true, true, true);
        emit Sell(inputAmount, minOutputAmount);
        p.sell(inputAmount, minOutputAmount);
    }
}",850
RealWorld_TA_193_BuySell.t_RealWorld_20240816084243.log,193,BuySell.t,55951,2741,58692,90.0,0.334575,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract BuySellTest is Fixture {
    function setUp() public {
        uint256 baseTokenAmount = 100e18;
        uint256 fractionalTokenAmount = 100e18;

        deal(address(usd), address(this), baseTokenAmount, true);
        deal(address(p), address(this), fractionalTokenAmount, true);

        usd.approve(address(p), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        deal(address(ethPair), address(this), fractionalTokenAmount, true);
        ethPair.add{value: baseTokenAmount}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItBuysSellsEqualAmounts(uint256 outputAmount) public {
        outputAmount = bound(outputAmount, 1e2, p.fractionalTokenReserves() - 1e18);
        uint256 maxInputAmount =
            (outputAmount * p.baseTokenReserves() * 1000) / ((p.fractionalTokenReserves() - outputAmount) * 997);
        deal(address(usd), address(this), maxInputAmount, true);

        // act
        p.buy(outputAmount, maxInputAmount);
        p.sell(outputAmount, 0);

        // assert
        assertApproxEqAbs(
            usd.balanceOf(address(this)),
            maxInputAmount,
            maxInputAmount - (((maxInputAmount * 997) / 1000) * 997) / 1000, // allow margin of error for approx. fee amount
            ""Should have bought and sold equal amounts of assets""
        );

        assertGt(
            maxInputAmount, usd.balanceOf(address(this)), ""Should have less usd than starting with because of fees""
        );
    }
}",442
RealWorld_TA_193_Buy.t_RealWorld_20240816083538.log,193,Buy.t,110622,3028,113650,114.0,0.61367,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract BuyTest is Fixture {
    event Buy(uint256 inputAmount, uint256 outputAmount);

    uint256 public outputAmount = 0.1e18;
    uint256 public maxInputAmount;

    function setUp() public {
        uint256 baseTokenAmount = 100e18;
        uint256 fractionalTokenAmount = 30.123e18;

        deal(address(usd), address(this), baseTokenAmount, true);
        deal(address(p), address(this), fractionalTokenAmount, true);

        usd.approve(address(p), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        maxInputAmount =
            (outputAmount * p.baseTokenReserves() * 1000) / ((p.fractionalTokenReserves() - outputAmount) * 997);
        deal(address(usd), address(this), maxInputAmount, true);

        deal(address(ethPair), address(this), fractionalTokenAmount, true);
        ethPair.add{value: baseTokenAmount}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItReturnsInputAmount() public {
        // arrange
        uint256 expectedInputAmount = maxInputAmount;

        // act
        uint256 inputAmount = p.buy(outputAmount, maxInputAmount);

        // assert
        assertEq(inputAmount, expectedInputAmount, ""Should have returned input amount"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 balanceBefore = usd.balanceOf(address(p));
        uint256 thisBalanceBefore = usd.balanceOf(address(this));

        // act
        p.buy(outputAmount, maxInputAmount);

        // assert
        assertEq(
            usd.balanceOf(address(p)) - balanceBefore, maxInputAmount, ""Should have transferred base tokens to pair""
        );
        assertEq(
            thisBalanceBefore - usd.balanceOf(address(this)),
            maxInputAmount,
            ""Should have transferred base tokens from sender""
        );
    }

    function testItTransfersFractionalTokens() public {
        // arrange
        uint256 balanceBefore = p.balanceOf(address(p));
        uint256 thisBalanceBefore = p.balanceOf(address(this));

        // act
        p.buy(outputAmount, maxInputAmount);

        // assert
        assertEq(
            p.balanceOf(address(this)) - thisBalanceBefore,
            outputAmount,
            ""Should have transferred fractional tokens from sender""
        );
        assertEq(
            balanceBefore - p.balanceOf(address(p)), outputAmount, ""Should have transferred fractional tokens to pair""
        );
    }

    function testItRevertsSlippageOnBuy() public {
        // arrange
        maxInputAmount -= 1; // subtract 1 to cause revert

        // act
        vm.expectRevert(""Slippage: amount in"");
        p.buy(outputAmount, maxInputAmount);
    }

    function testItRevertsIfValueIsGreaterThanZeroAndBaseTokenIsNot0() public {
        // act
        vm.expectRevert(""Invalid ether input"");
        p.buy{value: maxInputAmount}(outputAmount, maxInputAmount);
    }

    function testItTransfersEther() public {
        // arrange
        uint256 balanceBefore = address(ethPair).balance;
        uint256 thisBalanceBefore = address(this).balance;

        // act
        ethPair.buy{value: maxInputAmount}(outputAmount, maxInputAmount);

        // assert
        assertEq(address(ethPair).balance - balanceBefore, maxInputAmount, ""Should have transferred ether to pair"");
        assertEq(thisBalanceBefore - address(this).balance, maxInputAmount, ""Should have transferred ether from sender"");
    }

    function testItRefundsSurplusEther() public {
        // arrange
        uint256 surplus = 500;
        maxInputAmount += surplus;
        uint256 balanceBefore = address(ethPair).balance;
        uint256 thisBalanceBefore = address(this).balance;

        // act
        ethPair.buy{value: maxInputAmount}(outputAmount, maxInputAmount);

        // assert
        assertEq(
            address(ethPair).balance - balanceBefore, maxInputAmount - surplus, ""Should have transferred ether to pair""
        );
        assertEq(
            thisBalanceBefore - address(this).balance,
            maxInputAmount - surplus,
            ""Should have transferred ether from sender""
        );
    }

    function testItRevertsIfMaxInputAmountIsNotEqualToValue() public {
        // act
        vm.expectRevert(""Invalid ether input"");
        ethPair.buy{value: maxInputAmount + 100}(outputAmount, maxInputAmount);
    }

    function testItEmitsBuyEvent() public {
        // act
        vm.expectEmit(true, true, true, true);
        emit Buy(maxInputAmount, outputAmount);
        p.buy(outputAmount, maxInputAmount);
    }
}",1095
RealWorld_TA_193_CreateFakeInvisibleFriends.s_RealWorld_20240816085552.log,193,CreateFakeInvisibleFriends.s,39808,2792,42600,97.0,0.25488,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeInvisibleFriends is ERC721A {
    constructor() ERC721A(""Fake Invisible Friends"", ""INVSBLE"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(abi.encodePacked("" ipfs://QmarGRwVKPaCe2s5QSSTMEdbYDwKxFz6bAn58YZPPcWc7k/"", _toString(tokenId)));
    }
}

contract CreateFakeInvisibleFriendsScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeInvisibleFriends fakeInvisibleFriends = new FakeInvisibleFriends();
        console.log(""fake Invisble friends:"", address(fakeInvisibleFriends));

        fakeInvisibleFriends.mint(msg.sender, 250);
        fakeInvisibleFriends.mint(msg.sender, 250);
    }
}",251
RealWorld_TA_193_Wrap.t_RealWorld_20240816083923.log,193,Wrap.t,59289,2326,61615,95.0,0.342965,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract WrapTest is Fixture {
    event Wrap(uint256[] tokenIds);

    uint256[] public tokenIds;
    bytes32[][] public proofs;

    function setUp() public {
        bayc.setApprovalForAll(address(p), true);

        for (uint256 i = 0; i < 5; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }
    }

    function testItTransfersTokens() public {
        // act
        p.wrap(tokenIds, proofs);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(p), ""Should have sent bayc to pair"");
        }
    }

    function testItMintsFractionalTokens() public {
        // arrange
        uint256 expectedFractionalTokens = tokenIds.length * 1e18;

        // act
        p.wrap(tokenIds, proofs);

        // assert
        assertEq(p.balanceOf(address(this)), expectedFractionalTokens, ""Should have minted fractional tokens to sender"");
        assertEq(p.totalSupply(), expectedFractionalTokens, ""Should have minted fractional tokens"");
    }

    function testItEmitsWrapEvent() public {
        // act
        vm.expectEmit(true, true, true, true);
        emit Wrap(tokenIds);
        p.wrap(tokenIds, proofs);
    }

    function testItAddsWithMerkleProof() public {
        // arrange
        Pair pair = createPairScript.create(address(bayc), address(usd), ""YEET-mids.json"", address(c));
        proofs = createPairScript.generateMerkleProofs(""YEET-mids.json"", tokenIds);
        bayc.setApprovalForAll(address(pair), true);

        // act
        pair.wrap(tokenIds, proofs);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(pair), ""Should have sent bayc to pair"");
        }
    }
}",484
RealWorld_TA_193_Add.t_RealWorld_20240816082216.log,193,Add.t,231116,2587,233703,119.0,1.20732,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";
import ""../../../script/CreatePair.s.sol"";

contract AddTest is Fixture {
    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);

    uint256 public baseTokenAmount = 100;
    uint256 public fractionalTokenAmount = 30;

    function setUp() public {
        deal(address(usd), address(this), baseTokenAmount, true);
        deal(address(p), address(this), fractionalTokenAmount, true);
        deal(address(ethPair), address(this), fractionalTokenAmount, true);

        usd.approve(address(p), type(uint256).max);
    }

    function testItInitMintsLpTokensToSender() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        uint256 expectedLpTokenAmount = minLpTokenAmount;

        // act
        uint256 lpTokenAmount = p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(lpToken.balanceOf(address(this)), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(lpToken.totalSupply(), expectedLpTokenAmount, ""Should have increased lp supply"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        uint256 balanceBefore = usd.balanceOf(address(this));

        // act
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        // assert
        uint256 balanceAfter = usd.balanceOf(address(this));
        assertEq(balanceBefore - balanceAfter, baseTokenAmount, ""Should transferred base tokens from sender"");
        assertEq(usd.balanceOf(address(p)), baseTokenAmount, ""Should have transferred base tokens to pair"");
    }

    function testItTransfersFractionalTokens() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        uint256 balanceBefore = p.balanceOf(address(this));

        // act
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        // assert
        assertEq(p.balanceOf(address(p)), fractionalTokenAmount, ""Should have transferred fractional tokens to pair"");
        assertEq(
            balanceBefore - p.balanceOf(address(this)),
            fractionalTokenAmount,
            ""Should transferred fractional tokens from sender""
        );
    }

    function testItRevertsSlippageOnInitMint() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount) + 1; // increase 1 to cause revert

        // act
        vm.expectRevert(""Slippage: lp token amount out"");
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItMintsLpTokensAfterInit() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount); // initial add
        uint256 lpTokenSupplyBefore = lpToken.totalSupply();

        uint256 expectedLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount) * 17;
        minLpTokenAmount = expectedLpTokenAmount;
        baseTokenAmount = baseTokenAmount * 17;
        fractionalTokenAmount = fractionalTokenAmount * 17;
        deal(address(usd), babe, baseTokenAmount, true);
        deal(address(p), babe, fractionalTokenAmount, true);

        // act
        vm.startPrank(babe);
        usd.approve(address(p), type(uint256).max);
        uint256 lpTokenAmount = p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
        vm.stopPrank();

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(lpToken.balanceOf(babe), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(lpToken.totalSupply() - lpTokenSupplyBefore, expectedLpTokenAmount, ""Should have increased lp supply"");
    }

    function testItRevertsSlippageAfterInitMint() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount); // initial add

        minLpTokenAmount = (baseTokenAmount * fractionalTokenAmount * 17) + 1; // add 1 to cause a revert
        baseTokenAmount = baseTokenAmount * 17;
        fractionalTokenAmount = fractionalTokenAmount * 17;

        // act
        vm.expectRevert(""Slippage: lp token amount out"");
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItRevertsIfValueIsNot0AndBaseTokenIsNot0() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount * 17);
        baseTokenAmount = baseTokenAmount * 17;
        fractionalTokenAmount = fractionalTokenAmount * 17;

        // act
        vm.expectRevert(""Invalid ether input"");
        p.add{value: 0.1 ether}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItRevertsIfValueDoesNotMatchBaseTokenAmount() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount * 17);
        baseTokenAmount = baseTokenAmount * 17;
        fractionalTokenAmount = fractionalTokenAmount * 17;

        // act
        vm.expectRevert(""Invalid ether input"");
        ethPair.add{value: baseTokenAmount - 1}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItTransfersEther() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        uint256 balanceBefore = address(this).balance;

        // act
        ethPair.add{value: baseTokenAmount}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        // assert
        uint256 balanceAfter = address(this).balance;
        assertEq(balanceBefore - balanceAfter, baseTokenAmount, ""Should transferred ether from sender"");
        assertEq(address(ethPair).balance, baseTokenAmount, ""Should have transferred ether to pair"");
    }

    function testItMintsLpTokensAfterInitWithEther() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        ethPair.add{value: baseTokenAmount}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount); // initial add
        uint256 lpTokenSupplyBefore = ethPairLpToken.totalSupply();

        uint256 expectedLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount) * 17;
        minLpTokenAmount = expectedLpTokenAmount;
        baseTokenAmount = baseTokenAmount * 17;
        fractionalTokenAmount = fractionalTokenAmount * 17;
        deal(address(ethPair), babe, fractionalTokenAmount, true);

        // act
        vm.startPrank(babe);
        deal(babe, baseTokenAmount);
        uint256 lpTokenAmount =
            ethPair.add{value: baseTokenAmount}(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
        vm.stopPrank();

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(ethPairLpToken.balanceOf(babe), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(
            ethPairLpToken.totalSupply() - lpTokenSupplyBefore, expectedLpTokenAmount, ""Should have increased lp supply""
        );
    }

    function testItEmitsAddEvent() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);

        // act
        vm.expectEmit(true, true, true, true);
        emit Add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    function testItRevertsIfAmountIsZero() public {
        // act
        vm.expectRevert(""Input token amount is zero"");
        p.add(0, fractionalTokenAmount, 0);

        vm.expectRevert(""Input token amount is zero"");
        p.add(baseTokenAmount, 0, 0);
    }

    function testItInitMintsLpTokensToSender(uint256 _baseTokenAmount, uint256 _fractionalTokenAmount) public {
        // arrange
        _baseTokenAmount = bound(_baseTokenAmount, 1, type(uint128).max);
        _fractionalTokenAmount = bound(_fractionalTokenAmount, 1, 100_000_000 * 1e18);
        deal(address(usd), address(this), _baseTokenAmount, true);
        deal(address(p), address(this), _fractionalTokenAmount, true);
        uint256 minLpTokenAmount = Math.sqrt(_baseTokenAmount * _fractionalTokenAmount);
        uint256 expectedLpTokenAmount = minLpTokenAmount;

        // act
        uint256 lpTokenAmount = p.add(_baseTokenAmount, _fractionalTokenAmount, minLpTokenAmount);

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(lpToken.balanceOf(address(this)), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(lpToken.totalSupply(), expectedLpTokenAmount, ""Should have increased lp supply"");
    }

    function testItMintsLpTokensAfterInit(uint256 _initBaseTokenAmount, uint256 _initFractionalTokenAmount) public {
        // arrange
        _initBaseTokenAmount = bound(_initBaseTokenAmount, 1, type(uint128).max);
        _initFractionalTokenAmount = bound(_initFractionalTokenAmount, 1, 100_000_000 * 1e18);
        deal(address(usd), address(this), _initBaseTokenAmount, true);
        deal(address(p), address(this), _initFractionalTokenAmount, true);
        uint256 initMinLpTokenAmount = Math.sqrt(_initBaseTokenAmount * _initFractionalTokenAmount);
        p.add(_initBaseTokenAmount, _initFractionalTokenAmount, initMinLpTokenAmount); // initial add
        uint256 lpTokenSupplyBefore = lpToken.totalSupply();

        uint256 expectedLpTokenAmount = Math.sqrt(_initBaseTokenAmount * _initFractionalTokenAmount) * 17;
        uint256 minLpTokenAmount = expectedLpTokenAmount;
        baseTokenAmount = _initBaseTokenAmount * 17;
        fractionalTokenAmount = _initFractionalTokenAmount * 17;
        deal(address(usd), babe, baseTokenAmount, true);
        deal(address(p), babe, fractionalTokenAmount, true);

        // act
        vm.startPrank(babe);
        usd.approve(address(p), type(uint256).max);
        uint256 lpTokenAmount = p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
        vm.stopPrank();

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(lpToken.balanceOf(babe), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(lpToken.totalSupply() - lpTokenSupplyBefore, expectedLpTokenAmount, ""Should have increased lp supply"");
    }
}",2611
RealWorld_TA_193_CreatePair.s_RealWorld_20240816085228.log,193,CreatePair.s,61485,2202,63687,95.0,0.351465,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""solmate/utils/LibString.sol"";

import ""../src/Caviar.sol"";
import ""../src/Pair.sol"";

contract CreatePairScript is Script {
    using stdJson for string;

    function setUp() public {}

    function run() public {
        vm.broadcast();

        address caviar = vm.envAddress(""CAVIAR_ADDRESS"");
        address nft = vm.envAddress(""NFT_ADDRESS"");

        create(nft, address(0), ""invisible-friends-mids.json"", caviar);
    }

    function create(address nft, address baseToken, string memory rankingFile, address caviar) public returns (Pair) {
        // generate the merkle root
        bytes32 merkleRoot = generateMerkleRoot(rankingFile);

        // create the pair
        Pair pair = Caviar(caviar).create(nft, baseToken, merkleRoot);
        console.log(""pair:"", address(pair));
        console.log(""merkle root:"");
        console.logBytes32(merkleRoot);

        return pair;
    }

    function generateMerkleRoot(string memory rankingFile) public returns (bytes32) {
        string[] memory inputs = new string[](3);

        inputs[0] = ""node"";
        inputs[1] = ""./script/helpers/generate-merkle-root.js"";
        inputs[2] = rankingFile;

        bytes memory res = vm.ffi(inputs);
        bytes32 output = abi.decode(res, (bytes32));

        return output;
    }

    function generateMerkleProofs(string memory rankingFile, uint256[] memory tokenIds)
        public
        returns (bytes32[][] memory)
    {
        bytes32[][] memory proofs = new bytes32[][](tokenIds.length);

        string[] memory inputs = new string[](4);
        for (uint256 i = 0; i < tokenIds.length; i++) {
            inputs[0] = ""node"";
            inputs[1] = ""./script/helpers/generate-merkle-proof.js"";
            inputs[2] = rankingFile;
            inputs[3] = LibString.toString(tokenIds[i]);

            bytes memory res = vm.ffi(inputs);
            bytes32[] memory output = abi.decode(res, (bytes32[]));
            proofs[i] = output;
        }

        return proofs;
    }
}",514
RealWorld_TA_193_Price.t_RealWorld_20240816082043.log,193,Price.t,38613,1792,40405,91.0,0.228905,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";

contract PriceTest is Fixture {
    using stdStorage for StdStorage;

    function testItReturnsCorrectPrice() public {
        // arrange
        uint256 baseTokenReserves = 500;
        uint256 fractionalTokenReserves = 1000;
        uint256 expectedPrice = baseTokenReserves * 1e18 / fractionalTokenReserves;

        // forgefmt: disable-next-item
        stdstore
            .target(address(usd))
            .sig(""balanceOf(address)"")
            .with_key(address(p))
            .checked_write(baseTokenReserves);

        // forgefmt: disable-next-item
        stdstore
            .target(address(p))
            .sig(""balanceOf(address)"")
            .with_key(address(p))
            .checked_write(fractionalTokenReserves);

        // act
        uint256 price = p.price();

        // assert
        assertEq(price, expectedPrice, ""Price does not match"");
    }
}",234
RealWorld_TA_193_CreateFakeWrappedPunks.s_RealWorld_20240816090252.log,193,CreateFakeWrappedPunks.s,43506,2943,46449,98.0,0.27639,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeWrappedPunks is ERC721A {
    constructor() ERC721A(""Fake Wrapped Cryptopunks"", ""FWPUNKS"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(abi.encodePacked(""https://wrappedpunks.com:3000/api/punks/metadata/"", _toString(tokenId)));
    }
}

contract CreateFakeWrappedPunksScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeWrappedPunks fakeWrappedPunks = new FakeWrappedPunks();
        console.log(""fake wpunks:"", address(fakeWrappedPunks));

        fakeWrappedPunks.mint(msg.sender, 250);
        fakeWrappedPunks.mint(msg.sender, 250);
        fakeWrappedPunks.mint(msg.sender, 250);
        fakeWrappedPunks.mint(msg.sender, 250);
        fakeWrappedPunks.mint(msg.sender, 250);
        fakeWrappedPunks.mint(msg.sender, 250);
    }
}",284
RealWorld_TA_193_CreateFakePudgyPenguins.s_RealWorld_20240816085405.log,193,CreateFakePudgyPenguins.s,42737,3054,45791,104.0,0.274765,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakePudgyPenguins is ERC721A {
    constructor() ERC721A(""Fake Pudgy Penguins"", ""PPG"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(
            abi.encodePacked(""https://ipfs.io/ipfs/QmWXJXRdExse2YHRY21Wvh4pjRxNRQcWVhcKw4DLVnqGqs/"", _toString(tokenId))
        );
    }
}

contract CreateFakePudgyPenguinsScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakePudgyPenguins fakePudgyPenguins = new FakePudgyPenguins();
        console.log(""fake Pudgy Penguins:"", address(fakePudgyPenguins));

        fakePudgyPenguins.mint(msg.sender, 250);
        fakePudgyPenguins.mint(msg.sender, 250);
    }
}",277
RealWorld_TA_193_CreateFakeMoonbirds.s_RealWorld_20240816090053.log,193,CreateFakeMoonbirds.s,43074,2926,46000,117.0,0.27389,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeMoonbirds is ERC721A {
    constructor() ERC721A(""Fake Bored Ape Yacht Club"", ""FBAYC"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(abi.encodePacked(""https://live---metadata-5covpqijaa-uc.a.run.app/metadata/"", _toString(tokenId)));
    }
}

contract CreateFakeMoonbirdsScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeMoonbirds fakeMoonbirds = new FakeMoonbirds();
        console.log(""fake moonbirds:"", address(fakeMoonbirds));

        fakeMoonbirds.mint(msg.sender, 250);
        fakeMoonbirds.mint(msg.sender, 250);
        // fakeMoonbirds.mint(msg.sender, 250);
        // fakeMoonbirds.mint(msg.sender, 250);
        // fakeMoonbirds.mint(msg.sender, 250);
        // fakeMoonbirds.mint(msg.sender, 250);
    }
}",282
RealWorld_TA_193_NftAdd.t_RealWorld_20240816082418.log,193,NftAdd.t,140654,2831,143485,104.0,0.75989,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract NftAddTest is Fixture {
    uint256 public baseTokenAmount = 100 * 1e18;
    uint256[] public tokenIds;
    bytes32[][] public proofs;

    function setUp() public {
        deal(address(usd), address(this), baseTokenAmount, true);

        for (uint256 i = 0; i < 5; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }

        bayc.setApprovalForAll(address(p), true);
        usd.approve(address(p), type(uint256).max);
    }

    function testItInitMintsLpTokensToSender() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);
        uint256 expectedLpTokenAmount = minLpTokenAmount;

        // act
        uint256 lpTokenAmount = p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(lpToken.balanceOf(address(this)), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(lpToken.totalSupply(), expectedLpTokenAmount, ""Should have increased lp supply"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);
        uint256 balanceBefore = usd.balanceOf(address(this));

        // act
        p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);

        // assert
        uint256 balanceAfter = usd.balanceOf(address(this));
        assertEq(balanceBefore - balanceAfter, baseTokenAmount, ""Should transferred base tokens from sender"");
        assertEq(usd.balanceOf(address(p)), baseTokenAmount, ""Should have transferred base tokens to pair"");
    }

    function testItTransfersNfts() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);

        // act
        p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(p), ""Should have sent bayc to pair"");
        }
    }

    function testItRevertsSlippageOnInitMint() public {
        // arrange
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18) + 1; // increase 1 to cause revert

        // act
        vm.expectRevert(""Slippage: lp token amount out"");
        p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);
    }

    function testItMintsLpTokensAfterInit() public {
        // arrange
        uint256 fractionalTokenAmount = 101 * 1e18;
        deal(address(p), address(this), fractionalTokenAmount, true);
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount); // initial add
        uint256 lpTokenSupplyBefore = lpToken.totalSupply();

        uint256 expectedLpTokenAmount = (lpToken.totalSupply() * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        minLpTokenAmount = 0;
        baseTokenAmount = ((p.baseTokenReserves() + 100) * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        deal(address(usd), babe, baseTokenAmount, true);

        vm.startPrank(babe);
        bayc.setApprovalForAll(address(p), true);
        usd.approve(address(p), type(uint256).max);

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = i + tokenIds.length;
            bayc.mint(babe, tokenId);
            tokenIds[i] = tokenId;
        }

        // act
        uint256 lpTokenAmount = p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);
        vm.stopPrank();

        // assert
        assertEq(lpTokenAmount, expectedLpTokenAmount, ""Should have returned correct lp token amount"");
        assertEq(lpToken.balanceOf(babe), expectedLpTokenAmount, ""Should have minted lp tokens"");
        assertEq(lpToken.totalSupply() - lpTokenSupplyBefore, expectedLpTokenAmount, ""Should have increased lp supply"");
    }

    function testItRevertsSlippageAfterInitMint() public {
        // arrange
        uint256 fractionalTokenAmount = 101 * 1e18;
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);
        deal(address(p), address(this), fractionalTokenAmount, true);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount); // initial add

        minLpTokenAmount = (lpToken.totalSupply() * tokenIds.length * 1e18) / p.fractionalTokenReserves() + 1; // add 1 to cause a revert
        baseTokenAmount = ((p.baseTokenReserves() + 100) * tokenIds.length * 1e18) / p.fractionalTokenReserves();

        // act
        vm.expectRevert(""Slippage: lp token amount out"");
        p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);
    }

    function testItAddsWithMerkleProof() public {
        // arrange
        Pair pair = createPairScript.create(address(bayc), address(usd), ""YEET-mids.json"", address(c));
        proofs = createPairScript.generateMerkleProofs(""YEET-mids.json"", tokenIds);
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);
        bayc.setApprovalForAll(address(pair), true);
        usd.approve(address(pair), type(uint256).max);

        // act
        pair.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(pair), ""Should have sent bayc to pair"");
        }
    }
}",1482
RealWorld_TA_193_CreateFakeDoodles.s_RealWorld_20240816085049.log,193,CreateFakeDoodles.s,39661,2519,42180,97.0,0.248685,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeDoodles is ERC721A {
    constructor() ERC721A(""Fake Doodles"", ""DOODLE"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(abi.encodePacked(""ipfs://QmPMc4tcBsMqLRuCQtPmPe84bpSjrC3Ky7t3JWuHXYB4aS/"", _toString(tokenId)));
    }
}

contract CreateFakeDoodlesScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeDoodles fakeDoodles = new FakeDoodles();
        console.log(""fake doodles:"", address(fakeDoodles));

        fakeDoodles.mint(msg.sender, 250);
        fakeDoodles.mint(msg.sender, 250);
    }
}",244
RealWorld_TA_193_CreateFakeAzukis.s_RealWorld_20240816085732.log,193,CreateFakeAzukis.s,41738,2417,44155,95.0,0.25703,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeAzukis is ERC721A {
    constructor() ERC721A(""Fake Azuki"", ""AZUKI"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(
            abi.encodePacked(
                ""https://ikzttp.mypinata.cloud/ipfs/QmQFkLSQysj94s5GvTHPyzTxrawwtjgiiYS2TBLgrvw8CW/"", _toString(tokenId)
            )
        );
    }
}

contract CreateFakeAzukisScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeAzukis fakeAzukis = new FakeAzukis();
        console.log(""fake Azuki:"", address(fakeAzukis));

        fakeAzukis.mint(msg.sender, 250);
        fakeAzukis.mint(msg.sender, 250);
    }
}",265
RealWorld_TA_193_Caviar_RealWorld_20240816090920.log,193,Caviar,65937,2084,68021,91.0,0.371365,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""solmate/auth/Owned.sol"";

import ""./lib/SafeERC20Namer.sol"";
import ""./Pair.sol"";

/// @title caviar.sh
/// @author out.eth (@outdoteth)
/// @notice An AMM for creating and trading fractionalized NFTs.
contract Caviar is Owned {
    using SafeERC20Namer for address;

    event Create(address indexed nft, address indexed baseToken, bytes32 indexed merkleRoot);
    event Destroy(address indexed nft, address indexed baseToken, bytes32 indexed merkleRoot);

    /// @dev pairs[nft][baseToken][merkleRoot] -> pair
    mapping(address => mapping(address => mapping(bytes32 => address))) public pairs;

    constructor() Owned(msg.sender) {}

    /// @notice Creates a new pair.
    /// @param nft The NFT contract address.
    /// @param baseToken The base token contract address.
    /// @param merkleRoot The merkle root for the valid tokenIds.
    /// @return pair The address of the new pair.
    function create(address nft, address baseToken, bytes32 merkleRoot) public returns (Pair pair) {
        // check that the pair doesn't already exist
        require(pairs[nft][baseToken][merkleRoot] == address(0), ""Pair already exists"");

        // deploy the pair
        string memory baseTokenSymbol = baseToken == address(0) ? ""ETH"" : baseToken.tokenSymbol();
        string memory nftSymbol = nft.tokenSymbol();
        string memory nftName = nft.tokenName();
        string memory pairSymbol = string.concat(nftSymbol, "":"", baseTokenSymbol);
        pair = new Pair(nft, baseToken, merkleRoot, pairSymbol, nftName, nftSymbol);

        // save the pair
        pairs[nft][baseToken][merkleRoot] = address(pair);

        emit Create(nft, baseToken, merkleRoot);
    }

    /// @notice Deletes the pair for the given NFT, base token, and merkle root.
    /// @param nft The NFT contract address.
    /// @param baseToken The base token contract address.
    /// @param merkleRoot The merkle root for the valid tokenIds.
    function destroy(address nft, address baseToken, bytes32 merkleRoot) public {
        // check that a pair can only destroy itself
        require(msg.sender == pairs[nft][baseToken][merkleRoot], ""Only pair can destroy itself"");

        // delete the pair
        delete pairs[nft][baseToken][merkleRoot];

        emit Destroy(nft, baseToken, merkleRoot);
    }
}",580
RealWorld_TA_193_Remove.t_RealWorld_20240816082754.log,193,Remove.t,163472,3182,166654,123.0,0.881,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract RemoveTest is Fixture {
    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);

    uint256 public totalBaseTokenAmount = 100;
    uint256 public totalFractionalTokenAmount = 30;
    uint256 public totalLpTokenAmount;

    function setUp() public {
        deal(address(usd), address(this), totalBaseTokenAmount, true);
        deal(address(p), address(this), totalFractionalTokenAmount, true);

        usd.approve(address(p), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(totalBaseTokenAmount * totalFractionalTokenAmount);
        totalLpTokenAmount = p.add(totalBaseTokenAmount, totalFractionalTokenAmount, minLpTokenAmount);

        deal(address(ethPair), address(this), totalFractionalTokenAmount, true);
        ethPair.add{value: totalBaseTokenAmount}(totalBaseTokenAmount, totalFractionalTokenAmount, minLpTokenAmount);
    }

    function testItReturnsBaseTokenAmountAndFractionalTokenAmount() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 expectedBaseTokenAmount = totalBaseTokenAmount / 2;
        uint256 expectedFractionalTokenAmount = totalFractionalTokenAmount / 2;

        // act
        (uint256 baseTokenAmount, uint256 fractionalTokenAmount) =
            p.remove(lpTokenAmount, expectedBaseTokenAmount, expectedFractionalTokenAmount);

        // assert
        assertEq(baseTokenAmount, expectedBaseTokenAmount, ""Should have returned correct base token amount"");
        assertEq(
            fractionalTokenAmount, expectedFractionalTokenAmount, ""Should have returned correct fractional token amount""
        );
    }

    function testItBurnsLpTokens() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 minBaseTokenOutputAmount = totalBaseTokenAmount / 2;
        uint256 minFractionalTokenOutputAmount = totalFractionalTokenAmount / 2;
        uint256 balanceBefore = lpToken.balanceOf(address(this));
        uint256 totalSupplyBefore = lpToken.totalSupply();

        // act
        p.remove(lpTokenAmount, minBaseTokenOutputAmount, minFractionalTokenOutputAmount);

        // assert
        assertEq(
            balanceBefore - lpToken.balanceOf(address(this)), lpTokenAmount, ""Should have burned lp tokens from sender""
        );
        assertEq(totalSupplyBefore - lpToken.totalSupply(), lpTokenAmount, ""Should have burned lp tokens"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 minBaseTokenOutputAmount = totalBaseTokenAmount / 2;
        uint256 minFractionalTokenOutputAmount = totalFractionalTokenAmount / 2;
        uint256 thisBalanceBefore = usd.balanceOf(address(this));
        uint256 balanceBefore = usd.balanceOf(address(p));

        // act
        p.remove(lpTokenAmount, minBaseTokenOutputAmount, minFractionalTokenOutputAmount);

        // assert
        assertEq(
            usd.balanceOf(address(this)) - thisBalanceBefore,
            minBaseTokenOutputAmount,
            ""Should have transferred base tokens to sender""
        );

        assertEq(
            balanceBefore - usd.balanceOf(address(p)),
            minBaseTokenOutputAmount,
            ""Should have transferred base tokens from pair""
        );
    }

    function testItTransfersFractionalTokens() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 minBaseTokenOutputAmount = totalBaseTokenAmount / 2;
        uint256 minFractionalTokenOutputAmount = totalFractionalTokenAmount / 2;
        uint256 thisBalanceBefore = p.balanceOf(address(this));
        uint256 balanceBefore = p.balanceOf(address(p));

        // act
        p.remove(lpTokenAmount, minBaseTokenOutputAmount, minFractionalTokenOutputAmount);

        // assert
        assertEq(
            p.balanceOf(address(this)) - thisBalanceBefore,
            minFractionalTokenOutputAmount,
            ""Should have transferred fractionall tokens to sender""
        );

        assertEq(
            balanceBefore - p.balanceOf(address(p)),
            minFractionalTokenOutputAmount,
            ""Should have transferred fractional tokens from pair""
        );
    }

    function testItRevertsFractionalTokenSlippage() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 minBaseTokenOutputAmount = totalBaseTokenAmount / 2;
        uint256 minFractionalTokenOutputAmount = totalFractionalTokenAmount / 2 + 1; // add 1 to cause revert

        // act
        vm.expectRevert(""Slippage: fractional token out"");
        p.remove(lpTokenAmount, minBaseTokenOutputAmount, minFractionalTokenOutputAmount);
    }

    function testItRevertsBaseTokenSlippage() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 minBaseTokenOutputAmount = totalBaseTokenAmount / 2 + 1; // add 1 to cause revert
        uint256 minFractionalTokenOutputAmount = totalFractionalTokenAmount / 2;

        // act
        vm.expectRevert(""Slippage: base token amount out"");
        p.remove(lpTokenAmount, minBaseTokenOutputAmount, minFractionalTokenOutputAmount);
    }

    function testItTransfersEther() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 minBaseTokenOutputAmount = totalBaseTokenAmount / 2;
        uint256 minFractionalTokenOutputAmount = totalFractionalTokenAmount / 2;
        uint256 thisBalanceBefore = address(this).balance;
        uint256 balanceBefore = address(ethPair).balance;

        // act
        ethPair.remove(lpTokenAmount, minBaseTokenOutputAmount, minFractionalTokenOutputAmount);

        // assert
        assertEq(
            address(this).balance - thisBalanceBefore,
            minBaseTokenOutputAmount,
            ""Should have transferred ether to sender""
        );

        assertEq(
            balanceBefore - address(ethPair).balance,
            minBaseTokenOutputAmount,
            ""Should have transferred ether from pair""
        );
    }

    function testItEmitsRemoveEvent() public {
        // arrange
        uint256 lpTokenAmount = totalLpTokenAmount / 2;
        uint256 expectedBaseTokenAmount = totalBaseTokenAmount / 2;
        uint256 expectedFractionalTokenAmount = totalFractionalTokenAmount / 2;

        // act
        vm.expectEmit(true, true, true, true);
        emit Remove(expectedBaseTokenAmount, expectedFractionalTokenAmount, lpTokenAmount);
        p.remove(lpTokenAmount, expectedBaseTokenAmount, expectedFractionalTokenAmount);
    }

    function testItReturnsBaseTokenAmountAndFractionalTokenAmount(uint256 fractionToRemove) public {
        // arrange
        fractionToRemove = bound(fractionToRemove, 0, 1e18);
        uint256 lpTokenAmount = totalLpTokenAmount * fractionToRemove / 1e18;
        uint256 expectedBaseTokenAmount = totalBaseTokenAmount * lpTokenAmount / lpToken.totalSupply();
        uint256 expectedFractionalTokenAmount = totalFractionalTokenAmount * lpTokenAmount / lpToken.totalSupply();

        // act
        (uint256 baseTokenAmount, uint256 fractionalTokenAmount) =
            p.remove(lpTokenAmount, expectedBaseTokenAmount, expectedFractionalTokenAmount);

        // assert
        assertEq(baseTokenAmount, expectedBaseTokenAmount, ""Should have returned correct base token amount"");
        assertEq(
            fractionalTokenAmount, expectedFractionalTokenAmount, ""Should have returned correct fractional token amount""
        );
    }
}",1733
RealWorld_TA_193_CreateFakeBasedGhouls.s_RealWorld_20240816085909.log,193,CreateFakeBasedGhouls.s,42209,2807,45016,102.0,0.267185,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeBasedGhouls is ERC721A {
    constructor() ERC721A(""Fake Based Ghouls"", ""GHOUL"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(
            abi.encodePacked(
                ""ipfs://bafybeibtw646yhcbfqiox46qcoforbq6rndurbnqx2slueso7gvdtmioty/"", _toString(tokenId), "".json""
            )
        );
    }
}

contract CreateFakeBasedGhoulsScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeBasedGhouls fakeBasedGhouls = new FakeBasedGhouls();
        console.log(""fake ghoul:"", address(fakeBasedGhouls));

        fakeBasedGhouls.mint(msg.sender, 250);
        fakeBasedGhouls.mint(msg.sender, 250);
    }
}",270
RealWorld_TA_193_LpToken_RealWorld_20240816090737.log,193,LpToken,38546,1995,40541,101.0,0.23263,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""solmate/auth/Owned.sol"";
import ""solmate/tokens/ERC20.sol"";

/// @title LP token
/// @author out.eth (@outdoteth)
/// @notice LP token which is minted and burned by the Pair contract to represent liquidity in the pool.
contract LpToken is Owned, ERC20 {
    constructor(string memory pairSymbol)
        Owned(msg.sender)
        ERC20(string.concat(pairSymbol, "" LP token""), string.concat(""LP-"", pairSymbol), 18)
    {}

    /// @notice Mints new LP tokens to the given address.
    /// @param to The address to mint to.
    /// @param amount The amount to mint.
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    /// @notice Burns LP tokens from the given address.
    /// @param from The address to burn from.
    /// @param amount The amount to burn.
    function burn(address from, uint256 amount) public onlyOwner {
        _burn(from, amount);
    }
}",236
RealWorld_TA_193_MockERC20_RealWorld_20240816081421.log,193,MockERC20,23034,1607,24641,88.0,0.14731,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""solmate/tokens/ERC20.sol"";

contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_, 18) {}
}",56
RealWorld_TA_193_Pair_RealWorld_20240816090432.log,193,Pair,398408,6534,404942,183.0,2.12272,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""solmate/tokens/ERC20.sol"";
import ""solmate/tokens/ERC721.sol"";
import ""solmate/utils/MerkleProofLib.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""openzeppelin/utils/math/Math.sol"";

import ""./LpToken.sol"";
import ""./Caviar.sol"";

/// @title Pair
/// @author out.eth (@outdoteth)
/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.
contract Pair is ERC20, ERC721TokenReceiver {
    using SafeTransferLib for address;
    using SafeTransferLib for ERC20;

    uint256 public constant ONE = 1e18;
    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;

    address public immutable nft;
    address public immutable baseToken; // address(0) for ETH
    bytes32 public immutable merkleRoot;
    LpToken public immutable lpToken;
    Caviar public immutable caviar;
    uint256 public closeTimestamp;

    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);
    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);
    event Buy(uint256 inputAmount, uint256 outputAmount);
    event Sell(uint256 inputAmount, uint256 outputAmount);
    event Wrap(uint256[] tokenIds);
    event Unwrap(uint256[] tokenIds);
    event Close(uint256 closeTimestamp);
    event Withdraw(uint256 tokenId);

    constructor(
        address _nft,
        address _baseToken,
        bytes32 _merkleRoot,
        string memory pairSymbol,
        string memory nftName,
        string memory nftSymbol
    ) ERC20(string.concat(nftName, "" fractional token""), string.concat(""f"", nftSymbol), 18) {
        nft = _nft;
        baseToken = _baseToken; // use address(0) for native ETH
        merkleRoot = _merkleRoot;
        lpToken = new LpToken(pairSymbol);
        caviar = Caviar(msg.sender);
    }

    // ************************ //
    //      Core AMM logic      //
    // ***********************  //

    /// @notice Adds liquidity to the pair.
    /// @param baseTokenAmount The amount of base tokens to add.
    /// @param fractionalTokenAmount The amount of fractional tokens to add.
    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.
    /// @return lpTokenAmount The amount of LP tokens minted.
    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)
        public
        payable
        returns (uint256 lpTokenAmount)
    {
        // *** Checks *** //

        // check the token amount inputs are not zero
        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, ""Input token amount is zero"");

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, ""Invalid ether input"");

        // calculate the lp token shares to mint
        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);

        // check that the amount of lp tokens outputted is greater than the min amount
        require(lpTokenAmount >= minLpTokenAmount, ""Slippage: lp token amount out"");

        // *** Effects *** //

        // transfer fractional tokens in
        _transferFrom(msg.sender, address(this), fractionalTokenAmount);

        // *** Interactions *** //

        // mint lp tokens to sender
        lpToken.mint(msg.sender, lpTokenAmount);

        // transfer base tokens in if the base token is not ETH
        if (baseToken != address(0)) {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);
        }

        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);
    }

    /// @notice Removes liquidity from the pair.
    /// @param lpTokenAmount The amount of LP tokens to burn.
    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.
    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.
    /// @return baseTokenOutputAmount The amount of base tokens received.
    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.
    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)
        public
        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)
    {
        // *** Checks *** //

        // calculate the output amounts
        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);

        // check that the base token output amount is greater than the min amount
        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, ""Slippage: base token amount out"");

        // check that the fractional token output amount is greater than the min amount
        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, ""Slippage: fractional token out"");

        // *** Effects *** //

        // transfer fractional tokens to sender
        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);

        // *** Interactions *** //

        // burn lp tokens from sender
        lpToken.burn(msg.sender, lpTokenAmount);

        if (baseToken == address(0)) {
            // if base token is native ETH then send ether to sender
            msg.sender.safeTransferETH(baseTokenOutputAmount);
        } else {
            // transfer base tokens to sender
            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);
        }

        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);
    }

    /// @notice Buys fractional tokens from the pair.
    /// @param outputAmount The amount of fractional tokens to buy.
    /// @param maxInputAmount The maximum amount of base tokens to spend.
    /// @return inputAmount The amount of base tokens spent.
    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {
        // *** Checks *** //

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, ""Invalid ether input"");

        // calculate required input amount using xyk invariant
        inputAmount = buyQuote(outputAmount);

        // check that the required amount of base tokens is less than the max amount
        require(inputAmount <= maxInputAmount, ""Slippage: amount in"");

        // *** Effects *** //

        // transfer fractional tokens to sender
        _transferFrom(address(this), msg.sender, outputAmount);

        // *** Interactions *** //

        if (baseToken == address(0)) {
            // refund surplus eth
            uint256 refundAmount = maxInputAmount - inputAmount;
            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);
        } else {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);
        }

        emit Buy(inputAmount, outputAmount);
    }

    /// @notice Sells fractional tokens to the pair.
    /// @param inputAmount The amount of fractional tokens to sell.
    /// @param minOutputAmount The minimum amount of base tokens to receive.
    /// @return outputAmount The amount of base tokens received.
    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {
        // *** Checks *** //

        // calculate output amount using xyk invariant
        outputAmount = sellQuote(inputAmount);

        // check that the outputted amount of fractional tokens is greater than the min amount
        require(outputAmount >= minOutputAmount, ""Slippage: amount out"");

        // *** Effects *** //

        // transfer fractional tokens from sender
        _transferFrom(msg.sender, address(this), inputAmount);

        // *** Interactions *** //

        if (baseToken == address(0)) {
            // transfer ether out
            msg.sender.safeTransferETH(outputAmount);
        } else {
            // transfer base tokens out
            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);
        }

        emit Sell(inputAmount, outputAmount);
    }

    // ******************** //
    //      Wrap logic      //
    // ******************** //

    /// @notice Wraps NFTs into fractional tokens.
    /// @param tokenIds The ids of the NFTs to wrap.
    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.
    /// @return fractionalTokenAmount The amount of fractional tokens minted.
    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)
        public
        returns (uint256 fractionalTokenAmount)
    {
        // *** Checks *** //

        // check that wrapping is not closed
        require(closeTimestamp == 0, ""Wrap: closed"");

        // check the tokens exist in the merkle root
        _validateTokenIds(tokenIds, proofs);

        // *** Effects *** //

        // mint fractional tokens to sender
        fractionalTokenAmount = tokenIds.length * ONE;
        _mint(msg.sender, fractionalTokenAmount);

        // *** Interactions *** //

        // transfer nfts from sender
        for (uint256 i = 0; i < tokenIds.length; i++) {
            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);
        }

        emit Wrap(tokenIds);
    }

    /// @notice Unwraps fractional tokens into NFTs.
    /// @param tokenIds The ids of the NFTs to unwrap.
    /// @return fractionalTokenAmount The amount of fractional tokens burned.
    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {
        // *** Effects *** //

        // burn fractional tokens from sender
        fractionalTokenAmount = tokenIds.length * ONE;
        _burn(msg.sender, fractionalTokenAmount);

        // *** Interactions *** //

        // transfer nfts to sender
        for (uint256 i = 0; i < tokenIds.length; i++) {
            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);
        }

        emit Unwrap(tokenIds);
    }

    // *********************** //
    //      NFT AMM logic      //
    // *********************** //

    /// @notice nftAdd Adds liquidity to the pair using NFTs.
    /// @param baseTokenAmount The amount of base tokens to add.
    /// @param tokenIds The ids of the NFTs to add.
    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.
    /// @param proofs The merkle proofs for the NFTs.
    /// @return lpTokenAmount The amount of lp tokens minted.
    function nftAdd(
        uint256 baseTokenAmount,
        uint256[] calldata tokenIds,
        uint256 minLpTokenAmount,
        bytes32[][] calldata proofs
    ) public payable returns (uint256 lpTokenAmount) {
        // wrap the incoming NFTs into fractional tokens
        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);

        // add liquidity using the fractional tokens and base tokens
        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);
    }

    /// @notice Removes liquidity from the pair using NFTs.
    /// @param lpTokenAmount The amount of lp tokens to remove.
    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.
    /// @param tokenIds The ids of the NFTs to remove.
    /// @return baseTokenOutputAmount The amount of base tokens received.
    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.
    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)
        public
        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)
    {
        // remove liquidity and send fractional tokens and base tokens to sender
        (baseTokenOutputAmount, fractionalTokenOutputAmount) =
            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);

        // unwrap the fractional tokens into NFTs and send to sender
        unwrap(tokenIds);
    }

    /// @notice Buys NFTs from the pair using base tokens.
    /// @param tokenIds The ids of the NFTs to buy.
    /// @param maxInputAmount The maximum amount of base tokens to spend.
    /// @return inputAmount The amount of base tokens spent.
    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {
        // buy fractional tokens using base tokens
        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);

        // unwrap the fractional tokens into NFTs and send to sender
        unwrap(tokenIds);
    }

    /// @notice Sells NFTs to the pair for base tokens.
    /// @param tokenIds The ids of the NFTs to sell.
    /// @param minOutputAmount The minimum amount of base tokens to receive.
    /// @param proofs The merkle proofs for the NFTs.
    /// @return outputAmount The amount of base tokens received.
    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)
        public
        returns (uint256 outputAmount)
    {
        // wrap the incoming NFTs into fractional tokens
        uint256 inputAmount = wrap(tokenIds, proofs);

        // sell fractional tokens for base tokens
        outputAmount = sell(inputAmount, minOutputAmount);
    }

    // ****************************** //
    //      Emergency exit logic      //
    // ****************************** //

    /// @notice Closes the pair to new wraps.
    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case
    ///      the caviar owner suspects that the pair has been compromised.
    function close() public {
        // check that the sender is the caviar owner
        require(caviar.owner() == msg.sender, ""Close: not owner"");

        // set the close timestamp with a grace period
        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;

        // remove the pair from the Caviar contract
        caviar.destroy(nft, baseToken, merkleRoot);

        emit Close(closeTimestamp);
    }

    /// @notice Withdraws a particular NFT from the pair.
    /// @dev Can only be called by the caviar owner after the close grace period has passed. This
    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity
    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional
    ///      token holders. See documentation for more details.
    function withdraw(uint256 tokenId) public {
        // check that the sender is the caviar owner
        require(caviar.owner() == msg.sender, ""Withdraw: not owner"");

        // check that the close period has been set
        require(closeTimestamp != 0, ""Withdraw not initiated"");

        // check that the close grace period has passed
        require(block.timestamp >= closeTimestamp, ""Not withdrawable yet"");

        // transfer the nft to the caviar owner
        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);

        emit Withdraw(tokenId);
    }

    // ***************** //
    //      Getters      //
    // ***************** //

    function baseTokenReserves() public view returns (uint256) {
        return _baseTokenReserves();
    }

    function fractionalTokenReserves() public view returns (uint256) {
        return balanceOf[address(this)];
    }

    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.
    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.
    /// @return price The price of one fractional token in base tokens * 1e18.
    function price() public view returns (uint256) {
        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();
    }

    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.
    /// @dev Calculated using the xyk invariant and a 30bps fee.
    /// @param outputAmount The amount of fractional tokens to buy.
    /// @return inputAmount The amount of base tokens required.
    function buyQuote(uint256 outputAmount) public view returns (uint256) {
        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);
    }

    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.
    /// @dev Calculated using the xyk invariant and a 30bps fee.
    /// @param inputAmount The amount of fractional tokens to sell.
    /// @return outputAmount The amount of base tokens received.
    function sellQuote(uint256 inputAmount) public view returns (uint256) {
        uint256 inputAmountWithFee = inputAmount * 997;
        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);
    }

    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.
    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to
    ///      sqrt(baseTokenAmount * fractionalTokenAmount).
    /// @param baseTokenAmount The amount of base tokens to add.
    /// @param fractionalTokenAmount The amount of fractional tokens to add.
    /// @return lpTokenAmount The amount of lp tokens received.
    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {
        uint256 lpTokenSupply = lpToken.totalSupply();
        if (lpTokenSupply > 0) {
            // calculate amount of lp tokens as a fraction of existing reserves
            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();
            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();
            return Math.min(baseTokenShare, fractionalTokenShare);
        } else {
            // if there is no liquidity then init
            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        }
    }

    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.
    /// @dev Calculated as a share of existing deposits.
    /// @param lpTokenAmount The amount of lp tokens to burn.
    /// @return baseTokenAmount The amount of base tokens received.
    /// @return fractionalTokenAmount The amount of fractional tokens received.
    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {
        uint256 lpTokenSupply = lpToken.totalSupply();
        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;
        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;

        return (baseTokenOutputAmount, fractionalTokenOutputAmount);
    }

    // ************************ //
    //      Internal utils      //
    // ************************ //

    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {
        balanceOf[from] -= amount;

        // Cannot overflow because the sum of all user
        // balances can't exceed the max uint256 value.
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);

        return true;
    }

    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts
    ///      if any of the tokenId proofs are invalid.
    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {
        // if merkle root is not set then all tokens are valid
        if (merkleRoot == bytes23(0)) return;

        // validate merkle proofs against merkle root
        for (uint256 i = 0; i < tokenIds.length; i++) {
            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));
            require(isValid, ""Invalid merkle proof"");
        }
    }

    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores
    ///      the msg.value that is being sent in the current call context - this is to ensure the
    ///      xyk math is correct in the buy() and add() functions.
    function _baseTokenReserves() internal view returns (uint256) {
        return baseToken == address(0)
            ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH
            : ERC20(baseToken).balanceOf(address(this));
    }
}",4582
RealWorld_TA_193_Create.t_RealWorld_20240816081733.log,193,Create.t,77695,1418,79113,92.0,0.416835,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../shared/Fixture.t.sol"";

contract CreateTest is Fixture {
    event Create(address indexed nft, address indexed baseToken, bytes32 indexed merkleRoot);

    function testItReturnsPair() public {
        // arrange
        address nft = address(0xbeef);
        address baseToken = address(0xcafe);

        // act
        address pair = address(c.create(nft, baseToken, bytes32(0)));

        // assert
        assertTrue(pair != address(0), ""Should have deployed pair"");
    }

    function testItSetsSymbolsAndNames() public {
        // arrange
        address nft = 0xbEEFB00b00000000000000000000000000000000;
        address baseToken = 0xCAFE000000000000000000000000000000000000;

        // act
        Pair pair = c.create(nft, baseToken, bytes32(0));
        LpToken lpToken = LpToken(pair.lpToken());

        // assert
        assertEq(pair.symbol(), ""f0xbeef"", ""Should have set fractional token symbol"");
        assertEq(
            pair.name(),
            ""0xbeefb00b00000000000000000000000000000000 fractional token"",
            ""Should have set fractional token name""
        );
        assertEq(lpToken.symbol(), ""LP-0xbeef:0xcafe"", ""Should have set lp symbol"");
        assertEq(lpToken.name(), ""0xbeef:0xcafe LP token"", ""Should have set lp name"");
    }

    function testItSavesPair() public {
        // arrange
        address nft = address(0xbeef);
        address baseToken = address(0xcafe);
        bytes32 merkleRoot = bytes32(uint256(0xb00b));

        // act
        testItSavesPair(nft, baseToken, merkleRoot);
    }

    function testItRevertsIfDeployingSamePairTwice() public {
        // arrange
        address nft = address(0xbeef);
        address baseToken = address(0xcafe);
        bytes32 merkleRoot = bytes32(uint256(0xb00b));
        c.create(nft, baseToken, merkleRoot);

        // act
        vm.expectRevert(""Pair already exists"");
        c.create(nft, baseToken, merkleRoot);
    }

    function testItEmitsCreateEvent() public {
        // arrange
        address nft = address(0xbeef);
        address baseToken = address(0xcafe);
        bytes32 merkleRoot = bytes32(uint256(0xb00b));

        // act
        vm.expectEmit(true, true, true, true);
        emit Create(nft, baseToken, merkleRoot);
        c.create(nft, baseToken, merkleRoot);
    }

    function testItSavesPair(address nft, address baseToken, bytes32 merkleRoot) public {
        // act
        address pair = address(c.create(nft, baseToken, merkleRoot));

        // assert
        assertEq(c.pairs(nft, baseToken, merkleRoot), pair, ""Should have saved pair address in pairs"");
    }
}",709
RealWorld_TA_193_CreateFakeBoredApeYachtClub.s_RealWorld_20240816084550.log,193,CreateFakeBoredApeYachtClub.s,49129,3626,52755,113.0,0.318165,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";
import ""ERC721A/ERC721A.sol"";

contract FakeBoredApeYachtClub is ERC721A {
    constructor() ERC721A(""Fake Bored Ape Yacht Club"", ""FBAYC"") {}

    function mint(address to, uint256 quantity) public {
        _mint(to, quantity);
    }

    function tokenURI(uint256 tokenId) public pure override returns (string memory) {
        return string(abi.encodePacked(""ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/"", _toString(tokenId)));
    }
}

contract CreateFakeBoredApeYachtClubScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        FakeBoredApeYachtClub fakeBoredApeYachtClub = new FakeBoredApeYachtClub();
        console.log(""fake bayc:"", address(fakeBoredApeYachtClub));

        fakeBoredApeYachtClub.mint(msg.sender, 250);
        fakeBoredApeYachtClub.mint(msg.sender, 250);
        fakeBoredApeYachtClub.mint(msg.sender, 250);
        fakeBoredApeYachtClub.mint(msg.sender, 250);
        fakeBoredApeYachtClub.mint(msg.sender, 250);
        fakeBoredApeYachtClub.mint(msg.sender, 250);
    }
}",355
RealWorld_TA_193_Deploy.s_RealWorld_20240816084923.log,193,Deploy.s,26295,1592,27887,84.0,0.163315,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Script.sol"";
import ""forge-std/console.sol"";

import ""../src/Caviar.sol"";

contract DeployScript is Script {
    using stdJson for string;

    function setUp() public {}

    function run() public {
        vm.startBroadcast();

        Caviar c = new Caviar();

        console.log(""caviar:"", address(c));
    }
}",96
RealWorld_TA_193_SafeERC20Namer_RealWorld_20240816091053.log,193,SafeERC20Namer,94790,1786,96576,91.0,0.50967,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""openzeppelin/utils/Strings.sol"";

// modified from https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/SafeERC20Namer.sol
// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32
// this library will always produce a string symbol to represent the token
library SafeERC20Namer {
    function bytes32ToString(bytes32 x) private pure returns (string memory) {
        bytes memory bytesString = new bytes(32);
        uint256 charCount = 0;
        for (uint256 j = 0; j < 32; j++) {
            bytes1 char = x[j];
            if (char != 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (uint256 j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }

        return string(bytesStringTrimmed);
    }

    // assumes the data is in position 2
    function parseStringData(bytes memory b) private pure returns (string memory) {
        uint256 charCount = 0;
        // first parse the charCount out of the data
        for (uint256 i = 32; i < 64; i++) {
            charCount <<= 8;
            charCount += uint8(b[i]);
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (uint256 i = 0; i < charCount; i++) {
            bytesStringTrimmed[i] = b[i + 64];
        }

        return string(bytesStringTrimmed);
    }

    // uses a heuristic to produce a token name from the address
    // the heuristic returns the full hex of the address string
    function addressToName(address token) private pure returns (string memory) {
        return Strings.toHexString(uint160(token));
    }

    // uses a heuristic to produce a token symbol from the address
    // the heuristic returns the first 4 hex of the address string
    function addressToSymbol(address token) private pure returns (string memory) {
        return Strings.toHexString(uint160(token) >> (160 - 4 * 4));
    }

    // calls an external view token contract method that returns a symbol or name, and parses the output into a string
    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {
        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));
        // if not implemented, or returns empty data, return empty string
        if (!success || data.length == 0) {
            return """";
        }
        // bytes32 data always has length 32
        if (data.length == 32) {
            bytes32 decoded = abi.decode(data, (bytes32));
            return bytes32ToString(decoded);
        } else if (data.length > 64) {
            return abi.decode(data, (string));
        }
        return """";
    }

    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address
    function tokenSymbol(address token) internal view returns (string memory) {
        // 0x95d89b41 = bytes4(keccak256(""symbol()""))
        string memory symbol = callAndParseStringReturn(token, 0x95d89b41);
        if (bytes(symbol).length == 0) {
            // fallback to 6 uppercase hex of address
            return addressToSymbol(token);
        }
        return symbol;
    }

    // attempts to extract the token name. if it does not implement name, returns a name derived from the address
    function tokenName(address token) internal view returns (string memory) {
        // 0x06fdde03 = bytes4(keccak256(""name()""))
        string memory name = callAndParseStringReturn(token, 0x06fdde03);
        if (bytes(name).length == 0) {
            // fallback to full hex of address
            return addressToName(token);
        }

        return name;
    }
}",902
RealWorld_TA_193_Unwrap.t_RealWorld_20240816083734.log,193,Unwrap.t,52028,2680,54708,106.0,0.31374,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract UnwrapTest is Fixture {
    event Unwrap(uint256[] tokenIds);

    uint256[] public tokenIds;
    bytes32[][] public proofs;

    function setUp() public {
        bayc.setApprovalForAll(address(p), true);

        for (uint256 i = 0; i < 5; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }

        p.wrap(tokenIds, proofs);
    }

    function testItTransfersTokens() public {
        // act
        p.unwrap(tokenIds);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(this), ""Should have sent bayc to sender"");
        }
    }

    function testItBurnsFractionalTokens() public {
        // arrange
        uint256 expectedFractionalTokensBurned = tokenIds.length * 1e18;
        uint256 balanceBefore = p.balanceOf(address(this));
        uint256 totalSupplyBefore = p.totalSupply();

        // act
        p.unwrap(tokenIds);

        // assert
        assertEq(
            balanceBefore - p.balanceOf(address(this)),
            expectedFractionalTokensBurned,
            ""Should have burned fractional tokens from sender""
        );

        assertEq(
            totalSupplyBefore - p.totalSupply(), expectedFractionalTokensBurned, ""Should have burned fractional tokens""
        );
    }

    function testItEmitsUnwrapEvent() public {
        // act
        vm.expectEmit(true, true, true, true);
        emit Unwrap(tokenIds);
        p.unwrap(tokenIds);
    }
}",395
RealWorld_TA_193_Fixture.t_RealWorld_20240816081253.log,193,Fixture.t,49804,1546,51350,86.0,0.27994,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""solmate/tokens/ERC721.sol"";

import ""../../src/Caviar.sol"";
import ""../../src/Pair.sol"";
import ""./mocks/MockERC721.sol"";
import ""./mocks/MockERC20.sol"";
import ""../../script/CreatePair.s.sol"";

contract Fixture is Test, ERC721TokenReceiver {
    MockERC721 public bayc;
    MockERC20 public usd;

    CreatePairScript public createPairScript;
    Caviar public c;
    Pair public p;
    LpToken public lpToken;
    Pair public ethPair;
    LpToken public ethPairLpToken;

    address public babe = address(0xbabe);

    constructor() {
        createPairScript = new CreatePairScript();

        c = new Caviar();

        bayc = new MockERC721(""yeet"", ""YEET"");
        usd = new MockERC20(""us dollar"", ""USD"");

        p = c.create(address(bayc), address(usd), bytes32(0));
        lpToken = LpToken(p.lpToken());

        ethPair = c.create(address(bayc), address(0), bytes32(0));
        ethPairLpToken = LpToken(ethPair.lpToken());

        vm.label(babe, ""babe"");
        vm.label(address(c), ""caviar"");
        vm.label(address(bayc), ""bayc"");
        vm.label(address(usd), ""usd"");
        vm.label(address(p), ""pair"");
        vm.label(address(lpToken), ""LP-token"");
        vm.label(address(ethPair), ""ethPair"");
        vm.label(address(ethPairLpToken), ""ethPair-LP-token"");
    }

    receive() external payable {}
}",383
RealWorld_TA_193_Close.t_RealWorld_20240816084100.log,193,Close.t,70223,3181,73404,101.0,0.414735,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract CloseTest is Fixture {
    event Close(uint256 closeTimestamp);
    event Withdraw(uint256 tokenId);

    uint256[] public tokenIds;

    function setUp() public {
        bayc.setApprovalForAll(address(p), true);

        for (uint256 i = 0; i < 5; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }
    }

    function testExitSetsCloseTimestamp() public {
        // arrange
        uint256 expectedCloseTimestamp = block.timestamp + 7 days;

        // act
        p.close();

        // assert
        assertEq(p.closeTimestamp(), expectedCloseTimestamp, ""Should have set close timestamp"");
    }

    function testCannotExitIfNotAdmin() public {
        // act
        vm.prank(address(0xbabe));
        vm.expectRevert(""Close: not owner"");
        p.close();

        // assert
        assertEq(p.closeTimestamp(), 0, ""Should not have set close timestamp"");
    }

    function testCannotWithdrawIfNotAdmin() public {
        // arrange
        p.close();

        // act
        vm.prank(address(0xbabe));
        vm.expectRevert(""Withdraw: not owner"");
        p.withdraw(1);
    }

    function testCannotWithdrawIfNotClosed() public {
        // act
        vm.expectRevert(""Withdraw not initiated"");
        p.withdraw(1);
    }

    function testCannotWithdrawIfNotEnoughTimeElapsed() public {
        // arrange
        p.close();

        // act
        vm.expectRevert(""Not withdrawable yet"");
        p.withdraw(1);
    }

    function testItTransfersNftsAfterWithdraw() public {
        // arrange
        p.close();
        skip(7 days);
        uint256 tokenId = 1;
        bayc.transferFrom(address(this), address(p), tokenId);

        // act
        p.withdraw(tokenId);

        // assert
        assertEq(bayc.ownerOf(tokenId), address(this), ""Should have sent bayc to sender"");
    }

    function testItEmitsCloseEvent() public {
        // act
        vm.expectEmit(true, true, true, true);
        emit Close(block.timestamp + 7 days);
        p.close();
    }

    function testItEmitsWithdrawEvent() public {
        // arrange
        p.close();
        skip(7 days);
        uint256 tokenId = 1;
        bayc.transferFrom(address(this), address(p), tokenId);

        // act
        vm.expectEmit(true, true, true, true);
        emit Withdraw(tokenId);
        p.withdraw(tokenId);
    }
}",600
RealWorld_TA_193_NftSell.t_RealWorld_20240816082959.log,193,NftSell.t,104083,2983,107066,102.0,0.580075,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract NftSellTest is Fixture {
    uint256 public minOutputAmount;
    uint256[] public tokenIds;
    bytes32[][] public proofs;

    function setUp() public {
        uint256 baseTokenAmount = 69.69e18;
        uint256 fractionalTokenAmount = 420.42e18;

        deal(address(usd), address(this), baseTokenAmount, true);
        deal(address(p), address(this), fractionalTokenAmount, true);
        usd.approve(address(p), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        p.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        for (uint256 i = 0; i < 5; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }

        bayc.setApprovalForAll(address(p), true);

        minOutputAmount = (tokenIds.length * 1e18 * 997 * p.baseTokenReserves())
            / (p.fractionalTokenReserves() * 1000 + tokenIds.length * 1e18 * 997);
    }

    function testItReturnsOutputAmount() public {
        // arrange
        uint256 expectedOutputAmount = minOutputAmount;

        // act
        uint256 outputAmount = p.nftSell(tokenIds, expectedOutputAmount, proofs);

        // assert
        assertEq(outputAmount, expectedOutputAmount, ""Should have returned output amount"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 balanceBefore = usd.balanceOf(address(p));
        uint256 thisBalanceBefore = usd.balanceOf(address(this));

        // act
        p.nftSell(tokenIds, minOutputAmount, proofs);

        // assert
        assertEq(
            balanceBefore - usd.balanceOf(address(p)), minOutputAmount, ""Should have transferred base tokens from pair""
        );

        assertEq(
            usd.balanceOf(address(this)) - thisBalanceBefore,
            minOutputAmount,
            ""Should have transferred base tokens to sender""
        );
    }

    function testItTransfersNfts() public {
        // act
        p.nftSell(tokenIds, minOutputAmount, proofs);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(p), ""Should have sent bayc to pair"");
        }
    }

    function testItRevertsSlippageOnSell() public {
        // arrange
        minOutputAmount += 1; // add 1 to cause revert

        // act
        vm.expectRevert(""Slippage: amount out"");
        p.nftSell(tokenIds, minOutputAmount, proofs);
    }

    function testItMintsFractionalTokens() public {
        // arrange
        uint256 totalSupplyBefore = p.totalSupply();
        uint256 balanceBefore = p.balanceOf(address(p));

        // act
        p.nftSell(tokenIds, minOutputAmount, proofs);

        // assert
        assertEq(p.totalSupply() - totalSupplyBefore, tokenIds.length * 1e18, ""Should have minted fractional tokens"");
        assertEq(
            p.balanceOf(address(p)) - balanceBefore,
            tokenIds.length * 1e18,
            ""Should have minted fractional tokens to pair""
        );
    }

    function testItSellsWithMerkleProof() public {
        Pair pair = createPairScript.create(address(bayc), address(usd), ""YEET-mids.json"", address(c));

        uint256 baseTokenAmount = 69.69e18;
        uint256 fractionalTokenAmount = 420.42e18;

        deal(address(usd), address(this), baseTokenAmount, true);
        deal(address(pair), address(this), fractionalTokenAmount, true);
        usd.approve(address(pair), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        pair.add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);

        proofs = createPairScript.generateMerkleProofs(""YEET-mids.json"", tokenIds);
        bayc.setApprovalForAll(address(pair), true);

        // act
        pair.nftSell(tokenIds, minOutputAmount, proofs);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(tokenIds[i]), address(pair), ""Should have sent bayc to pair"");
        }
    }
}",1022
RealWorld_TA_193_NftRemove.t_RealWorld_20240816082605.log,193,NftRemove.t,123179,2413,125592,107.0,0.664155,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract NftRemoveTest is Fixture {
    uint256 public totalBaseTokenAmount = 3.15e18;
    uint256 public totalLpTokenAmount;
    uint256[] public tokenIds;
    bytes32[][] public proofs;

    function setUp() public {
        deal(address(usd), address(this), totalBaseTokenAmount, true);
        for (uint256 i = 0; i < 6; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }

        bayc.setApprovalForAll(address(p), true);
        usd.approve(address(p), type(uint256).max);

        uint256 minLpTokenAmount = Math.sqrt(totalBaseTokenAmount * tokenIds.length * 1e18);
        totalLpTokenAmount = p.nftAdd(totalBaseTokenAmount, tokenIds, minLpTokenAmount, proofs);

        tokenIds.pop();
        tokenIds.pop();
        tokenIds.pop();
    }

    function testItReturnsBaseTokenAmountAndFractionalTokenAmount() public {
        // arrange
        uint256 lpTokenAmount = (totalLpTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 expectedBaseTokenAmount = (totalBaseTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 expectedFractionalTokenAmount = tokenIds.length * 1e18;

        // act
        (uint256 baseTokenAmount, uint256 fractionalTokenAmount) =
            p.nftRemove(lpTokenAmount, expectedBaseTokenAmount, tokenIds);

        // assert
        assertEq(baseTokenAmount, expectedBaseTokenAmount, ""Should have returned correct base token amount"");
        assertEq(
            fractionalTokenAmount, expectedFractionalTokenAmount, ""Should have returned correct fractional token amount""
        );
    }

    function testItBurnsLpTokens() public {
        // arrange
        uint256 lpTokenAmount = (totalLpTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 minBaseTokenOutputAmount = (totalBaseTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 balanceBefore = lpToken.balanceOf(address(this));
        uint256 totalSupplyBefore = lpToken.totalSupply();

        // act
        p.nftRemove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds);

        // assert
        assertEq(
            balanceBefore - lpToken.balanceOf(address(this)), lpTokenAmount, ""Should have burned lp tokens from sender""
        );
        assertEq(totalSupplyBefore - lpToken.totalSupply(), lpTokenAmount, ""Should have burned lp tokens"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 lpTokenAmount = (totalLpTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 minBaseTokenOutputAmount = (totalBaseTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 thisBalanceBefore = usd.balanceOf(address(this));
        uint256 balanceBefore = usd.balanceOf(address(p));

        // act
        p.nftRemove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds);

        // assert
        assertEq(
            usd.balanceOf(address(this)) - thisBalanceBefore,
            minBaseTokenOutputAmount,
            ""Should have transferred base tokens to sender""
        );

        assertEq(
            balanceBefore - usd.balanceOf(address(p)),
            minBaseTokenOutputAmount,
            ""Should have transferred base tokens from pair""
        );
    }

    function testItTransfersNfts() public {
        // arrange
        uint256 lpTokenAmount = (totalLpTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 minBaseTokenOutputAmount = (totalBaseTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();

        // act
        p.nftRemove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(this), ""Should have sent bayc to sender"");
        }
    }

    function testItRevertsNftSlippage() public {
        // arrange
        uint256 lpTokenAmount = (totalLpTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 minBaseTokenOutputAmount = (totalBaseTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        tokenIds.push(100); // add a token to cause revert

        // act
        vm.expectRevert(""Slippage: fractional token out"");
        p.nftRemove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds);
    }

    function testItRevertsBaseTokenSlippage() public {
        // arrange
        uint256 lpTokenAmount = (totalLpTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves();
        uint256 minBaseTokenOutputAmount =
            (totalBaseTokenAmount * tokenIds.length * 1e18) / p.fractionalTokenReserves() + 1; // add 1 to cause revert

        // act
        vm.expectRevert(""Slippage: base token amount out"");
        p.nftRemove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds);
    }
}",1256
RealWorld_TA_193_NftBuy.t_RealWorld_20240816083339.log,193,NftBuy.t,79833,3348,83181,117.0,0.466125,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import ""forge-std/Test.sol"";
import ""forge-std/console.sol"";

import ""../../shared/Fixture.t.sol"";
import ""../../../src/Caviar.sol"";

contract NftBuyTest is Fixture {
    uint256 public outputAmount;
    uint256 public maxInputAmount;
    uint256[] public tokenIds;
    bytes32[][] public proofs;

    function setUp() public {
        for (uint256 i = 0; i < 5; i++) {
            bayc.mint(address(this), i);
            tokenIds.push(i);
        }

        bayc.setApprovalForAll(address(p), true);
        usd.approve(address(p), type(uint256).max);

        uint256 baseTokenAmount = 3.15e18;
        uint256 minLpTokenAmount = Math.sqrt(baseTokenAmount * tokenIds.length * 1e18);
        deal(address(usd), address(this), baseTokenAmount, true);
        p.nftAdd(baseTokenAmount, tokenIds, minLpTokenAmount, proofs);

        tokenIds.pop();
        tokenIds.pop();
        outputAmount = tokenIds.length * 1e18;
        maxInputAmount =
            (outputAmount * p.baseTokenReserves() * 1000) / ((p.fractionalTokenReserves() - outputAmount) * 997);
        deal(address(usd), address(this), maxInputAmount, true);
    }

    function testItReturnsInputAmount() public {
        // arrange
        uint256 expectedInputAmount = maxInputAmount;

        // act
        uint256 inputAmount = p.nftBuy(tokenIds, maxInputAmount);

        // assert
        assertEq(inputAmount, expectedInputAmount, ""Should have returned input amount"");
    }

    function testItTransfersBaseTokens() public {
        // arrange
        uint256 balanceBefore = usd.balanceOf(address(p));
        uint256 thisBalanceBefore = usd.balanceOf(address(this));

        // act
        p.nftBuy(tokenIds, maxInputAmount);

        // assert
        assertEq(
            usd.balanceOf(address(p)) - balanceBefore, maxInputAmount, ""Should have transferred base tokens to pair""
        );
        assertEq(
            thisBalanceBefore - usd.balanceOf(address(this)),
            maxInputAmount,
            ""Should have transferred base tokens from sender""
        );
    }

    function testItTransfersNfts() public {
        // act
        p.nftBuy(tokenIds, maxInputAmount);

        // assert
        for (uint256 i = 0; i < tokenIds.length; i++) {
            assertEq(bayc.ownerOf(i), address(this), ""Should have sent bayc to sender"");
        }
    }

    function testItRevertsSlippageOnBuy() public {
        // arrange
        maxInputAmount -= 1; // subtract 1 to cause revert

        // act
        vm.expectRevert(""Slippage: amount in"");
        p.nftBuy(tokenIds, maxInputAmount);
    }

    function testItBurnsFractionalTokens() public {
        // arrange
        uint256 totalSupplyBefore = p.totalSupply();

        // act
        p.nftBuy(tokenIds, maxInputAmount);

        // assert
        assertEq(totalSupplyBefore - p.totalSupply(), tokenIds.length * 1e18, ""Should have burned fractional tokens"");
    }
}",721
