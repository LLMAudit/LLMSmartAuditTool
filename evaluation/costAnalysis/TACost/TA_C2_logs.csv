filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_TA_22_ERC20Mock_RealWorld_20240803002220.log,22,ERC20Mock,34646,3112,37758,117.0,0.23547,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol"";

contract ERC20Mock is ERC20PresetMinterPauser {
  constructor(string memory name, string memory symbol) ERC20PresetMinterPauser(name, symbol) {}

  event TransferCalled(address sender, address recipient, uint256 amount);

  bool shouldMockTransfer = true;

  function setShouldMockTransfer(bool _value) public {
    shouldMockTransfer = _value;
  }

  function transfer(address recipient, uint256 amount) public override returns (bool) {
    emit TransferCalled(_msgSender(), recipient, amount);
    if (shouldMockTransfer) {
      return true;
    } else {
      return super.transfer(recipient, amount);
    }
  }
}",186
RealWorld_TA_22_Staker_RealWorld_20240802235238.log,22,Staker,830377,675,831052,204.0,4.165385,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ISyntheticToken.sol"";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, ""not admin"");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, ""not valid synth"");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), ""not valid market"");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), ""not long short"");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, ""marketLaunchIncentiveMultiplier must be >= 1e18"");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      ""balanceIncentiveCurve_exponent out of bounds""
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      ""balanceIncentiveCurve_equilibriumOffset out of bounds""
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, ""nothing to withdraw"");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        ""Outstanding next price stake shifts too great""
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}",10095
RealWorld_TA_22_OracleManagerEthKillerChainlinkTestnet_RealWorld_20240803004014.log,22,OracleManagerEthKillerChainlinkTestnet,43317,3543,46860,114.0,0.287445,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""./OracleManagerEthKillerChainlink.sol"";

contract OracleManagerEthKillerChainlinkTestnet is OracleManagerEthKillerChainlink {
  uint256 lastUpdate;
  uint256 maxUpdateIntervalSeconds;
  int256 forcedPriceAdjustment;

  constructor(
    address _admin,
    address _tronOracle,
    address _eosOracle,
    address _xrpOracle,
    uint256 _maxUpdateIntervalSeconds
  ) OracleManagerEthKillerChainlink(_admin, _tronOracle, _eosOracle, _xrpOracle) {
    maxUpdateIntervalSeconds = _maxUpdateIntervalSeconds;
  }

  function setMaxUpdateInterval(uint256 newMaxUpdateIntervalSeconds) external adminOnly {
    maxUpdateIntervalSeconds = newMaxUpdateIntervalSeconds;
  }

  function _updatePrice() internal override returns (int256) {
    int256 previousPrice = indexPrice;
    int256 latestPrice = super._updatePrice();

    if (previousPrice != latestPrice || lastUpdate + maxUpdateIntervalSeconds < block.timestamp) {
      forcedPriceAdjustment = (forcedPriceAdjustment + 1) % 2;
      lastUpdate = block.timestamp;
    }

    return latestPrice + forcedPriceAdjustment;
  }
}",277
RealWorld_TA_22_IOracleManager_RealWorld_20240803010638.log,22,IOracleManager,25692,1794,27486,98.0,0.16434,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

/*
 * Manages price feeds from different oracle implementations.
 */
interface IOracleManager {
  function updatePrice() external returns (int256);

  /*
   *Returns the latest price from the oracle feed.
   */
  function getLatestPrice() external view returns (int256);
}",78
RealWorld_TA_22_LendingPoolAaveMock_RealWorld_20240803002419.log,22,LendingPoolAaveMock,28832,3196,32028,110.0,0.20808,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

contract LendingPoolAaveMock {
  function deposit(
    address asset,
    uint256 amount,
    address onBehalfOf,
    uint16 referralCode
  ) public pure {
    return ();
  }

  function withdraw(
    address asset,
    uint256 amount,
    address to
  ) public pure returns (uint256) {
    return (abi.decode("""", (uint256)));
  }
}",105
RealWorld_TA_22_StakerInternalStateSetters_RealWorld_20240803004608.log,22,StakerInternalStateSetters,231972,4037,236009,144.0,1.2406,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""../Staker.sol"";

/*
NOTE: This contract is for testing purposes only!
*/

contract StakerInternalStateSetters is Staker {
  ///////////////////////////////////////////////
  //////////// Test Helper Functions ////////////
  ///////////////////////////////////////////////
  // TODO: remove parts of this function that aren't necessary for the updated `_calculateAccumulatedFloat` funciton
  function setFloatRewardCalcParams(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 newLatestRewardIndex,
    address user,
    uint256 usersLatestClaimedReward,
    uint256 accumulativeFloatPerTokenLatestLong,
    uint256 accumulativeFloatPerTokenLatestShort,
    uint256 accumulativeFloatPerTokenUserLong,
    uint256 accumulativeFloatPerTokenUserShort,
    uint256 newUserAmountStakedLong,
    uint256 newUserAmountStakedShort
  ) public {
    latestRewardIndex[marketIndex] = newLatestRewardIndex;
    userIndexOfLastClaimedReward[marketIndex][user] = usersLatestClaimedReward;
    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newLatestRewardIndex]
    .accumulativeFloatPerSyntheticToken_long = accumulativeFloatPerTokenLatestLong;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][usersLatestClaimedReward]
    .accumulativeFloatPerSyntheticToken_long = accumulativeFloatPerTokenUserLong;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newLatestRewardIndex]
    .accumulativeFloatPerSyntheticToken_short = accumulativeFloatPerTokenLatestShort;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][usersLatestClaimedReward]
    .accumulativeFloatPerSyntheticToken_short = accumulativeFloatPerTokenUserShort;

    userAmountStaked[longToken][user] = newUserAmountStakedLong;
    userAmountStaked[shortToken][user] = newUserAmountStakedShort;
  }

  function setCalculateAccumulatedFloatInRangeGlobals(
    uint32 marketIndex,
    uint256 rewardIndexTo,
    uint256 rewardIndexFrom,
    uint256 syntheticRewardToLongToken,
    uint256 syntheticRewardFromLongToken,
    uint256 syntheticRewardToShortToken,
    uint256 syntheticRewardFromShortToken
  ) public {
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
    .accumulativeFloatPerSyntheticToken_long = syntheticRewardToLongToken;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
    .accumulativeFloatPerSyntheticToken_short = syntheticRewardToShortToken;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
    .accumulativeFloatPerSyntheticToken_long = syntheticRewardFromLongToken;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
    .accumulativeFloatPerSyntheticToken_short = syntheticRewardFromShortToken;
  }

  function setShiftParams(
    uint32 marketIndex,
    address user,
    uint256 shiftAmountLong,
    uint256 shiftAmountShort,
    uint256 _userNextPrice_stakedSyntheticTokenShiftIndex,
    uint256 _batched_stakerNextTokenShiftIndex,
    uint256 _takerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping,
    uint256 _stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping
  ) public {
    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = _userNextPrice_stakedSyntheticTokenShiftIndex;
    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = shiftAmountLong;
    userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = shiftAmountShort;
    batched_stakerNextTokenShiftIndex[marketIndex] = _batched_stakerNextTokenShiftIndex;
    stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
      _userNextPrice_stakedSyntheticTokenShiftIndex
    ] = _takerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
    stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
      _userNextPrice_stakedSyntheticTokenShiftIndex
    ] = _stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  }

  function setShiftTokensParams(
    uint32 marketIndex,
    bool isShiftFromLong,
    address user,
    uint256 amountSyntheticTokensToShift,
    uint256 _userAmountStaked,
    uint256 _userNextPrice_stakedSyntheticTokenShiftIndex,
    uint256 _batched_stakerNextTokenShiftIndex,
    address syntheticToken
  ) public {
    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = _userNextPrice_stakedSyntheticTokenShiftIndex;
    batched_stakerNextTokenShiftIndex[marketIndex] = _batched_stakerNextTokenShiftIndex;

    if (isShiftFromLong) {
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = amountSyntheticTokensToShift;
    } else {
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = amountSyntheticTokensToShift;
    }

    syntheticTokens[marketIndex][isShiftFromLong] = syntheticToken;
    userAmountStaked[syntheticToken][user] = _userAmountStaked;
  }

  function setLongShort(address _longShort) public {
    longShort = _longShort;
  }

  function setAddNewStakingFundParams(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    address mockAddress,
    address longShortAddress
  ) public {
    longShort = address(longShortAddress);
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = 0; // don't test with 0
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 1;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 1;

    syntheticTokens[marketIndex][true] = mockAddress;
    syntheticTokens[marketIndex][false] = mockAddress;
  }

  function setAddNewStateForFloatRewardsGlobals(
    uint32 marketIndex,
    uint256 _batched_stakerNextTokenShiftIndex,
    uint256 _latestRewardIndex
  ) external {
    batched_stakerNextTokenShiftIndex[marketIndex] = _batched_stakerNextTokenShiftIndex;
    latestRewardIndex[marketIndex] = _latestRewardIndex;
  }

  function setGetMarketLaunchIncentiveParametersParams(
    uint32 marketIndex,
    uint256 period,
    uint256 multiplier
  ) external {
    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = multiplier;
  }

  function setGetKValueParams(uint32 marketIndex, uint256 timestamp) external {
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = timestamp;
  }

  function setStakeFromUserParams(
    address longshort,
    address token,
    uint32 marketIndexForToken
  ) external {
    longShort = address(longshort);
    marketIndexOfToken[token] = marketIndexForToken;
  }

  function setCalculateTimeDeltaParams(
    uint32 marketIndex,
    uint256 latestRewardIndexForMarket,
    uint256 timestamp
  ) external {
    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndexForMarket].timestamp = timestamp;
  }

  function setCalculateNewCumulativeRateParams(
    uint32 marketIndex,
    uint256 latestRewardIndexForMarket,
    uint256 accumFloatLong,
    uint256 accumFloatShort
  ) external {
    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
    .accumulativeFloatPerSyntheticToken_long = accumFloatLong;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
    .accumulativeFloatPerSyntheticToken_short = accumFloatShort;
  }

  function setSetRewardObjectsParams(uint32 marketIndex, uint256 latestRewardIndexForMarket) external {
    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;
  }

  function set_updateStateParams(
    address _longShort,
    address token,
    uint32 tokenMarketIndex
  ) public {
    longShort = _longShort;
    marketIndexOfToken[token] = tokenMarketIndex;
  }

  function set_mintFloatParams(address _floatToken, uint16 _floatPercentage) public {
    floatToken = _floatToken;
    floatPercentage = _floatPercentage;
  }

  function setMintAccumulatedFloatAndClaimFloatParams(uint32 marketIndex, uint256 latestRewardIndexForMarket) public {
    latestRewardIndex[marketIndex] = latestRewardIndexForMarket;
  }

  function set_stakeParams(
    address user,
    uint32 marketIndex,
    uint256 _latestRewardIndex,
    address token,
    uint256 _userAmountStaked,
    uint256 userLastRewardIndex
  ) external {
    marketIndexOfToken[token] = marketIndex;
    latestRewardIndex[marketIndex] = _latestRewardIndex;
    userAmountStaked[token][user] = _userAmountStaked;
    userIndexOfLastClaimedReward[marketIndex][user] = userLastRewardIndex;
  }

  function set_withdrawGlobals(
    uint32 marketIndex,
    address syntheticToken,
    address user,
    uint256 amountStaked,
    uint256 fees,
    address treasury
  ) external {
    marketIndexOfToken[syntheticToken] = marketIndex;
    marketUnstakeFee_e18[marketIndex] = fees;
    userAmountStaked[syntheticToken][user] = amountStaked;
    floatTreasury = treasury;
  }

  function setWithdrawGlobals(
    uint32 marketIndex,
    address _longShort,
    address token
  ) external {
    marketIndexOfToken[token] = marketIndex;
    longShort = _longShort;
  }

  function setWithdrawAllGlobals(
    uint32 marketIndex,
    address _longShort,
    address user,
    uint256 amountStaked,
    address token
  ) external {
    marketIndexOfToken[token] = marketIndex;
    longShort = _longShort;
    userAmountStaked[token][user] = amountStaked;
  }

  function setEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset) external {
    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  ///////////////////////////////////////////////////////
  //////////// Functions for Experimentation ////////////
  ///////////////////////////////////////////////////////

  function getRequiredAmountOfBitShiftForSafeExponentiationPerfect(uint256 number, uint256 exponent)
    external
    pure
    returns (uint256 amountOfBitShiftRequired)
  {
    uint256 targetMaxNumberSizeBinaryDigits = 257 / exponent;

    // Note this can be optimised, this gets a quick easy to compute safe upper bound, not the actuall upper bound.
    uint256 targetMaxNumber = 2**targetMaxNumberSizeBinaryDigits;

    while (number >> amountOfBitShiftRequired > targetMaxNumber) {
      ++amountOfBitShiftRequired;
    }
  }
}",2561
RealWorld_TA_22_YieldManagerMock_RealWorld_20240803002759.log,22,YieldManagerMock,106820,5392,112212,147.0,0.64194,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol"";

import ""../interfaces/IYieldManager.sol"";
import ""../interfaces/aave/IAaveIncentivesController.sol"";

/*
 * YieldManagerMock is an implementation of a yield manager that supports
 * configurable, deterministic token yields for testing. Note that the mock
 * needs to be able to mint the underlying token to simulate yield.
 */
contract YieldManagerMock is IYieldManager {
  // Admin contracts.
  address public admin;
  address public longShort;
  address public treasury;

  // Fixed-precision scale for interest percentages and fees.
  uint256 public constant TEN_TO_THE_18 = 1e18;

  // Global state.
  ERC20PresetMinterPauser public token;
  ERC20PresetMinterPauser public tokenOtherRewardERC20;

  uint256 public override totalReservedForTreasury;
  uint256 public totalHeld;

  uint256 public yieldRate; // pcnt per sec
  uint256 public lastSettled; // secs after epoch

  event ClaimAaveRewardTokenToTreasury(uint256 amount);

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier longShortOnly() {
    require(msg.sender == longShort, ""Not longShort"");
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(
    address _longShort,
    address _treasury,
    address _token
  ) {
    // Admin contracts.
    longShort = _longShort;
    treasury = _treasury;

    // Global state.
    token = ERC20PresetMinterPauser(_token);
    lastSettled = block.timestamp;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////

  /**
   * Adds the token's accrued yield to the token holdings.
   */
  function settle() public {
    uint256 totalYieldRate = yieldRate * (block.timestamp - lastSettled);
    uint256 totalYield = (totalHeld * totalYieldRate) / TEN_TO_THE_18;

    lastSettled = block.timestamp;
    totalHeld = totalHeld + totalYield;
    if (totalYield > 0) {
      token.mint(address(this), totalYield);
    }
  }

  /**
   * Adds the given yield percent to the token holdings.
   */
  function settleWithYieldPercent(uint256 yieldPercent) external {
    uint256 totalYield = (totalHeld * yieldPercent) / TEN_TO_THE_18;

    lastSettled = block.timestamp;
    totalHeld = totalHeld + totalYield;
    token.mint(address(this), totalYield);
  }

  /**
   * Adds the given absolute yield to the token holdings.
   */
  function settleWithYieldAbsolute(uint256 totalYield) external {
    lastSettled = block.timestamp;
    totalHeld = totalHeld + totalYield;
    token.mint(address(this), totalYield);
  }

  /**
   * Sets the yield percentage per second for the given token.
   */
  function setYieldRate(uint256 _yieldRate) external {
    yieldRate = _yieldRate;
  }

  function depositPaymentToken(uint256 amount) external override longShortOnly {
    // Ensure token state is current.
    settle();

    // Transfer tokens to manager contract.
    totalHeld = totalHeld + amount;
  }

  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave
  /// @param user User to recieve the payout
  /// @param amount Amount of payment token to pay to user
  function transferPaymentTokensToUser(address user, uint256 amount) external override longShortOnly {
    // Transfer tokens back to LongShort contract.
    token.transfer(user, amount);
  }

  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {
    // Ensure token state is current.
    settle();
    require(amount <= totalHeld);

    totalHeld = totalHeld - amount;
  }

  function distributeYieldForTreasuryAndReturnMarketAllocation(
    uint256 totalValueRealizedForMarket,
    uint256 treasuryYieldPercent_e18
  ) external override longShortOnly returns (uint256) {
    uint256 unrealizedYield = totalHeld - totalValueRealizedForMarket - totalReservedForTreasury;

    if (unrealizedYield == 0) {
      return 0;
    }

    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / TEN_TO_THE_18;
    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;

    totalReservedForTreasury += amountForTreasury;

    return amountForMarketIncentives;
  }

  function withdrawTreasuryFunds() external override longShortOnly {}
}",1074
RealWorld_TA_22_ISyntheticToken_RealWorld_20240803011133.log,22,ISyntheticToken,27837,1640,29477,94.0,0.171985,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol"";

/**
@title SyntheticToken
@notice An ERC20 token that tracks or inversely tracks the price of an
        underlying asset with floating exposure.
*/
abstract contract ISyntheticToken is ERC20PresetMinterPauser {
  /// @notice Allows users to stake their synthetic tokens to earn Float.
  function stake(uint256 amount) external virtual;
}",119
RealWorld_TA_22_IFloatToken_RealWorld_20240803010312.log,22,IFloatToken,23318,2323,25641,100.0,0.16305,"pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

abstract contract IFloatToken is IERC20Upgradeable {
  function mint(address to, uint256 amount) public virtual;
}",57
RealWorld_TA_22_StakerForInternalMocking_RealWorld_20240803005416.log,22,StakerForInternalMocking,95132,3431,98563,124.0,0.54428,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.3;

import ""./StakerMockable.sol"";

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";
import ""../../interfaces/IFloatToken.sol"";
import ""../../interfaces/ILongShort.sol"";
import ""../../interfaces/IStaker.sol"";
import ""../../interfaces/ISyntheticToken.sol"";

contract StakerForInternalMocking {
  function onlyAdminModifierLogicMock() public pure {
    return ();
  }

  function onlyValidSyntheticModifierLogicMock(address) public pure {
    return ();
  }

  function onlyValidMarketModifierLogicMock(uint32) public pure {
    return ();
  }

  function onlyLongShortModifierLogicMock() public pure {
    return ();
  }

  function initializeMock(
    address,
    address,
    address,
    address,
    address,
    uint256
  ) public pure {
    return ();
  }

  function _changeFloatPercentageMock(uint256) public pure {
    return ();
  }

  function _changeUnstakeFeeMock(uint32, uint256) public pure {
    return ();
  }

  function _changeMarketLaunchIncentiveParametersMock(
    uint32,
    uint256,
    uint256
  ) public pure {
    return ();
  }

  function _changeBalanceIncentiveExponentMock(uint32, uint256) public pure {
    return ();
  }

  function _changeBalanceIncentiveEquilibriumOffsetMock(uint32, int256) public pure {
    return ();
  }

  function _getMarketLaunchIncentiveParametersMock(uint32) public pure returns (uint256 period, uint256 multiplier) {
    return (abi.decode("""", (uint256)), abi.decode("""", (uint256)));
  }

  function _getKValueMock(uint32) public pure returns (uint256) {
    return (abi.decode("""", (uint256)));
  }

  function _calculateFloatPerSecondMock(
    uint32,
    uint256,
    uint256,
    uint256,
    uint256
  ) public pure returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    return (abi.decode("""", (uint256)), abi.decode("""", (uint256)));
  }

  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotMock(uint32)
    public
    pure
    returns (uint256)
  {
    return (abi.decode("""", (uint256)));
  }

  function _calculateNewCumulativeIssuancePerStakedSynthMock(
    uint32,
    uint256,
    uint256,
    uint256,
    uint256
  ) public pure returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    return (abi.decode("""", (uint256)), abi.decode("""", (uint256)));
  }

  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshotMock(
    uint32,
    uint256,
    uint256,
    uint256,
    uint256
  ) public pure {
    return ();
  }

  function _calculateAccumulatedFloatInRangeMock(
    uint32,
    uint256,
    uint256,
    uint256,
    uint256
  ) public pure returns (uint256 floatReward) {
    return (abi.decode("""", (uint256)));
  }

  function _calculateAccumulatedFloatMock(uint32, address) public pure returns (uint256 floatReward) {
    return (abi.decode("""", (uint256)));
  }

  function _mintFloatMock(address, uint256) public pure {
    return ();
  }

  function _mintAccumulatedFloatMock(uint32, address) public pure {
    return ();
  }

  function _mintAccumulatedFloatMultiMock(uint32[] memory, address) public pure {
    return ();
  }

  function stakeFromUserMock(address, uint256) public pure {
    return ();
  }

  function _stakeMock(
    address,
    uint256,
    address
  ) public pure {
    return ();
  }

  function shiftTokensMock(
    uint256,
    uint32,
    bool
  ) public pure {
    return ();
  }

  function _withdrawMock(
    uint32,
    address,
    uint256
  ) public pure {
    return ();
  }
}",914
RealWorld_TA_22_LongShortInternalStateSetters_RealWorld_20240803004834.log,22,LongShortInternalStateSetters,225572,5140,230712,161.0,1.23066,"pragma solidity 0.8.3;

import ""../LongShort.sol"";

/*
NOTE: This contract is for testing purposes only!
*/

contract LongShortInternalStateSetters is LongShort {
  bool overRideexecuteOutstandingNextPriceSettlements;

  event executeOutstandingNextPriceSettlementsMock(address _user, uint32 _marketIndex);

  function setInitializeMarketParams(
    uint32 marketIndex,
    bool marketIndexValue,
    uint32 _latestMarket,
    address _staker,
    address longAddress,
    address shortAddress
  ) public {
    latestMarket = _latestMarket;
    marketExists[marketIndex] = marketIndexValue;
    staker = (_staker);
    syntheticTokens[marketIndex][
      true /*short*/
    ] = (longAddress);
    syntheticTokens[marketIndex][
      false /*short*/
    ] = (shortAddress);
  }

  function setMarketExistsMulti(uint32[] calldata marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      marketExists[marketIndexes[i]] = true;
    }
  }

  function set_updateSystemStateInternalGlobals(
    uint32 marketIndex,
    uint256 _latestUpdateIndexForMarket,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short,
    uint256 _assetPrice,
    uint256 longValue,
    uint256 shortValue,
    address oracleManager,
    address _staker,
    address synthLong,
    address synthShort,
    uint256 stakerNextPrice_currentUpdateIndex
  ) public {
    marketExists[marketIndex] = true;
    marketUpdateIndex[marketIndex] = _latestUpdateIndexForMarket;
    syntheticToken_priceSnapshot[marketIndex][true][
      _latestUpdateIndexForMarket
    ] = syntheticTokenPrice_inPaymentTokens_long;
    syntheticToken_priceSnapshot[marketIndex][false][
      _latestUpdateIndexForMarket
    ] = syntheticTokenPrice_inPaymentTokens_short;

    marketSideValueInPaymentToken[marketIndex][true] = longValue;
    marketSideValueInPaymentToken[marketIndex][false] = shortValue;

    assetPrice[marketIndex] = _assetPrice;
    oracleManagers[marketIndex] = oracleManager;

    syntheticTokens[marketIndex][true] = synthLong;
    syntheticTokens[marketIndex][false] = synthShort;

    staker = _staker;

    userNextPrice_currentUpdateIndex[marketIndex][_staker] = stakerNextPrice_currentUpdateIndex;
  }

  function setUseexecuteOutstandingNextPriceSettlementsMock(bool shouldUseMock) public {
    overRideexecuteOutstandingNextPriceSettlements = shouldUseMock;
  }

  function _executeOutstandingNextPriceSettlementsMock(address _user, uint32 _marketIndex) internal {
    emit executeOutstandingNextPriceSettlementsMock(_user, _marketIndex);
  }

  function _executeOutstandingNextPriceSettlementsExposedWithEvent(address user, uint32 marketIndex) external {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  function setGetUsersConfirmedButNotSettledBalanceGlobals(
    uint32 marketIndex,
    address user,
    bool isLong,
    uint256 _userNextPrice_currentUpdateIndex,
    uint256 _marketUpdateIndex,
    uint256 _userNextPrice_paymentToken_depositAmount_isLong,
    uint256 _syntheticToken_priceSnapshot_isLong,
    uint256 _syntheticToken_priceSnapshot_notIsLong,
    uint256 _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide_notIsLong
  ) external {
    marketExists[marketIndex] = true;
    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;
    marketUpdateIndex[marketIndex] = _marketUpdateIndex;

    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][
      user
    ] = _userNextPrice_paymentToken_depositAmount_isLong;
    userNextPrice_paymentToken_depositAmount[marketIndex][!isLong][user] = 0; // reset other side for good measure

    syntheticToken_priceSnapshot[marketIndex][isLong][_marketUpdateIndex] = _syntheticToken_priceSnapshot_isLong;
    syntheticToken_priceSnapshot[marketIndex][!isLong][_marketUpdateIndex] = _syntheticToken_priceSnapshot_notIsLong;

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][
      user
    ] = _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide_notIsLong;
    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isLong][user] = 0; // reset other side for good measure
  }

  function setPerformOustandingBatchedSettlementsGlobals(
    uint32 marketIndex,
    uint256 batched_amountPaymentToken_depositLong,
    uint256 batched_amountPaymentToken_depositShort,
    uint256 batched_amountSyntheticToken_redeemLong,
    uint256 batched_amountSyntheticToken_redeemShort,
    uint256 batchedAmountSyntheticTokenToShiftFromLong,
    uint256 batchedAmountSyntheticTokenToShiftFromShort
  ) external {
    batched_amountPaymentToken_deposit[marketIndex][true] = batched_amountPaymentToken_depositLong;
    batched_amountPaymentToken_deposit[marketIndex][false] = batched_amountPaymentToken_depositShort;
    batched_amountSyntheticToken_redeem[marketIndex][true] = batched_amountSyntheticToken_redeemLong;
    batched_amountSyntheticToken_redeem[marketIndex][false] = batched_amountSyntheticToken_redeemShort;
    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      true
    ] = batchedAmountSyntheticTokenToShiftFromLong;
    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ] = batchedAmountSyntheticTokenToShiftFromShort;
  }

  function setHandleChangeInSyntheticTokensTotalSupplyGlobals(
    uint32 marketIndex,
    address longSyntheticToken,
    address shortSyntheticToken
  ) external {
    syntheticTokens[marketIndex][true] = longSyntheticToken;
    syntheticTokens[marketIndex][false] = shortSyntheticToken;
  }

  function setHandleTotalValueChangeForMarketWithYieldManagerGlobals(uint32 marketIndex, address yieldManager)
    external
  {
    yieldManagers[marketIndex] = yieldManager;
  }

  function setMintNextPriceGlobals(uint32 marketIndex, uint256 _marketUpdateIndex) external {
    marketUpdateIndex[marketIndex] = _marketUpdateIndex;
  }

  function setRedeemNextPriceGlobals(
    uint32 marketIndex,
    uint256 _marketUpdateIndex,
    address syntheticToken,
    bool isLong
  ) external {
    marketUpdateIndex[marketIndex] = _marketUpdateIndex;
    syntheticTokens[marketIndex][isLong] = syntheticToken;
  }

  function setShiftNextPriceGlobals(
    uint32 marketIndex,
    uint256 _marketUpdateIndex,
    address syntheticTokenShiftedFrom,
    bool isShiftFromLong
  ) external {
    marketUpdateIndex[marketIndex] = _marketUpdateIndex;
    syntheticTokens[marketIndex][isShiftFromLong] = syntheticTokenShiftedFrom;
  }

  function setExecuteOutstandingNextPriceMintsGlobals(
    uint32 marketIndex,
    address user,
    bool isLong,
    address syntheticToken,
    uint256 _userNextPrice_syntheticToken_redeemAmount,
    uint256 _userNextPrice_currentUpdateIndex,
    uint256 _syntheticToken_priceSnapshot
  ) external {
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = _userNextPrice_syntheticToken_redeemAmount;
    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;
    syntheticToken_priceSnapshot[marketIndex][isLong][
      _userNextPrice_currentUpdateIndex
    ] = _syntheticToken_priceSnapshot;
    syntheticTokens[marketIndex][isLong] = syntheticToken;
  }

  function setExecuteOutstandingNextPriceRedeemsGlobals(
    uint32 marketIndex,
    address user,
    bool isLong,
    address yieldManager,
    uint256 _userNextPrice_syntheticToken_redeemAmount,
    uint256 _userNextPrice_currentUpdateIndex,
    uint256 _syntheticToken_priceSnapshot
  ) external {
    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = _userNextPrice_syntheticToken_redeemAmount;
    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;
    syntheticToken_priceSnapshot[marketIndex][isLong][
      _userNextPrice_currentUpdateIndex
    ] = _syntheticToken_priceSnapshot;
    yieldManagers[marketIndex] = yieldManager;
  }

  function setExecuteOutstandingNextPriceTokenShiftsGlobals(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong,
    address syntheticTokenShiftedTo,
    uint256 _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide,
    uint256 _userNextPrice_currentUpdateIndex,
    uint256 _syntheticToken_priceSnapshotShiftedFrom,
    uint256 _syntheticToken_priceSnapshotShiftedTo
  ) external {
    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      user
    ] = _userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;
    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;
    syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      _userNextPrice_currentUpdateIndex
    ] = _syntheticToken_priceSnapshotShiftedFrom;
    syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      _userNextPrice_currentUpdateIndex
    ] = _syntheticToken_priceSnapshotShiftedTo;
    syntheticTokens[marketIndex][!isShiftFromLong] = syntheticTokenShiftedTo;
  }

  function setExecuteOutstandingNextPriceSettlementsGlobals(
    uint32 marketIndex,
    address user,
    uint256 _userNextPrice_currentUpdateIndex,
    uint256 _marketUpdateIndex
  ) external {
    userNextPrice_currentUpdateIndex[marketIndex][user] = _userNextPrice_currentUpdateIndex;
    marketUpdateIndex[marketIndex] = _marketUpdateIndex;
  }

  function setClaimAndDistributeYieldThenRebalanceMarketGlobals(
    uint32 marketIndex,
    uint256 _marketSideValueInPaymentTokenLong,
    uint256 _marketSideValueInPaymentTokenShort,
    address yieldManager
  ) external {
    marketSideValueInPaymentToken[marketIndex][true] = _marketSideValueInPaymentTokenLong;
    marketSideValueInPaymentToken[marketIndex][false] = _marketSideValueInPaymentTokenShort;
    yieldManagers[marketIndex] = yieldManager;
  }

  function setDepositFundsGlobals(
    uint32 marketIndex,
    address paymentToken,
    address yieldManager
  ) external {
    paymentTokens[marketIndex] = paymentToken;
    yieldManagers[marketIndex] = yieldManager;
  }

  function setLockFundsInMarketGlobals(uint32 marketIndex, address yieldManager) external {
    yieldManagers[marketIndex] = yieldManager;
  }
}",2482
RealWorld_TA_22_Treasury_v0_RealWorld_20240803001307.log,22,Treasury,37921,1824,39745,98.0,0.226085,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/** @title Treasury Contract */
contract Treasury_v0 is Initializable {
  address public admin;

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  modifier onlyAdmin() {
    require(msg.sender == admin, ""Not admin"");
    _;
  }

  /*╔══════════════════════════════╗
    ║        CONTRACT SETUP        ║
    ╚══════════════════════════════╝*/

  function initialize(address _admin) external initializer {
    admin = _admin;
  }

  /*╔════════════════════════════════╗
    ║    MULTISIG ADMIN FUNCTIONS    ║
    ╚════════════════════════════════╝*/

  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
  }

  /** To be upgraded in future allowing governance of treasury 
    and its funds */
}",295
RealWorld_TA_22_ILongShort_RealWorld_20240803011309.log,22,ILongShort,37845,1515,39360,89.0,0.219525,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

abstract contract ILongShort {
  function updateSystemState(uint32 marketIndex) external virtual;

  function updateSystemStateMulti(uint32[] calldata marketIndex) external virtual;

  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual returns (uint256 confirmedButNotSettledBalance);

  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external virtual;

  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external virtual;

  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external virtual;

  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticTokenShiftedFromOneSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual returns (uint256 amountSynthShiftedToOtherSide);
}",240
RealWorld_TA_22_OracleManagerFlippening_V0_RealWorld_20240803004210.log,22,OracleManagerFlippening,126734,3930,130664,124.0,0.71227,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

import ""../interfaces/IOracleManager.sol"";

/**
  Contract that estimates ETH / BTC dominance,
  expressed as (eth market cap) / (btc market cap)
  Estimates BTC & ETH supply. In the future
  look towards using oracles for it. 
*/
contract OracleManagerFlippening_V0 is IOracleManager {
  address public admin; // This will likely be the Gnosis safe

  int256 public ethDominance;

  uint256 public ethSupply; // 18 decimals
  uint256 public btcSupply; // 8 decimals

  uint256 public btcBlocksPerDay;
  uint256 public ethBlocksPerDay;

  uint256 public btcBlockReward; // 8 decimals
  uint256 public ethBlockReward; // 18 decimals

  uint256 public ethUnclesPerDay;

  // Eth has a variable uncle reward:
  //       - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1234.md,
  // Source here says it's roughly 75%:
  //       - https://docs.ethhub.io/ethereum-basics/monetary-policy/
  // Might be worth also looking into just taking it as the mean of the possibilities
  //         = sum from 1 to 7 of (8 - sumIndex) * blockReward / 8 / 7

  uint256 public ethUncleReward; // 18 decimals

  uint256 public ethNephewReward; // 18 decimals. currently = blockReward / 32

  uint256 lastUpdated;

  // Oracle addresses
  AggregatorV3Interface public btcOracle;
  AggregatorV3Interface public ethOracle;

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin);
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(
    address _admin,
    address _btcOracle,
    address _ethOracle,
    uint256 _ethSupply,
    uint256 _btcSupply,
    uint256 _btcBlocksPerDay,
    uint256 _ethBlocksPerDay,
    uint256 _ethUnclesPerDay,
    uint256 _btcBlockReward,
    uint256 _ethBlockReward,
    uint256 _ethUncleReward,
    uint256 _ethNephewReward
  ) {
    admin = _admin;

    btcOracle = AggregatorV3Interface(_btcOracle);
    ethOracle = AggregatorV3Interface(_ethOracle);

    ethSupply = _ethSupply;
    btcSupply = _btcSupply;

    btcBlocksPerDay = _btcBlocksPerDay;

    ethBlocksPerDay = _ethBlocksPerDay;
    ethUnclesPerDay = _ethUnclesPerDay;

    btcBlockReward = _btcBlockReward;

    ethBlockReward = _ethBlockReward;
    ethUncleReward = _ethUncleReward;
    ethNephewReward = _ethNephewReward;

    lastUpdated = block.timestamp;

    _updatePrice();
  }

  ////////////////////////////////////
  /// MULTISIG ADMIN FUNCTIONS ///////
  ////////////////////////////////////

  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  function changeEthSupply(uint256 supply) external adminOnly {
    ethSupply = supply;
  }

  function changeBtcSupply(uint256 supply) external adminOnly {
    btcSupply = supply;
  }

  function changeBtcBlocksPerDay(uint256 blocks) external adminOnly {
    btcBlocksPerDay = blocks;
  }

  function changeEthBlocksPerDay(uint256 blocks) external adminOnly {
    ethBlocksPerDay = blocks;
  }

  function changeEthUnclesPerDay(uint256 uncles) external adminOnly {
    ethUnclesPerDay = uncles;
  }

  function changeBtcBlockReward(uint256 reward) external adminOnly {
    btcBlockReward = reward;
  }

  function changeEthBlockReward(uint256 reward) external adminOnly {
    ethBlockReward = reward;
  }

  function changeEthUncleReward(uint256 reward) external adminOnly {
    ethUncleReward = reward;
  }

  function changeEthNephewReward(uint256 reward) external adminOnly {
    ethNephewReward = reward;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////

  function _getBtcSupply() internal view returns (uint256) {
    return btcSupply + (((block.timestamp - lastUpdated) * btcBlocksPerDay * btcBlockReward) / (1 days));
  }

  function _getEthSupply() internal view returns (uint256) {
    return
      ethSupply +
      (((block.timestamp - lastUpdated) *
        (ethBlocksPerDay * ethBlockReward + ethUnclesPerDay * (ethNephewReward + ethUncleReward))) / 1 days);
  }

  function _updatePrice() private returns (int256) {
    (, int256 _ethPrice, , , ) = ethOracle.latestRoundData();
    (, int256 _btcPrice, , , ) = btcOracle.latestRoundData();
    ethSupply = _getEthSupply();
    btcSupply = _getBtcSupply();

    lastUpdated = block.timestamp;

    // ethSupply * ethPrice = 26 decimals
    // btcSupply * btcPrice = 16 decimals

    // 1e20 as 18 decimals but as %
    ethDominance = int256((uint256(_ethPrice) * ethSupply * 1e20) / (uint256(_btcPrice) * btcSupply * 1e10));

    return ethDominance;
  }

  function updatePrice() external override returns (int256) {
    return _updatePrice();
  }

  function getLatestPrice() external view override returns (int256) {
    return ethDominance;
  }
}",1270
RealWorld_TA_22_IStaker_RealWorld_20240803010454.log,22,IStaker,35352,2288,37640,102.0,0.22252,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

abstract contract IStaker {
  function addNewStakingFund(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external virtual;

  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longTokenPrice,
    uint256 shortTokenPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted
  ) external virtual;

  function stakeFromUser(address from, uint256 amount) public virtual;
}",193
RealWorld_TA_22_FloatCapital_v0_RealWorld_20240803000240.log,22,FloatCapital,38007,1952,39959,98.0,0.229075,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/** @title Float Capital Contract */
contract FloatCapital_v0 is Initializable {
  address public admin;

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  modifier onlyAdmin() {
    require(msg.sender == admin, ""Not admin"");
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SETUP        ║
    ╚═════════════════════════════╝*/

  function initialize(address _admin) external initializer {
    admin = _admin;
  }

  /*╔════════════════════════════════╗
    ║    MULTISIG ADMIN FUNCTIONS    ║
    ╚════════════════════════════════╝*/

  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
  }

  /** A percentage of float token to accrue here for project
     development */
}",297
RealWorld_TA_22_LongShort_RealWorld_20240802235746.log,22,LongShort,1122003,1044,1123047,291.0,5.630895,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/ITokenFactory.sol"";
import ""./interfaces/ISyntheticToken.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/IOracleManager.sol"";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, ""only admin"");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], ""market doesn't exist"");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Up "", syntheticName)),
      string(abi.encodePacked(""fu"", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Down "", syntheticName)),
      string(abi.encodePacked(""fd"", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      ""Insufficient market seed""
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], ""already initialized"");
    require(marketIndex <= latestMarket, ""index too high"");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - ""Pending"" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - ""Confirmed"" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - ""Settled"" - there is no more computation left for the user.
        - ""Non-existant"" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}",13680
RealWorld_TA_22_IYieldManager_RealWorld_20240803010116.log,22,IYieldManager,58097,2588,60685,114.0,0.342245,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

/// @notice Manages yield accumulation for the LongShort contract. Each market is deployed with its own yield manager to simplify the bookkeeping, as different markets may share a payment token and yield pool.
abstract contract IYieldManager {
  event YieldDistributed(uint256 unrealizedYield, uint256 treasuryYieldPercent_e18);

  /// @dev This is purely saving some gas, but the subgraph will know how much is due for the treasury at all times - no need to include in event.
  event WithdrawTreasuryFunds();

  /// @notice distributed yield not yet transferred to the treasury
  function totalReservedForTreasury() external virtual returns (uint256);

  /// @notice Deposits the given amount of payment tokens into this yield manager.
  /// @param amount Amount of payment token to deposit
  function depositPaymentToken(uint256 amount) external virtual;

  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave
  /// @param user User to recieve the payout
  /// @param amount Amount of payment token to pay to user
  function transferPaymentTokensToUser(address user, uint256 amount) external virtual;

  /// @notice Withdraws the given amount of tokens from this yield manager.
  /// @param amount Amount of payment token to withdraw
  function removePaymentTokenFromMarket(uint256 amount) external virtual;

  /**    
    @notice Calculates and updates the yield allocation to the treasury and the market
    @dev treasuryPercent = 1 - marketPercent
    @param totalValueRealizedForMarket total value of long and short side of the market
    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury
    @return amountForMarketIncentives The market allocation of the yield
  */
  function distributeYieldForTreasuryAndReturnMarketAllocation(
    uint256 totalValueRealizedForMarket,
    uint256 treasuryYieldPercent_e18
  ) external virtual returns (uint256 amountForMarketIncentives);

  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract
  function withdrawTreasuryFunds() external virtual;
}",478
RealWorld_TA_22_OracleManagerBand_RealWorld_20240803004416.log,22,OracleManagerBand,49904,2618,52522,109.0,0.30188,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;
pragma abicoder v2;

import ""../interfaces/IOracleManager.sol"";
import ""../interfaces/IBandOracle.sol"";

/*
 * Implementation of an OracleManager that fetches prices from a band oracle.
 */
contract OracleManagerBand is IOracleManager {
  // Admin addresses.
  address public admin;

  // Global state.
  IBandOracle public bandOracle;
  string public base; // base pair for prices
  string public quote; // quote pair for prices

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin, ""Not admin"");
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(
    address _admin,
    address _bandOracle,
    string memory _base,
    string memory _quote
  ) {
    admin = _admin;
    base = _base;
    quote = _quote;

    bandOracle = IBandOracle(_bandOracle);
  }

  ////////////////////////////////////
  /// MULTISIG ADMIN FUNCTIONS ///////
  ////////////////////////////////////

  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////
  function _getLatestPrice() internal view returns (int256) {
    IBandOracle.ReferenceData memory data = bandOracle.getReferenceData(base, quote);

    return int256(data.rate);
  }

  function getLatestPrice() external view override returns (int256) {
    return _getLatestPrice();
  }

  function updatePrice() external override returns (int256) {
    return _getLatestPrice();
  }
}",365
RealWorld_TA_22_TokenFactory_RealWorld_20240803001124.log,22,TokenFactory,74810,1851,76661,101.0,0.41107,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""./SyntheticToken.sol"";
import ""./interfaces/ITokenFactory.sol"";

/// @title TokenFactory
/// @notice contract is used to reliably mint the synthetic tokens used by the float protocol.
contract TokenFactory is ITokenFactory {
  /*╔═══════════════════════════╗
    ║           STATE           ║
    ╚═══════════════════════════╝*/

  /// @notice address of long short contract
  address public longShort;

  /// @notice admin role hash for the synthetic token
  bytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(""DEFAULT_ADMIN_ROLE"");
  /// @notice minter role hash for the synthetic token
  bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
  /// @notice pauser role hash for the synthetic token
  bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

  /*╔═══════════════════════════╗
    ║         MODIFIERS         ║
    ╚═══════════════════════════╝*/

  /// @dev only allow longShort contract to call this function
  modifier onlyLongShort() {
    require(msg.sender == address(longShort));
    _;
  }

  /*╔════════════════════════════╗
    ║           SET-UP           ║
    ╚════════════════════════════╝*/

  /// @notice sets the address of the longShort contract on initialization
  /// @param _longShort address of the longShort contract
  constructor(address _longShort) {
    longShort = _longShort;
  }

  /*╔════════════════════════════╗
    ║       TOKEN CREATION       ║
    ╚════════════════════════════╝*/

  /// @notice creates and sets up a new synthetic token
  /// @param syntheticName name of the synthetic token
  /// @param syntheticSymbol ticker symbol of the synthetic token
  /// @param staker address of the staker contract
  /// @param marketIndex market index this synthetic token belongs to
  /// @param isLong boolean denoting if the synthetic token is long or short
  /// @return syntheticToken - address of the created synthetic token
  function createSyntheticToken(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address staker,
    uint32 marketIndex,
    bool isLong
  ) external override onlyLongShort returns (address syntheticToken) {
    syntheticToken = address(
      new SyntheticToken(syntheticName, syntheticSymbol, longShort, staker, marketIndex, isLong)
    );

    // Give minter roles
    SyntheticToken(syntheticToken).grantRole(DEFAULT_ADMIN_ROLE, longShort);
    SyntheticToken(syntheticToken).grantRole(MINTER_ROLE, longShort);
    SyntheticToken(syntheticToken).grantRole(PAUSER_ROLE, longShort);

    // Revoke roles
    SyntheticToken(syntheticToken).revokeRole(DEFAULT_ADMIN_ROLE, address(this));
    SyntheticToken(syntheticToken).revokeRole(MINTER_ROLE, address(this));
    SyntheticToken(syntheticToken).revokeRole(PAUSER_ROLE, address(this));
  }
}",757
RealWorld_TA_22_ILendingPoolAddressesProvider_RealWorld_20240803011829.log,22,ILendingPoolAddressesProvider,57012,1785,58797,98.0,0.32076,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.3;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
  event MarketIdSet(string newMarketId);
  event LendingPoolUpdated(address indexed newAddress);
  event ConfigurationAdminUpdated(address indexed newAddress);
  event EmergencyAdminUpdated(address indexed newAddress);
  event LendingPoolConfiguratorUpdated(address indexed newAddress);
  event LendingPoolCollateralManagerUpdated(address indexed newAddress);
  event PriceOracleUpdated(address indexed newAddress);
  event LendingRateOracleUpdated(address indexed newAddress);
  event ProxyCreated(bytes32 id, address indexed newAddress);
  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

  function getMarketId() external view returns (string memory);

  function setMarketId(string calldata marketId) external;

  function setAddress(bytes32 id, address newAddress) external;

  function setAddressAsProxy(bytes32 id, address impl) external;

  function getAddress(bytes32 id) external view returns (address);

  function getLendingPool() external view returns (address);

  function setLendingPoolImpl(address pool) external;

  function getLendingPoolConfigurator() external view returns (address);

  function setLendingPoolConfiguratorImpl(address configurator) external;

  function getLendingPoolCollateralManager() external view returns (address);

  function setLendingPoolCollateralManager(address manager) external;

  function getPoolAdmin() external view returns (address);

  function setPoolAdmin(address admin) external;

  function getEmergencyAdmin() external view returns (address);

  function setEmergencyAdmin(address admin) external;

  function getPriceOracle() external view returns (address);

  function setPriceOracle(address priceOracle) external;

  function getLendingRateOracle() external view returns (address);

  function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_TA_22_StakerMockable_RealWorld_20240803005811.log,22,StakerMockable,357160,5325,362485,183.0,1.8923,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";
import ""../../interfaces/IFloatToken.sol"";
import ""../../interfaces/ILongShort.sol"";
import ""../../interfaces/IStaker.sol"";
import ""../../interfaces/ISyntheticToken.sol"";

import ""./StakerForInternalMocking.sol"";
import ""../StakerInternalStateSetters.sol"";

contract StakerMockable is StakerInternalStateSetters {
  StakerForInternalMocking mocker;
  bool shouldUseMock;
  string functionToNotMock;

  function setMocker(StakerForInternalMocking _mocker) external {
    mocker = _mocker;
    shouldUseMock = true;
  }

  function setFunctionToNotMock(string calldata _functionToNotMock) external {
    functionToNotMock = _functionToNotMock;
  }

  function onlyAdminModifierLogicExposed() external {
    return super.onlyAdminModifierLogic();
  }

  function onlyAdminModifierLogic() internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""onlyAdminModifierLogic""))
    ) {
      return mocker.onlyAdminModifierLogicMock();
    } else {
      return super.onlyAdminModifierLogic();
    }
  }

  function onlyValidSyntheticModifierLogicExposed(address _synth) external {
    return super.onlyValidSyntheticModifierLogic(_synth);
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""onlyValidSyntheticModifierLogic""))
    ) {
      return mocker.onlyValidSyntheticModifierLogicMock(_synth);
    } else {
      return super.onlyValidSyntheticModifierLogic(_synth);
    }
  }

  function onlyValidMarketModifierLogicExposed(uint32 marketIndex) external {
    return super.onlyValidMarketModifierLogic(marketIndex);
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""onlyValidMarketModifierLogic""))
    ) {
      return mocker.onlyValidMarketModifierLogicMock(marketIndex);
    } else {
      return super.onlyValidMarketModifierLogic(marketIndex);
    }
  }

  function onlyLongShortModifierLogicExposed() external {
    return super.onlyLongShortModifierLogic();
  }

  function onlyLongShortModifierLogic() internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""onlyLongShortModifierLogic""))
    ) {
      return mocker.onlyLongShortModifierLogicMock();
    } else {
      return super.onlyLongShortModifierLogic();
    }
  }

  function _changeFloatPercentageExposed(uint256 newFloatPercentage) external {
    return super._changeFloatPercentage(newFloatPercentage);
  }

  function _changeFloatPercentage(uint256 newFloatPercentage) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_changeFloatPercentage""))
    ) {
      return mocker._changeFloatPercentageMock(newFloatPercentage);
    } else {
      return super._changeFloatPercentage(newFloatPercentage);
    }
  }

  function _changeUnstakeFeeExposed(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external {
    return super._changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
  }

  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_changeUnstakeFee""))
    ) {
      return mocker._changeUnstakeFeeMock(marketIndex, newMarketUnstakeFee_e18);
    } else {
      return super._changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    }
  }

  function _changeMarketLaunchIncentiveParametersExposed(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external {
    return super._changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);
  }

  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_changeMarketLaunchIncentiveParameters""))
    ) {
      return mocker._changeMarketLaunchIncentiveParametersMock(marketIndex, period, initialMultiplier);
    } else {
      return super._changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);
    }
  }

  function _changeBalanceIncentiveExponentExposed(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
  {
    return super._changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
  }

  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    override
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_changeBalanceIncentiveExponent""))
    ) {
      return mocker._changeBalanceIncentiveExponentMock(marketIndex, _balanceIncentiveCurve_exponent);
    } else {
      return super._changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    }
  }

  function _changeBalanceIncentiveEquilibriumOffsetExposed(
    uint32 marketIndex,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external {
    return super._changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    override
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_changeBalanceIncentiveEquilibriumOffset""))
    ) {
      return mocker._changeBalanceIncentiveEquilibriumOffsetMock(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    } else {
      return super._changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    }
  }

  function _getMarketLaunchIncentiveParametersExposed(uint32 marketIndex)
    external
    view
    returns (uint256 period, uint256 multiplier)
  {
    return super._getMarketLaunchIncentiveParameters(marketIndex);
  }

  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    override
    returns (uint256 period, uint256 multiplier)
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_getMarketLaunchIncentiveParameters""))
    ) {
      return mocker._getMarketLaunchIncentiveParametersMock(marketIndex);
    } else {
      return super._getMarketLaunchIncentiveParameters(marketIndex);
    }
  }

  function _getKValueExposed(uint32 marketIndex) external view returns (uint256) {
    return super._getKValue(marketIndex);
  }

  function _getKValue(uint32 marketIndex) internal view override returns (uint256) {
    if (shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_getKValue""))) {
      return mocker._getKValueMock(marketIndex);
    } else {
      return super._getKValue(marketIndex);
    }
  }

  function _calculateFloatPerSecondExposed(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) external view returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    return super._calculateFloatPerSecond(marketIndex, longPrice, shortPrice, longValue, shortValue);
  }

  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view override returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_calculateFloatPerSecond""))
    ) {
      return mocker._calculateFloatPerSecondMock(marketIndex, longPrice, shortPrice, longValue, shortValue);
    } else {
      return super._calculateFloatPerSecond(marketIndex, longPrice, shortPrice, longValue, shortValue);
    }
  }

  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotExposed(uint32 marketIndex)
    external
    view
    returns (uint256)
  {
    return super._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);
  }

  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    override
    returns (uint256)
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot""))
    ) {
      return mocker._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshotMock(marketIndex);
    } else {
      return super._calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);
    }
  }

  function _calculateNewCumulativeIssuancePerStakedSynthExposed(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) external view returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    return
      super._calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);
  }

  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view override returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_calculateNewCumulativeIssuancePerStakedSynth""))
    ) {
      return
        mocker._calculateNewCumulativeIssuancePerStakedSynthMock(
          marketIndex,
          longPrice,
          shortPrice,
          longValue,
          shortValue
        );
    } else {
      return
        super._calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);
    }
  }

  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshotExposed(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) external {
    return
      super._setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
  }

  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot""))
    ) {
      return
        mocker._setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshotMock(
          marketIndex,
          longPrice,
          shortPrice,
          longValue,
          shortValue
        );
    } else {
      return
        super._setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
          marketIndex,
          longPrice,
          shortPrice,
          longValue,
          shortValue
        );
    }
  }

  function _calculateAccumulatedFloatInRangeExposed(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) external view returns (uint256 floatReward) {
    return
      super._calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        rewardIndexFrom,
        rewardIndexTo
      );
  }

  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view override returns (uint256 floatReward) {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_calculateAccumulatedFloatInRange""))
    ) {
      return
        mocker._calculateAccumulatedFloatInRangeMock(
          marketIndex,
          amountStakedLong,
          amountStakedShort,
          rewardIndexFrom,
          rewardIndexTo
        );
    } else {
      return
        super._calculateAccumulatedFloatInRange(
          marketIndex,
          amountStakedLong,
          amountStakedShort,
          rewardIndexFrom,
          rewardIndexTo
        );
    }
  }

  function _calculateAccumulatedFloatExposed(uint32 marketIndex, address user) external returns (uint256 floatReward) {
    return super._calculateAccumulatedFloat(marketIndex, user);
  }

  function _calculateAccumulatedFloat(uint32 marketIndex, address user)
    internal
    override
    returns (uint256 floatReward)
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_calculateAccumulatedFloat""))
    ) {
      return mocker._calculateAccumulatedFloatMock(marketIndex, user);
    } else {
      return super._calculateAccumulatedFloat(marketIndex, user);
    }
  }

  function _mintFloatExposed(address user, uint256 floatToMint) external {
    return super._mintFloat(user, floatToMint);
  }

  function _mintFloat(address user, uint256 floatToMint) internal override {
    if (shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_mintFloat""))) {
      return mocker._mintFloatMock(user, floatToMint);
    } else {
      return super._mintFloat(user, floatToMint);
    }
  }

  function _mintAccumulatedFloatExposed(uint32 marketIndex, address user) external {
    return super._mintAccumulatedFloat(marketIndex, user);
  }

  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_mintAccumulatedFloat""))
    ) {
      return mocker._mintAccumulatedFloatMock(marketIndex, user);
    } else {
      return super._mintAccumulatedFloat(marketIndex, user);
    }
  }

  function _mintAccumulatedFloatMultiExposed(uint32[] calldata marketIndexes, address user) external {
    return super._mintAccumulatedFloatMulti(marketIndexes, user);
  }

  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_mintAccumulatedFloatMulti""))
    ) {
      return mocker._mintAccumulatedFloatMultiMock(marketIndexes, user);
    } else {
      return super._mintAccumulatedFloatMulti(marketIndexes, user);
    }
  }

  function stakeFromUser(address from, uint256 amount) public override onlyValidSynthetic((msg.sender)) {
    if (
      shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""stakeFromUser""))
    ) {
      return mocker.stakeFromUserMock(from, amount);
    } else {
      return super.stakeFromUser(from, amount);
    }
  }

  function _stakeExposed(
    address token,
    uint256 amount,
    address user
  ) external {
    return super._stake(token, amount, user);
  }

  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal override {
    if (shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_stake""))) {
      return mocker._stakeMock(token, amount, user);
    } else {
      return super._stake(token, amount, user);
    }
  }

  function _withdrawExposed(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) external {
    return super._withdraw(marketIndex, token, amount);
  }

  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal override {
    if (shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_withdraw""))) {
      return mocker._withdrawMock(marketIndex, token, amount);
    } else {
      return super._withdraw(marketIndex, token, amount);
    }
  }
}",4081
RealWorld_TA_22_OracleManagerEthKiller_RealWorld_20240803003609.log,22,OracleManagerEthKiller,82101,3644,85745,125.0,0.483385,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";

import ""../interfaces/IBandOracle.sol"";
import ""../interfaces/IOracleManager.sol"";

contract OracleManagerEthKiller is IOracleManager {
  address public admin; // This will likely be the Gnosis safe

  // Oracle price, changes by average of the underlying asset changes.
  uint256 public indexPrice;

  // Underlying asset prices.
  uint256 public tronPrice;
  uint256 public eosPrice;
  uint256 public xrpPrice;

  // Band oracle address.
  IBandOracle public oracle;

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin);
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(address _admin, address _bandOracle) {
    admin = _admin;
    oracle = IBandOracle(_bandOracle);

    // Initial asset prices.
    (tronPrice, eosPrice, xrpPrice) = _getAssetPrices();

    // Initial base index price.
    indexPrice = 1e18;
  }

  ////////////////////////////////////
  /// MULTISIG ADMIN FUNCTIONS ///////
  ////////////////////////////////////

  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////

  function _getAssetPrices()
    internal
    view
    returns (
      uint256,
      uint256,
      uint256
    )
  {
    string[] memory baseSymbols = new string[](3);
    baseSymbols[0] = ""TRX""; // tron
    baseSymbols[1] = ""EOS""; // eos
    baseSymbols[2] = ""XRP""; // ripple

    string[] memory quoteSymbols = new string[](3);
    quoteSymbols[0] = ""BUSD"";
    quoteSymbols[1] = ""BUSD"";
    quoteSymbols[2] = ""BUSD"";

    IBandOracle.ReferenceData[] memory data = oracle.getReferenceDataBulk(baseSymbols, quoteSymbols);

    return (data[0].rate, data[1].rate, data[2].rate);
  }

  function updatePrice() external override returns (int256) {
    (uint256 newTronPrice, uint256 newEosPrice, uint256 newXrpPrice) = _getAssetPrices();

    int256 valueOfChangeInIndex = (int256(indexPrice) *
      (_calcAbsolutePercentageChange(newTronPrice, tronPrice) +
        _calcAbsolutePercentageChange(newEosPrice, eosPrice) +
        _calcAbsolutePercentageChange(newXrpPrice, xrpPrice))) / (3 * 1e18);

    tronPrice = newTronPrice;
    eosPrice = newEosPrice;
    xrpPrice = newXrpPrice;

    indexPrice = uint256(int256(indexPrice) + valueOfChangeInIndex);

    return int256(indexPrice);
  }

  function _calcAbsolutePercentageChange(uint256 newPrice, uint256 basePrice) internal pure returns (int256) {
    return ((int256(newPrice) - int256(basePrice)) * (1e18)) / (int256(basePrice));
  }

  function getLatestPrice() external view override returns (int256) {
    return int256(indexPrice);
  }
}",735
RealWorld_TA_22_IBandOracle_RealWorld_20240803010950.log,22,IBandOracle,42669,1946,44615,101.0,0.252265,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;
pragma abicoder v2;

/* Standard Band oracle interface. Prices are queried by pair, i.e. what is
 * the price of the given base currency in units of the quote currency?
 *    see:
 *  https://kovan.etherscan.io/address/0xDA7a001b254CD22e46d3eAB04d937489c93174C3#code
 *  https://docs.matic.network/docs/develop/oracles/bandstandarddataset/
 */
interface IBandOracle {
  struct ReferenceData {
    uint256 rate; // exchange rate for base/quote in 1e18 scale
    uint256 lastUpdatedBase; // secs after epoch, last time base updated
    uint256 lastUpdatedQuote; // secs after epoch, last time quote updated
  }

  /*
   *Returns price data for given base/quote pair. Reverts if not available.
   */
  function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);

  /*
   * Batch version of getReferenceData(...).
   */
  function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes)
    external
    view
    returns (ReferenceData[] memory);
}",280
RealWorld_TA_22_MockERC20_RealWorld_20240803001837.log,22,MockERC20,55474,3649,59123,122.0,0.35035,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

contract MockERC20 {
  address public steward;

  mapping(address => uint256) public _balances;
  mapping(address => mapping(address => uint256)) public _allowance;
  string name;
  string symbol;
  uint8 decimals;
  address minter;

  constructor(
    string memory _name,
    string memory _symbol,
    uint8 _decimals,
    address _minter
  ) {
    name = _name;
    symbol = _symbol;
    decimals = _decimals;
    minter = _minter;
  }

  function mint(address user, uint256 amount) public returns (bool) {
    _balances[user] = _balances[user] + amount;
    return true;
  }

  function burnFrom(address user, uint256 amount) public {
    _balances[user] = _balances[user] - amount;
  }

  function approve(address user, uint256 amount) external returns (bool) {
    _allowance[msg.sender][user] = amount;
    return true;
  }

  function transfer(address to, uint256 amount) external returns (bool) {
    _balances[msg.sender] = _balances[msg.sender] - amount;
    _balances[to] = _balances[to] + amount;
    return true;
  }

  function allowance(address owner, address spender) external view returns (uint256) {
    return _allowance[owner][spender];
  }

  function transferFrom(
    address sender,
    address to,
    uint256 amount
  ) external returns (bool) {
    _balances[sender] = _balances[sender] - amount;
    _balances[to] = _balances[to] + amount;
    _allowance[sender][to] = _allowance[sender][to] - amount;
    return true;
  }

  function balanceOf(address user) external view returns (uint256) {
    return _balances[user];
  }
}",416
RealWorld_TA_22_LongShortForInternalMocking_RealWorld_20240803005622.log,22,LongShortForInternalMocking,105442,2679,108121,107.0,0.58079,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.3;

import ""./LongShortMockable.sol"";

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/ITokenFactory.sol"";
import ""../../interfaces/ISyntheticToken.sol"";
import ""../../interfaces/IStaker.sol"";
import ""../../interfaces/ILongShort.sol"";
import ""../../interfaces/IYieldManager.sol"";
import ""../../interfaces/IOracleManager.sol"";

contract LongShortForInternalMocking {
  function adminOnlyModifierLogicMock() public pure {
    return ();
  }

  function requireMarketExistsModifierLogicMock(uint32) public pure {
    return ();
  }

  function initializeMock(
    address,
    address,
    address,
    address
  ) public pure {
    return ();
  }

  function _seedMarketInitiallyMock(uint256, uint32) public pure {
    return ();
  }

  function _getMinMock(uint256, uint256) public pure returns (uint256) {
    return (abi.decode("""", (uint256)));
  }

  function _getSyntheticTokenPriceMock(uint256, uint256) public pure returns (uint256 syntheticTokenPrice) {
    return (abi.decode("""", (uint256)));
  }

  function _getAmountPaymentTokenMock(uint256, uint256) public pure returns (uint256 amountPaymentToken) {
    return (abi.decode("""", (uint256)));
  }

  function _getAmountSyntheticTokenMock(uint256, uint256) public pure returns (uint256 amountSyntheticToken) {
    return (abi.decode("""", (uint256)));
  }

  function _getEquivalentAmountSyntheticTokensOnTargetSideMock(
    uint256,
    uint256,
    uint256
  ) public pure returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    return (abi.decode("""", (uint256)));
  }

  function getAmountSyntheticTokenToMintOnTargetSideMock(
    uint32,
    uint256,
    bool,
    uint256
  ) public pure returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    return (abi.decode("""", (uint256)));
  }

  function getUsersConfirmedButNotSettledSynthBalanceMock(
    address,
    uint32,
    bool
  ) public pure returns (uint256 confirmedButNotSettledBalance) {
    return (abi.decode("""", (uint256)));
  }

  function _getYieldSplitMock(
    uint32,
    uint256,
    uint256,
    uint256
  ) public pure returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    return (abi.decode("""", (bool)), abi.decode("""", (uint256)));
  }

  function _claimAndDistributeYieldThenRebalanceMarketMock(
    uint32,
    int256,
    int256
  ) public pure returns (uint256 longValue, uint256 shortValue) {
    return (abi.decode("""", (uint256)), abi.decode("""", (uint256)));
  }

  function _updateSystemStateInternalMock(uint32) public pure {
    return ();
  }

  function _transferPaymentTokensFromUserToYieldManagerMock(uint32, uint256) public pure {
    return ();
  }

  function _mintNextPriceMock(
    uint32,
    uint256,
    bool
  ) public pure {
    return ();
  }

  function _redeemNextPriceMock(
    uint32,
    uint256,
    bool
  ) public pure {
    return ();
  }

  function _shiftPositionNextPriceMock(
    uint32,
    uint256,
    bool
  ) public pure {
    return ();
  }

  function _executeOutstandingNextPriceMintsMock(
    uint32,
    address,
    bool
  ) public pure {
    return ();
  }

  function _executeOutstandingNextPriceRedeemsMock(
    uint32,
    address,
    bool
  ) public pure {
    return ();
  }

  function _executeOutstandingNextPriceTokenShiftsMock(
    uint32,
    address,
    bool
  ) public pure {
    return ();
  }

  function _executeOutstandingNextPriceSettlementsMock(address, uint32) public pure {
    return ();
  }

  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManagerMock(uint32, int256) public pure {
    return ();
  }

  function _handleChangeInSyntheticTokensTotalSupplyMock(
    uint32,
    bool,
    int256
  ) public pure {
    return ();
  }

  function _batchConfirmOutstandingPendingActionsMock(
    uint32,
    uint256,
    uint256
  )
    public
    pure
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    return (abi.decode("""", (int256)), abi.decode("""", (int256)));
  }
}",1052
RealWorld_TA_22_FloatToken_RealWorld_20240803000935.log,22,FloatToken,70148,2215,72363,106.0,0.39504,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";

/**
 @title FloatToken
 @notice The Float Token is the governance token for the Float Capital protocol
 */
contract FloatToken is IFloatToken, ERC20PresetMinterPauserUpgradeable {
  /**
   @notice Initialize the Float Token with relevant
   @dev This function is called `initializeFloatToken` to differentiate it from `initialize(string,string)` in the parent contract which should NOT be called to initialize this contract. 
   @param name The name of the Float governance token
   @param symbol The ticker representing the token
   @param stakerAddress The staker contract that controls minting of the token
   */
  function initializeFloatToken(
    string calldata name,
    string calldata symbol,
    address stakerAddress
  ) external initializer {
    initialize(name, symbol);

    _setupRole(DEFAULT_ADMIN_ROLE, stakerAddress);
    _setupRole(MINTER_ROLE, stakerAddress);
    _setupRole(PAUSER_ROLE, stakerAddress);

    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);
    renounceRole(MINTER_ROLE, msg.sender);
    renounceRole(PAUSER_ROLE, msg.sender);
  }

  /*╔═══════════════════════════════════════════════════════════════════╗
    ║    FUNCTIONS INHERITED BY ERC20PresetMinterPauserUpgradeable      ║
    ╚═══════════════════════════════════════════════════════════════════╝*/

  /** 
  @notice Mints an amount of Float tokens for an address.
  @dev Can only be called by addresses with a MINTER_ROLE. 
        This should correspond to the Staker contract.
  @param to The address for which to mint the tokens for.
  @param amount Amount of synthetic tokens to mint in wei.
  */
  function mint(address to, uint256 amount) public override(IFloatToken, ERC20PresetMinterPauserUpgradeable) {
    ERC20PresetMinterPauserUpgradeable.mint(to, amount);
  }

  /**
   @notice modify token functionality so that a pausing this token doesn't affect minting
   @dev Pause functionality in the open zeppelin ERC20PresetMinterPauserUpgradeable comes from the below function.
    We override it to exclude anyone with the minter role (ie the Staker contract)
   @param from address tokens are being sent from
   @param to address tokens are being sent to
   @param amount amount of tokens being sent
   */
  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 amount
  ) internal virtual override {
    if (!hasRole(MINTER_ROLE, _msgSender())) {
      super._beforeTokenTransfer(from, to, amount);
    }
  }
}",677
RealWorld_TA_22_OracleManagerChainlink_RealWorld_20240803003426.log,22,OracleManagerChainlink,47884,2103,49987,101.0,0.28148,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""../interfaces/IOracleManager.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

/*
 * Implementation of an OracleManager that fetches prices from a Chainlink aggregate price feed.
 */
contract OracleManagerChainlink is IOracleManager {
  // Admin addresses.
  address public admin;

  // Global state.
  AggregatorV3Interface public chainlinkOracle;
  uint8 public oracleDecimals;

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin, ""Not admin"");
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////
  constructor(address _admin, address _chainLinkOracle) {
    admin = _admin;
    chainlinkOracle = AggregatorV3Interface(_chainLinkOracle);
    oracleDecimals = chainlinkOracle.decimals();
  }

  ////////////////////////////////////
  /// MULTISIG ADMIN FUNCTIONS ///////
  ////////////////////////////////////

  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////
  function _getLatestPrice() internal view returns (int256) {
    (, int256 price, , , ) = chainlinkOracle.latestRoundData();
    return price;
  }

  function getLatestPrice() external view override returns (int256) {
    return _getLatestPrice();
  }

  function updatePrice() external override returns (int256) {
    return _getLatestPrice();
  }
}",346
RealWorld_TA_22_ITokenFactory_RealWorld_20240803010818.log,22,ITokenFactory,23340,1567,24907,90.0,0.14804,"pragma solidity 0.8.3;

abstract contract ITokenFactory {
  function createSyntheticToken(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address staker,
    uint32 marketIndex,
    bool isLong
  ) external virtual returns (address);
}",61
RealWorld_TA_22_LongShortMockable_RealWorld_20240803005117.log,22,LongShortMockable,346814,5345,352159,177.0,1.84097,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../../interfaces/ITokenFactory.sol"";
import ""../../interfaces/ISyntheticToken.sol"";
import ""../../interfaces/IStaker.sol"";
import ""../../interfaces/ILongShort.sol"";
import ""../../interfaces/IYieldManager.sol"";
import ""../../interfaces/IOracleManager.sol"";

import ""./LongShortForInternalMocking.sol"";
import ""../LongShortInternalStateSetters.sol"";

contract LongShortMockable is LongShortInternalStateSetters {
  LongShortForInternalMocking mocker;
  bool shouldUseMock;
  string functionToNotMock;

  function setMocker(LongShortForInternalMocking _mocker) external {
    mocker = _mocker;
    shouldUseMock = true;
  }

  function setFunctionToNotMock(string calldata _functionToNotMock) external {
    functionToNotMock = _functionToNotMock;
  }

  function adminOnlyModifierLogicExposed() external {
    return super.adminOnlyModifierLogic();
  }

  function adminOnlyModifierLogic() internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""adminOnlyModifierLogic""))
    ) {
      return mocker.adminOnlyModifierLogicMock();
    } else {
      return super.adminOnlyModifierLogic();
    }
  }

  function requireMarketExistsModifierLogicExposed(uint32 marketIndex) external view {
    return super.requireMarketExistsModifierLogic(marketIndex);
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""requireMarketExistsModifierLogic""))
    ) {
      return mocker.requireMarketExistsModifierLogicMock(marketIndex);
    } else {
      return super.requireMarketExistsModifierLogic(marketIndex);
    }
  }

  function _seedMarketInitiallyExposed(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) external {
    return super._seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_seedMarketInitially""))
    ) {
      return mocker._seedMarketInitiallyMock(initialMarketSeedForEachMarketSide, marketIndex);
    } else {
      return super._seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
    }
  }

  function _getMinExposed(uint256 a, uint256 b) external pure returns (uint256) {
    return super._getMin(a, b);
  }

  function _getSyntheticTokenPriceExposed(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    external
    pure
    returns (uint256 syntheticTokenPrice)
  {
    return super._getSyntheticTokenPrice(amountPaymentTokenBackingSynth, amountSyntheticToken);
  }

  function _getAmountPaymentTokenExposed(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    external
    pure
    returns (uint256 amountPaymentToken)
  {
    return super._getAmountPaymentToken(amountSyntheticToken, syntheticTokenPriceInPaymentTokens);
  }

  function _getAmountSyntheticTokenExposed(
    uint256 amountPaymentTokenBackingSynth,
    uint256 syntheticTokenPriceInPaymentTokens
  ) external pure returns (uint256 amountSyntheticToken) {
    return super._getAmountSyntheticToken(amountPaymentTokenBackingSynth, syntheticTokenPriceInPaymentTokens);
  }

  function _getEquivalentAmountSyntheticTokensOnTargetSideExposed(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) external pure returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    return
      super._getEquivalentAmountSyntheticTokensOnTargetSide(
        amountSyntheticTokens_originSide,
        syntheticTokenPrice_originSide,
        syntheticTokenPrice_targetSide
      );
  }

  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""getAmountSyntheticTokenToMintOnTargetSide""))
    ) {
      return
        mocker.getAmountSyntheticTokenToMintOnTargetSideMock(
          marketIndex,
          amountSyntheticToken_redeemOnOriginSide,
          isShiftFromLong,
          priceSnapshotIndex
        );
    } else {
      return
        super.getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          amountSyntheticToken_redeemOnOriginSide,
          isShiftFromLong,
          priceSnapshotIndex
        );
    }
  }

  function _getYieldSplitExposed(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) external view returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    return super._getYieldSplit(marketIndex, longValue, shortValue, totalValueLockedInMarket);
  }

  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view override returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    if (
      shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_getYieldSplit""))
    ) {
      return mocker._getYieldSplitMock(marketIndex, longValue, shortValue, totalValueLockedInMarket);
    } else {
      return super._getYieldSplit(marketIndex, longValue, shortValue, totalValueLockedInMarket);
    }
  }

  function _claimAndDistributeYieldThenRebalanceMarketExposed(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) external returns (uint256 longValue, uint256 shortValue) {
    return super._claimAndDistributeYieldThenRebalanceMarket(marketIndex, newAssetPrice, oldAssetPrice);
  }

  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal override returns (uint256 longValue, uint256 shortValue) {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_claimAndDistributeYieldThenRebalanceMarket""))
    ) {
      return mocker._claimAndDistributeYieldThenRebalanceMarketMock(marketIndex, newAssetPrice, oldAssetPrice);
    } else {
      return super._claimAndDistributeYieldThenRebalanceMarket(marketIndex, newAssetPrice, oldAssetPrice);
    }
  }

  function _updateSystemStateInternalExposed(uint32 marketIndex) external {
    return super._updateSystemStateInternal(marketIndex);
  }

  function _updateSystemStateInternal(uint32 marketIndex) internal override requireMarketExists(marketIndex) {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_updateSystemStateInternal""))
    ) {
      return mocker._updateSystemStateInternalMock(marketIndex);
    } else {
      return super._updateSystemStateInternal(marketIndex);
    }
  }

  function _transferPaymentTokensFromUserToYieldManagerExposed(uint32 marketIndex, uint256 amount) external {
    return super._transferPaymentTokensFromUserToYieldManager(marketIndex, amount);
  }

  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_transferPaymentTokensFromUserToYieldManager""))
    ) {
      return mocker._transferPaymentTokensFromUserToYieldManagerMock(marketIndex, amount);
    } else {
      return super._transferPaymentTokensFromUserToYieldManager(marketIndex, amount);
    }
  }

  function _mintNextPriceExposed(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  ) external {
    return super._mintNextPrice(marketIndex, amount, isLong);
  }

  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    override
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    if (
      shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_mintNextPrice""))
    ) {
      return mocker._mintNextPriceMock(marketIndex, amount, isLong);
    } else {
      return super._mintNextPrice(marketIndex, amount, isLong);
    }
  }

  function _redeemNextPriceExposed(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  ) external {
    return super._redeemNextPrice(marketIndex, tokens_redeem, isLong);
  }

  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    override
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    if (
      shouldUseMock && keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_redeemNextPrice""))
    ) {
      return mocker._redeemNextPriceMock(marketIndex, tokens_redeem, isLong);
    } else {
      return super._redeemNextPrice(marketIndex, tokens_redeem, isLong);
    }
  }

  function _shiftPositionNextPriceExposed(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  ) external {
    return super._shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, isShiftFromLong);
  }

  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    override
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_shiftPositionNextPrice""))
    ) {
      return mocker._shiftPositionNextPriceMock(marketIndex, amountSyntheticTokensToShift, isShiftFromLong);
    } else {
      return super._shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, isShiftFromLong);
    }
  }

  function _executeOutstandingNextPriceMintsExposed(
    uint32 marketIndex,
    address user,
    bool isLong
  ) external {
    return super._executeOutstandingNextPriceMints(marketIndex, user, isLong);
  }

  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) != keccak256(abi.encodePacked(""_executeOutstandingNextPriceMints""))
    ) {
      return mocker._executeOutstandingNextPriceMintsMock(marketIndex, user, isLong);
    } else {
      return super._executeOutstandingNextPriceMints(marketIndex, user, isLong);
    }
  }

  function _executeOutstandingNextPriceRedeemsExposed(
    uint32 marketIndex,
    address user,
    bool isLong
  ) external {
    return super._executeOutstandingNextPriceRedeems(marketIndex, user, isLong);
  }

  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_executeOutstandingNextPriceRedeems""))
    ) {
      return mocker._executeOutstandingNextPriceRedeemsMock(marketIndex, user, isLong);
    } else {
      return super._executeOutstandingNextPriceRedeems(marketIndex, user, isLong);
    }
  }

  function _executeOutstandingNextPriceTokenShiftsExposed(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) external {
    return super._executeOutstandingNextPriceTokenShifts(marketIndex, user, isShiftFromLong);
  }

  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_executeOutstandingNextPriceTokenShifts""))
    ) {
      return mocker._executeOutstandingNextPriceTokenShiftsMock(marketIndex, user, isShiftFromLong);
    } else {
      return super._executeOutstandingNextPriceTokenShifts(marketIndex, user, isShiftFromLong);
    }
  }

  function _executeOutstandingNextPriceSettlementsExposed(address user, uint32 marketIndex) external {
    return super._executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_executeOutstandingNextPriceSettlements""))
    ) {
      return mocker._executeOutstandingNextPriceSettlementsMock(user, marketIndex);
    } else {
      return super._executeOutstandingNextPriceSettlements(user, marketIndex);
    }
  }

  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManagerExposed(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) external {
    return
      super._handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
        marketIndex,
        totalPaymentTokenValueChangeForMarket
      );
  }

  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_handleTotalPaymentTokenValueChangeForMarketWithYieldManager""))
    ) {
      return
        mocker._handleTotalPaymentTokenValueChangeForMarketWithYieldManagerMock(
          marketIndex,
          totalPaymentTokenValueChangeForMarket
        );
    } else {
      return
        super._handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
          marketIndex,
          totalPaymentTokenValueChangeForMarket
        );
    }
  }

  function _handleChangeInSyntheticTokensTotalSupplyExposed(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) external {
    return super._handleChangeInSyntheticTokensTotalSupply(marketIndex, isLong, changeInSyntheticTokensTotalSupply);
  }

  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal override {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_handleChangeInSyntheticTokensTotalSupply""))
    ) {
      return
        mocker._handleChangeInSyntheticTokensTotalSupplyMock(marketIndex, isLong, changeInSyntheticTokensTotalSupply);
    } else {
      return super._handleChangeInSyntheticTokensTotalSupply(marketIndex, isLong, changeInSyntheticTokensTotalSupply);
    }
  }

  function _batchConfirmOutstandingPendingActionsExposed(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  ) external returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken) {
    return
      super._batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
  }

  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    override
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    if (
      shouldUseMock &&
      keccak256(abi.encodePacked(functionToNotMock)) !=
      keccak256(abi.encodePacked(""_batchConfirmOutstandingPendingActions""))
    ) {
      return
        mocker._batchConfirmOutstandingPendingActionsMock(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        );
    } else {
      return
        super._batchConfirmOutstandingPendingActions(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        );
    }
  }
}",3965
RealWorld_TA_22_IAaveIncentivesController_RealWorld_20240803011440.log,22,IAaveIncentivesController,26280,1734,28014,90.0,0.16608,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.8.3;

interface IAaveIncentivesController {
  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);

  function claimRewards(
    address[] calldata assets,
    uint256 amount,
    address to
  ) external returns (uint256);

  function getUserUnclaimedRewards(address user) external view returns (uint256);
}",94
RealWorld_TA_22_Migrations_RealWorld_20240802235605.log,22,Migrations,28761,1977,30738,99.0,0.183345,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.6.0;

contract Migrations {
  address public owner;
  uint256 public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  constructor() public {
    owner = msg.sender;
  }

  function setCompleted(uint256 completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}",119
RealWorld_TA_22_DataTypes_RealWorld_20240803012009.log,22,DataTypes,51319,1359,52678,86.0,0.283775,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.3;

library DataTypes {
  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
  struct ReserveData {
    //stores the reserve configuration
    ReserveConfigurationMap configuration;
    //the liquidity index. Expressed in ray
    uint128 liquidityIndex;
    //variable borrow index. Expressed in ray
    uint128 variableBorrowIndex;
    //the current supply rate. Expressed in ray
    uint128 currentLiquidityRate;
    //the current variable borrow rate. Expressed in ray
    uint128 currentVariableBorrowRate;
    //the current stable borrow rate. Expressed in ray
    uint128 currentStableBorrowRate;
    uint40 lastUpdateTimestamp;
    //tokens addresses
    address aTokenAddress;
    address stableDebtTokenAddress;
    address variableDebtTokenAddress;
    //address of the interest rate strategy
    address interestRateStrategyAddress;
    //the id of the reserve. Represents the position in the list of the active reserves
    uint8 id;
  }

  struct ReserveConfigurationMap {
    //bit 0-15: LTV
    //bit 16-31: Liq. threshold
    //bit 32-47: Liq. bonus
    //bit 48-55: Decimals
    //bit 56: Reserve is active
    //bit 57: reserve is frozen
    //bit 58: borrowing is enabled
    //bit 59: stable rate borrowing enabled
    //bit 60-63: reserved
    //bit 64-79: reserve factor
    uint256 data;
  }

  struct UserConfigurationMap {
    uint256 data;
  }

  enum InterestRateMode {
    NONE,
    STABLE,
    VARIABLE
  }
}",398
RealWorld_TA_22_OracleManagerMock_RealWorld_20240803002042.log,22,OracleManagerMock,39455,2128,41583,96.0,0.239835,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""../interfaces/IOracleManager.sol"";

/*
 * Mock implementation of an OracleManager with fixed, changeable prices.
 */
contract OracleManagerMock is IOracleManager {
  // Admin contract.
  address public admin;

  // Global state.
  int256 currentPrice; // e18

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin, ""Not admin"");
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(address _admin) {
    admin = _admin;

    // Default to a price of 1.
    currentPrice = 1e18;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////

  function setPrice(int256 newPrice) public adminOnly {
    currentPrice = newPrice;
  }

  function updatePrice() external override returns (int256) {
    return currentPrice;
  }

  function getLatestPrice() external view override returns (int256) {
    return currentPrice;
  }
}",243
RealWorld_TA_22_SyntheticToken_RealWorld_20240803000701.log,22,SyntheticToken,118246,4594,122840,152.0,0.68311,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/ISyntheticToken.sol"";

/**
@title SyntheticToken
@notice An ERC20 token that tracks or inversely tracks the price of an
        underlying asset with floating exposure.
@dev Logic for price tracking contained in LongShort.sol. 
     The contract inherits from ERC20PresetMinterPauser.sol
*/
contract SyntheticToken is ISyntheticToken {
  /// @notice Address of the LongShort contract, a deployed LongShort.sol
  address public longShort;
  /// @notice Address of the Staker contract, a deployed Staker.sol
  address public staker;
  /// @notice Identifies which market in longShort the token is for.
  uint32 public marketIndex;
  /// @notice Whether the token is a long token or short token for its market.
  bool public isLong;

  /// @notice Creates an instance of the contract.
  /// @dev Should only be called by TokenFactory.sol for our system.
  /// @param name The name of the token.
  /// @param symbol The symbol for the token.
  /// @param _longShort Address of the core LongShort contract.
  /// @param _staker Address of the staker contract.
  /// @param _marketIndex Which market the token is for.
  /// @param _isLong Whether the token is long or short for its market.
  constructor(
    string memory name,
    string memory symbol,
    address _longShort,
    address _staker,
    uint32 _marketIndex,
    bool _isLong
  ) ERC20PresetMinterPauser(name, symbol) {
    longShort = _longShort;
    staker = _staker;
    marketIndex = _marketIndex;
    isLong = _isLong;
  }

  /// @notice Allows users to stake their synthetic tokens to earn Float.
  /// @dev Core staking logic contained in Staker.sol
  /// @param amount Amount to stake in wei.
  function stake(uint256 amount) external override {
    // NOTE: this is safe, this function will throw ""ERC20: transfer
    //       amount exceeds balance"" if amount exceeds users balance.
    super._transfer(msg.sender, address(staker), amount);

    IStaker(staker).stakeFromUser(msg.sender, amount);
  }

  /*╔══════════════════════════════════════════════════════╗
    ║    FUNCTIONS INHERITED BY ERC20PresetMinterPauser    ║
    ╚══════════════════════════════════════════════════════╝*/

  /** 
  @notice Mints a number of synthetic tokens for an address.
  @dev Can only be called by addresses with a minter role. 
        This should correspond to the Long Short contract.
  @param to The address for which to mint the tokens for.
  @param amount Amount of synthetic tokens to mint in wei.
  */
  function mint(address to, uint256 amount) public override {
    ERC20PresetMinterPauser.mint(to, amount);
  }

  /// @notice Burns or destroys a number of held synthetic tokens for an address.
  /// @dev Modified to only allow Long Short to burn tokens on redeem.
  /// @param account The account for which to burn tokens for.
  /// @param amount The amount of tokens to burn in wei.
  function _burn(address account, uint256 amount) internal override {
    require(msg.sender == longShort, ""Only LongShort contract"");
    super._burn(account, amount);
  }

  /** 
  @notice Overrides the default ERC20 transferFrom.
  @dev To allow users to avoid approving LongShort when redeeming tokens,
       longShort has a virtual infinite allowance.
  @param sender User for which to transfer tokens.
  @param recipient Recipient of the transferred tokens.
  @param amount Amount of tokens to transfer in wei.
  */
  function transferFrom(
    address sender,
    address recipient,
    uint256 amount
  ) public override returns (bool) {
    if (recipient == longShort && msg.sender == longShort) {
      super._transfer(sender, recipient, amount);
      return true;
    } else {
      return super.transferFrom(sender, recipient, amount);
    }
  }

  /** 
  @notice Overrides the OpenZeppelin _beforeTokenTransfer hook
  @dev Ensures that this contract's accounting reflects all the senders's outstanding
       tokens from next price actions before any token transfer occurs.
       Removal of pausing functionality of ERC20PresetMinterPausable is intentional.
  @param sender User for which tokens are to be transferred for.
  */
  function _beforeTokenTransfer(
    address sender,
    address,
    uint256
  ) internal override {
    if (sender != longShort) {
      ILongShort(longShort).executeOutstandingNextPriceSettlementsUser(sender, marketIndex);
    }
  }

  /** 
  @notice Gets the synthetic token balance of the user in wei.
  @dev To automatically account for next price actions which have been confirmed but not settled,
        includes any outstanding tokens owed by longShort.
  @param account The address for which to get the balance of.
  */
  function balanceOf(address account) public view virtual override returns (uint256) {
    return
      ERC20.balanceOf(account) +
      ILongShort(longShort).getUsersConfirmedButNotSettledSynthBalance(account, marketIndex, isLong);
  }
}",1212
RealWorld_TA_22_YieldManagerAave_RealWorld_20240803000420.log,22,YieldManagerAave,198247,4104,202351,159.0,1.073315,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/aave/ILendingPool.sol"";
import ""./interfaces/aave/IAaveIncentivesController.sol"";

/** @title YieldManagerAave
  @notice contract is used to manage the yield generated by the underlying tokens. 
  YieldManagerAave is an implementation of a yield manager that earns APY from the Aave protocol. 
  Each fund's payment token (such as DAI) has a corresponding aToken (such as aDAI) that 
  continuously accrues interest based on a lend/borrow liquidity ratio.
  @dev https://docs.aave.com/portal/
  */
contract YieldManagerAave is IYieldManager {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /// @notice address of longShort contract
  address public longShort;
  /// @notice address of treasury contract - this is the address that can claim aave incentives rewards
  address public treasury;

  /// @notice The payment token the yield manager supports
  /// @dev DAI token
  ERC20 public paymentToken;
  /// @notice The token representing the interest accruing payment token position from Aave
  /// @dev ADAI token
  IERC20Upgradeable public aToken;
  /// @notice The specific Aave lending pool contract
  ILendingPool public lendingPool;
  /// @notice The specific Aave incentives controller contract
  IAaveIncentivesController public aaveIncentivesController;

  /// @dev An aave specific referralCode that has been a depricated feature. This will be set to 0 for ""no referral"" at deployment
  uint16 referralCode;

  /// @notice distributed yield not yet transferred to the treasury
  uint256 public override totalReservedForTreasury;

  /// @dev This value will likely remain zero forever. It exists to handle the rare edge case that Aave doesn't have enough liquidity for a withdrawal.
  ///      In this case this variable would keep track of that so that the withdrawal can happen after the fact when liquidity becomes available.
  uint256 public amountReservedInCaseOfInsufficientAaveLiquidity;

  /*╔═════════════════════════════╗
    ║           EVENTS            ║
    ╚═════════════════════════════╝*/

  event ClaimAaveRewardTokenToTreasury(uint256 amount);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  /// @dev only allow longShort contract to execute modified functions
  modifier longShortOnly() {
    require(msg.sender == longShort, ""Not longShort"");
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /** 
    @notice Constructor for initializing the aave yield manager with a given payment token and corresponding Aave contracts
    @param _longShort address of the longShort contract
    @param _treasury address of the treasury contract
    @param _paymentToken address of the payment token
    @param _aToken address of the interest accruing token linked to the payment token
    @param _lendingPool address of the aave lending pool contract
    @param _aaveReferralCode unique code for aave referrals
    @dev referral code will be set to 0, depricated Aave feature
  */
  constructor(
    address _longShort,
    address _treasury,
    address _paymentToken,
    address _aToken,
    address _lendingPool,
    address _aaveIncentivesController,
    uint16 _aaveReferralCode
  ) {
    longShort = _longShort;
    treasury = _treasury;

    referralCode = _aaveReferralCode;

    paymentToken = ERC20(_paymentToken);
    aToken = IERC20Upgradeable(_aToken);
    lendingPool = ILendingPool(_lendingPool);
    aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController);

    // Approve tokens for aave lending pool maximally.
    paymentToken.approve(address(lendingPool), type(uint256).max);
  }

  /*╔════════════════════════╗
    ║     IMPLEMENTATION     ║
    ╚════════════════════════╝*/

  /** 
   @notice Allows the LongShort contract to deposit tokens into the aave pool
   @param amount Amount of payment token to deposit
  */
  function depositPaymentToken(uint256 amount) external override longShortOnly {
    // If amountReservedInCaseOfInsufficientAaveLiquidity isn't zero, then efficiently net the difference between the amount
    //    It basically always be zero besides extreme and unlikely situations with aave.
    if (amountReservedInCaseOfInsufficientAaveLiquidity != 0) {
      if (amountReservedInCaseOfInsufficientAaveLiquidity > amount) {
        amountReservedInCaseOfInsufficientAaveLiquidity -= amount;
        // Return early, nothing to deposit into the lending pool
        return;
      } else {
        amount -= amountReservedInCaseOfInsufficientAaveLiquidity;
        amountReservedInCaseOfInsufficientAaveLiquidity = 0;
      }
    }

    lendingPool.deposit(address(paymentToken), amount, address(this), referralCode);
  }

  /// @notice Allows the LongShort pay out a user from tokens already withdrawn from Aave
  /// @param user User to recieve the payout
  /// @param amount Amount of payment token to pay to user
  function transferPaymentTokensToUser(address user, uint256 amount) external override longShortOnly {
    try paymentToken.transfer(user, amount) returns (bool transferSuccess) {
      if (transferSuccess) {
        // If the transfer is successful return early, otherwise try pay the user out with the amountReservedInCaseOfInsufficientAaveLiquidity
        return;
      }
    } catch {}

    amountReservedInCaseOfInsufficientAaveLiquidity -= amount;

    // If this reverts (ie aave unable to make payout), then the whole transaction will revent. User will have to wait until sufficient liquidity available.
    lendingPool.withdraw(address(paymentToken), amount, user);
  }

  /// @notice Allows the LongShort contract to redeem aTokens for the payment token
  /// @param amount Amount of payment token to withdraw
  /// @dev This will update the amountReservedInCaseOfInsufficientAaveLiquidity if not enough liquidity is avaiable on aave.
  ///      This means that our system can continue to operate even if there is insufficient liquidity in Aave for any reason.
  function removePaymentTokenFromMarket(uint256 amount) external override longShortOnly {
    try lendingPool.withdraw(address(paymentToken), amount, address(this)) {} catch {
      // In theory we should only catch `VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH` errors.
      // Safe to revert on all errors, if aave completely blocks withdrawals the amountReservedInCaseOfInsufficientAaveLiquidity can grow until it is fixed without problems.
      amountReservedInCaseOfInsufficientAaveLiquidity += amount;
    }
  }

  /**  
    @notice Allows for withdrawal of aave rewards to the treasury contract    
    @dev This is specifically implemented to allow withdrawal of aave reward wMatic tokens accrued    
  */
  function claimAaveRewardsToTreasury() external {
    uint256 amount = IAaveIncentivesController(aaveIncentivesController).getUserUnclaimedRewards(address(this));

    address[] memory rewardsDepositedAssets = new address[](1);
    rewardsDepositedAssets[0] = address(paymentToken);

    IAaveIncentivesController(aaveIncentivesController).claimRewards(rewardsDepositedAssets, amount, treasury);

    emit ClaimAaveRewardTokenToTreasury(amount);
  }

  /**    
    @notice Calculates and updates the yield allocation to the treasury and the market
    @dev treasuryPercent = 1 - marketPercent
    @param totalValueRealizedForMarket total value of long and short side of the market
    @param treasuryYieldPercent_e18 Percentage of yield in base 1e18 that is allocated to the treasury
    @return The market allocation of the yield
  */
  function distributeYieldForTreasuryAndReturnMarketAllocation(
    uint256 totalValueRealizedForMarket,
    uint256 treasuryYieldPercent_e18
  ) external override longShortOnly returns (uint256) {
    uint256 totalHeld = aToken.balanceOf(address(this));

    uint256 totalRealized = totalValueRealizedForMarket +
      totalReservedForTreasury +
      amountReservedInCaseOfInsufficientAaveLiquidity;

    if (totalRealized == totalHeld) {
      return 0;
    }

    // will revert in case totalRealized > totalHeld which should be never.
    uint256 unrealizedYield = totalHeld - totalRealized;

    uint256 amountForTreasury = (unrealizedYield * treasuryYieldPercent_e18) / 1e18;
    uint256 amountForMarketIncentives = unrealizedYield - amountForTreasury;

    totalReservedForTreasury += amountForTreasury;

    emit YieldDistributed(unrealizedYield, treasuryYieldPercent_e18);

    return amountForMarketIncentives;
  }

  /// @notice Withdraw treasury allocated accrued yield from the lending pool to the treasury contract
  function withdrawTreasuryFunds() external override {
    uint256 amountToWithdrawForTreasury = totalReservedForTreasury;
    totalReservedForTreasury = 0;

    // Redeem aToken for payment tokens.
    lendingPool.withdraw(address(paymentToken), amountToWithdrawForTreasury, treasury);

    emit WithdrawTreasuryFunds();
  }
}",2292
RealWorld_TA_22_OracleManagerEthVsBtc_RealWorld_20240803003816.log,22,OracleManagerEthVsBtc,55326,2881,58207,116.0,0.33425,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

import ""../interfaces/IOracleManager.sol"";

/**
  Contract that gives price ration of ETH/BTC
*/
contract OracleManagerEthVsBtc is IOracleManager {
  address public admin; // This will likely be the Gnosis safe

  int256 public ethDominance;

  // Oracle addresses
  AggregatorV3Interface public btcOracle;
  AggregatorV3Interface public ethOracle;

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin);
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(
    address _admin,
    address _btcOracle,
    address _ethOracle
  ) {
    admin = _admin;

    btcOracle = AggregatorV3Interface(_btcOracle);
    ethOracle = AggregatorV3Interface(_ethOracle);

    _updatePrice();
  }

  ////////////////////////////////////
  /// MULTISIG ADMIN FUNCTIONS ///////
  ////////////////////////////////////

  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////

  function _updatePrice() private returns (int256) {
    (, int256 _ethPrice, , , ) = ethOracle.latestRoundData();
    (, int256 _btcPrice, , , ) = btcOracle.latestRoundData();

    // 1e20 as 18 decimals but as %
    ethDominance = int256((uint256(_ethPrice) * 1e20) / (uint256(_btcPrice)));

    return ethDominance;
  }

  function updatePrice() external override returns (int256) {
    return _updatePrice();
  }

  function getLatestPrice() external view override returns (int256) {
    return ethDominance;
  }
}",425
RealWorld_TA_22_ILendingPool_RealWorld_20240803011612.log,22,ILendingPool,350148,2248,352396,134.0,1.7957,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity ^0.8.3;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
  /**
   * @dev Emitted on deposit()
   * @param reserve The address of the underlying asset of the reserve
   * @param user The address initiating the deposit
   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
   * @param amount The amount deposited
   * @param referral The referral code used
   **/
  event Deposit(
    address indexed reserve,
    address user,
    address indexed onBehalfOf,
    uint256 amount,
    uint16 indexed referral
  );

  /**
   * @dev Emitted on withdraw()
   * @param reserve The address of the underlyng asset being withdrawn
   * @param user The address initiating the withdrawal, owner of aTokens
   * @param to Address that will receive the underlying
   * @param amount The amount to be withdrawn
   **/
  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

  /**
   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
   * @param reserve The address of the underlying asset being borrowed
   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
   * initiator of the transaction on flashLoan()
   * @param onBehalfOf The address that will be getting the debt
   * @param amount The amount borrowed out
   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
   * @param borrowRate The numeric rate at which the user has borrowed
   * @param referral The referral code used
   **/
  event Borrow(
    address indexed reserve,
    address user,
    address indexed onBehalfOf,
    uint256 amount,
    uint256 borrowRateMode,
    uint256 borrowRate,
    uint16 indexed referral
  );

  /**
   * @dev Emitted on repay()
   * @param reserve The address of the underlying asset of the reserve
   * @param user The beneficiary of the repayment, getting his debt reduced
   * @param repayer The address of the user initiating the repay(), providing the funds
   * @param amount The amount repaid
   **/
  event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

  /**
   * @dev Emitted on swapBorrowRateMode()
   * @param reserve The address of the underlying asset of the reserve
   * @param user The address of the user swapping his rate mode
   * @param rateMode The rate mode that the user wants to swap to
   **/
  event Swap(address indexed reserve, address indexed user, uint256 rateMode);

  /**
   * @dev Emitted on setUserUseReserveAsCollateral()
   * @param reserve The address of the underlying asset of the reserve
   * @param user The address of the user enabling the usage as collateral
   **/
  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

  /**
   * @dev Emitted on setUserUseReserveAsCollateral()
   * @param reserve The address of the underlying asset of the reserve
   * @param user The address of the user enabling the usage as collateral
   **/
  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

  /**
   * @dev Emitted on rebalanceStableBorrowRate()
   * @param reserve The address of the underlying asset of the reserve
   * @param user The address of the user for which the rebalance has been executed
   **/
  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

  /**
   * @dev Emitted on flashLoan()
   * @param target The address of the flash loan receiver contract
   * @param initiator The address initiating the flash loan
   * @param asset The address of the asset being flash borrowed
   * @param amount The amount flash borrowed
   * @param premium The fee flash borrowed
   * @param referralCode The referral code used
   **/
  event FlashLoan(
    address indexed target,
    address indexed initiator,
    address indexed asset,
    uint256 amount,
    uint256 premium,
    uint16 referralCode
  );

  /**
   * @dev Emitted when the pause is triggered.
   */
  event Paused();

  /**
   * @dev Emitted when the pause is lifted.
   */
  event Unpaused();

  /**
   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
   * LendingPoolCollateral manager using a DELEGATECALL
   * This allows to have the events in the generated ABI for LendingPool.
   * @param collateralAsset The address of the underlying asset used as collateral,
   *                        to receive as result of the liquidation.
   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
   * @param user The address of the borrower getting liquidated
   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
   * @param liquidator The address of the liquidator
   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
   * to receive the underlying collateral asset directly
   **/
  event LiquidationCall(
    address indexed collateralAsset,
    address indexed debtAsset,
    address indexed user,
    uint256 debtToCover,
    uint256 liquidatedCollateralAmount,
    address liquidator,
    bool receiveAToken
  );

  /**
   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
   * gets added to the LendingPool ABI
   * @param reserve The address of the underlying asset of the reserve
   * @param liquidityRate The new liquidity rate
   * @param stableBorrowRate The new stable borrow rate
   * @param variableBorrowRate The new variable borrow rate
   * @param liquidityIndex The new liquidity index
   * @param variableBorrowIndex The new variable borrow index
   **/
  event ReserveDataUpdated(
    address indexed reserve,
    uint256 liquidityRate,
    uint256 stableBorrowRate,
    uint256 variableBorrowRate,
    uint256 liquidityIndex,
    uint256 variableBorrowIndex
  );

  /**
   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
   * @param asset The address of the underlying asset to deposit
   * @param amount The amount to be deposited
   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
   *   is a different wallet
   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
   *   0 if the action is executed directly by the user, without any middle-man
   **/
  function deposit(
    address asset,
    uint256 amount,
    address onBehalfOf,
    uint16 referralCode
  ) external;

  /**
   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
   * @param asset The address of the underlying asset to withdraw
   * @param amount The underlying amount to be withdrawn
   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
   * @param to Address that will receive the underlying, same as msg.sender if the user
   *   wants to receive it on his own wallet, or a different address if the beneficiary is a
   *   different wallet
   * @return The final amount withdrawn
   **/
  function withdraw(
    address asset,
    uint256 amount,
    address to
  ) external returns (uint256);

  /**
   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
   * corresponding debt token (StableDebtToken or VariableDebtToken)
   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
   * @param asset The address of the underlying asset to borrow
   * @param amount The amount to be borrowed
   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
   *   0 if the action is executed directly by the user, without any middle-man
   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
   * if he has been given credit delegation allowance
   **/
  function borrow(
    address asset,
    uint256 amount,
    uint256 interestRateMode,
    uint16 referralCode,
    address onBehalfOf
  ) external;

  /**
   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
   * @param asset The address of the borrowed underlying asset previously borrowed
   * @param amount The amount to repay
   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
   * user calling the function if he wants to reduce/remove his own debt, or the address of any other
   * other borrower whose debt should be removed
   * @return The final amount repaid
   **/
  function repay(
    address asset,
    uint256 amount,
    uint256 rateMode,
    address onBehalfOf
  ) external returns (uint256);

  /**
   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
   * @param asset The address of the underlying asset borrowed
   * @param rateMode The rate mode that the user wants to swap to
   **/
  function swapBorrowRateMode(address asset, uint256 rateMode) external;

  /**
   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
   * - Users can be rebalanced if the following conditions are satisfied:
   *     1. Usage ratio is above 95%
   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate,
   *        which means that too much has been borrowed at a stable rate and depositors are not earning enough
   * @param asset The address of the underlying asset borrowed
   * @param user The address of the user to be rebalanced
   **/
  function rebalanceStableBorrowRate(address asset, address user) external;

  /**
   * @dev Allows depositors to enable/disable a specific deposited asset as collateral
   * @param asset The address of the underlying asset deposited
   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
   **/
  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

  /**
   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
   * @param collateralAsset The address of the underlying asset used as collateral,
   *                        to receive as result of the liquidation.
   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
   * @param user The address of the borrower getting liquidated
   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
   * to receive the underlying collateral asset directly
   **/
  function liquidationCall(
    address collateralAsset,
    address debtAsset,
    address user,
    uint256 debtToCover,
    bool receiveAToken
  ) external;

  /**
   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
   * as long as the amount taken plus a fee is returned.
   * IMPORTANT There are security concerns for developers of flashloan receiver
   *           contracts that must be kept into consideration.
   * For further details please visit https://developers.aave.com
   * @param receiverAddress The address of the contract receiving the funds,
   *                        implementing the IFlashLoanReceiver interface.
   * @param assets The addresses of the assets being flash-borrowed
   * @param amounts The amounts amounts being flash-borrowed
   * @param modes Types of the debt to open if the flash loan is not returned:
   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
   * @param params Variadic packed params to pass to the receiver as extra information
   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
   *   0 if the action is executed directly by the user, without any middle-man
   **/
  function flashLoan(
    address receiverAddress,
    address[] calldata assets,
    uint256[] calldata amounts,
    uint256[] calldata modes,
    address onBehalfOf,
    bytes calldata params,
    uint16 referralCode
  ) external;

  /**
   * @dev Returns the user account data across all the reserves
   * @param user The address of the user
   * @return totalCollateralETH the total collateral in ETH of the user
   * @return totalDebtETH the total debt in ETH of the user
   * @return availableBorrowsETH the borrowing power left of the user
   * @return currentLiquidationThreshold the liquidation threshold of the user
   * @return ltv the loan to value of the user
   * @return healthFactor the current health factor of the user
   **/
  function getUserAccountData(address user)
    external
    view
    returns (
      uint256 totalCollateralETH,
      uint256 totalDebtETH,
      uint256 availableBorrowsETH,
      uint256 currentLiquidationThreshold,
      uint256 ltv,
      uint256 healthFactor
    );

  function initReserve(
    address reserve,
    address aTokenAddress,
    address stableDebtAddress,
    address variableDebtAddress,
    address interestRateStrategyAddress
  ) external;

  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

  function setConfiguration(address reserve, uint256 configuration) external;

  /**
   * @dev Returns the configuration of the reserve
   * @param asset The address of the underlying asset of the reserve
   * @return The configuration of the reserve
   **/
  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

  /**
   * @dev Returns the configuration of the user across all the reserves
   * @param user The user address
   * @return The configuration of the user
   **/
  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

  /**
   * @dev Returns the normalized income normalized income of the reserve
   * @param asset The address of the underlying asset of the reserve
   * @return The reserve's normalized income
   */
  function getReserveNormalizedIncome(address asset) external view returns (uint256);

  /**
   * @dev Returns the normalized variable debt per unit of asset
   * @param asset The address of the underlying asset of the reserve
   * @return The reserve normalized variable debt
   */
  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

  /**
   * @dev Returns the state and configuration of the reserve
   * @param asset The address of the underlying asset of the reserve
   * @return The state of the reserve
   **/
  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

  function finalizeTransfer(
    address asset,
    address from,
    address to,
    uint256 amount,
    uint256 balanceFromAfter,
    uint256 balanceToBefore
  ) external;

  function getReservesList() external view returns (address[] memory);

  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

  function setPause(bool val) external;

  function paused() external view returns (bool);
}",4001
RealWorld_TA_22_OracleManagerEthKillerChainlink_RealWorld_20240803003228.log,22,OracleManagerEthKillerChainlink,82378,3202,85580,116.0,0.47593,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

import ""../interfaces/IOracleManager.sol"";

contract OracleManagerEthKillerChainlink is IOracleManager {
  address public admin; // This will likely be the Gnosis safe

  // Oracle price, changes by average of the underlying asset changes.
  int256 public indexPrice;

  // Underlying asset prices.
  int256 public tronPrice;
  int256 public eosPrice;
  int256 public xrpPrice;

  // Oracle addresses
  AggregatorV3Interface public tronOracle;
  AggregatorV3Interface public eosOracle;
  AggregatorV3Interface public xrpOracle;

  ////////////////////////////////////
  /////////// MODIFIERS //////////////
  ////////////////////////////////////

  modifier adminOnly() {
    require(msg.sender == admin);
    _;
  }

  ////////////////////////////////////
  ///// CONTRACT SET-UP //////////////
  ////////////////////////////////////

  constructor(
    address _admin,
    address _tronOracle,
    address _eosOracle,
    address _xrpOracle
  ) {
    admin = _admin;
    tronOracle = AggregatorV3Interface(_tronOracle);
    eosOracle = AggregatorV3Interface(_eosOracle);
    xrpOracle = AggregatorV3Interface(_xrpOracle);
    // Initial asset prices.
    (tronPrice, eosPrice, xrpPrice) = _getAssetPrices();

    // Initial base index price.
    indexPrice = 1e18;
  }

  ////////////////////////////////////
  /// MULTISIG ADMIN FUNCTIONS ///////
  ////////////////////////////////////

  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  ////////////////////////////////////
  ///// IMPLEMENTATION ///////////////
  ////////////////////////////////////

  function _getAssetPrices()
    internal
    view
    returns (
      int256,
      int256,
      int256
    )
  {
    (, int256 _tronPrice, , , ) = tronOracle.latestRoundData();
    (, int256 _eosPrice, , , ) = eosOracle.latestRoundData();
    (, int256 _xrpPrice, , , ) = xrpOracle.latestRoundData();
    return (_tronPrice, _eosPrice, _xrpPrice);
  }

  function _updatePrice() internal virtual returns (int256) {
    (int256 newTronPrice, int256 newEosPrice, int256 newXrpPrice) = _getAssetPrices();

    int256 valueOfChangeInIndex = (int256(indexPrice) *
      (_calcAbsolutePercentageChange(newTronPrice, tronPrice) +
        _calcAbsolutePercentageChange(newEosPrice, eosPrice) +
        _calcAbsolutePercentageChange(newXrpPrice, xrpPrice))) / (3 * 1e18);

    tronPrice = newTronPrice;
    eosPrice = newEosPrice;
    xrpPrice = newXrpPrice;

    indexPrice = indexPrice + valueOfChangeInIndex;

    return indexPrice;
  }

  function updatePrice() external override returns (int256) {
    return _updatePrice();
  }

  function _calcAbsolutePercentageChange(int256 newPrice, int256 basePrice) internal pure returns (int256) {
    return ((newPrice - basePrice) * (1e18)) / (basePrice);
  }

  function getLatestPrice() external view override returns (int256) {
    return indexPrice;
  }
}",742
RealWorld_TA_23_BaseMockLiquidation_RealWorld_20240803021832.log,23,BaseMockLiquidation,111807,4597,116404,135.0,0.650975,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/markets/CashGroup.sol"";
import ""../internal/markets/Market.sol"";
import ""../internal/AccountContextHandler.sol"";
import ""../internal/portfolio/PortfolioHandler.sol"";
import ""../global/StorageLayoutV1.sol"";

contract BaseMockLiquidation is StorageLayoutV1 {
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;
    using CashGroup for CashGroupParameters;
    using Market for MarketParameters;

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setCashGroup(uint256 id, CashGroupSettings calldata cg) external {
        CashGroup.setCashGroupStorage(id, cg);
    }

    function buildCashGroupView(uint256 currencyId)
        public
        view
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupView(currencyId);
    }

    function setMarketStorage(
        uint256 currencyId,
        uint256 settlementDate,
        MarketParameters memory market
    ) public {
        market.storageSlot = Market.getSlot(currencyId, settlementDate, market.maturity);
        // ensure that state gets set
        market.storageState = 0xFF;
        market.setMarketStorage();
    }

    function getMarkets(uint256 currencyId, uint256 blockTime)
        public
        view
        returns (MarketParameters[] memory)
    {
        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);
        MarketParameters[] memory markets = new MarketParameters[](cashGroup.maxMarketIndex);

        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {
            cashGroup.loadMarket(markets[i], i + 1, true, blockTime);
        }

        return markets;
    }

    function getPortfolio(address account) public view returns (PortfolioAsset[] memory) {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);
    }

    function setETHRateMapping(uint256 id, ETHRateStorage calldata rs) external {
        underlyingToETHRateMapping[id] = rs;
    }

    function clearPortfolio(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        PortfolioState memory portfolioState =
            PortfolioHandler.buildPortfolioState(account, accountContext.assetArrayLength, 0);
        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            portfolioState.deleteAsset(i);
        }
        accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);
        accountContext.setAccountContext(account);
    }

    function setPortfolio(address account, PortfolioAsset[] memory assets) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        PortfolioState memory portfolioState =
            PortfolioHandler.buildPortfolioState(account, accountContext.assetArrayLength, 0);
        portfolioState.newAssets = assets;
        accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);
        accountContext.setAccountContext(account);
    }

    function setBalance(
        address account,
        uint256 currencyId,
        int256 cashBalance,
        int256 nTokenBalance
    ) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        accountContext.setActiveCurrency(currencyId, true, Constants.ACTIVE_IN_BALANCES);
        accountContext.setAccountContext(account);

        bytes32 slot =
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(account, Constants.BALANCE_STORAGE_OFFSET))
                )
            );
        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow
        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow
        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow

        bytes32 data =
            ((bytes32(uint256(nTokenBalance))) |
                (bytes32(0) << 80) |
                (bytes32(0) << 112) |
                (bytes32(cashBalance) << 168));

        assembly {
            sstore(slot, data)
        }
    }

    function setBitmapAsset(
        address account,
        uint16 currencyId,
        uint40 nextSettleTime,
        uint256 maturity,
        int256 notional
    ) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        accountContext.bitmapCurrencyId = currencyId;
        accountContext.nextSettleTime = nextSettleTime;
        bytes32 assetsBitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);
        BitmapAssetsHandler.addifCashAsset(
            account,
            currencyId,
            maturity,
            accountContext.nextSettleTime,
            notional,
            assetsBitmap
        );
        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, assetsBitmap);
        accountContext.setAccountContext(account);
    }

}",1081
RealWorld_TA_23_GovernanceAction_RealWorld_20240803063004.log,23,GovernanceAction,352585,4039,356624,373.0,1.843705,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/valuation/ExchangeRate.sol"";
import ""../../internal/markets/CashGroup.sol"";
import ""../../internal/nTokenHandler.sol"";
import ""../../internal/balances/TokenHandler.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""../../proxy/utils/UUPSUpgradeable.sol"";
import ""../adapters/nTokenERC20Proxy.sol"";
import ""interfaces/notional/AssetRateAdapter.sol"";
import ""interfaces/notional/NotionalGovernance.sol"";
import ""@openzeppelin/contracts/utils/Create2.sol"";

/// @notice Governance methods can only be called by the governance contract
contract GovernanceAction is StorageLayoutV1, NotionalGovernance, UUPSUpgradeable {
    /// @dev Throws if called by any account other than the owner.
    modifier onlyOwner() {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /// @dev Transfers ownership of the contract to a new account (`newOwner`).
    /// Can only be called by the current owner.
    function transferOwnership(address newOwner) external override onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    /// @dev Only the owner may upgrade the contract, the pauseGuardian may downgrade the contract
    /// to a predetermined router contract that provides read only access to the system.
    function _authorizeUpgrade(address newImplementation) internal override {
        require(
            owner == msg.sender ||
            (msg.sender == pauseGuardian && newImplementation == pauseRouter),
            ""Unauthorized upgrade""
        );

        // This is set temporarily during a downgrade to the pauseRouter so that the upgrade
        // will pass _authorizeUpgrade on the pauseRouter during the UUPSUpgradeable rollback check
        if (newImplementation == pauseRouter) rollbackRouterImplementation = _getImplementation();
    }

    /// @notice Sets a new pause router and guardian address.
    function setPauseRouterAndGuardian(
        address pauseRouter_,
        address pauseGuardian_
    ) external override onlyOwner {
        pauseRouter = pauseRouter_;
        pauseGuardian = pauseGuardian_;

        emit PauseRouterAndGuardianUpdated(pauseRouter_, pauseGuardian_);
    }

    /// @notice Lists a new currency along with its exchange rate to ETH
    /// @dev emit:ListCurrency emit:UpdateETHRate
    /// @param assetToken the token parameters for the asset token
    /// @param underlyingToken the underlying token (if asset token is an interest bearing wrapper)
    /// @param rateOracle ETH to underlying rate oracle
    /// @param mustInvert if the rate from the oracle needs to be inverted
    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral
    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral
    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating
    function listCurrency(
        TokenStorage calldata assetToken,
        TokenStorage calldata underlyingToken,
        address rateOracle,
        bool mustInvert,
        uint8 buffer,
        uint8 haircut,
        uint8 liquidationDiscount
    ) external override onlyOwner {
        uint16 currencyId = maxCurrencyId + 1;
        // Set the new max currency id
        maxCurrencyId = currencyId;
        require(currencyId <= Constants.MAX_CURRENCIES, ""G: max currency overflow"");
        require(
            tokenAddressToCurrencyId[assetToken.tokenAddress] == 0,
            ""G: duplicate token listing""
        );
        tokenAddressToCurrencyId[assetToken.tokenAddress] = currencyId;

        // Set the underlying first because the asset token may set an approval using the underlying
        if (
            underlyingToken.tokenAddress != address(0) ||
            // Ether has a token address of zero
            underlyingToken.tokenType == TokenType.Ether
        ) {
            TokenHandler.setToken(currencyId, true, underlyingToken);
        }
        TokenHandler.setToken(currencyId, false, assetToken);

        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);

        emit ListCurrency(currencyId);
    }

    /// @notice Enables a cash group on a given currency so that it can have lend and borrow markets. Will
    /// also deploy an nToken contract so that markets can be initialized.
    /// @dev emit:UpdateCashGroup emit:UpdateAssetRate emit:DeployNToken
    /// @param currencyId id of the currency to enable
    /// @param assetRateOracle address of the rate oracle for converting interest bearing assets to
    /// underlying values
    /// @param cashGroup parameters for the cash group
    /// @param underlyingName underlying token name for seeding nToken name
    /// @param underlyingSymbol underlying token symbol for seeding nToken symbol (i.e. nDAI)
    function enableCashGroup(
        uint16 currencyId,
        address assetRateOracle,
        CashGroupSettings calldata cashGroup,
        string calldata underlyingName,
        string calldata underlyingSymbol
    ) external override onlyOwner {
        _updateCashGroup(currencyId, cashGroup);
        _updateAssetRate(currencyId, assetRateOracle);

        // Creates the nToken erc20 proxy that routes back to the main contract
        address nTokenAddress =
            Create2.deploy(
                0,
                bytes32(uint256(currencyId)),
                abi.encodePacked(
                    type(nTokenERC20Proxy).creationCode,
                    abi.encode(address(this), currencyId, underlyingName, underlyingSymbol)
                )
            );

        nTokenHandler.setNTokenAddress(currencyId, nTokenAddress);
        emit DeployNToken(currencyId, nTokenAddress);
    }

    /// @notice Updates the deposit parameters for an nToken
    /// @dev emit:UpdateDepositParameters
    /// @param currencyId the currency id that the nToken references
    /// @param depositShares an array of values that represent the proportion of each deposit
    /// that will go to a respective market, must add up to DEPOSIT_PERCENT_BASIS. For example,
    /// 0.40e8, 0.40e8 and 0.20e8 will result in 40%, 40% and 20% deposited as liquidity into
    /// the 3 month, 6 month and 1 year markets.
    /// @param leverageThresholds an array of values denominated in RATE_PRECISION that mark the
    /// highest proportion of fCash where the nToken will provide liquidity. Above this proportion,
    /// the nToken will lend to the market instead to reduce the leverage in the market.
    function updateDepositParameters(
        uint16 currencyId,
        uint32[] calldata depositShares,
        uint32[] calldata leverageThresholds
    ) external override onlyOwner {
        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);
        emit UpdateDepositParameters(currencyId);
    }

    /// @notice Updates the market initialization parameters for an nToken
    /// @dev emit:UpdateInitializationParameters
    /// @param currencyId the currency id that the nToken references
    /// @param annualizedAnchorRates is a target interest rate that will be used to calculate a 
    /// rate anchor during initialize markets. This rate anchor will set the offset from the
    /// x-axis where the liquidity curve will be initialized. This is used in combination with
    /// previous market rates to determine the initial proportion where markets will be initialized
    /// every quarter.
    /// @param proportions used to combination with annualizedAnchorRate set the initial proportion when
    /// a market is first initialized. This is required since there is no previous rate to reference.
    function updateInitializationParameters(
        uint16 currencyId,
        uint32[] calldata annualizedAnchorRates,
        uint32[] calldata proportions
    ) external override onlyOwner {
        nTokenHandler.setInitializationParameters(currencyId, annualizedAnchorRates, proportions);
        emit UpdateInitializationParameters(currencyId);
    }

    /// @notice Updates the emission rate of incentives for a given currency
    /// @dev emit:UpdateIncentiveEmissionRate
    /// @param currencyId the currency id that the nToken references
    /// @param newEmissionRate Target total incentives to emit for an nToken over an entire year
    /// denominated in WHOLE TOKENS (i.e. setting this to 1 means 1e8 tokens). The rate will not be
    /// exact due to multiplier effects and fluctuating token supply.
    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate)
        external
        override
        onlyOwner
    {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(nTokenAddress != address(0), ""Invalid currency"");
        // Sanity check that emissions rate is not specified in 1e8 terms.
        require(newEmissionRate < Constants.INTERNAL_TOKEN_PRECISION, ""Invalid rate"");

        nTokenHandler.setIncentiveEmissionRate(nTokenAddress, newEmissionRate);
        emit UpdateIncentiveEmissionRate(currencyId, newEmissionRate);
    }

    /// @notice Updates collateralization parameters for an nToken
    /// @dev emit:UpdateTokenCollateralParameters
    /// @param currencyId the currency id that the nToken references
    /// @param residualPurchaseIncentive10BPS nTokens will have residual amounts of fCash at the end of each
    /// quarter that are ""dead weight"" because they are at idiosyncratic maturities and do not contribute to
    /// actively providing liquidity. This parameter will incentivize market participants to purchase these residuals
    /// at a discount from the on chain oracle rate, denominated in 10 basis point increments. These residuals will
    /// be added back into nToken balances and will be used to provide liquidity upon the next market initialization.
    /// @param pvHaircutPercentage a percentage (< 100) that the present value of the nToken's assets will be valued
    /// at for the purposes of free collateral, relevant when accounts hold nTokens as collateral against debts.
    /// @param residualPurchaseTimeBufferHours an arbitrage opportunity is available by pushing markets in one direction
    /// before quarterly settlement to generate large residual balances that can be purchased at a discount. The time buffer
    /// here ensures that anyone attempting such an act would have to wait some number of hours (likely a few days) before
    /// they could attempt to purchase residuals, ensuring that the market could realign to rates where the arbitrage is
    /// no longer possible.
    /// @param cashWithholdingBuffer10BPS nToken residuals may be negative fCash (debt), in this case cash is withheld to
    /// transfer to accounts that take on the debt. This parameter denominates the discounted rate at which the cash will
    /// be withheld at for this purpose.
    /// @param liquidationHaircutPercentage a percentage of nToken present value (> pvHaircutPercentage and <= 100) at which
    /// liquidators will purchase nTokens during liquidation
    function updateTokenCollateralParameters(
        uint16 currencyId,
        uint8 residualPurchaseIncentive10BPS,
        uint8 pvHaircutPercentage,
        uint8 residualPurchaseTimeBufferHours,
        uint8 cashWithholdingBuffer10BPS,
        uint8 liquidationHaircutPercentage
    ) external override onlyOwner {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(nTokenAddress != address(0), ""Invalid currency"");

        nTokenHandler.setNTokenCollateralParameters(
            nTokenAddress,
            residualPurchaseIncentive10BPS,
            pvHaircutPercentage,
            residualPurchaseTimeBufferHours,
            cashWithholdingBuffer10BPS,
            liquidationHaircutPercentage
        );
        emit UpdateTokenCollateralParameters(currencyId);
    }

    /// @notice Updates cash group parameters
    /// @dev emit:UpdateCashGroup
    /// @param currencyId id of the currency to enable
    /// @param cashGroup new parameters for the cash group
    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup)
        external
        override
        onlyOwner
    {
        _updateCashGroup(currencyId, cashGroup);
    }

    /// @notice Updates asset rate oracle
    /// @dev emit:UpdateAssetRate
    /// @param currencyId id of the currency
    /// @param rateOracle new rate oracle for the asset
    function updateAssetRate(uint16 currencyId, address rateOracle) external override onlyOwner {
        _updateAssetRate(currencyId, rateOracle);
    }

    /// @notice Updates ETH exchange rate or related parameters
    /// @dev emit:UpdateETHRate
    /// @param currencyId id of the currency
    /// @param rateOracle new rate oracle for the asset
    /// @param rateOracle ETH to underlying rate oracle
    /// @param mustInvert if the rate from the oracle needs to be inverted
    /// @param buffer multiplier (>= 100) for negative balances when calculating free collateral
    /// @param haircut multiplier (<= 100) for positive balances when calculating free collateral
    /// @param liquidationDiscount multiplier (>= 100) for exchange rate when liquidating
    function updateETHRate(
        uint16 currencyId,
        address rateOracle,
        bool mustInvert,
        uint8 buffer,
        uint8 haircut,
        uint8 liquidationDiscount
    ) external override onlyOwner {
        _updateETHRate(currencyId, rateOracle, mustInvert, buffer, haircut, liquidationDiscount);
    }

    /// @notice Sets a global transfer operator that can do authenticated ERC1155 transfers. This enables
    /// OTC trading or other use cases such as layer 2 authenticated transfers.
    /// @dev emit:UpdateGlobalTransferOperator
    /// @param operator address of the operator
    /// @param approved true if the operator is allowed to transfer globally
    function updateGlobalTransferOperator(address operator, bool approved)
        external
        override
        onlyOwner
    {
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(operator)
        }
        // Sanity check to ensure that operator is a contract, not an EOA
        require(codeSize > 0, ""Operator must be a contract"");

        globalTransferOperator[operator] = approved;
        emit UpdateGlobalTransferOperator(operator, approved);
    }

    /// @notice Approves contracts that can call `batchTradeActionWithCallback`. These contracts can
    /// ""flash loan"" from Notional V2 and receive a callback before the free collateral check. Flash loans
    /// via the Notional V2 liquidity pool are not very gas efficient so this is not generally available,
    /// it can be used for migrating borrows into Notional V2 from other platforms.
    /// @dev emit:UpdateAuthorizedCallbackContract
    /// @param operator address of the contract
    /// @param approved true if the contract is authorized
    function updateAuthorizedCallbackContract(address operator, bool approved)
        external
        override
        onlyOwner
    {
        uint256 codeSize;
        assembly {
            codeSize := extcodesize(operator)
        }
        // Sanity check to ensure that operator is a contract, not an EOA
        require(codeSize > 0, ""Operator must be a contract"");

        authorizedCallbackContract[operator] = approved;
        emit UpdateAuthorizedCallbackContract(operator, approved);
    }

    function _updateCashGroup(uint256 currencyId, CashGroupSettings calldata cashGroup) internal {
        require(currencyId != 0, ""G: invalid currency id"");
        require(currencyId <= maxCurrencyId, ""G: invalid currency id"");

        CashGroup.setCashGroupStorage(currencyId, cashGroup);

        emit UpdateCashGroup(uint16(currencyId));
    }

    function _updateAssetRate(uint256 currencyId, address rateOracle) internal {
        require(currencyId != 0, ""G: invalid currency id"");
        require(currencyId <= maxCurrencyId, ""G: invalid currency id"");

        // If rate oracle refers to address zero then do not apply any updates here, this means
        // that a token is non mintable.
        Token memory assetToken = TokenHandler.getToken(currencyId, false);
        if (rateOracle == address(0)) {
            // Sanity check that unset rate oracles are only for non mintable tokens
            require(assetToken.tokenType == TokenType.NonMintable, ""G: invalid asset rate"");
            return;
        }

        // Sanity check that the rate oracle refers to the proper asset token
        address token = AssetRateAdapter(rateOracle).token();
        require(assetToken.tokenAddress == token, ""G: invalid rate oracle"");

        uint8 underlyingDecimals;
        if (currencyId == 1) {
            // If currencyId is one then this is referring to cETH and there is no underlying() to call
            underlyingDecimals = 18;
        } else {
            address underlyingToken = AssetRateAdapter(rateOracle).underlying();
            underlyingDecimals = ERC20(underlyingToken).decimals();
        }

        assetToUnderlyingRateMapping[currencyId] = AssetRateStorage({
            rateOracle: rateOracle,
            underlyingDecimalPlaces: underlyingDecimals
        });

        emit UpdateAssetRate(uint16(currencyId));
    }

    function _updateETHRate(
        uint256 currencyId,
        address rateOracle,
        bool mustInvert,
        uint8 buffer,
        uint8 haircut,
        uint8 liquidationDiscount
    ) internal {
        require(currencyId != 0, ""G: invalid currency id"");
        require(currencyId <= maxCurrencyId, ""G: invalid currency id"");

        uint8 rateDecimalPlaces;
        if (currencyId == Constants.ETH_CURRENCY_ID) {
            // ETH to ETH exchange rate is fixed at 1 and has no rate oracle
            rateOracle = address(0);
            rateDecimalPlaces = 18;
        } else {
            require(rateOracle != address(0), ""G: zero rate oracle address"");
            rateDecimalPlaces = AggregatorV2V3Interface(rateOracle).decimals();
        }
        require(buffer >= Constants.PERCENTAGE_DECIMALS, ""G: buffer must be gte decimals"");
        require(haircut <= Constants.PERCENTAGE_DECIMALS, ""G: buffer must be lte decimals"");
        require(
            liquidationDiscount > Constants.PERCENTAGE_DECIMALS,
            ""G: discount must be gt decimals""
        );

        underlyingToETHRateMapping[currencyId] = ETHRateStorage({
            rateOracle: rateOracle,
            rateDecimalPlaces: rateDecimalPlaces,
            mustInvert: mustInvert,
            buffer: buffer,
            haircut: haircut,
            liquidationDiscount: liquidationDiscount
        });

        emit UpdateETHRate(uint16(currencyId));
    }
}",4023
RealWorld_TA_23_ERC1967Proxy_RealWorld_20240803030303.log,23,ERC1967Proxy,43260,1419,44679,85.0,0.24468,"// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import ""../Proxy.sol"";
import ""./ERC1967Upgrade.sol"";

/**
 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
 * implementation address that can be changed. This address is stored in storage in the location specified by
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the
 * implementation behind the proxy.
 */
contract ERC1967Proxy is Proxy, ERC1967Upgrade {
    /**
     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
     *
     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded
     * function call, and allows initializating the storage of the proxy like a Solidity constructor.
     */
    constructor(address _logic, bytes memory _data) payable {
        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1));
        _upgradeToAndCall(_logic, _data, false);
    }

    /**
     * @dev Returns the current implementation address.
     */
    function _implementation() internal view virtual override returns (address impl) {
        return ERC1967Upgrade._getImplementation();
    }
}",299
RealWorld_TA_23_LiquidateCurrency_RealWorld_20240803033028.log,23,LiquidateCurrency,433615,4769,438384,376.0,2.263455,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./LiquidationHelpers.sol"";
import ""../AccountContextHandler.sol"";
import ""../valuation/ExchangeRate.sol"";
import ""../markets/CashGroup.sol"";
import ""../markets/AssetRate.sol"";
import ""../portfolio/BitmapAssetsHandler.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../balances/BalanceHandler.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library LiquidateCurrency {
    using SafeInt256 for int256;
    using ExchangeRate for ETHRate;
    using PortfolioHandler for PortfolioState;
    using AssetHandler for PortfolioAsset;
    using AssetRate for AssetRateParameters;
    using CashGroup for CashGroupParameters;
    using Market for MarketParameters;
    using AccountContextHandler for AccountContext;
    using BalanceHandler for BalanceState;

    function _hasLiquidityTokens(PortfolioAsset[] memory portfolio, uint256 currencyId)
        private
        pure
        returns (bool)
    {
        for (uint256 i; i < portfolio.length; i++) {
            if (
                portfolio[i].currencyId == currencyId &&
                AssetHandler.isLiquidityToken(portfolio[i].assetType) &&
                // This should not be possible (a deleted asset) in the portfolio
                // at this stage of liquidation but we do this check to be defensive.
                portfolio[i].storageState != AssetStorageState.Delete
            ) {
                return true;
            }
        }

        return false;
    }

    /// @notice Liquidates an account by converting their local currency collateral into cash and
    /// eliminates any haircut value incurred by liquidity tokens or nTokens. Requires no capital
    /// on the part of the liquidator, this is pure arbitrage. It's highly unlikely that an account will
    /// encounter this scenario but this method is here for completeness.
    function liquidateLocalCurrency(
        uint256 localCurrency,
        uint96 maxNTokenLiquidation,
        uint256 blockTime,
        BalanceState memory balanceState,
        LiquidationFactors memory factors,
        PortfolioState memory portfolio
    ) internal view returns (int256) {
        require(factors.localAssetAvailable < 0, ""No local debt"");

        int256 assetBenefitRequired =
            factors.cashGroup.assetRate.convertFromUnderlying(
                factors
                    .localETHRate
                    .convertETHTo(factors.netETHValue.neg())
                    .mul(Constants.PERCENTAGE_DECIMALS)
                    .div(factors.localETHRate.buffer)
            );

        int256 netAssetCashFromLiquidator;

        if (_hasLiquidityTokens(portfolio.storedAssets, localCurrency)) {
            WithdrawFactors memory w;
            (w, assetBenefitRequired) = _withdrawLocalLiquidityTokens(
                portfolio,
                factors,
                blockTime,
                assetBenefitRequired
            );
            netAssetCashFromLiquidator = w.totalIncentivePaid.neg();
            balanceState.netCashChange = w.totalCashClaim.sub(w.totalIncentivePaid);
        }

        if (factors.nTokenHaircutAssetValue > 0) {
            int256 nTokensToLiquidate;
            {
                // This will not underflow, checked when saving parameters
                int256 haircutDiff =
                    int256(
                        uint8(factors.nTokenParameters[Constants.LIQUIDATION_HAIRCUT_PERCENTAGE]) -
                            uint8(factors.nTokenParameters[Constants.PV_HAIRCUT_PERCENTAGE])
                    ) * Constants.PERCENTAGE_DECIMALS;

                // fullNTokenPV = haircutTokenPV / haircutPercentage
                // benefitGained = nTokensToLiquidate * (liquidatedPV - freeCollateralPV)
                // benefitGained = nTokensToLiquidate * (fullNTokenPV * liquidatedPV - fullNTokenPV * pvHaircut)
                // benefitGained = nTokensToLiquidate * fullNTokenPV * (liquidatedPV - pvHaircut) / totalBalance
                // benefitGained = nTokensToLiquidate * (haircutTokenPV / haircutPercentage) * (liquidationHaircut - pvHaircut) / totalBalance
                // benefitGained = nTokensToLiquidate * haircutTokenPV * (liquidationHaircut - pvHaircut) / (totalBalance * haircutPercentage)
                // nTokensToLiquidate = (benefitGained * totalBalance * haircutPercentage) / (haircutTokenPV * (liquidationHaircut - pvHaircut))
                nTokensToLiquidate = assetBenefitRequired
                    .mul(balanceState.storedNTokenBalance)
                    .mul(int256(uint8(factors.nTokenParameters[Constants.PV_HAIRCUT_PERCENTAGE])))
                    .div(factors.nTokenHaircutAssetValue.mul(haircutDiff));
            }

            nTokensToLiquidate = LiquidationHelpers.calculateLiquidationAmount(
                nTokensToLiquidate,
                balanceState.storedNTokenBalance,
                int256(maxNTokenLiquidation)
            );
            balanceState.netNTokenTransfer = nTokensToLiquidate.neg();

            {
                // fullNTokenPV = haircutTokenPV / haircutPercentage
                // localFromLiquidator = tokensToLiquidate * fullNTokenPV * liquidationHaircut / totalBalance
                // prettier-ignore
                int256 localAssetCash =
                    nTokensToLiquidate
                        .mul(int256(uint8(factors.nTokenParameters[Constants.LIQUIDATION_HAIRCUT_PERCENTAGE])))
                        .mul(factors.nTokenHaircutAssetValue)
                        .div(int256(uint8(factors.nTokenParameters[Constants.PV_HAIRCUT_PERCENTAGE])))
                        .div(balanceState.storedNTokenBalance);

                balanceState.netCashChange = balanceState.netCashChange.add(localAssetCash);
                netAssetCashFromLiquidator = netAssetCashFromLiquidator.add(localAssetCash);
            }
        }

        return netAssetCashFromLiquidator;
    }

    /// @notice Liquidates collateral in the form of cash, liquidity token cash claims, or nTokens in that
    /// liquidation preference.
    function liquidateCollateralCurrency(
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation,
        uint256 blockTime,
        BalanceState memory balanceState,
        LiquidationFactors memory factors,
        PortfolioState memory portfolio
    ) internal view returns (int256) {
        require(factors.localAssetAvailable < 0, ""No local debt"");
        require(factors.collateralAssetAvailable > 0, ""No collateral"");

        (
            int256 requiredCollateralAssetCash,
            int256 localAssetCashFromLiquidator,
            int256 liquidationDiscount
        ) = _calculateCollateralToRaise(factors, int256(maxCollateralLiquidation));

        int256 collateralAssetRemaining = requiredCollateralAssetCash;
        if (balanceState.storedCashBalance > 0) {
            if (balanceState.storedCashBalance > collateralAssetRemaining) {
                balanceState.netCashChange = collateralAssetRemaining.neg();
                collateralAssetRemaining = 0;
            } else {
                // Sell off all cash balance and calculate remaining collateral
                balanceState.netCashChange = balanceState.storedCashBalance.neg();
                collateralAssetRemaining = collateralAssetRemaining.sub(
                    balanceState.storedCashBalance
                );
            }
        }

        if (
            collateralAssetRemaining > 0 &&
            _hasLiquidityTokens(portfolio.storedAssets, balanceState.currencyId)
        ) {
            int256 newCollateralAssetRemaining =
                _withdrawCollateralLiquidityTokens(
                    portfolio,
                    factors,
                    blockTime,
                    collateralAssetRemaining
                );

            // This is a hack and ugly but there are stack issues in `LiquidateCurrencyAction.liquidateCollateralCurrency`
            // and this is a way to deal with it with the fewest contortions. There are no asset cash transfers within liquidation
            // so we overload the meaning of the field here to hold the net liquidity token cash change. Will zero this out before
            // going into finalize for the liquidated account's cash balances. This value is not simply added to the netCashChange field
            // because the cashClaim value is not stored in the balances and therefore the liquidated account will have too much cash
            // debited from their stored cash value.
            balanceState.netAssetTransferInternalPrecision = collateralAssetRemaining.sub(
                newCollateralAssetRemaining
            );
            collateralAssetRemaining = newCollateralAssetRemaining;
        }

        if (collateralAssetRemaining > 0 && factors.nTokenHaircutAssetValue > 0) {
            collateralAssetRemaining = _calculateCollateralNTokenTransfer(
                balanceState,
                factors,
                collateralAssetRemaining,
                int256(maxNTokenLiquidation)
            );
        }

        if (collateralAssetRemaining > 0) {
            // If there is any collateral asset remaining then recalculate the localAssetCashFromLiquidator
            // prettier-ignore
            (
                /* collateralToRaise */,
                localAssetCashFromLiquidator
            ) = LiquidationHelpers.calculateLocalToPurchase(
                factors,
                liquidationDiscount,
                requiredCollateralAssetCash.sub(collateralAssetRemaining),
                requiredCollateralAssetCash.sub(collateralAssetRemaining)
            );
        }

        return localAssetCashFromLiquidator;
    }

    /// @dev Calculates anticipated collateral to raise, enforcing some limits. Actual transfers may be lower due
    /// to limits on the nToken transfer
    function _calculateCollateralToRaise(
        LiquidationFactors memory factors,
        int256 maxCollateralLiquidation
    )
        private
        pure
        returns (
            int256 requiredCollateralAssetCash,
            int256 localAssetCashFromLiquidator,
            int256 liquidationDiscount
        )
    {
        int256 assetCashBenefitRequired;
        (assetCashBenefitRequired, liquidationDiscount) = LiquidationHelpers
            .calculateCrossCurrencyBenefitAndDiscount(factors);
        {
            // collateralCurrencyBenefit = localPurchased * localBuffer * exchangeRate -
            //      collateralToSell * collateralHaircut
            // localPurchased = collateralToSell / (exchangeRate * liquidationDiscount)
            //
            // collateralCurrencyBenefit = [collateralToSell / (exchangeRate * liquidationDiscount)] * localBuffer * exchangeRate -
            //      collateralToSell * collateralHaircut
            // collateralCurrencyBenefit = (collateralToSell * localBuffer) / liquidationDiscount - collateralToSell * collateralHaircut
            // collateralCurrencyBenefit = collateralToSell * (localBuffer / liquidationDiscount - collateralHaircut)
            // collateralToSell = collateralCurrencyBenefit / [(localBuffer / liquidationDiscount - collateralHaircut)]
            int256 denominator =
                factors
                    .localETHRate
                    .buffer
                    .mul(Constants.PERCENTAGE_DECIMALS)
                    .div(liquidationDiscount)
                    .sub(factors.collateralETHRate.haircut);

            requiredCollateralAssetCash = assetCashBenefitRequired
                .mul(Constants.PERCENTAGE_DECIMALS)
                .div(denominator);
        }

        requiredCollateralAssetCash = LiquidationHelpers.calculateLiquidationAmount(
            requiredCollateralAssetCash,
            factors.collateralAssetAvailable,
            0 // will check userSpecifiedAmount below
        );

        // Enforce the user specified max liquidation amount
        if (
            maxCollateralLiquidation > 0 && requiredCollateralAssetCash > maxCollateralLiquidation
        ) {
            requiredCollateralAssetCash = maxCollateralLiquidation;
        }

        // prettier-ignore
        (requiredCollateralAssetCash, localAssetCashFromLiquidator) = LiquidationHelpers
            .calculateLocalToPurchase(
                factors,
                liquidationDiscount,
                requiredCollateralAssetCash,
                requiredCollateralAssetCash
            );

        return (requiredCollateralAssetCash, localAssetCashFromLiquidator, liquidationDiscount);
    }

    /// @dev Calculates the nToken transfer.
    function _calculateCollateralNTokenTransfer(
        BalanceState memory balanceState,
        LiquidationFactors memory factors,
        int256 collateralAssetRemaining,
        int256 maxNTokenLiquidation
    ) internal pure returns (int256) {
        // fullNTokenPV = haircutTokenPV / haircutPercentage
        // collateralToRaise = tokensToLiquidate * fullNTokenPV * liquidationHaircut / totalBalance
        // tokensToLiquidate = collateralToRaise * totalBalance / (fullNTokenPV * liquidationHaircut)
        // tokensToLiquidate = (collateralToRaise * totalBalance * haircutPercentage) / (haircutTokenPV * liquidationHaircut)
        int256 nTokenLiquidationHaircut =
            int256(uint8(factors.nTokenParameters[Constants.LIQUIDATION_HAIRCUT_PERCENTAGE]));
        int256 nTokenHaircut =
            int256(uint8(factors.nTokenParameters[Constants.PV_HAIRCUT_PERCENTAGE]));
        int256 nTokensToLiquidate =
            collateralAssetRemaining.mul(balanceState.storedNTokenBalance).mul(nTokenHaircut).div(
                factors.nTokenHaircutAssetValue.mul(nTokenLiquidationHaircut)
            );

        if (maxNTokenLiquidation > 0 && nTokensToLiquidate > maxNTokenLiquidation) {
            nTokensToLiquidate = maxNTokenLiquidation;
        }

        if (nTokensToLiquidate > balanceState.storedNTokenBalance) {
            nTokensToLiquidate = balanceState.storedNTokenBalance;
        }

        balanceState.netNTokenTransfer = nTokensToLiquidate.neg();
        // NOTE: it's possible that this results in > DEFAULT_LIQUIDATION_PORTION in PV terms. However, it will not be more than
        // the liquidateHaircutPercentage which will be set to a nominal amount. Since DEFAULT_LIQUIDATION_PORTION is arbitrary we
        // don't put too much emphasis on this and allow it to occur.
        collateralAssetRemaining = collateralAssetRemaining.subNoNeg(
            // collateralToRaise = (nTokenToLiquidate * nTokenPV * liquidateHaircutPercentage) / nTokenBalance
            nTokensToLiquidate
                .mul(factors.nTokenHaircutAssetValue)
                .mul(nTokenLiquidationHaircut)
                .div(nTokenHaircut)
                .div(balanceState.storedNTokenBalance)
        );

        return collateralAssetRemaining;
    }

    struct WithdrawFactors {
        int256 netCashIncrease;
        int256 fCash;
        int256 assetCash;
        int256 totalIncentivePaid;
        int256 totalCashClaim;
        int256 incentivePaid;
    }

    /// @notice Withdraws local liquidity tokens from a portfolio and pays an incentive to the liquidator.
    function _withdrawLocalLiquidityTokens(
        PortfolioState memory portfolioState,
        LiquidationFactors memory factors,
        uint256 blockTime,
        int256 assetAmountRemaining
    ) internal view returns (WithdrawFactors memory, int256) {
        require(portfolioState.newAssets.length == 0); // dev: new assets in portfolio
        factors.markets = new MarketParameters[](factors.cashGroup.maxMarketIndex);
        // Do this to deal with stack issues
        WithdrawFactors memory w;

        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            PortfolioAsset memory asset = portfolioState.storedAssets[i];
            if (asset.storageState == AssetStorageState.Delete) continue;
            if (
                !AssetHandler.isLiquidityToken(asset.assetType) ||
                asset.currencyId != factors.cashGroup.currencyId
            ) continue;

            uint256 marketIndex = asset.assetType - 1;
            // This is set up this way so that we can delay setting storage of markets so that this method can
            // remain a view function
            factors.cashGroup.loadMarket(
                factors.markets[marketIndex - 1],
                marketIndex,
                true,
                blockTime
            );

            // NOTE: we do not give any credit to the haircut fCash in this procedure but it will end up adding
            // additional collateral value back into the account. It's probably too complex to deal with this so
            // we will just leave it as such.
            (w.assetCash, w.fCash) = asset.getCashClaims(factors.markets[marketIndex - 1]);
            _calculateNetCashIncreaseAndIncentivePaid(factors, w, asset.assetType);

            // (netCashToAccount <= assetAmountRemaining)
            if (w.netCashIncrease.subNoNeg(w.incentivePaid) <= assetAmountRemaining) {
                // The additional cash is insufficient to cover asset amount required so we just remove all of it.
                portfolioState.deleteAsset(i);
                factors.markets[marketIndex - 1].removeLiquidity(asset.notional);

                // assetAmountRemaining = assetAmountRemaining - netCashToAccount
                // netCashToAccount = netCashIncrease - incentivePaid
                // overflow checked above
                assetAmountRemaining =
                    assetAmountRemaining -
                    w.netCashIncrease.sub(w.incentivePaid);
            } else {
                // Otherwise remove a proportional amount of liquidity tokens to cover the amount remaining.
                int256 tokensToRemove =
                    asset.notional.mul(assetAmountRemaining).div(
                        w.netCashIncrease.subNoNeg(w.incentivePaid)
                    );

                (w.assetCash, w.fCash) = factors.markets[marketIndex - 1].removeLiquidity(
                    tokensToRemove
                );
                // Recalculate net cash increase and incentive paid. w.assetCash is different because we partially
                // remove asset cash
                _calculateNetCashIncreaseAndIncentivePaid(factors, w, asset.assetType);

                // Remove liquidity token balance
                portfolioState.storedAssets[i].notional = asset.notional.subNoNeg(tokensToRemove);
                portfolioState.storedAssets[i].storageState = AssetStorageState.Update;
                assetAmountRemaining = 0;
            }

            w.totalIncentivePaid = w.totalIncentivePaid.add(w.incentivePaid);
            w.totalCashClaim = w.totalCashClaim.add(w.assetCash);

            // Add the netfCash asset to the portfolio since we've withdrawn the liquidity tokens
            portfolioState.addAsset(
                factors.cashGroup.currencyId,
                asset.maturity,
                Constants.FCASH_ASSET_TYPE,
                w.fCash
            );

            if (assetAmountRemaining == 0) break;
        }

        return (w, assetAmountRemaining);
    }

    function _calculateNetCashIncreaseAndIncentivePaid(
        LiquidationFactors memory factors,
        WithdrawFactors memory w,
        uint256 assetType
    ) private pure {
        // We can only recollateralize the local currency using the part of the liquidity token that
        // between the pre-haircut cash claim and the post-haircut cash claim. Part of the cash raised
        // is paid out as an incentive so that must be accounted for.
        // netCashIncrease = cashClaim * (1 - haircut)
        // netCashIncrease = netCashToAccount + incentivePaid
        // incentivePaid = netCashIncrease * incentive
        int256 haircut = int256(factors.cashGroup.getLiquidityHaircut(assetType));
        w.netCashIncrease = w.assetCash.mul(Constants.PERCENTAGE_DECIMALS.sub(haircut)).div(
            Constants.PERCENTAGE_DECIMALS
        );
        w.incentivePaid = w.netCashIncrease.mul(Constants.TOKEN_REPO_INCENTIVE_PERCENT).div(
            Constants.PERCENTAGE_DECIMALS
        );
    }

    /// @dev Similar to withdraw liquidity tokens, except there is no incentive paid and we do not worry about
    /// haircut amounts, we simply withdraw as much collateral as needed.
    function _withdrawCollateralLiquidityTokens(
        PortfolioState memory portfolioState,
        LiquidationFactors memory factors,
        uint256 blockTime,
        int256 collateralToWithdraw
    ) internal view returns (int256) {
        require(portfolioState.newAssets.length == 0); // dev: new assets in portfolio
        factors.markets = new MarketParameters[](factors.cashGroup.maxMarketIndex);

        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            PortfolioAsset memory asset = portfolioState.storedAssets[i];
            if (asset.storageState == AssetStorageState.Delete) continue;
            if (
                !AssetHandler.isLiquidityToken(asset.assetType) ||
                asset.currencyId != factors.cashGroup.currencyId
            ) continue;

            uint256 marketIndex = asset.assetType - 1;
            // This is set up this way so that we can delay setting storage of markets so that this method can
            // remain a view function
            factors.cashGroup.loadMarket(
                factors.markets[marketIndex - 1],
                marketIndex,
                true,
                blockTime
            );
            (int256 cashClaim, int256 fCashClaim) =
                asset.getCashClaims(factors.markets[marketIndex - 1]);

            if (cashClaim <= collateralToWithdraw) {
                // The additional cash is insufficient to cover asset amount required so we just remove all of it.
                portfolioState.deleteAsset(i);
                factors.markets[marketIndex - 1].removeLiquidity(asset.notional);

                // overflow checked above
                collateralToWithdraw = collateralToWithdraw - cashClaim;
            } else {
                // Otherwise remove a proportional amount of liquidity tokens to cover the amount remaining.
                // NOTE: dust can accrue when withdrawing liquidity at this point
                int256 tokensToRemove = asset.notional.mul(collateralToWithdraw).div(cashClaim);
                (cashClaim, fCashClaim) = factors.markets[marketIndex - 1].removeLiquidity(
                    tokensToRemove
                );

                // Remove liquidity token balance
                portfolioState.storedAssets[i].notional = asset.notional.subNoNeg(tokensToRemove);
                portfolioState.storedAssets[i].storageState = AssetStorageState.Update;
                collateralToWithdraw = 0;
            }

            // Add the netfCash asset to the portfolio since we've withdrawn the liquidity tokens
            portfolioState.addAsset(
                factors.cashGroup.currencyId,
                asset.maturity,
                Constants.FCASH_ASSET_TYPE,
                fCashClaim
            );

            if (collateralToWithdraw == 0) return 0;
        }

        return collateralToWithdraw;
    }

    function finalizeLiquidatedCollateralAndPortfolio(
        address liquidateAccount,
        BalanceState memory collateralBalanceState,
        AccountContext memory accountContext,
        PortfolioState memory portfolio,
        MarketParameters[] memory markets
    ) internal {
        // Asset transfer value is set to record liquidity token withdraw balances and should not be
        // finalized inside the liquidated collateral. See comment inside liquidateCollateralCurrency
        // for more details
        int256 tmpAssetTransferAmount = collateralBalanceState.netAssetTransferInternalPrecision;
        collateralBalanceState.netAssetTransferInternalPrecision = 0;

        // Finalize liquidated account balance
        collateralBalanceState.finalize(liquidateAccount, accountContext, false);
        if (accountContext.bitmapCurrencyId == 0) {
            // Portfolio updates only happen if the account has liquidity tokens, which can only be the
            // case in a non-bitmapped portfolio.
            accountContext.storeAssetsAndUpdateContext(
                liquidateAccount,
                portfolio,
                true // is liquidation
            );

            for (uint256 i; i < markets.length; i++) {
                // Will short circuit if market does not need to be set
                markets[i].setMarketStorage();
            }
        }
        accountContext.setAccountContext(liquidateAccount);

        collateralBalanceState.netAssetTransferInternalPrecision = tmpAssetTransferAmount;
    }
}",5039
RealWorld_TA_23_AggregatorInterface_RealWorld_20240803091714.log,23,AggregatorInterface,29566,1608,31174,361.0,0.17999,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

interface AggregatorInterface {
  function latestAnswer() external view returns (int256);
  function latestTimestamp() external view returns (uint256);
  function latestRound() external view returns (uint256);
  function getAnswer(uint256 roundId) external view returns (int256);
  function getTimestamp(uint256 roundId) external view returns (uint256);

  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);
  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);
}",129
RealWorld_TA_23_MockExchange_RealWorld_20240803020311.log,23,MockExchange,43204,3739,46943,120.0,0.2908,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

// Mock decentralized exchange for testing liquidations
contract MockExchange {
    uint256 public exchangeRate;

    function setExchangeRate(uint256 exchangeRate_) external {
        exchangeRate = exchangeRate_;
    }

    function exchange(
        address assetIn,
        address assetOut,
        uint256 amountIn
    ) external {
        uint256 amountOut = (amountIn * exchangeRate) / 1e18;
        if (IERC20(assetIn).balanceOf(msg.sender) < amountIn) {
            revert(""Insufficient balance of assetIn"");
        }

        IERC20(assetIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(assetOut).transfer(msg.sender, amountOut);
    }

    function exchangeOut(
        address assetIn,
        address assetOut,
        uint256 amountOut
    ) external {
        uint256 amountIn = (amountOut * 1e18) / exchangeRate;
        if (IERC20(assetIn).balanceOf(msg.sender) < amountIn) {
            revert(""Insufficient balance of assetIn"");
        }

        IERC20(assetIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(assetOut).transfer(msg.sender, amountOut);
    }
}",305
RealWorld_TA_23_cTokenAggregator_RealWorld_20240803061123.log,23,cTokenAggregator,66386,2333,68719,370.0,0.37859,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;

import ""interfaces/notional/AssetRateAdapter.sol"";
import ""interfaces/compound/CTokenInterface.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

// TODO: is this necessary?
contract cTokenAggregator is AssetRateAdapter {
    using SafeMath for uint256;

    address public immutable override token;
    uint8 public override decimals = 18;
    uint256 public override version = 1;
    string public override description;
    uint256 public constant BLOCKS_PER_YEAR = 2102400;
    // Notional rate precision = 1e9
    // Compound rate precision = 1e18
    uint256 public constant SCALE_RATE = 1e9;

    constructor(address _cToken) {
        token = _cToken;
        description = ERC20(_cToken).symbol();
    }

    function underlying() external view override returns (address) {
        return CTokenInterface(token).underlying();
    }

    /** @notice Returns the current exchange rate for the cToken to the underlying */
    function getExchangeRateStateful() external override returns (int256) {
        uint256 exchangeRate = CTokenInterface(token).exchangeRateCurrent();
        require(exchangeRate <= uint256(type(int256).max), ""cTokenAdapter: overflow"");

        return int256(exchangeRate);
    }

    function getExchangeRateView() external view override returns (int256) {
        uint256 exchangeRate = CTokenInterface(token).exchangeRateStored();
        require(exchangeRate <= uint256(type(int256).max), ""cTokenAdapter: overflow"");

        return int256(exchangeRate);
    }

    function getAnnualizedSupplyRate() external view override returns (uint256) {
        uint256 supplyRatePerBlock = CTokenInterface(token).supplyRatePerBlock();

        // Although the Compound documentation recommends doing a per day compounding of the supply
        // rate to get the annualized rate (https://compound.finance/docs#protocol-math), we just do a
        // simple linear approximation of the rate here. Since Compound rates are variable per block
        // any rate we calculate here will be an approximation and so this is the simplest implementation
        // that gets a pretty good answer. Supply rates are only used when valuing idiosyncratic fCash assets
        // that are shorter dated than the 3 month fCash market.

        // Supply rate per block * blocks per year * notional rate precision / supply rate precision
        return supplyRatePerBlock.mul(BLOCKS_PER_YEAR).div(SCALE_RATE);
    }
}",570
RealWorld_TA_23_AssetRate_RealWorld_20240803034252.log,23,AssetRate,187879,3181,191060,368.0,1.003015,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../../math/SafeInt256.sol"";
import ""interfaces/notional/AssetRateAdapter.sol"";

library AssetRate {
    using SafeInt256 for int256;
    event SetSettlementRate(uint256 currencyId, uint256 maturity, uint128 rate);

    uint256 private constant ASSET_RATE_STORAGE_SLOT = 2;
    // Asset rates are in 1e18 decimals (cToken exchange rates), internal balances
    // are in 1e8 decimals. Therefore we leave this as 1e18 / 1e8 = 1e10
    int256 private constant ASSET_RATE_DECIMAL_DIFFERENCE = 1e10;

    /// @notice Converts an internal asset cash value to its underlying token value.
    /// @param ar exchange rate object between asset and underlying
    /// @param assetBalance amount to convert to underlying
    function convertToUnderlying(AssetRateParameters memory ar, int256 assetBalance)
        internal
        pure
        returns (int256)
    {
        if (assetBalance == 0) return 0;

        // Calculation here represents:
        // rateDecimals * balance * internalPrecision / rateDecimals * underlyingPrecision
        int256 underlyingBalance =
            ar.rate.mul(assetBalance).div(ASSET_RATE_DECIMAL_DIFFERENCE).div(ar.underlyingDecimals);

        return underlyingBalance;
    }

    /// @notice Converts an internal underlying cash value to its asset cash value
    /// @param ar exchange rate object between asset and underlying
    /// @param underlyingBalance amount to convert to asset cash, denominated in internal token precision
    function convertFromUnderlying(AssetRateParameters memory ar, int256 underlyingBalance)
        internal
        pure
        returns (int256)
    {
        if (underlyingBalance == 0) return 0;

        // Calculation here represents:
        // rateDecimals * balance * underlyingPrecision / rateDecimals * internalPrecision
        int256 assetBalance =
            underlyingBalance.mul(ASSET_RATE_DECIMAL_DIFFERENCE).mul(ar.underlyingDecimals).div(
                ar.rate
            );

        return assetBalance;
    }

    /// @notice Returns the current per block supply rate, is used when calculating oracle rates
    /// for idiosyncratic fCash with a shorter duration than the 3 month maturity.
    function getSupplyRate(AssetRateParameters memory ar) internal view returns (uint256) {
        // If the rate oracle is not set, the asset is not interest bearing and has an oracle rate of zero.
        if (ar.rateOracle == address(0)) return 0;

        uint256 rate = AssetRateAdapter(ar.rateOracle).getAnnualizedSupplyRate();
        require(rate >= 0); // dev: invalid supply rate

        return rate;
    }

    function _getAssetRateStorage(uint256 currencyId)
        private
        view
        returns (address rateOracle, uint8 underlyingDecimalPlaces)
    {
        bytes32 slot = keccak256(abi.encode(currencyId, ASSET_RATE_STORAGE_SLOT));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        rateOracle = address(bytes20(data << 96));
        underlyingDecimalPlaces = uint8(uint256(data >> 160));
    }

    /// @notice Gets an asset rate using a view function, does not accrue interest so the
    /// exchange rate will not be up to date. Should only be used for non-stateful methods
    function _getAssetRateView(uint256 currencyId)
        private
        view
        returns (
            int256,
            address,
            uint8
        )
    {
        (address rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);

        int256 rate;
        if (rateOracle == address(0)) {
            // If no rate oracle is set, then set this to the identity
            rate = ASSET_RATE_DECIMAL_DIFFERENCE;
            underlyingDecimalPlaces = 0;
        } else {
            rate = AssetRateAdapter(rateOracle).getExchangeRateView();
            require(rate > 0); // dev: invalid exchange rate
        }

        return (rate, rateOracle, underlyingDecimalPlaces);
    }

    /// @notice Gets an asset rate using a stateful function, accrues interest so the
    /// exchange rate will be up to date for the current block.
    function _getAssetRateStateful(uint256 currencyId)
        private
        returns (
            int256,
            address,
            uint8
        )
    {
        (address rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);

        int256 rate;
        if (rateOracle == address(0)) {
            // If no rate oracle is set, then set this to the identity
            rate = ASSET_RATE_DECIMAL_DIFFERENCE;
            underlyingDecimalPlaces = 0;
        } else {
            rate = AssetRateAdapter(rateOracle).getExchangeRateStateful();
            require(rate > 0); // dev: invalid exchange rate
        }

        return (rate, rateOracle, underlyingDecimalPlaces);
    }

    /// @notice Returns an asset rate object using the view method
    function buildAssetRateView(uint256 currencyId)
        internal
        view
        returns (AssetRateParameters memory)
    {
        (int256 rate, address rateOracle, uint8 underlyingDecimalPlaces) =
            _getAssetRateView(currencyId);

        return
            AssetRateParameters({
                rateOracle: rateOracle,
                rate: rate,
                underlyingDecimals: int256(10**underlyingDecimalPlaces)
            });
    }

    /// @notice Returns an asset rate object using the stateful method
    function buildAssetRateStateful(uint256 currencyId)
        internal
        returns (AssetRateParameters memory)
    {
        (int256 rate, address rateOracle, uint8 underlyingDecimalPlaces) =
            _getAssetRateStateful(currencyId);

        return
            AssetRateParameters({
                rateOracle: rateOracle,
                rate: rate,
                underlyingDecimals: int256(10**underlyingDecimalPlaces)
            });
    }

    /// @dev Gets a settlement rate object
    function _getSettlementRateStorage(uint256 currencyId, uint256 maturity)
        private
        view
        returns (
            int256 settlementRate,
            uint8 underlyingDecimalPlaces,
            bytes32 slot
        )
    {
        bytes32 data;
        slot = keccak256(
            abi.encode(
                currencyId,
                keccak256(abi.encode(maturity, Constants.SETTLEMENT_RATE_STORAGE_OFFSET))
            )
        );

        assembly {
            data := sload(slot)
        }

        settlementRate = int256(uint128(uint256(data >> 40)));
        underlyingDecimalPlaces = uint8(uint256(data >> 168));
    }

    /// @notice Returns a settlement rate object using the view method
    function buildSettlementRateView(uint256 currencyId, uint256 maturity)
        internal
        view
        returns (AssetRateParameters memory)
    {
        // prettier-ignore
        (
            int256 settlementRate,
            uint8 underlyingDecimalPlaces,
            /* bytes32 slot */
        ) = _getSettlementRateStorage(currencyId, maturity);

        if (settlementRate == 0) {
            // If settlement rate has not been set then we need to fetch it
            // prettier-ignore
            (
                settlementRate,
                /* address */,
                underlyingDecimalPlaces
            ) = _getAssetRateView(currencyId);
        }

        return AssetRateParameters(address(0), settlementRate, int256(10**underlyingDecimalPlaces));
    }

    /// @notice Returns a settlement rate object and sets the rate if it has not been set yet
    function buildSettlementRateStateful(
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime
    ) internal returns (AssetRateParameters memory) {
        (int256 settlementRate, uint8 underlyingDecimalPlaces, bytes32 slot) =
            _getSettlementRateStorage(currencyId, maturity);

        if (settlementRate == 0) {
            // Settlement rate has not yet been set, set it in this branch
            address rateOracle;
            // prettier-ignore
            (
                settlementRate,
                rateOracle,
                underlyingDecimalPlaces
            ) = _getAssetRateStateful(currencyId);

            if (rateOracle != address(0)) {
                // Only need to set settlement rates when the rate oracle is set (meaning the asset token has
                // a conversion rate to an underlying). If not set then the asset cash always settles to underlying at a 1-1
                // rate since they are the same.
                require(blockTime != 0 && blockTime <= type(uint40).max); // dev: settlement rate timestamp overflow
                require(settlementRate > 0 && settlementRate <= type(uint128).max); // dev: settlement rate overflow
                uint128 storedRate = uint128(uint256(settlementRate));

                bytes32 data =
                    (bytes32(blockTime) |
                        (bytes32(uint256(storedRate)) << 40) |
                        (bytes32(uint256(underlyingDecimalPlaces)) << 168));

                assembly {
                    sstore(slot, data)
                }

                emit SetSettlementRate(currencyId, maturity, storedRate);
            }
        }

        return AssetRateParameters(address(0), settlementRate, int256(10**underlyingDecimalPlaces));
    }
}",2019
RealWorld_TA_23_MockTokenHandler_RealWorld_20240803023602.log,23,MockTokenHandler,49437,3821,53258,120.0,0.323605,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/balances/TokenHandler.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockTokenHandler is StorageLayoutV1 {
    using TokenHandler for Token;

    function setMaxCurrencyId(uint16 num) external {
        maxCurrencyId = num;
    }

    function setCurrencyMapping(
        uint256 id,
        bool underlying,
        TokenStorage calldata ts
    ) external {
        return TokenHandler.setToken(id, underlying, ts);
    }

    /// @dev This method does not update internal balances...must use currency handler.

    function transfer(
        uint256 currencyId,
        address account,
        bool underlying,
        int256 netTransfer
    ) external returns (int256) {
        Token memory token = TokenHandler.getToken(currencyId, underlying);
        return token.transfer(account, netTransfer);
    }

    function mint(uint256 currencyId, uint256 underlyingAmount) external returns (int256) {
        Token memory token = TokenHandler.getToken(currencyId, false);
        return token.mint(underlyingAmount);
    }

    function redeem(uint256 currencyId, uint256 tokensInternalPrecision) external returns (int256) {
        Token memory token = TokenHandler.getToken(currencyId, false);
        Token memory underlyingToken = TokenHandler.getToken(currencyId, true);
        return token.redeem(underlyingToken, tokensInternalPrecision);
    }

    function getToken(uint256 currencyId, bool underlying) external view returns (Token memory) {
        return TokenHandler.getToken(currencyId, underlying);
    }
}",344
RealWorld_TA_23_PauseRouter_RealWorld_20240803052150.log,23,PauseRouter,102968,2917,105885,370.0,0.57318,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../global/StorageLayoutV1.sol"";
import ""../global/Constants.sol"";
import ""../proxy/utils/UUPSUpgradeable.sol"";
import ""interfaces/notional/NotionalProxy.sol"";

/**
 * Read only version of the Router that can only be upgraded by governance. Used in emergency when the system must
 * be paused for some reason.
 */
contract PauseRouter is StorageLayoutV1, UUPSUpgradeable {
    address public immutable VIEWS;
    address public immutable LIQUIDATE_CURRENCY;
    address public immutable LIQUIDATE_FCASH;

    constructor(
        address views_,
        address liquidateCurrency_,
        address liquidatefCash_
    ) {
        VIEWS = views_;
        LIQUIDATE_CURRENCY = liquidateCurrency_;
        LIQUIDATE_FCASH = liquidatefCash_;
    }

    function _authorizeUpgrade(address newImplementation) internal override {
        // This is only true during a rollback check when the pause router is downgraded
        bool isRollbackCheck = rollbackRouterImplementation != address(0) &&
            newImplementation == rollbackRouterImplementation;

        require(
            owner == msg.sender || (msg.sender == pauseGuardian && isRollbackCheck),
            ""Unauthorized upgrade""
        );

        // Clear this storage slot so the guardian cannot upgrade back to the previous router,
        // requires governance to do so.
        rollbackRouterImplementation = address(0);
    }

    function getLiquidationEnabledState() external view returns (bytes1) {
        return liquidationEnabledState;
    }

    function setLiquidationEnabledState(bytes1 liquidationEnabledState_) external {
        // Only authorized addresses can set the liquidation state
        require(owner == msg.sender || msg.sender == pauseGuardian);
        liquidationEnabledState = liquidationEnabledState_;
    }

    function isEnabled(bytes1 state) private view returns (bool) {
        return (liquidationEnabledState & state == state);
    }

    function getRouterImplementation(bytes4 sig) public view returns (address) {
        // Liquidation calculation methods are stateful (they settle accounts if required)
        // and therefore we prevent them from being called unless specifically authorized.
        if (
            (sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector ||
                sig == NotionalProxy.liquidateCollateralCurrency.selector) &&
            isEnabled(Constants.COLLATERAL_CURRENCY_ENABLED)
        ) {
            return LIQUIDATE_CURRENCY;
        }

        if (
            (sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||
                sig == NotionalProxy.liquidateLocalCurrency.selector) &&
            isEnabled(Constants.LOCAL_CURRENCY_ENABLED)
        ) {
            return LIQUIDATE_CURRENCY;
        }

        if (
            (sig == NotionalProxy.liquidatefCashLocal.selector ||
                sig == NotionalProxy.calculatefCashLocalLiquidation.selector) &&
            isEnabled(Constants.LOCAL_FCASH_ENABLED)
        ) {
            return LIQUIDATE_FCASH;
        }

        if (
            (sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||
                sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector) &&
            isEnabled(Constants.CROSS_CURRENCY_FCASH_ENABLED)
        ) {
            return LIQUIDATE_FCASH;
        }

        // If not found then delegate to views. This will revert if there is no method on
        // the view contract
        return VIEWS;
    }

    /// @dev Delegates the current call to `implementation`.
    /// This function does not return to its internal call site, it will return directly to the external caller.
    function _delegate(address implementation) private {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    fallback() external payable {
        _delegate(getRouterImplementation(msg.sig));
    }
}",995
RealWorld_TA_23_OpenZeppelinImports_RealWorld_20240803022049.log,23,OpenZeppelinImports,29266,2492,31758,109.0,0.19617,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

// Bring these open zeppelin contracts into the build for brownie
import ""@openzeppelin/contracts/proxy/ProxyAdmin.sol"";
import ""@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol"";

contract nProxyAdmin is ProxyAdmin { }
contract nTransparentUpgradeableProxy is TransparentUpgradeableProxy {
    constructor(
        address _logic,
        address admin_,
        bytes memory _data
    ) TransparentUpgradeableProxy(_logic, admin_, _data) {}

    receive() external payable override {}
}",135
RealWorld_TA_23_BitmapAssetsHandler_RealWorld_20240803042621.log,23,BitmapAssetsHandler,212541,5035,217576,371.0,1.163405,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../AccountContextHandler.sol"";
import ""../markets/CashGroup.sol"";
import ""../valuation/AssetHandler.sol"";
import ""../../math/Bitmap.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/Constants.sol"";
import ""../../global/Types.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library BitmapAssetsHandler {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using Bitmap for bytes32;
    using CashGroup for CashGroupParameters;

    function _getAssetsBitmapSlot(address account, uint256 currencyId)
        private
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    account,
                    keccak256(abi.encode(currencyId, Constants.ASSETS_BITMAP_STORAGE_OFFSET))
                )
            );
    }

    function getAssetsBitmap(address account, uint256 currencyId) internal view returns (bytes32) {
        bytes32 slot = _getAssetsBitmapSlot(account, currencyId);
        bytes32 data;
        assembly {
            data := sload(slot)
        }
        return data;
    }

    function setAssetsBitmap(
        address account,
        uint256 currencyId,
        bytes32 assetsBitmap
    ) internal {
        bytes32 slot = _getAssetsBitmapSlot(account, currencyId);
        require(assetsBitmap.totalBitsSet() <= Constants.MAX_BITMAP_ASSETS, ""Over max assets"");

        assembly {
            sstore(slot, assetsBitmap)
        }
    }

    function getifCashSlot(
        address account,
        uint256 currencyId,
        uint256 maturity
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    maturity,
                    keccak256(
                        abi.encode(
                            currencyId,
                            keccak256(abi.encode(account, Constants.IFCASH_STORAGE_OFFSET))
                        )
                    )
                )
            );
    }

    function getifCashNotional(
        address account,
        uint256 currencyId,
        uint256 maturity
    ) internal view returns (int256 notional) {
        bytes32 fCashSlot = getifCashSlot(account, currencyId, maturity);
        assembly {
            notional := sload(fCashSlot)
        }
    }

    /// @notice Adds multiple assets to a bitmap portfolio
    function addMultipleifCashAssets(
        address account,
        AccountContext memory accountContext,
        PortfolioAsset[] memory assets
    ) internal {
        uint256 currencyId = accountContext.bitmapCurrencyId;
        require(currencyId != 0); // dev: invalid account in set ifcash assets
        bytes32 ifCashBitmap = getAssetsBitmap(account, currencyId);

        for (uint256 i; i < assets.length; i++) {
            if (assets[i].notional == 0) continue;
            require(assets[i].currencyId == currencyId); // dev: invalid asset in set ifcash assets
            require(assets[i].assetType == Constants.FCASH_ASSET_TYPE); // dev: invalid asset in set ifcash assets
            int256 finalNotional;

            (ifCashBitmap, finalNotional) = addifCashAsset(
                account,
                currencyId,
                assets[i].maturity,
                accountContext.nextSettleTime,
                assets[i].notional,
                ifCashBitmap
            );

            if (finalNotional < 0)
                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;
        }

        setAssetsBitmap(account, currencyId, ifCashBitmap);
    }

    /// @notice Add an ifCash asset in the bitmap and mapping. Updates the bitmap in memory
    /// but not in storage.
    function addifCashAsset(
        address account,
        uint256 currencyId,
        uint256 maturity,
        uint256 nextSettleTime,
        int256 notional,
        bytes32 assetsBitmap
    ) internal returns (bytes32, int256) {
        bytes32 fCashSlot = getifCashSlot(account, currencyId, maturity);
        (uint256 bitNum, bool isExact) = DateTime.getBitNumFromMaturity(nextSettleTime, maturity);
        require(isExact); // dev: invalid maturity in set ifcash asset

        if (assetsBitmap.isBitSet(bitNum)) {
            // Bit is set so we read and update the notional amount
            int256 existingNotional;
            assembly {
                existingNotional := sload(fCashSlot)
            }
            existingNotional = existingNotional.add(notional);

            require(existingNotional >= type(int128).min && existingNotional <= type(int128).max); // dev: bitmap notional overflow
            assembly {
                sstore(fCashSlot, existingNotional)
            }

            // If the new notional is zero then turn off the bit
            if (existingNotional == 0) {
                assetsBitmap = assetsBitmap.setBit(bitNum, false);
            }

            return (assetsBitmap, existingNotional);
        }

        if (notional != 0) {
            // Bit is not set so we turn it on and update the mapping directly, no read required.
            require(notional >= type(int128).min && notional <= type(int128).max); // dev: bitmap notional overflow
            assembly {
                sstore(fCashSlot, notional)
            }
            assetsBitmap = assetsBitmap.setBit(bitNum, true);
        }

        return (assetsBitmap, notional);
    }

    /// @notice Returns the present value of an asset
    function getPresentValue(
        address account,
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime,
        CashGroupParameters memory cashGroup,
        bool riskAdjusted
    ) internal view returns (int256) {
        int256 notional = getifCashNotional(account, currencyId, maturity);

        // In this case the asset has matured and the total value is just the notional amount
        if (maturity <= blockTime) return notional;

        uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);
        if (riskAdjusted) {
            return
                AssetHandler.getRiskAdjustedPresentValue(
                    cashGroup,
                    notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
        }

        return AssetHandler.getPresentValue(notional, maturity, blockTime, oracleRate);
    }

    /// @notice Get the net present value of all the ifCash assets
    function getifCashNetPresentValue(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime,
        uint256 blockTime,
        bytes32 assetsBitmap,
        CashGroupParameters memory cashGroup,
        bool riskAdjusted
    ) internal view returns (int256, bool) {
        int256 totalValueUnderlying;
        bool hasDebt;

        uint256 bitNum = assetsBitmap.getNextBitNum();
        while (bitNum != 0) {
            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);
            int256 pv =
                getPresentValue(
                    account,
                    currencyId,
                    maturity,
                    blockTime,
                    cashGroup,
                    riskAdjusted
                );
            totalValueUnderlying = totalValueUnderlying.add(pv);

            if (pv < 0) hasDebt = true;

            // Turn off the bit and look for the next one
            assetsBitmap = assetsBitmap.setBit(bitNum, false);
            bitNum = assetsBitmap.getNextBitNum();
        }

        return (totalValueUnderlying, hasDebt);
    }

    /// @notice Returns the ifCash assets as an array
    function getifCashArray(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime
    ) internal view returns (PortfolioAsset[] memory) {
        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);
        uint256 index = assetsBitmap.totalBitsSet();
        PortfolioAsset[] memory assets = new PortfolioAsset[](index);
        index = 0;

        uint256 bitNum = assetsBitmap.getNextBitNum();
        while (bitNum != 0) {
            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);
            int256 notional = getifCashNotional(account, currencyId, maturity);

            assets[index].currencyId = currencyId;
            assets[index].maturity = maturity;
            assets[index].assetType = Constants.FCASH_ASSET_TYPE;
            assets[index].notional = notional;
            index += 1;

            // Turn off the bit and look for the next one
            assetsBitmap = assetsBitmap.setBit(bitNum, false);
            bitNum = assetsBitmap.getNextBitNum();
        }

        return assets;
    }

    /// @notice Used to reduce an nToken ifCash assets portfolio proportionately when redeeming
    /// nTokens to its underlying assets.
    function reduceifCashAssetsProportional(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime,
        int256 tokensToRedeem,
        int256 totalSupply
    ) internal returns (PortfolioAsset[] memory) {
        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);
        uint256 index = assetsBitmap.totalBitsSet();
        PortfolioAsset[] memory assets = new PortfolioAsset[](index);
        index = 0;

        uint256 bitNum = assetsBitmap.getNextBitNum();
        while (bitNum != 0) {
            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);
            bytes32 fCashSlot = getifCashSlot(account, currencyId, maturity);
            int256 notional;
            assembly {
                notional := sload(fCashSlot)
            }

            int256 notionalToTransfer = notional.mul(tokensToRedeem).div(totalSupply);
            notional = notional.sub(notionalToTransfer);
            assembly {
                sstore(fCashSlot, notional)
            }

            assets[index].currencyId = currencyId;
            assets[index].maturity = maturity;
            assets[index].assetType = Constants.FCASH_ASSET_TYPE;
            assets[index].notional = notionalToTransfer;
            index += 1;

            // Turn off the bit and look for the next one
            assetsBitmap = assetsBitmap.setBit(bitNum, false);
            bitNum = assetsBitmap.getNextBitNum();
        }

        // If the entire token supply is redeemed then the assets bitmap will have been reduced to zero.
        // Because solidity truncates division there will always be dust left unless the entire supply is
        // redeemed.
        if (tokensToRedeem == totalSupply) {
            setAssetsBitmap(account, currencyId, 0x00);
        }

        return assets;
    }
}",2281
RealWorld_TA_23_AggregatorV3Interface_RealWorld_20240803091101.log,23,AggregatorV3Interface,35723,1622,37345,371.0,0.211055,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

interface AggregatorV3Interface {

  function decimals() external view returns (uint8);
  function description() external view returns (string memory);
  function version() external view returns (uint256);

  // getRoundData and latestRoundData should both raise ""No data present""
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

}",200
RealWorld_TA_23_MockBitmap_RealWorld_20240803021416.log,23,MockBitmap,35357,1379,36736,85.0,0.204365,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../math/Bitmap.sol"";

contract MockBitmap {
    using Bitmap for bytes32;

    function isBitSet(bytes32 bitmap, uint256 index) public pure returns (bool) {
        return bitmap.isBitSet(index);
    }

    function setBit(
        bytes32 bitmap,
        uint256 index,
        bool setOn
    ) public pure returns (bytes32) {
        return bitmap.setBit(index, setOn);
    }

    function totalBitsSet(bytes32 bitmap) public pure returns (uint256) {
        return bitmap.totalBitsSet();
    }

    function getMSB(uint256 x) external pure returns (uint256) {
        return Bitmap.getMSB(x);
    }

    function getNextBitNum(bytes32 x) external pure returns (uint256) {
        return Bitmap.getNextBitNum(x);
    }
}",200
RealWorld_TA_23_AssetHandler_RealWorld_20240803044455.log,23,AssetHandler,225586,4354,229940,358.0,1.21501,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../markets/CashGroup.sol"";
import ""../markets/AssetRate.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/ABDKMath64x64.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library AssetHandler {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;

    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {
        return
            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&
            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;
    }

    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method
    /// calculates the settlement date for any PortfolioAsset.
    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {
        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type
        // 3 month tokens and fCash tokens settle at maturity
        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;

        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);
        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:
        // maturity = tRef + marketLength
        // Here we calculate:
        // tRef = maturity - marketLength + 90 days
        return asset.maturity.sub(marketLength).add(Constants.QUARTER);
    }

    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.
    /// The formula is: notional * e^(-rate * timeToMaturity).
    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)
        internal
        pure
        returns (int256)
    {
        int128 expValue =
            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));
        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);
        expValue = ABDKMath64x64.exp(expValue * -1);
        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);
        int256 discountFactor = ABDKMath64x64.toInt(expValue);

        return discountFactor;
    }

    /// @notice Present value of an fCash asset without any risk adjustments.
    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mulInRatePrecision(discountFactor);
    }

    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more
    /// heavily than the oracle rate given and vice versa for negative fCash.
    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mulInRatePrecision(discountFactor);
    }

    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.
    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)
        internal
        pure
        returns (int256 assetCash, int256 fCash)
    {
        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims

        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);
        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);
    }

    /// @notice Returns the haircut claims on cash and fCash
    /// @return (assetCash, fCash)
    function getHaircutCashClaims(
        PortfolioAsset memory token,
        MarketParameters memory market,
        CashGroupParameters memory cashGroup
    ) internal pure returns (int256, int256) {
        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims

        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch
        // This won't overflow, the liquidity token haircut is stored as an uint8
        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));

        int256 assetCash =
            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);

        int256 fCash =
            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);

        return (assetCash, fCash);
    }

    /// @dev This is here to clean up the stack in getHaircutCashClaims
    function _calcToken(
        int256 numerator,
        int256 tokens,
        int256 haircut,
        int256 liquidity
    ) private pure returns (int256) {
        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);
    }

    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)
    function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            // Liquidity tokens can never be idiosyncratic
            require(!idiosyncratic); // dev: idiosyncratic liquidity token

            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and
        // in that case we know the previous asset will be the matching fCash asset
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            // Net off the fCashClaim here and we will discount it to present value in the second pass.
            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        // If not matching fCash asset found then get the pv directly
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }

    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)
    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        // First calculate value of liquidity tokens because we need to net off fCash value
        // before discounting to present value
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true // risk adjusted
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            // If we hit a different currency id then we've accounted for all assets in this currency
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
}",2500
RealWorld_TA_23_MockMarket_RealWorld_20240803021149.log,23,MockMarket,134768,3852,138620,145.0,0.75088,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/markets/CashGroup.sol"";
import ""../internal/markets/AssetRate.sol"";
import ""../internal/markets/Market.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockMarket is StorageLayoutV1 {
    using CashGroup for CashGroupParameters;
    using Market for MarketParameters;
    using AssetRate for AssetRateParameters;
    using SafeInt256 for int256;

    function getUint64(uint256 value) public pure returns (int128) {
        return ABDKMath64x64.fromUInt(value);
    }

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setCashGroup(uint256 id, CashGroupSettings calldata cg) external {
        CashGroup.setCashGroupStorage(id, cg);
    }

    function buildCashGroupView(uint256 currencyId)
        public
        view
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupView(currencyId);
    }

    function getExchangeRate(
        int256 totalfCash,
        int256 totalCashUnderlying,
        int256 rateScalar,
        int256 rateAnchor,
        int256 fCashAmount
    ) external pure returns (int256, bool) {
        return
            Market._getExchangeRate(
                totalfCash,
                totalCashUnderlying,
                rateScalar,
                rateAnchor,
                fCashAmount
            );
    }

    function logProportion(int256 proportion) external pure returns (int256, bool) {
        return Market._logProportion(proportion);
    }

    function getImpliedRate(
        int256 totalfCash,
        int256 totalCashUnderlying,
        int256 rateScalar,
        int256 rateAnchor,
        uint256 timeToMaturity
    ) external pure returns (uint256) {
        return
            Market.getImpliedRate(
                totalfCash,
                totalCashUnderlying,
                rateScalar,
                rateAnchor,
                timeToMaturity
            );
    }

    function getRateAnchor(
        int256 totalfCash,
        uint256 lastImpliedRate,
        int256 totalCashUnderlying,
        int256 rateScalar,
        uint256 timeToMaturity
    ) external pure returns (int256, bool) {
        return
            Market._getRateAnchor(
                totalfCash,
                lastImpliedRate,
                totalCashUnderlying,
                rateScalar,
                timeToMaturity
            );
    }

    function calculateTrade(
        MarketParameters memory marketState,
        CashGroupParameters memory cashGroup,
        int256 fCashAmount,
        uint256 timeToMaturity,
        uint256 marketIndex
    )
        external
        view
        returns (
            MarketParameters memory,
            int256,
            int256
        )
    {
        (int256 assetCash, int256 fee) =
            marketState.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);

        return (marketState, assetCash, fee);
    }

    function addLiquidity(MarketParameters memory marketState, int256 assetCash)
        public
        pure
        returns (
            MarketParameters memory,
            int256,
            int256
        )
    {
        (int256 liquidityTokens, int256 fCash) = marketState.addLiquidity(assetCash);
        assert(liquidityTokens >= 0);
        assert(fCash <= 0);
        return (marketState, liquidityTokens, fCash);
    }

    function removeLiquidity(MarketParameters memory marketState, int256 tokensToRemove)
        public
        pure
        returns (
            MarketParameters memory,
            int256,
            int256
        )
    {
        (int256 assetCash, int256 fCash) = marketState.removeLiquidity(tokensToRemove);

        assert(assetCash >= 0);
        assert(fCash >= 0);
        return (marketState, assetCash, fCash);
    }

    function setMarketStorage(
        uint256 currencyId,
        uint256 settlementDate,
        MarketParameters memory market
    ) public {
        market.storageSlot = Market.getSlot(currencyId, market.maturity, settlementDate);
        // ensure that state gets set
        market.storageState = 0xFF;
        market.setMarketStorage();
    }

    function setMarketStorageSimulate(MarketParameters memory market) public {
        // This is to simulate a real market storage
        market.setMarketStorage();
    }

    function getMarketStorageOracleRate(bytes32 slot) public view returns (uint256) {
        bytes32 data;

        assembly {
            data := sload(slot)
        }
        return uint256(uint32(uint256(data >> 192)));
    }

    function buildMarket(
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime,
        bool needsLiquidity,
        uint256 rateOracleTimeWindow
    ) public view returns (MarketParameters memory) {
        MarketParameters memory market;
        market.loadMarket(currencyId, maturity, blockTime, needsLiquidity, rateOracleTimeWindow);
        return market;
    }

    function getSettlementMarket(
        uint256 currencyId,
        uint256 maturity,
        uint256 settlementDate
    ) public view returns (SettlementMarket memory) {
        return Market.getSettlementMarket(currencyId, maturity, settlementDate);
    }

    function setSettlementMarket(SettlementMarket memory market) public {
        return Market.setSettlementMarket(market);
    }

    function getfCashAmountGivenCashAmount(
        MarketParameters memory market,
        CashGroupParameters memory cashGroup,
        int256 netCashToAccount,
        uint256 marketIndex,
        uint256 timeToMaturity,
        uint256 maxfCashDelta
    ) external pure returns (int256) {
        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =
            Market.getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);
        // Rate scalar can never be zero so this signifies a failure and we return zero
        if (rateScalar == 0) revert();
        int256 fee = Market.getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);

        return
            Market.getfCashGivenCashAmount(
                market.totalfCash,
                netCashToAccount,
                totalCashUnderlying,
                rateScalar,
                rateAnchor,
                fee,
                maxfCashDelta
            );
    }
}",1390
RealWorld_TA_23_nTokenERC20Proxy_RealWorld_20240803055909.log,23,nTokenERC20Proxy,122872,2628,125500,361.0,0.66692,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/notional/nTokenERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @notice ERC20 proxy for nToken contracts that forwards calls to the Router, all nToken
/// balances and allowances are stored in at single address for gas efficiency. This contract
/// is used simply for ERC20 compliance.
contract nTokenERC20Proxy is IERC20 {
    /// @notice Will be ""nToken {Underlying Token}.name()""
    string public name;

    /// @notice Will be ""n{Underlying Token}.symbol()""
    string public symbol;

    /// @notice Inherits from Constants.INTERNAL_TOKEN_DECIMALS
    uint8 public constant decimals = 8;

    /// @notice Address of the notional proxy
    nTokenERC20 public immutable proxy;

    /// @notice Currency id that this nToken refers to
    uint16 public immutable currencyId;

    constructor(
        nTokenERC20 proxy_,
        uint16 currencyId_,
        string memory underlyingName_,
        string memory underlyingSymbol_
    ) {
        proxy = proxy_;
        currencyId = currencyId_;
        name = string(abi.encodePacked(""nToken "", underlyingName_));
        symbol = string(abi.encodePacked(""n"", underlyingSymbol_));
    }

    /// @notice Total number of tokens in circulation
    function totalSupply() external view override returns (uint256) {
        // Total supply is looked up via the token address
        return proxy.nTokenTotalSupply(address(this));
    }

    /// @notice Get the number of tokens held by the `account`
    /// @param account The address of the account to get the balance of
    /// @return The number of tokens held
    function balanceOf(address account) external view override returns (uint256) {
        return proxy.nTokenBalanceOf(currencyId, account);
    }

    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
    /// @param account The address of the account holding the funds
    /// @param spender The address of the account spending the funds
    /// @return The number of tokens approved
    function allowance(address account, address spender) external view override returns (uint256) {
        return proxy.nTokenTransferAllowance(currencyId, account, spender);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    ///  emit:Approval
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        // Emit approvals here so that they come from the correct contract address
        emit Approval(msg.sender, spender, amount);
        return proxy.nTokenTransferApprove(currencyId, msg.sender, spender, amount);
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @dev emit:Transfer
    /// @param to The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address to, uint256 amount) external override returns (bool) {
        // Emit transfer events here so they come from the correct contract
        emit Transfer(msg.sender, to, amount);
        return proxy.nTokenTransfer(currencyId, msg.sender, to, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @dev emit:Transfer emit:Approval
    /// @param from The address of the source account
    /// @param to The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        (bool success, uint256 newAllowance) =
            proxy.nTokenTransferFrom(currencyId, msg.sender, from, to, amount);

        // Emit transfer events here so they come from the correct contract
        emit Transfer(from, to, amount);
        emit Approval(msg.sender, from, newAllowance);

        return success;
    }

    /// @notice Returns the present value of the nToken's assets denominated in asset tokens
    function getPresentValueAssetDenominated() external view returns (int256) {
        return proxy.nTokenPresentValueAssetDenominated(currencyId);
    }

    /// @notice Returns the present value of the nToken's assets denominated in underlying
    function getPresentValueUnderlyingDenominated() external view returns (int256) {
        return proxy.nTokenPresentValueUnderlyingDenominated(currencyId);
    }

    /// @dev nTokens should never accept any erc1155 transfers of fCash
    function onERC1155Received(
        address, /* _operator */
        address, /* _from */
        uint256, /* _id */
        uint256, /* _value */
        bytes calldata /* _data */
    ) external pure returns (bytes4) {
        return 0;
    }

    /// @dev nTokens should never accept any erc1155 transfers of fCash
    function onERC1155BatchReceived(
        address, /* _operator */
        address, /* _from */
        uint256[] calldata, /* _ids */
        uint256[] calldata, /* _values */
        bytes calldata /* _data */
    ) external pure returns (bytes4) {
        return 0;
    }
}",1259
RealWorld_TA_23_MockPortfolioHandler_RealWorld_20240803022858.log,23,MockPortfolioHandler,54910,3171,58081,114.0,0.33797,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/AccountContextHandler.sol"";
import ""../internal/portfolio/PortfolioHandler.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockPortfolioHandler is StorageLayoutV1 {
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;

    function getAssetArray(address account) external view returns (PortfolioAsset[] memory) {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);
    }

    function addAsset(
        PortfolioState memory portfolioState,
        uint256 currencyId,
        uint256 maturity,
        uint256 assetType,
        int256 notional
    ) public pure returns (PortfolioState memory) {
        portfolioState.addAsset(currencyId, maturity, assetType, notional);

        return portfolioState;
    }

    function getAccountContext(address account) external view returns (AccountContext memory) {
        return AccountContextHandler.getAccountContext(account);
    }

    function storeAssets(address account, PortfolioState memory portfolioState)
        public
        returns (AccountContext memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);
        accountContext.setAccountContext(account);

        return accountContext;
    }

    function deleteAsset(PortfolioState memory portfolioState, uint256 index)
        public
        pure
        returns (PortfolioState memory)
    {
        portfolioState.deleteAsset(index);

        return portfolioState;
    }

    function buildPortfolioState(address account, uint256 newAssetsHint)
        public
        view
        returns (PortfolioState memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);

        return
            PortfolioHandler.buildPortfolioState(
                account,
                accountContext.assetArrayLength,
                newAssetsHint
            );
    }
}",416
RealWorld_TA_23_SettleBitmapAssets_RealWorld_20240803031432.log,23,SettleBitmapAssets,108685,3462,112147,211.0,0.612665,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../markets/AssetRate.sol"";
import ""../portfolio/BitmapAssetsHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/Bitmap.sol"";
import ""../../global/Constants.sol"";
import ""../../global/Types.sol"";

/**
 * Settles a bitmap portfolio by checking for all matured fCash assets and turning them into cash
 * at the prevailing settlement rate. It will also update the asset bitmap to ensure that it continues
 * to correctly reference all actual maturities. fCash asset notional values are stored in *absolute* 
 * time terms and bitmap bits are *relative* time terms based on the bitNumber and the stored oldSettleTime.
 * Remapping bits requires converting the old relative bit numbers to new relative bit numbers based on
 * newSettleTime and the absolute times (maturities) that the previous bitmap references.
 */
library SettleBitmapAssets {
    using SafeInt256 for int256;
    using AssetRate for AssetRateParameters;
    using Bitmap for bytes32;

    /// @notice Given a bitmap for a cash group and timestamps, will settle all assets
    /// that have matured and remap the bitmap to correspond to the current time.
    function settleBitmappedCashGroup(
        address account,
        uint256 currencyId,
        uint256 oldSettleTime,
        uint256 blockTime
    ) internal returns (bytes32, int256, uint256) {
        bytes32 bitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);
        int256 totalAssetCash;

        // This newSettleTime will be set to the new `oldSettleTime`. The bits between 1 and
        // `lastSettleBit` (inclusive) will be shifted out of the bitmap and settled. The reason
        // that lastSettleBit is inclusive is that it refers to newSettleTime which always less
        // than the current block time.
        uint256 newSettleTime = DateTime.getTimeUTC0(blockTime);
        require(newSettleTime >= oldSettleTime); // dev: new settle time before previous

        // Do not need to worry about validity, if newSettleTime is not on an exact bit we will settle up until
        // the closest maturity that is less than newSettleTime.
        (uint256 lastSettleBit, /* isValid */) = DateTime.getBitNumFromMaturity(oldSettleTime, newSettleTime);
        if (lastSettleBit == 0) return (bitmap, totalAssetCash, newSettleTime);

        // Returns the next bit that is set in the bitmap using a binary search for the MSB.
        uint256 nextBitNum = bitmap.getNextBitNum();
        while (nextBitNum != 0 && nextBitNum <= lastSettleBit) {
            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);
            totalAssetCash = totalAssetCash.add(
                _settlefCashAsset(account, currencyId, maturity, blockTime)
            );
            // Turn the bit off now that it is settled
            bitmap = bitmap.setBit(nextBitNum, false);

            // Continue the loop
            nextBitNum = bitmap.getNextBitNum();
        }

        bytes32 newBitmap;
        while (nextBitNum != 0) {
            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);
            (uint256 newBitNum, bool isValid) = DateTime.getBitNumFromMaturity(newSettleTime, maturity);
            require(isValid); // dev: invalid new bit num

            newBitmap = newBitmap.setBit(newBitNum, true);
            // Turn the bit off now that it is remapped
            bitmap = bitmap.setBit(nextBitNum, false);

            // Continue the loop
            nextBitNum = bitmap.getNextBitNum();
        }

        return (newBitmap, totalAssetCash, newSettleTime);
    }

    /// @dev Stateful settlement function to settle a bitmapped asset. Deletes the
    /// asset from storage after calculating it.
    function _settlefCashAsset(
        address account,
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime
    ) private returns (int256 assetCash) {
        // Storage Read
        bytes32 ifCashSlot = BitmapAssetsHandler.getifCashSlot(account, currencyId, maturity);
        int256 ifCash;
        assembly {
            ifCash := sload(ifCashSlot)
        }

        // Gets the current settlement rate or will store a new settlement rate if it does not
        // yet exist.
        AssetRateParameters memory rate =
            AssetRate.buildSettlementRateStateful(currencyId, maturity, blockTime);
        assetCash = rate.convertFromUnderlying(ifCash);
        // Delete ifCash value
        assembly {
            sstore(ifCashSlot, 0)
        }

        return assetCash;
    }
}",1055
RealWorld_TA_23_MockExchangeRate_RealWorld_20240803025252.log,23,MockExchangeRate,64479,3494,67973,120.0,0.392275,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/valuation/ExchangeRate.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockExchangeRate is StorageLayoutV1 {
    using SafeInt256 for int256;
    using ExchangeRate for ETHRate;

    function setETHRateMapping(uint256 id, ETHRateStorage calldata rs) external {
        underlyingToETHRateMapping[id] = rs;
    }

    function assertBalanceSign(int256 balance, int256 result) private pure {
        if (balance == 0) assert(result == 0);
        else if (balance < 0) assert(result < 0);
        else if (balance > 0) assert(result > 0);
    }

    // Prove that exchange rates move in the correct direction
    function assertRateDirection(
        int256 base,
        int256 quote,
        ETHRate memory er
    ) private pure {
        require(er.rate > 0);
        if (base == 0) return;

        if (er.rate == er.rateDecimals) {
            assert(quote.abs() == base.abs());
        } else if (er.rate < er.rateDecimals) {
            assert(quote.abs() < base.abs());
        } else if (er.rate > er.rateDecimals) {
            assert(quote.abs() > base.abs());
        }
    }

    function convertToETH(ETHRate memory er, int256 balance) external pure returns (int256) {
        require(er.rate > 0);
        int256 result = er.convertToETH(balance);
        assertBalanceSign(balance, result);

        return result;
    }

    function convertETHTo(ETHRate memory er, int256 balance) external pure returns (int256) {
        require(er.rate > 0);
        int256 result = er.convertETHTo(balance);
        assertBalanceSign(balance, result);
        assertRateDirection(result, balance, er);

        return result;
    }

    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)
        external
        pure
        returns (int256)
    {
        require(baseER.rate > 0);
        require(quoteER.rate > 0);

        int256 result = baseER.exchangeRate(quoteER);
        assert(result > 0);

        return result;
    }

    function buildExchangeRate(uint256 currencyId) external view returns (ETHRate memory) {
        return ExchangeRate.buildExchangeRate(currencyId);
    }
}",532
RealWorld_TA_23_NotionalCallback_RealWorld_20240803082741.log,23,NotionalCallback,22180,1303,23483,364.0,0.13696,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

interface NotionalCallback {
    function notionalCallback(address sender, address account, bytes calldata callbackdata) external;
}",46
RealWorld_TA_23_GovernorAlpha_RealWorld_20240803073205.log,23,GovernorAlpha,420205,5692,425897,365.0,2.214865,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/notional/INoteERC20.sol"";
import ""@openzeppelin/contracts/access/TimelockController.sol"";
import ""@openzeppelin/contracts/cryptography/ECDSA.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

/**
 * @title Notional Governor Alpha
 * Fork of Compound Governor Alpha at commit hash
 * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96
 */
contract GovernorAlpha is TimelockController {
    /// @notice The name of this contract
    string public constant name = ""Notional Governor Alpha"";

    /// @notice The address of the Notional governance token
    INoteERC20 public immutable note;

    /// @notice The maximum number of actions that can be included in a proposal
    uint8 public constant PROPOSAL_MAX_OPERATIONS = 10;

    /// @notice The minimum voting period in blocks, about 1 day assuming 13 second blocks. Ensures that proposals will always have
    /// time to be voted on.
    uint32 public constant MIN_VOTING_PERIOD_BLOCKS = 6700;

    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a proposal to succeed
    uint96 public quorumVotes;

    /// @notice The number of votes required in order for a voter to become a proposer
    uint96 public proposalThreshold;

    /// @notice The delay before voting on a proposal may take place, once proposed
    uint32 public votingDelayBlocks;

    /// @notice The duration of voting on a proposal, in blocks
    uint32 public votingPeriodBlocks;

    /// @notice The address of the Governor Guardian
    address public guardian;

    /// @notice The total number of proposals
    uint256 public proposalCount;

    struct Proposal {
        // Unique id for looking up a proposal
        uint256 id;
        // The timestamp at which voting begins: holders must delegate their votes prior to this block
        uint32 startBlock;
        // The timestamp at which voting ends: votes must be cast prior to this block
        uint32 endBlock;
        // Current number of votes in favor of this proposal
        uint96 forVotes;
        // Current number of votes in opposition to this proposal
        uint96 againstVotes;
        // Creator of the proposal
        address proposer;
        // Flag marking whether the proposal has been canceled
        bool canceled;
        // Flag marking whether the proposal has been executed
        bool executed;
        // Hash of the operation to reduce storage cost
        bytes32 operationHash;
    }

    // Ballot receipt record for a voter
    struct Receipt {
        // Whether or not a vote has been cast
        bool hasVoted;
        // Whether or not the voter supports the proposal
        bool support;
        // The number of votes the voter had, which were cast
        uint96 votes;
    }

    // Possible states that a proposal may be in
    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}

    /// @notice The official record of all proposals ever proposed
    mapping(uint256 => Proposal) public proposals;

    /// @notice Receipts of ballots for the entire set of voters
    mapping(uint256 => mapping(address => Receipt)) public receipts;

    /// @notice The latest proposal for each proposer
    mapping(address => uint256) public latestProposalIds;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract
    bytes32 public constant BALLOT_TYPEHASH = keccak256(""Ballot(uint256 proposalId,bool support)"");

    /// @notice An event emitted when a new proposal is created
    event ProposalCreated(
        uint256 indexed id,
        address indexed proposer,
        address[] targets,
        uint256[] values,
        bytes[] calldatas,
        uint256 startBlock,
        uint256 endBlock
    );

    /// @notice An event emitted when a vote has been cast on a proposal
    event VoteCast(address indexed voter, uint256 indexed proposalId, bool support, uint256 votes);

    /// @notice An event emitted when a proposal has been canceled
    event ProposalCanceled(uint256 indexed id);

    /// @notice An event emitted when a proposal has been queued in the Timelock
    event ProposalQueued(uint256 indexed id, uint256 eta);

    /// @notice An event emitted when a proposal has been executed in the Timelock
    event ProposalExecuted(uint256 indexed id);

    /// @notice An event emitted when amount of quorum votes required is updated
    event UpdateQuorumVotes(uint96 newQuorumVotes);

    /// @notice An event emitted when a new proposal threshold has been set
    event UpdateProposalThreshold(uint96 newProposalThreshold);

    /// @notice An event emitted when a new voting delay in blocks has been set
    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);

    /// @notice An event emitted when a new voting period in blocks has been set
    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);

    /// @notice Emitted when the guardian abdicates their role
    event Abdicate();

    /// @notice An event emitted when guardian is transferred
    event TransferGuardian(address newGuardian);
    
    /// @notice Initializes the GovernorAlpha with initial parameters
    /// @param quorumVotes_ initial quorum votes value
    /// @param proposalThreshold_ initial proposal threshold value
    /// @param votingDelayBlocks_ initial voting delay blocks value
    /// @param votingPeriodBlocks_ initial voting period blocks value
    /// @param note_ address of the NOTE token to get voting power
    /// @param guardian_ address of guardian
    /// @param minDelay_ initial minimum delay for timelock in seconds
    constructor(
        uint96 quorumVotes_,
        uint96 proposalThreshold_,
        uint32 votingDelayBlocks_,
        uint32 votingPeriodBlocks_,
        address note_,
        address guardian_,
        uint256 minDelay_
    ) TimelockController(minDelay_, new address[](0), new address[](0)) {
        require(Address.isContract(note_));

        quorumVotes = quorumVotes_;
        proposalThreshold = proposalThreshold_;
        votingDelayBlocks = votingDelayBlocks_;
        // Do not enforce MIN_VOTING_DELAY during constructor so that tests don't require a large number
        // of blocks for the voting period. During actual mainnet deployment this will be set to a reasonable value.
        votingPeriodBlocks = votingPeriodBlocks_;
        note = INoteERC20(note_);
        guardian = guardian_;

        // Only the external methods can be used to execute governance
        grantRole(PROPOSER_ROLE, address(this));
        grantRole(EXECUTOR_ROLE, address(this));
        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);
    }

    /// @notice Proposes a new governance action
    /// @param targets an array of addresses to take actions on
    /// @param values an array of ether amounts to send to respective target address
    /// @param calldatas an array of calldata bytes to call respective target address with
    /// @dev emit:ProposalCreated
    /// @return newly created proposal id
    function propose(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas
    ) external returns (uint256) {
        uint256 blockNumber = block.number;
        require(blockNumber > 0 && blockNumber < type(uint32).max);

        require(
            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,
            ""GovernorAlpha::propose: proposer votes below proposal threshold""
        );
        require(
            targets.length == values.length && targets.length == calldatas.length,
            ""GovernorAlpha::propose: proposal function information arity mismatch""
        );
        require(targets.length != 0, ""GovernorAlpha::propose: must provide actions"");
        require(
            targets.length <= PROPOSAL_MAX_OPERATIONS,
            ""GovernorAlpha::propose: too many actions""
        );

        {
            uint256 latestProposalId = latestProposalIds[msg.sender];
            if (latestProposalId != 0) {
                ProposalState proposersLatestProposalState = state(latestProposalId);
                require(
                    proposersLatestProposalState != ProposalState.Active,
                    ""GovernorAlpha::propose: one live proposal per proposer, found an already active proposal""
                );
                require(
                    proposersLatestProposalState != ProposalState.Pending,
                    ""GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal""
                );
            }
        }

        uint256 newProposalId = proposalCount + 1;
        proposalCount = newProposalId;

        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);
        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);
        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);

        Proposal memory newProposal =
            Proposal({
                id: newProposalId,
                proposer: msg.sender,
                startBlock: startBlock,
                endBlock: endBlock,
                forVotes: 0,
                againstVotes: 0,
                canceled: false,
                executed: false,
                operationHash: operationHash
            });

        proposals[newProposal.id] = newProposal;
        latestProposalIds[newProposal.proposer] = newProposal.id;

        emit ProposalCreated(
            newProposal.id,
            msg.sender,
            targets,
            values,
            calldatas,
            startBlock,
            endBlock
        );
        return newProposal.id;
    }

    /// @dev Helper method required to clear the stack for hashing operations
    function _computeHash(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas,
        uint256 proposalId
    ) private pure returns (bytes32) {
        return hashOperationBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));
    }

    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,
    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals
    /// will automatically be delayed `getMinDelay()` seconds.
    /// @param proposalId unique identifier for the proposal
    /// @param targets an array of addresses to take actions on
    /// @param values an array of ether amounts to send to respective target address
    /// @param calldatas an array of calldata bytes to call respective target address with
    /// @dev emit:ProposalQueued emit:CallScheduled (per call)
    function queueProposal(
        uint256 proposalId,
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas
    ) external {
        require(state(proposalId) == ProposalState.Succeeded, ""Proposal must be success"");
        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);
        {
            Proposal storage proposal = proposals[proposalId];
            require(computedOperationHash == proposal.operationHash, ""Operation hash mismatch"");
        }

        _scheduleBatch(targets, values, calldatas, proposalId);

        emit ProposalQueued(proposalId, getMinDelay());
    }

    /// @dev Required to clear the stack for calling the timelock controller
    function _scheduleBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas,
        uint256 proposalId
    ) private {
        // NOTE: this will also emit events
        this.scheduleBatch(
            targets,
            values,
            calldatas,
            bytes32(0),
            bytes32(proposalId),
            getMinDelay()
        );
    }

    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,
    /// `values`, and `calldatas` provided must hash back to the original proposal.
    /// @param proposalId unique identifier for the proposal
    /// @param targets an array of addresses to take actions on
    /// @param values an array of ether amounts to send to respective target address
    /// @param calldatas an array of calldata bytes to call respective target address with
    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)
    function executeProposal(
        uint256 proposalId,
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas
    ) external payable {
        Proposal storage proposal = proposals[proposalId];
        proposal.executed = true;

        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);
        require(computedOperationHash == proposal.operationHash, ""Operation hash mismatch"");
        // Execute batch will revert if the call has not been scheduled
        _executeBatch(targets, values, calldatas, proposalId);

        emit ProposalExecuted(proposalId);
    }

    /// @dev Helper function to clear the stack for the timelock controller call
    function _executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas,
        uint256 proposalId
    ) private {
        this.executeBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));
    }

    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer
    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or
    /// by a guardian address if it exists.
    /// @param proposalId unique identifier for the proposal
    /// @dev emit:ProposalCanceled emit:Canceled
    function cancelProposal(uint256 proposalId) public {
        ProposalState proposalState = state(proposalId);
        require(proposalState != ProposalState.Executed, ""Proposal already executed"");

        Proposal storage proposal = proposals[proposalId];
        uint256 blockNumber = block.number;
        require(blockNumber > 0 && blockNumber <= type(uint32).max);
        require(
            msg.sender == guardian ||
                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,
            ""GovernorAlpha::cancel: proposer above threshold""
        );

        proposal.canceled = true;
        // Removes the operation hash from the timelock controller if pending.
        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);

        emit ProposalCanceled(proposalId);
    }

    /// @notice Returns the voting receipt for a voter on a proposal
    /// @param proposalId unique identifier for the proposal
    /// @param voter address of the voter
    /// @return the voting receipt for the voter and proposal
    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {
        return receipts[proposalId][voter];
    }

    /// @notice Returns the current state of a proposal
    /// @param proposalId unique identifier for the proposal
    /// @return ProposalState enum for the current state of the proposal
    function state(uint256 proposalId) public view returns (ProposalState) {
        require(
            proposalCount >= proposalId && proposalId > 0,
            ""GovernorAlpha::state: invalid proposal id""
        );
        Proposal memory proposal = proposals[proposalId];
        uint256 blockNumber = block.number;
        require(blockNumber > 0 && blockNumber <= type(uint32).max);

        if (proposal.canceled) {
            return ProposalState.Canceled;
        } else if (blockNumber <= proposal.startBlock) {
            return ProposalState.Pending;
        } else if (blockNumber <= proposal.endBlock) {
            return ProposalState.Active;
        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {
            return ProposalState.Defeated;
        } else if (proposal.executed) {
            return ProposalState.Executed;
        } else if (isOperationPending(proposal.operationHash)) {
            return ProposalState.Queued;
        } else if (
            proposal.forVotes > proposal.againstVotes &&
            proposal.forVotes > quorumVotes &&
            blockNumber > proposal.endBlock
        ) {
            return ProposalState.Succeeded;
        }
    }

    /// @notice Cast a vote for a proposal
    /// @param proposalId unique identifier for the proposal
    /// @param support true if votes are for the proposal, false if against
    /// @dev emit:VoteCast
    function castVote(uint256 proposalId, bool support) public {
        return _castVote(msg.sender, proposalId, support);
    }

    /// @notice Cast a vote for a proposal via signature
    /// @param proposalId unique identifier for the proposal
    /// @param support true if votes are for the proposal, false if against
    /// @param v signature component
    /// @param r signature component
    /// @param s signature component
    /// @dev emit:VoteCast
    function castVoteBySig(
        uint256 proposalId,
        bool support,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator =
            keccak256(
                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))
            );
        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));
        bytes32 digest = keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        // ECDSA.recover will check if address is zero
        address signatory = ECDSA.recover(digest, v, r, s);
        return _castVote(signatory, proposalId, support);
    }

    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter
    function _castVote(
        address voter,
        uint256 proposalId,
        bool support
    ) internal {
        require(
            state(proposalId) == ProposalState.Active,
            ""GovernorAlpha::_castVote: voting is closed""
        );
        Proposal storage proposal = proposals[proposalId];
        Receipt storage receipt = receipts[proposalId][voter];
        require(receipt.hasVoted == false, ""GovernorAlpha::_castVote: voter already voted"");
        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);
        // Short circuit if voter has no votes
        if (votes == 0) return;

        if (support) {
            proposal.forVotes = _add96(proposal.forVotes, votes);
        } else {
            proposal.againstVotes = _add96(proposal.againstVotes, votes);
        }

        receipt.hasVoted = true;
        receipt.support = support;
        receipt.votes = votes;

        emit VoteCast(voter, proposalId, support, votes);
    }

    /// @notice Updates the quorum votes required, can only be executed via a proposal
    /// @param newQuorumVotes new quorum votes required
    /// @dev emit:UpdateQuorumVotes
    function updateQuorumVotes(uint96 newQuorumVotes) external {
        require(msg.sender == address(this), ""Unauthorized caller"");
        quorumVotes = newQuorumVotes;
        emit UpdateQuorumVotes(newQuorumVotes);
    }

    /// @notice Updates the proposal threshold required, can only be executed via a proposal
    /// @param newProposalThreshold new proposal threshold
    /// @dev emit:UpdateProposalThreshold
    function updateProposalThreshold(uint96 newProposalThreshold) external {
        require(msg.sender == address(this), ""Unauthorized caller"");
        proposalThreshold = newProposalThreshold;
        emit UpdateProposalThreshold(newProposalThreshold);
    }

    /// @notice Updates the voting delay blocks required, can only be executed via a proposal
    /// @param newVotingDelayBlocks new voting delay blocks
    /// @dev emit:UpdateVotingDelayBlocks
    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {
        require(msg.sender == address(this), ""Unauthorized caller"");
        votingDelayBlocks = newVotingDelayBlocks;
        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);
    }

    /// @notice Updates the voting period blocks required, can only be executed via a proposal
    /// @param newVotingPeriodBlocks new voting period blocks
    /// @dev emit:UpdateVotingPeriodBlocks
    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {
        require(msg.sender == address(this), ""Unauthorized caller"");
        require(newVotingPeriodBlocks >= MIN_VOTING_PERIOD_BLOCKS, ""Below min voting period"");
        votingPeriodBlocks = newVotingPeriodBlocks;
        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);
    }

    /// @dev Hidden public method
    function __abdicate() external {
        require(msg.sender == guardian, ""GovernorAlpha::__abdicate: sender must be gov guardian"");
        guardian = address(0);
        emit Abdicate();
    }

    /// @notice Transfers guardian role to a new guardian
    /// @param newGuardian address to transfer role to
    function __transferGuardian(address newGuardian) external {
        require(
            msg.sender == guardian,
            ""GovernorAlpha::__transferGuardian: sender must be gov guardian""
        );
        require(newGuardian != address(0), ""Cannot transfer to zero address"");

        guardian = newGuardian;
        emit TransferGuardian(newGuardian);
    }

    /// @dev Overflow check for adding votes
    function _add96(uint96 a, uint96 b) private pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, ""addition overflow"");
        return c;
    }

    /// @dev Overflow check for adding block numbers
    function _add32(uint32 a, uint32 b) private pure returns (uint32) {
        uint32 c = a + b;
        require(c >= a, ""addition overflow"");
        return c;
    }

    /// @dev Helper method for signature check
    function _getChainId() private pure returns (uint256) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}",4839
RealWorld_TA_23_nTokenERC20_RealWorld_20240803085833.log,23,nTokenERC20,45821,2250,48071,375.0,0.274105,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

interface nTokenERC20 {
    event Transfer(address indexed from, address indexed to, uint256 amount);

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function nTokenTotalSupply(address nTokenAddress) external view returns (uint256);

    function nTokenTransferAllowance(
        uint16 currencyId,
        address owner,
        address spender
    ) external view returns (uint256);

    function nTokenBalanceOf(uint16 currencyId, address account) external view returns (uint256);

    function nTokenTransferApprove(
        uint16 currencyId,
        address owner,
        address spender,
        uint256 amount
    ) external returns (bool);

    function nTokenTransfer(
        uint16 currencyId,
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    function nTokenTransferFrom(
        uint16 currencyId,
        address spender,
        address from,
        address to,
        uint256 amount
    ) external returns (bool, uint256);

    function nTokenTransferApproveAll(address spender, uint256 amount) external returns (bool);

    function nTokenClaimIncentives() external returns (uint256);

    function nTokenPresentValueAssetDenominated(uint16 currencyId) external view returns (int256);

    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)
        external
        view
        returns (int256);
}",325
RealWorld_TA_23_SafeInt256_RealWorld_20240803050313.log,23,SafeInt256,78538,2829,81367,377.0,0.44927,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

import ""../global/Constants.sol"";

library SafeInt256 {
    int256 private constant _INT256_MIN = -2**255;

    /// @dev Returns the multiplication of two signed integers, reverting on
    /// overflow.

    /// Counterpart to Solidity's `*` operator.

    /// Requirements:

    /// - Multiplication cannot overflow.

    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        require(!(a == -1 && b == _INT256_MIN)); // dev: int256 mul overflow

        int256 c = a * b;
        require(c / a == b); // dev: int256 mul overflow

        return c;
    }

    /// @dev Returns the integer division of two signed integers. Reverts on
    /// division by zero. The result is rounded towards zero.

    /// Counterpart to Solidity's `/` operator. Note: this function uses a
    /// `revert` opcode (which leaves remaining gas untouched) while Solidity
    /// uses an invalid opcode to revert (consuming all remaining gas).

    /// Requirements:

    /// - The divisor cannot be zero.

    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0); // dev: int256 div by zero
        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow

        int256 c = a / b;

        return c;
    }

    function sub(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x - y) <= x == (y >= 0));
    }

    function add(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x + y) >= x == (y >= 0));
    }

    function neg(int256 x) internal pure returns (int256) {
        return mul(x, -1);
    }

    function abs(int256 x) internal pure returns (int256) {
        if (x < 0) return neg(x);
        else return x;
    }

    function subNoNeg(int256 x, int256 y) internal pure returns (int256) {
        int256 z = sub(x, y);
        require(z >= 0); // dev: int256 sub to negative

        return z;
    }

    /// @dev Calculates x * RATE_PRECISION / y while checking overflows
    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {
        return div(mul(x, Constants.RATE_PRECISION), y);
    }

    /// @dev Calculates x * y / RATE_PRECISION while checking overflows
    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {
        return div(mul(x, y), Constants.RATE_PRECISION);
    }
}",709
RealWorld_TA_23_nTokenHandler_RealWorld_20240803030859.log,23,nTokenHandler,395687,4980,400667,180.0,2.078035,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./markets/CashGroup.sol"";
import ""./markets/AssetRate.sol"";
import ""./valuation/AssetHandler.sol"";
import ""./portfolio/BitmapAssetsHandler.sol"";
import ""./portfolio/PortfolioHandler.sol"";
import ""./balances/BalanceHandler.sol"";
import ""../math/SafeInt256.sol"";

library nTokenHandler {
    using AssetRate for AssetRateParameters;
    using SafeInt256 for int256;

    /// @dev Stores (uint32)
    bytes32 private constant INCENTIVE_RATE_MASK =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFF;
    /// @dev Stores (uint8, uint32)
    bytes32 private constant ARRAY_TIME_MASK =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000FFFFFFFFFFFF;
    /// @dev Stores (uint8, uint8, uint8, uint8, uint8)
    bytes32 private constant COLLATERAL_MASK =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000FFFFFFFFFFFFFFFFFFFFFF;

    /// @notice Returns an account context object that is specific to nTokens.
    function getNTokenContext(address tokenAddress)
        internal
        view
        returns (
            uint256 currencyId,
            uint256 incentiveAnnualEmissionRate,
            uint256 lastInitializedTime,
            bytes6 parameters
        )
    {
        bytes32 slot = keccak256(abi.encode(tokenAddress, Constants.NTOKEN_CONTEXT_STORAGE_OFFSET));
        bytes32 data;
        assembly {
            data := sload(slot)
        }

        currencyId = uint256(uint16(uint256(data)));
        incentiveAnnualEmissionRate = uint256(uint32(uint256(data >> 16)));
        lastInitializedTime = uint256(uint32(uint256(data >> 48)));
        parameters = bytes6(data << 128);
    }

    /// @notice Returns the nToken token address for a given currency
    function nTokenAddress(uint256 currencyId) internal view returns (address tokenAddress) {
        bytes32 slot = keccak256(abi.encode(currencyId, Constants.NTOKEN_ADDRESS_STORAGE_OFFSET));
        assembly {
            tokenAddress := sload(slot)
        }
    }

    /// @notice Called by governance to set the nToken token address and its reverse lookup. Cannot be
    /// reset once this is set.
    function setNTokenAddress(uint16 currencyId, address tokenAddress) internal {
        bytes32 addressSlot =
            keccak256(abi.encode(currencyId, Constants.NTOKEN_ADDRESS_STORAGE_OFFSET));
        bytes32 currencySlot =
            keccak256(abi.encode(tokenAddress, Constants.NTOKEN_CONTEXT_STORAGE_OFFSET));

        uint256 data;
        assembly {
            data := sload(addressSlot)
        }
        require(data == 0, ""PT: token address exists"");
        assembly {
            data := sload(currencySlot)
        }
        require(data == 0, ""PT: currency exists"");

        assembly {
            sstore(addressSlot, tokenAddress)
        }

        // This will initialize all the other token context values to zer
        assembly {
            sstore(currencySlot, currencyId)
        }
    }

    /// @notice Set nToken token collateral parameters
    function setNTokenCollateralParameters(
        address tokenAddress,
        uint8 residualPurchaseIncentive10BPS,
        uint8 pvHaircutPercentage,
        uint8 residualPurchaseTimeBufferHours,
        uint8 cashWithholdingBuffer10BPS,
        uint8 liquidationHaircutPercentage
    ) internal {
        bytes32 slot = keccak256(abi.encode(tokenAddress, Constants.NTOKEN_CONTEXT_STORAGE_OFFSET));
        bytes32 data;
        assembly {
            data := sload(slot)
        }

        require(liquidationHaircutPercentage <= Constants.PERCENTAGE_DECIMALS, ""Invalid haircut"");
        // The pv haircut percentage must be less than the liquidation percentage or else liquidators will not
        // get profit for liquidating nToken.
        require(pvHaircutPercentage < liquidationHaircutPercentage, ""Invalid pv haircut"");
        // Ensure that the cash withholding buffer is greater than the residual purchase incentive or
        // the nToken may not have enough cash to pay accounts to buy its negative ifCash
        require(residualPurchaseIncentive10BPS <= cashWithholdingBuffer10BPS, ""Invalid discounts"");

        // Clear the bytes where collateral parameters will go and OR the data in
        data = data & COLLATERAL_MASK;
        bytes32 parameters =
            (bytes32(uint256(residualPurchaseIncentive10BPS)) |
                (bytes32(uint256(pvHaircutPercentage)) << 8) |
                (bytes32(uint256(residualPurchaseTimeBufferHours)) << 16) |
                (bytes32(uint256(cashWithholdingBuffer10BPS)) << 24) |
                (bytes32(uint256(liquidationHaircutPercentage)) << 32));
        data = data | (bytes32(parameters) << 88);
        assembly {
            sstore(slot, data)
        }
    }

    /// @notice Retrieves the nToken supply factors without any updates or calculations
    function getStoredNTokenSupplyFactors(address tokenAddress)
        internal
        view
        returns (
            uint256 totalSupply,
            uint256 integralTotalSupply,
            uint256 lastSupplyChangeTime
        )
    {
        bytes32 slot = keccak256(abi.encode(tokenAddress, Constants.NTOKEN_TOTAL_SUPPLY_OFFSET));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        totalSupply = uint256(uint96(uint256(data)));
        // NOTE: DO NOT USE THIS RETURNED VALUE FOR CALCULATING INCENTIVES. The integral total supply
        // must be updated given the block time. Use `calculateIntegralTotalSupply` instead
        integralTotalSupply = uint256(uint128(uint256(data >> 96)));
        lastSupplyChangeTime = uint256(data >> 224);
    }

    /// @notice Retrieves stored total supply factors and 
    function calculateIntegralTotalSupply(address tokenAddress, uint256 blockTime) 
        internal
        view 
        returns (
            uint256 totalSupply,
            uint256 integralTotalSupply,
            uint256 lastSupplyChangeTime
        )
    {
        (
            totalSupply,
            integralTotalSupply,
            lastSupplyChangeTime
        ) = getStoredNTokenSupplyFactors(tokenAddress);

        // Initialize last supply change time if it has not been set.
        if (lastSupplyChangeTime == 0) lastSupplyChangeTime = blockTime;

        require(blockTime >= lastSupplyChangeTime); // dev: invalid block time

        // Add to the integral total supply the total supply of tokens multiplied by the time that the total supply
        // has been the value. This will part of the numerator for the average total supply calculation during
        // minting incentives.
        integralTotalSupply = uint256(int256(integralTotalSupply).add(
            int256(totalSupply).mul(int256(blockTime - lastSupplyChangeTime))
        ));

        require(integralTotalSupply >= 0 && integralTotalSupply < type(uint128).max); // dev: integral total supply overflow
        require(blockTime < type(uint32).max); // dev: last supply change supply overflow
    }


    /// @notice Updates the nToken token supply amount when minting or redeeming.
    function changeNTokenSupply(
        address tokenAddress,
        int256 netChange,
        uint256 blockTime
    ) internal returns (uint256) {
        (
            uint256 totalSupply,
            uint256 integralTotalSupply,
            /* uint256 lastSupplyChangeTime */
        ) = calculateIntegralTotalSupply(tokenAddress, blockTime);

        if (netChange != 0) {
            bytes32 slot = keccak256(abi.encode(tokenAddress, Constants.NTOKEN_TOTAL_SUPPLY_OFFSET));
            // If the totalSupply will change then we store the new total supply, the integral total supply and the
            // current block time. We know that this int256 conversion will not overflow because totalSupply is stored
            // as a uint96 and checked in the next line.
            int256 newTotalSupply = int256(totalSupply).add(netChange);
            require(newTotalSupply >= 0 && uint256(newTotalSupply) < type(uint96).max); // dev: nToken supply overflow

            bytes32 newData = (
                (bytes32(uint256(newTotalSupply))) |
                (bytes32(integralTotalSupply << 96)) |
                (bytes32(blockTime << 224))
            );

            assembly {
                sstore(slot, newData)
            }
        }

        return integralTotalSupply;
    }

    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate) internal {
        bytes32 slot = keccak256(abi.encode(tokenAddress, Constants.NTOKEN_CONTEXT_STORAGE_OFFSET));

        bytes32 data;
        assembly {
            data := sload(slot)
        }
        // Clear the 4 bytes where emissions rate will go and OR it in
        data = data & INCENTIVE_RATE_MASK;
        data = data | (bytes32(uint256(newEmissionsRate)) << 16);
        assembly {
            sstore(slot, data)
        }
    }

    function setArrayLengthAndInitializedTime(
        address tokenAddress,
        uint8 arrayLength,
        uint256 lastInitializedTime
    ) internal {
        bytes32 slot = keccak256(abi.encode(tokenAddress, Constants.NTOKEN_CONTEXT_STORAGE_OFFSET));
        require(lastInitializedTime >= 0 && uint256(lastInitializedTime) < type(uint32).max); // dev: next settle time overflow

        bytes32 data;
        assembly {
            data := sload(slot)
        }
        // Clear the 6 bytes where array length and settle time will go
        data = data & ARRAY_TIME_MASK;
        data = data | (bytes32(uint256(lastInitializedTime)) << 48);
        data = data | (bytes32(uint256(arrayLength)) << 80);
        assembly {
            sstore(slot, data)
        }
    }

    /// @notice Returns the array of deposit shares and leverage thresholds for nTokens
    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)
        internal
        view
        returns (int256[] memory depositShares, int256[] memory leverageThresholds)
    {
        uint256 slot =
            uint256(keccak256(abi.encode(currencyId, Constants.NTOKEN_DEPOSIT_STORAGE_OFFSET)));
        (depositShares, leverageThresholds) = _getParameters(slot, maxMarketIndex, false);
    }

    /// @notice Sets the deposit parameters
    /// @dev We pack the values in alternating between the two parameters into either one or two
    // storage slots depending on the number of markets. This is to save storage reads when we use the parameters.
    function setDepositParameters(
        uint256 currencyId,
        uint32[] calldata depositShares,
        uint32[] calldata leverageThresholds
    ) internal {
        uint256 slot =
            uint256(keccak256(abi.encode(currencyId, Constants.NTOKEN_DEPOSIT_STORAGE_OFFSET)));
        require(
            depositShares.length <= Constants.MAX_TRADED_MARKET_INDEX,
            ""PT: deposit share length""
        );

        require(depositShares.length == leverageThresholds.length, ""PT: leverage share length"");

        uint256 shareSum;
        for (uint256 i; i < depositShares.length; i++) {
            // This cannot overflow in uint 256 with 9 max slots
            shareSum = shareSum + depositShares[i];
            require(
                leverageThresholds[i] > 0 && leverageThresholds[i] < Constants.RATE_PRECISION,
                ""PT: leverage threshold""
            );
        }

        // Total deposit share must add up to 100%
        require(shareSum == uint256(Constants.DEPOSIT_PERCENT_BASIS), ""PT: deposit shares sum"");
        _setParameters(slot, depositShares, leverageThresholds);
    }

    /// @notice Sets the initialization parameters for the markets, these are read only when markets
    /// are initialized
    function setInitializationParameters(
        uint256 currencyId,
        uint32[] calldata annualizedAnchorRates,
        uint32[] calldata proportions
    ) internal {
        uint256 slot =
            uint256(keccak256(abi.encode(currencyId, Constants.NTOKEN_INIT_STORAGE_OFFSET)));
        require(annualizedAnchorRates.length <= Constants.MAX_TRADED_MARKET_INDEX, ""PT: annualized anchor rates length"");

        require(proportions.length == annualizedAnchorRates.length, ""PT: proportions length"");

        for (uint256 i; i < proportions.length; i++) {
            // Proportions must be between zero and the rate precision
            require(
                proportions[i] > 0 && proportions[i] < Constants.RATE_PRECISION,
                ""PT: invalid proportion""
            );
        }

        _setParameters(slot, annualizedAnchorRates, proportions);
    }

    /// @notice Returns the array of initialization parameters for a given currency.
    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)
        internal
        view
        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)
    {
        uint256 slot =
            uint256(keccak256(abi.encode(currencyId, Constants.NTOKEN_INIT_STORAGE_OFFSET)));
        (annualizedAnchorRates, proportions) = _getParameters(slot, maxMarketIndex, true);
    }

    function _getParameters(
        uint256 slot,
        uint256 maxMarketIndex,
        bool noUnset
    ) private view returns (int256[] memory, int256[] memory) {
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        int256[] memory array1 = new int256[](maxMarketIndex);
        int256[] memory array2 = new int256[](maxMarketIndex);
        for (uint256 i; i < maxMarketIndex; i++) {
            array1[i] = int256(uint32(uint256(data)));
            data = data >> 32;
            array2[i] = int256(uint32(uint256(data)));
            data = data >> 32;

            if (noUnset) {
                require(array1[i] > 0 && array2[i] > 0, ""PT: init value zero"");
            }

            if (i == 3) {
                // Load the second slot which occurs after the 4th market index
                slot = slot + 1;
                assembly {
                    data := sload(slot)
                }
            }
        }

        return (array1, array2);
    }

    function _setParameters(
        uint256 slot,
        uint32[] calldata array1,
        uint32[] calldata array2
    ) private {
        bytes32 data;
        uint256 bitShift;
        uint256 i;
        for (; i < array1.length; i++) {
            // Pack the data into alternating 4 byte slots
            data = data | (bytes32(uint256(array1[i])) << bitShift);
            bitShift += 32;

            data = data | (bytes32(uint256(array2[i])) << bitShift);
            bitShift += 32;

            if (i == 3) {
                // The first 4 (i == 3) pairs of values will fit into 32 bytes of the first storage slot,
                // after this we move one slot over
                assembly {
                    sstore(slot, data)
                }
                slot = slot + 1;
                data = 0x00;
                bitShift = 0;
            }
        }

        // Store the data if i is not exactly 4 which means it was stored completely in the first slot
        // when i == 3
        if (i != 4) {
            assembly {
                sstore(slot, data)
            }
        }
    }

    function loadNTokenPortfolioNoCashGroup(uint256 currencyId, nTokenPortfolio memory nToken)
        internal
        view
    {
        nToken.tokenAddress = nTokenAddress(currencyId);
        // prettier-ignore
        (
            /* currencyId */,
            /* incentiveRate */,
            uint256 lastInitializedTime,
            bytes6 parameters
        ) = getNTokenContext(nToken.tokenAddress);

        // prettier-ignore
        (
            uint256 totalSupply,
            /* integralTotalSupply */,
            /* lastSupplyChangeTime */
        ) = getStoredNTokenSupplyFactors(nToken.tokenAddress);

        nToken.lastInitializedTime = lastInitializedTime;
        nToken.totalSupply = int256(totalSupply);
        nToken.parameters = parameters;

        nToken.portfolioState = PortfolioHandler.buildPortfolioState(
            nToken.tokenAddress,
            uint8(parameters[Constants.ASSET_ARRAY_LENGTH]),
            0
        );

        // prettier-ignore
        (
            nToken.cashBalance,
            /* nTokenBalance */,
            /* lastClaimTime */,
            /* lastClaimIntegralSupply */
        ) = BalanceHandler.getBalanceStorage(nToken.tokenAddress, currencyId);
    }

    /// @notice Uses buildCashGroupStateful
    function loadNTokenPortfolioStateful(uint256 currencyId, nTokenPortfolio memory nToken)
        internal
    {
        loadNTokenPortfolioNoCashGroup(currencyId, nToken);
        nToken.cashGroup = CashGroup.buildCashGroupStateful(currencyId);
    }

    /// @notice Uses buildCashGroupView
    function loadNTokenPortfolioView(uint256 currencyId, nTokenPortfolio memory nToken)
        internal
        view
    {
        loadNTokenPortfolioNoCashGroup(currencyId, nToken);
        nToken.cashGroup = CashGroup.buildCashGroupView(currencyId);
    }

    function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {
        if (nToken.lastInitializedTime == 0) return 0;
        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;
    }

    /// @notice Returns the nToken present value denominated in asset terms.
    function getNTokenAssetPV(nTokenPortfolio memory nToken, uint256 blockTime)
        internal
        view
        returns (int256, bytes32)
    {
        int256 totalAssetPV;
        int256 totalUnderlyingPV;
        bytes32 ifCashBitmap =
            BitmapAssetsHandler.getAssetsBitmap(nToken.tokenAddress, nToken.cashGroup.currencyId);

        {
            uint256 nextSettleTime = getNextSettleTime(nToken);
            // If the first asset maturity has passed (the 3 month), this means that all the LTs must
            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in
            // initialize markets so we calculate the cash value of the portfolio here.
            if (nextSettleTime <= blockTime) {
                // NOTE: this condition should only be present for a very short amount of time, which is the window between
                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.
                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is
                // not strictly correct the different should be quite slight. We do this to ensure that free collateral checks
                // for withdraws and liquidations can still be processed. If this condition persists for a long period of time then
                // the entire protocol will have serious problems as markets will not be tradable.
                blockTime = nextSettleTime - 1;
            }
        }

        // Since we are not doing a risk adjusted valuation here we do not need to net off residual fCash
        // balances in the future before discounting to present. If we did, then the ifCash assets would
        // have to be in the portfolio array first. PV here is denominated in asset cash terms, not in
        // underlying terms.
        {
            MarketParameters memory market;
            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) {
                // NOTE: getLiquidityTokenValue can rewrite fCash values in memory, however, that does not
                // happen in this call because there are no fCash values in the nToken portfolio.
                (int256 assetCashClaim, int256 pv) =
                    AssetHandler.getLiquidityTokenValue(
                        i,
                        nToken.cashGroup,
                        market,
                        nToken.portfolioState.storedAssets,
                        blockTime,
                        false
                    );

                totalAssetPV = totalAssetPV.add(assetCashClaim);
                totalUnderlyingPV = totalUnderlyingPV.add(pv);
            }
        }

        // Then iterate over bitmapped assets and get present value
        // prettier-ignore
        (
            int256 bitmapPv, 
            /* */
        ) = BitmapAssetsHandler.getifCashNetPresentValue(
            nToken.tokenAddress,
            nToken.cashGroup.currencyId,
            nToken.lastInitializedTime,
            blockTime,
            ifCashBitmap,
            nToken.cashGroup,
            false
        );
        totalUnderlyingPV = totalUnderlyingPV.add(bitmapPv);

        // Return the total present value denominated in asset terms
        totalAssetPV = totalAssetPV
            .add(nToken.cashGroup.assetRate.convertFromUnderlying(totalUnderlyingPV))
            .add(nToken.cashBalance);

        return (totalAssetPV, ifCashBitmap);
    }
}",4488
RealWorld_TA_23_NoteERC20_RealWorld_20240803072555.log,23,NoteERC20,358304,5259,363563,367.0,1.8967,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";
import ""@openzeppelin/contracts/cryptography/ECDSA.sol"";
import ""../../proxy/utils/UUPSUpgradeable.sol"";

/// @title Note ERC20 Token
/// Fork of Compound Comp token at commit hash
/// https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96
contract NoteERC20 is Initializable, UUPSUpgradeable {
    /// @notice EIP-20 token name for this token
    string public constant name = ""Notional"";

    /// @notice EIP-20 token symbol for this token
    string public constant symbol = ""NOTE"";

    /// @notice EIP-20 token decimals for this token
    uint8 public constant decimals = 8;

    /// @notice Total number of tokens in circulation (100 million NOTE)
    uint256 public constant totalSupply = 100000000e8;

    /// @notice Notional router address
    NotionalProxy public notionalProxy;

    // Allowance amounts on behalf of others
    mapping(address => mapping(address => uint96)) internal allowances;

    // Official record of token balances for each account
    mapping(address => uint96) internal balances;

    /// @notice A record of each accounts delegate
    mapping(address => address) public delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping(address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    /// @notice A record of states for signing / validating signatures
    mapping(address => uint256) public nonces;

    /// @notice Owner address which can upgrade the tokens implementation
    address public owner;

    /// @notice Emitted when the ownership of the contract is transferred
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    /// @notice The standard EIP-20 transfer event
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /// @notice The standard EIP-20 approval event
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /// @notice Initialize note token with initial grants
    /// @param initialAccounts initial address to grant tokens to
    /// @param initialGrantAmount amount to grant address initially
    function initialize(
        address[] calldata initialAccounts,
        uint96[] calldata initialGrantAmount,
        address owner_
    ) public initializer {
        require(initialGrantAmount.length == initialAccounts.length);

        uint96 totalGrants = 0;
        for (uint256 i = 0; i < initialGrantAmount.length; i++) {
            totalGrants = _add96(totalGrants, initialGrantAmount[i], """");
            require(balances[initialAccounts[i]] == 0, ""Duplicate account"");
            balances[initialAccounts[i]] = initialGrantAmount[i];

            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);
        }

        require(totalGrants == totalSupply);
        owner = owner_;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function activateNotional(NotionalProxy notionalProxy_) external onlyOwner {
        require(address(notionalProxy) == address(0), ""Notional Proxy already initialized"");
        Address.isContract(address(notionalProxy_));
        notionalProxy = notionalProxy_;
    }

    /// @dev Transfers ownership of the contract to a new account (`newOwner`).
    /// Can only be called by the current owner.
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    /// @dev Only the owner may upgrade the contract
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }

    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
    /// @param account The address of the account holding the funds
    /// @param spender The address of the account spending the funds
    /// @return The number of tokens approved
    function allowance(address account, address spender) external view returns (uint256) {
        return allowances[account][spender];
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    ///  emit:Approval
    /// @param spender The address of the account which may transfer tokens
    /// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 rawAmount) external returns (bool) {
        uint96 amount;
        if (rawAmount == uint256(-1)) {
            amount = uint96(-1);
        } else {
            amount = _safe96(rawAmount, ""Note::approve: amount exceeds 96 bits"");
        }

        allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Get the number of tokens held by the `account`
    /// @param account The address of the account to get the balance of
    /// @return The number of tokens held
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @dev emit:Transfer
    /// @param dst The address of the destination account
    /// @param rawAmount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 rawAmount) external returns (bool) {
        uint96 amount = _safe96(rawAmount, ""Note::transfer: amount exceeds 96 bits"");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @dev emit:Transfer emit:Approval
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param rawAmount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(
        address src,
        address dst,
        uint256 rawAmount
    ) external returns (bool) {
        // Short circuit transfer execution and return true. It may be the case that external
        // logic tries to execute a zero transfer but don't emit events here.
        if (rawAmount == 0) {
            // Emit a zero transfer event for ERC20 token compatibility
            emit Transfer(src, dst, 0);
            return true;
        }

        address spender = msg.sender;
        uint96 spenderAllowance = allowances[src][spender];
        uint96 amount = _safe96(rawAmount, ""Note::approve: amount exceeds 96 bits"");

        if (spender != src && spenderAllowance != uint96(-1)) {
            uint96 newAllowance =
                _sub96(
                    spenderAllowance,
                    amount,
                    ""Note::transferFrom: transfer amount exceeds spender allowance""
                );
            allowances[src][spender] = newAllowance;

            emit Approval(src, spender, newAllowance);
        }

        _transferTokens(src, dst, amount);
        return true;
    }

    /// @notice Delegate votes from `msg.sender` to `delegatee`
    /// @param delegatee The address to delegate votes to
    /// @dev emit:DelegatesChanged
    function delegate(address delegatee) public {
        _delegate(msg.sender, delegatee);
    }

    /// @notice Delegates votes from signatory to `delegatee`
    /// @dev emit:DelegatesChanged
    /// @param delegatee The address to delegate votes to
    /// @param nonce The contract state required to match the signature
    /// @param expiry The time at which to expire the signature
    /// @param v The recovery byte of the signature
    /// @param r Half of the ECDSA signature pair
    /// @param s Half of the ECDSA signature pair
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator =
            keccak256(
                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))
            );
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        // ECDSA will check if address is zero inside
        address signatory = ECDSA.recover(digest, v, r, s);
        require(nonce == nonces[signatory]++, ""Note::delegateBySig: invalid nonce"");
        require(block.timestamp <= expiry, ""Note::delegateBySig: signature expired"");
        _delegate(signatory, delegatee);
    }

    /// @notice Gets the current votes balance for `account`
    /// @param account The address to get votes balance
    /// @return The number of current votes for `account`
    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
        return
            _add96(
                currentVotes,
                getUnclaimedVotes(account),
                ""Note::getCurrentVotes: uint96 overflow""
            );
    }

    /// @notice Determine the prior number of votes for an account as of a block number
    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
    /// @param account The address of the account to check
    /// @param blockNumber The block number to get the vote balance at
    /// @return The number of votes the account had as of the given block
    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, ""Note::getPriorVotes: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return _add96(
                checkpoints[account][nCheckpoints - 1].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return
                    _add96(
                        cp.votes,
                        getUnclaimedVotes(account),
                        ""Note::getPriorVotes: uint96 overflow""
                    );
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }

        return
            _add96(
                checkpoints[account][lower].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
    }

    /// @notice Notional counts unclaimed incentives as part of a users' voting power. There is no
    /// need to checkpoint these values because they cannot be transferred or delegated.
    /// @param account the address of the Notional account to check
    /// @return Total number of unclaimed tokens accrued on the Notional account
    function getUnclaimedVotes(address account) public view returns (uint96) {
        // If the notional proxy is not set then there are no unclaimed votes
        if (address(notionalProxy) == address(0)) return 0;

        uint256 votes = notionalProxy.nTokenGetClaimableIncentives(account, block.timestamp);
        require(votes <= type(uint96).max);
        return uint96(votes);
    }

    /// @dev Changes delegates from one address to another
    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    /// @dev Transfers tokens and inherits the delegate from the destination address
    function _transferTokens(
        address src,
        address dst,
        uint96 amount
    ) internal {
        require(src != address(0), ""Note::_transferTokens: cannot transfer from the zero address"");
        require(dst != address(0), ""Note::_transferTokens: cannot transfer to the zero address"");

        balances[src] = _sub96(
            balances[src],
            amount,
            ""Note::_transferTokens: transfer amount exceeds balance""
        );
        balances[dst] = _add96(
            balances[dst],
            amount,
            ""Note::_transferTokens: transfer amount overflows""
        );
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    /// @dev Transfers delegates and writes a checkpoint for `getPriorVotes` to use
    function _moveDelegates(
        address srcRep,
        address dstRep,
        uint96 amount
    ) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint96 srcRepNew =
                    _sub96(srcRepOld, amount, ""Note::_moveVotes: vote amount underflow"");
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint96 dstRepNew =
                    _add96(dstRepOld, amount, ""Note::_moveVotes: vote amount overflows"");
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    /// @dev Writes checkpoints for `getPriorVotes`, this is somewhat inefficient as it uses
    /// 20000 gas per transfer of delegated tokens. The goal is prevent voters from borrowing
    /// a large number of votes for a short period to vote for or against a proposal. It's unclear
    /// if there is a better model than this one here. Using only a single checkpoint means that
    /// a delegate could be the victim of a denial of service attack where an attacker continually
    /// transfers tokens to them to prevent them from voting.
    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber =
            _safe32(block.number, ""Note::_writeCheckpoint: block number exceeds 32 bits"");

        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function _safe32(uint256 n, string memory errorMessage) private pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function _safe96(uint256 n, string memory errorMessage) private pure returns (uint96) {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function _add96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) private pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function _sub96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) private pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function _getChainId() private pure returns (uint256) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}",4036
RealWorld_TA_23_MockAggregator_RealWorld_20240803024515.log,23,MockAggregator,36678,3209,39887,111.0,0.24757,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

contract MockAggregator {
    int256 private _answer;
    uint8 public decimals;

    // AggregatorV1 event
    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);

    constructor(uint8 _decimals) {
        decimals = _decimals;
    }

    function latestRoundData() external view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) {

        return (0, _answer, 0, 0, 0);
    }

    function latestAnswer() external view returns (int256) {
        return _answer;
    }

    function setAnswer(int256 a) external {
        _answer = a;
        emit AnswerUpdated(a, 0, block.timestamp);
    }
}",198
RealWorld_TA_23_NotionalV1ToNotionalV2_RealWorld_20240803060512.log,23,NotionalV1ToNotionalV2,157427,5120,162547,369.0,0.889535,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface WETH9 {
    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface IEscrow {
    function getBalances(address account) external view returns (int256[] memory);
}

interface INotionalV1Erc1155 {
    /** Notional V1 Types */
    struct Deposit {
        // Currency Id to deposit
        uint16 currencyId;
        // Amount of tokens to deposit
        uint128 amount;
    }

    /**
     * Used to describe withdraws in ERC1155.batchOperationWithdraw
     */
    struct Withdraw {
        // Destination of the address to withdraw to
        address to;
        // Currency Id to withdraw
        uint16 currencyId;
        // Amount of tokens to withdraw
        uint128 amount;
    }

    enum TradeType {TakeCurrentCash, TakefCash, AddLiquidity, RemoveLiquidity}

    /**
     * Used to describe a trade in ERC1155.batchOperation
     */
    struct Trade {
        TradeType tradeType;
        uint8 cashGroup;
        uint32 maturity;
        uint128 amount;
        bytes slippageData;
    }

    function batchOperationWithdraw(
        address account,
        uint32 maxTime,
        Deposit[] memory deposits,
        Trade[] memory trades,
        Withdraw[] memory withdraws
    ) external payable;
}

contract NotionalV1ToNotionalV2 {
    IEscrow public immutable Escrow;
    NotionalProxy public immutable NotionalV2;
    INotionalV1Erc1155 public immutable NotionalV1Erc1155;
    WETH9 public immutable WETH;
    IERC20 public immutable WBTC;

    uint16 internal constant V1_ETH = 0;
    uint16 internal constant V1_DAI = 1;
    uint16 internal constant V1_USDC = 2;
    uint16 internal constant V1_WBTC = 3;

    uint16 public constant V2_ETH = 1;
    uint16 public immutable V2_DAI;
    uint16 public immutable V2_USDC;
    uint16 public immutable V2_WBTC;

    constructor(
        IEscrow escrow_,
        NotionalProxy notionalV2_,
        INotionalV1Erc1155 erc1155_,
        WETH9 weth_,
        IERC20 wbtc_,
        uint16 v2Dai_,
        uint16 v2USDC_,
        uint16 v2WBTC_
    ) {
        Escrow = escrow_;
        NotionalV2 = notionalV2_;
        NotionalV1Erc1155 = erc1155_;
        WETH = weth_;
        WBTC = wbtc_;
        V2_DAI = v2Dai_;
        V2_USDC = v2USDC_;
        V2_WBTC = v2WBTC_;
    }

    function enableWBTC() external {
        WBTC.approve(address(NotionalV2), type(uint256).max);
    }

    function migrateDaiEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        // borrow on notional via special flash loan facility
        //  - borrow repayment amount
        //  - withdraw to wallet
        // receive callback (tokens transferred to borrowing account)
        //   -> inside callback
        //   -> repay Notional V1
        //   -> deposit collateral to notional v2 (account needs to have set approvals)
        //   -> exit callback
        // inside original borrow, check FC
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateDaiWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");
        (
            uint16 v1DebtCurrencyId,
            uint128 v1RepayAmount,
            uint16 v1CollateralId,
            uint16 v2CollateralId
        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));

        int256[] memory balances = Escrow.getBalances(account);
        int256 collateralBalance =
            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);
        require(collateralBalance > 0);

        {
            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);
            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);
            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);

            // This will deposit what was borrowed from the account's wallet
            deposits[0].currencyId = v1DebtCurrencyId;
            deposits[0].amount = v1RepayAmount;

            // This will withdraw to the current contract the collateral to repay the flash loan
            withdraws[0].currencyId = v1CollateralId;
            withdraws[0].to = address(this);
            withdraws[0].amount = uint128(collateralBalance);

            NotionalV1Erc1155.batchOperationWithdraw(
                account,
                uint32(block.timestamp),
                deposits,
                trades,
                withdraws
            );
        }

        // Overflow checked above, cannot be negative
        uint256 v2CollateralBalance = uint256(collateralBalance);
        if (v2CollateralId == V2_ETH) {
            // Notional V1 uses WETH, but V2 uses ETH
            WETH.withdraw(v2CollateralBalance);
            NotionalV2.depositUnderlyingToken{value: v2CollateralBalance}(
                account,
                v2CollateralId,
                v2CollateralBalance
            );
        } else {
            NotionalV2.depositUnderlyingToken(account, v2CollateralId, v2CollateralBalance);
        }

        // When this exits it will do a free collateral check
    }

    receive() external payable {}
}",1658
RealWorld_TA_23_AccountContextHandler_RealWorld_20240803030615.log,23,AccountContextHandler,218659,4460,223119,161.0,1.182495,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./balances/BalanceHandler.sol"";
import ""./portfolio/BitmapAssetsHandler.sol"";
import ""./portfolio/PortfolioHandler.sol"";

library AccountContextHandler {
    using PortfolioHandler for PortfolioState;

    bytes18 private constant TURN_OFF_PORTFOLIO_FLAGS = 0x7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF;
    event AccountContextUpdate(address indexed account);

    /// @notice Returns the account context of a given account
    function getAccountContext(address account) internal view returns (AccountContext memory) {
        bytes32 slot = keccak256(abi.encode(account, Constants.ACCOUNT_CONTEXT_STORAGE_OFFSET));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        return
            AccountContext({
                nextSettleTime: uint40(uint256(data)),
                hasDebt: bytes1(data << 208),
                assetArrayLength: uint8(uint256(data >> 48)),
                bitmapCurrencyId: uint16(uint256(data >> 56)),
                activeCurrencies: bytes18(data << 40)
            });
    }

    /// @notice Sets the account context of a given account
    function setAccountContext(AccountContext memory accountContext, address account) internal {
        bytes32 slot = keccak256(abi.encode(account, Constants.ACCOUNT_CONTEXT_STORAGE_OFFSET));
        bytes32 data =
            (bytes32(uint256(accountContext.nextSettleTime)) |
                (bytes32(accountContext.hasDebt) >> 208) |
                (bytes32(uint256(accountContext.assetArrayLength)) << 48) |
                (bytes32(uint256(accountContext.bitmapCurrencyId)) << 56) |
                (bytes32(accountContext.activeCurrencies) >> 40));

        assembly {
            sstore(slot, data)
        }

        emit AccountContextUpdate(account);
    }

    /// @notice Sets the account context of a given account
    function enableBitmapForAccount(
        AccountContext memory accountContext,
        address account,
        uint256 currencyId,
        uint256 blockTime
    ) internal view {
        // Allow setting the currency id to zero to turn off bitmap
        require(currencyId <= Constants.MAX_CURRENCIES, ""AC: invalid currency id"");

        if (accountContext.bitmapCurrencyId == 0) {
            require(accountContext.assetArrayLength == 0, ""AC: cannot have assets"");
            // Account context also cannot have negative cash debts
            require(accountContext.hasDebt == 0x00, ""AC: cannot have debt"");

            // Ensure that the active currency is set to false in the array so that there is no double
            // counting during FreeCollateral
            setActiveCurrency(accountContext, currencyId, false, Constants.ACTIVE_IN_BALANCES);
        } else {
            bytes32 ifCashBitmap =
                BitmapAssetsHandler.getAssetsBitmap(account, accountContext.bitmapCurrencyId);
            require(ifCashBitmap == 0, ""AC: cannot have assets"");
        }

        accountContext.bitmapCurrencyId = uint16(currencyId);

        // Setting this is required to initialize the assets bitmap
        uint256 nextSettleTime = DateTime.getTimeUTC0(blockTime);
        require(nextSettleTime < type(uint40).max); // dev: blockTime overflow
        accountContext.nextSettleTime = uint40(nextSettleTime);
    }

    /// @notice Returns true if the context needs to settle
    function mustSettleAssets(AccountContext memory accountContext) internal view returns (bool) {
        return (accountContext.nextSettleTime != 0 &&
            accountContext.nextSettleTime <= block.timestamp);
    }

    /// @notice Checks if a currency id (uint16 max) is in the 9 slots in the account
    /// context active currencies list.
    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)
        internal
        pure
        returns (bool)
    {
        bytes18 currencies = accountContext.activeCurrencies;
        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id

        if (accountContext.bitmapCurrencyId == currencyId) return true;

        while (currencies != 0x00) {
            uint256 cid = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));
            if (cid == currencyId) {
                // Currency found, return if it is active in balances or not
                return bytes2(currencies) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES;
            }

            currencies = currencies << 16;
        }

        return false;
    }

    /// @notice Iterates through the active currency list and removes, inserts or does nothing
    /// to ensure that the active currency list is an ordered byte array of uint16 currency ids
    /// that refer to the currencies that an account is active in.
    ///
    /// This is called to ensure that currencies are active when the account has a non zero cash balance,
    /// a non zero nToken balance or a portfolio asset.
    function setActiveCurrency(
        AccountContext memory accountContext,
        uint256 currencyId,
        bool isActive,
        bytes2 flags
    ) internal pure {
        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id

        // If the bitmapped currency is already set then return here. Turning off the bitmap currency
        // id requires other logical handling so we will do it elsewhere.
        if (isActive && accountContext.bitmapCurrencyId == currencyId) return;

        bytes18 prefix;
        bytes18 suffix = accountContext.activeCurrencies;
        uint256 shifts;

        /// There are six possible outcomes from this search:
        /// 1. The currency id is in the list
        ///      - it must be set to active, do nothing
        ///      - it must be set to inactive, shift suffix and concatenate
        /// 2. The current id is greater than the one in the search:
        ///      - it must be set to active, append to prefix and then concatenate the suffix,
        ///        ensure that we do not lose the last 2 bytes if set.
        ///      - it must be set to inactive, it is not in the list, do nothing
        /// 3. Reached the end of the list:
        ///      - it must be set to active, check that the last two bytes are not set and then
        ///        append to the prefix
        ///      - it must be set to inactive, do nothing

        while (suffix != 0x00) {
            uint256 cid = uint256(uint16(bytes2(suffix) & Constants.UNMASK_FLAGS));
            // if matches and isActive then return, already in list
            if (cid == currencyId && isActive) {
                // set flag and return
                accountContext.activeCurrencies =
                    accountContext.activeCurrencies |
                    (bytes18(flags) >> (shifts * 16));
                return;
            }

            // if matches and not active then shift suffix to remove
            if (cid == currencyId && !isActive) {
                // turn off flag, if both flags are off then remove
                suffix = suffix & ~bytes18(flags);
                if (bytes2(suffix) & ~Constants.UNMASK_FLAGS == 0x0000) suffix = suffix << 16;
                accountContext.activeCurrencies = prefix | (suffix >> (shifts * 16));
                return;
            }

            // if greater than and isActive then insert into prefix
            if (cid > currencyId && isActive) {
                prefix = prefix | (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));
                // check that the total length is not greater than 9, meaning that the last
                // two bytes of the active currencies array should be zero
                require(
                    (accountContext.activeCurrencies << 128) == 0x00,
                    ""AC: too many currencies""
                );

                // append the suffix
                accountContext.activeCurrencies = prefix | (suffix >> ((shifts + 1) * 16));
                return;
            }

            // if past the point of the currency id and not active, not in list
            if (cid > currencyId && !isActive) return;

            prefix = prefix | (bytes18(bytes2(suffix)) >> (shifts * 16));
            suffix = suffix << 16;
            shifts += 1;
        }

        // If reached this point and not active then return
        if (!isActive) return;

        // if end and isActive then insert into suffix, check max length
        require(shifts < 9, ""AC: too many currencies"");
        accountContext.activeCurrencies =
            prefix |
            (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));
    }

    function _clearPortfolioActiveFlags(bytes18 activeCurrencies) internal pure returns (bytes18) {
        bytes18 result;
        bytes18 suffix = activeCurrencies & TURN_OFF_PORTFOLIO_FLAGS;
        uint256 shifts;

        while (suffix != 0x00) {
            if (bytes2(suffix) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {
                // If any flags are active, then append.
                result = result | (bytes18(bytes2(suffix)) >> (shifts * 16));
                shifts += 1;
            }
            suffix = suffix << 16;
        }

        return result;
    }

    /// @notice Stores a portfolio array and updates the account context information, this method should
    /// be used whenever updating a portfolio array except in the case of nTokens
    function storeAssetsAndUpdateContext(
        AccountContext memory accountContext,
        address account,
        PortfolioState memory portfolioState,
        bool isLiquidation
    ) internal {
        (bool hasDebt, bytes32 portfolioCurrencies, uint8 assetArrayLength, uint40 nextSettleTime) =
            portfolioState.storeAssets(account);

        if (!isLiquidation) {
            require(assetArrayLength <= uint8(Constants.MAX_TRADED_MARKET_INDEX)); // dev: max assets allowed
        }

        if (hasDebt) {
            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;
        } else {
            // Turns off the ASSET_DEBT flag
            accountContext.hasDebt = accountContext.hasDebt & Constants.HAS_CASH_DEBT;
        }
        accountContext.assetArrayLength = assetArrayLength;
        accountContext.nextSettleTime = nextSettleTime;

        uint256 lastCurrency;
        // Clear the active portfolio active flags and they will be recalculated in the next step
        accountContext.activeCurrencies = _clearPortfolioActiveFlags(
            accountContext.activeCurrencies
        );

        while (portfolioCurrencies != 0) {
            uint256 currencyId = uint256(uint16(bytes2(portfolioCurrencies)));
            if (currencyId != lastCurrency) {
                setActiveCurrency(accountContext, currencyId, true, Constants.ACTIVE_IN_PORTFOLIO);
            }
            lastCurrency = currencyId;

            portfolioCurrencies = portfolioCurrencies << 16;
        }
    }
}",2372
RealWorld_TA_23_ExchangeRate_RealWorld_20240803045055.log,23,ExchangeRate,97818,3121,100939,364.0,0.55151,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../balances/TokenHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""interfaces/chainlink/AggregatorV2V3Interface.sol"";

library ExchangeRate {
    using SafeInt256 for int256;

    uint256 private constant ETH_RATE_STORAGE_SLOT = 1;

    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are
    /// always applied in this method.
    /// @param er exchange rate object from base to ETH
    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION
    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {
        if (balance == 0) return 0;
        int256 multiplier = balance > 0 ? er.haircut : er.buffer;

        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals
        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)
        // Therefore the result is in ethDecimals
        int256 result =
            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(
                er.rateDecimals
            );

        return result;
    }

    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.
    /// Buffers and haircuts ARE NOT applied in this method.
    /// @param er exchange rate object from base to ETH
    /// @param balance amount (denominated in ETH) to convert
    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {
        if (balance == 0) return 0;

        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals
        // internalDecimals * rateDecimals / rateDecimals
        int256 result = balance.mul(er.rateDecimals).div(er.rate);

        return result;
    }

    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in
    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals
    /// @param baseER base exchange rate struct
    /// @param quoteER quote exchange rate struct
    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)
        internal
        pure
        returns (int256)
    {
        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);
    }

    /// @notice Returns an ETHRate object used to calculate free collateral
    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {
        bytes32 slot = keccak256(abi.encode(currencyId, ETH_RATE_STORAGE_SLOT));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        int256 rateDecimals;
        int256 rate;
        if (currencyId == Constants.ETH_CURRENCY_ID) {
            // ETH rates will just be 1e18, but will still have buffers, haircuts,
            // and liquidation discounts
            rateDecimals = Constants.ETH_DECIMALS;
            rate = Constants.ETH_DECIMALS;
        } else {
            address rateOracle = address(bytes20(data << 96));
            // prettier-ignore
            (
                /* uint80 */,
                rate,
                /* uint256 */,
                /* uint256 */,
                /* uint80 */
            ) = AggregatorV2V3Interface(rateOracle).latestRoundData();
            require(rate > 0, ""ExchangeRate: invalid rate"");

            uint8 rateDecimalPlaces = uint8(bytes1(data << 88));
            rateDecimals = int256(10**rateDecimalPlaces);
            if (
                bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */
            ) {
                rate = rateDecimals.mul(rateDecimals).div(rate);
            }
        }

        int256 buffer = int256(uint8(bytes1(data << 72)));
        int256 haircut = int256(uint8(bytes1(data << 64)));
        int256 liquidationDiscount = int256(uint8(bytes1(data << 56)));
        return
            ETHRate({
                rateDecimals: rateDecimals,
                rate: rate,
                buffer: buffer,
                haircut: haircut,
                liquidationDiscount: liquidationDiscount
            });
    }
}",958
RealWorld_TA_23_BalanceHandler_RealWorld_20240803040122.log,23,BalanceHandler,362903,4392,367295,375.0,1.902355,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./Incentives.sol"";
import ""./TokenHandler.sol"";
import ""../AccountContextHandler.sol"";
import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/FloatingPoint56.sol"";

library BalanceHandler {
    using SafeInt256 for int256;
    using TokenHandler for Token;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;

    /// @notice Emitted when a cash balance changes
    event CashBalanceChange(address indexed account, uint16 currencyId, int256 netCashChange);
    /// @notice Emitted when nToken supply changes (not the same as transfers)
    event nTokenSupplyChange(address indexed account, uint16 currencyId, int256 tokenSupplyChange);

    /// @notice Deposits asset tokens into an account
    /// @dev Handles two special cases when depositing tokens into an account.
    ///  - If a token has transfer fees then the amount specified does not equal the amount that the contract
    ///    will receive. Complete the deposit here rather than in finalize so that the contract has the correct
    ///    balance to work with.
    ///  - Force a transfer before finalize to allow a different account to deposit into an account
    /// @return Returns two values:
    ///  - assetAmountInternal which is the converted asset amount accounting for transfer fees
    ///  - assetAmountTransferred which is the internal precision amount transferred into the account
    function depositAssetToken(
        BalanceState memory balanceState,
        address account,
        int256 assetAmountExternal,
        bool forceTransfer
    ) internal returns (int256) {
        if (assetAmountExternal == 0) return 0;
        require(assetAmountExternal > 0); // dev: deposit asset token amount negative
        Token memory token = TokenHandler.getToken(balanceState.currencyId, false);
        int256 assetAmountInternal = token.convertToInternal(assetAmountExternal);

        // Force transfer is used to complete the transfer before going to finalize
        if (token.hasTransferFee || forceTransfer) {
            // If the token has a transfer fee the deposit amount may not equal the actual amount
            // that the contract will receive. We handle the deposit here and then update the netCashChange
            // accordingly which is denominated in internal precision.
            int256 assetAmountExternalPrecisionFinal = token.transfer(account, assetAmountExternal);
            // Convert the external precision to internal, it's possible that we lose dust amounts here but
            // this is unavoidable because we do not know how transfer fees are calculated.
            assetAmountInternal = token.convertToInternal(assetAmountExternalPrecisionFinal);
            balanceState.netCashChange = balanceState.netCashChange.add(assetAmountInternal);

            return assetAmountInternal;
        }

        // Otherwise add the asset amount here. It may be net off later and we want to only do
        // a single transfer during the finalize method. Use internal precision to ensure that internal accounting
        // and external account remain in sync.
        balanceState.netAssetTransferInternalPrecision = balanceState
            .netAssetTransferInternalPrecision
            .add(assetAmountInternal);

        // Returns the converted assetAmountExternal to the internal amount
        return assetAmountInternal;
    }

    /// @notice Handle deposits of the underlying token
    /// @dev In this case we must wrap the underlying token into an asset token, ensuring that we do not end up
    /// with any underlying tokens left as dust on the contract.
    function depositUnderlyingToken(
        BalanceState memory balanceState,
        address account,
        int256 underlyingAmountExternal
    ) internal returns (int256) {
        if (underlyingAmountExternal == 0) return 0;
        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative

        Token memory underlyingToken = TokenHandler.getToken(balanceState.currencyId, true);
        // This is the exact amount of underlying tokens the account has in external precision.
        if (underlyingToken.tokenType == TokenType.Ether) {
            require(underlyingAmountExternal == int256(msg.value), ""Invalid ETH balance"");
        } else {
            underlyingAmountExternal = underlyingToken.transfer(account, underlyingAmountExternal);
        }

        Token memory assetToken = TokenHandler.getToken(balanceState.currencyId, false);
        // Tokens that are not mintable like cTokens will be deposited as assetTokens
        require(assetToken.tokenType == TokenType.cToken || assetToken.tokenType == TokenType.cETH); // dev: deposit underlying token invalid token type
        int256 assetTokensReceivedExternalPrecision =
            assetToken.mint(uint256(underlyingAmountExternal));

        // cTokens match INTERNAL_TOKEN_PRECISION so this will short circuit but we leave this here in case a different
        // type of asset token is listed in the future. It's possible if those tokens have a different precision dust may
        // accrue but that is not relevant now.
        int256 assetTokensReceivedInternal =
            assetToken.convertToInternal(assetTokensReceivedExternalPrecision);
        balanceState.netCashChange = balanceState.netCashChange.add(assetTokensReceivedInternal);

        return assetTokensReceivedInternal;
    }

    /// @notice Finalizes an account's balances, handling any transfer logic required
    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken
    /// as the nToken is limited in what types of balances it can hold.
    function finalize(
        BalanceState memory balanceState,
        address account,
        AccountContext memory accountContext,
        bool redeemToUnderlying
    ) internal returns (int256 transferAmountExternal) {
        bool mustUpdate;
        if (balanceState.netNTokenTransfer < 0) {
            require(
                balanceState.storedNTokenBalance.add(balanceState.netNTokenSupplyChange) >=
                    balanceState.netNTokenTransfer.neg(),
                ""Neg withdraw""
            );
        }

        if (balanceState.netAssetTransferInternalPrecision < 0) {
            require(
                balanceState.storedCashBalance.add(balanceState.netCashChange).add(
                    balanceState.netAssetTransferInternalPrecision
                ) >= 0,
                ""Neg withdraw""
            );
        }

        if (balanceState.netAssetTransferInternalPrecision != 0) {
            transferAmountExternal = _finalizeTransfers(balanceState, account, redeemToUnderlying);
        }

        if (
            balanceState.netCashChange != 0 || balanceState.netAssetTransferInternalPrecision != 0
        ) {
            balanceState.storedCashBalance = balanceState
                .storedCashBalance
                .add(balanceState.netCashChange)
                .add(balanceState.netAssetTransferInternalPrecision);

            mustUpdate = true;

            emit CashBalanceChange(
                account,
                uint16(balanceState.currencyId),
                balanceState.netCashChange.add(balanceState.netAssetTransferInternalPrecision)
            );
        }

        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {
            // It's crucial that incentives are claimed before we do any sort of nToken transfer to prevent gaming
            // of the system. This method will update the lastClaimTime time in the balanceState for storage.
            Incentives.claimIncentives(balanceState, account);

            // nTokens are within the notional system so we can update balances directly.
            balanceState.storedNTokenBalance = balanceState
                .storedNTokenBalance
                .add(balanceState.netNTokenTransfer)
                .add(balanceState.netNTokenSupplyChange);

            if (balanceState.netNTokenSupplyChange != 0) {
                emit nTokenSupplyChange(
                    account,
                    uint16(balanceState.currencyId),
                    balanceState.netNTokenSupplyChange
                );
            }

            mustUpdate = true;
        }

        if (mustUpdate) {
            _setBalanceStorage(
                account,
                balanceState.currencyId,
                balanceState.storedCashBalance,
                balanceState.storedNTokenBalance,
                balanceState.lastClaimTime,
                balanceState.lastClaimIntegralSupply
            );
        }

        accountContext.setActiveCurrency(
            balanceState.currencyId,
            // Set active currency to true if either balance is non-zero
            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,
            Constants.ACTIVE_IN_BALANCES
        );

        if (balanceState.storedCashBalance < 0) {
            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances
            // are examined
            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;
        }

        return transferAmountExternal;
    }

    /// @dev Returns the amount transferred in underlying or asset terms depending on how redeem to underlying
    /// is specified.
    function _finalizeTransfers(
        BalanceState memory balanceState,
        address account,
        bool redeemToUnderlying
    ) private returns (int256 actualTransferAmountExternal) {
        Token memory assetToken = TokenHandler.getToken(balanceState.currencyId, false);
        int256 assetTransferAmountExternal =
            assetToken.convertToExternal(balanceState.netAssetTransferInternalPrecision);

        // We only do the redeem to underlying if the asset transfer amount is less than zero. If it is greater than
        // zero then we will do a normal transfer instead. We know in this function that the value will not be zero.
        if (redeemToUnderlying && assetTransferAmountExternal < 0) {
            // We use the internal amount here and then scale it to the external amount so that there is
            // no loss of precision between our internal accounting and the external account. In this case
            // there will be no dust accrual since we will transfer the exact amount of underlying that was
            // received.
            Token memory underlyingToken = TokenHandler.getToken(balanceState.currencyId, true);
            int256 underlyingAmountExternal = assetToken.redeem(
                underlyingToken,
                // NOTE: dust may accrue at the lowest decimal place
                uint256(assetTransferAmountExternal.neg())
            );

            // Withdraws the underlying amount out to the destination account
            actualTransferAmountExternal = underlyingToken.transfer(
                account,
                underlyingAmountExternal.neg()
            );
        } else {
            assetTransferAmountExternal = assetToken.transfer(account, assetTransferAmountExternal);
            actualTransferAmountExternal = assetTransferAmountExternal;
        }

        // Convert the actual transferred amount
        balanceState.netAssetTransferInternalPrecision = assetToken.convertToInternal(
            assetTransferAmountExternal
        );

        return actualTransferAmountExternal;
    }

    /// @notice Special method for settling negative current cash debts. This occurs when an account
    /// has a negative fCash balance settle to cash. A settler may come and force the account to borrow
    /// at the prevailing 3 month rate
    /// @dev Use this method to avoid any nToken and transfer logic in finalize which is unnecessary.
    function setBalanceStorageForSettleCashDebt(
        address account,
        CashGroupParameters memory cashGroup,
        int256 amountToSettleAsset,
        AccountContext memory accountContext
    ) internal returns (int256) {
        require(amountToSettleAsset >= 0); // dev: amount to settle negative
        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 lastClaimIntegralSupply) =
            getBalanceStorage(account, cashGroup.currencyId);

        require(cashBalance < 0, ""Invalid settle balance"");
        if (amountToSettleAsset == 0) {
            // Symbolizes that the entire debt should be settled
            amountToSettleAsset = cashBalance.neg();
            cashBalance = 0;
        } else {
            // A partial settlement of the debt
            require(amountToSettleAsset <= cashBalance.neg(), ""Invalid amount to settle"");
            cashBalance = cashBalance.add(amountToSettleAsset);
        }

        // NOTE: we do not update HAS_CASH_DEBT here because it is possible that the other balances
        // also have cash debts
        if (cashBalance == 0 && nTokenBalance == 0) {
            accountContext.setActiveCurrency(
                cashGroup.currencyId,
                false,
                Constants.ACTIVE_IN_BALANCES
            );
        }

        _setBalanceStorage(
            account,
            cashGroup.currencyId,
            cashBalance,
            nTokenBalance,
            lastClaimTime,
            lastClaimIntegralSupply
        );

        // Emit the event here, we do not call finalize
        emit CashBalanceChange(account, uint16(cashGroup.currencyId), amountToSettleAsset);

        return amountToSettleAsset;
    }

    /// @notice Helper method for settling the output of the SettleAssets method
    function finalizeSettleAmounts(
        address account,
        AccountContext memory accountContext,
        SettleAmount[] memory settleAmounts
    ) internal {
        for (uint256 i; i < settleAmounts.length; i++) {
            if (settleAmounts[i].netCashChange == 0) continue;

            (
                int256 cashBalance,
                int256 nTokenBalance,
                uint256 lastClaimTime,
                uint256 lastClaimIntegralSupply
            ) = getBalanceStorage(account, settleAmounts[i].currencyId);

            cashBalance = cashBalance.add(settleAmounts[i].netCashChange);
            accountContext.setActiveCurrency(
                settleAmounts[i].currencyId,
                cashBalance != 0 || nTokenBalance != 0,
                Constants.ACTIVE_IN_BALANCES
            );

            if (cashBalance < 0) {
                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;
            }

            emit CashBalanceChange(
                account,
                uint16(settleAmounts[i].currencyId),
                settleAmounts[i].netCashChange
            );

            _setBalanceStorage(
                account,
                settleAmounts[i].currencyId,
                cashBalance,
                nTokenBalance,
                lastClaimTime,
                lastClaimIntegralSupply
            );
        }
    }

    /// @notice Special method for setting balance storage for nToken
    function setBalanceStorageForNToken(
        address nTokenAddress,
        uint256 currencyId,
        int256 cashBalance
    ) internal {
        require(cashBalance >= 0); // dev: invalid nToken cash balance
        _setBalanceStorage(nTokenAddress, currencyId, cashBalance, 0, 0, 0);
    }

    /// @notice increments fees to the reserve
    function incrementFeeToReserve(uint256 currencyId, int256 fee) internal {
        require(fee >= 0); // dev: invalid fee
        // prettier-ignore
        (int256 totalReserve, /* */, /* */, /* */) = getBalanceStorage(Constants.RESERVE, currencyId);
        totalReserve = totalReserve.add(fee);
        _setBalanceStorage(Constants.RESERVE, currencyId, totalReserve, 0, 0, 0);
    }

    function _getSlot(address account, uint256 currencyId) private pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(account, Constants.BALANCE_STORAGE_OFFSET))
                )
            );
    }

    /// @notice Sets internal balance storage.
    function _setBalanceStorage(
        address account,
        uint256 currencyId,
        int256 cashBalance,
        int256 nTokenBalance,
        uint256 lastClaimTime,
        uint256 lastClaimIntegralSupply
    ) private {
        bytes32 slot = _getSlot(account, currencyId);
        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow
        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow
        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow
        require(lastClaimTime >= 0 && lastClaimTime <= type(uint32).max); // dev: last claim time overflow
        // Last claim supply is stored in a ""floating point"" storage slot that does not maintain exact precision but
        // is also not limited by storage overflows. `packTo56Bits` will ensure that the the returned value will fit
        // in 56 bits (7 bytes)
        bytes32 packedLastClaimIntegralSupply = FloatingPoint56.packTo56Bits(lastClaimIntegralSupply);

        bytes32 data =
            ((bytes32(uint256(nTokenBalance))) |
                (bytes32(lastClaimTime) << 80) |
                (packedLastClaimIntegralSupply << 112) |
                (bytes32(cashBalance) << 168));

        assembly {
            sstore(slot, data)
        }
    }

    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances
    function getBalanceStorage(address account, uint256 currencyId)
        internal
        view
        returns (
            int256 cashBalance,
            int256 nTokenBalance,
            uint256 lastClaimTime,
            uint256 lastClaimIntegralSupply
        )
    {
        bytes32 slot = _getSlot(account, currencyId);
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        nTokenBalance = int256(uint80(uint256(data)));
        lastClaimTime = uint256(uint32(uint256(data >> 80)));
        lastClaimIntegralSupply = FloatingPoint56.unpackFrom56Bits(uint256(uint56(uint256(data >> 112))));
        cashBalance = int256(int88(int256(data >> 168)));
    }

    /// @notice Loads a balance state memory object
    /// @dev Balance state objects occupy a lot of memory slots, so this method allows
    /// us to reuse them if possible
    function loadBalanceState(
        BalanceState memory balanceState,
        address account,
        uint256 currencyId,
        AccountContext memory accountContext
    ) internal view {
        require(currencyId != 0); // dev: invalid currency id
        balanceState.currencyId = currencyId;

        if (accountContext.isActiveInBalances(currencyId)) {
            (
                balanceState.storedCashBalance,
                balanceState.storedNTokenBalance,
                balanceState.lastClaimTime,
                balanceState.lastClaimIntegralSupply
            ) = getBalanceStorage(account, currencyId);
        } else {
            balanceState.storedCashBalance = 0;
            balanceState.storedNTokenBalance = 0;
            balanceState.lastClaimTime = 0;
            balanceState.lastClaimIntegralSupply = 0;
        }

        balanceState.netCashChange = 0;
        balanceState.netAssetTransferInternalPrecision = 0;
        balanceState.netNTokenTransfer = 0;
        balanceState.netNTokenSupplyChange = 0;
    }

    /// @notice Used when manually claiming incentives in nTokenAction
    function claimIncentivesManual(BalanceState memory balanceState, address account)
        internal
        returns (uint256)
    {
        uint256 incentivesClaimed = Incentives.claimIncentives(balanceState, account);
        _setBalanceStorage(
            account,
            balanceState.currencyId,
            balanceState.storedCashBalance,
            balanceState.storedNTokenBalance,
            balanceState.lastClaimTime,
            balanceState.lastClaimIntegralSupply
        );

        return incentivesClaimed;
    }
}",4107
RealWorld_TA_23_AccountAction_RealWorld_20240803065449.log,23,AccountAction,166254,6850,173104,374.0,0.96827,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../SettleAssetsExternal.sol"";
import ""../FreeCollateralExternal.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/AccountContextHandler.sol"";

contract AccountAction {
    using BalanceHandler for BalanceState;
    using AccountContextHandler for AccountContext;
    using SafeInt256 for int256;

    /// @notice Enables a bitmap currency for msg.sender, account cannot have any assets when this call
    /// occurs.
    /// @param currencyId the currency to enable the bitmap for
    /// @dev emit:AccountSettled emit:AccountContextUpdate
    /// @dev auth:msg.sender
    function enableBitmapCurrency(uint16 currencyId) external {
        require(msg.sender != address(this)); // dev: no internal call to enableBitmapCurrency
        address account = msg.sender;
        AccountContext memory accountContext = _settleAccountIfRequiredAndFinalize(account);
        accountContext.enableBitmapForAccount(account, currencyId, block.timestamp);
        accountContext.setAccountContext(account);
    }

    /// @notice Method for manually settling an account, generally should not be called because other
    /// methods will check if an account needs to be settled automatically. If a bitmap account has debt
    /// and is settled via this method, the hasDebt flag will not be cleared until a free collateral check
    /// is performed on the account.
    /// @param account the account to settle
    /// @dev emit:AccountSettled emit:AccountContextUpdate
    /// @dev auth:none
    function settleAccount(address account) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);
            // Don't use the internal method here to avoid setting the account context if it does
            // not require settlement
            accountContext.setAccountContext(account);
        }
    }

    /// @notice Deposits and wraps the underlying token for a particular cToken. Does not settle assets or check free
    /// collateral, idea is to be as gas efficient as possible during potential liquidation events.
    /// @param account the account to deposit into
    /// @param currencyId currency id of the asset token that wraps this underlying
    /// @param amountExternalPrecision the amount of underlying tokens in its native decimal precision
    /// (i.e. 18 decimals for DAI or 6 decimals for USDC). This will be converted to 8 decimals during transfer.
    /// @return asset tokens minted and deposited to the account in internal decimals (8)
    /// @dev emit:CashBalanceChange emit:AccountContextUpdate
    /// @dev auth:none
    function depositUnderlyingToken(
        address account,
        uint16 currencyId,
        uint256 amountExternalPrecision
    ) external payable returns (uint256) {
        // No other authorization required on depositing
        require(msg.sender != address(this)); // dev: no internal call to deposit underlying

        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        BalanceState memory balanceState;
        balanceState.loadBalanceState(account, currencyId, accountContext);

        // Int conversion overflow check done inside this method call
        // NOTE: using msg.sender here allows for a different sender to deposit tokens into the specified account. This may
        // be useful for on-demand collateral top ups from a third party
        int256 assetTokensReceivedInternal = balanceState.depositUnderlyingToken(
            msg.sender,
            int256(amountExternalPrecision)
        );

        balanceState.finalize(account, accountContext, false);
        accountContext.setAccountContext(account);

        require(assetTokensReceivedInternal > 0); // dev: asset tokens negative

        // NOTE: no free collateral checks required for depositing
        return uint256(assetTokensReceivedInternal);
    }

    /// @notice Deposits asset tokens into an account. Does not settle or check free collateral, idea is to
    /// make deposit as gas efficient as possible during potential liquidation events.
    /// @param account the account to deposit into
    /// @param currencyId currency id of the asset token
    /// @param amountExternalPrecision the amount of asset tokens in its native decimal precision
    /// (i.e. 8 decimals for cTokens). This will be converted to 8 decimals during transfer if necessary.
    /// @return asset tokens minted and deposited to the account in internal decimals (8)
    /// @dev emit:CashBalanceChange emit:AccountContextUpdate
    /// @dev auth:none
    function depositAssetToken(
        address account,
        uint16 currencyId,
        uint256 amountExternalPrecision
    ) external returns (uint256) {
        require(msg.sender != address(this)); // dev: no internal call to deposit asset

        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        BalanceState memory balanceState;
        balanceState.loadBalanceState(account, currencyId, accountContext);

        // Int conversion overflow check done inside this method call. msg.sender
        // is used as the account in deposit to allow for other accounts to deposit
        // on behalf of the given account.
        int256 assetTokensReceivedInternal = balanceState.depositAssetToken(
            msg.sender,
            int256(amountExternalPrecision),
            true // force transfer to ensure that msg.sender does the transfer, not account
        );

        balanceState.finalize(account, accountContext, false);
        accountContext.setAccountContext(account);

        require(assetTokensReceivedInternal > 0); // dev: asset tokens negative

        // NOTE: no free collateral checks required for depositing
        return uint256(assetTokensReceivedInternal);
    }

    /// @notice Withdraws balances from Notional, may also redeem to underlying tokens on user request. Will settle
    /// and do free collateral checks if required. Can only be called by msg.sender, operators who want to withdraw for
    /// an account must do an authenticated call via ERC1155Action `safeTransferFrom` or `safeBatchTransferFrom`
    /// @param currencyId currency id of the asset token
    /// @param amountInternalPrecision the amount of asset tokens in its native decimal precision
    /// (i.e. 8 decimals for cTokens). This will be converted to 8 decimals during transfer if necessary.
    /// @param redeemToUnderlying true if the tokens should be converted to underlying assets
    /// @dev emit:CashBalanceChange emit:AccountContextUpdate
    /// @dev auth:msg.sender
    /// @return the amount of tokens received by the account denominated in the destination token precision (if
    // redeeming to underlying the amount will be the underlying amount received in that token's native precision)
    function withdraw(
        uint16 currencyId,
        uint88 amountInternalPrecision,
        bool redeemToUnderlying
    ) external returns (uint256) {
        address account = msg.sender;

        // This happens before reading the balance state to get the most up to date cash balance
        AccountContext memory accountContext = _settleAccountIfRequiredAndFinalize(account);

        BalanceState memory balanceState;
        balanceState.loadBalanceState(account, currencyId, accountContext);
        require(balanceState.storedCashBalance >= amountInternalPrecision, ""Insufficient balance"");
        balanceState.netAssetTransferInternalPrecision = int256(amountInternalPrecision).neg();

        int256 amountWithdrawn = balanceState.finalize(account, accountContext, redeemToUnderlying);

        accountContext.setAccountContext(account);
        if (accountContext.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(account);
        }

        require(amountWithdrawn <= 0);
        return uint256(amountWithdrawn.neg());
    }

    function _settleAccountIfRequiredAndFinalize(address account)
        private
        returns (AccountContext memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            return SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);
        }

        return accountContext;
    }
}",1733
RealWorld_TA_23_CompoundToNotionalV2_RealWorld_20240803055250.log,23,CompoundToNotionalV2,95354,4900,100254,377.0,0.57477,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/compound/CTokenInterface.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract CompoundToNotionalV2 {
    NotionalProxy public immutable NotionalV2;
    address public owner;

    constructor(NotionalProxy notionalV2_) {
        NotionalV2 = notionalV2_;
        owner = msg.sender;
    }

    function enableToken(address token, address spender) external {
        require(msg.sender == owner, ""Unauthorized"");
        CTokenInterface(token).approve(spender, type(uint256).max);
    }

    function migrateBorrowFromCompound(
        address cTokenBorrow,
        uint256 cTokenRepayAmount,
        uint16[] memory notionalV2CollateralIds,
        uint256[] memory notionalV2CollateralAmounts,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        // borrow on notional via special flash loan facility
        //  - borrow repayment amount
        //  - withdraw to wallet, redeem to underlying
        // receive callback (tokens transferred to borrowing account)
        //   -> inside callback
        //   -> repayBorrowBehalf(account, repayAmount)
        //   -> deposit cToken to notional (account needs to have set approvals)
        //   -> exit callback
        // inside original borrow, check FC
        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);
        if (cTokenRepayAmount == 0) {
            // Set the entire borrow balance if it is not set
            cTokenRepayAmount = borrowBalance;
        } else {
            // Check that the cToken repayment amount is not more than required
            require(cTokenRepayAmount <= borrowBalance, ""Invalid repayment amount"");
        }

        bytes memory encodedData = abi.encode(
            cTokenBorrow,
            cTokenRepayAmount,
            notionalV2CollateralIds,
            notionalV2CollateralAmounts
        );
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");

        (
            address cTokenBorrow,
            uint256 cTokenRepayAmount,
            uint16[] memory notionalV2CollateralIds,
            uint256[] memory notionalV2CollateralAmounts
        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));

        // Transfer in the underlying amount that was borrowed
        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();
        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);
        require(success, ""Transfer of repayment failed"");

        // Use the amount transferred to repay the borrow
        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);
        require(code == 0, ""Repay borrow behalf failed"");

        for (uint256 i; i < notionalV2CollateralIds.length; i++) {
            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);
            // Transfer the collateral to this contract so we can deposit it
            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);
            require(success, ""cToken transfer failed"");

            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here
            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);
        }

        // When this exits a free collateral check will be triggered
    }

    receive() external payable {
        // This contract cannot migrate ETH loans because there is no way
        // to do transferFrom on ETH
        revert(""Cannot transfer ETH"");
    }
}",924
RealWorld_TA_23_nTokenRedeemAction_RealWorld_20240803061735.log,23,nTokenRedeemAction,260362,5825,266187,381.0,1.41831,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/markets/Market.sol"";
import ""../../internal/nTokenHandler.sol"";
import ""../../internal/portfolio/PortfolioHandler.sol"";
import ""../../internal/portfolio/TransferAssets.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../external/FreeCollateralExternal.sol"";
import ""../../external/SettleAssetsExternal.sol"";
import ""../../math/SafeInt256.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract nTokenRedeemAction {
    using SafeInt256 for int256;
    using SafeMath for uint256;
    using BalanceHandler for BalanceState;
    using Market for MarketParameters;
    using CashGroup for CashGroupParameters;
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;
    using nTokenHandler for nTokenPortfolio;

    event nTokenSupplyChange(address indexed account, uint16 currencyId, int256 tokenSupplyChange);

    /// @notice When redeeming nTokens via the batch they must all be sold to cash and this
    /// method will return the amount of asset cash sold. This method can only be invoked via delegatecall.
    /// @param currencyId the currency associated the nToken
    /// @param tokensToRedeem the amount of nTokens to convert to cash
    /// @dev auth:only internal
    /// @return amount of asset cash to return to the account, denominated in internal token decimals
    function nTokenRedeemViaBatch(uint256 currencyId, int256 tokensToRedeem)
        external
        returns (int256)
    {
        require(msg.sender == address(this), ""Unauthorized caller"");
        uint256 blockTime = block.timestamp;
        // prettier-ignore
        (
            int256 totalAssetCash,
            bool hasResidual,
            /* PortfolioAssets[] memory newfCashAssets */
        ) = _redeem(currencyId, tokensToRedeem, true, blockTime);

        require(!hasResidual, ""Cannot redeem via batch, residual"");
        return totalAssetCash;
    }

    /// @notice Allows accounts to redeem nTokens into constituent assets and then absorb the assets
    /// into their portfolio. Due to the complexity here, it is not allowed to be called during a batch trading
    /// operation and must be done separately.
    /// @param redeemer the address that holds the nTokens to redeem
    /// @param currencyId the currency associated the nToken
    /// @param tokensToRedeem_ the amount of nTokens to convert to cash
    /// @param sellTokenAssets attempt to sell residual fCash and convert to cash, if unsuccessful then
    /// residual fCash assets will be placed into the portfolio
    /// @dev auth:msg.sender auth:ERC1155
    /// @return total amount of asset cash redeemed
    function nTokenRedeem(
        address redeemer,
        uint16 currencyId,
        uint96 tokensToRedeem_,
        bool sellTokenAssets
    ) external returns (int256) {
        // ERC1155 can call this method during a post transfer event
        require(msg.sender == redeemer || msg.sender == address(this), ""Unauthorized caller"");

        uint256 blockTime = block.timestamp;
        int256 tokensToRedeem = int256(tokensToRedeem_);

        AccountContext memory context = AccountContextHandler.getAccountContext(redeemer);
        BalanceState memory balance;
        balance.loadBalanceState(redeemer, currencyId, context);

        require(balance.storedNTokenBalance >= tokensToRedeem, ""Insufficient tokens"");
        balance.netNTokenSupplyChange = tokensToRedeem.neg();

        (int256 totalAssetCash, bool hasResidual, PortfolioAsset[] memory assets) =
            _redeem(currencyId, tokensToRedeem, sellTokenAssets, blockTime);
        balance.netCashChange = totalAssetCash;
        balance.finalize(redeemer, context, false);

        if (hasResidual) {
            // If the account has assets that need to be settled it will occur inside
            // this method call. We ensure that balances are finalized before this so
            // that settled balances don't overwrite existing balances.
            context = TransferAssets.placeAssetsInAccount(redeemer, context, assets);
        }
        context.setAccountContext(redeemer);

        emit nTokenSupplyChange(redeemer, currencyId, tokensToRedeem.neg());

        if (context.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(redeemer);
        }

        return totalAssetCash;
    }

    function _redeem(
        uint256 currencyId,
        int256 tokensToRedeem,
        bool sellTokenAssets,
        uint256 blockTime
    )
        private
        returns (
            int256,
            bool,
            PortfolioAsset[] memory
        )
    {
        require(tokensToRedeem > 0);
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioStateful(currencyId, nToken);
        MarketParameters[] memory markets = new MarketParameters[](nToken.cashGroup.maxMarketIndex);

        // Get the assetCash and fCash assets as a result of redeeming tokens
        (PortfolioAsset[] memory newfCashAssets, int256 totalAssetCash) =
            _reduceTokenAssets(nToken, markets, tokensToRedeem, blockTime);

        // hasResidual is set to true if fCash assets need to be put back into the redeemer's portfolio
        bool hasResidual = true;
        if (sellTokenAssets) {
            int256 assetCash;
            (assetCash, hasResidual) = _sellfCashAssets(
                nToken.cashGroup,
                markets,
                newfCashAssets,
                blockTime
            );

            totalAssetCash = totalAssetCash.add(assetCash);
        }

        // Finalize all market states
        for (uint256 i; i < markets.length; i++) {
            markets[i].setMarketStorage();
        }

        return (totalAssetCash, hasResidual, newfCashAssets);
    }

    /// @notice Removes nToken assets and returns the net amount of asset cash owed to the account.
    function _reduceTokenAssets(
        nTokenPortfolio memory nToken,
        MarketParameters[] memory markets,
        int256 tokensToRedeem,
        uint256 blockTime
    ) private returns (PortfolioAsset[] memory, int256) {
        require(nToken.getNextSettleTime() > blockTime, ""PT: requires settlement"");

        // Get share of ifCash assets to remove
        PortfolioAsset[] memory newifCashAssets =
            BitmapAssetsHandler.reduceifCashAssetsProportional(
                nToken.tokenAddress,
                nToken.cashGroup.currencyId,
                nToken.lastInitializedTime,
                tokensToRedeem,
                nToken.totalSupply
            );

        // Get asset cash share for the nToken, if it exists. It is required in balance handler that the
        // nToken can never have a negative cash asset cash balance so what we get here is always positive.
        int256 assetCashShare = nToken.cashBalance.mul(tokensToRedeem).div(nToken.totalSupply);
        if (assetCashShare > 0) {
            nToken.cashBalance = nToken.cashBalance.subNoNeg(assetCashShare);
            BalanceHandler.setBalanceStorageForNToken(
                nToken.tokenAddress,
                nToken.cashGroup.currencyId,
                nToken.cashBalance
            );
        }

        // Get share of liquidity tokens to remove
        assetCashShare = assetCashShare.add(
            _removeLiquidityTokens(
                nToken,
                markets,
                newifCashAssets,
                tokensToRedeem,
                nToken.totalSupply,
                blockTime
            )
        );

        {
            // prettier-ignore
            (
                /* hasDebt */,
                /* currencies */,
                uint8 newStorageLength,
                /* nextSettleTime */
            ) = nToken.portfolioState.storeAssets(nToken.tokenAddress);

            // This can happen if a liquidity token is redeemed down to zero. It's possible that due to dust amounts
            // one token is reduced down to a zero balance while the others still have some amount remaining. In this case
            // the mint nToken will fail in `addLiquidityToMarket`, an account must accept redeeming part of their
            // nTokens and leaving some dust amount behind.
            require(
                nToken.portfolioState.storedAssets.length == uint256(newStorageLength),
                ""Cannot redeem to zero""
            );
        }

        // NOTE: Token supply change will happen when we finalize balances and after minting of incentives
        return (newifCashAssets, assetCashShare);
    }

    /// @notice Removes nToken liquidity tokens and updates the netfCash figures.
    function _removeLiquidityTokens(
        nTokenPortfolio memory nToken,
        MarketParameters[] memory markets,
        PortfolioAsset[] memory newifCashAssets,
        int256 tokensToRedeem,
        int256 totalSupply,
        uint256 blockTime
    ) private view returns (int256) {
        int256 totalAssetCash;

        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) {
            PortfolioAsset memory asset = nToken.portfolioState.storedAssets[i];
            int256 tokensToRemove = asset.notional.mul(tokensToRedeem).div(int256(totalSupply));
            asset.notional = asset.notional.sub(tokensToRemove);
            asset.storageState = AssetStorageState.Update;

            nToken.cashGroup.loadMarket(markets[i], i + 1, true, blockTime);
            // Remove liquidity from the market
            (int256 assetCash, int256 fCash) = markets[i].removeLiquidity(tokensToRemove);
            totalAssetCash = totalAssetCash.add(assetCash);

            // It is improbable but possible that an fcash asset does not exist if the fCash position for an active liquidity token
            // is zero. This would occur when the nToken has done a lot of lending instead of providing liquidity to the point
            // where the fCash position is exactly zero. This is highly unlikely so instead of adding more logic to handle it we will just
            // fail here. Minting some amount of nTokens will cause the fCash position to be reinstated.
            {
                uint256 ifCashIndex;
                while (newifCashAssets[ifCashIndex].maturity != asset.maturity) {
                    ifCashIndex += 1;
                    require(ifCashIndex < newifCashAssets.length, ""Error removing tokens"");
                }
                newifCashAssets[ifCashIndex].notional = newifCashAssets[ifCashIndex].notional.add(
                    fCash
                );
            }
        }

        return totalAssetCash;
    }

    /// @notice Sells fCash assets back into the market for cash. Negative fCash assets will decrease netAssetCash
    /// as a result. The aim here is to ensure that accounts can redeem nTokens without having to take on
    /// fCash assets.
    function _sellfCashAssets(
        CashGroupParameters memory cashGroup,
        MarketParameters[] memory markets,
        PortfolioAsset[] memory fCashAssets,
        uint256 blockTime
    ) private returns (int256, bool) {
        int256[] memory values = new int256[](2);
        uint256 fCashIndex;
        bool hasResidual;

        for (uint256 i; i < markets.length; i++) {
            while (fCashAssets[fCashIndex].maturity < markets[i].maturity) {
                // Skip an idiosyncratic fCash asset, if this happens then we know there is a residual
                // fCash asset
                fCashIndex += 1;
                hasResidual = true;
            }
            // It's not clear that this is idiosyncratic at this point but we know that this asset cannot trade
            // on this particular market.
            if (fCashAssets[fCashIndex].maturity > markets[i].maturity) continue;

            // Safety check to ensure that we only ever trade on matching markets
            require(fCashAssets[fCashIndex].maturity == markets[i].maturity); // dev: invalid maturity during trading

            if (fCashAssets[fCashIndex].notional != 0) {
                // If the notional amount is not zero then attempt to execute a trade on the asset
                (int256 netAssetCash, int256 fee) =
                    markets[i].calculateTrade(
                        cashGroup,
                        // Use the negative of fCash notional here since we want to net it out
                        fCashAssets[fCashIndex].notional.neg(),
                        fCashAssets[fCashIndex].maturity.sub(blockTime),
                        i + 1
                    );

                if (netAssetCash == 0) {
                    hasResidual = true;
                } else {
                    values[0] = values[0].add(netAssetCash);
                    values[1] = values[1].add(fee);
                    fCashAssets[fCashIndex].notional = 0;
                }
            }

            fCashIndex += 1;
        }
        BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, values[1]);

        // By the end of the for loop all fCashAssets should have been accounted for as traded, failed in trade,
        // or skipped and hasResidual is marked as true. It is not possible to have idiosyncratic fCash at a date
        // past the max market maturity since maxMarketIndex can never be reduced.
        return (values[0], hasResidual);
    }
}",2904
RealWorld_TA_23_UUPSUpgradeable_RealWorld_20240803030128.log,23,UUPSUpgradeable,56374,1670,58044,93.0,0.31527,"// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import ""../ERC1967/ERC1967Upgrade.sol"";

/**
 * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an
 * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.
 *
 * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is
 * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing
 * `UUPSUpgradeable` with a custom implementation of upgrades.
 *
 * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.
 *
 * _Available since v4.1._
 */
abstract contract UUPSUpgradeable is ERC1967Upgrade {
    /**
     * @dev Upgrade the implementation of the proxy to `newImplementation`.
     *
     * Calls {_authorizeUpgrade}.
     *
     * Emits an {Upgraded} event.
     */
    function upgradeTo(address newImplementation) external virtual {
        _authorizeUpgrade(newImplementation);
        _upgradeToAndCallSecure(newImplementation, bytes(""""), false);
    }

    /**
     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call
     * encoded in `data`.
     *
     * Calls {_authorizeUpgrade}.
     *
     * Emits an {Upgraded} event.
     */
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {
        _authorizeUpgrade(newImplementation);
        _upgradeToAndCallSecure(newImplementation, data, true);
    }

    /**
     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
     * {upgradeTo} and {upgradeToAndCall}.
     *
     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.
     *
     * ```solidity
     * function _authorizeUpgrade(address) internal override onlyOwner {}
     * ```
     */
    function _authorizeUpgrade(address newImplementation) internal virtual;
}",452
RealWorld_TA_23_LiquidatefCashAction_RealWorld_20240803063619.log,23,LiquidatefCashAction,186373,4719,191092,371.0,1.026245,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/AccountContextHandler.sol"";
import ""../../internal/liquidation/LiquidatefCash.sol"";
import ""../../internal/liquidation/LiquidationHelpers.sol"";
import ""../../math/SafeInt256.sol"";

contract LiquidatefCashAction {
    using AccountContextHandler for AccountContext;
    using AssetRate for AssetRateParameters;
    using SafeInt256 for int256;

    event LiquidatefCashEvent(
        address indexed liquidated,
        uint16 localCurrencyId,
        uint16 fCashCurrency,
        int256 netLocalFromLiquidator,
        uint256[] fCashMaturities,
        int256[] fCashNotionalTransfer
    );

    /// @notice Calculates fCash local liquidation amounts, may settle account so this can be called off chain using
    /// a static call
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency local currency to liquidate
    /// @param fCashMaturities array of fCash maturities in the local currency to purchase
    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity, zero will represent
    /// no maximum
    /// @return returns two parameters
    ///   - an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities
    ///   - amount of local currency required from the liquidator
    function calculatefCashLocalLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256) {
        uint256 blockTime = block.timestamp;
        LiquidatefCash.fCashContext memory c =
            _liquidateLocal(
                liquidateAccount,
                localCurrency,
                fCashMaturities,
                maxfCashLiquidateAmounts,
                blockTime
            );

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator);
    }

    /// @notice Liquidates fCash using local currency
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency local currency to liquidate
    /// @param fCashMaturities array of fCash maturities in the local currency to purchase
    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity, zero will represent
    /// no maximum
    /// @return returns two parameters
    ///   - an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities
    ///   - amount of local currency required from the liquidator
    function liquidatefCashLocal(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256) {
        uint256 blockTime = block.timestamp;
        LiquidatefCash.fCashContext memory c =
            _liquidateLocal(
                liquidateAccount,
                localCurrency,
                fCashMaturities,
                maxfCashLiquidateAmounts,
                blockTime
            );

        LiquidatefCash.finalizefCashLiquidation(
            liquidateAccount,
            msg.sender,
            localCurrency,
            localCurrency,
            fCashMaturities,
            c
        );

        emit LiquidatefCashEvent(
            liquidateAccount,
            uint16(localCurrency),
            uint16(localCurrency),
            c.localAssetCashFromLiquidator,
            fCashMaturities,
            c.fCashNotionalTransfers
        );

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator);
    }

    /// @notice Calculates fCash cross currency liquidation, can be called via staticcall off chain
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency local currency to liquidate
    /// @param fCashCurrency currency of fCash to purchase
    /// @param fCashMaturities array of fCash maturities in the local currency to purchase
    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity, zero will represent
    /// no maximum
    /// @return returns two parameters
    ///   - an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities
    ///   - amount of local currency required from the liquidator
    function calculatefCashCrossCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256) {
        uint256 blockTime = block.timestamp;
        LiquidatefCash.fCashContext memory c =
            _liquidateCrossCurrency(
                liquidateAccount,
                localCurrency,
                fCashCurrency,
                fCashMaturities,
                maxfCashLiquidateAmounts,
                blockTime
            );

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator);
    }

    /// @notice Liquidates fCash across local to collateral currency
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency local currency to liquidate
    /// @param fCashCurrency currency of fCash to purchase
    /// @param fCashMaturities array of fCash maturities in the local currency to purchase
    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity, zero will represent
    /// no maximum
    /// @return returns two parameters
    ///   - an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities
    ///   - amount of local currency required from the liquidator
    function liquidatefCashCrossCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256) {
        uint256 blockTime = block.timestamp;

        LiquidatefCash.fCashContext memory c =
            _liquidateCrossCurrency(
                liquidateAccount,
                localCurrency,
                fCashCurrency,
                fCashMaturities,
                maxfCashLiquidateAmounts,
                blockTime
            );

        LiquidatefCash.finalizefCashLiquidation(
            liquidateAccount,
            msg.sender,
            localCurrency,
            fCashCurrency,
            fCashMaturities,
            c
        );

        emit LiquidatefCashEvent(
            liquidateAccount,
            uint16(localCurrency),
            uint16(fCashCurrency),
            c.localAssetCashFromLiquidator,
            fCashMaturities,
            c.fCashNotionalTransfers
        );

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator);
    }

    function _liquidateLocal(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts,
        uint256 blockTime
    ) private returns (LiquidatefCash.fCashContext memory) {
        LiquidatefCash.fCashContext memory c;
        (c.accountContext, c.factors, c.portfolio) = LiquidationHelpers.preLiquidationActions(
            liquidateAccount,
            localCurrency,
            0
        );

        // prettier-ignore
        (
            int256 cashBalance,
            /* int256 nTokenBalance */,
            /* uint256 lastClaimTime */,
            /* uint256 lastClaimIntegralSupply*/
        ) = BalanceHandler.getBalanceStorage(liquidateAccount, localCurrency);
        c.localCashBalanceUnderlying = c.factors.localAssetRate.convertToUnderlying(cashBalance);
        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);

        LiquidatefCash.liquidatefCashLocal(
            liquidateAccount,
            localCurrency,
            fCashMaturities,
            maxfCashLiquidateAmounts,
            c,
            blockTime
        );

        return c;
    }

    function _liquidateCrossCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts,
        uint256 blockTime
    ) private returns (LiquidatefCash.fCashContext memory) {
        LiquidatefCash.fCashContext memory c;
        (c.accountContext, c.factors, c.portfolio) = LiquidationHelpers.preLiquidationActions(
            liquidateAccount,
            localCurrency,
            fCashCurrency
        );
        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);

        LiquidatefCash.liquidatefCashCrossCurrency(
            liquidateAccount,
            fCashCurrency,
            fCashMaturities,
            maxfCashLiquidateAmounts,
            c,
            blockTime
        );

        return c;
    }
}",2011
RealWorld_TA_23_FloatingPoint56_RealWorld_20240803045701.log,23,FloatingPoint56,47225,1471,48696,370.0,0.265545,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

import ""./Bitmap.sol"";

/**
 * Packs an uint value into a ""floating point"" storage slot. Used for storing
 * lastClaimIntegralSupply values in balance storage. For these values, we don't need
 * to maintain exact precision but we don't want to be limited by storage size overflows.
 *
 * A floating point value is defined by the 48 most significant bits and an 8 bit number
 * of bit shifts required to restore its precision. The unpacked value will always be less
 * than the packed value with a maximum absolute loss of precision of (2 ** bitShift) - 1.
 */
library FloatingPoint56 {

    function packTo56Bits(uint256 value) internal pure returns (bytes32) {
        uint256 bitShift;
        // If the value is over the uint48 max value then we will shift it down
        // given the index of the most significant bit. We store this bit shift 
        // in the least significant byte of the 56 bit slot available.
        if (value > type(uint48).max) bitShift = (Bitmap.getMSB(value) - 47);

        uint256 shiftedValue = value >> bitShift;
        return bytes32((shiftedValue << 8) | bitShift);
    }

    function unpackFrom56Bits(uint256 value) internal pure returns (uint256) {
        // The least significant 8 bits will be the amount to bit shift
        uint256 bitShift = uint256(uint8(value));
        return ((value >> 8) << bitShift);
    }

}",343
RealWorld_TA_23_MockIncentives_RealWorld_20240803023403.log,23,MockIncentives,48580,3685,52265,117.0,0.3166,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/balances/Incentives.sol"";
import ""../internal/nTokenHandler.sol"";

contract MockIncentives {
    function setNTokenParameters(
        uint16 currencyId,
        address tokenAddress,
        int256 totalSupply,
        uint32 emissionRate,
        uint32 blockTime
    ) external returns (uint256) {
        nTokenHandler.setNTokenAddress(currencyId, tokenAddress);
        nTokenHandler.setIncentiveEmissionRate(tokenAddress, emissionRate);
        return nTokenHandler.changeNTokenSupply(tokenAddress, totalSupply, blockTime);
    }

    function calculateIntegralTotalSupply(address tokenAddress, uint256 blockTime) 
        external
        view 
        returns (uint256, uint256, uint256) 
    {
        return nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);
    }

    function calculateIncentivesToClaim(
        address tokenAddress,
        uint256 nTokenBalance,
        uint256 lastClaimTime,
        uint256 lastClaimIntegralSupply,
        uint256 blockTime
    ) external view returns (uint256) {
        // prettier-ignore
        (
            /* */,
            uint256 integralTotalSupply,
            /* */
        ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);

        return
            Incentives.calculateIncentivesToClaim(
                tokenAddress,
                nTokenBalance,
                lastClaimTime,
                lastClaimIntegralSupply,
                blockTime,
                integralTotalSupply
            );
    }
}",342
RealWorld_TA_23_Router_RealWorld_20240803053421.log,23,Router,183475,4725,188200,367.0,1.011875,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./actions/nTokenAction.sol"";
import ""./actions/nTokenMintAction.sol"";
import ""./actions/nTokenRedeemAction.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""interfaces/notional/nERC1155Interface.sol"";
import ""interfaces/notional/NotionalGovernance.sol"";

/**
 * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage
 * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing
 * contracts.
 *
 * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also
 * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a
 * new Router with the new hardcoded addresses will then be deployed and upgraded into place.
 */
contract Router is StorageLayoutV1 {
    // These contract addresses cannot be changed once set by the constructor
    address public immutable GOVERNANCE;
    address public immutable VIEWS;
    address public immutable INITIALIZE_MARKET;
    address public immutable NTOKEN_ACTIONS;
    address public immutable NTOKEN_REDEEM;
    address public immutable BATCH_ACTION;
    address public immutable ACCOUNT_ACTION;
    address public immutable ERC1155;
    address public immutable LIQUIDATE_CURRENCY;
    address public immutable LIQUIDATE_FCASH;
    address public immutable cETH;

    constructor(
        address governance_,
        address views_,
        address initializeMarket_,
        address nTokenActions_,
        address nTokenRedeem_,
        address batchAction_,
        address accountAction_,
        address erc1155_,
        address liquidateCurrency_,
        address liquidatefCash_,
        address cETH_
    ) {
        GOVERNANCE = governance_;
        VIEWS = views_;
        INITIALIZE_MARKET = initializeMarket_;
        NTOKEN_ACTIONS = nTokenActions_;
        NTOKEN_REDEEM = nTokenRedeem_;
        BATCH_ACTION = batchAction_;
        ACCOUNT_ACTION = accountAction_;
        ERC1155 = erc1155_;
        LIQUIDATE_CURRENCY = liquidateCurrency_;
        LIQUIDATE_FCASH = liquidatefCash_;
        cETH = cETH_;
    }

    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {
        // Cannot re-initialize once the contract has been initialized, ownership transfer does not
        // allow address to be set back to zero
        require(owner == address(0), ""R: already initialized"");

        // Allow list currency to be called by this contract for the purposes of
        // initializing ETH as a currency
        owner = msg.sender;
        // List ETH as currency id == 1, NOTE: return value is ignored here
        (bool status, ) =
            address(GOVERNANCE).delegatecall(
                abi.encodeWithSelector(
                    NotionalGovernance.listCurrency.selector,
                    TokenStorage(cETH, false, TokenType.cETH),
                    // No underlying set for cETH
                    TokenStorage(address(0), false, TokenType.Ether),
                    address(0),
                    false,
                    130, // Initial settings of 130 buffer
                    70,  // 70% haircut
                    105  // 105 liquidation discount
                )
            );
        require(status);

        owner = owner_;
        // The pause guardian may downgrade the router to the pauseRouter
        pauseRouter = pauseRouter_;
        pauseGuardian = pauseGuardian_;
    }

    /// @notice Returns the implementation contract for the method signature
    /// @param sig method signature to call
    /// @return implementation address
    function getRouterImplementation(bytes4 sig) public view returns (address) {
        if (
            sig == NotionalProxy.batchBalanceAction.selector ||
            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||
            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector
        ) {
            return BATCH_ACTION;
        }

        if (
            sig == nTokenAction.nTokenTotalSupply.selector ||
            sig == nTokenAction.nTokenBalanceOf.selector ||
            sig == nTokenAction.nTokenTransferAllowance.selector ||
            sig == nTokenAction.nTokenTransferApprove.selector ||
            sig == nTokenAction.nTokenTransfer.selector ||
            sig == nTokenAction.nTokenTransferFrom.selector ||
            sig == nTokenAction.nTokenClaimIncentives.selector ||
            sig == nTokenAction.nTokenTransferApproveAll.selector ||
            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||
            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector
        ) {
            return NTOKEN_ACTIONS;
        }

        if (
            sig == NotionalProxy.depositUnderlyingToken.selector ||
            sig == NotionalProxy.depositAssetToken.selector ||
            sig == NotionalProxy.withdraw.selector ||
            sig == NotionalProxy.settleAccount.selector ||
            sig == NotionalProxy.enableBitmapCurrency.selector
        ) {
            return ACCOUNT_ACTION;
        }

        if (
            sig == nTokenRedeemAction.nTokenRedeem.selector ||
            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector
        ) {
            return NTOKEN_REDEEM;
        }

        if (
            sig == nERC1155Interface.supportsInterface.selector ||
            sig == nERC1155Interface.balanceOf.selector ||
            sig == nERC1155Interface.balanceOfBatch.selector ||
            sig == nERC1155Interface.safeTransferFrom.selector ||
            sig == nERC1155Interface.safeBatchTransferFrom.selector ||
            sig == nERC1155Interface.decodeToAssets.selector ||
            sig == nERC1155Interface.encodeToId.selector ||
            sig == nERC1155Interface.setApprovalForAll.selector ||
            sig == nERC1155Interface.isApprovedForAll.selector
        ) {
            return ERC1155;
        }

        if (
            sig == NotionalProxy.liquidateLocalCurrency.selector ||
            sig == NotionalProxy.liquidateCollateralCurrency.selector ||
            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||
            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector
        ) {
            return LIQUIDATE_CURRENCY;
        }

        if (
            sig == NotionalProxy.liquidatefCashLocal.selector ||
            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||
            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||
            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector
        ) {
            return LIQUIDATE_FCASH;
        }

        if (
            sig == NotionalProxy.initializeMarkets.selector ||
            sig == NotionalProxy.sweepCashIntoMarkets.selector
        ) {
            return INITIALIZE_MARKET;
        }

        if (
            sig == NotionalGovernance.listCurrency.selector ||
            sig == NotionalGovernance.enableCashGroup.selector ||
            sig == NotionalGovernance.updateCashGroup.selector ||
            sig == NotionalGovernance.updateAssetRate.selector ||
            sig == NotionalGovernance.updateETHRate.selector ||
            sig == NotionalGovernance.transferOwnership.selector ||
            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||
            sig == NotionalGovernance.updateDepositParameters.selector ||
            sig == NotionalGovernance.updateInitializationParameters.selector ||
            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||
            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||
            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||
            sig == NotionalProxy.upgradeTo.selector ||
            sig == NotionalProxy.upgradeToAndCall.selector
        ) {
            return GOVERNANCE;
        }

        // If not found then delegate to views. This will revert if there is no method on
        // the view contract
        return VIEWS;
    }

    /// @dev Delegates the current call to `implementation`.
    /// This function does not return to its internal call site, it will return directly to the external caller.
    function _delegate(address implementation) private {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    fallback() external payable {
        _delegate(getRouterImplementation(msg.sig));
    }

    // NOTE: receive() is overridden in ""nProxy"" to allow for eth transfers to succeed
}",1954
RealWorld_TA_23_AssetRateAdapter_RealWorld_20240803081512.log,23,AssetRateAdapter,32045,1613,33658,371.0,0.192485,"// SPDX-License-Identifier: GPL-v3
pragma solidity >=0.7.0;

/// @notice Used as a wrapper for tokens that are interest bearing for an
/// underlying token. Follows the cToken interface, however, can be adapted
/// for other interest bearing tokens.
interface AssetRateAdapter {
    function token() external view returns (address);

    function decimals() external view returns (uint8);

    function description() external view returns (string memory);

    function version() external view returns (uint256);

    function underlying() external view returns (address);

    function getExchangeRateStateful() external returns (int256);

    function getExchangeRateView() external view returns (int256);

    function getAnnualizedSupplyRate() external view returns (uint256);
}",160
RealWorld_TA_23_LiquidateCurrencyAction_RealWorld_20240803064837.log,23,LiquidateCurrencyAction,241085,3398,244483,370.0,1.273385,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/AccountContextHandler.sol"";
import ""../../internal/liquidation/LiquidateCurrency.sol"";
import ""../../internal/liquidation/LiquidationHelpers.sol"";
import ""../../math/SafeInt256.sol"";

contract LiquidateCurrencyAction {
    using AccountContextHandler for AccountContext;
    using BalanceHandler for BalanceState;
    using SafeInt256 for int256;

    event LiquidateLocalCurrency(
        address indexed liquidated,
        address indexed liquidator,
        uint16 localCurrencyId,
        int256 localAssetCashFromLiquidator
    );

    event LiquidateCollateralCurrency(
        address indexed liquidated,
        address indexed liquidator,
        uint16 localCurrencyId,
        uint16 collateralCurrencyId,
        int256 localAssetCashFromLiquidator,
        int256 netCollateralTransfer,
        int256 netNTokenTransfer
    );

    /// @notice Calculates the net local currency required by the liquidator. This is a stateful method
    /// because it may settle the liquidated account if required. However, it can be called using staticcall
    /// off chain to determine the net local currency required before liquidating.
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency id of the local currency
    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)
    /// @return currency transfer amounts:
    ///   - local currency required from liquidator (positive or negative)
    ///   - local nTokens paid to liquidator (positive)
    function calculateLocalCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint96 maxNTokenLiquidation
    ) external returns (int256, int256) {
        // prettier-ignore
        (
            int256 localAssetCashFromLiquidator,
            BalanceState memory localBalanceState,
            /* PortfolioState memory portfolio */,
            /* AccountContext memory accountContext */,
            /* MarketParameters[] memory markets */
        ) = _localCurrencyLiquidation(liquidateAccount, localCurrency, maxNTokenLiquidation);

        return (
            localAssetCashFromLiquidator,
            localBalanceState.netNTokenTransfer.neg()
        );
    }

    /// @notice Liquidates an account using local currency only
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency id of the local currency
    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)
    /// @return currency transfer amounts:
    ///   - local currency required from liquidator (positive or negative)
    ///   - local nTokens paid to liquidator (positive)
    function liquidateLocalCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint96 maxNTokenLiquidation
    ) external returns (int256, int256) {
        (
            int256 localAssetCashFromLiquidator,
            BalanceState memory localBalanceState,
            PortfolioState memory portfolio,
            AccountContext memory accountContext,
            MarketParameters[] memory markets
        ) = _localCurrencyLiquidation(liquidateAccount, localCurrency, maxNTokenLiquidation);

        // Transfers a positive or negative amount of local currency as well as the net nToken
        // amounts to the liquidator
        AccountContext memory liquidatorContext =
            LiquidationHelpers.finalizeLiquidatorLocal(
                msg.sender,
                localCurrency,
                localAssetCashFromLiquidator,
                localBalanceState.netNTokenTransfer.neg()
            );
        liquidatorContext.setAccountContext(msg.sender);

        LiquidateCurrency.finalizeLiquidatedCollateralAndPortfolio(
            liquidateAccount,
            localBalanceState, // In this case, local currency is the collateral
            accountContext,
            portfolio,
            markets
        );

        emit LiquidateLocalCurrency(
            liquidateAccount,
            msg.sender,
            uint16(localCurrency),
            localAssetCashFromLiquidator
        );

        return (
            localAssetCashFromLiquidator,
            localBalanceState.netNTokenTransfer.neg()
        );
    }

    /// @notice Calculates local and collateral currency transfers for a liquidation. This is a stateful method
    /// because it may settle the liquidated account if required. However, it can be called using staticcall
    /// off chain to determine the net currency amounts required before liquidating.
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency id of the local currency
    /// @param collateralCurrency id of the collateral currency
    /// @param maxCollateralLiquidation maximum amount of collateral (inclusive of cash and nTokens) to liquidate
    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)
    /// @return currency transfer amounts:
    ///   - local currency required from liquidator (negative)
    ///   - collateral asset cash paid to liquidator (positive)
    ///   - collateral nTokens paid to liquidator (positive)
    function calculateCollateralCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency,
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation
    )
        external
        returns (
            int256,
            int256,
            int256
        )
    {
        // prettier-ignore
        (
            int256 localAssetCashFromLiquidator,
            BalanceState memory collateralBalanceState,
            /* PortfolioState memory portfolio */,
            /* AccountContext memory accountContext */,
            /* MarketParameters[] memory markets */
        ) = _collateralCurrencyLiquidation(
                liquidateAccount,
                localCurrency,
                collateralCurrency,
                maxCollateralLiquidation,
                maxNTokenLiquidation
            );

        return (
            localAssetCashFromLiquidator,
            _collateralAssetCashToLiquidator(collateralBalanceState),
            collateralBalanceState.netNTokenTransfer.neg()
        );
    }

    /// @notice Liquidates an account between local and collateral currency
    /// @param liquidateAccount account to liquidate
    /// @param localCurrency id of the local currency
    /// @param collateralCurrency id of the collateral currency
    /// @param maxCollateralLiquidation maximum amount of collateral (inclusive of cash and nTokens) to liquidate
    /// @param maxNTokenLiquidation maximum amount of nTokens to purchase (if any)
    /// @param withdrawCollateral if true, withdraws collateral back to msg.sender
    /// @param redeemToUnderlying if true, converts collateral from asset cash to underlying
    /// @return currency transfer amounts:
    ///   - local currency required from liquidator (negative)
    ///   - collateral asset cash paid to liquidator (positive)
    ///   - collateral nTokens paid to liquidator (positive)
    function liquidateCollateralCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency,
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation,
        bool withdrawCollateral,
        bool redeemToUnderlying
    )
        external
        returns (
            int256,
            int256,
            int256
        )
    {
        (
            int256 localAssetCashFromLiquidator,
            BalanceState memory collateralBalanceState,
            PortfolioState memory portfolio,
            AccountContext memory accountContext,
            MarketParameters[] memory markets
        ) =
            _collateralCurrencyLiquidation(
                liquidateAccount,
                localCurrency,
                collateralCurrency,
                maxCollateralLiquidation,
                maxNTokenLiquidation
            );

        _finalizeLiquidatorBalances(
            localCurrency,
            collateralCurrency,
            localAssetCashFromLiquidator,
            collateralBalanceState,
            withdrawCollateral,
            redeemToUnderlying
        );

        _emitCollateralEvent(
            liquidateAccount,
            uint16(localCurrency),
            localAssetCashFromLiquidator,
            collateralBalanceState
        );

        // Liquidated local currency balance will increase by the net paid from the liquidator
        LiquidationHelpers.finalizeLiquidatedLocalBalance(
            liquidateAccount,
            localCurrency,
            accountContext,
            localAssetCashFromLiquidator
        );

        // netAssetTransfer is cleared and set back when finalizing inside this function
        LiquidateCurrency.finalizeLiquidatedCollateralAndPortfolio(
            liquidateAccount,
            collateralBalanceState,
            accountContext,
            portfolio,
            markets
        );

        return (
            localAssetCashFromLiquidator,
            _collateralAssetCashToLiquidator(collateralBalanceState),
            collateralBalanceState.netNTokenTransfer.neg()
        );
    }

    function _emitCollateralEvent(
        address liquidateAccount,
        uint256 localCurrency,
        int256 localAssetCashFromLiquidator,
        BalanceState memory collateralBalanceState
    ) private {
        emit LiquidateCollateralCurrency(
            liquidateAccount,
            msg.sender,
            uint16(localCurrency),
            uint16(collateralBalanceState.currencyId),
            localAssetCashFromLiquidator,
            _collateralAssetCashToLiquidator(collateralBalanceState),
            collateralBalanceState.netNTokenTransfer.neg()
        );
    }

    function _localCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint96 maxNTokenLiquidation
    )
        private
        returns (
            int256,
            BalanceState memory,
            PortfolioState memory,
            AccountContext memory,
            MarketParameters[] memory markets
        )
    {
        uint256 blockTime = block.timestamp;
        (
            AccountContext memory accountContext,
            LiquidationFactors memory factors,
            PortfolioState memory portfolio
        ) = LiquidationHelpers.preLiquidationActions(liquidateAccount, localCurrency, 0);
        BalanceState memory localBalanceState;
        localBalanceState.loadBalanceState(liquidateAccount, localCurrency, accountContext);

        int256 localAssetCashFromLiquidator =
            LiquidateCurrency.liquidateLocalCurrency(
                localCurrency,
                maxNTokenLiquidation,
                blockTime,
                localBalanceState,
                factors,
                portfolio
            );

        return (
            localAssetCashFromLiquidator,
            localBalanceState,
            portfolio,
            accountContext,
            factors.markets
        );
    }

    function _collateralCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency,
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation
    )
        private
        returns (
            int256,
            BalanceState memory,
            PortfolioState memory,
            AccountContext memory,
            MarketParameters[] memory markets
        )
    {
        uint256 blockTime = block.timestamp;
        (
            AccountContext memory accountContext,
            LiquidationFactors memory factors,
            PortfolioState memory portfolio
        ) =
            LiquidationHelpers.preLiquidationActions(
                liquidateAccount,
                localCurrency,
                collateralCurrency
            );

        BalanceState memory collateralBalanceState;
        collateralBalanceState.loadBalanceState(
            liquidateAccount,
            collateralCurrency,
            accountContext
        );

        int256 localAssetCashFromLiquidator =
            LiquidateCurrency.liquidateCollateralCurrency(
                maxCollateralLiquidation,
                maxNTokenLiquidation,
                blockTime,
                collateralBalanceState,
                factors,
                portfolio
            );

        return (
            localAssetCashFromLiquidator,
            collateralBalanceState,
            portfolio,
            accountContext,
            factors.markets
        );
    }

    /// @dev Only used for collateral currency liquidation
    function _finalizeLiquidatorBalances(
        uint256 localCurrency,
        uint256 collateralCurrency,
        int256 localAssetCashFromLiquidator,
        BalanceState memory collateralBalanceState,
        bool withdrawCollateral,
        bool redeemToUnderlying
    ) private {
        // Will transfer local currency from the liquidator
        AccountContext memory liquidatorContext =
            LiquidationHelpers.finalizeLiquidatorLocal(
                msg.sender,
                localCurrency,
                localAssetCashFromLiquidator,
                0 // No nToken transfers
            );

        // Will transfer collateral to the liquidator
        LiquidationHelpers.finalizeLiquidatorCollateral(
            msg.sender,
            liquidatorContext,
            collateralCurrency,
            _collateralAssetCashToLiquidator(collateralBalanceState),
            collateralBalanceState.netNTokenTransfer.neg(),
            withdrawCollateral,
            redeemToUnderlying
        );

        liquidatorContext.setAccountContext(msg.sender);
    }

    function _collateralAssetCashToLiquidator(BalanceState memory collateralBalanceState)
        private
        pure
        returns (int256)
    {
        return
            collateralBalanceState.netCashChange.neg().add(
                collateralBalanceState.netAssetTransferInternalPrecision
            );
    }
}",2670
RealWorld_TA_23_Views_RealWorld_20240803052802.log,23,Views,344929,4401,349330,377.0,1.812665,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../external/FreeCollateralExternal.sol"";
import ""./actions/nTokenMintAction.sol"";
import ""../internal/valuation/ExchangeRate.sol"";
import ""../internal/markets/CashGroup.sol"";
import ""../internal/markets/AssetRate.sol"";
import ""../internal/nTokenHandler.sol"";
import ""../internal/balances/TokenHandler.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""../math/SafeInt256.sol"";
import ""@openzeppelin/contracts/utils/SafeCast.sol"";
import ""interfaces/notional/NotionalViews.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract Views is StorageLayoutV1, NotionalViews {
    using CashGroup for CashGroupParameters;
    using TokenHandler for Token;
    using Market for MarketParameters;
    using AssetRate for AssetRateParameters;
    using SafeInt256 for int256;
    using SafeMath for uint256;
    using BalanceHandler for BalanceState;

    /** Governance Parameter Getters **/

    /// @notice Returns the current maximum currency id
    function getMaxCurrencyId() external view override returns (uint16) {
        return maxCurrencyId;
    }

    /// @notice Returns a currency id, a zero means that it is not listed.
    function getCurrencyId(address tokenAddress)
        external
        view
        override
        returns (uint16 currencyId)
    {
        currencyId = tokenAddressToCurrencyId[tokenAddress];
    }

    /// @notice Returns the asset token and underlying token related to a given currency id. If underlying
    /// token is not set then will return the zero address
    function getCurrency(uint16 currencyId)
        external
        view
        override
        returns (Token memory assetToken, Token memory underlyingToken)
    {
        assetToken = TokenHandler.getToken(currencyId, false);
        underlyingToken = TokenHandler.getToken(currencyId, true);
    }

    /// @notice Returns the ETH and Asset rates for a currency as stored, useful for viewing how they are configured
    function getRateStorage(uint16 currencyId)
        external
        view
        override
        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate)
    {
        ethRate = underlyingToETHRateMapping[currencyId];
        assetRate = assetToUnderlyingRateMapping[currencyId];
    }

    /// @notice Returns a currency and its corresponding asset rate and ETH exchange rates. Note that this does not recalculate
    /// cToken interest rates, it only retrieves the latest stored rate.
    function getCurrencyAndRates(uint16 currencyId)
        external
        view
        override
        returns (
            Token memory assetToken,
            Token memory underlyingToken,
            ETHRate memory ethRate,
            AssetRateParameters memory assetRate
        )
    {
        assetToken = TokenHandler.getToken(currencyId, false);
        underlyingToken = TokenHandler.getToken(currencyId, false);
        ethRate = ExchangeRate.buildExchangeRate(currencyId);
        assetRate = AssetRate.buildAssetRateView(currencyId);
    }

    /// @notice Returns cash group settings for a currency
    function getCashGroup(uint16 currencyId)
        external
        view
        override
        returns (CashGroupSettings memory)
    {
        return CashGroup.deserializeCashGroupStorage(currencyId);
    }

    /// @notice Returns the cash group along with the asset rate for convenience.
    function getCashGroupAndAssetRate(uint16 currencyId)
        external
        view
        override
        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate)
    {
        cashGroup = CashGroup.deserializeCashGroupStorage(currencyId);
        assetRate = AssetRate.buildAssetRateView(currencyId);
    }

    /// @notice Returns market initialization parameters for a given currency
    function getInitializationParameters(uint16 currencyId)
        external
        view
        override
        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)
    {
        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);
        (annualizedAnchorRates, proportions) = nTokenHandler.getInitializationParameters(
            currencyId,
            maxMarketIndex
        );
    }

    /// @notice Returns nToken deposit parameters for a given currency
    function getDepositParameters(uint16 currencyId)
        external
        view
        override
        returns (int256[] memory depositShares, int256[] memory leverageThresholds)
    {
        uint256 maxMarketIndex = CashGroup.getMaxMarketIndex(currencyId);
        (depositShares, leverageThresholds) = nTokenHandler.getDepositParameters(
            currencyId,
            maxMarketIndex
        );
    }

    /// @notice Returns nToken address for a given currency
    function nTokenAddress(uint16 currencyId) external view override returns (address) {
        return nTokenHandler.nTokenAddress(currencyId);
    }

    /// @notice Returns address of contract owner
    function getOwner() external view override returns (address) {
        return owner;
    }

    /** Global System State View Methods **/

    /// @notice Returns the asset settlement rate for a given maturity
    function getSettlementRate(uint16 currencyId, uint40 maturity)
        external
        view
        override
        returns (AssetRateParameters memory)
    {
        return AssetRate.buildSettlementRateView(currencyId, maturity);
    }

    /// @notice Returns all currently active markets for a currency
    function getActiveMarkets(uint16 currencyId)
        external
        view
        override
        returns (MarketParameters[] memory)
    {
        uint256 blockTime = block.timestamp;
        return _getActiveMarketsAtBlockTime(currencyId, blockTime);
    }

    /// @notice Returns all active markets for a currency at the specified block time, useful for looking
    /// at historical markets
    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)
        external
        view
        override
        returns (MarketParameters[] memory)
    {
        return _getActiveMarketsAtBlockTime(currencyId, blockTime);
    }

    function _getActiveMarketsAtBlockTime(uint256 currencyId, uint256 blockTime)
        internal
        view
        returns (MarketParameters[] memory)
    {
        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);
        MarketParameters[] memory markets = new MarketParameters[](cashGroup.maxMarketIndex);

        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {
            cashGroup.loadMarket(markets[i], i + 1, true, blockTime);
        }

        return markets;
    }

    /// @notice Returns the current reserve balance for a currency
    function getReserveBalance(uint16 currencyId)
        external
        view
        override
        returns (int256 reserveBalance)
    {
        // prettier-ignore
        (
            reserveBalance,
            /* */,
            /* */,
            /* */
        ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);
    }

    function getNTokenPortfolio(address tokenAddress)
        external
        view
        override
        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets)
    {
        // prettier-ignore
        (
            uint256 currencyId,
            /* incentiveRate */,
            uint256 lastInitializedTime,
            bytes6 parameters
        ) = nTokenHandler.getNTokenContext(tokenAddress);

        liquidityTokens = PortfolioHandler.getSortedPortfolio(
            tokenAddress,
            uint8(parameters[Constants.ASSET_ARRAY_LENGTH])
        );

        netfCashAssets = BitmapAssetsHandler.getifCashArray(
            tokenAddress,
            currencyId,
            lastInitializedTime
        );
    }

    function getNTokenAccount(address tokenAddress)
        external
        view
        override
        returns (
            uint256 currencyId,
            uint256 totalSupply,
            uint256 incentiveAnnualEmissionRate,
            uint256 lastInitializedTime,
            bytes6 nTokenParameters,
            int256 cashBalance,
            uint256 integralTotalSupply,
            uint256 lastSupplyChangeTime
        )
    {
        (
            currencyId,
            incentiveAnnualEmissionRate,
            lastInitializedTime,
            nTokenParameters
        ) = nTokenHandler.getNTokenContext(tokenAddress);

        // prettier-ignore
        (
            totalSupply,
            integralTotalSupply,
            lastSupplyChangeTime
        ) = nTokenHandler.getStoredNTokenSupplyFactors(tokenAddress);

        // prettier-ignore
        (
            cashBalance,
            /* */,
            /* */,
            /* */
        ) = BalanceHandler.getBalanceStorage(tokenAddress, currencyId);
    }

    /** Account Specific View Methods **/

    /// @notice Returns all account details in a single view
    function getAccount(address account)
        external
        view
        override
        returns (
            AccountContext memory accountContext,
            AccountBalance[] memory accountBalances,
            PortfolioAsset[] memory portfolio
        )
    {
        accountContext = AccountContextHandler.getAccountContext(account);
        accountBalances = new AccountBalance[](10);

        uint256 i;
        if (accountContext.bitmapCurrencyId != 0) {
            (
                accountBalances[i].cashBalance,
                accountBalances[i].nTokenBalance,
                accountBalances[i].lastClaimTime,
                accountBalances[i].lastClaimIntegralSupply
            ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);
            i += 1;
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            accountBalances[i].currencyId = uint256(
                uint16(bytes2(currencies) & Constants.UNMASK_FLAGS)
            );
            if (accountBalances[i].currencyId == 0) break;

            (
                accountBalances[i].cashBalance,
                accountBalances[i].nTokenBalance,
                accountBalances[i].lastClaimTime,
                accountBalances[i].lastClaimIntegralSupply
            ) = BalanceHandler.getBalanceStorage(account, accountBalances[i].currencyId);
            i += 1;
            currencies = currencies << 16;
        }

        if (accountContext.bitmapCurrencyId != 0) {
            portfolio = BitmapAssetsHandler.getifCashArray(
                account,
                accountContext.bitmapCurrencyId,
                accountContext.nextSettleTime
            );
        } else {
            portfolio = PortfolioHandler.getSortedPortfolio(
                account,
                accountContext.assetArrayLength
            );
        }
    }

    /// @notice Returns account context
    function getAccountContext(address account)
        external
        view
        override
        returns (AccountContext memory)
    {
        return AccountContextHandler.getAccountContext(account);
    }

    /// @notice Returns account balances for a given currency
    function getAccountBalance(uint16 currencyId, address account)
        external
        view
        override
        returns (
            int256 cashBalance,
            int256 nTokenBalance,
            uint256 lastClaimTime
        )
    {
        // prettier-ignore
        (
            cashBalance,
            nTokenBalance,
            lastClaimTime,
            /* */
        ) = BalanceHandler.getBalanceStorage(account, currencyId);
    }

    /// @notice Returns account portfolio of assets
    function getAccountPortfolio(address account)
        external
        view
        override
        returns (PortfolioAsset[] memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.bitmapCurrencyId != 0) {
            return
                BitmapAssetsHandler.getifCashArray(
                    account,
                    accountContext.bitmapCurrencyId,
                    accountContext.nextSettleTime
                );
        } else {
            return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);
        }
    }

    /// @notice Returns the fCash amount at the specified maturity for a bitmapped portfolio
    function getfCashNotional(
        address account,
        uint256 currencyId,
        uint256 maturity
    ) external view override returns (int256) {
        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);
    }

    /// @notice Returns the assets bitmap for an account
    function getAssetsBitmap(address account, uint256 currencyId)
        external
        view
        override
        returns (bytes32)
    {
        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);
    }

    /// @notice Returns free collateral of an account along with an array of the individual net available
    /// asset cash amounts
    function getFreeCollateral(address account)
        external
        view
        override
        returns (int256, int256[] memory)
    {
        return FreeCollateralExternal.getFreeCollateralView(account);
    }

    /** General Calculation View Methods **/

    /// @notice Returns the nTokens that will be minted when some amount of asset tokens are deposited
    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)
        external
        view
        override
        returns (uint256)
    {
        Token memory token = TokenHandler.getToken(currencyId, false);
        int256 amountToDepositInternal =
            token.convertToInternal(int256(amountToDepositExternalPrecision));
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);

        // prettier-ignore
        (
            int256 tokensToMint,
            /* */
        ) = nTokenMintAction.calculateTokensToMint(
            nToken,
            amountToDepositInternal,
            block.timestamp
        );

        return SafeCast.toUint256(tokensToMint);
    }

    /// @notice Returns the fCash amount to send when given a cash amount, be sure to buffer these amounts
    /// slightly because the liquidity curve is sensitive to changes in block time
    function getfCashAmountGivenCashAmount(
        uint16 currencyId,
        int88 netCashToAccount,
        uint256 marketIndex,
        uint256 blockTime
    ) external view override returns (int256) {
        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);
        MarketParameters memory market;
        cashGroup.loadMarket(market, marketIndex, false, blockTime);

        require(market.maturity > blockTime, ""Invalid block time"");
        uint256 timeToMaturity = market.maturity - blockTime;
        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =
            Market.getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);
        int256 fee = Market.getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);

        return
            Market.getfCashGivenCashAmount(
                market.totalfCash,
                int256(netCashToAccount),
                totalCashUnderlying,
                rateScalar,
                rateAnchor,
                fee,
                0
            );
    }

    /// @notice Returns the cash amount that will be traded given an fCash amount, be sure to buffer these amounts
    /// slightly because the liquidity curve is sensitive to changes in block time
    function getCashAmountGivenfCashAmount(
        uint16 currencyId,
        int88 fCashAmount,
        uint256 marketIndex,
        uint256 blockTime
    ) external view override returns (int256, int256) {
        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupView(currencyId);
        MarketParameters memory market;
        cashGroup.loadMarket(market, marketIndex, false, blockTime);

        require(market.maturity > blockTime, ""Invalid block time"");
        uint256 timeToMaturity = market.maturity - blockTime;

        // prettier-ignore
        (int256 assetCash, /* int fee */) =
            market.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);

        return (assetCash, cashGroup.assetRate.convertToUnderlying(assetCash));
    }

    /// @notice Returns the claimable incentives for all nToken balances
    /// @param account The address of the account which holds the tokens
    /// @param blockTime The block time when incentives will be minted
    /// @return Incentives an account is eligible to claim
    function nTokenGetClaimableIncentives(address account, uint256 blockTime)
        external
        view
        override
        returns (uint256)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        BalanceState memory balanceState;
        uint256 totalIncentivesClaimable;

        if (accountContext.bitmapCurrencyId != 0) {
            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);

                // prettier-ignore
                (
                    /* totalSupply */,
                    uint256 integralTotalSupply,
                    /* lastSupplyChangeTime */
                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);

                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(
                    tokenAddress,
                    uint256(balanceState.storedNTokenBalance),
                    balanceState.lastClaimTime,
                    balanceState.lastClaimIntegralSupply,
                    blockTime,
                    integralTotalSupply
                );
                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);
            }
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));
            balanceState.loadBalanceState(account, currencyId, accountContext);

            if (balanceState.storedNTokenBalance > 0) {
                address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);

                (
                    /* totalSupply */,
                    uint256 integralTotalSupply,
                    /* lastSupplyChangeTime */
                ) = nTokenHandler.calculateIntegralTotalSupply(tokenAddress, blockTime);

                uint256 incentivesToClaim = Incentives.calculateIncentivesToClaim(
                    nTokenHandler.nTokenAddress(balanceState.currencyId),
                    uint256(balanceState.storedNTokenBalance),
                    balanceState.lastClaimTime,
                    balanceState.lastClaimIntegralSupply,
                    blockTime,
                    integralTotalSupply
                );
                totalIncentivesClaimable = totalIncentivesClaimable.add(incentivesToClaim);
            }

            currencies = currencies << 16;
        }

        return totalIncentivesClaimable;
    }

    fallback() external {
        revert(""Method not found"");
    }
}",3906
RealWorld_TA_23_MockCToken_RealWorld_20240803022707.log,23,MockCToken,41236,3280,44516,109.0,0.27178,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

contract MockCToken {
    uint private _answer;
    uint private _supplyRate;
    uint8 public decimals;
    address public underlying;
    string public symbol = ""cMock"";
    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    constructor(uint8 _decimals) {
        decimals = _decimals;
    }

    function setUnderlying(address underlying_) external {
        underlying = underlying_;
    }

    function setAnswer(uint a) external {
        _answer = a;
    }

    function setSupplyRate(uint a) external {
        _supplyRate = a;
    }

    function exchangeRateCurrent() external returns (uint) {
        // This is here to test if we've called the right function
        emit AccrueInterest(0, 0, 0, 0);
        return _answer;
    }

    function exchangeRateStored() external view returns (uint) {
        return _answer;
    }

    function supplyRatePerBlock() external view returns (uint) {
        return _supplyRate;
    }
}",251
RealWorld_TA_23_nERC1155Interface_RealWorld_20240803084002.log,23,nERC1155Interface,51633,1976,53609,369.0,0.297685,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../contracts/global/Types.sol"";
import ""@openzeppelin/contracts/introspection/IERC165.sol"";

interface nERC1155Interface is IERC165 {
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    /// @dev Return value is overridden to be int256 here
    function balanceOf(address account, uint256 id) external view returns (int256);

    /// @dev Return value is overridden to be int256 here
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (int256[] memory);

    function setApprovalForAll(address operator, bool approved) external;

    function isApprovedForAll(address account, address operator) external view returns (bool);

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external payable;

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;

    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)
        external
        view
        returns (PortfolioAsset[] memory);

    function encodeToId(
        uint16 currencyId,
        uint40 maturity,
        uint8 assetType
    ) external pure returns (uint256 id);
}",410
RealWorld_TA_23_SettleAssetsExternal_RealWorld_20240803054030.log,23,SettleAssetsExternal,94413,3343,97756,367.0,0.538925,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/portfolio/PortfolioHandler.sol"";
import ""../internal/balances/BalanceHandler.sol"";
import ""../internal/settlement/SettlePortfolioAssets.sol"";
import ""../internal/settlement/SettleBitmapAssets.sol"";
import ""../internal/AccountContextHandler.sol"";

/// @notice External library for settling assets, presents different options for calling methods
/// depending on their data requirements. Note that bitmapped portfolios will always be settled
/// and an empty portfolio state will be returned.
library SettleAssetsExternal {
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;
    event AccountSettled(address indexed account);

    function settleAssetsAndFinalize(
        address account,
        AccountContext memory accountContext
    ) external returns (AccountContext memory) {
        _settleAccount(account, accountContext, true, true);
        return accountContext;
    }

    function settleAssetsAndStorePortfolio(
        address account,
        AccountContext memory accountContext
    ) external returns (AccountContext memory, SettleAmount[] memory) {
        // prettier-ignore
        (
            SettleAmount[] memory settleAmounts,
            /* PortfolioState memory portfolioState */
        ) = _settleAccount(account, accountContext, false, true);

        return (accountContext, settleAmounts);
    }

    function settleAssetsAndReturnPortfolio(
        address account,
        AccountContext memory accountContext
    ) external returns (AccountContext memory, PortfolioState memory) {
        // prettier-ignore
        (
            /* SettleAmount[] memory settleAmounts */,
            PortfolioState memory portfolioState
        ) = _settleAccount(account, accountContext, true, false);

        return (accountContext, portfolioState);
    }

    function settleAssetsAndReturnAll(
        address account,
        AccountContext memory accountContext
    ) external returns (
        AccountContext memory,
        SettleAmount[] memory,
        PortfolioState memory
    ) {
        (
            SettleAmount[] memory settleAmounts,
            PortfolioState memory portfolioState
        ) = _settleAccount(account, accountContext, false, false);
        return (accountContext, settleAmounts, portfolioState);
    }

    function _settleAccount(
        address account,
        AccountContext memory accountContext,
        bool finalizeAmounts,
        bool finalizePortfolio
    )
        private
        returns (
            SettleAmount[] memory,
            PortfolioState memory
        )
    {
        SettleAmount[] memory settleAmounts;
        PortfolioState memory portfolioState;

        if (accountContext.bitmapCurrencyId != 0) {
            settleAmounts = _settleBitmappedAccountStateful(account, accountContext);
        } else {
            portfolioState = PortfolioHandler.buildPortfolioState(
                account,
                accountContext.assetArrayLength,
                0
            );
            settleAmounts = SettlePortfolioAssets.settlePortfolio(portfolioState, block.timestamp);

            if (finalizePortfolio) {
                accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);
            }
        }

        if (finalizeAmounts) {
            BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);
        }

        emit AccountSettled(account);

        return (settleAmounts, portfolioState);
    }

    function _settleBitmappedAccountStateful(
        address account,
        AccountContext memory accountContext
    ) private returns (SettleAmount[] memory) {
        (bytes32 assetsBitmap, int256 settledCash, uint256 blockTimeUTC0) =
            SettleBitmapAssets.settleBitmappedCashGroup(
                account,
                accountContext.bitmapCurrencyId,
                accountContext.nextSettleTime,
                block.timestamp
            );
        require(blockTimeUTC0 < type(uint40).max); // dev: block time utc0 overflow
        accountContext.nextSettleTime = uint40(blockTimeUTC0);

        BitmapAssetsHandler.setAssetsBitmap(account, accountContext.bitmapCurrencyId, assetsBitmap);
        SettleAmount[] memory settleAmounts = new SettleAmount[](1);
        settleAmounts[0].currencyId = accountContext.bitmapCurrencyId;
        settleAmounts[0].netCashChange = settledCash;
        return settleAmounts;
    }
}",900
RealWorld_TA_23_NotionalViews_RealWorld_20240803084613.log,23,NotionalViews,93030,1552,94582,368.0,0.49619,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../contracts/global/Types.sol"";

interface NotionalViews {
    function getMaxCurrencyId() external view returns (uint16);

    function getCurrencyId(address tokenAddress) external view returns (uint16 currencyId);

    function getCurrency(uint16 currencyId)
        external
        view
        returns (Token memory assetToken, Token memory underlyingToken);

    function getRateStorage(uint16 currencyId)
        external
        view
        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate);

    function getCurrencyAndRates(uint16 currencyId)
        external
        view
        returns (
            Token memory assetToken,
            Token memory underlyingToken,
            ETHRate memory ethRate,
            AssetRateParameters memory assetRate
        );

    function getCashGroup(uint16 currencyId) external view returns (CashGroupSettings memory);

    function getCashGroupAndAssetRate(uint16 currencyId)
        external
        view
        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate);

    function getInitializationParameters(uint16 currencyId)
        external
        view
        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions);

    function getDepositParameters(uint16 currencyId)
        external
        view
        returns (int256[] memory depositShares, int256[] memory leverageThresholds);

    function nTokenAddress(uint16 currencyId) external view returns (address);

    function getOwner() external view returns (address);

    function getSettlementRate(uint16 currencyId, uint40 maturity)
        external
        view
        returns (AssetRateParameters memory);

    function getActiveMarkets(uint16 currencyId) external view returns (MarketParameters[] memory);

    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)
        external
        view
        returns (MarketParameters[] memory);

    function getReserveBalance(uint16 currencyId) external view returns (int256 reserveBalance);

    function getNTokenPortfolio(address tokenAddress)
        external
        view
        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets);

    function getNTokenAccount(address tokenAddress)
        external
        view
        returns (
            uint256 currencyId,
            uint256 totalSupply,
            uint256 incentiveAnnualEmissionRate,
            uint256 lastInitializedTime,
            bytes6 nTokenParameters,
            int256 cashBalance,
            uint256 integralTotalSupply,
            uint256 lastSupplyChangeTime
        );

    function getAccount(address account)
        external
        view
        returns (
            AccountContext memory accountContext,
            AccountBalance[] memory accountBalances,
            PortfolioAsset[] memory portfolio
        );

    function getAccountContext(address account) external view returns (AccountContext memory);

    function getAccountBalance(uint16 currencyId, address account)
        external
        view
        returns (
            int256 cashBalance,
            int256 nTokenBalance,
            uint256 lastClaimTime
        );

    function getAccountPortfolio(address account) external view returns (PortfolioAsset[] memory);

    function getfCashNotional(
        address account,
        uint256 currencyId,
        uint256 maturity
    ) external view returns (int256);

    function getAssetsBitmap(address account, uint256 currencyId) external view returns (bytes32);

    function getFreeCollateral(address account) external view returns (int256, int256[] memory);

    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)
        external
        view
        returns (uint256);

    function getfCashAmountGivenCashAmount(
        uint16 currencyId,
        int88 netCashToAccount,
        uint256 marketIndex,
        uint256 blockTime
    ) external view returns (int256);

    function getCashAmountGivenfCashAmount(
        uint16 currencyId,
        int88 fCashAmount,
        uint256 marketIndex,
        uint256 blockTime
    ) external view returns (int256, int256);

    function nTokenGetClaimableIncentives(address account, uint256 blockTime)
        external
        view
        returns (uint256);

}",894
RealWorld_TA_23_nTokenAction_RealWorld_20240803071333.log,23,nTokenAction,211990,4131,216121,357.0,1.14257,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/nTokenHandler.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/balances/Incentives.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""interfaces/notional/nTokenERC20.sol"";
import ""@openzeppelin/contracts/utils/SafeCast.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract nTokenAction is StorageLayoutV1, nTokenERC20 {
    using BalanceHandler for BalanceState;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using SafeInt256 for int256;
    using SafeMath for uint256;

    /// @notice Total number of tokens in circulation
    /// @param nTokenAddress The address of the nToken
    /// @return totalSupply number of tokens held
    function nTokenTotalSupply(address nTokenAddress)
        external
        view
        override
        returns (uint256 totalSupply)
    {
        // prettier-ignore
        (
            totalSupply,
            /* integralTotalSupply */,
            /* lastSupplyChangeTime */
        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);
    }

    /// @notice Get the number of tokens held by the `account`
    /// @param account The address of the account to get the balance of
    /// @return The number of tokens held
    function nTokenBalanceOf(uint16 currencyId, address account)
        external
        view
        override
        returns (uint256)
    {
        // prettier-ignore
        (
            /* int cashBalance */,
            int256 nTokenBalance,
            /* uint lastClaimTime */,
            /* uint lastClaimIntegralSupply */
        ) = BalanceHandler.getBalanceStorage(account, currencyId);

        require(nTokenBalance >= 0); // dev: negative nToken balance
        return uint256(nTokenBalance);
    }

    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
    /// @param owner The address of the account holding the funds
    /// @param spender The address of the account spending the funds
    /// @return The number of tokens approved
    function nTokenTransferAllowance(
        uint16 currencyId,
        address owner,
        address spender
    ) external view override returns (uint256) {
        // This whitelist allowance supersedes any specific allowances
        uint256 allowance = nTokenWhitelist[owner][spender];
        if (allowance > 0) return allowance;

        return nTokenAllowance[owner][spender][currencyId];
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev Can only be called via the nToken proxy
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function nTokenTransferApprove(
        uint16 currencyId,
        address owner,
        address spender,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        nTokenAllowance[owner][spender][currencyId] = amount;

        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @dev Can only be called via the nToken proxy
    /// @param from The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function nTokenTransfer(
        uint16 currencyId,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        return _transfer(currencyId, from, to, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @dev Can only be called via the nToken proxy
    /// @param currencyId Currency id of the nToken
    /// @param spender The address of the original caller
    /// @param from The address of the source account
    /// @param to The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function nTokenTransferFrom(
        uint16 currencyId,
        address spender,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool, uint256) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        uint256 allowance = nTokenWhitelist[from][spender];

        if (allowance > 0) {
            // This whitelist allowance supersedes any specific allowances
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenWhitelist[from][spender] = allowance;
        } else {
            // This is the specific allowance for the nToken.
            allowance = nTokenAllowance[from][spender][currencyId];
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenAllowance[from][spender][currencyId] = allowance;
        }

        bool success = _transfer(currencyId, from, to, amount);
        return (success, allowance);
    }

    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve
    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly
    /// on the Notional contract, not available via the ERC20 proxy.
    /// @dev emit:Approval
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function nTokenTransferApproveAll(address spender, uint256 amount)
        external
        override
        returns (bool)
    {
        nTokenWhitelist[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender
    /// @dev auth:msg.sender
    /// @return Total amount of incentives claimed
    function nTokenClaimIncentives() external override returns (uint256) {
        address account = msg.sender;
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        uint256 totalIncentivesClaimed;
        BalanceState memory balanceState;

        if (accountContext.bitmapCurrencyId != 0) {
            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));

            balanceState.loadBalanceState(account, currencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }

            currencies = currencies << 16;
        }

        // NOTE: no need to set account context after claiming incentives
        return totalIncentivesClaimed;
    }

    /// @notice Returns the present value of the nToken's assets denominated in asset tokens
    function nTokenPresentValueAssetDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        // prettier-ignore
        (
            int256 totalAssetPV,
            /* portfolio */
        ) = _getNTokenPV(currencyId);

        return totalAssetPV;
    }

    /// @notice Returns the present value of the nToken's assets denominated in underlying
    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);

        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);
    }

    function _getNTokenPV(uint256 currencyId)
        private
        view
        returns (int256, nTokenPortfolio memory)
    {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);

        // prettier-ignore
        (
            int256 totalAssetPV,
            /* ifCashMapping */
        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);

        return (totalAssetPV, nToken);
    }

    /// @notice Transferring tokens will also claim incentives at the same time
    function _transfer(
        uint256 currencyId,
        address sender,
        address recipient,
        uint256 amount
    ) internal returns (bool) {
        {
            // prettier-ignore
            (
                uint256 isNToken,
                /* incentiveAnnualEmissionRate */,
                /* lastInitializedTime */,
                /* parameters */
            ) = nTokenHandler.getNTokenContext(recipient);
            // nTokens cannot hold nToken balances
            require(isNToken == 0, ""Cannot transfer to nToken"");
        }

        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);
        BalanceState memory senderBalance;
        senderBalance.loadBalanceState(sender, currencyId, senderContext);

        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);
        BalanceState memory recipientBalance;
        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);

        int256 amountInt = SafeCast.toInt256(amount);
        senderBalance.netNTokenTransfer = amountInt.neg();
        recipientBalance.netNTokenTransfer = amountInt;

        senderBalance.finalize(sender, senderContext, false);
        recipientBalance.finalize(recipient, recipientContext, false);
        senderContext.setAccountContext(sender);
        recipientContext.setAccountContext(recipient);

        emit Transfer(sender, recipient, amount);

        return true;
    }
}",2309
RealWorld_TA_23_ABDKMath64x64_RealWorld_20240803050933.log,23,ABDKMath64x64,421903,1690,423593,367.0,2.143315,"// SPDX-License-Identifier: BSD-4-Clause
/**
 * ABDK Math 64.64 Smart Contract Library.    Copyright © 2019 by ABDK Consulting.
 * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>
 */
pragma solidity ^0.7.0;

/**
 * Smart contract library of mathematical functions operating with signed
 * 64.64-bit fixed point numbers.    Signed 64.64-bit fixed point number is
 * basically a simple fraction whose numerator is signed 128-bit integer and
 * denominator is 2^64.    As long as denominator is always the same, there is no
 * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are
 * represented by int128 type holding only the numerator.
 */
library ABDKMath64x64 {
    /* Minimum value signed 64.64-bit fixed point number may have. */
    int128 internal constant MIN_64x64 = -0x80000000000000000000000000000000;

    /* Maximum value signed 64.64-bit fixed point number may have. */
    int128 internal constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    /// Convert signed 256-bit integer number into signed 64.64-bit fixed point
    /// number.    Revert on overflow.
    /// @param x signed 256-bit integer number
    /// @return signed 64.64-bit fixed point number
    function fromInt(int256 x) internal pure returns (int128) {
        require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF); // dev: abdk int256 overflow
        return int128(x << 64);
    }

    /// Convert signed 64.64 fixed point number into signed 64-bit integer number
    /// rounding down.
    /// @param x signed 64.64-bit fixed point number
    /// @return signed 64-bit integer number
    function toInt(int128 x) internal pure returns (int64) {
        return int64(x >> 64);
    }

    /// Convert unsigned 256-bit integer number into signed 64.64-bit fixed point
    /// number.    Revert on overflow.
    /// @param x unsigned 256-bit integer number
    /// @return signed 64.64-bit fixed point number
    function fromUInt(uint256 x) internal pure returns (int128) {
        require(x <= 0x7FFFFFFFFFFFFFFF); // dev: abdk uint overflow
        return int128(x << 64);
    }

    /// Convert signed 64.64 fixed point number into unsigned 64-bit integer
    /// number rounding down.    Revert on underflow.
    /// @param x signed 64.64-bit fixed point number
    /// @return unsigned 64-bit integer number
    function toUInt(int128 x) internal pure returns (uint64) {
        require(x >= 0); // dev: abdk uint overflow
        return uint64(x >> 64);
    }

    /// Calculate x * y rounding down.  Revert on overflow.
    /// @param x signed 64.64-bit fixed point number
    /// @param y signed 64.64-bit fixed point number
    /// @return signed 64.64-bit fixed point number
    function mul(int128 x, int128 y) internal pure returns (int128) {
        int256 result = (int256(x) * y) >> 64;
        require(result >= MIN_64x64 && result <= MAX_64x64); // dev: abdk mul overflow
        return int128(result);
    }

    /// Calculate x / y rounding towards zero.  Revert on overflow or when y is
    /// zero.
    /// @param x signed 64.64-bit fixed point number
    /// @param y signed 64.64-bit fixed point number
    /// @return signed 64.64-bit fixed point number
    function div(int128 x, int128 y) internal pure returns (int128) {
        require(y != 0);
        int256 result = (int256(x) << 64) / y;
        require(result >= MIN_64x64 && result <= MAX_64x64);
        return int128(result);
    }

    function add(int128 x, int128 y) internal pure returns (int128) {
        int256 result = int256(x) + y;
        require(result >= MIN_64x64 && result <= MAX_64x64);
        return int128(result);
    }

    function sub(int128 x, int128 y) internal pure returns (int128) {
        int256 result = int256(x) - y;
        require(result >= MIN_64x64 && result <= MAX_64x64);
        return int128(result);
    }

    /// Calculate binary logarithm of x.    Revert if x <= 0.
    /// @param x signed 64.64-bit fixed point number
    /// @return signed 64.64-bit fixed point number
    function log_2(int128 x) internal pure returns (int128) {
        require(x > 0); // dev: abdk neg log

        int256 msb = 0;
        int256 xc = x;
        if (xc >= 0x10000000000000000) {
            xc >>= 64;
            msb += 64;
        }
        if (xc >= 0x100000000) {
            xc >>= 32;
            msb += 32;
        }
        if (xc >= 0x10000) {
            xc >>= 16;
            msb += 16;
        }
        if (xc >= 0x100) {
            xc >>= 8;
            msb += 8;
        }
        if (xc >= 0x10) {
            xc >>= 4;
            msb += 4;
        }
        if (xc >= 0x4) {
            xc >>= 2;
            msb += 2;
        }
        if (xc >= 0x2) msb += 1; // No need to shift xc anymore

        int256 result = (msb - 64) << 64;
        uint256 ux = uint256(x) << uint256(127 - msb);
        for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {
            ux *= ux;
            uint256 b = ux >> 255;
            ux >>= 127 + b;
            result += bit * int256(b);
        }

        return int128(result);
    }

    /// Calculate natural logarithm of x.    Revert if x <= 0.
    /// @param x signed 64.64-bit fixed point number
    /// @return signed 64.64-bit fixed point number
    function ln(int128 x) internal pure returns (int128) {
        require(x > 0); // dev: abdk neg log

        return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128);
    }

    /// Calculate binary exponent of x.    Revert on overflow.
    /// @param x signed 64.64-bit fixed point number
    /// @return signed 64.64-bit fixed point number
    function exp_2(int128 x) internal pure returns (int128) {
        require(x < 0x400000000000000000); // dev: abdk exp overflow

        if (x < -0x400000000000000000) return 0; // Underflow

        uint256 result = 0x80000000000000000000000000000000;

        if (x & 0x8000000000000000 > 0)
            result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;
        if (x & 0x4000000000000000 > 0)
            result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;
        if (x & 0x2000000000000000 > 0)
            result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;
        if (x & 0x1000000000000000 > 0)
            result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;
        if (x & 0x800000000000000 > 0)
            result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;
        if (x & 0x400000000000000 > 0)
            result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;
        if (x & 0x200000000000000 > 0)
            result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;
        if (x & 0x100000000000000 > 0)
            result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;
        if (x & 0x80000000000000 > 0)
            result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;
        if (x & 0x40000000000000 > 0)
            result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;
        if (x & 0x20000000000000 > 0)
            result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;
        if (x & 0x10000000000000 > 0)
            result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;
        if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;
        if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;
        if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;
        if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;
        if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;
        if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;
        if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;
        if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;
        if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;
        if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;
        if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;
        if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;
        if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;
        if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;
        if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;
        if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;
        if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;
        if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;
        if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;
        if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;
        if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;
        if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;
        if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;
        if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;
        if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;
        if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;
        if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;
        if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;
        if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;
        if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;
        if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;
        if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;
        if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;
        if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;
        if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;
        if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;
        if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;
        if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;
        if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;
        if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;
        if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;
        if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;
        if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;
        if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;
        if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;
        if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;
        if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;
        if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;
        if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;
        if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;
        if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;
        if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;

        result >>= uint256(63 - (x >> 64));
        require(result <= uint256(MAX_64x64)); // dev: abdk exp overflow max64

        return int128(result);
    }

    /// Calculate natural exponent of x.    Revert on overflow.
    /// @param x signed 64.64-bit fixed point number
    /// @return signed 64.64-bit fixed point number
    function exp(int128 x) internal pure returns (int128) {
        require(x < 0x400000000000000000); // dev: abdk exp overflow

        if (x < -0x400000000000000000) return 0; // Underflow

        return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));
    }
}",4809
RealWorld_TA_23_MockFreeCollateral_RealWorld_20240803023054.log,23,MockFreeCollateral,152531,6469,159000,187.0,0.892035,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/valuation/ExchangeRate.sol"";
import ""../internal/markets/AssetRate.sol"";

import ""../external/FreeCollateralExternal.sol"";
import ""../internal/valuation/FreeCollateral.sol"";
import ""../internal/portfolio/PortfolioHandler.sol"";
import ""../internal/AccountContextHandler.sol"";
import ""../internal/markets/Market.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockFreeCollateral is StorageLayoutV1 {
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;
    using Market for MarketParameters;

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setCashGroup(uint256 id, CashGroupSettings calldata cg) external {
        CashGroup.setCashGroupStorage(id, cg);
    }

    function buildCashGroupView(uint256 currencyId)
        public
        view
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupView(currencyId);
    }

    function setMarketStorage(
        uint256 currencyId,
        uint256 settlementDate,
        MarketParameters memory market
    ) public {
        market.storageSlot = Market.getSlot(currencyId, settlementDate, market.maturity);
        // ensure that state gets set
        market.storageState = 0xFF;
        market.setMarketStorage();
    }

    function getMarketStorage(
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime
    ) public view returns (MarketParameters memory) {
        MarketParameters memory market;
        Market.loadMarket(market, currencyId, maturity, blockTime, true, 1);

        return market;
    }

    function getAccountContext(address account) external view returns (AccountContext memory) {
        return AccountContextHandler.getAccountContext(account);
    }

    function enableBitmapForAccount(
        address account,
        uint256 currencyId,
        uint256 blockTime
    ) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        accountContext.enableBitmapForAccount(account, currencyId, blockTime);
        accountContext.setAccountContext(account);
    }

    function setifCashAsset(
        address account,
        uint256 currencyId,
        uint256 maturity,
        int256 notional,
        uint256 blockTime
    ) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        bytes32 bitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);
        if (
            accountContext.nextSettleTime != 0 &&
            accountContext.nextSettleTime != DateTime.getTimeUTC0(blockTime)
        ) {
            revert(); // dev: invalid block time for test
        }
        accountContext.nextSettleTime = uint40(DateTime.getTimeUTC0(blockTime));

        int256 finalNotional;
        (bitmap, finalNotional) = BitmapAssetsHandler.addifCashAsset(
            account,
            currencyId,
            maturity,
            accountContext.nextSettleTime,
            notional,
            bitmap
        );
        if (finalNotional < 0)
            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;

        accountContext.setAccountContext(account);

        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, bitmap);
    }

    function setETHRateMapping(uint256 id, ETHRateStorage calldata rs) external {
        underlyingToETHRateMapping[id] = rs;
    }

    function setPortfolio(address account, PortfolioAsset[] memory assets) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        PortfolioState memory portfolioState =
            PortfolioHandler.buildPortfolioState(account, accountContext.assetArrayLength, 0);
        portfolioState.newAssets = assets;
        accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);
        accountContext.setAccountContext(account);
    }

    function setBalance(
        address account,
        uint256 currencyId,
        int256 cashBalance,
        int256 nTokenBalance
    ) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (cashBalance < 0)
            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;
        accountContext.setActiveCurrency(currencyId, true, Constants.ACTIVE_IN_BALANCES);
        accountContext.setAccountContext(account);

        bytes32 slot =
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(account, Constants.BALANCE_STORAGE_OFFSET))
                )
            );
        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow
        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow
        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow

        bytes32 data =
            ((bytes32(uint256(nTokenBalance))) |
                (bytes32(0) << 80) |
                (bytes32(0) << 112) |
                (bytes32(cashBalance) << 168));

        assembly {
            sstore(slot, data)
        }
    }

    function convert(uint256 currencyId, int256 balance) public view returns (int256, int256) {
        AssetRateParameters memory assetRate = AssetRate.buildAssetRateView(currencyId);
        int256 underlying = AssetRate.convertToUnderlying(assetRate, balance);
        ETHRate memory ethRate = ExchangeRate.buildExchangeRate(currencyId);
        int256 eth = ExchangeRate.convertToETH(ethRate, underlying);

        return (underlying, eth);
    }

    event AccountContextUpdate(address indexed account);
    event Liquidation(LiquidationFactors factors);
    event Test(AccountContext context, bool updateContext);

    function freeCollateralView(address account, uint256 blockTime)
        external
        view
        returns (int256, int256[] memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        return FreeCollateral.getFreeCollateralView(account, accountContext, blockTime);
    }

    function testFreeCollateral(address account, uint256 blockTime)
        external
        returns (int256, int256[] memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        (int256 fcView, int256[] memory netLocal) =
            FreeCollateral.getFreeCollateralView(account, accountContext, blockTime);

        if (fcView >= 0) {
            // Refetch to clear state
            AccountContext memory accountContextNew =
                AccountContextHandler.getAccountContext(account);

            // prettier-ignore
            (int256 ethDenominatedFC, bool updateContext) =
                FreeCollateral.getFreeCollateralStateful(account, accountContextNew, blockTime);

            if (updateContext) {
                accountContextNew.setAccountContext(account);
            }

            assert(fcView == ethDenominatedFC);
        } else {
            // prettier-ignore
            (LiquidationFactors memory factors, /* */) = FreeCollateral.getLiquidationFactors(
                account, accountContext, blockTime, 1, 0);
            emit Liquidation(factors);

            assert(fcView == factors.netETHValue);
        }

        return (fcView, netLocal);
    }
}",1560
RealWorld_TA_23_CashGroup_RealWorld_20240803034902.log,23,CashGroup,324509,3151,327660,365.0,1.685565,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./Market.sol"";
import ""./AssetRate.sol"";
import ""./DateTime.sol"";
import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../../math/SafeInt256.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library CashGroup {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using AssetRate for AssetRateParameters;
    using Market for MarketParameters;

    // Offsets for the bytes of the different parameters
    uint256 private constant RATE_ORACLE_TIME_WINDOW = 8;
    uint256 private constant TOTAL_FEE = 16;
    uint256 private constant RESERVE_FEE_SHARE = 24;
    uint256 private constant DEBT_BUFFER = 32;
    uint256 private constant FCASH_HAIRCUT = 40;
    uint256 private constant SETTLEMENT_PENALTY = 48;
    uint256 private constant LIQUIDATION_FCASH_HAIRCUT = 56;
    uint256 private constant LIQUIDATION_DEBT_BUFFER = 64;
    // 7 bytes allocated, one byte per market for the liquidity token haircut
    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT = 72;
    // 7 bytes allocated, one byte per market for the rate scalar
    uint256 private constant RATE_SCALAR = 144;

    /// @notice Returns the rate scalar scaled by time to maturity. The rate scalar multiplies
    /// the ln() portion of the liquidity curve as an inverse so it increases with time to
    /// maturity. The effect of the rate scalar on slippage must decrease with time to maturity.
    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) internal pure returns (int256) {
        require(marketIndex >= 1); // dev: invalid market index
        require(timeToMaturity <= uint256(type(int256).max)); // dev: time to maturity overflow

        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);
        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * Constants.RATE_PRECISION;
        int256 rateScalar =
            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(int256(timeToMaturity));

        // Rate scalar is denominated in RATE_PRECISION, it is unlikely to underflow in the
        // division above.
        require(rateScalar > 0); // dev: rate scalar underflow
        return rateScalar;
    }

    /// @notice Haircut on liquidity tokens to account for the risk associated with changes in the
    /// proportion of cash to fCash within the pool. This is set as a percentage less than or equal to 100.
    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)
        internal
        pure
        returns (uint256)
    {
        require(assetType > 1); // dev: liquidity haircut invalid asset type
        uint256 offset =
            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);
        uint256 liquidityTokenHaircut = uint256(uint8(uint256(cashGroup.data >> offset)));
        return liquidityTokenHaircut;
    }

    /// @notice Total trading fee denominated in basis points
    function getTotalFee(CashGroupParameters memory cashGroup) internal pure returns (uint256) {
        return uint256(uint8(uint256(cashGroup.data >> TOTAL_FEE))) * Constants.BASIS_POINT;
    }

    /// @notice Percentage of the total trading fee that goes to the reserve
    function getReserveFeeShare(CashGroupParameters memory cashGroup)
        internal
        pure
        returns (int256)
    {
        return int256(uint8(uint256(cashGroup.data >> RESERVE_FEE_SHARE)));
    }

    /// @notice fCash haircut for valuation denominated in basis points
    function getfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {
        return
            uint256(uint8(uint256(cashGroup.data >> FCASH_HAIRCUT))) * (5 * Constants.BASIS_POINT);
    }

    /// @notice fCash debt buffer for valuation denominated in basis points
    function getDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {
        return uint256(uint8(uint256(cashGroup.data >> DEBT_BUFFER))) * (5 * Constants.BASIS_POINT);
    }

    /// @notice Time window factor for the rate oracle denominated in seconds
    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)
        internal
        pure
        returns (uint256)
    {
        // This is denominated in minutes in storage
        return uint256(uint8(uint256(cashGroup.data >> RATE_ORACLE_TIME_WINDOW))) * 60;
    }

    /// @notice Penalty rate for settling cash debts denominated in basis points
    function getSettlementPenalty(CashGroupParameters memory cashGroup)
        internal
        pure
        returns (uint256)
    {
        return
            uint256(uint8(uint256(cashGroup.data >> SETTLEMENT_PENALTY))) *
            (5 * Constants.BASIS_POINT);
    }

    /// @notice Haircut for fCash during liquidation denominated in basis points
    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup)
        internal
        pure
        returns (uint256)
    {
        return
            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_FCASH_HAIRCUT))) *
            (5 * Constants.BASIS_POINT);
    }

    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup)
        internal
        pure
        returns (uint256)
    {
        return
            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_DEBT_BUFFER))) *
            (5 * Constants.BASIS_POINT);
    }

    function loadMarket(
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 marketIndex,
        bool needsLiquidity,
        uint256 blockTime
    ) internal view {
        require(marketIndex > 0 && marketIndex <= cashGroup.maxMarketIndex, ""Invalid market"");
        uint256 maturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));

        market.loadMarket(
            cashGroup.currencyId,
            maturity,
            blockTime,
            needsLiquidity,
            getRateOracleTimeWindow(cashGroup)
        );
    }

    /// @notice Returns the linear interpolation between two market rates. The formula is
    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)
    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate
    function interpolateOracleRate(
        uint256 shortMaturity,
        uint256 longMaturity,
        uint256 shortRate,
        uint256 longRate,
        uint256 assetMaturity
    ) internal pure returns (uint256) {
        require(shortMaturity < assetMaturity); // dev: cash group interpolation error, short maturity
        require(assetMaturity < longMaturity); // dev: cash group interpolation error, long maturity

        // It's possible that the rates are inverted where the short market rate > long market rate and
        // we will get an underflow here so we check for that
        if (longRate >= shortRate) {
            return
                (longRate - shortRate)
                    .mul(assetMaturity - shortMaturity)
                // No underflow here, checked above
                    .div(longMaturity - shortMaturity)
                    .add(shortRate);
        } else {
            // In this case the slope is negative so:
            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)
            // NOTE: this subtraction should never overflow, the linear interpolation between two points above zero
            // cannot go below zero
            return
                shortRate.sub(
                    // This is reversed to keep it it positive
                    (shortRate - longRate)
                        .mul(assetMaturity - shortMaturity)
                    // No underflow here, checked above
                        .div(longMaturity - shortMaturity)
                );
        }
    }

    /// @dev Gets an oracle rate without interpolation
    function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime
    ) internal view returns (uint256) {
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);
        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);

        if (!idiosyncratic) {
            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);
        }

        uint256 longMaturity =
            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));
        uint256 longRate =
            Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);

        uint256 shortMaturity;
        uint256 shortRate;
        if (marketIndex == 1) {
            // In this case the short market is the annualized asset supply rate
            shortMaturity = blockTime;
            shortRate = cashGroup.assetRate.getSupplyRate();
        } else {
            shortMaturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(marketIndex - 1)
            );

            shortRate = Market.getOracleRate(
                cashGroup.currencyId,
                shortMaturity,
                timeWindow,
                blockTime
            );
        }

        return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);
    }

    function _getCashGroupStorageBytes(uint256 currencyId) private view returns (bytes32) {
        bytes32 slot = keccak256(abi.encode(currencyId, Constants.CASH_GROUP_STORAGE_OFFSET));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        return data;
    }

    /// @dev Helper method for validating maturities in ERC1155Action
    function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        return uint8(data[31]);
    }

    /// @notice Checks all cash group settings for invalid values and sets them into storage
    function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)
        internal
    {
        bytes32 slot = keccak256(abi.encode(currencyId, Constants.CASH_GROUP_STORAGE_OFFSET));
        require(
            cashGroup.maxMarketIndex >= 0 &&
                cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,
            ""CG: invalid market index""
        );
        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.
        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month
        // fixed. It also complicates the logic in the nToken initialization method
        require(cashGroup.maxMarketIndex != 1, ""CG: invalid market index"");
        require(
            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,
            ""CG: invalid reserve share""
        );
        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);
        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);
        // This is required so that fCash liquidation can proceed correctly
        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);
        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);

        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve
        uint8 previousMaxMarketIndex = uint8(uint256(_getCashGroupStorageBytes(currencyId)));
        require(
            previousMaxMarketIndex <= cashGroup.maxMarketIndex,
            ""CG: market index cannot decrease""
        );

        // Per cash group settings
        bytes32 data =
            (bytes32(uint256(cashGroup.maxMarketIndex)) |
                (bytes32(uint256(cashGroup.rateOracleTimeWindowMin)) << RATE_ORACLE_TIME_WINDOW) |
                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |
                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |
                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |
                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |
                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |
                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<
                    LIQUIDATION_FCASH_HAIRCUT) |
                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));

        // Per market group settings
        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) {
            require(
                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,
                ""CG: invalid token haircut""
            );

            data =
                data |
                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<
                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));
        }

        for (uint256 i; i < cashGroup.rateScalars.length; i++) {
            // Causes a divide by zero error
            require(cashGroup.rateScalars[i] != 0, ""CG: invalid rate scalar"");
            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));
        }

        assembly {
            sstore(slot, data)
        }
    }

    /// @notice Deserialize the cash group storage bytes into a user friendly object
    function deserializeCashGroupStorage(uint256 currencyId)
        internal
        view
        returns (CashGroupSettings memory)
    {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        uint8 maxMarketIndex = uint8(data[31]);
        uint8[] memory tokenHaircuts = new uint8[](uint256(maxMarketIndex));
        uint8[] memory rateScalars = new uint8[](uint256(maxMarketIndex));

        for (uint8 i; i < maxMarketIndex; i++) {
            tokenHaircuts[i] = uint8(data[22 - i]);
            rateScalars[i] = uint8(data[13 - i]);
        }

        return
            CashGroupSettings({
                maxMarketIndex: maxMarketIndex,
                rateOracleTimeWindowMin: uint8(data[30]),
                totalFeeBPS: uint8(data[29]),
                reserveFeeShare: uint8(data[28]),
                debtBuffer5BPS: uint8(data[27]),
                fCashHaircut5BPS: uint8(data[26]),
                settlementPenaltyRate5BPS: uint8(data[25]),
                liquidationfCashHaircut5BPS: uint8(data[24]),
                liquidationDebtBuffer5BPS: uint8(data[23]),
                liquidityTokenHaircuts: tokenHaircuts,
                rateScalars: rateScalars
            });
    }

    function _buildCashGroup(uint256 currencyId, AssetRateParameters memory assetRate)
        private
        view
        returns (CashGroupParameters memory)
    {
        bytes32 data = _getCashGroupStorageBytes(currencyId);
        uint256 maxMarketIndex = uint256(uint8(uint256(data)));

        return
            CashGroupParameters({
                currencyId: currencyId,
                maxMarketIndex: maxMarketIndex,
                assetRate: assetRate,
                data: data
            });
    }

    /// @notice Builds a cash group using a view version of the asset rate
    function buildCashGroupView(uint256 currencyId)
        internal
        view
        returns (CashGroupParameters memory)
    {
        AssetRateParameters memory assetRate = AssetRate.buildAssetRateView(currencyId);
        return _buildCashGroup(currencyId, assetRate);
    }

    /// @notice Builds a cash group using a stateful version of the asset rate
    function buildCashGroupStateful(uint256 currencyId)
        internal
        returns (CashGroupParameters memory)
    {
        AssetRateParameters memory assetRate = AssetRate.buildAssetRateStateful(currencyId);
        return _buildCashGroup(currencyId, assetRate);
    }
}",3633
RealWorld_TA_23_IERC1155TokenReceiver_RealWorld_20240803080251.log,23,IERC1155TokenReceiver,74985,1489,76474,370.0,0.404705,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

/**
    Note: The ERC-165 identifier for this interface is 0x4e2312e0.
*/

interface IERC1155TokenReceiver {
    /**
        @notice Handle the receipt of a single ERC1155 token type.
        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the
        end of a `safeTransferFrom` after the balance has been updated.
        This function MUST return `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`
        (i.e. 0xf23a6e61) if it accepts the transfer.
        This function MUST revert if it rejects the transfer.
        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction
        being reverted by the caller.
        @param _operator  The address which initiated the transfer (i.e. msg.sender)
        @param _from      The address which previously owned the token
        @param _id        The ID of the token being transferred
        @param _value     The amount of tokens being transferred
        @param _data      Additional data with no specified format
        @return           `bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))`
    */
    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data)
        external
        returns (bytes4);

    /**
        @notice Handle the receipt of multiple ERC1155 token types.
        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end
        of a `safeBatchTransferFrom` after the balances have been updated.
        This function MUST return
            `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`
            (i.e. 0xbc197c81) if it accepts the transfer(s).
        This function MUST revert if it rejects the transfer(s).
        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being
        reverted by the caller.
        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)
        @param _from      The address which previously owned the token
        @param _ids       An array containing ids of each token being transferred (order and length must match
            _values array)
        @param _values    An array containing amounts of each token being transferred (order and length must match
            _ids array)
        @param _data      Additional data with no specified format
        @return           `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`
    */
    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _values,
        bytes calldata _data
    ) external returns (bytes4);
}",674
RealWorld_TA_23_SettlePortfolioAssets_RealWorld_20240803031201.log,23,SettlePortfolioAssets,152416,4498,156914,149.0,0.85204,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../valuation/AssetHandler.sol"";
import ""../markets/Market.sol"";
import ""../markets/AssetRate.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/Constants.sol"";
import ""../../global/Types.sol"";

library SettlePortfolioAssets {
    using SafeInt256 for int256;
    using AssetRate for AssetRateParameters;
    using PortfolioHandler for PortfolioState;
    using AssetHandler for PortfolioAsset;

    /// @dev Returns a SettleAmount array for the assets that will be settled
    function _getSettleAmountArray(PortfolioState memory portfolioState, uint256 blockTime)
        private
        pure
        returns (SettleAmount[] memory)
    {
        uint256 currenciesSettled;
        uint256 lastCurrencyId;
        if (portfolioState.storedAssets.length == 0) return new SettleAmount[](0);

        // Loop backwards so ""lastCurrencyId"" will be set to the first currency in the portfolio
        // NOTE: if this contract is ever upgraded to Solidity 0.8+ then this i-- will underflow and cause
        // a revert, must wrap in an unchecked.
        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) {
            PortfolioAsset memory asset = portfolioState.storedAssets[i];
            if (asset.getSettlementDate() > blockTime) {
                continue;
            }

            // Assume that this is sorted by cash group and maturity, currencyId = 0 is unused so this
            // will work for the first asset
            if (lastCurrencyId != asset.currencyId) {
                lastCurrencyId = asset.currencyId;
                currenciesSettled++;
            }
        }

        // Actual currency ids will be set in the loop
        SettleAmount[] memory settleAmounts = new SettleAmount[](currenciesSettled);
        if (currenciesSettled > 0) settleAmounts[0].currencyId = lastCurrencyId;
        return settleAmounts;
    }

    /// @notice Shared calculation for liquidity token settlement
    function _calculateMarketStorage(PortfolioAsset memory asset)
        private
        view
        returns (
            int256,
            int256,
            SettlementMarket memory
        )
    {
        SettlementMarket memory market =
            Market.getSettlementMarket(asset.currencyId, asset.maturity, asset.getSettlementDate());

        int256 assetCash = market.totalAssetCash.mul(asset.notional).div(market.totalLiquidity);
        int256 fCash = market.totalfCash.mul(asset.notional).div(market.totalLiquidity);

        market.totalfCash = market.totalfCash.subNoNeg(fCash);
        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);
        market.totalLiquidity = market.totalLiquidity.subNoNeg(asset.notional);

        return (assetCash, fCash, market);
    }

    /// @notice Settles a liquidity token which requires getting the claims on both cash and fCash,
    /// converting the fCash portion to cash at the settlement rate.
    function _settleLiquidityToken(
        PortfolioAsset memory asset,
        AssetRateParameters memory settlementRate
    ) private view returns (int256, SettlementMarket memory) {
        (int256 assetCash, int256 fCash, SettlementMarket memory market) =
            _calculateMarketStorage(asset);

        assetCash = assetCash.add(settlementRate.convertFromUnderlying(fCash));
        return (assetCash, market);
    }

    /// @notice Settles a liquidity token to idiosyncratic fCash, this occurs when the maturity is still in the future
    function _settleLiquidityTokenTofCash(PortfolioState memory portfolioState, uint256 index)
        private
        view
        returns (int256, SettlementMarket memory)
    {
        PortfolioAsset memory liquidityToken = portfolioState.storedAssets[index];
        (int256 assetCash, int256 fCash, SettlementMarket memory market) =
            _calculateMarketStorage(liquidityToken);

        // If the liquidity token's maturity is still in the future then we change the entry to be
        // an idiosyncratic fCash entry with the net fCash amount.
        if (index != 0) {
            // Check to see if the previous index is the matching fCash asset, this will be the case when the
            // portfolio is sorted
            PortfolioAsset memory fCashAsset = portfolioState.storedAssets[index - 1];

            if (
                fCashAsset.currencyId == liquidityToken.currencyId &&
                fCashAsset.maturity == liquidityToken.maturity &&
                fCashAsset.assetType == Constants.FCASH_ASSET_TYPE
            ) {
                // This fCash asset has not matured if were are settling to fCash
                fCashAsset.notional = fCashAsset.notional.add(fCash);
                fCashAsset.storageState = AssetStorageState.Update;

                portfolioState.deleteAsset(index);
                return (assetCash, market);
            }
        }

        liquidityToken.assetType = Constants.FCASH_ASSET_TYPE;
        liquidityToken.notional = fCash;
        liquidityToken.storageState = AssetStorageState.Update;

        return (assetCash, market);
    }

    /// @notice Settles a portfolio array
    function settlePortfolio(PortfolioState memory portfolioState, uint256 blockTime)
        internal
        returns (SettleAmount[] memory)
    {
        AssetRateParameters memory settlementRate;
        SettleAmount[] memory settleAmounts = _getSettleAmountArray(portfolioState, blockTime);
        if (settleAmounts.length == 0) return settleAmounts;
        uint256 settleAmountIndex;
        uint256 lastMaturity;

        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            PortfolioAsset memory asset = portfolioState.storedAssets[i];
            if (asset.getSettlementDate() > blockTime) continue;

            if (settleAmounts[settleAmountIndex].currencyId != asset.currencyId) {
                // New currency in the portfolio
                lastMaturity = 0;
                settleAmountIndex += 1;
                settleAmounts[settleAmountIndex].currencyId = asset.currencyId;
            }

            // Saves a storage call if there is an fCash token and then an liquidity token after it
            if (lastMaturity != asset.maturity && asset.maturity < blockTime) {
                settlementRate = AssetRate.buildSettlementRateStateful(
                    asset.currencyId,
                    asset.maturity,
                    blockTime
                );
                lastMaturity = asset.maturity;
            }

            int256 assetCash;
            if (asset.assetType == Constants.FCASH_ASSET_TYPE) {
                assetCash = settlementRate.convertFromUnderlying(asset.notional);
                portfolioState.deleteAsset(i);
            } else if (AssetHandler.isLiquidityToken(asset.assetType)) {
                SettlementMarket memory market;
                if (asset.maturity > blockTime) {
                    (assetCash, market) = _settleLiquidityTokenTofCash(portfolioState, i);
                } else {
                    (assetCash, market) = _settleLiquidityToken(asset, settlementRate);
                    portfolioState.deleteAsset(i);
                }

                Market.setSettlementMarket(market);
            }

            settleAmounts[settleAmountIndex].netCashChange = settleAmounts[settleAmountIndex]
                .netCashChange
                .add(assetCash);
        }

        return settleAmounts;
    }
}",1617
RealWorld_TA_23_StorageLayoutV1_RealWorld_20240803074418.log,23,StorageLayoutV1,63371,1580,64951,367.0,0.348455,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./Types.sol"";

/**
 * @notice Storage layout for the system. Do not change this file once deployed, future storage
 * layouts must inherit this and increment the version number.
 */
contract StorageLayoutV1 {
    uint16 internal maxCurrencyId;

    // Returns the exchange rate between an underlying currency and ETH for free
    // collateral purposes. Mapping is from currency id to rate storage object.
    mapping(uint256 => ETHRateStorage) internal underlyingToETHRateMapping;
    // Returns the exchange rate between an underlying currency and asset for trading
    // and free collateral. Mapping is from currency id to rate storage object.
    mapping(uint256 => AssetRateStorage) internal assetToUnderlyingRateMapping;

    /* Authentication Mappings */
    // This is set to the timelock contract to execute governance functions
    address public owner;
    // This is set to the governance token address
    address internal token;
    // This is set to an address of a router that can only call governance actions
    address public pauseRouter;
    // This is set to an address of a router that can only call governance actions
    address public pauseGuardian;
    // On upgrades this is set in the case that the pause router is used to pass the rollback check
    address internal rollbackRouterImplementation;
    // Sets the state of liquidations being enabled during a paused state. Each of the four lower
    // bits can be turned on to represent one of the liquidation types being enabled.
    bytes1 internal liquidationEnabledState;

    // A blanket allowance for a spender to transfer any of an account's nTokens. This would allow a user
    // to set an allowance on all nTokens for a particular integrating contract system.
    // owner => spender => transferAllowance
    mapping(address => mapping(address => uint256)) internal nTokenWhitelist;
    // Individual transfer allowances for nTokens used for ERC20
    // owner => spender => currencyId => transferAllowance
    mapping(address => mapping(address => mapping(uint16 => uint256))) internal nTokenAllowance;

    // Transfer operators
    mapping(address => bool) internal globalTransferOperator;
    mapping(address => mapping(address => bool)) internal accountAuthorizedTransferOperator;
    mapping(address => bool) internal authorizedCallbackContract;

    // Reverse mapping from token addresses to currency ids, only used for referencing in views
    // and checking for duplicate token listings.
    mapping(address => uint16) internal tokenAddressToCurrencyId;
}",541
RealWorld_TA_23_TransferAssets_RealWorld_20240803043234.log,23,TransferAssets,82054,3363,85417,362.0,0.47753,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./PortfolioHandler.sol"";
import ""./BitmapAssetsHandler.sol"";
import ""../AccountContextHandler.sol"";
import ""../../external/SettleAssetsExternal.sol"";

/// @notice Helper library for transferring assets from one portfolio to another
library TransferAssets {
    using AccountContextHandler for AccountContext;
    using PortfolioHandler for PortfolioState;
    using SafeInt256 for int256;

    /// @notice Decodes asset ids
    function decodeAssetId(uint256 id)
        internal
        pure
        returns (
            uint16 currencyId,
            uint40 maturity,
            uint8 assetType
        )
    {
        currencyId = uint16(uint256(bytes32(id) >> 48));
        maturity = uint40(uint256(bytes32(id) >> 8));
        assetType = uint8(uint256(bytes32(id)));
    }

    /// @notice Encodes asset ids
    function encodeAssetId(
        uint256 currencyId,
        uint256 maturity,
        uint256 assetType
    ) internal pure returns (uint256) {
        return
            uint256(
                (bytes32(uint256(uint16(currencyId))) << 48) |
                    (bytes32(uint256(uint40(maturity))) << 8) |
                    bytes32(uint256(uint8(assetType)))
            );
    }

    /// @dev Used to flip the sign of assets to decrement the `from` account that is sending assets
    function invertNotionalAmountsInPlace(PortfolioAsset[] memory assets) internal pure {
        for (uint256 i; i < assets.length; i++) {
            assets[i].notional = assets[i].notional.neg();
        }
    }

    /// @dev Useful method for hiding the logic of updating an account. WARNING: the account
    /// context returned from this method may not be the same memory location as the account
    /// context provided if the account is settled.
    function placeAssetsInAccount(
        address account,
        AccountContext memory accountContext,
        PortfolioAsset[] memory assets
    ) internal returns (AccountContext memory) {
        if (accountContext.bitmapCurrencyId == 0) {
            return _addAssetsToPortfolio(account, accountContext, assets);
        } else {
            return _addAssetsToBitmap(account, accountContext, assets);
        }
    }

    function _addAssetsToPortfolio(
        address account,
        AccountContext memory accountContext,
        PortfolioAsset[] memory assets
    ) private returns (AccountContext memory) {
        PortfolioState memory portfolioState;
        if (accountContext.mustSettleAssets()) {
            // accountContext may change memory locations after this returns
            (accountContext, portfolioState) = SettleAssetsExternal.settleAssetsAndReturnPortfolio(
                account,
                accountContext
            );
        } else {
            portfolioState = PortfolioHandler.buildPortfolioState(
                account,
                accountContext.assetArrayLength,
                assets.length
            );
        }

        portfolioState.addMultipleAssets(assets);
        accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);

        return accountContext;
    }

    function _addAssetsToBitmap(
        address account,
        AccountContext memory accountContext,
        PortfolioAsset[] memory assets
    ) private returns (AccountContext memory) {
        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);
        }

        BitmapAssetsHandler.addMultipleifCashAssets(account, accountContext, assets);

        return accountContext;
    }
}",747
RealWorld_TA_23_TokenHandler_RealWorld_20240803040739.log,23,TokenHandler,195858,5661,201519,376.0,1.09251,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../math/SafeInt256.sol"";
import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/compound/CEtherInterface.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/// @notice Handles all external token transfers and events
library TokenHandler {
    using SafeInt256 for int256;
    using SafeMath for uint256;

    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))
                )
            );
    }

    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns
    /// the underlying token. (These may not always exist)
    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {
        bytes32 slot = _getSlot(currencyId, underlying);
        bytes32 data;

        assembly {
            data := sload(slot)
        }
        address tokenAddress = address(bytes20(data << 96));
        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;
        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));
        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));

        return
            Token({
                tokenAddress: tokenAddress,
                hasTransferFee: tokenHasTransferFee,
                decimals: int256(10**tokenDecimalPlaces),
                tokenType: tokenType
            });
    }

    /// @notice Sets a token for a currency id.
    function setToken(
        uint256 currencyId,
        bool underlying,
        TokenStorage memory tokenStorage
    ) internal {
        bytes32 slot = _getSlot(currencyId, underlying);

        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {
            // Specific storage for Ether token type
            bytes32 etherData =
                ((bytes32(bytes20(address(0))) >> 96) |
                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |
                    bytes32(uint256(18) << 168) |
                    bytes32(uint256(TokenType.Ether) << 176));

            assembly {
                sstore(slot, etherData)
            }

            return;
        }
        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once
        require(tokenStorage.tokenAddress != address(0), ""TH: address is zero"");

        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();
        require(decimalPlaces != 0, ""TH: decimals is zero"");

        // Once a token is set we cannot override it. In the case that we do need to do change a token address
        // then we should explicitly upgrade this method to allow for a token to be changed.
        Token memory token = getToken(currencyId, underlying);
        require(
            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),
            ""TH: token cannot be reset""
        );

        if (tokenStorage.tokenType == TokenType.cToken) {
            // Set the approval for the underlying so that we can mint cTokens
            Token memory underlyingToken = getToken(currencyId, true);
            ERC20(underlyingToken.tokenAddress).approve(
                tokenStorage.tokenAddress,
                type(uint256).max
            );
        }

        bytes1 transferFee =
            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;

        bytes32 data =
            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |
                (bytes32(bytes1(transferFee)) >> 88) |
                bytes32(uint256(decimalPlaces) << 168) |
                bytes32(uint256(tokenStorage.tokenType) << 176));

        assembly {
            sstore(slot, data)
        }
    }

    /// @notice This method only works with cTokens, it's unclear how we can make this more generic
    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {
        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

        uint256 success;
        if (token.tokenType == TokenType.cToken) {
            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);
        } else if (token.tokenType == TokenType.cETH) {
            // Reverts on error
            CEtherInterface(token.tokenAddress).mint{value: msg.value}();
        } else {
            revert(); // dev: non mintable token
        }

        require(success == 0, ""Mint fail"");
        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

        // This is the starting and ending balance in external precision
        return int256(endingBalance.sub(startingBalance));
    }

    function redeem(
        Token memory assetToken,
        Token memory underlyingToken,
        uint256 assetAmountExternal
    ) internal returns (int256) {
        uint256 startingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            startingBalance = address(this).balance;
        } else if (assetToken.tokenType == TokenType.cToken) {
            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        } else {
            revert(); // dev: non redeemable failure
        }

        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);
        require(success == 0, ""Redeem fail"");

        uint256 endingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            endingBalance = address(this).balance;
        } else {
            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        }

        // Underlying token external precision
        return int256(endingBalance.sub(startingBalance));
    }

    /// @notice Handles transfers into and out of the system denominated in the external token decimal
    /// precision.
    function transfer(
        Token memory token,
        address account,
        int256 netTransferExternal
    ) internal returns (int256) {
        if (netTransferExternal > 0) {
            // Deposits must account for transfer fees.
            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));
        } else if (token.tokenType == TokenType.Ether) {
            require(netTransferExternal < 0); // dev: cannot transfer ether
            address payable accountPayable = payable(account);
            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying
            // ETH they will have to withdraw the cETH token and then redeem it manually.
            accountPayable.transfer(uint256(netTransferExternal.neg()));
        } else {
            safeTransferOut(
                IERC20(token.tokenAddress),
                account,
                uint256(netTransferExternal.neg())
            );
        }

        return netTransferExternal;
    }

    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must
    /// calculate the net balance after transfer. Amounts are denominated in the destination token's
    /// precision.
    function _deposit(
        Token memory token,
        address account,
        uint256 amount
    ) private returns (int256) {
        if (token.hasTransferFee) {
            // Must deposit from the token and calculate the net transfer
            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));
            safeTransferIn(IERC20(token.tokenAddress), account, amount);
            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

            return int256(endingBalance.sub(startingBalance));
        }

        safeTransferIn(IERC20(token.tokenAddress), account, amount);
        return int256(amount);
    }

    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);
    }

    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);
    }

    function transferIncentive(address account, uint256 tokensToTransfer) internal {
        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);
    }

    function safeTransferOut(
        IERC20 token,
        address account,
        uint256 amount
    ) private {
        token.transfer(account, amount);
        checkReturnCode();
    }

    function safeTransferIn(
        IERC20 token,
        address account,
        uint256 amount
    ) private {
        token.transferFrom(account, address(this), amount);
        checkReturnCode();
    }

    function checkReturnCode() private pure {
        bool success;
        assembly {
            switch returndatasize()
                case 0 {
                    // This is a non-standard ERC-20
                    success := not(0) // set success to true
                }
                case 32 {
                    // This is a compliant ERC-20
                    returndatacopy(0, 0, 32)
                    success := mload(0) // Set `success = returndata` of external call
                }
                default {
                    // This is an excessively non-compliant ERC-20, revert.
                    revert(0, 0)
                }
        }

        require(success, ""Transfer Failed"");
    }
}",2090
RealWorld_TA_23_Types_RealWorld_20240803075641.log,23,Types,281972,1504,283476,368.0,1.43994,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

/// @notice Different types of internal tokens
///  - UnderlyingToken: underlying asset for a cToken (except for Ether)
///  - cToken: Compound interest bearing token
///  - cETH: Special handling for cETH tokens
///  - Ether: the one and only
///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)
enum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}

/// @notice Specifies the different trade action types in the system. Each trade action type is
/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the
/// 32 byte trade action object. The schemas for each trade action type are defined below.
enum TradeActionType {
    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)
    Lend,
    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)
    Borrow,
    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)
    AddLiquidity,
    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)
    RemoveLiquidity,
    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)
    PurchaseNTokenResidual,
    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)
    SettleCashDebt
}

/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades
enum DepositActionType {
    // No deposit action
    None,
    // Deposit asset cash, depositActionAmount is specified in asset cash external precision
    DepositAsset,
    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token
    // external precision
    DepositUnderlying,
    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of
    // nTokens into the account
    DepositAssetAndMintNToken,
    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens
    DepositUnderlyingAndMintNToken,
    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action
    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.
    RedeemNToken,
    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in
    // Notional internal 8 decimal precision.
    ConvertCashToNToken
}

/// @notice Used internally for PortfolioHandler state
enum AssetStorageState {NoChange, Update, Delete}

/****** Calldata objects ******/

/// @notice Defines a balance action for batchAction
struct BalanceAction {
    // Deposit action to take (if any)
    DepositActionType actionType;
    uint16 currencyId;
    // Deposit action amount must correspond to the depositActionType, see documentation above.
    uint256 depositActionAmount;
    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision
    uint256 withdrawAmountInternalPrecision;
    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash
    // residual left from trading.
    bool withdrawEntireCashBalance;
    // If set to true, will redeem asset cash to the underlying token on withdraw.
    bool redeemToUnderlying;
}

/// @notice Defines a balance action with a set of trades to do as well
struct BalanceActionWithTrades {
    DepositActionType actionType;
    uint16 currencyId;
    uint256 depositActionAmount;
    uint256 withdrawAmountInternalPrecision;
    bool withdrawEntireCashBalance;
    bool redeemToUnderlying;
    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation
    bytes32[] trades;
}

/****** In memory objects ******/
/// @notice Internal object that represents settled cash balances
struct SettleAmount {
    uint256 currencyId;
    int256 netCashChange;
}

/// @notice Internal object that represents a token
struct Token {
    address tokenAddress;
    bool hasTransferFee;
    int256 decimals;
    TokenType tokenType;
}

/// @notice Internal object that represents an nToken portfolio
struct nTokenPortfolio {
    CashGroupParameters cashGroup;
    PortfolioState portfolioState;
    int256 totalSupply;
    int256 cashBalance;
    uint256 lastInitializedTime;
    bytes6 parameters;
    address tokenAddress;
}

/// @notice Internal object used during liquidation
struct LiquidationFactors {
    address account;
    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision
    int256 netETHValue;
    // Amount of net local currency asset cash before haircuts and buffers available
    int256 localAssetAvailable;
    // Amount of net collateral currency asset cash before haircuts and buffers available
    int256 collateralAssetAvailable;
    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based
    // on liquidation type
    int256 nTokenHaircutAssetValue;
    // nToken parameters for calculating liquidation amount
    bytes6 nTokenParameters;
    // ETH exchange rate from local currency to ETH
    ETHRate localETHRate;
    // ETH exchange rate from collateral currency to ETH
    ETHRate collateralETHRate;
    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required
    AssetRateParameters localAssetRate;
    // Used during currency liquidations if the account has liquidity tokens
    CashGroupParameters cashGroup;
    // Used during currency liquidations if the account has liquidity tokens
    MarketParameters[] markets;
}

/// @notice Internal asset array portfolio state
struct PortfolioState {
    // Array of currently stored assets
    PortfolioAsset[] storedAssets;
    // Array of new assets to add
    PortfolioAsset[] newAssets;
    uint256 lastNewAssetIndex;
    // Holds the length of stored assets after accounting for deleted assets
    uint256 storedAssetLength;
}

/// @notice In memory ETH exchange rate used during free collateral calculation.
struct ETHRate {
    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate
    int256 rateDecimals;
    // The exchange rate from base to ETH (if rate invert is required it is already done)
    int256 rate;
    // Amount of buffer to apply to the exchange rate for negative balances.
    int256 buffer;
    // Amount of haircut to apply to the exchange rate for positive balances
    int256 haircut;
    // Liquidation discount for this currency
    int256 liquidationDiscount;
}

/// @notice Internal object used to handle balance state during a transaction
struct BalanceState {
    uint256 currencyId;
    // Cash balance stored in balance state at the beginning of the transaction
    int256 storedCashBalance;
    // nToken balance stored at the beginning of the transaction
    int256 storedNTokenBalance;
    // The net cash change as a result of asset settlement or trading
    int256 netCashChange;
    // Net asset transfers into or out of the account
    int256 netAssetTransferInternalPrecision;
    // Net token transfers into or out of the account
    int256 netNTokenTransfer;
    // Net token supply change from minting or redeeming
    int256 netNTokenSupplyChange;
    // The last time incentives were claimed for this currency
    uint256 lastClaimTime;
    // The last integral supply amount when tokens were claimed
    uint256 lastClaimIntegralSupply;
}

/// @dev Asset rate used to convert between underlying cash and asset cash
struct AssetRateParameters {
    // Address of the asset rate oracle
    address rateOracle;
    // The exchange rate from base to quote (if invert is required it is already done)
    int256 rate;
    // The decimals of the underlying, the rate converts to the underlying decimals
    int256 underlyingDecimals;
}

/// @dev Cash group when loaded into memory
struct CashGroupParameters {
    uint256 currencyId;
    uint256 maxMarketIndex;
    AssetRateParameters assetRate;
    bytes32 data;
}

/// @dev A portfolio asset when loaded in memory
struct PortfolioAsset {
    // Asset currency id
    uint256 currencyId;
    uint256 maturity;
    // Asset type, fCash or liquidity token.
    uint256 assetType;
    // fCash amount or liquidity token amount
    int256 notional;
    // Used for managing portfolio asset state
    uint256 storageSlot;
    // The state of the asset for when it is written to storage
    AssetStorageState storageState;
}

/// @dev Market object as represented in memory
struct MarketParameters {
    bytes32 storageSlot;
    uint256 maturity;
    // Total amount of fCash available for purchase in the market.
    int256 totalfCash;
    // Total amount of cash available for purchase in the market.
    int256 totalAssetCash;
    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.
    int256 totalLiquidity;
    // This is the implied rate that we use to smooth the anchor rate between trades.
    uint256 lastImpliedRate;
    // This is the oracle rate used to value fCash and prevent flash loan attacks
    uint256 oracleRate;
    // This is the timestamp of the previous trade
    uint256 previousTradeTime;
    // Used to determine if the market has been updated
    bytes1 storageState;
}

/// @dev Simplified market object used during settlement
struct SettlementMarket {
    bytes32 storageSlot;
    // Total amount of fCash available for purchase in the market.
    int256 totalfCash;
    // Total amount of cash available for purchase in the market.
    int256 totalAssetCash;
    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.
    int256 totalLiquidity;
    // Un parsed market data used for storage
    bytes32 data;
}

/// @dev Used during settling bitmap assets for calculating bitmap shifts
struct SplitBitmap {
    bytes32 dayBits;
    bytes32 weekBits;
    bytes32 monthBits;
    bytes32 quarterBits;
}

/****** Storage objects ******/

/// @dev Token object in storage
struct TokenStorage {
    // Address of the token
    address tokenAddress;
    // Transfer fees will change token deposit behavior
    bool hasTransferFee;
    TokenType tokenType;
}

/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.
struct ETHRateStorage {
    // Address of the rate oracle
    address rateOracle;
    // The decimal places of precision that the rate oracle uses
    uint8 rateDecimalPlaces;
    // True of the exchange rate must be inverted
    bool mustInvert;
    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision
    // Amount of buffer to apply to the exchange rate for negative balances.
    uint8 buffer;
    // Amount of haircut to apply to the exchange rate for positive balances
    uint8 haircut;
    // Liquidation discount in percentage point terms, 106 means a 6% discount
    uint8 liquidationDiscount;
}

/// @dev Asset rate object as it is represented in storage, total storage is 21 bytes.
struct AssetRateStorage {
    // Address of the rate oracle
    address rateOracle;
    // The decimal places of the underlying asset
    uint8 underlyingDecimalPlaces;
}

/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts
/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there
/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the
/// length.
struct CashGroupSettings {
    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash
    // that is dated less than the longest AMM will be tradable.
    uint8 maxMarketIndex;
    // Time window in minutes that the rate oracle will be averaged over
    uint8 rateOracleTimeWindowMin;
    // Total fees per trade, specified in BPS
    uint8 totalFeeBPS;
    // Share of the fees given to the protocol, denominated in percentage
    uint8 reserveFeeShare;
    // Debt buffer specified in 5 BPS increments
    uint8 debtBuffer5BPS;
    // fCash haircut specified in 5 BPS increments
    uint8 fCashHaircut5BPS;
    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This
    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.
    uint8 settlementPenaltyRate5BPS;
    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for
    uint8 liquidationfCashHaircut5BPS;
    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for
    uint8 liquidationDebtBuffer5BPS;
    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100
    uint8[] liquidityTokenHaircuts;
    // Rate scalar used to determine the slippage of the market
    uint8[] rateScalars;
}

/// @dev Holds account level context information used to determine settlement and
/// free collateral actions. Total storage is 28 bytes
struct AccountContext {
    // Used to check when settlement must be triggered on an account
    uint40 nextSettleTime;
    // For lenders that never incur debt, we use this flag to skip the free collateral check.
    bytes1 hasDebt;
    // Length of the account's asset array
    uint8 assetArrayLength;
    // If this account has bitmaps set, this is the corresponding currency id
    uint16 bitmapCurrencyId;
    // 9 total active currencies possible (2 bytes each)
    bytes18 activeCurrencies;
}

/// @dev Used in view methods to return account balances in a developer friendly manner
struct AccountBalance {
    uint256 currencyId;
    int256 cashBalance;
    int256 nTokenBalance;
    uint256 lastClaimTime;
    uint256 lastClaimIntegralSupply;
}",3196
RealWorld_TA_23_MockLiquidation_RealWorld_20240803024708.log,23,MockLiquidation,130977,3852,134829,124.0,0.731925,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/portfolio/PortfolioHandler.sol"";
import ""../internal/AccountContextHandler.sol"";
import ""../internal/liquidation/LiquidationHelpers.sol"";
import ""../internal/liquidation/LiquidateCurrency.sol"";
import ""../internal/liquidation/LiquidatefCash.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""./BaseMockLiquidation.sol"";

contract MockLiquidationSetup is BaseMockLiquidation {
    function preLiquidationActions(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency
    )
        external
        returns (
            AccountContext memory,
            LiquidationFactors memory,
            PortfolioState memory
        )
    {
        return
            LiquidationHelpers.preLiquidationActions(
                liquidateAccount,
                localCurrency,
                collateralCurrency
            );
    }
}

contract MockLocalLiquidation is BaseMockLiquidation {
    using BalanceHandler for BalanceState;

    function liquidateLocalCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint96 maxNTokenLiquidation,
        uint256 blockTime
    )
        external
        returns (
            BalanceState memory,
            int256,
            PortfolioState memory,
            LiquidationFactors memory
        )
    {
        (
            AccountContext memory accountContext,
            LiquidationFactors memory factors,
            PortfolioState memory portfolio
        ) = LiquidationHelpers.preLiquidationActions(liquidateAccount, localCurrency, 0);
        BalanceState memory localBalanceState;
        localBalanceState.loadBalanceState(liquidateAccount, localCurrency, accountContext);

        int256 netLocalFromLiquidator =
            LiquidateCurrency.liquidateLocalCurrency(
                localCurrency,
                maxNTokenLiquidation,
                blockTime,
                localBalanceState,
                factors,
                portfolio
            );

        LiquidateCurrency.finalizeLiquidatedCollateralAndPortfolio(
            liquidateAccount,
            localBalanceState, // In this case, local currency is the collateral
            accountContext,
            portfolio,
            factors.markets
        );

        return (localBalanceState, netLocalFromLiquidator, portfolio, factors);
    }

    function fc(address account) external view returns (int256, int256[] memory) {
        return FreeCollateralExternal.getFreeCollateralView(account);
    }
}

contract MockLocalLiquidationOverride is BaseMockLiquidation {
    function liquidateLocalCurrencyOverride(
        uint256 localCurrency,
        uint96 maxNTokenLiquidation,
        uint256 blockTime,
        BalanceState memory liquidatedBalanceState,
        LiquidationFactors memory factors
    )
        external
        view
        returns (
            BalanceState memory,
            int256,
            MarketParameters[] memory
        )
    {
        PortfolioState memory portfolio;

        int256 netLocalFromLiquidator =
            LiquidateCurrency.liquidateLocalCurrency(
                localCurrency,
                maxNTokenLiquidation,
                blockTime,
                liquidatedBalanceState,
                factors,
                portfolio
            );

        return (liquidatedBalanceState, netLocalFromLiquidator, factors.markets);
    }
}

contract MockCollateralLiquidation is BaseMockLiquidation {
    function liquidateCollateralCurrency(
        BalanceState memory liquidatedBalanceState,
        LiquidationFactors memory factors,
        PortfolioState memory portfolio,
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation,
        uint256 blockTime
    )
        external
        view
        returns (
            BalanceState memory,
            int256,
            PortfolioState memory,
            MarketParameters[] memory
        )
    {
        int256 localAssetCashFromLiquidator =
            LiquidateCurrency.liquidateCollateralCurrency(
                maxCollateralLiquidation,
                maxNTokenLiquidation,
                blockTime,
                liquidatedBalanceState,
                factors,
                portfolio
            );

        return (liquidatedBalanceState, localAssetCashFromLiquidator, portfolio, factors.markets);
    }
}

contract MockfCashLiquidation is BaseMockLiquidation {
    function preLiquidationActions(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency
    )
        external
        returns (
            AccountContext memory,
            LiquidationFactors memory,
            PortfolioState memory
        )
    {
        return
            LiquidationHelpers.preLiquidationActions(
                liquidateAccount,
                localCurrency,
                collateralCurrency
            );
    }

    function liquidatefCashLocal(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts,
        LiquidatefCash.fCashContext memory c,
        uint256 blockTime
    )
        external
        view
        returns (
            int256[] memory,
            int256,
            LiquidatefCash.fCashContext memory
        )
    {
        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);
        LiquidatefCash.liquidatefCashLocal(
            liquidateAccount,
            localCurrency,
            fCashMaturities,
            maxfCashLiquidateAmounts,
            c,
            blockTime
        );

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator, c);
    }

    function liquidatefCashCrossCurrency(
        address liquidateAccount,
        uint256 collateralCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts,
        LiquidatefCash.fCashContext memory c,
        uint256 blockTime
    )
        external
        view
        returns (
            int256[] memory,
            int256,
            PortfolioState memory
        )
    {
        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);

        LiquidatefCash.liquidatefCashCrossCurrency(
            liquidateAccount,
            collateralCurrency,
            fCashMaturities,
            maxfCashLiquidateAmounts,
            c,
            blockTime
        );

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator, c.portfolio);
    }

    function fc(address account) external view returns (int256, int256[] memory) {
        return FreeCollateralExternal.getFreeCollateralView(account);
    }
}",1341
RealWorld_TA_23_CErc20Interface_RealWorld_20240803092317.log,23,CErc20Interface,30413,1996,32409,371.0,0.191985,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.7.0;

import ""./CTokenInterface.sol"";

interface CErc20Interface {

    /*** User Interface ***/

    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
    function borrow(uint borrowAmount) external returns (uint);
    function repayBorrow(uint repayAmount) external returns (uint);
    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);
    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);
}",149
RealWorld_TA_23_MockFloatingPoint56_RealWorld_20240803024914.log,23,MockFloatingPoint56,29387,1296,30683,96.0,0.172855,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

import ""../math/FloatingPoint56.sol"";
import ""../math/Bitmap.sol"";

contract MockFloatingPoint56 {
    function testPackingUnpacking(uint256 value)
        external
        pure
        returns (bytes32 packed, uint256 unpacked)
    {
        packed = FloatingPoint56.packTo56Bits(value);
        unpacked = FloatingPoint56.unpackFrom56Bits(uint256(packed));
    }

    function getMSB(uint256 x) external pure returns (uint256) {
        return Bitmap.getMSB(x);
    }
}",132
RealWorld_TA_23_ERC1967Upgrade_RealWorld_20240803030430.log,23,ERC1967Upgrade,85639,1603,87242,103.0,0.460255,"// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import ""@openzeppelin/contracts/utils/Address.sol"";
import ""../utils/StorageSlot.sol"";

/**
 * @dev This abstract contract provides getters and event emitting update functions for
 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
 *
 * _Available since v4.1._
 *
 */
abstract contract ERC1967Upgrade {
    // This is the keccak-256 hash of ""eip1967.proxy.rollback"" subtracted by 1
    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Emitted when the implementation is upgraded.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Returns the current implementation address.
     */
    function _getImplementation() internal view returns (address) {
        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 implementation slot.
     */
    function _setImplementation(address newImplementation) private {
        require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");
        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    }

    /**
     * @dev Perform implementation upgrade
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Perform implementation upgrade with additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCall(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        _upgradeTo(newImplementation);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(newImplementation, data);
        }
    }

    /**
     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeToAndCallSecure(
        address newImplementation,
        bytes memory data,
        bool forceCall
    ) internal {
        address oldImplementation = _getImplementation();

        // Initial upgrade and setup call
        _setImplementation(newImplementation);
        if (data.length > 0 || forceCall) {
            Address.functionDelegateCall(newImplementation, data);
        }

        // Perform rollback test if not already in progress
        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);
        if (!rollbackTesting.value) {
            // Trigger rollback using upgradeTo from the new implementation
            rollbackTesting.value = true;
            Address.functionDelegateCall(
                newImplementation,
                abi.encodeWithSignature(""upgradeTo(address)"", oldImplementation)
            );
            rollbackTesting.value = false;
            // Check rollback was effective
            require(oldImplementation == _getImplementation(), ""ERC1967Upgrade: upgrade breaks further upgrades"");
            // Finally reset to the new implementation and log the upgrade
            _upgradeTo(newImplementation);
        }
    }

}",799
RealWorld_TA_23_LiquidatefCash_RealWorld_20240803032421.log,23,LiquidatefCash,424104,5014,429118,365.0,2.2208,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./LiquidationHelpers.sol"";
import ""../AccountContextHandler.sol"";
import ""../valuation/AssetHandler.sol"";
import ""../markets/CashGroup.sol"";
import ""../markets/AssetRate.sol"";
import ""../valuation/ExchangeRate.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../portfolio/BitmapAssetsHandler.sol"";
import ""../../external/FreeCollateralExternal.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library LiquidatefCash {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using ExchangeRate for ETHRate;
    using AssetHandler for PortfolioAsset;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using PortfolioHandler for PortfolioState;

    /// @notice Calculates the two discount factors relevant when liquidating fCash.
    function _calculatefCashDiscounts(
        LiquidationFactors memory factors,
        uint256 maturity,
        uint256 blockTime,
        bool isNotionalPositive
    ) private view returns (int256 riskAdjustedDiscountFactor, int256 liquidationDiscountFactor) {
        uint256 oracleRate = factors.cashGroup.calculateOracleRate(maturity, blockTime);
        uint256 timeToMaturity = maturity.sub(blockTime);

        if (isNotionalPositive) {
            // This is the discount factor used to calculate the fCash present value during free collateral
            riskAdjustedDiscountFactor = AssetHandler.getDiscountFactor(
                timeToMaturity,
                oracleRate.add(factors.cashGroup.getfCashHaircut())
            );

            // This is the discount factor that liquidators get to purchase fCash at, will be larger than
            // the risk adjusted discount factor.
            liquidationDiscountFactor = AssetHandler.getDiscountFactor(
                timeToMaturity,
                oracleRate.add(factors.cashGroup.getLiquidationfCashHaircut())
            );
        } else {
            uint256 buffer = factors.cashGroup.getDebtBuffer();
            riskAdjustedDiscountFactor = AssetHandler.getDiscountFactor(
                timeToMaturity,
                oracleRate < buffer ? 0 : oracleRate.sub(buffer)
            );

            buffer = factors.cashGroup.getLiquidationDebtBuffer();
            liquidationDiscountFactor = AssetHandler.getDiscountFactor(
                timeToMaturity,
                oracleRate < buffer ? 0 : oracleRate.sub(buffer)
            );
        }
    }

    /// @dev Helper function because of two portfolio types
    function _getfCashNotional(
        address liquidateAccount,
        fCashContext memory context,
        uint256 currencyId,
        uint256 maturity
    ) private view returns (int256) {
        if (context.accountContext.bitmapCurrencyId == currencyId) {
            return
                BitmapAssetsHandler.getifCashNotional(liquidateAccount, currencyId, maturity);
        }

        PortfolioAsset[] memory portfolio = context.portfolio.storedAssets;
        for (uint256 i; i < portfolio.length; i++) {
            if (
                portfolio[i].currencyId == currencyId &&
                portfolio[i].assetType == Constants.FCASH_ASSET_TYPE &&
                portfolio[i].maturity == maturity
            ) {
                return portfolio[i].notional;
            }
        }

        // If asset is not found then we return zero instead of failing in the case that a previous
        // liquidation has already liquidated the specified fCash asset. This liquidation can continue
        // to the next specified fCash asset.
        return 0;
    }

    struct fCashContext {
        AccountContext accountContext;
        LiquidationFactors factors;
        PortfolioState portfolio;
        int256 localCashBalanceUnderlying;
        int256 underlyingBenefitRequired;
        int256 localAssetCashFromLiquidator;
        int256 liquidationDiscount;
        int256[] fCashNotionalTransfers;
    }

    /// @notice Allows the liquidator to purchase fCash in the same currency that a debt is denominated in. It's
    /// also possible that there is no debt in the local currency, in that case the liquidated account will gain the
    /// benefit of the difference between the discounted fCash value and the cash
    function liquidatefCashLocal(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts,
        fCashContext memory c,
        uint256 blockTime
    ) internal view {
        if (c.factors.localAssetAvailable > 0) {
            // If local available is positive then we can bring it down to zero
            //prettier-ignore
            c.underlyingBenefitRequired = c.factors.localETHRate
                .convertETHTo(c.factors.netETHValue.neg())
                .mul(Constants.PERCENTAGE_DECIMALS)
                // If the haircut is zero then this will revert which is the correct result. A currency with
                // a haircut to zero does not affect free collateral.
                .div(c.factors.localETHRate.haircut);
        } else {
            // If local available is negative then we can bring it up to zero
            c.underlyingBenefitRequired = c.factors.localAssetRate.convertToUnderlying(
                c.factors.localAssetAvailable.neg()
            );
        }

        for (uint256 i; i < fCashMaturities.length; i++) {
            int256 notional =
                _getfCashNotional(liquidateAccount, c, localCurrency, fCashMaturities[i]);
            // If a notional balance is negative, ensure that there is some local cash balance to
            // purchase for the liquidation. Allow a zero cash balance so that the loop continues even if
            // all of the cash balance has been transferred.
            if (notional < 0) require(c.localCashBalanceUnderlying >= 0); // dev: insufficient cash balance
            if (notional == 0) continue;

            // We know that liquidation discount > risk adjusted discount because they are required to
            // be this way when setting cash group variables.
            (int256 riskAdjustedDiscountFactor, int256 liquidationDiscountFactor) =
                _calculatefCashDiscounts(c.factors, fCashMaturities[i], blockTime, notional > 0);

            // The benefit to the liquidated account is the difference between the liquidation discount factor
            // and the risk adjusted discount factor:
            // localCurrencyBenefit = fCash * (liquidationDiscountFactor - riskAdjustedDiscountFactor)
            // fCash = localCurrencyBenefit / (liquidationDiscountFactor - riskAdjustedDiscountFactor)
            c.fCashNotionalTransfers[i] = c.underlyingBenefitRequired
            // NOTE: Governance should be set such that these discount factors are unlikely to be zero. It's
            // possible that the interest rates are so low that this situation can occur.
                .divInRatePrecision(liquidationDiscountFactor.sub(riskAdjustedDiscountFactor).abs());

            // fCashNotionalTransfers[i] is always positive at this point. The max liquidate amount is
            // calculated using the absolute value of the notional amount to ensure that the inequalities
            // operate properly inside calculateLiquidationAmount.
            c.fCashNotionalTransfers[i] = LiquidationHelpers.calculateLiquidationAmount(
                c.fCashNotionalTransfers[i],
                notional.abs(),
                int256(maxfCashLiquidateAmounts[i])
            );

            int256 fCashLiquidationValueUnderlying =
                c.fCashNotionalTransfers[i].mulInRatePrecision(liquidationDiscountFactor);

            if (notional < 0) {
                // In the case of negative notional amounts, limit the amount of liquidation to the local cash
                // balance in underlying so that the liquidated account does not incur a negative cash balance.
                if (fCashLiquidationValueUnderlying > c.localCashBalanceUnderlying) {
                    // We know that all these values are positive at this point.
                    c.fCashNotionalTransfers[i] = c.fCashNotionalTransfers[i]
                        .mul(c.localCashBalanceUnderlying)
                        .div(fCashLiquidationValueUnderlying);
                    fCashLiquidationValueUnderlying = c.localCashBalanceUnderlying;
                }

                // Flip the sign when the notional is negative
                c.fCashNotionalTransfers[i] = c.fCashNotionalTransfers[i].neg();
                // When the notional is negative, cash balance will be transferred to the liquidator instead of
                // being provided by the liquidator.
                fCashLiquidationValueUnderlying = fCashLiquidationValueUnderlying.neg();
            }

            // NOTE: localAssetCashFromLiquidator is actually in underlying terms during this loop, it is converted to asset terms just once
            // at the end of the loop to limit loss of precision
            c.localAssetCashFromLiquidator = c.localAssetCashFromLiquidator.add(
                fCashLiquidationValueUnderlying
            );
            c.localCashBalanceUnderlying = c.localCashBalanceUnderlying.add(
                fCashLiquidationValueUnderlying
            );

            // Deduct the total benefit gained from liquidating this fCash position
            c.underlyingBenefitRequired = c.underlyingBenefitRequired.sub(
                c.fCashNotionalTransfers[i]
                    .mulInRatePrecision(liquidationDiscountFactor.sub(riskAdjustedDiscountFactor).abs())
                    .abs()
            );

            if (c.underlyingBenefitRequired <= Constants.LIQUIDATION_DUST) break;
        }

        // Convert local to purchase to asset terms for transfers
        c.localAssetCashFromLiquidator = c.factors.localAssetRate.convertFromUnderlying(
            c.localAssetCashFromLiquidator
        );
    }

    /// @notice Allows the liquidator to purchase fCash in a different currency that a debt is denominated in.
    function liquidatefCashCrossCurrency(
        address liquidateAccount,
        uint256 collateralCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts,
        fCashContext memory c,
        uint256 blockTime
    ) internal view {
        require(c.factors.localAssetAvailable < 0); // dev: no local debt
        require(c.factors.collateralAssetAvailable > 0); // dev: no collateral assets

        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);
        {
            // NOTE: underlying benefit is return in asset terms from this function, convert it to underlying
            // for the purposes of this method
            (c.underlyingBenefitRequired, c.liquidationDiscount) = LiquidationHelpers
                .calculateCrossCurrencyBenefitAndDiscount(c.factors);
            c.underlyingBenefitRequired = c.factors.cashGroup.assetRate.convertToUnderlying(
                c.underlyingBenefitRequired
            );
        }

        for (uint256 i; i < fCashMaturities.length; i++) {
            int256 notional =
                _getfCashNotional(liquidateAccount, c, collateralCurrency, fCashMaturities[i]);
            if (notional == 0) continue;
            require(notional > 0); // dev: invalid fcash asset

            c.fCashNotionalTransfers[i] = _calculateCrossCurrencyfCashToLiquidate(
                c,
                fCashMaturities[i],
                blockTime,
                int256(maxfCashLiquidateAmounts[i]),
                notional
            );

            if (
                c.underlyingBenefitRequired <= Constants.LIQUIDATION_DUST ||
                c.factors.collateralAssetAvailable <= 0
            ) break;
        }
    }

    function _calculateCrossCurrencyfCashToLiquidate(
        fCashContext memory c,
        uint256 maturity,
        uint256 blockTime,
        int256 maxfCashLiquidateAmount,
        int256 notional
    ) private view returns (int256) {
        (int256 riskAdjustedDiscountFactor, int256 liquidationDiscountFactor) =
            _calculatefCashDiscounts(c.factors, maturity, blockTime, true);

        // collateralPurchased = fCashToLiquidate * fCashDiscountFactor
        // (see: _calculateCollateralToRaise)
        // collateralBenefit = collateralPurchased * (localBuffer / liquidationDiscount - collateralHaircut)
        // totalBenefit = fCashBenefit + collateralBenefit
        // totalBenefit = fCashToLiquidate * (liquidationDiscountFactor - riskAdjustedDiscountFactor) +
        //      fCashToLiquidate * liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut)
        // totalBenefit = fCashToLiquidate * [
        //      (liquidationDiscountFactor - riskAdjustedDiscountFactor) +
        //      (liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut))
        // ]
        // fCashToLiquidate = totalBenefit / [
        //      (liquidationDiscountFactor - riskAdjustedDiscountFactor) +
        //      (liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut))
        // ]
        int256 benefitMultiplier;
        {
            // prettier-ignore
            int256 termTwo = (
                    c.factors.localETHRate.buffer.mul(Constants.PERCENTAGE_DECIMALS).div(
                        c.liquidationDiscount
                    )
                ).sub(c.factors.collateralETHRate.haircut);
            termTwo = liquidationDiscountFactor.mul(termTwo).div(Constants.PERCENTAGE_DECIMALS);
            int256 termOne = liquidationDiscountFactor.sub(riskAdjustedDiscountFactor);
            benefitMultiplier = termOne.add(termTwo);
        }

        int256 fCashToLiquidate =
            c.underlyingBenefitRequired.divInRatePrecision(benefitMultiplier);

        fCashToLiquidate = LiquidationHelpers.calculateLiquidationAmount(
            fCashToLiquidate,
            notional,
            maxfCashLiquidateAmount
        );

        // Ensures that local available does not go above zero and collateral available does not go below zero
        int256 localAssetCashFromLiquidator;
        (fCashToLiquidate, localAssetCashFromLiquidator) = _limitPurchaseByAvailableAmounts(
            c,
            liquidationDiscountFactor,
            riskAdjustedDiscountFactor,
            fCashToLiquidate
        );

        // inverse of initial fCashToLiquidate calculation above
        // totalBenefit = fCashToLiquidate * [
        //      (liquidationDiscountFactor - riskAdjustedDiscountFactor) +
        //      (liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut))
        // ]
        int256 benefitGainedUnderlying = fCashToLiquidate.mulInRatePrecision(benefitMultiplier);

        c.underlyingBenefitRequired = c.underlyingBenefitRequired.sub(benefitGainedUnderlying);
        c.localAssetCashFromLiquidator = c.localAssetCashFromLiquidator.add(
            localAssetCashFromLiquidator
        );

        return fCashToLiquidate;
    }

    /// @dev Limits the fCash purchase to ensure that collateral available and local available do not go below zero,
    /// in both those cases the liquidated account would incur debt
    function _limitPurchaseByAvailableAmounts(
        fCashContext memory c,
        int256 liquidationDiscountFactor,
        int256 riskAdjustedDiscountFactor,
        int256 fCashToLiquidate
    ) private pure returns (int256, int256) {
        // The collateral value of the fCash is discounted back to PV given the liquidation discount factor,
        // this is the discounted value that the liquidator will purchase it at.
        int256 fCashLiquidationUnderlyingPV = fCashToLiquidate.mulInRatePrecision(liquidationDiscountFactor);
        int256 fCashRiskAdjustedUnderlyingPV = fCashToLiquidate.mulInRatePrecision(riskAdjustedDiscountFactor);

        // Ensures that collateralAssetAvailable does not go below zero
        int256 collateralUnderlyingAvailable =
            c.factors.cashGroup.assetRate.convertToUnderlying(c.factors.collateralAssetAvailable);
        if (fCashRiskAdjustedUnderlyingPV > collateralUnderlyingAvailable) {
            // If inside this if statement then all collateralAssetAvailable should be coming from fCashRiskAdjustedPV
            // collateralAssetAvailable = fCashRiskAdjustedPV
            // collateralAssetAvailable = fCashToLiquidate * riskAdjustedDiscountFactor
            // fCashToLiquidate = collateralAssetAvailable / riskAdjustedDiscountFactor
            fCashToLiquidate = collateralUnderlyingAvailable.divInRatePrecision(riskAdjustedDiscountFactor);

            fCashRiskAdjustedUnderlyingPV = collateralUnderlyingAvailable;

            // Recalculate the PV at the new liquidation amount
            fCashLiquidationUnderlyingPV = fCashToLiquidate.mulInRatePrecision(liquidationDiscountFactor);
        }

        int256 localAssetCashFromLiquidator;
        (fCashToLiquidate, localAssetCashFromLiquidator) = _calculateLocalToPurchaseUnderlying(
            c.factors,
            c.liquidationDiscount,
            fCashLiquidationUnderlyingPV,
            fCashToLiquidate
        );

        // As we liquidate here the local available and collateral available will change. Update values accordingly so
        // that the limits will be hit on subsequent iterations.
        c.factors.collateralAssetAvailable = c.factors.collateralAssetAvailable.subNoNeg(
            c.factors.cashGroup.assetRate.convertFromUnderlying(fCashRiskAdjustedUnderlyingPV)
        );
        c.factors.localAssetAvailable = c.factors.localAssetAvailable.add(
            localAssetCashFromLiquidator
        );

        return (fCashToLiquidate, localAssetCashFromLiquidator);
    }

    function _calculateLocalToPurchaseUnderlying(
        LiquidationFactors memory factors,
        int256 liquidationDiscount,
        int256 fCashLiquidationUnderlyingPV,
        int256 fCashToLiquidate
    ) internal pure returns (int256, int256) {
        int256 localUnderlyingFromLiquidator =
            fCashLiquidationUnderlyingPV
                .mul(Constants.PERCENTAGE_DECIMALS)
                .mul(factors.localETHRate.rateDecimals)
                .div(ExchangeRate.exchangeRate(factors.localETHRate, factors.collateralETHRate))
                .div(liquidationDiscount);

        int256 localAssetFromLiquidator =
            factors.localAssetRate.convertFromUnderlying(localUnderlyingFromLiquidator);

        if (localAssetFromLiquidator > factors.localAssetAvailable.neg()) {
            // If the local to purchase will put the local available into negative territory we
            // have to cut the collateral purchase amount back. Putting local available into negative
            // territory will force the liquidated account to incur more debt.

            // This is still in underlying terms because it is multiplied by a ratio of two values in asset terms
            fCashToLiquidate = fCashToLiquidate.mul(factors.localAssetAvailable.neg()).div(
                localAssetFromLiquidator
            );

            localAssetFromLiquidator = factors.localAssetAvailable.neg();
        }

        return (fCashToLiquidate, localAssetFromLiquidator);
    }

    /// @dev Finalizes fCash liquidation for both local and cross currency liquidation
    function finalizefCashLiquidation(
        address liquidateAccount,
        address liquidator,
        uint256 localCurrency,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        fCashContext memory c
    ) internal returns (int256[] memory, int256) {
        AccountContext memory liquidatorContext =
            LiquidationHelpers.finalizeLiquidatorLocal(
                liquidator,
                localCurrency,
                c.localAssetCashFromLiquidator,
                0
            );

        LiquidationHelpers.finalizeLiquidatedLocalBalance(
            liquidateAccount,
            localCurrency,
            c.accountContext,
            c.localAssetCashFromLiquidator
        );

        bool liquidatorIncursDebt;
        (liquidatorIncursDebt, liquidatorContext) =
            _transferAssets(
                liquidateAccount,
                liquidator,
                liquidatorContext,
                fCashCurrency,
                fCashMaturities,
                c
            );

        liquidatorContext.setAccountContext(liquidator);
        c.accountContext.setAccountContext(liquidateAccount);

        // If the liquidator takes on debt as a result of the liquidation and has debt in their portfolio
        // then they must have a free collateral check. It's possible for the liquidator to skip this if the
        // negative fCash incurred from the liquidation nets off against an existing fCash position.
        if (liquidatorIncursDebt && liquidatorContext.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(liquidator);
        }

        return (c.fCashNotionalTransfers, c.localAssetCashFromLiquidator);
    }

    function _transferAssets(
        address liquidateAccount,
        address liquidator,
        AccountContext memory liquidatorContext,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        fCashContext memory c
    ) private returns (bool, AccountContext memory) {
        (PortfolioAsset[] memory assets, bool liquidatorIncursDebt) =
            _makeAssetArray(fCashCurrency, fCashMaturities, c.fCashNotionalTransfers);

        // NOTE: when this method returns liquidatorContext may not point to the same
        // memory location as before so we need to ensure that the liquidator context
        // is returned from this method and set properly
        liquidatorContext = TransferAssets.placeAssetsInAccount(
            liquidator,
            liquidatorContext,
            assets
        );
        TransferAssets.invertNotionalAmountsInPlace(assets);

        if (c.accountContext.bitmapCurrencyId == 0) {
            c.portfolio.addMultipleAssets(assets);
            AccountContextHandler.storeAssetsAndUpdateContext(
                c.accountContext,
                liquidateAccount,
                c.portfolio,
                false // Although this is liquidation, we should not allow past max assets here
            );
        } else {
            BitmapAssetsHandler.addMultipleifCashAssets(liquidateAccount, c.accountContext, assets);
        }

        return (liquidatorIncursDebt, liquidatorContext);
    }

    function _makeAssetArray(
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        int256[] memory fCashNotionalTransfers
    ) private pure returns (PortfolioAsset[] memory, bool) {
        PortfolioAsset[] memory assets = new PortfolioAsset[](fCashMaturities.length);
        bool liquidatorIncursDebt = false;
        for (uint256 i; i < assets.length; i++) {
            assets[i].currencyId = fCashCurrency;
            assets[i].assetType = Constants.FCASH_ASSET_TYPE;
            assets[i].notional = fCashNotionalTransfers[i];
            assets[i].maturity = fCashMaturities[i];

            if (assets[i].notional < 0) liquidatorIncursDebt = true;
        }

        return (assets, liquidatorIncursDebt);
    }
}",4951
RealWorld_TA_23_InitializeMarketsAction_RealWorld_20240803062358.log,23,InitializeMarketsAction,593440,5455,598895,364.0,3.0763,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./nTokenMintAction.sol"";
import ""../../internal/markets/Market.sol"";
import ""../../internal/markets/CashGroup.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/portfolio/PortfolioHandler.sol"";
import ""../../internal/settlement/SettlePortfolioAssets.sol"";
import ""../../internal/settlement/SettleBitmapAssets.sol"";
import ""../../internal/nTokenHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/Bitmap.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

/// @notice Initialize markets is called once every quarter to setup the new markets. Only the nToken account
/// can initialize markets, and this method will be called on behalf of that account. In this action
/// the following will occur:
///  - nToken Liquidity Tokens will be settled
///  - Any ifCash assets will be settled
///  - If nToken liquidity tokens are settled with negative net ifCash, enough cash will be withheld at the PV
///    to purchase offsetting positions
///  - fCash positions are written to storage
///  - For each market, calculate the proportion of fCash to cash given:
///     - previous oracle rates
///     - rate anchor set by governance
///     - percent of cash to deposit into the market set by governance
///  - Set new markets and add liquidity tokens to portfolio
library InitializeMarketsAction {
    using Bitmap for bytes32;
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using PortfolioHandler for PortfolioState;
    using Market for MarketParameters;
    using BalanceHandler for BalanceState;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;

    event MarketsInitialized(uint16 currencyId);
    event SweepCashIntoMarkets(uint16 currencyId, int256 cashIntoMarkets);

    struct GovernanceParameters {
        int256[] depositShares;
        int256[] leverageThresholds;
        int256[] annualizedAnchorRates;
        int256[] proportions;
    }

    function _getGovernanceParameters(uint256 currencyId, uint256 maxMarketIndex)
        private
        view
        returns (GovernanceParameters memory)
    {
        GovernanceParameters memory params;
        (params.depositShares, params.leverageThresholds) = nTokenHandler.getDepositParameters(
            currencyId,
            maxMarketIndex
        );

        (params.annualizedAnchorRates, params.proportions) = nTokenHandler.getInitializationParameters(
            currencyId,
            maxMarketIndex
        );

        return params;
    }

    function _settleNTokenPortfolio(nTokenPortfolio memory nToken, uint256 blockTime)
        private
        returns (bytes32)
    {
        // nToken never has idiosyncratic cash between 90 day intervals but since it also has a
        // bitmap fCash assets we don't set the pointer to the settlement date of the liquidity
        // tokens (1 quarter away), instead we set it to the current block time. This is a bit
        // esoteric but will ensure that ifCash is never improperly settled.
        uint256 referenceTime = DateTime.getReferenceTime(blockTime);
        require(nToken.lastInitializedTime < referenceTime, ""IM: invalid time"");

        {
            // Settles liquidity token balances and portfolio state now contains the net fCash amounts
            SettleAmount[] memory settleAmount =
                SettlePortfolioAssets.settlePortfolio(nToken.portfolioState, blockTime);
            nToken.cashBalance = nToken.cashBalance.add(settleAmount[0].netCashChange);
        }

        (bytes32 ifCashBitmap, int256 settledAssetCash, uint256 blockTimeUTC0) =
            SettleBitmapAssets.settleBitmappedCashGroup(
                nToken.tokenAddress,
                nToken.cashGroup.currencyId,
                nToken.lastInitializedTime,
                blockTime
            );
        nToken.cashBalance = nToken.cashBalance.add(settledAssetCash);

        // The ifCashBitmap has been updated to reference this new settlement time
        nToken.lastInitializedTime = uint40(blockTimeUTC0);

        return ifCashBitmap;
    }

    /// @notice Special method to get previous markets, normal usage would not reference previous markets
    /// in this way
    function _getPreviousMarkets(
        uint256 currencyId,
        uint256 blockTime,
        nTokenPortfolio memory nToken,
        MarketParameters[] memory previousMarkets
    ) private view {
        uint256 rateOracleTimeWindow = nToken.cashGroup.getRateOracleTimeWindow();
        // This will reference the previous settlement date to get the previous markets
        uint256 settlementDate = DateTime.getReferenceTime(blockTime);

        // Assume that assets are stored in order and include all assets of the previous market
        // set. This will account for the potential that markets.length is greater than the previous
        // markets when the maxMarketIndex is increased (increasing the overall number of markets).
        // We don't fetch the 3 month market (i = 0) because it has settled and will not be used for
        // the subsequent calculations.
        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) {
            previousMarkets[i].loadMarketWithSettlementDate(
                currencyId,
                // These assets will reference the previous liquidity tokens
                nToken.portfolioState.storedAssets[i].maturity,
                blockTime,
                // No liquidity tokens required for this process
                false,
                rateOracleTimeWindow,
                settlementDate
            );
        }
    }

    /// @notice Check the net fCash assets set by the portfolio and withhold cash to account for
    /// the PV of negative ifCash. Also sets the ifCash assets into the nToken mapping.
    function _withholdAndSetfCashAssets(
        nTokenPortfolio memory nToken,
        MarketParameters[] memory previousMarkets,
        uint256 currencyId,
        bytes32 ifCashBitmap,
        uint256 blockTime
    ) private returns (int256, bytes32) {
        // Residual fcash must be put into the ifCash bitmap from the portfolio, skip the 3 month
        // liquidity token since there is no residual fCash for that maturity, it always settles to cash.
        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) {
            PortfolioAsset memory asset = nToken.portfolioState.storedAssets[i];
            if (asset.assetType != Constants.FCASH_ASSET_TYPE) continue;

            // prettier-ignore
            (
                ifCashBitmap,
                /* notional */
            ) = BitmapAssetsHandler.addifCashAsset(
                nToken.tokenAddress,
                currencyId,
                asset.maturity,
                nToken.lastInitializedTime,
                asset.notional,
                ifCashBitmap
            );

            // Do not have fCash assets stored in the portfolio
            nToken.portfolioState.deleteAsset(i);
        }

        // Recalculate what the withholdings are if there are any ifCash assets remaining
        int256 assetCashWithholding =
            _getNTokenNegativefCashWithholding(nToken, previousMarkets, blockTime, ifCashBitmap);

        return (assetCashWithholding, ifCashBitmap);
    }

    /// @notice If a nToken incurs a negative fCash residual as a result of lending, this means
    /// that we are going to need to withhold some amount of cash so that market makers can purchase and
    /// clear the debts off the balance sheet.
    function _getNTokenNegativefCashWithholding(
        nTokenPortfolio memory nToken,
        MarketParameters[] memory previousMarkets,
        uint256 blockTime,
        bytes32 assetsBitmap
    ) internal view returns (int256) {
        int256 totalCashWithholding;
        // This buffer is denominated in 10 basis point increments. It is used to shift the withholding rate to ensure
        // that sufficient cash is withheld for negative fCash balances.
        uint256 oracleRateBuffer =
            uint256(uint8(nToken.parameters[Constants.CASH_WITHHOLDING_BUFFER])) *
                10 *
                Constants.BASIS_POINT;

        uint256 bitNum = assetsBitmap.getNextBitNum();
        while (bitNum != 0) {
            uint256 maturity = DateTime.getMaturityFromBitNum(nToken.lastInitializedTime, bitNum);

            // When looping for sweepCashIntoMarkets, previousMarkets is not defined and we only
            // want to apply withholding for idiosyncratic fCash.
            if (
                previousMarkets.length == 0 &&
                DateTime.isValidMarketMaturity(
                    nToken.cashGroup.maxMarketIndex,
                    maturity,
                    blockTime
                )
            ) {
                assetsBitmap = assetsBitmap << 1;
                bitNum += 1;
                continue;
            }

            int256 notional =
                BitmapAssetsHandler.getifCashNotional(
                    nToken.tokenAddress,
                    nToken.cashGroup.currencyId,
                    maturity
                );

            // Withholding only applies for negative cash balances
            if (notional < 0) {
                uint256 oracleRate;
                if (previousMarkets.length > 0) {
                    oracleRate = _getPreviousWithholdingRate(
                        nToken.cashGroup,
                        previousMarkets,
                        maturity,
                        blockTime
                    );
                } else {
                    oracleRate = nToken.cashGroup.calculateOracleRate(maturity, blockTime);
                }

                if (oracleRateBuffer > oracleRate) {
                    oracleRate = 0;
                } else {
                    oracleRate = oracleRate.sub(oracleRateBuffer);
                }

                totalCashWithholding = totalCashWithholding.sub(
                    AssetHandler.getPresentValue(notional, maturity, blockTime, oracleRate)
                );
            }

            // Turn off the bit and look for the next one
            assetsBitmap = assetsBitmap.setBit(bitNum, false);
            bitNum = assetsBitmap.getNextBitNum();
        }

        return nToken.cashGroup.assetRate.convertFromUnderlying(totalCashWithholding);
    }

    function _getPreviousWithholdingRate(
        CashGroupParameters memory cashGroup,
        MarketParameters[] memory markets,
        uint256 maturity,
        uint256 blockTime
    ) private pure returns (uint256) {
        // Get the market index referenced in the previous quarter
        (uint256 marketIndex, bool idiosyncratic) =
            DateTime.getMarketIndex(
                cashGroup.maxMarketIndex,
                maturity,
                blockTime - Constants.QUARTER
            );
        // NOTE: If idiosyncratic cash survives a quarter without being purchased this will fail
        require(!idiosyncratic); // dev: fail on market index

        return markets[marketIndex - 1].oracleRate;
    }

    function _calculateNetAssetCashAvailable(
        nTokenPortfolio memory nToken,
        MarketParameters[] memory previousMarkets,
        uint256 blockTime,
        uint256 currencyId,
        bool isFirstInit
    ) private returns (int256, bytes32) {
        int256 netAssetCashAvailable;
        bytes32 ifCashBitmap;
        int256 assetCashWithholding;

        if (isFirstInit) {
            nToken.lastInitializedTime = uint40(DateTime.getTimeUTC0(blockTime));
        } else {
            ifCashBitmap = _settleNTokenPortfolio(nToken, blockTime);
            _getPreviousMarkets(currencyId, blockTime, nToken, previousMarkets);
            (assetCashWithholding, ifCashBitmap) = _withholdAndSetfCashAssets(
                nToken,
                previousMarkets,
                currencyId,
                ifCashBitmap,
                blockTime
            );
        }

        // Deduct the amount of withholding required from the cash balance (at this point includes all settled cash)
        netAssetCashAvailable = nToken.cashBalance.subNoNeg(assetCashWithholding);

        // This is the new balance to store
        nToken.cashBalance = nToken.cashBalance.subNoNeg(netAssetCashAvailable);

        // We can't have less net asset cash than our percent basis or some markets will end up not
        // initialized
        require(
            netAssetCashAvailable > int256(Constants.DEPOSIT_PERCENT_BASIS),
            ""IM: insufficient cash""
        );

        return (netAssetCashAvailable, ifCashBitmap);
    }

    /// @notice The six month implied rate is zero if there have never been any markets initialized
    /// otherwise the market will be the interpolation between the old 6 month and 1 year markets
    /// which are now sitting at 3 month and 9 month time to maturity
    function _getSixMonthImpliedRate(
        MarketParameters[] memory previousMarkets,
        uint256 referenceTime
    ) private pure returns (uint256) {
        // Cannot interpolate six month rate without a 1 year market
        require(previousMarkets.length >= 3, ""IM: six month error"");

        return
            CashGroup.interpolateOracleRate(
                previousMarkets[1].maturity,
                previousMarkets[2].maturity,
                previousMarkets[1].oracleRate,
                previousMarkets[2].oracleRate,
                referenceTime + 2 * Constants.QUARTER
            );
    }

    /// @notice Calculates a market proportion via the implied rate. The formula is:
    ///    exchangeRate = e ^ (impliedRate * timeToMaturity)
    ///    exchangeRate = (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor
    ///    proportion / (1 - proportion) = e^((exchangeRate - rateAnchor) * rateScalar)
    ///    exp = e^((exchangeRate - rateAnchor) * rateScalar)
    ///    proportion / (1 - proportion) = exp
    ///    exp * (1 - proportion) = proportion
    ///    exp - exp * proportion = proportion
    ///    exp = proportion + exp * proportion
    ///    exp = proportion * (1 + exp)
    ///    proportion = exp / (1 + exp)
    function _getProportionFromOracleRate(
        uint256 oracleRate,
        uint256 timeToMaturity,
        int256 rateScalar,
        uint256 annualizedAnchorRate
    ) private pure returns (int256) {
        int256 rateAnchor = Market.getExchangeRateFromImpliedRate(annualizedAnchorRate, timeToMaturity);
        int256 exchangeRate = Market.getExchangeRateFromImpliedRate(oracleRate, timeToMaturity);
        // If exchange rate is less than 1 then we set it to 1 so that this can continue
        if (exchangeRate < Constants.RATE_PRECISION) {
            // This can happen if the result of interpolation results in a negative interest rate.
            // This would be a bad result but in this case we floor the exchange rate at a 0% interest rate.
            exchangeRate = Constants.RATE_PRECISION;
        }

        int128 expValue = ABDKMath64x64.fromInt(
            (exchangeRate.sub(rateAnchor)).mulInRatePrecision(rateScalar)
        );
        // Scale this back to a decimal in abdk
        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);
        // Take the exponent
        expValue = ABDKMath64x64.exp(expValue);
        // proportion = exp / (1 + exp)
        // NOTE: 2**64 == 1 in ABDKMath64x64
        int128 proportion = ABDKMath64x64.div(expValue, ABDKMath64x64.add(expValue, 2**64));

        // Scale this back to 1e9 precision
        proportion = ABDKMath64x64.mul(proportion, Constants.RATE_PRECISION_64x64);

        return ABDKMath64x64.toInt(proportion);
    }

    /// @dev Returns the oracle rate given the market ratios of fCash to cash. The annualizedAnchorRate
    /// is used to calculate a rate anchor. Since a rate anchor varies with timeToMaturity and annualizedAnchorRate
    /// does not, this method will return consistent values regardless of the timeToMaturity of when initialize
    /// markets is called. This can be helpful if a currency needs to be initialized mid quarter when it is
    /// newly launched.
    function _calculateOracleRate(
        int256 fCashAmount,
        int256 underlyingCashToMarket,
        int256 rateScalar,
        uint256 annualizedAnchorRate,
        uint256 timeToMaturity
    ) internal pure returns (uint256) {
        int256 rateAnchor = Market.getExchangeRateFromImpliedRate(annualizedAnchorRate, timeToMaturity);
        uint256 oracleRate = Market.getImpliedRate(
            fCashAmount,
            underlyingCashToMarket,
            rateScalar,
            rateAnchor,
            timeToMaturity
        );

        return oracleRate;
    }

    /// @notice Returns the linear interpolation between two market rates. The formula is
    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)
    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate
    function _interpolateFutureRate(
        uint256 shortMaturity,
        uint256 shortRate,
        MarketParameters memory longMarket
    ) private pure returns (uint256) {
        uint256 longMaturity = longMarket.maturity;
        uint256 longRate = longMarket.oracleRate;
        // the next market maturity is always a quarter away
        uint256 newMaturity = longMarket.maturity + Constants.QUARTER;
        require(shortMaturity < longMaturity, ""IM: interpolation error"");

        // It's possible that the rates are inverted where the short market rate > long market rate and
        // we will get an underflow here so we check for that
        if (longRate >= shortRate) {
            return
                (longRate - shortRate)
                    .mul(newMaturity - shortMaturity)
                // No underflow here, checked above
                    .div(longMaturity - shortMaturity)
                    .add(shortRate);
        } else {
            // In this case the slope is negative so:
            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)
            uint256 diff =
                (shortRate - longRate)
                    .mul(newMaturity - shortMaturity)
                // No underflow here, checked above
                    .div(longMaturity - shortMaturity);

            // This interpolation may go below zero so we bottom out interpolated rates at zero
            return shortRate > diff ? shortRate - diff : 0;
        }
    }

    /// @dev This is hear to clear the stack
    function _setLiquidityAmount(
        int256 netAssetCashAvailable,
        int256 depositShare,
        uint256 assetType,
        MarketParameters memory newMarket,
        nTokenPortfolio memory nToken
    ) private pure returns (int256) {
        // The portion of the cash available that will be deposited into the market
        int256 assetCashToMarket =
            netAssetCashAvailable.mul(depositShare).div(Constants.DEPOSIT_PERCENT_BASIS);
        newMarket.totalAssetCash = assetCashToMarket;
        newMarket.totalLiquidity = assetCashToMarket;

        // Add a new liquidity token, this will end up in the new asset array
        nToken.portfolioState.addAsset(
            nToken.cashGroup.currencyId,
            newMarket.maturity,
            assetType, // This is liquidity token asset type
            assetCashToMarket
        );

        // fCashAmount is calculated using the underlying amount
        return nToken.cashGroup.assetRate.convertToUnderlying(assetCashToMarket);
    }

    /// @notice Sweeps nToken cash balance into markets after accounting for cash withholding. Can be
    /// done after fCash residuals are purchased to ensure that markets have maximum liquidity.
    /// @param currencyId currency of markets to initialize
    /// @dev emit:CashSweepIntoMarkets
    /// @dev auth:none
    function sweepCashIntoMarkets(uint16 currencyId) external {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioStateful(currencyId, nToken);
        require(nToken.portfolioState.storedAssets.length > 0, ""No nToken assets"");

        // Can only sweep cash after markets have been initialized
        uint256 referenceTime = DateTime.getReferenceTime(blockTime);
        require(nToken.lastInitializedTime >= referenceTime, ""Must initialize markets"");

        // Can only sweep cash after the residual purchase time has passed
        uint256 minSweepCashTime =
            nToken.lastInitializedTime.add(
                uint256(uint8(nToken.parameters[Constants.RESIDUAL_PURCHASE_TIME_BUFFER])) * 3600
            );
        require(blockTime > minSweepCashTime, ""Invalid sweep cash time"");

        bytes32 ifCashBitmap = BitmapAssetsHandler.getAssetsBitmap(nToken.tokenAddress, currencyId);
        int256 assetCashWithholding =
            _getNTokenNegativefCashWithholding(
                nToken,
                new MarketParameters[](0), // Parameter is unused when referencing current markets
                blockTime,
                ifCashBitmap
            );

        int256 cashIntoMarkets = nToken.cashBalance.subNoNeg(assetCashWithholding);
        BalanceHandler.setBalanceStorageForNToken(
            nToken.tokenAddress,
            nToken.cashGroup.currencyId,
            assetCashWithholding
        );

        // This will deposit the cash balance into markets, but will not record a token supply change.
        nTokenMintAction.nTokenMint(currencyId, cashIntoMarkets);
        emit SweepCashIntoMarkets(currencyId, cashIntoMarkets);
    }

    /// @notice Initialize the market for a given currency id, done once a quarter
    /// @param currencyId currency of markets to initialize
    /// @param isFirstInit true if this is the first time the markets have been initialized
    /// @dev emit:MarketsInitialized
    /// @dev auth:none
    function initializeMarkets(uint256 currencyId, bool isFirstInit) external {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioStateful(currencyId, nToken);
        MarketParameters[] memory previousMarkets =
            new MarketParameters[](nToken.cashGroup.maxMarketIndex);

        // This should be sufficient to validate that the currency id is valid
        require(nToken.cashGroup.maxMarketIndex != 0, ""IM: no markets to init"");
        // If the nToken has any assets then this is not the first initialization
        if (isFirstInit) {
            require(nToken.portfolioState.storedAssets.length == 0, ""IM: not first init"");
        }

        (int256 netAssetCashAvailable, bytes32 ifCashBitmap) =
            _calculateNetAssetCashAvailable(
                nToken,
                previousMarkets,
                blockTime,
                currencyId,
                isFirstInit
            );

        GovernanceParameters memory parameters =
            _getGovernanceParameters(currencyId, nToken.cashGroup.maxMarketIndex);

        MarketParameters memory newMarket;
        // Oracle rate is carried over between loops
        uint256 oracleRate;
        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) {
            // Traded markets are 1-indexed
            newMarket.maturity = DateTime.getReferenceTime(blockTime).add(
                DateTime.getTradedMarket(i + 1)
            );

            int256 underlyingCashToMarket =
                _setLiquidityAmount(
                    netAssetCashAvailable,
                    parameters.depositShares[i],
                    Constants.MIN_LIQUIDITY_TOKEN_INDEX + i, // liquidity token asset type
                    newMarket,
                    nToken
                );

            uint256 timeToMaturity = newMarket.maturity.sub(blockTime);
            int256 rateScalar = nToken.cashGroup.getRateScalar(i + 1, timeToMaturity);
            // Governance will prevent previousMarkets.length from being equal to 1, meaning that we will
            // either have 0 markets (on first init), exactly 2 markets, or 2+ markets. In the case that there
            // are exactly two markets then the 6 month market must be initialized via this method (there is no
            // 9 month market to interpolate a rate against). In the case of 2+ markets then we will only enter this
            // first branch when the number of markets is increased
            if (
                isFirstInit ||
                // This is the six month market when there are only 3 and 6 month markets
                (i == 1 && previousMarkets.length == 2) ||
                // At this point, these are new markets and they must be initialized
                (i >= nToken.portfolioState.storedAssets.length) ||
                // When extending from the 6 month to 1 year market we must initialize both 6 and 1 year as new
                (i == 1 && previousMarkets[2].oracleRate == 0)
            ) {
                // Any newly added markets cannot have their implied rates interpolated via the previous
                // markets. In this case we initialize the markets using the rate anchor and proportion.
                // proportion = totalfCash / (totalfCash + totalCashUnderlying)
                // proportion * (totalfCash + totalCashUnderlying) = totalfCash
                // proportion * totalCashUnderlying + proportion * totalfCash = totalfCash
                // proportion * totalCashUnderlying = totalfCash * (1 - proportion)
                // totalfCash = proportion * totalCashUnderlying / (1 - proportion)
                int256 fCashAmount =
                    underlyingCashToMarket.mul(parameters.proportions[i]).div(
                        Constants.RATE_PRECISION.sub(parameters.proportions[i])
                    );

                newMarket.totalfCash = fCashAmount;
                newMarket.oracleRate = _calculateOracleRate(
                    fCashAmount,
                    underlyingCashToMarket,
                    rateScalar,
                    uint256(parameters.annualizedAnchorRates[i]), // No overflow, uint32 when set
                    timeToMaturity
                );

                // If this fails it is because the rate anchor and proportion are not set properly by
                // governance.
                require(newMarket.oracleRate > 0, ""IM: implied rate failed"");
            } else {
                // Two special cases for the 3 month and 6 month market when interpolating implied rates. The 3 month market
                // inherits the implied rate from the previous 6 month market (they are now at the same maturity).
                if (i == 0) {
                    // We should never get an array out of bounds error here because of the inequality check in the first branch
                    // of the outer if statement.
                    oracleRate = previousMarkets[1].oracleRate;
                } else if (i == 1) {
                    // The six month market is the interpolation between the 3 month and the 1 year market (now at 9 months). This
                    // interpolation is different since the rate is between 3 and 9 months, for all the other interpolations we interpolate
                    // forward in time (i.e. use a 3 and 6 month rate to interpolate a 1 year rate). The first branch of this if statement
                    // will capture the case when the 1 year rate has not been set.
                    oracleRate = _getSixMonthImpliedRate(
                        previousMarkets,
                        DateTime.getReferenceTime(blockTime)
                    );
                } else {
                    // Any other market has the interpolation between the new implied rate from the newly initialized market previous
                    // to this market interpolated with the previous version of this market. For example, the newly initialized 1 year
                    // market will have its implied rate set to the interpolation between the newly initialized 6 month market (done in
                    // previous iteration of this loop) and the previous 1 year market (which has now rolled down to 9 months). Similarly,
                    // a 2 year market will be interpolated from the newly initialized 1 year and the previous 2 year market.

                    // This is the previous market maturity, traded markets are 1-indexed
                    uint256 shortMarketMaturity =
                        DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(i));
                    oracleRate = _interpolateFutureRate(
                        shortMarketMaturity,
                        oracleRate,
                        previousMarkets[i]
                    );
                }

                // When initializing new markets we need to ensure that the new implied oracle rates align
                // with the current yield curve or valuations for ifCash will spike. This should reference the
                // previously calculated implied rate and the current market.
                int256 proportion =
                    _getProportionFromOracleRate(
                        oracleRate,
                        timeToMaturity,
                        rateScalar,
                        uint256(parameters.annualizedAnchorRates[i]) // No overflow, uint32 when set
                    );

                // If the calculated proportion is greater than the leverage threshold then we cannot
                // provide liquidity without risk of liquidation. In this case, set the leverage threshold
                // as the new proportion and calculate the oracle rate from it. This will result in fCash valuations
                // changing on chain, however, adding liquidity via nTokens would also end up with this
                // result as well.
                if (proportion > parameters.leverageThresholds[i]) {
                    proportion = parameters.leverageThresholds[i];
                    newMarket.totalfCash = underlyingCashToMarket.mul(proportion).div(
                        Constants.RATE_PRECISION.sub(proportion)
                    );

                    oracleRate = _calculateOracleRate(
                        newMarket.totalfCash,
                        underlyingCashToMarket,
                        rateScalar,
                        uint256(parameters.annualizedAnchorRates[i]), // No overflow, uint32 when set
                        timeToMaturity
                    );

                    require(oracleRate != 0, ""Oracle rate overflow"");
                } else {
                    newMarket.totalfCash = underlyingCashToMarket.mul(proportion).div(
                        Constants.RATE_PRECISION.sub(proportion)
                    );
                }

                // It's possible for proportion to be equal to zero, in this case we set the totalfCash to a minimum
                // value so that we don't have divide by zero errors.
                if (proportion == 0) newMarket.totalfCash = 1;

                newMarket.oracleRate = oracleRate;
                newMarket.previousTradeTime = blockTime;
            }

            newMarket.lastImpliedRate = newMarket.oracleRate;
            ifCashBitmap = finalizeMarket(newMarket, currencyId, nToken, ifCashBitmap);
        }

        // prettier-ignore
        (
            /* hasDebt */,
            /* activeCurrencies */,
            uint8 assetArrayLength,
            /* nextSettleTime */
        ) = nToken.portfolioState.storeAssets(nToken.tokenAddress);
        BalanceHandler.setBalanceStorageForNToken(
            nToken.tokenAddress,
            currencyId,
            nToken.cashBalance
        );
        BitmapAssetsHandler.setAssetsBitmap(nToken.tokenAddress, currencyId, ifCashBitmap);
        nTokenHandler.setArrayLengthAndInitializedTime(
            nToken.tokenAddress,
            assetArrayLength,
            nToken.lastInitializedTime
        );

        emit MarketsInitialized(uint16(currencyId));
    }

    function finalizeMarket(
        MarketParameters memory market,
        uint256 currencyId,
        nTokenPortfolio memory nToken,
        bytes32 ifCashBitmap
    ) internal returns (bytes32) {
        uint256 blockTime = block.timestamp;
        // Always reference the current settlement date
        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;
        market.storageSlot = Market.getSlot(currencyId, settlementDate, market.maturity);
        market.storageState = Market.STORAGE_STATE_INITIALIZE_MARKET;
        market.setMarketStorage();

        // prettier-ignore
        (
            bytes32 bitmap,
            /* notional */
        ) = BitmapAssetsHandler.addifCashAsset(
                nToken.tokenAddress,
                currencyId,
                market.maturity,
                nToken.lastInitializedTime,
                market.totalfCash.neg(),
                ifCashBitmap
            );

        return bitmap;
    }
}",6878
RealWorld_TA_23_CTokenInterface_RealWorld_20240803092931.log,23,CTokenInterface,41578,1666,43244,369.0,0.24121,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.7.0;

interface CTokenInterface {

    /*** User Interface ***/

    function underlying() external view returns (address);
    function transfer(address dst, uint amount) external returns (bool);
    function transferFrom(address src, address dst, uint amount) external returns (bool);
    function approve(address spender, uint amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function balanceOfUnderlying(address owner) external returns (uint);
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);
    function borrowRatePerBlock() external view returns (uint);
    function supplyRatePerBlock() external view returns (uint);
    function totalBorrowsCurrent() external returns (uint);
    function borrowBalanceCurrent(address account) external returns (uint);
    function borrowBalanceStored(address account) external view returns (uint);
    function exchangeRateCurrent() external returns (uint);
    function exchangeRateStored() external view returns (uint);
    function getCash() external view returns (uint);
    function accrueInterest() external returns (uint);
    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);
}",280
RealWorld_TA_23_MockAssetHandler_RealWorld_20240803024307.log,23,MockAssetHandler,116690,3814,120504,126.0,0.65973,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/valuation/AssetHandler.sol"";
import ""../internal/markets/Market.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""@openzeppelin/contracts/utils/SafeCast.sol"";

contract MockAssetHandler is StorageLayoutV1 {
    using SafeInt256 for int256;
    using AssetHandler for PortfolioAsset;
    using Market for MarketParameters;

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setCashGroup(uint256 id, CashGroupSettings calldata cg) external {
        CashGroup.setCashGroupStorage(id, cg);
    }

    function buildCashGroupView(uint256 currencyId)
        public
        view
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupView(currencyId);
    }

    function setMarketStorage(
        uint256 currencyId,
        uint256 settlementDate,
        MarketParameters memory market
    ) public {
        market.storageSlot = Market.getSlot(currencyId, settlementDate, market.maturity);
        // ensure that state gets set
        market.storageState = 0xFF;
        market.setMarketStorage();
    }

    function getMarketStorage(
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime
    ) public view returns (MarketParameters memory) {
        MarketParameters memory market;
        Market.loadMarket(market, currencyId, maturity, blockTime, true, 1);

        return market;
    }

    function getSettlementDate(PortfolioAsset memory asset) public pure returns (uint256) {
        return asset.getSettlementDate();
    }

    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) public pure returns (int256) {
        int256 pv = AssetHandler.getPresentValue(notional, maturity, blockTime, oracleRate);
        if (notional > 0) assert(pv > 0);
        if (notional < 0) assert(pv < 0);

        assert(pv.abs() <= notional.abs());
        return pv;
    }

    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) public pure returns (int256) {
        int256 riskPv =
            AssetHandler.getRiskAdjustedPresentValue(
                cashGroup,
                notional,
                maturity,
                blockTime,
                oracleRate
            );
        int256 pv = getPresentValue(notional, maturity, blockTime, oracleRate);

        assert(riskPv <= pv);
        assert(riskPv.abs() <= notional.abs());
        return riskPv;
    }

    function getCashClaims(
        PortfolioAsset memory liquidityToken,
        MarketParameters memory marketState
    ) public pure returns (int256, int256) {
        (int256 cash, int256 fCash) = liquidityToken.getCashClaims(marketState);
        assert(cash > 0);
        assert(fCash > 0);
        assert(cash <= marketState.totalAssetCash);
        assert(fCash <= marketState.totalfCash);

        return (cash, fCash);
    }

    function getHaircutCashClaims(
        PortfolioAsset memory liquidityToken,
        MarketParameters memory marketState,
        CashGroupParameters memory cashGroup
    ) public pure returns (int256, int256) {
        (int256 haircutCash, int256 haircutfCash) =
            liquidityToken.getHaircutCashClaims(marketState, cashGroup);
        (int256 cash, int256 fCash) = liquidityToken.getCashClaims(marketState);

        assert(haircutCash < cash);
        assert(haircutfCash < fCash);

        return (haircutCash, haircutfCash);
    }

    function getLiquidityTokenValueRiskAdjusted(
        uint256 index,
        CashGroupParameters memory cashGroup,
        PortfolioAsset[] memory assets,
        uint256 blockTime
    )
        public
        view
        returns (
            int256,
            int256,
            PortfolioAsset[] memory
        )
    {
        MarketParameters memory market;
        (int256 assetValue, int256 pv) =
            AssetHandler.getLiquidityTokenValue(index, cashGroup, market, assets, blockTime, true);

        return (assetValue, pv, assets);
    }

    function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        PortfolioAsset[] memory assets,
        uint256 blockTime
    )
        public
        view
        returns (
            int256,
            int256,
            PortfolioAsset[] memory
        )
    {
        MarketParameters memory market;
        (int256 assetValue, int256 pv) =
            AssetHandler.getLiquidityTokenValue(index, cashGroup, market, assets, blockTime, false);

        return (assetValue, pv, assets);
    }

    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        uint256 blockTime,
        uint256 portfolioIndex
    ) public view returns (int256, uint256) {
        MarketParameters memory market;
        return
            AssetHandler.getNetCashGroupValue(assets, cashGroup, market, blockTime, portfolioIndex);
    }
}",1169
RealWorld_TA_23_MockAssetRate_RealWorld_20240803025454.log,23,MockAssetRate,69337,3595,72932,113.0,0.418585,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/markets/AssetRate.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockAssetRate is StorageLayoutV1 {
    event SetSettlementRate(uint256 currencyId, uint256 maturity, uint128 rate);

    using SafeInt256 for int256;
    using AssetRate for AssetRateParameters;

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function assertBalanceSign(int256 balance, int256 result) private pure {
        if (balance == 0) assert(result == 0);
        else if (balance < 0) assert(result < 0);
        else if (balance > 0) assert(result > 0);
    }

    function convertToUnderlying(AssetRateParameters memory er, int256 balance)
        external
        pure
        returns (int256)
    {
        require(er.rate > 0);
        int256 result = er.convertToUnderlying(balance);
        assertBalanceSign(balance, result);

        return result;
    }

    function convertFromUnderlying(AssetRateParameters memory er, int256 balance)
        external
        pure
        returns (int256)
    {
        require(er.rate > 0);
        int256 result = er.convertFromUnderlying(balance);
        assertBalanceSign(balance, result);

        return result;
    }

    function buildAssetRate(uint256 currencyId) external returns (AssetRateParameters memory) {
        AssetRateParameters memory assetRateStateful = AssetRate.buildAssetRateStateful(currencyId);
        AssetRateParameters memory assetRateView = AssetRate.buildAssetRateView(currencyId);

        assert(assetRateStateful.rate == assetRateView.rate);
        assert(assetRateStateful.underlyingDecimals == assetRateView.underlyingDecimals);
        assert(assetRateStateful.rateOracle == assetRateView.rateOracle);

        return assetRateStateful;
    }

    function buildAssetRateStateful(uint256 currencyId)
        external
        returns (AssetRateParameters memory)
    {
        return AssetRate.buildAssetRateStateful(currencyId);
    }

    function buildSettlementRate(
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime
    ) external returns (AssetRateParameters memory) {
        AssetRateParameters memory initialViewRate =
            AssetRate.buildSettlementRateView(currencyId, maturity);

        AssetRateParameters memory statefulRate =
            AssetRate.buildSettlementRateStateful(currencyId, maturity, blockTime);

        assert(initialViewRate.rate == statefulRate.rate);
        assert(initialViewRate.underlyingDecimals == statefulRate.underlyingDecimals);

        return statefulRate;
    }
}",599
RealWorld_TA_23_DateTime_RealWorld_20240803033646.log,23,DateTime,157854,2629,160483,363.0,0.84185,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Constants.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library DateTime {
    using SafeMath for uint256;

    /// @notice Returns the current reference time which is how all the AMM dates are calculated.
    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {
        require(blockTime > Constants.QUARTER);
        return blockTime - (blockTime % Constants.QUARTER);
    }

    /// @notice Truncates a date to midnight UTC time
    function getTimeUTC0(uint256 time) internal pure returns (uint256) {
        require(time > Constants.DAY);
        return time - (time % Constants.DAY);
    }

    /// @notice These are the predetermined market offsets for trading
    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.
    function getTradedMarket(uint256 index) internal pure returns (uint256) {
        require(index != 0); // dev: get traded market index is zero

        if (index == 1) return Constants.QUARTER;
        if (index == 2) return 2 * Constants.QUARTER;
        if (index == 3) return Constants.YEAR;
        if (index == 4) return 2 * Constants.YEAR;
        if (index == 5) return 5 * Constants.YEAR;
        if (index == 6) return 10 * Constants.YEAR;
        if (index == 7) return 20 * Constants.YEAR;

        revert(""CG: invalid index"");
    }

    /// @notice Determines if the maturity falls on one of the valid on chain market dates.
    function isValidMarketMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex < 10, ""CG: market index bound"");

        if (maturity % Constants.QUARTER != 0) return false;
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;
        }

        return false;
    }

    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.
    function isValidMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        uint256 tRef = DateTime.getReferenceTime(blockTime);
        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));
        if (maturity > maxMaturity) return false;

        // prettier-ignore
        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);
        return isValid;
    }

    /// @notice Returns the market index for a given maturity
    /// @return uint marketIndex, bool isIdiosyncratic
    function getMarketIndex(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (uint256, bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex < 10, ""CG: market index bound"");
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));
            if (marketMaturity == maturity) return (i, false);
            if (marketMaturity > maturity) return (i, true);
        }

        revert(""CG: no market found"");
    }

    /// @notice Given a bit number and the reference time of the first bit, returns the bit number
    /// of a given maturity.
    /// @return bitNum and a true or false if the maturity falls on the exact bit
    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        internal
        pure
        returns (uint256, bool)
    {
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);

        if (maturity % Constants.DAY != 0) return (0, false);
        if (blockTimeUTC0 >= maturity) return (0, false);

        // Overflow check done above
        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;

        // These if statements need to fall through to the next one
        if (daysOffset <= Constants.MAX_DAY_OFFSET) {
            return (daysOffset, true);
        }

        if (daysOffset <= Constants.MAX_WEEK_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_DAY_OFFSET +
                    (blockTimeUTC0 % Constants.WEEK) /
                    Constants.DAY;
            // Ensures that the maturity specified falls on the actual day, otherwise division
            // will truncate it
            return (Constants.WEEK_BIT_OFFSET + offset / 6, (offset % 6) == 0);
        }

        if (daysOffset <= Constants.MAX_MONTH_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_WEEK_OFFSET +
                    (blockTimeUTC0 % Constants.MONTH) /
                    Constants.DAY;

            return (Constants.MONTH_BIT_OFFSET + offset / 30, (offset % 30) == 0);
        }

        if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {
            uint256 offset =
                daysOffset -
                    Constants.MAX_MONTH_OFFSET +
                    (blockTimeUTC0 % Constants.QUARTER) /
                    Constants.DAY;

            return (Constants.QUARTER_BIT_OFFSET + offset / 90, (offset % 90) == 0);
        }

        // This is the maximum 1-indexed bit num
        return (256, false);
    }

    /// @notice Given a bit number and a block time returns the maturity that the bit number
    /// should reference. Bit numbers are one indexed.
    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)
        internal
        pure
        returns (uint256)
    {
        require(bitNum != 0); // dev: cash group get maturity from bit num is zero
        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow
        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);
        uint256 firstBit;

        if (bitNum <= Constants.WEEK_BIT_OFFSET) {
            return blockTimeUTC0 + bitNum * Constants.DAY;
        }

        if (bitNum <= Constants.MONTH_BIT_OFFSET) {
            firstBit =
                blockTimeUTC0 +
                Constants.MAX_DAY_OFFSET *
                Constants.DAY -
                (blockTimeUTC0 % Constants.WEEK);
            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;
        }

        if (bitNum <= Constants.QUARTER_BIT_OFFSET) {
            firstBit =
                blockTimeUTC0 +
                Constants.MAX_WEEK_OFFSET *
                Constants.DAY -
                (blockTimeUTC0 % Constants.MONTH);
            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;
        }

        firstBit =
            blockTimeUTC0 +
            Constants.MAX_MONTH_OFFSET *
            Constants.DAY -
            (blockTimeUTC0 % Constants.QUARTER);
        return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;
    }
}",1641
RealWorld_TA_23_NotionalGovernance_RealWorld_20240803085223.log,23,NotionalGovernance,68435,3474,71909,368.0,0.411655,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../contracts/global/Types.sol"";

interface NotionalGovernance {
    event ListCurrency(uint16 newCurrencyId);
    event UpdateETHRate(uint16 currencyId);
    event UpdateAssetRate(uint16 currencyId);
    event UpdateCashGroup(uint16 currencyId);
    event DeployNToken(uint16 currencyId, address nTokenAddress);
    event UpdateDepositParameters(uint16 currencyId);
    event UpdateInitializationParameters(uint16 currencyId);
    event UpdateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate);
    event UpdateTokenCollateralParameters(uint16 currencyId);
    event UpdateGlobalTransferOperator(address operator, bool approved);
    event UpdateAuthorizedCallbackContract(address operator, bool approved);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event PauseRouterAndGuardianUpdated(address indexed pauseRouter, address indexed pauseGuardian);

    function transferOwnership(address newOwner) external;

    function setPauseRouterAndGuardian(address pauseRouter_, address pauseGuardian_) external;

    function listCurrency(
        TokenStorage calldata assetToken,
        TokenStorage calldata underlyingToken,
        address rateOracle,
        bool mustInvert,
        uint8 buffer,
        uint8 haircut,
        uint8 liquidationDiscount
    ) external;

    function enableCashGroup(
        uint16 currencyId,
        address assetRateOracle,
        CashGroupSettings calldata cashGroup,
        string calldata underlyingName,
        string calldata underlyingSymbol
    ) external;

    function updateDepositParameters(
        uint16 currencyId,
        uint32[] calldata depositShares,
        uint32[] calldata leverageThresholds
    ) external;

    function updateInitializationParameters(
        uint16 currencyId,
        uint32[] calldata annualizedAnchorRates,
        uint32[] calldata proportions
    ) external;

    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external;

    function updateTokenCollateralParameters(
        uint16 currencyId,
        uint8 residualPurchaseIncentive10BPS,
        uint8 pvHaircutPercentage,
        uint8 residualPurchaseTimeBufferHours,
        uint8 cashWithholdingBuffer10BPS,
        uint8 liquidationHaircutPercentage
    ) external;

    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup) external;

    function updateAssetRate(uint16 currencyId, address rateOracle) external;

    function updateETHRate(
        uint16 currencyId,
        address rateOracle,
        bool mustInvert,
        uint8 buffer,
        uint8 haircut,
        uint8 liquidationDiscount
    ) external;

    function updateGlobalTransferOperator(address operator, bool approved) external;

    function updateAuthorizedCallbackContract(address operator, bool approved) external;
}",605
RealWorld_TA_23_AggregatorV2V3Interface_RealWorld_20240803090450.log,23,AggregatorV2V3Interface,23151,1818,24969,369.0,0.152115,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

import ""./AggregatorInterface.sol"";
import ""./AggregatorV3Interface.sol"";

interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface
{
}",53
RealWorld_TA_23_MockBalanceHandler_RealWorld_20240803022508.log,23,MockBalanceHandler,83226,3285,86511,117.0,0.48183,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/AccountContextHandler.sol"";
import ""../internal/balances/BalanceHandler.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockBalanceHandler is StorageLayoutV1 {
    using BalanceHandler for BalanceState;
    using AccountContextHandler for AccountContext;

    function setMaxCurrencyId(uint16 num) external {
        maxCurrencyId = num;
    }

    function getCurrencyMapping(uint256 id, bool underlying) external view returns (Token memory) {
        return TokenHandler.getToken(id, underlying);
    }

    function setCurrencyMapping(
        uint256 id,
        bool underlying,
        TokenStorage calldata ts
    ) external {
        TokenHandler.setToken(id, underlying, ts);
    }

    function setAccountContext(address account, AccountContext memory a) external {
        a.setAccountContext(account);
    }

    function setBalance(
        address account,
        uint256 currencyId,
        int256 cashBalance,
        int256 nTokenBalance
    ) external {
        bytes32 slot = keccak256(
            abi.encode(currencyId, keccak256(abi.encode(account, Constants.BALANCE_STORAGE_OFFSET)))
        );
        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow
        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow
        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow

        bytes32 data = ((bytes32(uint256(nTokenBalance))) |
            (bytes32(0) << 80) |
            (bytes32(0) << 112) |
            (bytes32(cashBalance) << 168));

        assembly {
            sstore(slot, data)
        }
    }

    function getData(address account, uint256 currencyId) external view returns (bytes32) {
        bytes32 slot = keccak256(abi.encode(currencyId, account, ""account.balances""));
        bytes32 data;
        assembly {
            data := sload(slot)
        }

        return data;
    }

    function finalize(
        BalanceState memory balanceState,
        address account,
        AccountContext memory accountContext,
        bool redeemToUnderlying
    ) public returns (AccountContext memory) {
        balanceState.finalize(account, accountContext, redeemToUnderlying);

        return accountContext;
    }

    function loadBalanceState(
        address account,
        uint256 currencyId,
        AccountContext memory accountContext
    ) public view returns (BalanceState memory, AccountContext memory) {
        BalanceState memory bs;
        bs.loadBalanceState(account, currencyId, accountContext);

        return (bs, accountContext);
    }

    function depositAssetToken(
        BalanceState memory balanceState,
        address account,
        int256 assetAmountExternal,
        bool forceTransfer
    ) external returns (BalanceState memory, int256) {
        int256 assetAmountInternal = balanceState.depositAssetToken(
            account,
            assetAmountExternal,
            forceTransfer
        );

        return (balanceState, assetAmountInternal);
    }

    function depositUnderlyingToken(
        BalanceState memory balanceState,
        address account,
        int256 underlyingAmountExternal
    ) external returns (BalanceState memory, int256) {
        int256 assetTokensReceivedInternal = balanceState.depositUnderlyingToken(
            account,
            underlyingAmountExternal
        );

        return (balanceState, assetTokensReceivedInternal);
    }
}",759
RealWorld_TA_23_MockAccountContextHandler_RealWorld_20240803025052.log,23,MockAccountContextHandler,72780,3421,76201,118.0,0.43232,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/AccountContextHandler.sol"";

contract MockAccountContextHandler {
    using AccountContextHandler for AccountContext;

    function setAssetBitmap(
        address account,
        uint256 id,
        bytes32 bitmap
    ) external {
        BitmapAssetsHandler.setAssetsBitmap(account, id, bitmap);
    }

    function enableBitmapForAccount(
        address account,
        uint256 currencyId,
        uint256 blockTime
    ) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        accountContext.enableBitmapForAccount(account, currencyId, blockTime);
        accountContext.setAccountContext(account);
    }

    function getAccountContext(address account) external view returns (AccountContext memory) {
        return AccountContextHandler.getAccountContext(account);
    }

    function setAccountContext(AccountContext memory accountContext, address account) external {
        return accountContext.setAccountContext(account);
    }

    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)
        external
        pure
        returns (bool)
    {
        return accountContext.isActiveInBalances(currencyId);
    }

    function clearPortfolioActiveFlags(bytes18 activeCurrencies) external pure returns (bytes18) {
        return AccountContextHandler._clearPortfolioActiveFlags(activeCurrencies);
    }

    function setActiveCurrency(
        bytes18 activeCurrencies,
        uint256 currencyId,
        bool isActive,
        bytes2 flags,
        uint16 bitmapId
    ) external pure returns (bytes18) {
        AccountContext memory accountContext =
            AccountContext(0, 0x00, 0, bitmapId, activeCurrencies);
        accountContext.setActiveCurrency(currencyId, isActive, flags);

        // Assert that the currencies are in order
        bytes18 currencies = accountContext.activeCurrencies;
        uint256 lastCurrency;
        while (currencies != 0x0) {
            uint256 thisCurrency = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));
            assert(thisCurrency != 0);
            // Either flag must be set
            assert(
                ((bytes2(currencies) & Constants.ACTIVE_IN_PORTFOLIO) ==
                    Constants.ACTIVE_IN_PORTFOLIO) ||
                    ((bytes2(currencies) & Constants.ACTIVE_IN_BALANCES) ==
                        Constants.ACTIVE_IN_BALANCES)
            );
            // currencies are in order
            assert(thisCurrency > lastCurrency);

            if (isActive && currencyId == thisCurrency) {
                assert(bytes2(currencies) & flags == flags);
            } else if (!isActive && currencyId == thisCurrency) {
                assert(bytes2(currencies) & flags != flags);
            }

            lastCurrency = thisCurrency;
            currencies = currencies << 16;
        }

        // Bitmap id should never change in this method
        assert(accountContext.bitmapCurrencyId == bitmapId);

        return accountContext.activeCurrencies;
    }
}",627
RealWorld_TA_23_BatchAction_RealWorld_20240803071932.log,23,BatchAction,272409,6070,278479,381.0,1.483445,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./TradingAction.sol"";
import ""./nTokenMintAction.sol"";
import ""./nTokenRedeemAction.sol"";
import ""../SettleAssetsExternal.sol"";
import ""../FreeCollateralExternal.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/portfolio/PortfolioHandler.sol"";
import ""../../internal/AccountContextHandler.sol"";
import ""interfaces/notional/NotionalCallback.sol"";

contract BatchAction is StorageLayoutV1 {
    using BalanceHandler for BalanceState;
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;
    using SafeInt256 for int256;

    /// @notice Executes a batch of balance transfers including minting and redeeming nTokens.
    /// @param account the account for the action
    /// @param actions array of balance actions to take, must be sorted by currency id
    /// @dev emit:CashBalanceChange for each balance
    /// @dev auth:msg.sender auth:ERC1155
    function batchBalanceAction(address account, BalanceAction[] calldata actions)
        external
        payable
    {
        require(account == msg.sender || msg.sender == address(this), ""Unauthorized"");

        // Return any settle amounts here to reduce the number of storage writes to balances
        (
            AccountContext memory accountContext,
            SettleAmount[] memory settleAmounts
        ) = _settleAccountIfRequiredAndStorePortfolio(account);

        uint256 settleAmountIndex;
        BalanceState memory balanceState;
        for (uint256 i; i < actions.length; i++) {
            if (i > 0) {
                require(actions[i].currencyId > actions[i - 1].currencyId, ""Unsorted actions"");
            }

            settleAmountIndex = _preTradeActions(
                account,
                settleAmountIndex,
                actions[i].currencyId,
                settleAmounts,
                balanceState,
                accountContext
            );

            _executeDepositAction(
                account,
                balanceState,
                actions[i].actionType,
                actions[i].depositActionAmount
            );

            _calculateWithdrawActionAndFinalize(
                account,
                accountContext,
                balanceState,
                actions[i].withdrawAmountInternalPrecision,
                actions[i].withdrawEntireCashBalance,
                actions[i].redeemToUnderlying
            );
        }

        // Finalize remaining settle amounts
        BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);
        _finalizeAccountContext(account, accountContext);
    }

    /// @notice Executes a batch of balance transfers and trading actions
    /// @param account the account for the action
    /// @param actions array of balance actions with trades to take, must be sorted by currency id
    /// @dev emit:CashBalanceChange for each balance, emit:BatchTradeExecution for each trade set, emit:nTokenSupplyChange
    /// @dev auth:msg.sender auth:ERC1155
    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions)
        external
        payable
    {
        require(account == msg.sender || msg.sender == address(this), ""Unauthorized"");
        AccountContext memory accountContext = _batchBalanceAndTradeAction(account, actions);
        _finalizeAccountContext(account, accountContext);
    }

    function batchBalanceAndTradeActionWithCallback(
        address account,
        BalanceActionWithTrades[] calldata actions,
        bytes calldata callbackData
    ) external payable {
        require(authorizedCallbackContract[msg.sender], ""Unauthorized"");
        AccountContext memory accountContext = _batchBalanceAndTradeAction(account, actions);
        accountContext.setAccountContext(account);
        // Be sure to set the account context before initiating the callback
        NotionalCallback(msg.sender).notionalCallback(msg.sender, account, callbackData);

        if (accountContext.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(account);
        }
    }

    function _batchBalanceAndTradeAction(
        address account,
        BalanceActionWithTrades[] calldata actions
    ) internal returns (AccountContext memory) {
        (
            AccountContext memory accountContext,
            SettleAmount[] memory settleAmounts,
            PortfolioState memory portfolioState
        ) = _settleAccountIfRequiredAndReturnPortfolio(account);

        uint256 settleAmountIndex;
        BalanceState memory balanceState;
        for (uint256 i; i < actions.length; i++) {
            if (i > 0) {
                require(actions[i].currencyId > actions[i - 1].currencyId, ""Unsorted actions"");
            }
            settleAmountIndex = _preTradeActions(
                account,
                settleAmountIndex,
                actions[i].currencyId,
                settleAmounts,
                balanceState,
                accountContext
            );

            _executeDepositAction(
                account,
                balanceState,
                actions[i].actionType,
                actions[i].depositActionAmount
            );

            if (actions[i].trades.length > 0) {
                int256 netCash;
                if (accountContext.bitmapCurrencyId != 0) {
                    require(
                        accountContext.bitmapCurrencyId == actions[i].currencyId,
                        ""Invalid trades for account""
                    );
                    bool didIncurDebt;
                    (netCash, didIncurDebt) = TradingAction.executeTradesBitmapBatch(
                        account,
                        accountContext,
                        actions[i].trades
                    );
                    if (didIncurDebt) {
                        accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;
                    }
                } else {
                    // NOTE: we return portfolio state here instead of setting it inside executeTradesArrayBatch
                    // because we want to only write to storage once after all trades are completed
                    (portfolioState, netCash) = TradingAction.executeTradesArrayBatch(
                        account,
                        actions[i].currencyId,
                        portfolioState,
                        actions[i].trades
                    );
                }

                // If the account owes cash after trading, ensure that it has enough
                if (netCash < 0) _checkSufficientCash(balanceState, netCash.neg());
                balanceState.netCashChange = balanceState.netCashChange.add(netCash);
            }

            _calculateWithdrawActionAndFinalize(
                account,
                accountContext,
                balanceState,
                actions[i].withdrawAmountInternalPrecision,
                actions[i].withdrawEntireCashBalance,
                actions[i].redeemToUnderlying
            );
        }

        if (accountContext.bitmapCurrencyId == 0) {
            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);
        }

        // Finalize remaining settle amounts
        BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);
        return accountContext;
    }

    /// @dev Loads balances, nets off settle amounts and then executes deposit actions
    function _preTradeActions(
        address account,
        uint256 settleAmountIndex,
        uint256 currencyId,
        SettleAmount[] memory settleAmounts,
        BalanceState memory balanceState,
        AccountContext memory accountContext
    ) private returns (uint256) {
        while (
            settleAmountIndex < settleAmounts.length &&
            settleAmounts[settleAmountIndex].currencyId < currencyId
        ) {
            // Loop through settleAmounts to find a matching currency
            settleAmountIndex += 1;
        }

        // This saves a number of memory allocations
        balanceState.loadBalanceState(account, currencyId, accountContext);

        if (
            settleAmountIndex < settleAmounts.length &&
            settleAmounts[settleAmountIndex].currencyId == currencyId
        ) {
            balanceState.netCashChange = settleAmounts[settleAmountIndex].netCashChange;
            // Set to zero so that we don't double count later
            settleAmounts[settleAmountIndex].netCashChange = 0;
        }

        return settleAmountIndex;
    }

    /// @dev Executes deposits
    function _executeDepositAction(
        address account,
        BalanceState memory balanceState,
        DepositActionType depositType,
        uint256 depositActionAmount_
    ) private {
        int256 depositActionAmount = int256(depositActionAmount_);
        int256 assetInternalAmount;
        require(depositActionAmount >= 0);

        if (depositType == DepositActionType.None) {
            return;
        } else if (
            depositType == DepositActionType.DepositAsset ||
            depositType == DepositActionType.DepositAssetAndMintNToken
        ) {
            assetInternalAmount = balanceState.depositAssetToken(
                account,
                depositActionAmount,
                false // no force transfer
            );
        } else if (
            depositType == DepositActionType.DepositUnderlying ||
            depositType == DepositActionType.DepositUnderlyingAndMintNToken
        ) {
            assetInternalAmount = balanceState.depositUnderlyingToken(account, depositActionAmount);
        } else if (depositType == DepositActionType.ConvertCashToNToken) {
            // _executeNTokenAction, will check if the account has sufficient cash
            assetInternalAmount = depositActionAmount;
        }

        _executeNTokenAction(
            account,
            balanceState,
            depositType,
            depositActionAmount,
            assetInternalAmount
        );
    }

    /// @dev Executes nToken actions
    function _executeNTokenAction(
        address account,
        BalanceState memory balanceState,
        DepositActionType depositType,
        int256 depositActionAmount,
        int256 assetInternalAmount
    ) private {
        // After deposits have occurred, check if we are minting nTokens
        if (
            depositType == DepositActionType.DepositAssetAndMintNToken ||
            depositType == DepositActionType.DepositUnderlyingAndMintNToken ||
            depositType == DepositActionType.ConvertCashToNToken
        ) {
            _checkSufficientCash(balanceState, assetInternalAmount);
            balanceState.netCashChange = balanceState.netCashChange.sub(assetInternalAmount);

            // Converts a given amount of cash (denominated in internal precision) into nTokens
            int256 tokensMinted = nTokenMintAction.nTokenMint(
                balanceState.currencyId,
                assetInternalAmount
            );

            balanceState.netNTokenSupplyChange = balanceState.netNTokenSupplyChange.add(
                tokensMinted
            );
        } else if (depositType == DepositActionType.RedeemNToken) {
            require(
                // prettier-ignore
                balanceState
                    .storedNTokenBalance
                    .add(balanceState.netNTokenTransfer) // transfers would not occur at this point
                    .add(balanceState.netNTokenSupplyChange) >= depositActionAmount,
                ""Insufficient token balance""
            );

            balanceState.netNTokenSupplyChange = balanceState.netNTokenSupplyChange.sub(
                depositActionAmount
            );

            int256 assetCash = nTokenRedeemAction(address(this)).nTokenRedeemViaBatch(
                balanceState.currencyId,
                depositActionAmount
            );

            balanceState.netCashChange = balanceState.netCashChange.add(assetCash);
        }
    }

    /// @dev Calculations any withdraws and finalizes balances
    function _calculateWithdrawActionAndFinalize(
        address account,
        AccountContext memory accountContext,
        BalanceState memory balanceState,
        uint256 withdrawAmountInternalPrecision,
        bool withdrawEntireCashBalance,
        bool redeemToUnderlying
    ) private {
        int256 withdrawAmount = int256(withdrawAmountInternalPrecision);
        require(withdrawAmount >= 0); // dev: withdraw action overflow

        if (withdrawEntireCashBalance) {
            // This option is here so that accounts do not end up with dust after lending since we generally
            // cannot calculate exact cash amounts from the liquidity curve.
            withdrawAmount = balanceState.storedCashBalance.add(balanceState.netCashChange).add(
                balanceState.netAssetTransferInternalPrecision
            );

            // If the account has a negative cash balance then cannot withdraw
            if (withdrawAmount < 0) withdrawAmount = 0;
        }

        // prettier-ignore
        balanceState.netAssetTransferInternalPrecision = balanceState
            .netAssetTransferInternalPrecision
            .sub(withdrawAmount);

        balanceState.finalize(account, accountContext, redeemToUnderlying);
    }

    function _finalizeAccountContext(address account, AccountContext memory accountContext)
        private
    {
        // At this point all balances, market states and portfolio states should be finalized. Just need to check free
        // collateral if required.
        accountContext.setAccountContext(account);
        if (accountContext.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(account);
        }
    }

    /// @notice When lending, adding liquidity or minting nTokens the account must have a sufficient cash balance
    /// to do so.
    function _checkSufficientCash(BalanceState memory balanceState, int256 amountInternalPrecision)
        private
        pure
    {
        require(
            amountInternalPrecision >= 0 &&
                balanceState.storedCashBalance.add(balanceState.netCashChange).add(
                    balanceState.netAssetTransferInternalPrecision
                ) >=
                amountInternalPrecision,
            ""Insufficient cash""
        );
    }

    function _settleAccountIfRequiredAndReturnPortfolio(address account)
        private
        returns (
            AccountContext memory,
            SettleAmount[] memory,
            PortfolioState memory
        )
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        if (accountContext.mustSettleAssets()) {
            return SettleAssetsExternal.settleAssetsAndReturnAll(account, accountContext);
        }

        return (
            accountContext,
            new SettleAmount[](0),
            PortfolioHandler.buildPortfolioState(account, accountContext.assetArrayLength, 0)
        );
    }

    function _settleAccountIfRequiredAndStorePortfolio(address account)
        private
        returns (AccountContext memory, SettleAmount[] memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        SettleAmount[] memory settleAmounts;

        if (accountContext.mustSettleAssets()) {
            return SettleAssetsExternal.settleAssetsAndStorePortfolio(account, accountContext);
        }

        return (accountContext, settleAmounts);
    }
}",3052
RealWorld_TA_23_MockTransferOperator_RealWorld_20240803020729.log,23,MockTransferOperator,74047,3472,77519,128.0,0.439675,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;

import ""interfaces/notional/NotionalProxy.sol"";

// Contract to test safe transfer behavior.
contract MockTransferOperator {
    // bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))
    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;
    // bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))
    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;

    NotionalProxy immutable notionalProxy;

    // Keep values from last received contract.
    bool public shouldReject;

    bytes public lastData;
    address public lastOperator;
    address public lastFrom;
    uint256 public lastId;
    uint256 public lastValue;

    constructor(NotionalProxy notional_) {
        notionalProxy = notional_;
    }

    function initiateTransfer(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external {
        notionalProxy.safeTransferFrom(from, to, id, amount, data);
    }

    function initiateBatchTransfer(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external {
        notionalProxy.safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    function setShouldReject(bool _value) public {
        shouldReject = _value;
    }

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _value,
        bytes calldata _data
    ) external returns (bytes4) {
        lastOperator = _operator;
        lastFrom = _from;
        lastId = _id;
        lastValue = _value;
        lastData = _data;
        if (shouldReject == true) {
            return 0;
        } else {
            return ERC1155_ACCEPTED;
        }
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _values,
        bytes calldata _data
    ) external returns (bytes4) {
        lastOperator = _operator;
        lastFrom = _from;
        lastId = _ids[0];
        lastValue = _values[0];
        lastData = _data;
        if (shouldReject == true) {
            return 0;
        } else {
            return ERC1155_BATCH_ACCEPTED;
        }
    }

    // ERC165 interface support
    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
        return
            interfaceID == 0x01ffc9a7 || // ERC165
            interfaceID == 0x4e2312e0; // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;
    }
}",650
RealWorld_TA_23_Bitmap_RealWorld_20240803051543.log,23,Bitmap,107518,1445,108963,365.0,0.56649,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../global/Types.sol"";
import ""../global/Constants.sol"";

/// @notice Helper methods for bitmaps, they are big-endian and 1-indexed.
library Bitmap {

    /// @notice Set a bit on or off in a bitmap, index is 1-indexed
    function setBit(
        bytes32 bitmap,
        uint256 index,
        bool setOn
    ) internal pure returns (bytes32) {
        require(index >= 1 && index <= 256); // dev: set bit index bounds

        if (setOn) {
            return bitmap | (Constants.MSB >> (index - 1));
        } else {
            return bitmap & ~(Constants.MSB >> (index - 1));
        }
    }

    /// @notice Check if a bit is set
    function isBitSet(bytes32 bitmap, uint256 index) internal pure returns (bool) {
        require(index >= 1 && index <= 256); // dev: set bit index bounds
        return ((bitmap << (index - 1)) & Constants.MSB) == Constants.MSB;
    }

    /// @notice Count the total bits set
    function totalBitsSet(bytes32 bitmap) internal pure returns (uint256) {
        uint256 x = uint256(bitmap);
        x = (x & 0x5555555555555555555555555555555555555555555555555555555555555555) + (x >> 1 & 0x5555555555555555555555555555555555555555555555555555555555555555);
        x = (x & 0x3333333333333333333333333333333333333333333333333333333333333333) + (x >> 2 & 0x3333333333333333333333333333333333333333333333333333333333333333);
        x = (x & 0x0707070707070707070707070707070707070707070707070707070707070707) + (x >> 4);
        x = (x & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) + (x >> 8 & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F);
        x = x + (x >> 16);
        x = x + (x >> 32);
        x = x  + (x >> 64);
        return (x & 0xFF) + (x >> 128 & 0xFF);
    }

    // Does a binary search over x to get the position of the most significant bit
    function getMSB(uint256 x) internal pure returns (uint256 msb) {
        // If x == 0 then there is no MSB and this method will return zero. That would
        // be the same as the return value when x == 1 (MSB is zero indexed), so instead
        // we have this require here to ensure that the values don't get mixed up.
        require(x != 0); // dev: get msb zero value
        if (x >= 0x100000000000000000000000000000000) {
            x >>= 128;
            msb += 128;
        }
        if (x >= 0x10000000000000000) {
            x >>= 64;
            msb += 64;
        }
        if (x >= 0x100000000) {
            x >>= 32;
            msb += 32;
        }
        if (x >= 0x10000) {
            x >>= 16;
            msb += 16;
        }
        if (x >= 0x100) {
            x >>= 8;
            msb += 8;
        }
        if (x >= 0x10) {
            x >>= 4;
            msb += 4;
        }
        if (x >= 0x4) {
            x >>= 2;
            msb += 2;
        }
        if (x >= 0x2) msb += 1; // No need to shift xc anymore
    }

    /// @dev getMSB returns a zero indexed bit number where zero is the first bit counting
    /// from the right (little endian). Asset Bitmaps are counted from the left (big endian)
    /// and one indexed.
    function getNextBitNum(bytes32 bitmap) internal pure returns (uint256 bitNum) {
        // Short circuit the search if bitmap is all zeros
        if (bitmap == 0x00) return 0;

        return 255 - getMSB(uint256(bitmap)) + 1;
    }
}",1058
RealWorld_TA_23_MockNTokenHandler_RealWorld_20240803020939.log,23,MockNTokenHandler,102773,4587,107360,128.0,0.605605,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/nTokenHandler.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockNTokenHandler is StorageLayoutV1 {
    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate) external {
        nTokenHandler.setIncentiveEmissionRate(tokenAddress, newEmissionsRate);
    }

    function getNTokenContext(address tokenAddress)
        external
        view
        returns (
            uint256,
            uint256,
            uint256,
            bytes6
        )
    {
        (
            uint256 currencyId,
            uint256 incentiveRate,
            uint256 lastInitializedTime,
            bytes6 parameters
        ) = nTokenHandler.getNTokenContext(tokenAddress);
        assert(nTokenHandler.nTokenAddress(currencyId) == tokenAddress);

        return (currencyId, incentiveRate, lastInitializedTime, parameters);
    }

    function nTokenAddress(uint256 currencyId) external view returns (address) {
        address tokenAddress = nTokenHandler.nTokenAddress(currencyId);
        // prettier-ignore
        (
            uint256 currencyIdStored,
            /* incentiveRate */,
            /* lastInitializedTime */,
            /* parameters */
        ) = nTokenHandler.getNTokenContext(tokenAddress);
        assert(currencyIdStored == currencyId);

        return tokenAddress;
    }

    function setArrayLengthAndInitializedTime(
        address tokenAddress,
        uint8 arrayLength,
        uint256 lastInitializedTime
    ) external {
        nTokenHandler.setArrayLengthAndInitializedTime(
            tokenAddress,
            arrayLength,
            lastInitializedTime
        );
    }

    function changeNTokenSupply(
        address tokenAddress,
        int256 netChange,
        uint256 blockTime
    ) external returns (uint256) {
        return nTokenHandler.changeNTokenSupply(tokenAddress, netChange, blockTime);
    }

    function getStoredNTokenSupplyFactors(address tokenAddress)
        external
        view
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        return nTokenHandler.getStoredNTokenSupplyFactors(tokenAddress);
    }

    function setNTokenAddress(uint16 currencyId, address tokenAddress) external {
        nTokenHandler.setNTokenAddress(currencyId, tokenAddress);

        // Test the assertions
        this.nTokenAddress(currencyId);
        this.getNTokenContext(tokenAddress);
    }

    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)
        external
        view
        returns (int256[] memory, int256[] memory)
    {
        return nTokenHandler.getDepositParameters(currencyId, maxMarketIndex);
    }

    function setDepositParameters(
        uint256 currencyId,
        uint32[] calldata depositShares,
        uint32[] calldata leverageThresholds
    ) external {
        nTokenHandler.setDepositParameters(currencyId, depositShares, leverageThresholds);
    }

    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)
        external
        view
        returns (int256[] memory, int256[] memory)
    {
        return nTokenHandler.getInitializationParameters(currencyId, maxMarketIndex);
    }

    function setInitializationParameters(
        uint256 currencyId,
        uint32[] calldata annualizedAnchorRates,
        uint32[] calldata proportions
    ) external {
        nTokenHandler.setInitializationParameters(currencyId, annualizedAnchorRates, proportions);
    }

    function getNTokenAssetPV(uint256 currencyId, uint256 blockTime)
        external
        view
        returns (int256)
    {
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);

        (
            int256 assetPv, /* ifCashBitmap */

        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);

        return assetPv;
    }

    function updateNTokenCollateralParameters(
        uint16 currencyId,
        uint8 residualPurchaseIncentive10BPS,
        uint8 pvHaircutPercentage,
        uint8 residualPurchaseTimeBufferHours,
        uint8 cashWithholdingBuffer10BPS,
        uint8 liquidationHaircutPercentage
    ) external {
        address tokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(tokenAddress != address(0), ""Invalid currency"");

        nTokenHandler.setNTokenCollateralParameters(
            tokenAddress,
            residualPurchaseIncentive10BPS,
            pvHaircutPercentage,
            residualPurchaseTimeBufferHours,
            cashWithholdingBuffer10BPS,
            liquidationHaircutPercentage
        );
    }
}",985
RealWorld_TA_23_PortfolioHandler_RealWorld_20240803042002.log,23,PortfolioHandler,304982,4392,309374,377.0,1.61275,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./TransferAssets.sol"";
import ""../valuation/AssetHandler.sol"";
import ""../../math/SafeInt256.sol"";

/// @notice Handles the management of an array of assets including reading from storage, inserting
/// updating, deleting and writing back to storage.
library PortfolioHandler {
    using SafeInt256 for int256;
    using AssetHandler for PortfolioAsset;

    /// @notice Primarily used by the TransferAssets library
    function addMultipleAssets(PortfolioState memory portfolioState, PortfolioAsset[] memory assets)
        internal
        pure
    {
        for (uint256 i; i < assets.length; i++) {
            if (assets[i].notional == 0) continue;

            addAsset(
                portfolioState,
                assets[i].currencyId,
                assets[i].maturity,
                assets[i].assetType,
                assets[i].notional
            );
        }
    }

    function _mergeAssetIntoArray(
        PortfolioAsset[] memory assetArray,
        uint256 currencyId,
        uint256 maturity,
        uint256 assetType,
        int256 notional
    ) private pure returns (bool) {
        for (uint256 i; i < assetArray.length; i++) {
            if (assetArray[i].assetType != assetType) continue;
            if (assetArray[i].currencyId != currencyId) continue;
            if (assetArray[i].maturity != maturity) continue;

            // If the storage index is -1 this is because it's been deleted from settlement. We cannot
            // add fcash that has been settled.
            require(assetArray[i].storageState != AssetStorageState.Delete); // dev: portfolio handler deleted storage

            int256 newNotional = assetArray[i].notional.add(notional);
            // Liquidity tokens cannot be reduced below zero.
            if (AssetHandler.isLiquidityToken(assetType)) {
                require(newNotional >= 0); // dev: portfolio handler negative liquidity token balance
            }

            require(newNotional >= type(int88).min && newNotional <= type(int88).max); // dev: portfolio handler notional overflow

            assetArray[i].notional = newNotional;
            assetArray[i].storageState = AssetStorageState.Update;

            return true;
        }

        return false;
    }

    /// @notice Adds an asset to a portfolio state in memory (does not write to storage)
    /// @dev Ensures that only one version of an asset exists in a portfolio (i.e. does not allow two fCash assets of the same maturity
    /// to exist in a single portfolio). Also ensures that liquidity tokens do not have a negative notional.
    function addAsset(
        PortfolioState memory portfolioState,
        uint256 currencyId,
        uint256 maturity,
        uint256 assetType,
        int256 notional
    ) internal pure {
        if (
            // Will return true if merged
            _mergeAssetIntoArray(
                portfolioState.storedAssets,
                currencyId,
                maturity,
                assetType,
                notional
            )
        ) return;

        if (portfolioState.lastNewAssetIndex > 0) {
            bool merged = _mergeAssetIntoArray(
                portfolioState.newAssets,
                currencyId,
                maturity,
                assetType,
                notional
            );
            if (merged) return;
        }

        // At this point if we have not merged the asset then append to the array
        // Cannot remove liquidity that the portfolio does not have
        if (AssetHandler.isLiquidityToken(assetType)) {
            require(notional >= 0); // dev: portfolio handler negative liquidity token balance
        }
        require(notional >= type(int88).min && notional <= type(int88).max); // dev: portfolio handler notional overflow

        // Need to provision a new array at this point
        if (portfolioState.lastNewAssetIndex == portfolioState.newAssets.length) {
            portfolioState.newAssets = _extendNewAssetArray(portfolioState.newAssets);
        }

        // Otherwise add to the new assets array. It should not be possible to add matching assets in a single transaction, we will
        // check this again when we write to storage.
        portfolioState.newAssets[portfolioState.lastNewAssetIndex].currencyId = currencyId;
        portfolioState.newAssets[portfolioState.lastNewAssetIndex].maturity = maturity;
        portfolioState.newAssets[portfolioState.lastNewAssetIndex].assetType = assetType;
        portfolioState.newAssets[portfolioState.lastNewAssetIndex].notional = notional;
        portfolioState.newAssets[portfolioState.lastNewAssetIndex].storageState = AssetStorageState
            .NoChange;
        portfolioState.lastNewAssetIndex += 1;
    }

    /// @dev Extends the new asset array if it is not large enough, this is likely to get a bit expensive if we do
    /// it too much
    function _extendNewAssetArray(PortfolioAsset[] memory newAssets)
        private
        pure
        returns (PortfolioAsset[] memory)
    {
        PortfolioAsset[] memory extendedArray = new PortfolioAsset[](newAssets.length + 1);
        for (uint256 i; i < newAssets.length; i++) {
            extendedArray[i] = newAssets[i];
        }

        return extendedArray;
    }

    /// @notice Takes a portfolio state and writes it to storage.
    /// @dev This method should only be called directly by the nToken. Account updates to portfolios should happen via
    /// the storeAssetsAndUpdateContext call in the AccountContextHandler.sol library.
    function storeAssets(PortfolioState memory portfolioState, address account)
        internal
        returns (
            bool,
            bytes32,
            uint8,
            uint40
        )
    {
        uint256 initialSlot = uint256(
            keccak256(abi.encode(account, Constants.PORTFOLIO_ARRAY_STORAGE_OFFSET))
        );
        bool hasDebt;
        // NOTE: cannot have more than 16 assets or this byte object will overflow. Max assets is
        // set to 7 and the worst case during liquidation would be 7 liquidity tokens that generate
        // 7 additional fCash assets for a total of 14 assets. Although even in this case all assets
        // would be of the same currency so it would not change the end result of the active currency
        // calculation.
        bytes32 portfolioActiveCurrencies;
        uint256 nextSettleTime;

        // Mark any zero notional assets as deleted
        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            if (
                portfolioState.storedAssets[i].storageState != AssetStorageState.Delete &&
                portfolioState.storedAssets[i].notional == 0
            ) {
                deleteAsset(portfolioState, i);
            }
        }

        // First delete assets from asset storage to maintain asset storage indexes
        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            PortfolioAsset memory asset = portfolioState.storedAssets[i];

            if (asset.storageState == AssetStorageState.Delete) {
                // Delete asset from storage
                uint256 currentSlot = asset.storageSlot;
                assembly {
                    sstore(currentSlot, 0x00)
                }
                continue;
            }

            if (portfolioState.storedAssets[i].storageState == AssetStorageState.Update) {
                // Apply updates
                uint256 currentSlot = asset.storageSlot;
                bytes32 encodedAsset = _encodeAssetToBytes(portfolioState.storedAssets[i]);
                assembly {
                    sstore(currentSlot, encodedAsset)
                }
            }

            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(
                asset,
                hasDebt,
                portfolioActiveCurrencies,
                nextSettleTime
            );
        }

        // Add new assets
        uint256 assetStorageLength = portfolioState.storedAssetLength;
        for (uint256 i; i < portfolioState.newAssets.length; i++) {
            PortfolioAsset memory asset = portfolioState.newAssets[i];
            if (asset.notional == 0) continue;

            bytes32 encodedAsset = _encodeAssetToBytes(portfolioState.newAssets[i]);
            uint256 newAssetSlot = initialSlot + assetStorageLength;

            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(
                asset,
                hasDebt,
                portfolioActiveCurrencies,
                nextSettleTime
            );

            assembly {
                sstore(newAssetSlot, encodedAsset)
            }
            assetStorageLength += 1;
        }

        return (
            hasDebt,
            portfolioActiveCurrencies,
            uint8(assetStorageLength),
            uint40(nextSettleTime)
        );
    }

    /// @notice Updates context information during the store assets method
    function _updatePortfolioContext(
        PortfolioAsset memory asset,
        bool hasDebt,
        bytes32 portfolioActiveCurrencies,
        uint256 nextSettleTime
    )
        private
        pure
        returns (
            bool,
            bytes32,
            uint256
        )
    {
        if (nextSettleTime == 0 || nextSettleTime > asset.getSettlementDate()) {
            nextSettleTime = asset.getSettlementDate();
        }
        hasDebt = hasDebt || asset.notional < 0;
        portfolioActiveCurrencies =
            (portfolioActiveCurrencies >> 16) |
            (bytes32(asset.currencyId) << 240);

        return (hasDebt, portfolioActiveCurrencies, nextSettleTime);
    }

    /// @dev Encodes assets for storage
    function _encodeAssetToBytes(PortfolioAsset memory asset) internal pure returns (bytes32) {
        require(asset.currencyId > 0 && asset.currencyId <= type(uint16).max); // dev: encode asset currency id overflow
        require(asset.maturity > 0 && asset.maturity <= type(uint40).max); // dev: encode asset maturity overflow
        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: encode asset type invalid
        require(asset.notional >= type(int88).min && asset.notional <= type(int88).max); // dev: encode asset notional overflow

        return (bytes32(asset.currencyId) |
            (bytes32(asset.maturity) << 16) |
            (bytes32(asset.assetType) << 56) |
            (bytes32(asset.notional) << 64));
    }

    /// @notice Deletes an asset from a portfolio
    /// @dev This method should only be called during settlement, assets can only be removed from a portfolio before settlement
    /// by adding the offsetting negative position
    function deleteAsset(PortfolioState memory portfolioState, uint256 index) internal pure {
        require(index < portfolioState.storedAssets.length); // dev: stored assets bounds
        require(portfolioState.storedAssetLength > 0); // dev: stored assets length is zero
        require(portfolioState.storedAssets[index].storageState != AssetStorageState.Delete); // dev: cannot re-delete asset

        portfolioState.storedAssetLength -= 1;

        uint256 maxActiveSlotIndex;
        uint256 maxActiveSlot;
        // The max active slot is the last storage slot where an asset exists, it's not clear where this will be in the
        // array so we search for it here.
        for (uint256 i; i < portfolioState.storedAssets.length; i++) {
            if (
                portfolioState.storedAssets[i].storageSlot > maxActiveSlot &&
                portfolioState.storedAssets[i].storageState != AssetStorageState.Delete
            ) {
                maxActiveSlot = portfolioState.storedAssets[i].storageSlot;
                maxActiveSlotIndex = i;
            }
        }

        if (index == maxActiveSlotIndex) {
            // In this case we are deleting the asset with the max storage slot so no swap is necessary.
            portfolioState.storedAssets[index].storageState = AssetStorageState.Delete;
            return;
        }

        // Swap the storage slots of the deleted asset with the last non-deleted asset in the array. Mark them accordingly
        // so that when we call store assets they will be updated appropriately
        (
            portfolioState.storedAssets[maxActiveSlotIndex].storageSlot,
            portfolioState.storedAssets[index].storageSlot
        ) = (
            portfolioState.storedAssets[index].storageSlot,
            portfolioState.storedAssets[maxActiveSlotIndex].storageSlot
        );
        portfolioState.storedAssets[maxActiveSlotIndex].storageState = AssetStorageState.Update;
        portfolioState.storedAssets[index].storageState = AssetStorageState.Delete;
    }

    /// @notice Returns a portfolio array, will be sorted
    function getSortedPortfolio(address account, uint8 assetArrayLength)
        internal
        view
        returns (PortfolioAsset[] memory)
    {
        PortfolioAsset[] memory assets = _loadAssetArray(account, assetArrayLength);
        // No sorting required for length of 1
        if (assets.length <= 1) return assets;

        _quickSortInPlace(assets, 0, int256(assets.length) - 1);
        return assets;
    }

    /// @notice Builds a portfolio array from storage. The new assets hint parameter will
    /// be used to provision a new array for the new assets. This will increase gas efficiency
    /// so that we don't have to make copies when we extend the array.
    function buildPortfolioState(
        address account,
        uint8 assetArrayLength,
        uint256 newAssetsHint
    ) internal view returns (PortfolioState memory) {
        PortfolioState memory state;
        if (assetArrayLength == 0) return state;

        state.storedAssets = getSortedPortfolio(account, assetArrayLength);
        state.storedAssetLength = assetArrayLength;
        state.newAssets = new PortfolioAsset[](newAssetsHint);

        return state;
    }

    /// @dev These ids determine the sort order of assets
    function _getEncodedId(PortfolioAsset memory asset) private pure returns (uint256) {
        return TransferAssets.encodeAssetId(asset.currencyId, asset.maturity, asset.assetType);
    }

    function _quickSortInPlace(
        PortfolioAsset[] memory assets,
        int256 left,
        int256 right
    ) private pure {
        if (left == right) return;
        int256 i = left;
        int256 j = right;

        uint256 pivot = _getEncodedId(assets[uint256(left + (right - left) / 2)]);
        while (i <= j) {
            while (_getEncodedId(assets[uint256(i)]) < pivot) i++;
            while (pivot < _getEncodedId(assets[uint256(j)])) j--;
            if (i <= j) {
                (assets[uint256(i)], assets[uint256(j)]) = (assets[uint256(j)], assets[uint256(i)]);
                i++;
                j--;
            }
        }

        if (left < j) _quickSortInPlace(assets, left, j);
        if (i < right) _quickSortInPlace(assets, i, right);
    }

    function _loadAssetArray(address account, uint8 length)
        private
        view
        returns (PortfolioAsset[] memory)
    {
        PortfolioAsset[] memory assets = new PortfolioAsset[](length);
        uint256 slot = uint256(
            keccak256(abi.encode(account, Constants.PORTFOLIO_ARRAY_STORAGE_OFFSET))
        );

        for (uint256 i; i < length; i++) {
            bytes32 data;
            assembly {
                data := sload(slot)
            }

            assets[i].currencyId = uint256(uint16(uint256(data)));
            assets[i].maturity = uint256(uint40(uint256(data >> 16)));
            assets[i].assetType = uint256(uint8(uint256(data >> 56)));
            assets[i].notional = int256(int88(uint256(data >> 64)));
            assets[i].storageSlot = slot;
            slot = slot + 1;
        }

        return assets;
    }
}",3423
RealWorld_TA_23_CashMarketInterface_RealWorld_20240803083347.log,23,CashMarketInterface,21963,1341,23304,373.0,0.136635,"// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0;

interface CashMarketInterface {
    function getActiveMaturities() external view returns (uint32[] memory);
}",39
RealWorld_TA_23_MockSettleAssets_RealWorld_20240803021543.log,23,MockSettleAssets,147199,6209,153408,167.0,0.860175,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/AccountContextHandler.sol"";
import ""../internal/portfolio/BitmapAssetsHandler.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""../internal/settlement/SettlePortfolioAssets.sol"";
import ""../internal/settlement/SettleBitmapAssets.sol"";

contract MockSettleAssets is StorageLayoutV1 {
    using PortfolioHandler for PortfolioState;
    using Market for MarketParameters;
    using AccountContextHandler for AccountContext;

    function setMaxCurrencyId(uint16 num) external {
        maxCurrencyId = num;
    }

    function getifCashAsset(
        address account,
        uint256 currencyId,
        uint256 maturity
    ) public view returns (int256) {
        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);
    }

    function setAssetArray(address account, PortfolioAsset[] memory a) external {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        PortfolioState memory state;
        state.newAssets = a;
        state.lastNewAssetIndex = a.length - 1;
        accountContext.storeAssetsAndUpdateContext(account, state, false);
        accountContext.setAccountContext(account);
    }

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        require(id <= maxCurrencyId, ""invalid currency id"");
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setMarketState(
        uint256 currencyId,
        uint256 settlementDate,
        uint256 maturity,
        MarketParameters memory ms
    ) external {
        ms.storageSlot = Market.getSlot(currencyId, settlementDate, maturity);
        // ensure that state gets set
        ms.storageState = 0xFF;
        ms.setMarketStorage();
    }

    function getSettlementMarket(
        uint256 currencyId,
        uint256 maturity,
        uint256 settlementDate
    ) external view returns (SettlementMarket memory) {
        return Market.getSettlementMarket(currencyId, maturity, settlementDate);
    }

    function getSettlementRate(uint256 currencyId, uint256 maturity)
        external
        view
        returns (AssetRateParameters memory)
    {
        AssetRateParameters memory rate = AssetRate.buildSettlementRateView(currencyId, maturity);
        return rate;
    }

    function getAssetArray(address account) external view returns (PortfolioAsset[] memory) {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        return PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength);
    }

    function setAccountContext(address account, AccountContext memory a) external {
        a.setAccountContext(account);
    }

    function setAssetBitmap(
        address account,
        uint256 id,
        bytes32 bitmap
    ) external {
        BitmapAssetsHandler.setAssetsBitmap(account, id, bitmap);
    }

    function setifCash(
        address account,
        uint256 currencyId,
        uint256 maturity,
        int256 notional,
        uint256 nextSettleTime
    ) external {
        bytes32 ifCashBitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);

        // prettier-ignore
        (
            ifCashBitmap,
            /* finalNotional */
        ) = BitmapAssetsHandler.addifCashAsset(
            account,
            currencyId,
            maturity,
            nextSettleTime,
            notional,
            ifCashBitmap
        );

        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, ifCashBitmap);
    }

    function setSettlementRate(
        uint256 currencyId,
        uint256 maturity,
        uint128 rate,
        uint8 underlyingDecimalPlaces
    ) external {
        uint256 blockTime = block.timestamp;
        bytes32 slot =
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(maturity, Constants.SETTLEMENT_RATE_STORAGE_OFFSET))
                )
            );
        bytes32 data =
            (bytes32(blockTime) |
                (bytes32(uint256(rate)) << 40) |
                (bytes32(uint256(underlyingDecimalPlaces)) << 168));

        assembly {
            sstore(slot, data)
        }
    }

    function settlePortfolio(address account, uint256 blockTime)
        public
        returns (SettleAmount[] memory)
    {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        PortfolioState memory pState =
            PortfolioHandler.buildPortfolioState(account, accountContext.assetArrayLength, 0);

        SettleAmount[] memory settleAmount =
            SettlePortfolioAssets.settlePortfolio(pState, blockTime);

        // This will change the stored asset array
        accountContext.storeAssetsAndUpdateContext(account, pState, false);
        accountContext.setAccountContext(account);

        return settleAmount;
    }

    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)
        public
        pure
        returns (uint256)
    {
        uint256 maturity = DateTime.getMaturityFromBitNum(blockTime, bitNum);
        assert(maturity > blockTime);

        return maturity;
    }

    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        public
        pure
        returns (uint256, bool)
    {
        return DateTime.getBitNumFromMaturity(blockTime, maturity);
    }

    bytes32 public newBitmapStorage;
    int256 public totalAssetCash;

    function _settleBitmappedCashGroup(
        address account,
        uint256 currencyId,
        bytes32 bitmap,
        uint256 nextSettleTime,
        uint256 blockTime
    ) public {
        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, bitmap);

        (bytes32 newBitmap, int256 newAssetCash, uint256 blockTimeUTC0) =
            SettleBitmapAssets.settleBitmappedCashGroup(
                account,
                currencyId,
                nextSettleTime,
                blockTime
            );

        newBitmapStorage = newBitmap;
        totalAssetCash = newAssetCash;
    }

    function getAssetsBitmap(address account, uint256 currencyId) public view returns (bytes32) {
        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);
    }

    function settleAccount(address account, uint256 currencyId, uint256 nextSettleTime, uint256 blockTime) external {
        // prettier-ignore
        (bytes32 newBitmap, /* int256 newAssetCash */, /* uint256 blockTimeUTC0 */) =
            SettleBitmapAssets.settleBitmappedCashGroup(
                account,
                currencyId,
                nextSettleTime,
                blockTime
            );
        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, newBitmap);
    }

    function getifCashArray(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime
    ) external view returns (PortfolioAsset[] memory) {
        return BitmapAssetsHandler.getifCashArray(account, currencyId, nextSettleTime);
    }

    function getNextBitNum(bytes32 bitmap) external pure returns (uint256) {
        return Bitmap.getNextBitNum(bitmap);
    }

}",1485
RealWorld_TA_23_MockWETH_RealWorld_20240803024004.log,23,MockWETH,693848,1110,694958,181.0,3.49144,"// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.7.0;

contract MockWETH {
    string public name = ""Wrapped Ether"";
    string public symbol = ""WETH"";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // function() public payable {
    //     deposit();
    // }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad, """");
        balanceOf[msg.sender] -= wad;
        // WARNING: msg.sender.transfer fails in buidler, not sure if this will fail
        // on real environments
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad, """");

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad, """");
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}

/*
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  ""This License"" refers to version 3 of the GNU General Public License.

  ""Copyright"" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  ""The Program"" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as ""you"".  ""Licensees"" and
""recipients"" may be individuals or organizations.

  To ""modify"" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a ""modified version"" of the
earlier work or a work ""based on"" the earlier work.

  A ""covered work"" means either the unmodified Program or a work based
on the Program.

  To ""propagate"" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To ""convey"" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays ""Appropriate Legal Notices""
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The ""source code"" for a work means the preferred form of the work
for making modifications to it.  ""Object code"" means any non-source
form of a work.

  A ""Standard Interface"" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The ""System Libraries"" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
""Major Component"", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The ""Corresponding Source"" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    ""keep intact all notices"".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
""aggregate"" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A ""User Product"" is either (1) a ""consumer product"", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, ""normally used"" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  ""Installation Information"" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  ""Additional permissions"" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered ""further
restrictions"" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An ""entity transaction"" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A ""contributor"" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's ""contributor version"".

  A contributor's ""essential patent claims"" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, ""control"" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a ""patent license"" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To ""grant"" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  ""Knowingly relying"" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is ""discriminatory"" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License ""or any later version"" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the ""copyright"" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an ""about box"".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a ""copyright disclaimer"" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

*/",8082
RealWorld_TA_23_LiquidationHelpers_RealWorld_20240803031805.log,23,LiquidationHelpers,188455,4719,193174,373.0,1.036655,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./LiquidatefCash.sol"";
import ""../AccountContextHandler.sol"";
import ""../valuation/ExchangeRate.sol"";
import ""../portfolio/BitmapAssetsHandler.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../balances/BalanceHandler.sol"";
import ""../balances/TokenHandler.sol"";
import ""../markets/AssetRate.sol"";
import ""../../external/FreeCollateralExternal.sol"";
import ""../../math/SafeInt256.sol"";

library LiquidationHelpers {
    using SafeInt256 for int256;
    using ExchangeRate for ETHRate;
    using BalanceHandler for BalanceState;
    using PortfolioHandler for PortfolioState;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using TokenHandler for Token;

    /// @notice Settles accounts and returns liquidation factors for all of the liquidation actions.
    function preLiquidationActions(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency
    )
        internal
        returns (
            AccountContext memory,
            LiquidationFactors memory,
            PortfolioState memory
        )
    {
        // Cannot liquidate yourself
        require(msg.sender != liquidateAccount);
        require(localCurrency != 0);
        // Collateral currency must be unset or not equal to the local currency
        require(collateralCurrency == 0 || collateralCurrency != localCurrency);
        (
            AccountContext memory accountContext,
            LiquidationFactors memory factors,
            PortfolioAsset[] memory portfolio
        ) =
            FreeCollateralExternal.getLiquidationFactors(
                liquidateAccount,
                localCurrency,
                collateralCurrency
            );

        PortfolioState memory portfolioState =
            PortfolioState({
                storedAssets: portfolio,
                newAssets: new PortfolioAsset[](0),
                lastNewAssetIndex: 0,
                storedAssetLength: portfolio.length
            });

        return (accountContext, factors, portfolioState);
    }

    /// @notice We allow liquidators to purchase up to Constants.DEFAULT_LIQUIDATION_PORTION percentage of collateral
    /// assets during liquidation to recollateralize an account as long as it does not also put the account
    /// further into negative free collateral (i.e. constraints on local available and collateral available).
    /// Additionally, we allow the liquidator to specify a maximum amount of collateral they would like to
    /// purchase so we also enforce that limit here.
    function calculateLiquidationAmount(
        int256 initialAmountToLiquidate,
        int256 maxTotalBalance,
        int256 userSpecifiedMaximum
    ) internal pure returns (int256) {
        // By default, the liquidator is allowed to purchase at least to `defaultAllowedAmount`
        // if `initialAmountToLiquidate` is less than `defaultAllowedAmount`.
        int256 defaultAllowedAmount =
            maxTotalBalance.mul(Constants.DEFAULT_LIQUIDATION_PORTION).div(
                Constants.PERCENTAGE_DECIMALS
            );

        int256 result = initialAmountToLiquidate;

        // Limit the purchase amount by the max total balance, we cannot purchase
        // more than what is available.
        if (initialAmountToLiquidate > maxTotalBalance) {
            result = maxTotalBalance;
        }

        if (initialAmountToLiquidate < defaultAllowedAmount) {
            // Allow the liquidator to go up to the default allowed amount
            result = defaultAllowedAmount;
        }

        if (userSpecifiedMaximum > 0 && result > userSpecifiedMaximum) {
            // Do not allow liquidation above the user specified maximum
            result = userSpecifiedMaximum;
        }

        return result;
    }

    /// @dev Calculates factors when liquidating across two currencies
    function calculateCrossCurrencyBenefitAndDiscount(LiquidationFactors memory factors)
        internal
        pure
        returns (int256 assetCashBenefitRequired, int256 liquidationDiscount)
    {
        // This calculation returns the amount of benefit that selling collateral for local currency will
        // be back to the account.
        assetCashBenefitRequired = factors.cashGroup.assetRate.convertFromUnderlying(
            factors
                .collateralETHRate
                .convertETHTo(factors.netETHValue.neg())
                .mul(Constants.PERCENTAGE_DECIMALS)
            // If the haircut is zero here the transaction will revert, which is the correct result. Liquidating
            // collateral with a zero haircut will have no net benefit back to the liquidated account.
                .div(factors.collateralETHRate.haircut)
        );

        if (
            factors.collateralETHRate.liquidationDiscount > factors.localETHRate.liquidationDiscount
        ) {
            liquidationDiscount = factors.collateralETHRate.liquidationDiscount;
        } else {
            liquidationDiscount = factors.localETHRate.liquidationDiscount;
        }

        return (assetCashBenefitRequired, liquidationDiscount);
    }

    /// @notice Calculates the local to purchase in cross currency liquidations. Ensures that local to purchase
    /// is not so large that the account is put further into debt.
    function calculateLocalToPurchase(
        LiquidationFactors memory factors,
        int256 liquidationDiscount,
        int256 collateralAssetPresentValue,
        int256 collateralAssetBalanceToSell
    ) internal pure returns (int256, int256) {
        // Converts collateral present value to the local amount along with the liquidation discount.
        // localPurchased = collateralToSell / (exchangeRate * liquidationDiscount)
        int256 collateralUnderlyingPresentValue =
            factors.cashGroup.assetRate.convertToUnderlying(collateralAssetPresentValue);
        int256 localUnderlyingFromLiquidator =
            collateralUnderlyingPresentValue
                .mul(Constants.PERCENTAGE_DECIMALS)
                .mul(factors.localETHRate.rateDecimals)
                .div(ExchangeRate.exchangeRate(factors.localETHRate, factors.collateralETHRate))
                .div(liquidationDiscount);

        int256 localAssetFromLiquidator =
            factors.localAssetRate.convertFromUnderlying(localUnderlyingFromLiquidator);

        if (localAssetFromLiquidator > factors.localAssetAvailable.neg()) {
            // If the local to purchase will flip the sign of localAssetAvailable then the calculations
            // for the collateral purchase amounts will be thrown off. The positive portion of localAssetAvailable
            // has to have a haircut applied. If this haircut reduces the localAssetAvailable value below
            // the collateralAssetValue then this may actually decrease overall free collateral.
            collateralAssetBalanceToSell = collateralAssetBalanceToSell
                .mul(factors.localAssetAvailable.neg())
                .div(localAssetFromLiquidator);

            localAssetFromLiquidator = factors.localAssetAvailable.neg();
        }

        return (collateralAssetBalanceToSell, localAssetFromLiquidator);
    }

    function finalizeLiquidatorLocal(
        address liquidator,
        uint256 localCurrencyId,
        int256 netLocalFromLiquidator,
        int256 netLocalNTokens
    ) internal returns (AccountContext memory) {
        // Liquidator must deposit netLocalFromLiquidator, in the case of a repo discount then the
        // liquidator will receive some positive amount
        Token memory token = TokenHandler.getToken(localCurrencyId, false);
        AccountContext memory liquidatorContext =
            AccountContextHandler.getAccountContext(liquidator);
        BalanceState memory liquidatorLocalBalance;
        liquidatorLocalBalance.loadBalanceState(liquidator, localCurrencyId, liquidatorContext);

        if (token.hasTransferFee && netLocalFromLiquidator > 0) {
            // If a token has a transfer fee then it must have been deposited prior to the liquidation
            // or else we won't be able to net off the correct amount. We also require that the account
            // does not have debt so that we do not have to run a free collateral check here
            require(
                liquidatorLocalBalance.storedCashBalance >= netLocalFromLiquidator &&
                    liquidatorContext.hasDebt == 0x00,
                ""No cash""
            ); // dev: token has transfer fee, no liquidator balance
            liquidatorLocalBalance.netCashChange = netLocalFromLiquidator.neg();
        } else {
            token.transfer(liquidator, token.convertToExternal(netLocalFromLiquidator));
        }
        liquidatorLocalBalance.netNTokenTransfer = netLocalNTokens;
        liquidatorLocalBalance.finalize(liquidator, liquidatorContext, false);

        return liquidatorContext;
    }

    function finalizeLiquidatorCollateral(
        address liquidator,
        AccountContext memory liquidatorContext,
        uint256 collateralCurrencyId,
        int256 netCollateralToLiquidator,
        int256 netCollateralNTokens,
        bool withdrawCollateral,
        bool redeemToUnderlying
    ) internal returns (AccountContext memory) {
        BalanceState memory balance;
        balance.loadBalanceState(liquidator, collateralCurrencyId, liquidatorContext);
        balance.netCashChange = netCollateralToLiquidator;

        if (withdrawCollateral) {
            balance.netAssetTransferInternalPrecision = netCollateralToLiquidator.neg();
        }

        balance.netNTokenTransfer = netCollateralNTokens;
        balance.finalize(liquidator, liquidatorContext, redeemToUnderlying);

        return liquidatorContext;
    }

    function finalizeLiquidatedLocalBalance(
        address liquidateAccount,
        uint256 localCurrency,
        AccountContext memory accountContext,
        int256 netLocalFromLiquidator
    ) internal {
        BalanceState memory balance;
        balance.loadBalanceState(liquidateAccount, localCurrency, accountContext);
        balance.netCashChange = netLocalFromLiquidator;
        balance.finalize(liquidateAccount, accountContext, false);
    }
}",2047
RealWorld_TA_23_CEtherInterface_RealWorld_20240803093542.log,23,CEtherInterface,21678,1688,23366,368.0,0.14215,"// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.7.0;

interface CEtherInterface {
    function mint() external payable;
}",32
RealWorld_TA_23_MockERC20_RealWorld_20240803020513.log,23,MockERC20,211742,3201,214943,134.0,1.12273,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

contract MockERC20 is IERC20, Context {
    uint public transferFee;
    uint internal constant transferFeeDecimals = 1e18;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The defaut value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        uint fee
    ) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;
        _mint(msg.sender, 10**decimals_ * 1e23);
        transferFee = fee;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overloaded;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        require(_allowances[sender][_msgSender()] >= amount, ""ERC20: transfer amount exceeds allowance"");
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        require(_allowances[_msgSender()][spender] >= subtractedValue, ""ERC20: decreased allowance below zero"");
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);

        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        require(_balances[sender] >= amount, ""ERC20: transfer amount exceeds balance"");
        _balances[sender] -= amount;
        if (transferFee != 0) {
            uint fee = amount * transferFee / 1e18;
            amount = amount - fee;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        require(_balances[account] >= amount, ""ERC20: burn amount exceeds balance"");
        _balances[account] -= amount;
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}",2312
RealWorld_TA_23_ERC1155Action_RealWorld_20240803070105.log,23,ERC1155Action,308395,6067,314462,362.0,1.663315,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./BatchAction.sol"";
import ""./nTokenRedeemAction.sol"";
import ""../FreeCollateralExternal.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""../../internal/AccountContextHandler.sol"";
import ""../../internal/portfolio/TransferAssets.sol"";
import ""../../internal/portfolio/PortfolioHandler.sol"";
import ""interfaces/IERC1155TokenReceiver.sol"";
import ""interfaces/notional/nERC1155Interface.sol"";

contract ERC1155Action is nERC1155Interface, StorageLayoutV1 {
    using AccountContextHandler for AccountContext;

    // bytes4(keccak256(""onERC1155Received(address,address,uint256,uint256,bytes)""))
    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;
    // bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))
    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;

    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {
        return interfaceId == type(nERC1155Interface).interfaceId;
    }

    /// @notice Returns the balance of an ERC1155 id on an account. WARNING: the balances returned by
    /// this method are int256 not uint256 as specified in ERC1155. Modify smart contracts accordingly.
    /// @param account account to get the id for
    /// @param id the ERC1155 id
    /// @return Balance of the ERC1155 id as a signed integer
    function balanceOf(address account, uint256 id) public view override returns (int256) {
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        int256 notional;

        if (accountContext.bitmapCurrencyId != 0) {
            notional = _balanceInBitmap(account, accountContext.bitmapCurrencyId, id);
        } else {
            notional = _balanceInArray(
                PortfolioHandler.getSortedPortfolio(account, accountContext.assetArrayLength),
                id
            );
        }

        return notional;
    }

    /// @notice Returns the balance of a batch of accounts and ids. WARNING: these balances are signed integers, not
    /// unsigned integers as the ERC1155 spec designates
    /// @param accounts array of accounts to get balances for
    /// @param ids array of ids to get balances for
    /// @return Returns an array of balances as signed integers
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        override
        returns (int256[] memory)
    {
        require(accounts.length == ids.length);
        int256[] memory amounts = new int256[](accounts.length);

        for (uint256 i; i < accounts.length; i++) {
            // This is pretty inefficient but gets the job done
            amounts[i] = balanceOf(accounts[i], ids[i]);
        }

        return amounts;
    }

    /// @dev Returns the balance from a bitmap given the id
    function _balanceInBitmap(
        address account,
        uint256 bitmapCurrencyId,
        uint256 id
    ) internal view returns (int256) {
        (uint256 currencyId, uint256 maturity, uint256 assetType) = TransferAssets.decodeAssetId(
            id
        );
        if (currencyId != bitmapCurrencyId) return 0;
        if (assetType != Constants.FCASH_ASSET_TYPE) return 0;

        return BitmapAssetsHandler.getifCashNotional(account, currencyId, maturity);
    }

    /// @dev Searches an array for the matching asset
    function _balanceInArray(PortfolioAsset[] memory portfolio, uint256 id)
        internal
        pure
        returns (int256)
    {
        for (uint256 i; i < portfolio.length; i++) {
            if (
                TransferAssets.encodeAssetId(
                    portfolio[i].currencyId,
                    portfolio[i].maturity,
                    portfolio[i].assetType
                ) == id
            ) return portfolio[i].notional;
        }
    }

    /// @notice Transfer of a single fCash or liquidity token asset between accounts. Allows `from` account to transfer more fCash
    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.
    /// @param from account to transfer from
    /// @param to account to transfer to
    /// @param id ERC1155 id of the asset
    /// @param amount amount to transfer
    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate
    /// a trading action on Notional for the `from` address
    /// @dev emit:TransferSingle
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external payable override {
        require(amount <= uint256(type(int256).max)); // dev: int overflow
        _validateAccounts(from, to);

        // If code size > 0 call onERC1155received
        uint256 codeSize;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            codeSize := extcodesize(to)
        }
        if (codeSize > 0) {
            require(
                IERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==
                    ERC1155_ACCEPTED,
                ""Not accepted""
            );
        }

        // When amount is set to zero this method can be used as a way to execute trades via a transfer operator
        AccountContext memory fromContext;
        if (amount > 0) {
            PortfolioAsset[] memory assets = new PortfolioAsset[](1);
            (assets[0].currencyId, assets[0].maturity, assets[0].assetType) = TransferAssets
                .decodeAssetId(id);
            assets[0].notional = int256(amount);
            _assertValidMaturity(assets[0].currencyId, assets[0].maturity, block.timestamp);

            // prettier-ignore
            (fromContext, /* toContext */) = _transfer(from, to, assets);

            emit TransferSingle(msg.sender, from, to, id, amount);
        } else {
            fromContext = AccountContextHandler.getAccountContext(from);
        }

        // toContext is always empty here because we cannot have bidirectional transfers in `safeTransferFrom`
        AccountContext memory toContext;
        _checkPostTransferEvent(from, to, fromContext, toContext, data, false);
    }

    /// @notice Transfer of a batch of fCash or liquidity token assets between accounts. Allows `from` account to transfer more fCash
    /// than they have as long as they pass a subsequent free collateral check. This enables OTC trading of fCash assets.
    /// @param from account to transfer from
    /// @param to account to transfer to
    /// @param ids ERC1155 ids of the assets
    /// @param amounts amounts to transfer
    /// @param data arbitrary data passed to ERC1155Receiver (if contract) and if properly specified can be used to initiate
    /// a trading action on Notional for the `from` address
    /// @dev emit:TransferBatch
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external override {
        _validateAccounts(from, to);

        // If code size > 0 call onERC1155received
        uint256 codeSize;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            codeSize := extcodesize(to)
        }
        if (codeSize > 0) {
            require(
                IERC1155TokenReceiver(to).onERC1155BatchReceived(
                    msg.sender,
                    from,
                    ids,
                    amounts,
                    data
                ) == ERC1155_BATCH_ACCEPTED,
                ""Not accepted""
            );
        }

        (PortfolioAsset[] memory assets, bool toTransferNegative) = _decodeToAssets(ids, amounts);
        // When doing a bidirectional transfer must ensure that the `to` account has given approval
        // to msg.sender as well.
        if (toTransferNegative) require(isApprovedForAll(to, msg.sender), ""Unauthorized"");

        (AccountContext memory fromContext, AccountContext memory toContext) = _transfer(
            from,
            to,
            assets
        );

        _checkPostTransferEvent(from, to, fromContext, toContext, data, toTransferNegative);

        emit TransferBatch(msg.sender, from, to, ids, amounts);
    }

    /// @dev Validates accounts on transfer
    function _validateAccounts(address from, address to) private view {
        require(from != to && to != address(0), ""Invalid address"");
        require(msg.sender == from || isApprovedForAll(from, msg.sender), ""Unauthorized"");
    }

    /// @notice Decodes ids and amounts to PortfolioAsset objects
    /// @param ids array of ERC1155 ids
    /// @param amounts amounts to transfer
    /// @return array of portfolio asset objects
    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)
        external
        view
        override
        returns (PortfolioAsset[] memory)
    {
        // prettier-ignore
        (PortfolioAsset[] memory assets, /* */) = _decodeToAssets(ids, amounts);
        return assets;
    }

    function _decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)
        internal
        view
        returns (PortfolioAsset[] memory, bool)
    {
        uint256 blockTime = block.timestamp;
        bool toTransferNegative = false;
        PortfolioAsset[] memory assets = new PortfolioAsset[](ids.length);

        for (uint256 i; i < ids.length; i++) {
            (assets[i].currencyId, assets[i].maturity, assets[i].assetType) = TransferAssets
                .decodeAssetId(ids[i]);

            _assertValidMaturity(assets[i].currencyId, assets[i].maturity, blockTime);
            // Although amounts is encoded as uint256 we allow it to be negative here. This will
            // allow for bidirectional transfers of fCash. Internally fCash assets are always stored
            // as int128 (for bitmap portfolio) or int88 (for array portfolio) so there is no potential
            // that a uint256 value that is greater than type(int256).max would actually valid.
            assets[i].notional = int256(amounts[i]);
            // If there is a negative transfer we mark it as such, this will force us to do a free collateral
            // check on the `to` address as well.
            if (assets[i].notional < 0) toTransferNegative = true;
        }

        return (assets, toTransferNegative);
    }

    /// @notice Encodes parameters into an ERC1155 id
    /// @param currencyId currency id of the asset
    /// @param maturity timestamp of the maturity
    /// @param assetType id of the asset type
    /// @return ERC1155 id
    function encodeToId(
        uint16 currencyId,
        uint40 maturity,
        uint8 assetType
    ) external pure override returns (uint256) {
        return TransferAssets.encodeAssetId(currencyId, maturity, assetType);
    }

    /// @dev Ensures that all maturities specified are valid for the currency id (i.e. they do not
    /// go past the max maturity date)
    function _assertValidMaturity(
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime
    ) private view {
        require(
            DateTime.isValidMaturity(CashGroup.getMaxMarketIndex(currencyId), maturity, blockTime),
            ""Invalid maturity""
        );
    }

    /// @dev Internal asset transfer event between accounts
    function _transfer(
        address from,
        address to,
        PortfolioAsset[] memory assets
    ) internal returns (AccountContext memory, AccountContext memory) {
        AccountContext memory fromContext = AccountContextHandler.getAccountContext(from);
        AccountContext memory toContext = AccountContextHandler.getAccountContext(to);

        toContext = TransferAssets.placeAssetsInAccount(to, toContext, assets);
        TransferAssets.invertNotionalAmountsInPlace(assets);
        fromContext = TransferAssets.placeAssetsInAccount(from, fromContext, assets);

        toContext.setAccountContext(to);
        fromContext.setAccountContext(from);

        return (fromContext, toContext);
    }

    /// @dev Checks post transfer events which will either be initiating one of the batch trading events or a free collateral
    /// check if required.
    function _checkPostTransferEvent(
        address from,
        address to,
        AccountContext memory fromContext,
        AccountContext memory toContext,
        bytes calldata data,
        bool toTransferNegative
    ) internal {
        bytes4 sig;
        address transactedAccount;
        if (data.length >= 32) {
            // Method signature is not abi encoded so decode to bytes32 first and take the first 4 bytes. This works
            // because all the methods we want to call below require more than 32 bytes in the calldata
            bytes32 tmp = abi.decode(data, (bytes32));
            sig = bytes4(tmp);
        }

        // These are the only three methods allowed to occur in a post transfer event. These actions allow `from`
        // accounts to take any sort of trading action as a result of their transfer. All of these actions will
        // handle checking free collateral so no additional check is necessary here.
        if (
            sig == nTokenRedeemAction.nTokenRedeem.selector ||
            sig == BatchAction.batchBalanceAction.selector ||
            sig == BatchAction.batchBalanceAndTradeAction.selector
        ) {
            transactedAccount = abi.decode(data[4:36], (address));
            // Ensure that the ""transactedAccount"" parameter of the call is set to the from address or the
            // to address. If it is the ""to"" address then ensure that the msg.sender has approval to
            // execute operations
            require(
                transactedAccount == from ||
                    (transactedAccount == to && isApprovedForAll(to, msg.sender)),
                ""Unauthorized call""
            );

            (bool status, bytes memory result) = address(this).call{value: msg.value}(data);
            // TODO: retrieve revert string
            require(status, ""Call failed"");
        }

        // The transacted account will have its free collateral checked above so there is
        // no need to recheck here.
        if (transactedAccount != from && fromContext.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(from);
        }

        // Check free collateral if the `to` account has taken on a negative fCash amount
        if (transactedAccount != to && toTransferNegative && toContext.hasDebt != 0x00) {
            FreeCollateralExternal.checkFreeCollateralAndRevert(to);
        }
    }

    /// @notice Allows an account to set approval for an operator
    /// @param operator address of the operator
    /// @param approved state of the approval
    /// @dev emit:ApprovalForAll
    function setApprovalForAll(address operator, bool approved) external override {
        accountAuthorizedTransferOperator[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /// @notice Checks approval state for an account, will first check if global transfer operator is enabled
    /// before falling through to an account specific transfer operator.
    /// @param account address of the account
    /// @param operator address of the operator
    /// @return true for approved
    function isApprovedForAll(address account, address operator)
        public
        view
        override
        returns (bool)
    {
        if (globalTransferOperator[operator]) return true;

        return accountAuthorizedTransferOperator[account][operator];
    }
}",3432
RealWorld_TA_23_FreeCollateralExternal_RealWorld_20240803054639.log,23,FreeCollateralExternal,69811,2112,71923,369.0,0.391295,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/AccountContextHandler.sol"";
import ""../internal/valuation/FreeCollateral.sol"";

/// @title Externally deployed library for free collateral calculations
library FreeCollateralExternal {
    using AccountContextHandler for AccountContext;

    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of
    /// debt that the account can incur before liquidation.
    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work
    /// for the nToken
    /// @param account account to calculate free collateral for
    /// @return
    ///     - total free collateral in ETH w/ 8 decimal places
    ///     - array of net local values in asset values ordered
    function getFreeCollateralView(address account)
        external
        view
        returns (int256, int256[] memory)
    {
        uint256 blockTime = block.timestamp;
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        return FreeCollateral.getFreeCollateralView(account, accountContext, blockTime);
    }

    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context
    /// must be updated due to changes in debt settings, will update
    /// @param account account to calculate free collateral for
    function checkFreeCollateralAndRevert(address account) external {
        uint256 blockTime = block.timestamp;
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);

        (int256 ethDenominatedFC, bool updateContext) =
            FreeCollateral.getFreeCollateralStateful(account, accountContext, blockTime);

        if (updateContext) {
            accountContext.setAccountContext(account);
        }

        require(ethDenominatedFC >= 0, ""Insufficient free collateral"");
    }

    /// @notice Calculates liquidation factors for an account
    /// @param account account to liquidate
    /// @param localCurrencyId currency that the debts are denominated in
    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation
    function getLiquidationFactors(
        address account,
        uint256 localCurrencyId,
        uint256 collateralCurrencyId
    )
        external
        returns (
            AccountContext memory accountContext,
            LiquidationFactors memory factors,
            PortfolioAsset[] memory portfolio
        )
    {
        accountContext = AccountContextHandler.getAccountContext(account);

        if (accountContext.mustSettleAssets()) {
            accountContext = SettleAssetsExternal.settleAssetsAndFinalize(account, accountContext);
        }

        (factors, portfolio) = FreeCollateral.getLiquidationFactors(
            account,
            accountContext,
            block.timestamp,
            localCurrencyId,
            collateralCurrencyId
        );
    }
}",617
RealWorld_TA_23_Market_RealWorld_20240803035510.log,23,Market,688685,352,689037,370.0,3.450465,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./AssetRate.sol"";
import ""./CashGroup.sol"";
import ""./DateTime.sol"";
import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/ABDKMath64x64.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library Market {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;

    bytes1 private constant STORAGE_STATE_NO_CHANGE = 0x00;
    bytes1 private constant STORAGE_STATE_UPDATE_LIQUIDITY = 0x01;
    bytes1 private constant STORAGE_STATE_UPDATE_TRADE = 0x02;
    bytes1 internal constant STORAGE_STATE_INITIALIZE_MARKET = 0x03; // Both settings are set

    // Max positive value for a ABDK64x64 integer
    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;

    /// @notice Add liquidity to a market, assuming that it is initialized. If not then
    /// this method will revert and the market must be initialized first.
    /// @return liquidityTokenAmount and net negative fCash
    function addLiquidity(MarketParameters memory market, int256 assetCash)
        internal
        pure
        returns (int256, int256)
    {
        require(market.totalLiquidity > 0, ""M: zero liquidity"");
        if (assetCash == 0) return (0, 0);
        require(assetCash > 0); // dev: negative asset cash

        int256 liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);
        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.
        int256 fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);

        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);
        market.totalfCash = market.totalfCash.add(fCash);
        market.totalAssetCash = market.totalAssetCash.add(assetCash);
        market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;

        return (liquidityTokens, fCash.neg());
    }

    /// @notice Remove liquidity from a market, assuming that it is initialized.
    /// @return asset cash and positive fCash claim to return
    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)
        internal
        pure
        returns (int256, int256)
    {
        if (tokensToRemove == 0) return (0, 0);
        require(tokensToRemove > 0); // dev: negative tokens to remove

        int256 assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);
        int256 fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);

        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);
        market.totalfCash = market.totalfCash.subNoNeg(fCash);
        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);
        market.storageState = market.storageState | STORAGE_STATE_UPDATE_LIQUIDITY;

        return (assetCash, fCash);
    }

    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive
    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.
    /// @param market the current market state
    /// @param cashGroup cash group configuration parameters
    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change
    /// to the market is in the opposite direction.
    /// @param timeToMaturity number of seconds until maturity
    /// @return netAssetCash, netAssetCashToReserve
    function calculateTrade(
        MarketParameters memory market,
        CashGroupParameters memory cashGroup,
        int256 fCashToAccount,
        uint256 timeToMaturity,
        uint256 marketIndex
    ) internal view returns (int256, int256) {
        // We return false if there is not enough fCash to support this trade.
        if (market.totalfCash.sub(fCashToAccount) <= 0) return (0, 0);

        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =
            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);

        int256 preFeeExchangeRate;
        {
            bool success;
            (preFeeExchangeRate, success) = _getExchangeRate(
                market.totalfCash,
                totalCashUnderlying,
                rateScalar,
                rateAnchor,
                fCashToAccount
            );
            if (!success) return (0, 0);
        }

        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =
            _getNetCashAmountsUnderlying(
                cashGroup,
                preFeeExchangeRate,
                fCashToAccount,
                timeToMaturity
            );
        if (netCashToAccount == 0) return (0, 0);

        {
            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);
            market.lastImpliedRate = getImpliedRate(
                market.totalfCash,
                totalCashUnderlying.add(netCashToMarket),
                rateScalar,
                rateAnchor,
                timeToMaturity
            );

            // It's technically possible that the implied rate is actually exactly zero (or
            // more accurately the natural log rounds down to zero) but we will still fail
            // in this case. If this does happen we may assume that markets are not initialized.
            if (market.lastImpliedRate == 0) return (0, 0);
        }

        return
            _setNewMarketState(
                market,
                cashGroup.assetRate,
                netCashToAccount,
                netCashToMarket,
                netCashToReserve
            );
    }

    /// @notice Returns factors for calculating exchange rates
    function getExchangeRateFactors(
        MarketParameters memory market,
        CashGroupParameters memory cashGroup,
        uint256 timeToMaturity,
        uint256 marketIndex
    )
        internal
        pure
        returns (
            int256,
            int256,
            int256
        )
    {
        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);
        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);

        // This will result in a divide by zero
        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);

        // Get the rate anchor given the market state, this will establish the baseline for where
        // the exchange rate is set.
        int256 rateAnchor;
        {
            bool success;
            (rateAnchor, success) = _getRateAnchor(
                market.totalfCash,
                market.lastImpliedRate,
                totalCashUnderlying,
                rateScalar,
                timeToMaturity
            );
            if (!success) return (0, 0, 0);
        }

        return (rateScalar, totalCashUnderlying, rateAnchor);
    }

    /// @dev Returns net asset cash amounts to the account, the market and the reserve
    function _getNetCashAmountsUnderlying(
        CashGroupParameters memory cashGroup,
        int256 preFeeExchangeRate,
        int256 fCashToAccount,
        uint256 timeToMaturity
    )
        private
        pure
        returns (
            int256,
            int256,
            int256
        )
    {
        // Fees are specified in basis points which is an implied rate denomination. We convert this to
        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply
        // or divide depending on the side of the trade).
        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)
        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)
        int256 preFeeCashToAccount =
            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();
        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);

        if (fCashToAccount > 0) {
            // Lending
            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);
            // It's possible that the fee pushes exchange rates into negative territory. This is not possible
            // when borrowing. If this happens then the trade has failed.
            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);

            // cashToAccount = -(fCashToAccount / exchangeRate)
            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate
            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)
            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)
            // netFee = preFeeCashToAccount - postFeeCashToAccount
            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)
            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)
            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)
            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)
            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)
            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));
        } else {
            // Borrowing
            // cashToAccount = -(fCashToAccount / exchangeRate)
            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate

            // netFee = preFeeCashToAccount - postFeeCashToAccount
            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)
            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)
            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)
            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)
            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number
            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();
        }

        int256 cashToReserve =
            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);

        return (
            // postFeeCashToAccount = preFeeCashToAccount - fee
            preFeeCashToAccount.sub(fee),
            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)
            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),
            cashToReserve
        );
    }

    function _setNewMarketState(
        MarketParameters memory market,
        AssetRateParameters memory assetRate,
        int256 netCashToAccount,
        int256 netCashToMarket,
        int256 netCashToReserve
    ) private view returns (int256, int256) {
        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);
        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);

        // Sets the trade time for the next oracle update
        market.previousTradeTime = block.timestamp;
        market.storageState = market.storageState | STORAGE_STATE_UPDATE_TRADE;

        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);
        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);
        return (netAssetCashToAccount, assetCashToReserve);
    }

    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable
    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate
    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied
    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage
    /// which will hurt the liquidity providers.
    ///
    /// The rate anchor will update as the market rolls down to maturity. The calculation is:
    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)
    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar
    ///
    /// where:
    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')
    ///      (calculated when the last trade in the market was made)
    /// @dev has an underscore to denote as private but is marked internal for the mock
    /// @return the new rate anchor and a boolean that signifies success
    function _getRateAnchor(
        int256 totalfCash,
        uint256 lastImpliedRate,
        int256 totalCashUnderlying,
        int256 rateScalar,
        uint256 timeToMaturity
    ) internal pure returns (int256, bool) {
        // This is the exchange rate at the new time to maturity
        int256 exchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);
        if (exchangeRate < Constants.RATE_PRECISION) return (0, false);

        int256 rateAnchor;
        {
            int256 proportion =
                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));

            (int256 lnProportion, bool success) = _logProportion(proportion);
            if (!success) return (0, false);

            rateAnchor = exchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));
        }

        return (rateAnchor, true);
    }

    /// @notice Calculates the current market implied rate.
    /// @return the implied rate and a bool that is true on success
    function getImpliedRate(
        int256 totalfCash,
        int256 totalCashUnderlying,
        int256 rateScalar,
        int256 rateAnchor,
        uint256 timeToMaturity
    ) internal pure returns (uint256) {
        // This will check for exchange rates < Constants.RATE_PRECISION
        (int256 exchangeRate, bool success) =
            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);
        if (!success) return 0;

        // Uses continuous compounding to calculate the implied rate:
        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity
        int128 rate = ABDKMath64x64.fromInt(exchangeRate);
        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);
        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION
        // inside getExchangeRate
        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);
        uint256 lnRate =
            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));

        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);

        // Implied rates over 429% will overflow, this seems like a safe assumption
        if (impliedRate > type(uint32).max) return 0;

        return impliedRate;
    }

    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The
    /// formula is E = e^rt
    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)
        internal
        pure
        returns (int256)
    {
        int128 expValue =
            ABDKMath64x64.fromUInt(
                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)
            );
        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);
        int128 expResult = ABDKMath64x64.exp(expValueScaled);
        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);

        return ABDKMath64x64.toInt(expResultScaled);
    }

    /// @notice Returns the exchange rate between fCash and cash for the given market
    /// Calculates the following exchange rate:
    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor
    /// where:
    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)
    /// @dev has an underscore to denote as private but is marked internal for the mock
    function _getExchangeRate(
        int256 totalfCash,
        int256 totalCashUnderlying,
        int256 rateScalar,
        int256 rateAnchor,
        int256 fCashToAccount
    ) internal pure returns (int256, bool) {
        int256 numerator = totalfCash.subNoNeg(fCashToAccount);

        // This is the proportion scaled by Constants.RATE_PRECISION
        int256 proportion =
            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));

        (int256 lnProportion, bool success) = _logProportion(proportion);
        if (!success) return (0, false);

        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);
        // Do not succeed if interest rates fall below 1
        if (rate < Constants.RATE_PRECISION) {
            return (0, false);
        } else {
            return (rate, true);
        }
    }

    /// @dev This method calculates the log of the proportion inside the logit function which is
    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with
    /// fixed point precision and the ABDK library.
    function _logProportion(int256 proportion) internal pure returns (int256, bool) {
        if (proportion == Constants.RATE_PRECISION) return (0, false);

        proportion = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));

        // This is the max 64 bit integer for ABDKMath. This is unlikely to trip because the
        // value is 9.2e18 and the proportion is scaled by 1e9. We can hit very high levels of
        // pool utilization before this returns false.
        if (proportion > MAX64) return (0, false);

        // ABDK does not handle log of numbers that are less than 1, in order to get the right value
        // scaled by RATE_PRECISION we use the log identity:
        // (ln(proportion / RATE_PRECISION)) * RATE_PRECISION = (ln(proportion) - ln(RATE_PRECISION)) * RATE_PRECISION
        int128 abdkProportion = ABDKMath64x64.fromInt(proportion);
        // Here, abdk will revert due to negative log so abort
        if (abdkProportion <= 0) return (0, false);
        int256 result =
            ABDKMath64x64.toInt(
                ABDKMath64x64.mul(
                    ABDKMath64x64.sub(
                        ABDKMath64x64.ln(abdkProportion),
                        Constants.LOG_RATE_PRECISION_64x64
                    ),
                    Constants.RATE_PRECISION_64x64
                )
            );

        return (result, true);
    }

    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value
    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,
    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.
    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then
    /// be liquidated.
    ///
    /// Oracle rates are calculated when the market is loaded from storage.
    ///
    /// The oracle rate is a lagged weighted average over a short term price window. If we are past
    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the
    /// weighted average:
    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +
    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)
    function _updateRateOracle(
        uint256 previousTradeTime,
        uint256 lastImpliedRate,
        uint256 oracleRate,
        uint256 rateOracleTimeWindow,
        uint256 blockTime
    ) private pure returns (uint256) {
        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero

        // This can occur when using a view function get to a market state in the past
        if (previousTradeTime > blockTime) return lastImpliedRate;

        uint256 timeDiff = blockTime.sub(previousTradeTime);
        if (timeDiff > rateOracleTimeWindow) {
            // If past the time window just return the lastImpliedRate
            return lastImpliedRate;
        }

        // (currentTs - previousTs) / timeWindow
        uint256 lastTradeWeight =
            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);

        // 1 - (currentTs - previousTs) / timeWindow
        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);

        uint256 newOracleRate =
            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(
                uint256(Constants.RATE_PRECISION)
            );

        return newOracleRate;
    }

    function getSlot(
        uint256 currencyId,
        uint256 settlementDate,
        uint256 maturity
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    maturity,
                    keccak256(
                        abi.encode(
                            settlementDate,
                            keccak256(abi.encode(currencyId, Constants.MARKET_STORAGE_OFFSET))
                        )
                    )
                )
            );
    }

    /// @notice Liquidity is not required for lending and borrowing so we don't automatically read it. This method is called if we
    /// do need to load the liquidity amount.
    function getTotalLiquidity(MarketParameters memory market) internal view {
        int256 totalLiquidity;
        bytes32 slot = bytes32(uint256(market.storageSlot) + 1);

        assembly {
            totalLiquidity := sload(slot)
        }
        market.totalLiquidity = totalLiquidity;
    }

    function getOracleRate(
        uint256 currencyId,
        uint256 maturity,
        uint256 rateOracleTimeWindow,
        uint256 blockTime
    ) internal view returns (uint256) {
        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;
        bytes32 slot = getSlot(currencyId, settlementDate, maturity);
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        uint256 lastImpliedRate = uint256(uint32(uint256(data >> 160)));
        uint256 oracleRate = uint256(uint32(uint256(data >> 192)));
        uint256 previousTradeTime = uint256(uint32(uint256(data >> 224)));

        // If the oracle rate is set to zero this can only be because the markets have past their settlement
        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated
        // during this time, but market initialization can be called by anyone so the actual time that this condition
        // exists for should be quite short.
        require(oracleRate > 0, ""Market not initialized"");

        return
            _updateRateOracle(
                previousTradeTime,
                lastImpliedRate,
                oracleRate,
                rateOracleTimeWindow,
                blockTime
            );
    }

    /// @notice Reads a market object directly from storage. `buildMarket` should be called instead of this method
    /// which ensures that the rate oracle is set properly.
    function _loadMarketStorage(
        MarketParameters memory market,
        uint256 currencyId,
        uint256 maturity,
        bool needsLiquidity,
        uint256 settlementDate
    ) private view {
        // Market object always uses the most current reference time as the settlement date
        bytes32 slot = getSlot(currencyId, settlementDate, maturity);
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        market.storageSlot = slot;
        market.maturity = maturity;
        market.totalfCash = int256(uint80(uint256(data)));
        market.totalAssetCash = int256(uint80(uint256(data >> 80)));
        market.lastImpliedRate = uint256(uint32(uint256(data >> 160)));
        market.oracleRate = uint256(uint32(uint256(data >> 192)));
        market.previousTradeTime = uint256(uint32(uint256(data >> 224)));
        market.storageState = STORAGE_STATE_NO_CHANGE;

        if (needsLiquidity) {
            getTotalLiquidity(market);
        } else {
            market.totalLiquidity = 0;
        }
    }

    /// @notice Writes market parameters to storage if the market is marked as updated.
    function setMarketStorage(MarketParameters memory market) internal {
        if (market.storageState == STORAGE_STATE_NO_CHANGE) return;
        bytes32 slot = market.storageSlot;

        if (market.storageState & STORAGE_STATE_UPDATE_TRADE != STORAGE_STATE_UPDATE_TRADE) {
            // If no trade has occurred then the oracleRate on chain should not update.
            bytes32 oldData;
            assembly {
                oldData := sload(slot)
            }
            market.oracleRate = uint256(uint32(uint256(oldData >> 192)));
        }

        require(market.totalfCash >= 0 && market.totalfCash <= type(uint80).max); // dev: market storage totalfCash overflow
        require(market.totalAssetCash >= 0 && market.totalAssetCash <= type(uint80).max); // dev: market storage totalAssetCash overflow
        require(market.lastImpliedRate >= 0 && market.lastImpliedRate <= type(uint32).max); // dev: market storage lastImpliedRate overflow
        require(market.oracleRate >= 0 && market.oracleRate <= type(uint32).max); // dev: market storage oracleRate overflow
        require(market.previousTradeTime >= 0 && market.previousTradeTime <= type(uint32).max); // dev: market storage previous trade time overflow

        bytes32 data =
            (bytes32(market.totalfCash) |
                (bytes32(market.totalAssetCash) << 80) |
                (bytes32(market.lastImpliedRate) << 160) |
                (bytes32(market.oracleRate) << 192) |
                (bytes32(market.previousTradeTime) << 224));

        assembly {
            sstore(slot, data)
        }

        if (
            market.storageState & STORAGE_STATE_UPDATE_LIQUIDITY == STORAGE_STATE_UPDATE_LIQUIDITY
        ) {
            require(market.totalLiquidity >= 0 && market.totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow
            slot = bytes32(uint256(slot) + 1);
            bytes32 totalLiquidity = bytes32(market.totalLiquidity);

            assembly {
                sstore(slot, totalLiquidity)
            }
        }
    }

    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.
    function loadMarket(
        MarketParameters memory market,
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime,
        bool needsLiquidity,
        uint256 rateOracleTimeWindow
    ) internal view {
        // Always reference the current settlement date
        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;
        loadMarketWithSettlementDate(
            market,
            currencyId,
            maturity,
            blockTime,
            needsLiquidity,
            rateOracleTimeWindow,
            settlementDate
        );
    }

    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this
    /// is mainly used in the InitializeMarketAction contract.
    function loadMarketWithSettlementDate(
        MarketParameters memory market,
        uint256 currencyId,
        uint256 maturity,
        uint256 blockTime,
        bool needsLiquidity,
        uint256 rateOracleTimeWindow,
        uint256 settlementDate
    ) internal view {
        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);

        market.oracleRate = _updateRateOracle(
            market.previousTradeTime,
            market.lastImpliedRate,
            market.oracleRate,
            rateOracleTimeWindow,
            blockTime
        );
    }

    /// @notice When settling liquidity tokens we only need to get half of the market parameters and the settlement
    /// date must be specified.
    function getSettlementMarket(
        uint256 currencyId,
        uint256 maturity,
        uint256 settlementDate
    ) internal view returns (SettlementMarket memory) {
        uint256 slot = uint256(getSlot(currencyId, settlementDate, maturity));
        int256 totalLiquidity;
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        int256 totalfCash = int256(uint80(uint256(data)));
        int256 totalAssetCash = int256(uint80(uint256(data >> 80)));
        // Clear the lower 160 bits, this data will be combined with the new totalfCash
        // and totalAssetCash figures.
        data = data & 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;

        slot = uint256(slot) + 1;

        assembly {
            totalLiquidity := sload(slot)
        }

        return
            SettlementMarket({
                storageSlot: bytes32(slot - 1),
                totalfCash: totalfCash,
                totalAssetCash: totalAssetCash,
                totalLiquidity: int256(totalLiquidity),
                data: data
            });
    }

    function setSettlementMarket(SettlementMarket memory market) internal {
        bytes32 slot = market.storageSlot;
        bytes32 data;
        require(market.totalfCash >= 0 && market.totalfCash <= type(uint80).max); // dev: settlement market storage totalfCash overflow
        require(market.totalAssetCash >= 0 && market.totalAssetCash <= type(uint80).max); // dev: settlement market storage totalAssetCash overflow
        require(market.totalLiquidity >= 0 && market.totalLiquidity <= type(uint80).max); // dev: settlement market storage totalLiquidity overflow

        data = (bytes32(market.totalfCash) |
            (bytes32(market.totalAssetCash) << 80) |
            bytes32(market.data));

        // Don't clear the storage even when all liquidity tokens have been removed because we need to use
        // the oracle rates to initialize the next set of markets.
        assembly {
            sstore(slot, data)
        }

        slot = bytes32(uint256(slot) + 1);
        bytes32 totalLiquidity = bytes32(market.totalLiquidity);
        assembly {
            sstore(slot, totalLiquidity)
        }
    }

    /// Uses Newton's method to converge on an fCash amount given the amount of
    /// cash. The relation between cash and fcash is:
    /// cashAmount * exchangeRate * fee + fCash = 0
    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor
    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)
    ///       if cashAmount < 0: fee = feeRate ^ -1
    ///       if cashAmount > 0: fee = feeRate
    ///
    /// Newton's method is:
    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)
    ///
    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash
    ///
    ///                                    (totalfCash + totalCash)
    /// exchangeRate'(fCash) = -  ------------------------------------------
    ///                           (totalfCash - fCash) * (totalCash + fCash)
    ///
    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29
    ///
    ///                     (cashAmount * fee) * (totalfCash + totalCash)
    /// f'(fCash) = 1 - ------------------------------------------------------
    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)
    ///
    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.
    function getfCashGivenCashAmount(
        int256 totalfCash,
        int256 netCashToAccount,
        int256 totalCashUnderlying,
        int256 rateScalar,
        int256 rateAnchor,
        int256 feeRate,
        uint256 maxDelta
    ) internal pure returns (int256) {
        int256 fCashChangeToAccountGuess =
            netCashToAccount.mul(rateAnchor).div(Constants.RATE_PRECISION).neg();
        for (uint8 i; i < 250; i++) {
            (int256 exchangeRate, bool success) =
                _getExchangeRate(
                    totalfCash,
                    totalCashUnderlying,
                    rateScalar,
                    rateAnchor,
                    fCashChangeToAccountGuess
                );

            require(success); // dev: invalid exchange rate
            int256 delta =
                _calculateDelta(
                    netCashToAccount,
                    totalfCash,
                    totalCashUnderlying,
                    rateScalar,
                    fCashChangeToAccountGuess,
                    exchangeRate,
                    feeRate
                );

            if (delta.abs() <= int256(maxDelta)) return fCashChangeToAccountGuess;
            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);
        }

        revert(""No convergence"");
    }

    /// @dev Calculates: f(fCash) / f'(fCash)
    /// f(fCash) = cashAmount * exchangeRate * fee + fCash
    ///                     (cashAmount * fee) * (totalfCash + totalCash)
    /// f'(fCash) = 1 - ------------------------------------------------------
    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)
    function _calculateDelta(
        int256 cashAmount,
        int256 totalfCash,
        int256 totalCashUnderlying,
        int256 rateScalar,
        int256 fCashGuess,
        int256 exchangeRate,
        int256 feeRate
    ) private pure returns (int256) {
        int256 derivative;
        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)
        // Precision: TOKEN_PRECISION ^ 2
        int256 denominator =
            rateScalar.mulInRatePrecision(
                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))
            );

        if (fCashGuess > 0) {
            // Lending
            exchangeRate = exchangeRate.divInRatePrecision(feeRate);
            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow

            // (cashAmount / fee) * (totalfCash + totalCash)
            // Precision: TOKEN_PRECISION ^ 2
            derivative = cashAmount
                .mul(totalfCash.add(totalCashUnderlying))
                .divInRatePrecision(feeRate);
        } else {
            // Borrowing
            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);
            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow

            // (cashAmount * fee) * (totalfCash + totalCash)
            // Precision: TOKEN_PRECISION ^ 2
            derivative = cashAmount.mulInRatePrecision(
                feeRate.mul(totalfCash.add(totalCashUnderlying))
            );
        }
        // 1 - numerator / denominator
        // Precision: TOKEN_PRECISION
        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));

        // f(fCash) = cashAmount * exchangeRate * fee + fCash
        // NOTE: exchangeRate at this point already has the fee taken into account
        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);
        numerator = numerator.add(fCashGuess);

        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION
        // here instead of RATE_PRECISION
        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);
    }
}",8137
RealWorld_TA_23_StorageSlot_RealWorld_20240803030001.log,23,StorageSlot,65581,1172,66753,85.0,0.351345,"// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev Library for reading and writing primitive types to specific storage slots.
 *
 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
 * This library helps with reading and writing to such slots without the need for inline assembly.
 *
 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
 *
 * Example usage to set ERC1967 implementation slot:
 * ```
 * contract ERC1967 {
 *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
 *
 *     function _getImplementation() internal view returns (address) {
 *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
 *     }
 *
 *     function _setImplementation(address newImplementation) internal {
 *         require(Address.isContract(newImplementation), ""ERC1967: new implementation is not a contract"");
 *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
 *     }
 * }
 * ```
 *
 * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
 */
library StorageSlot {
    struct AddressSlot {
        address value;
    }

    struct BooleanSlot {
        bool value;
    }

    struct Bytes32Slot {
        bytes32 value;
    }

    struct Uint256Slot {
        uint256 value;
    }

    /**
     * @dev Returns an `AddressSlot` with member `value` located at `slot`.
     */
    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
        assembly {
            r.slot := slot
        }
    }

    /**
     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
     */
    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
        assembly {
            r.slot := slot
        }
    }

    /**
     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
     */
    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
        assembly {
            r.slot := slot
        }
    }

    /**
     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
     */
    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
        assembly {
            r.slot := slot
        }
    }
}",560
RealWorld_TA_23_MockBitmapAssetsHandler_RealWorld_20240803020111.log,23,MockBitmapAssetsHandler,100389,3322,103711,118.0,0.568385,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/markets/Market.sol"";
import ""../internal/portfolio/BitmapAssetsHandler.sol"";
import ""../internal/markets/AssetRate.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockBitmapAssetsHandler is StorageLayoutV1 {
    using Market for MarketParameters;

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setCashGroup(uint256 id, CashGroupSettings calldata cg) external {
        CashGroup.setCashGroupStorage(id, cg);
    }

    function buildCashGroupView(uint256 currencyId)
        public
        view
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupView(currencyId);
    }

    function setMarketStorage(
        uint256 currencyId,
        uint256 settlementDate,
        MarketParameters memory market
    ) public {
        market.storageSlot = Market.getSlot(currencyId, settlementDate, market.maturity);
        // ensure that state gets set
        market.storageState = 0xFF;
        market.setMarketStorage();
    }

    function getifCashAsset(
        address account,
        uint256 currencyId,
        uint256 maturity
    ) public view returns (int256) {
        bytes32 slot = BitmapAssetsHandler.getifCashSlot(account, currencyId, maturity);
        int256 notional;
        assembly {
            notional := sload(slot)
        }
        return notional;
    }

    function getAssetsBitmap(address account, uint256 currencyId) public view returns (bytes32) {
        return BitmapAssetsHandler.getAssetsBitmap(account, currencyId);
    }

    function setAssetsBitmap(
        address account,
        uint256 currencyId,
        bytes32 assetsBitmap
    ) public {
        return BitmapAssetsHandler.setAssetsBitmap(account, currencyId, assetsBitmap);
    }

    function addifCashAsset(
        address account,
        uint256 currencyId,
        uint256 maturity,
        uint256 nextSettleTime,
        int256 notional,
        bytes32 assetsBitmap
    ) public returns (bytes32, int256) {
        return
            BitmapAssetsHandler.addifCashAsset(
                account,
                currencyId,
                maturity,
                nextSettleTime,
                notional,
                assetsBitmap
            );
    }

    function getifCashNetPresentValue(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime,
        uint256 blockTime,
        bytes32 assetsBitmap,
        CashGroupParameters memory cashGroup,
        bool riskAdjusted
    ) public view returns (int256, bool) {
        return
            BitmapAssetsHandler.getifCashNetPresentValue(
                account,
                currencyId,
                nextSettleTime,
                blockTime,
                assetsBitmap,
                cashGroup,
                riskAdjusted
            );
    }

    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)
        public
        pure
        returns (uint256)
    {
        return DateTime.getMaturityFromBitNum(blockTime, bitNum);
    }

    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        public
        pure
        returns (uint256, bool)
    {
        return DateTime.getBitNumFromMaturity(blockTime, maturity);
    }

    function getPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime
    ) public view returns (int256) {
        uint256 oracleRate = CashGroup.calculateOracleRate(cashGroup, maturity, blockTime);

        return AssetHandler.getPresentValue(notional, maturity, blockTime, oracleRate);
    }

    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime
    ) public view returns (int256) {
        uint256 oracleRate = CashGroup.calculateOracleRate(cashGroup, maturity, blockTime);

        return
            AssetHandler.getRiskAdjustedPresentValue(
                cashGroup,
                notional,
                maturity,
                blockTime,
                oracleRate
            );
    }

    function getifCashArray(
        address account,
        uint256 currencyId,
        uint256 nextSettleTime
    ) external view returns (PortfolioAsset[] memory) {
        return BitmapAssetsHandler.getifCashArray(account, currencyId, nextSettleTime);
    }
}",958
RealWorld_TA_23_Incentives_RealWorld_20240803041357.log,23,Incentives,88716,3256,91972,363.0,0.5087,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./TokenHandler.sol"";
import ""../nTokenHandler.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library Incentives {
    using SafeMath for uint256;

    /// @dev Notional incentivizes nTokens using the formula:
    ///     incentivesToClaim = (tokenBalance / totalSupply) * emissionRatePerYear * proRataYears
    ///     where proRataYears is:
    ///         (timeSinceLastClaim / YEAR) * INTERNAL_TOKEN_PRECISION
    /// @return (emissionRatePerYear * proRataYears), decimal basis is (1e8 * 1e8 = 1e16)
    function _getIncentiveRate(uint256 timeSinceLastClaim, uint256 emissionRatePerYear)
        private
        pure
        returns (uint256)
    {
        // (timeSinceLastClaim * INTERNAL_TOKEN_PRECISION) / YEAR
        uint256 proRataYears =
            timeSinceLastClaim.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION)).div(Constants.YEAR);

        return proRataYears.mul(emissionRatePerYear);
    }

    /// @notice Calculates the claimable incentives for a particular nToken and account
    function calculateIncentivesToClaim(
        address tokenAddress,
        uint256 nTokenBalance,
        uint256 lastClaimTime,
        uint256 lastClaimIntegralSupply,
        uint256 blockTime,
        uint256 integralTotalSupply
    ) internal view returns (uint256) {
        if (lastClaimTime == 0 || lastClaimTime >= blockTime) return 0;

        // prettier-ignore
        (
            /* currencyId */,
            uint256 emissionRatePerYear,
            /* initializedTime */,
            /* parameters */
        ) = nTokenHandler.getNTokenContext(tokenAddress);

        // No overflow here, checked above
        uint256 timeSinceLastClaim = blockTime - lastClaimTime;
        uint256 incentiveRate =
            _getIncentiveRate(
                timeSinceLastClaim,
                // Convert this to the appropriate denomination
                emissionRatePerYear.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))
            );

        // Returns the average supply between now and the previous mint time using the integral of the total
        // supply.
        uint256 avgTotalSupply = integralTotalSupply.sub(lastClaimIntegralSupply).div(timeSinceLastClaim);
        if (avgTotalSupply == 0) return 0;

        uint256 incentivesToClaim = nTokenBalance.mul(incentiveRate).div(avgTotalSupply);
        // incentiveRate has a decimal basis of 1e16 so divide by token precision to reduce to 1e8
        incentivesToClaim = incentivesToClaim.div(uint256(Constants.INTERNAL_TOKEN_PRECISION));

        return incentivesToClaim;
    }

    /// @notice Incentives must be claimed every time nToken balance changes
    function claimIncentives(BalanceState memory balanceState, address account)
        internal
        returns (uint256)
    {
        uint256 blockTime = block.timestamp;
        address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);
        uint256 integralTotalSupply = nTokenHandler.changeNTokenSupply(
            tokenAddress,
            balanceState.netNTokenSupplyChange,
            blockTime
        );

        uint256 incentivesToClaim = calculateIncentivesToClaim(
            tokenAddress,
            uint256(balanceState.storedNTokenBalance),
            balanceState.lastClaimTime,
            balanceState.lastClaimIntegralSupply,
            blockTime,
            integralTotalSupply
        );

        balanceState.lastClaimTime = blockTime;
        balanceState.lastClaimIntegralSupply = integralTotalSupply;

        if (incentivesToClaim > 0) TokenHandler.transferIncentive(account, incentivesToClaim);

        return incentivesToClaim;
    }
}",815
RealWorld_TA_23_nProxy_RealWorld_20240803025824.log,23,nProxy,26327,1912,28239,95.0,0.169875,"// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

import ""./ERC1967/ERC1967Proxy.sol"";

contract nProxy is ERC1967Proxy {
    constructor(
        address _logic,
        bytes memory _data
    ) ERC1967Proxy(_logic, _data) {}

    receive() external payable override {}

    function getImplementation() external view returns (address) {
        return _getImplementation();
    }
}",92
RealWorld_TA_23_nTokenMintAction_RealWorld_20240803064232.log,23,nTokenMintAction,243791,5572,249363,363.0,1.330395,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Constants.sol"";
import ""../../internal/nTokenHandler.sol"";
import ""../../internal/markets/Market.sol"";
import ""../../internal/markets/CashGroup.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/portfolio/PortfolioHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library nTokenMintAction {
    using SafeInt256 for int256;
    using BalanceHandler for BalanceState;
    using CashGroup for CashGroupParameters;
    using Market for MarketParameters;
    using nTokenHandler for nTokenPortfolio;
    using PortfolioHandler for PortfolioState;
    using AssetRate for AssetRateParameters;
    using SafeMath for uint256;

    /// @notice Converts the given amount of cash to nTokens in the same currency.
    /// @param currencyId the currency associated the nToken
    /// @param amountToDepositInternal the amount of asset tokens to deposit denominated in internal decimals
    /// @return nTokens minted by this action
    function nTokenMint(uint256 currencyId, int256 amountToDepositInternal)
        external
        returns (int256)
    {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioStateful(currencyId, nToken);

        (int256 tokensToMint, bytes32 ifCashBitmap) =
            calculateTokensToMint(nToken, amountToDepositInternal, blockTime);

        if (nToken.portfolioState.storedAssets.length == 0) {
            // If the token does not have any assets, then the markets must be initialized first.
            nToken.cashBalance = nToken.cashBalance.add(amountToDepositInternal);
            BalanceHandler.setBalanceStorageForNToken(
                nToken.tokenAddress,
                currencyId,
                nToken.cashBalance
            );
        } else {
            _depositIntoPortfolio(nToken, ifCashBitmap, amountToDepositInternal, blockTime);
        }

        require(tokensToMint >= 0, ""Invalid token amount"");

        // NOTE: token supply does not change here, it will change after incentives have been claimed
        // during BalanceHandler.finalize
        return tokensToMint;
    }

    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken
    /// present value denominated in asset cash terms.
    function calculateTokensToMint(
        nTokenPortfolio memory nToken,
        int256 amountToDepositInternal,
        uint256 blockTime
    ) internal view returns (int256, bytes32) {
        require(amountToDepositInternal >= 0); // dev: deposit amount negative
        if (amountToDepositInternal == 0) return (0, 0x0);

        if (nToken.lastInitializedTime != 0) {
            // For the sake of simplicity, nTokens cannot be minted if they have assets
            // that need to be settled. This is only done during market initialization.
            uint256 nextSettleTime = nToken.getNextSettleTime();
            require(nextSettleTime > blockTime, ""PT: requires settlement"");
        }

        (int256 assetCashPV, bytes32 ifCashBitmap) = nToken.getNTokenAssetPV(blockTime);
        require(assetCashPV >= 0, ""PT: pv value negative"");

        // Allow for the first deposit
        if (nToken.totalSupply == 0) {
            return (amountToDepositInternal, ifCashBitmap);
        }

        return (amountToDepositInternal.mul(nToken.totalSupply).div(assetCashPV), ifCashBitmap);
    }

    /// @notice Portions out assetCashDeposit into amounts to deposit into individual markets. When
    /// entering this method we know that assetCashDeposit is positive and the nToken has been
    /// initialized to have liquidity tokens.
    function _depositIntoPortfolio(
        nTokenPortfolio memory nToken,
        bytes32 ifCashBitmap,
        int256 assetCashDeposit,
        uint256 blockTime
    ) private {
        (int256[] memory depositShares, int256[] memory leverageThresholds) =
            nTokenHandler.getDepositParameters(
                nToken.cashGroup.currencyId,
                nToken.cashGroup.maxMarketIndex
            );

        // Loop backwards from the last market to the first market, the reasoning is a little complicated:
        // If we have to deleverage the markets (i.e. lend instead of provide liquidity) it's quite gas inefficient
        // to calculate the cash amount to lend. We do know that longer term maturities will have more
        // slippage and therefore the residual from the perMarketDeposit will be lower as the maturities get
        // closer to the current block time. Any residual cash from lending will be rolled into shorter
        // markets as this loop progresses.
        int256 residualCash;
        MarketParameters memory market;
        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) {
            int256 fCashAmount;
            nToken.cashGroup.loadMarket(
                market,
                marketIndex,
                true, // Needs liquidity to true
                blockTime
            );
            // If market has not been initialized, continue. This can occur when cash groups extend maxMarketIndex
            // before initializing
            if (market.totalLiquidity == 0) continue;

            // We know from the call into this method that assetCashDeposit is positive
            int256 perMarketDeposit =
                assetCashDeposit.mul(depositShares[marketIndex - 1]).div(Constants.DEPOSIT_PERCENT_BASIS).add(
                    residualCash
                );

            (fCashAmount, residualCash) = _lendOrAddLiquidity(
                nToken,
                market,
                perMarketDeposit,
                leverageThresholds[marketIndex - 1],
                marketIndex,
                blockTime
            );

            if (fCashAmount != 0) {
                // prettier-ignore
                (
                    ifCashBitmap,
                    /* notional */
                ) = BitmapAssetsHandler.addifCashAsset(
                    nToken.tokenAddress,
                    nToken.cashGroup.currencyId,
                    market.maturity,
                    nToken.lastInitializedTime,
                    fCashAmount,
                    ifCashBitmap
                );
            }

            market.setMarketStorage();
        }

        BitmapAssetsHandler.setAssetsBitmap(
            nToken.tokenAddress,
            nToken.cashGroup.currencyId,
            ifCashBitmap
        );
        nToken.portfolioState.storeAssets(nToken.tokenAddress);

        // This will occur if the three month market is over levered and we cannot lend into it
        if (residualCash != 0) {
            // Any remaining residual cash will be put into the nToken balance and added as liquidity on the
            // next market initialization
            nToken.cashBalance = nToken.cashBalance.add(residualCash);
            BalanceHandler.setBalanceStorageForNToken(
                nToken.tokenAddress,
                nToken.cashGroup.currencyId,
                nToken.cashBalance
            );
        }
    }

    /// @notice For a given amount of cash to deposit, decides how much to lend or provide
    /// given the market conditions.
    function _lendOrAddLiquidity(
        nTokenPortfolio memory nToken,
        MarketParameters memory market,
        int256 perMarketDeposit,
        int256 leverageThreshold,
        uint256 marketIndex,
        uint256 blockTime
    ) private returns (int256, int256) {
        int256 fCashAmount;
        bool marketOverLeveraged =
            _isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold);

        if (marketOverLeveraged) {
            (perMarketDeposit, fCashAmount) = _deleverageMarket(
                nToken.cashGroup,
                market,
                perMarketDeposit,
                blockTime,
                marketIndex
            );

            // Recalculate this after lending into the market
            marketOverLeveraged = _isMarketOverLeveraged(
                nToken.cashGroup,
                market,
                leverageThreshold
            );
        }

        if (!marketOverLeveraged) {
            // (marketIndex - 1) is the index of the nToken portfolio array where the asset
            // is stored
            fCashAmount = fCashAmount.add(
                _addLiquidityToMarket(nToken, market, marketIndex - 1, perMarketDeposit)
            );
            // No residual cash if we're adding liquidity
            return (fCashAmount, 0);
        }

        return (fCashAmount, perMarketDeposit);
    }

    /// @notice Markets are over levered when their proportion is greater than a governance set
    /// threshold. At this point, providing liquidity will incur too much negative fCash on the nToken
    /// account for the given amount of cash deposited, putting the nToken account at risk of liquidation.
    /// If the market is over leveraged, we call `deleverageMarket` to lend to the market instead.
    function _isMarketOverLeveraged(
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        int256 leverageThreshold
    ) private pure returns (bool) {
        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);
        int256 proportion =
            market.totalfCash.divInRatePrecision(market.totalfCash.add(totalCashUnderlying));

        // If proportion is over the threshold, the market is over leveraged
        return proportion > leverageThreshold;
    }

    function _addLiquidityToMarket(
        nTokenPortfolio memory nToken,
        MarketParameters memory market,
        uint256 index,
        int256 perMarketDeposit
    ) private pure returns (int256) {
        // Add liquidity to the market
        PortfolioAsset memory asset = nToken.portfolioState.storedAssets[index];
        // We expect that all the liquidity tokens are in the portfolio in order.
        require(
            asset.maturity == market.maturity &&
                // Ensures that the asset type references the proper liquidity token
                asset.assetType == index + Constants.MIN_LIQUIDITY_TOKEN_INDEX,
            ""PT: invalid liquidity token""
        );

        // This will update the market state as well, fCashAmount returned here is negative
        (int256 liquidityTokens, int256 fCashAmount) = market.addLiquidity(perMarketDeposit);
        asset.notional = asset.notional.add(liquidityTokens);
        asset.storageState = AssetStorageState.Update;

        return fCashAmount;
    }

    /// @notice Lends into the market to reduce the leverage that the nToken will add liquidity at. May fail due
    /// to slippage or result in some amount of residual cash.
    function _deleverageMarket(
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        int256 perMarketDeposit,
        uint256 blockTime,
        uint256 marketIndex
    ) private returns (int256, int256) {
        uint256 timeToMaturity = market.maturity.sub(blockTime);

        // Shift the last implied rate by some buffer and calculate the exchange rate to fCash. Hope that this
        // is sufficient to cover all potential slippage. We don't use the `getfCashGivenCashAmount` method here
        // because it is very gas inefficient.
        int256 assumedExchangeRate;
        if (market.lastImpliedRate < Constants.DELEVERAGE_BUFFER) {
            assumedExchangeRate = Constants.RATE_PRECISION;
        } else {
            assumedExchangeRate = Market.getExchangeRateFromImpliedRate(
                market.lastImpliedRate.sub(Constants.DELEVERAGE_BUFFER),
                timeToMaturity
            );
        }

        int256 fCashAmount;
        {
            int256 perMarketDepositUnderlying =
                cashGroup.assetRate.convertToUnderlying(perMarketDeposit);
            fCashAmount = perMarketDepositUnderlying.mulInRatePrecision(assumedExchangeRate);
        }
        (int256 netAssetCash, int256 fee) =
            market.calculateTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);
        BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, fee);

        // This means that the trade failed
        if (netAssetCash == 0) return (perMarketDeposit, 0);

        // Ensure that net the per market deposit figure does not drop below zero, this should not be possible
        // given how we've calculated the exchange rate but extra caution here
        int256 residual = perMarketDeposit.add(netAssetCash);
        require(residual >= 0); // dev: insufficient cash
        return (residual, fCashAmount);
    }
}",2718
RealWorld_TA_23_INoteERC20_RealWorld_20240803082125.log,23,INoteERC20,22558,1404,23962,374.0,0.14087,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;

interface INoteERC20 {
    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);
}",48
RealWorld_TA_23_TradingAction_RealWorld_20240803070709.log,23,TradingAction,379883,5642,385525,382.0,2.012255,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../FreeCollateralExternal.sol"";
import ""../SettleAssetsExternal.sol"";
import ""../../internal/markets/Market.sol"";
import ""../../internal/markets/CashGroup.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/portfolio/PortfolioHandler.sol"";
import ""../../internal/portfolio/TransferAssets.sol"";
import ""../../math/SafeInt256.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library TradingAction {
    using PortfolioHandler for PortfolioState;
    using AccountContextHandler for AccountContext;
    using Market for MarketParameters;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;
    using SafeInt256 for int256;
    using SafeMath for uint256;

    event LendBorrowTrade(
        address account,
        uint16 currencyId,
        uint40 maturity,
        int256 netAssetCash,
        int256 netfCash,
        int256 netFee
    );
    event AddRemoveLiquidity(
        address account,
        uint16 currencyId,
        uint40 maturity,
        int256 netAssetCash,
        int256 netfCash,
        int256 netLiquidityTokens
    );

    event SettledCashDebt(
        address settledAccount,
        uint16 currencyId,
        int256 amountToSettleAsset,
        int256 fCashAmount
    );

    event nTokenResidualPurchase(
        uint16 currencyId,
        uint40 maturity,
        int256 fCashAmountToPurchase,
        int256 netAssetCashNToken
    );

    /// @dev Used internally to manage stack issues
    struct TradeContext {
        int256 cash;
        int256 fCashAmount;
        int256 fee;
        int256 netCash;
        int256 totalFee;
        uint256 blockTime;
    }

    /// @dev Executes trades for a bitmapped portfolio
    function executeTradesBitmapBatch(
        address account,
        AccountContext calldata accountContext,
        bytes32[] calldata trades
    ) external returns (int256, bool) {
        CashGroupParameters memory cashGroup =
            CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);
        MarketParameters memory market;
        bytes32 ifCashBitmap =
            BitmapAssetsHandler.getAssetsBitmap(account, accountContext.bitmapCurrencyId);
        bool didIncurDebt;
        TradeContext memory c;
        c.blockTime = block.timestamp;

        for (uint256 i; i < trades.length; i++) {
            uint256 maturity;
            (maturity, c.cash, c.fCashAmount, c.fee) = _executeTrade(
                account,
                cashGroup,
                market,
                trades[i],
                c.blockTime
            );

            (ifCashBitmap, c.fCashAmount) = BitmapAssetsHandler.addifCashAsset(
                account,
                accountContext.bitmapCurrencyId,
                maturity,
                accountContext.nextSettleTime,
                c.fCashAmount,
                ifCashBitmap
            );

            if (c.fCashAmount < 0) didIncurDebt = true;
            c.netCash = c.netCash.add(c.cash);
            c.totalFee = c.totalFee.add(c.fee);
        }

        BitmapAssetsHandler.setAssetsBitmap(account, accountContext.bitmapCurrencyId, ifCashBitmap);
        BalanceHandler.incrementFeeToReserve(accountContext.bitmapCurrencyId, c.totalFee);

        return (c.netCash, didIncurDebt);
    }

    /// @dev Executes trades for an array portfolio
    function executeTradesArrayBatch(
        address account,
        uint256 currencyId,
        PortfolioState memory portfolioState,
        bytes32[] calldata trades
    ) external returns (PortfolioState memory, int256) {
        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(currencyId);
        MarketParameters memory market;
        TradeContext memory c;
        c.blockTime = block.timestamp;

        for (uint256 i; i < trades.length; i++) {
            TradeActionType tradeType = TradeActionType(uint256(uint8(bytes1(trades[i]))));

            if (
                tradeType == TradeActionType.AddLiquidity ||
                tradeType == TradeActionType.RemoveLiquidity
            ) {
                // Liquidity tokens can only be added by array portfolio
                c.cash = _executeLiquidityTrade(
                    account,
                    cashGroup,
                    market,
                    tradeType,
                    trades[i],
                    portfolioState,
                    c.netCash
                );
            } else {
                uint256 maturity;
                (maturity, c.cash, c.fCashAmount, c.fee) = _executeTrade(
                    account,
                    cashGroup,
                    market,
                    trades[i],
                    c.blockTime
                );
                // Stack issues here :(
                _addfCashAsset(portfolioState, currencyId, maturity, c.fCashAmount);
                c.totalFee = c.totalFee.add(c.fee);
            }

            c.netCash = c.netCash.add(c.cash);
        }

        BalanceHandler.incrementFeeToReserve(currencyId, c.totalFee);

        return (portfolioState, c.netCash);
    }

    /// @dev used to clear the stack
    function _addfCashAsset(
        PortfolioState memory portfolioState,
        uint256 currencyId,
        uint256 maturity,
        int256 notional
    ) private pure {
        portfolioState.addAsset(currencyId, maturity, Constants.FCASH_ASSET_TYPE, notional);
    }

    function _executeTrade(
        address account,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        bytes32 trade,
        uint256 blockTime
    )
        private
        returns (
            uint256 maturity,
            int256 cashAmount,
            int256 fCashAmount,
            int256 fee
        )
    {
        TradeActionType tradeType = TradeActionType(uint256(uint8(bytes1(trade))));
        if (tradeType == TradeActionType.PurchaseNTokenResidual) {
            (maturity, cashAmount, fCashAmount) = _purchaseNTokenResidual(
                cashGroup,
                blockTime,
                trade
            );
        } else if (tradeType == TradeActionType.SettleCashDebt) {
            (maturity, cashAmount, fCashAmount) = _settleCashDebt(cashGroup, blockTime, trade);
        } else if (tradeType == TradeActionType.Lend || tradeType == TradeActionType.Borrow) {
            (cashAmount, fCashAmount, fee) = _executeLendBorrowTrade(
                cashGroup,
                market,
                tradeType,
                blockTime,
                trade
            );

            // This is a little ugly but required to deal with stack issues. We know the market is loaded with the proper
            // maturity inside _executeLendBorrowTrade
            maturity = market.maturity;
            emit LendBorrowTrade(
                account,
                uint16(cashGroup.currencyId),
                uint40(maturity),
                cashAmount,
                fCashAmount,
                fee
            );
        } else {
            revert(""Invalid trade type"");
        }
    }

    function _executeLiquidityTrade(
        address account,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        TradeActionType tradeType,
        bytes32 trade,
        PortfolioState memory portfolioState,
        int256 netCash
    ) private returns (int256) {
        uint256 marketIndex = uint256(uint8(bytes1(trade << 8)));
        cashGroup.loadMarket(market, marketIndex, true, block.timestamp);

        int256 cashAmount;
        int256 fCashAmount;
        int256 tokens;
        if (tradeType == TradeActionType.AddLiquidity) {
            cashAmount = int256(uint88(bytes11(trade << 16)));
            // Setting cash amount to zero will deposit all net cash accumulated in this trade into
            // liquidity. This feature allows accounts to borrow in one maturity to provide liquidity
            // in another in a single transaction without dust. It also allows liquidity providers to
            // sell off the net cash residuals and use the cash amount in the new market without dust
            if (cashAmount == 0) {
                cashAmount = netCash;
                require(cashAmount > 0, ""Invalid cash roll"");
            }

            (tokens, fCashAmount) = market.addLiquidity(cashAmount);
            cashAmount = cashAmount.neg(); // Net cash is negative
        } else {
            tokens = int256(uint88(bytes11(trade << 16)));
            (cashAmount, fCashAmount) = market.removeLiquidity(tokens);
            tokens = tokens.neg();
        }

        {
            uint256 minImpliedRate = uint256(uint32(bytes4(trade << 104)));
            uint256 maxImpliedRate = uint256(uint32(bytes4(trade << 136)));
            require(market.lastImpliedRate >= minImpliedRate, ""Trade failed, slippage"");
            if (maxImpliedRate != 0)
                require(market.lastImpliedRate <= maxImpliedRate, ""Trade failed, slippage"");
            market.setMarketStorage();
        }

        // Add the assets in this order so they are sorted
        portfolioState.addAsset(
            cashGroup.currencyId,
            market.maturity,
            Constants.FCASH_ASSET_TYPE,
            fCashAmount
        );
        portfolioState.addAsset(
            cashGroup.currencyId,
            market.maturity,
            marketIndex + 1,
            tokens
        );

        emit AddRemoveLiquidity(
            account,
            uint16(cashGroup.currencyId),
            uint40(market.maturity),
            cashAmount,
            fCashAmount,
            tokens
        );

        return (cashAmount);
    }

    function _executeLendBorrowTrade(
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        TradeActionType tradeType,
        uint256 blockTime,
        bytes32 trade
    )
        private
        returns (
            int256,
            int256,
            int256
        )
    {
        uint256 marketIndex = uint256(uint8(bytes1(trade << 8)));
        cashGroup.loadMarket(market, marketIndex, false, blockTime);

        int256 fCashAmount = int256(uint88(bytes11(trade << 16)));
        if (tradeType == TradeActionType.Borrow) fCashAmount = fCashAmount.neg();

        (int256 cashAmount, int256 fee) =
            market.calculateTrade(
                cashGroup,
                fCashAmount,
                market.maturity.sub(blockTime),
                marketIndex
            );
        require(cashAmount != 0, ""Trade failed, liquidity"");

        uint256 rateLimit = uint256(uint32(bytes4(trade << 104)));
        if (rateLimit != 0) {
            if (tradeType == TradeActionType.Borrow) {
                require(market.lastImpliedRate <= rateLimit, ""Trade failed, slippage"");
            } else {
                require(market.lastImpliedRate >= rateLimit, ""Trade failed, slippage"");
            }
        }
        market.setMarketStorage();

        return (cashAmount, fCashAmount, fee);
    }

    /// @notice If an account has a negative cash balance we allow anyone to lend to to that account at a penalty
    /// rate to the 3 month market.
    function _settleCashDebt(
        CashGroupParameters memory cashGroup,
        uint256 blockTime,
        bytes32 trade
    )
        internal
        returns (
            uint256,
            int256,
            int256
        )
    {
        address counterparty = address(bytes20(trade << 8));
        int256 amountToSettleAsset = int256(int88(bytes11(trade << 168)));

        AccountContext memory counterpartyContext =
            AccountContextHandler.getAccountContext(counterparty);

        if (counterpartyContext.mustSettleAssets()) {
            counterpartyContext = SettleAssetsExternal.settleAssetsAndFinalize(counterparty, counterpartyContext);
        }

        // This will check if the amountToSettleAsset is valid and revert if it is not. Amount to settle is a positive
        // number denominated in asset terms. If amountToSettleAsset is set equal to zero on the input, will return the
        // max amount to settle.
        amountToSettleAsset = BalanceHandler.setBalanceStorageForSettleCashDebt(
            counterparty,
            cashGroup,
            amountToSettleAsset,
            counterpartyContext
        );

        // Settled account must borrow from the 3 month market at a penalty rate. Even if the market is
        // not initialized we can still settle cash debts because we reference the previous 3 month market's oracle
        // rate which is where the new 3 month market's oracle rate will be initialized to.
        uint256 threeMonthMaturity = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;
        int256 fCashAmount =
            _getfCashSettleAmount(cashGroup, threeMonthMaturity, blockTime, amountToSettleAsset);

        // It's possible that this action will put an account into negative free collateral. In this case they
        // will immediately become eligible for liquidation and the account settling the debt can also liquidate
        // them in the same transaction. Do not run a free collateral check here to allow this to happen.
        {
            PortfolioAsset[] memory assets = new PortfolioAsset[](1);
            assets[0].currencyId = cashGroup.currencyId;
            assets[0].maturity = threeMonthMaturity;
            assets[0].notional = fCashAmount.neg(); // This is the debt the settled account will incur
            assets[0].assetType = Constants.FCASH_ASSET_TYPE;
            counterpartyContext = TransferAssets.placeAssetsInAccount(
                counterparty,
                counterpartyContext,
                assets
            );
        }
        counterpartyContext.setAccountContext(counterparty);

        emit SettledCashDebt(
            counterparty,
            uint16(cashGroup.currencyId),
            amountToSettleAsset,
            fCashAmount.neg()
        );

        return (threeMonthMaturity, amountToSettleAsset.neg(), fCashAmount);
    }

    /// @dev Helper method to calculate the fCashAmount from the penalty settlement rate
    function _getfCashSettleAmount(
        CashGroupParameters memory cashGroup,
        uint256 threeMonthMaturity,
        uint256 blockTime,
        int256 amountToSettleAsset
    ) private view returns (int256) {
        uint256 oracleRate = cashGroup.calculateOracleRate(threeMonthMaturity, blockTime);

        int256 exchangeRate =
            Market.getExchangeRateFromImpliedRate(
                oracleRate.add(cashGroup.getSettlementPenalty()),
                threeMonthMaturity.sub(blockTime)
            );

        // Amount to settle is positive, this returns the fCashAmount that the settler will
        // receive as a positive number
        return
            cashGroup.assetRate.convertToUnderlying(amountToSettleAsset).mul(exchangeRate).div(
                Constants.RATE_PRECISION
            );
    }

    /// @dev Enables purchasing of NToken residuals
    function _purchaseNTokenResidual(
        CashGroupParameters memory cashGroup,
        uint256 blockTime,
        bytes32 trade
    )
        internal
        returns (
            uint256,
            int256,
            int256
        )
    {
        uint256 maturity = uint256(uint32(bytes4(trade << 8)));
        int256 fCashAmountToPurchase = int256(int88(bytes11(trade << 40)));
        require(maturity > blockTime, ""Invalid maturity"");
        // Require that the residual to purchase does not fall on an existing maturity (i.e.
        // it is an idiosyncratic maturity)
        require(
            !DateTime.isValidMarketMaturity(cashGroup.maxMarketIndex, maturity, blockTime),
            ""Invalid maturity""
        );

        address nTokenAddress = nTokenHandler.nTokenAddress(cashGroup.currencyId);
        // prettier-ignore
        (
            /* currencyId */,
            /* incentiveRate */,
            uint256 lastInitializedTime,
            bytes6 parameters
        ) = nTokenHandler.getNTokenContext(nTokenAddress);

        // Restrict purchasing until some amount of time after the last initialized time to ensure that arbitrage
        // opportunities are not available (by generating residuals and then immediately purchasing them at a discount)
        require(
            blockTime >
                lastInitializedTime.add(
                    uint256(uint8(parameters[Constants.RESIDUAL_PURCHASE_TIME_BUFFER])) * 3600
                ),
            ""Insufficient block time""
        );

        int256 notional =
            BitmapAssetsHandler.getifCashNotional(nTokenAddress, cashGroup.currencyId, maturity);
        // Check if amounts are valid and set them to the max available if necessary
        if (notional < 0 && fCashAmountToPurchase < 0) {
            if (fCashAmountToPurchase < notional) fCashAmountToPurchase = notional;
        } else if (notional > 0 && fCashAmountToPurchase > 0) {
            if (fCashAmountToPurchase > notional) fCashAmountToPurchase = notional;
        } else {
            revert(""Invalid amount"");
        }

        int256 netAssetCashNToken =
            _getResidualPriceAssetCash(
                cashGroup,
                maturity,
                blockTime,
                fCashAmountToPurchase,
                parameters
            );

        _updateNTokenPortfolio(
            nTokenAddress,
            cashGroup.currencyId,
            maturity,
            lastInitializedTime,
            fCashAmountToPurchase,
            netAssetCashNToken
        );

        emit nTokenResidualPurchase(
            uint16(cashGroup.currencyId),
            uint40(maturity),
            fCashAmountToPurchase,
            netAssetCashNToken
        );

        return (maturity, netAssetCashNToken.neg(), fCashAmountToPurchase);
    }

    function _getResidualPriceAssetCash(
        CashGroupParameters memory cashGroup,
        uint256 maturity,
        uint256 blockTime,
        int256 fCashAmount,
        bytes6 parameters
    ) internal view returns (int256) {
        uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);
        uint256 purchaseIncentive =
            uint256(uint8(parameters[Constants.RESIDUAL_PURCHASE_INCENTIVE])) *
                10 *
                Constants.BASIS_POINT;

        if (fCashAmount > 0) {
            oracleRate = oracleRate.add(purchaseIncentive);
        } else if (oracleRate > purchaseIncentive) {
            oracleRate = oracleRate.sub(purchaseIncentive);
        } else {
            // If the oracle rate is less than the purchase incentive floor the interest rate at zero
            oracleRate = 0;
        }

        int256 exchangeRate =
            Market.getExchangeRateFromImpliedRate(oracleRate, maturity.sub(blockTime));

        // Returns the net asset cash from the nToken perspective, which is the same sign as the fCash amount
        return
            cashGroup.assetRate.convertFromUnderlying(fCashAmount.divInRatePrecision(exchangeRate));
    }

    function _updateNTokenPortfolio(
        address nTokenAddress,
        uint256 currencyId,
        uint256 maturity,
        uint256 lastInitializedTime,
        int256 fCashAmountToPurchase,
        int256 netAssetCashNToken
    ) private {
        bytes32 ifCashBitmap = BitmapAssetsHandler.getAssetsBitmap(nTokenAddress, currencyId);
        // prettier-ignore
        (
            ifCashBitmap,
            /* notional */
        ) = BitmapAssetsHandler.addifCashAsset(
            nTokenAddress,
            currencyId,
            maturity,
            lastInitializedTime,
            fCashAmountToPurchase.neg(),
            ifCashBitmap
        );
        BitmapAssetsHandler.setAssetsBitmap(nTokenAddress, currencyId, ifCashBitmap);

        // prettier-ignore
        (
            int256 nTokenCashBalance,
            /* storedNTokenBalance */,
            /* lastClaimTime */,
            /* lastClaimIntegralSupply */
        ) = BalanceHandler.getBalanceStorage(nTokenAddress, currencyId);
        nTokenCashBalance = nTokenCashBalance.add(netAssetCashNToken);

        // This will ensure that the cash balance is not negative
        BalanceHandler.setBalanceStorageForNToken(nTokenAddress, currencyId, nTokenCashBalance);
    }
}",4332
RealWorld_TA_23_NotionalProxy_RealWorld_20240803080903.log,23,NotionalProxy,136269,2492,138761,367.0,0.731185,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../contracts/global/Types.sol"";
import ""./nTokenERC20.sol"";
import ""./nERC1155Interface.sol"";
import ""./NotionalGovernance.sol"";
import ""./NotionalViews.sol"";

interface NotionalProxy is nTokenERC20, nERC1155Interface, NotionalGovernance, NotionalViews {
    /** User trading events */
    event CashBalanceChange(address indexed account, uint16 currencyId, int256 netCashChange);
    event nTokenSupplyChange(address indexed account, uint16 currencyId, int256 tokenSupplyChange);
    event MarketsInitialized(uint16 currencyId);
    event SweepCashIntoMarkets(uint16 currencyId, int256 cashIntoMarkets);
    event SettledCashDebt(
        address settledAccount,
        uint16 currencyId,
        int256 amountToSettleAsset,
        int256 fCashAmount
    );
    event nTokenResidualPurchase(
        uint16 currencyId,
        uint40 maturity,
        int256 fCashAmountToPurchase,
        int256 netAssetCashNToken
    );
    event LendBorrowTrade(
        address account,
        uint16 currencyId,
        uint40 maturity,
        int256 netAssetCash,
        int256 netfCash,
        int256 netFee
    );
    event AddRemoveLiquidity(
        address account,
        uint16 currencyId,
        uint40 maturity,
        int256 netAssetCash,
        int256 netfCash,
        int256 netLiquidityTokens
    );

    /// @notice Emitted whenever an account context has updated
    event AccountContextUpdate(address indexed account);
    /// @notice Emitted when an account has assets that are settled
    event AccountSettled(address indexed account);
    /// @notice Emitted when an asset rate is settled
    event SetSettlementRate(uint256 currencyId, uint256 maturity, uint128 rate);

    /* Liquidation Events */
    event LiquidateLocalCurrency(
        address indexed liquidated,
        address indexed liquidator,
        uint16 localCurrencyId,
        int256 netLocalFromLiquidator
    );

    event LiquidateCollateralCurrency(
        address indexed liquidated,
        address indexed liquidator,
        uint16 localCurrencyId,
        uint16 collateralCurrencyId,
        int256 netLocalFromLiquidator,
        int256 netCollateralTransfer,
        int256 netNTokenTransfer
    );

    event LiquidatefCashEvent(
        address indexed liquidated,
        uint16 localCurrencyId,
        uint16 fCashCurrency,
        int256 netLocalFromLiquidator,
        uint256[] fCashMaturities,
        int256[] fCashNotionalTransfer
    );

    /** UUPS Upgradeable contract calls */
    function upgradeTo(address newImplementation) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function getImplementation() external view returns (address);
    function owner() external view returns (address);
    function pauseRouter() external view returns (address);
    function pauseGuardian() external view returns (address);

    /** Initialize Markets Action */
    function initializeMarkets(uint256 currencyId, bool isFirstInit) external;

    function sweepCashIntoMarkets(uint16 currencyId) external;

    /** Redeem nToken Action */
    function nTokenRedeem(
        address redeemer,
        uint16 currencyId,
        uint96 tokensToRedeem_,
        bool sellTokenAssets
    ) external returns (int256);

    /** Account Action */
    function enableBitmapCurrency(uint16 currencyId) external;

    function settleAccount(address account) external;

    function depositUnderlyingToken(
        address account,
        uint16 currencyId,
        uint256 amountExternalPrecision
    ) external payable returns (uint256);

    function depositAssetToken(
        address account,
        uint16 currencyId,
        uint256 amountExternalPrecision
    ) external returns (uint256);

    function withdraw(
        uint16 currencyId,
        uint88 amountInternalPrecision,
        bool redeemToUnderlying
    ) external returns (uint256);

    /** Batch Action */
    function batchBalanceAction(address account, BalanceAction[] calldata actions) external payable;

    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions)
        external
        payable;

    function batchBalanceAndTradeActionWithCallback(
        address account,
        BalanceActionWithTrades[] calldata actions,
        bytes calldata callbackData
    ) external payable;

    /** Liquidation Action */
    function calculateLocalCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint96 maxNTokenLiquidation
    ) external returns (int256, int256);

    function liquidateLocalCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint96 maxNTokenLiquidation
    ) external returns (int256, int256);

    function calculateCollateralCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency,
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation
    )
        external
        returns (
            int256,
            int256,
            int256
        );

    function liquidateCollateralCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 collateralCurrency,
        uint128 maxCollateralLiquidation,
        uint96 maxNTokenLiquidation,
        bool withdrawCollateral,
        bool redeemToUnderlying
    )
        external
        returns (
            int256,
            int256,
            int256
        );

    function calculatefCashLocalLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256);

    function liquidatefCashLocal(
        address liquidateAccount,
        uint256 localCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256);

    function calculatefCashCrossCurrencyLiquidation(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256);

    function liquidatefCashCrossCurrency(
        address liquidateAccount,
        uint256 localCurrency,
        uint256 fCashCurrency,
        uint256[] calldata fCashMaturities,
        uint256[] calldata maxfCashLiquidateAmounts
    ) external returns (int256[] memory, int256);
}",1441
RealWorld_TA_23_Proxy_RealWorld_20240803025649.log,23,Proxy,74974,1683,76657,93.0,0.40853,"// SPDX-License-Identifier: MIT

pragma solidity ^0.7.0;

/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */
abstract contract Proxy {
    /**
     * @dev Delegates the current call to `implementation`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _delegate(address implementation) internal virtual {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    /**
     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function
     * and {_fallback} should delegate.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates the current call to the address returned by `_implementation()`.
     *
     * This function does not return to its internall call site, it will return directly to the external caller.
     */
    function _fallback() internal virtual {
        _beforeFallback();
        _delegate(_implementation());
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
     * function in the contract matches the call data.
     */
    fallback() external payable virtual {
        _fallback();
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
     * is empty.
     */
    receive() external payable virtual {
        _fallback();
    }

    /**
     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
     * call, or as part of the Solidity `fallback` or `receive` functions.
     *
     * If overriden should call `super._beforeFallback()`.
     */
    function _beforeFallback() internal virtual {}
}",672
RealWorld_TA_23_FreeCollateral_RealWorld_20240803043838.log,23,FreeCollateral,356415,4444,360859,375.0,1.870955,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./AssetHandler.sol"";
import ""./ExchangeRate.sol"";
import ""../markets/CashGroup.sol"";
import ""../AccountContextHandler.sol"";
import ""../balances/BalanceHandler.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../../math/SafeInt256.sol"";

library FreeCollateral {
    using SafeInt256 for int256;
    using Bitmap for bytes;
    using ExchangeRate for ETHRate;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using nTokenHandler for nTokenPortfolio;

    /// @dev This is only used within the library to clean up the stack
    struct FreeCollateralFactors {
        int256 netETHValue;
        bool updateContext;
        uint256 portfolioIndex;
        CashGroupParameters cashGroup;
        MarketParameters market;
        PortfolioAsset[] portfolio;
        AssetRateParameters assetRate;
        nTokenPortfolio nToken;
    }

    /// @notice Checks if an asset is active in the portfolio
    function _isActiveInPortfolio(bytes2 currencyBytes) private pure returns (bool) {
        return currencyBytes & Constants.ACTIVE_IN_PORTFOLIO == Constants.ACTIVE_IN_PORTFOLIO;
    }

    /// @notice Checks if currency balances are active in the account returns them if true
    function _getCurrencyBalances(address account, bytes2 currencyBytes)
        private
        view
        returns (int256, int256)
    {
        if (currencyBytes & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {
            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));
            // prettier-ignore
            (
                int256 netLocalAssetValue,
                int256 nTokenBalance,
                /* lastClaimTime */,
                /* lastClaimIntegralSupply */
            ) = BalanceHandler.getBalanceStorage(account, currencyId);

            return (netLocalAssetValue, nTokenBalance);
        }

        return (0, 0);
    }

    /// @notice Calculates the nToken asset value with a haircut set by governance
    function _getNTokenHaircutAssetPV(
        CashGroupParameters memory cashGroup,
        nTokenPortfolio memory nToken,
        int256 tokenBalance,
        uint256 blockTime
    ) internal view returns (int256, bytes6) {
        nTokenHandler.loadNTokenPortfolioNoCashGroup(cashGroup.currencyId, nToken);
        nToken.cashGroup = cashGroup;

        // prettier-ignore
        (
            int256 nTokenAssetPV,
            /* ifCashBitmap */
        ) = nToken.getNTokenAssetPV(blockTime);

        int256 nTokenHaircutAssetPV =
            tokenBalance
                .mul(nTokenAssetPV)
                .mul(int256(uint8(nToken.parameters[Constants.PV_HAIRCUT_PERCENTAGE])))
                .div(Constants.PERCENTAGE_DECIMALS)
                .div(nToken.totalSupply);

        return (nTokenHaircutAssetPV, nToken.parameters);
    }

    /// @notice Calculates portfolio and/or nToken values while using the supplied cash groups and
    /// markets. The reason these are grouped together is because they both require storage reads of the same
    /// values.
    function _getPortfolioAndNTokenAssetValue(
        FreeCollateralFactors memory factors,
        int256 nTokenBalance,
        uint256 blockTime
    )
        private
        view
        returns (
            int256 netPortfolioValue,
            int256 nTokenHaircutAssetValue,
            bytes6 nTokenParameters
        )
    {
        // If the next asset matches the currency id then we need to calculate the cash group value
        if (
            factors.portfolioIndex < factors.portfolio.length &&
            factors.portfolio[factors.portfolioIndex].currencyId == factors.cashGroup.currencyId
        ) {
            (netPortfolioValue, factors.portfolioIndex) = AssetHandler.getNetCashGroupValue(
                factors.portfolio,
                factors.cashGroup,
                factors.market,
                blockTime,
                factors.portfolioIndex
            );
        }

        if (nTokenBalance > 0) {
            (nTokenHaircutAssetValue, nTokenParameters) = _getNTokenHaircutAssetPV(
                factors.cashGroup,
                factors.nToken,
                nTokenBalance,
                blockTime
            );
        }
    }

    /// @notice Returns balance values for the bitmapped currency
    function _getBitmapBalanceValue(
        address account,
        uint256 blockTime,
        AccountContext memory accountContext,
        FreeCollateralFactors memory factors
    )
        private
        view
        returns (
            int256 cashBalance,
            int256 nTokenHaircutAssetValue,
            bytes6 nTokenParameters
        )
    {
        int256 nTokenBalance;
        // prettier-ignore
        (
            cashBalance,
            nTokenBalance, 
            /* lastClaimTime */,
            /* lastClaimIntegralSupply */
        ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);

        if (nTokenBalance > 0) {
            (nTokenHaircutAssetValue, nTokenParameters) = _getNTokenHaircutAssetPV(
                factors.cashGroup,
                factors.nToken,
                nTokenBalance,
                blockTime
            );
        }
    }

    /// @notice Returns portfolio value for the bitmapped currency
    function _getBitmapPortfolioValue(
        address account,
        uint256 blockTime,
        AccountContext memory accountContext,
        FreeCollateralFactors memory factors
    ) private view returns (int256) {
        bytes32 assetsBitmap =
            BitmapAssetsHandler.getAssetsBitmap(account, accountContext.bitmapCurrencyId);
        (int256 netPortfolioValue, bool bitmapHasDebt) =
            BitmapAssetsHandler.getifCashNetPresentValue(
                account,
                accountContext.bitmapCurrencyId,
                accountContext.nextSettleTime,
                blockTime,
                assetsBitmap,
                factors.cashGroup,
                true // risk adjusted
            );

        // Turns off has debt flag if it has changed
        bool contextHasAssetDebt =
            accountContext.hasDebt & Constants.HAS_ASSET_DEBT == Constants.HAS_ASSET_DEBT;
        if (bitmapHasDebt && !contextHasAssetDebt) {
            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;
            factors.updateContext = true;
        } else if (!bitmapHasDebt && contextHasAssetDebt) {
            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;
            factors.updateContext = true;
        }

        return factors.cashGroup.assetRate.convertFromUnderlying(netPortfolioValue);
    }

    function _updateNetETHValue(
        uint256 currencyId,
        int256 netLocalAssetValue,
        FreeCollateralFactors memory factors
    ) private view returns (ETHRate memory) {
        ETHRate memory ethRate = ExchangeRate.buildExchangeRate(currencyId);
        factors.netETHValue = factors.netETHValue.add(
            ethRate.convertToETH(factors.assetRate.convertToUnderlying(netLocalAssetValue))
        );

        return ethRate;
    }

    /// @notice Stateful version of get free collateral, returns the total net ETH value and true or false if the account
    /// context needs to be updated.
    function getFreeCollateralStateful(
        address account,
        AccountContext memory accountContext,
        uint256 blockTime
    ) internal returns (int256, bool) {
        FreeCollateralFactors memory factors;
        bool hasCashDebt;

        if (accountContext.bitmapCurrencyId != 0) {
            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);

            // prettier-ignore
            (
                int256 netCashBalance,
                int256 nTokenHaircutAssetValue,
                /* nTokenParameters */
            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);
            if (netCashBalance < 0) hasCashDebt = true;

            int256 portfolioValue =
                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);
            int256 netLocalAssetValue =
                netCashBalance.add(nTokenHaircutAssetValue).add(portfolioValue);

            factors.assetRate = factors.cashGroup.assetRate;
            _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);
        } else {
            factors.portfolio = PortfolioHandler.getSortedPortfolio(
                account,
                accountContext.assetArrayLength
            );
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            bytes2 currencyBytes = bytes2(currencies);
            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));

            (int256 netLocalAssetValue, int256 nTokenBalance) =
                _getCurrencyBalances(account, currencyBytes);
            if (netLocalAssetValue < 0) hasCashDebt = true;

            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {
                factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);

                // prettier-ignore
                (
                    int256 netPortfolioValue,
                    int256 nTokenHaircutAssetValue,
                    /* nTokenParameters */
                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);
                netLocalAssetValue = netLocalAssetValue.add(netPortfolioValue).add(
                    nTokenHaircutAssetValue
                );
                factors.assetRate = factors.cashGroup.assetRate;
            } else {
                factors.assetRate = AssetRate.buildAssetRateStateful(currencyId);
            }

            _updateNetETHValue(currencyId, netLocalAssetValue, factors);
            currencies = currencies << 16;
        }

        // Free collateral is the only method that examines all cash balances for an account at once. If there is no cash debt (i.e.
        // they have been repaid or settled via more debt) then this will turn off the flag. It's possible that this flag is out of
        // sync temporarily after a cash settlement and before the next free collateral check. The only downside for that is forcing
        // an account to do an extra free collateral check to turn off this setting.
        if (
            accountContext.hasDebt & Constants.HAS_CASH_DEBT == Constants.HAS_CASH_DEBT &&
            !hasCashDebt
        ) {
            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_CASH_DEBT;
            factors.updateContext = true;
        }

        return (factors.netETHValue, factors.updateContext);
    }

    /// @notice View version of getFreeCollateral, does not use the stateful version of build cash group and skips
    /// all the update context logic.
    function getFreeCollateralView(
        address account,
        AccountContext memory accountContext,
        uint256 blockTime
    ) internal view returns (int256, int256[] memory) {
        FreeCollateralFactors memory factors;
        uint256 netLocalIndex;
        int256[] memory netLocalAssetValues = new int256[](10);

        if (accountContext.bitmapCurrencyId != 0) {
            factors.cashGroup = CashGroup.buildCashGroupView(accountContext.bitmapCurrencyId);

            // prettier-ignore
            (
                int256 netCashBalance,
                int256 nTokenHaircutAssetValue,
                /* nTokenParameters */
            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);
            int256 portfolioBalance =
                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);

            netLocalAssetValues[netLocalIndex] = netCashBalance.add(nTokenHaircutAssetValue).add(
                portfolioBalance
            );
            factors.assetRate = factors.cashGroup.assetRate;
            _updateNetETHValue(
                accountContext.bitmapCurrencyId,
                netLocalAssetValues[netLocalIndex],
                factors
            );
            netLocalIndex++;
        } else {
            factors.portfolio = PortfolioHandler.getSortedPortfolio(
                account,
                accountContext.assetArrayLength
            );
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            bytes2 currencyBytes = bytes2(currencies);
            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));
            int256 nTokenBalance;
            (netLocalAssetValues[netLocalIndex], nTokenBalance) = _getCurrencyBalances(
                account,
                currencyBytes
            );

            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {
                factors.cashGroup = CashGroup.buildCashGroupView(currencyId);
                // prettier-ignore
                (
                    int256 netPortfolioValue,
                    int256 nTokenHaircutAssetValue,
                    /* nTokenParameters */
                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);

                netLocalAssetValues[netLocalIndex] = netLocalAssetValues[netLocalIndex]
                    .add(netPortfolioValue)
                    .add(nTokenHaircutAssetValue);
                factors.assetRate = factors.cashGroup.assetRate;
            } else {
                factors.assetRate = AssetRate.buildAssetRateView(currencyId);
            }

            _updateNetETHValue(currencyId, netLocalAssetValues[netLocalIndex], factors);
            netLocalIndex++;
            currencies = currencies << 16;
        }

        return (factors.netETHValue, netLocalAssetValues);
    }

    /// @dev this is used to clear the stack frame
    function _calculateLiquidationAssetValue(
        FreeCollateralFactors memory factors,
        LiquidationFactors memory liquidationFactors,
        bytes2 currencyBytes,
        bool setLiquidationFactors,
        uint256 blockTime
    ) private returns (int256) {
        uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));
        (int256 netLocalAssetValue, int256 nTokenBalance) =
            _getCurrencyBalances(liquidationFactors.account, currencyBytes);

        if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {
            factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);
            (int256 netPortfolioValue, int256 nTokenHaircutAssetValue, bytes6 nTokenParameters) =
                _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);

            netLocalAssetValue = netLocalAssetValue.add(netPortfolioValue).add(
                nTokenHaircutAssetValue
            );
            factors.assetRate = factors.cashGroup.assetRate;

            // If collateralCurrencyId is set to zero then this is a local currency liquidation
            if (setLiquidationFactors) {
                liquidationFactors.cashGroup = factors.cashGroup;
                liquidationFactors.nTokenParameters = nTokenParameters;
                liquidationFactors.nTokenHaircutAssetValue = nTokenHaircutAssetValue;
            }
        } else {
            factors.assetRate = AssetRate.buildAssetRateStateful(currencyId);
        }

        return netLocalAssetValue;
    }

    /// @notice A version of getFreeCollateral used during liquidation to save off necessary additional information.
    function getLiquidationFactors(
        address account,
        AccountContext memory accountContext,
        uint256 blockTime,
        uint256 localCurrencyId,
        uint256 collateralCurrencyId
    ) internal returns (LiquidationFactors memory, PortfolioAsset[] memory) {
        FreeCollateralFactors memory factors;
        LiquidationFactors memory liquidationFactors;
        // This is only set to reduce the stack size
        liquidationFactors.account = account;

        if (accountContext.bitmapCurrencyId != 0) {
            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);
            (int256 netCashBalance, int256 nTokenHaircutAssetValue, bytes6 nTokenParameters) =
                _getBitmapBalanceValue(account, blockTime, accountContext, factors);
            int256 portfolioBalance =
                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);

            int256 netLocalAssetValue =
                netCashBalance.add(nTokenHaircutAssetValue).add(portfolioBalance);
            factors.assetRate = factors.cashGroup.assetRate;
            ETHRate memory ethRate =
                _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);

            // If the bitmap currency id can only ever be the local currency where debt is held. During enable bitmap we check that
            // the account has no assets in their portfolio and no cash debts.
            if (accountContext.bitmapCurrencyId == localCurrencyId) {
                liquidationFactors.cashGroup = factors.cashGroup;
                liquidationFactors.localAssetAvailable = netLocalAssetValue;
                liquidationFactors.localETHRate = ethRate;

                // This will be the case during local currency or local fCash liquidation
                if (collateralCurrencyId == 0) {
                    liquidationFactors.nTokenHaircutAssetValue = nTokenHaircutAssetValue;
                    liquidationFactors.nTokenParameters = nTokenParameters;
                }
            }
        } else {
            factors.portfolio = PortfolioHandler.getSortedPortfolio(
                account,
                accountContext.assetArrayLength
            );
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            bytes2 currencyBytes = bytes2(currencies);

            // This next bit of code here is annoyingly structured to get around stack size issues
            bool setLiquidationFactors;
            {
                uint256 tempId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));
                setLiquidationFactors =
                    (tempId == localCurrencyId && collateralCurrencyId == 0) ||
                    tempId == collateralCurrencyId;
            }
            int256 netLocalAssetValue =
                _calculateLiquidationAssetValue(
                    factors,
                    liquidationFactors,
                    currencyBytes,
                    setLiquidationFactors,
                    blockTime
                );

            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));
            ETHRate memory ethRate = _updateNetETHValue(currencyId, netLocalAssetValue, factors);

            if (currencyId == collateralCurrencyId) {
                // Ensure that this is set even if the cash group is not loaded
                liquidationFactors.cashGroup.assetRate = factors.assetRate;
                liquidationFactors.collateralAssetAvailable = netLocalAssetValue;
                liquidationFactors.collateralETHRate = ethRate;
            } else if (currencyId == localCurrencyId) {
                liquidationFactors.localAssetAvailable = netLocalAssetValue;
                liquidationFactors.localETHRate = ethRate;
                liquidationFactors.localAssetRate = factors.assetRate;
            }

            currencies = currencies << 16;
        }

        liquidationFactors.netETHValue = factors.netETHValue;
        require(liquidationFactors.netETHValue < 0, ""Sufficient collateral"");

        // Refetch the portfolio if it exists, AssetHandler.getNetCashValue updates values in memory to do fCash
        // netting which will make further calculations incorrect.
        if (accountContext.assetArrayLength > 0) {
            factors.portfolio = PortfolioHandler.getSortedPortfolio(
                account,
                accountContext.assetArrayLength
            );
        }

        return (liquidationFactors, factors.portfolio);
    }
}",4089
RealWorld_TA_23_Reservoir_RealWorld_20240803073812.log,23,Reservoir,73968,2631,76599,364.0,0.42246,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @title Reservoir Contract
/// @notice Distributes a token to a different contract at a fixed rate. Though not entirely
/// necessary this contract does give some measure of safety against the Notional contract's token
/// reserves being drained by an attack. The goal should be to set up a reservoir such that the
/// Notional contract's target reserves are maintained at some reasonable level. The reservoir should
/// only ever have NOTE token balances, nothing else.
/// @dev This contract must be poked via the `drip()` function every so often.
/// @author Compound, modified by Notional
contract Reservoir {
    using SafeMath for uint256;

    /// @notice Emitted whenever the reservoir drips tokens to the target
    event ReservoirDrip(address indexed targetAddress, uint256 amountTransferred);

    /// @notice The timestamp when the Reservoir started
    uint256 public immutable DRIP_START;

    /// @notice Tokens per second that to drip to target
    uint256 public immutable DRIP_RATE;

    /// @notice Reference to token to drip
    IERC20 public immutable TOKEN;

    /// @notice Target to receive dripped tokens
    address public immutable TARGET;

    /// @notice Amount that has already been dripped
    uint256 public dripped;

    /// @notice Constructs a Reservoir
    /// @param dripRate_ Number of tokens per second to drip
    /// @param token_ The token to drip
    /// @param target_ The recipient of dripped tokens
    constructor(
        uint256 dripRate_,
        IERC20 token_,
        address target_
    ) {
        require(dripRate_ > 0, ""Drip rate cannot be zero"");

        DRIP_START = block.timestamp;
        DRIP_RATE = dripRate_;
        TOKEN = token_;
        TARGET = target_;
        dripped = 0;
    }

    /// @notice Drips the maximum amount of tokens to match the drip rate since inception
    /// @dev emit:Transfer
    /// @return amountToDrip tokens dripped
    function drip() public returns (uint256 amountToDrip) {
        uint256 reservoirBalance = TOKEN.balanceOf(address(this));
        require(reservoirBalance > 0, ""Reservoir empty"");
        uint256 blockTime = block.timestamp;

        amountToDrip = DRIP_RATE.mul(blockTime - DRIP_START).sub(dripped);
        if (amountToDrip > reservoirBalance) amountToDrip = reservoirBalance;

        // Finally, write new `dripped` value and transfer tokens to target
        dripped = dripped.add(amountToDrip);
        // No need to do special checking for return codes, here we know that the token
        // will be compliant because it is the NOTE contract
        bool success = TOKEN.transfer(TARGET, amountToDrip);
        require(success, ""Transfer failed"");
        emit ReservoirDrip(TARGET, amountToDrip);
    }
}",671
RealWorld_TA_23_MockFlashLender_RealWorld_20240803023804.log,23,MockFlashLender,45583,3835,49418,118.0,0.304615,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IFlashLoanReceiver {
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool);

    //   function ADDRESSES_PROVIDER() external view returns (address);

    //   function LENDING_POOL() external view returns (address);
}

contract MockFlashLender {
    function executeFlashLoan(
        address[] calldata assets,
        uint256[] calldata amounts,
        IFlashLoanReceiver receiver,
        bytes calldata params
    ) external {
        uint256[] memory premiums = new uint256[](assets.length);

        for (uint256 i; i < assets.length; i++) {
            // 9 basis point fee
            premiums[i] = (amounts[i] * 9) / 10000;
            IERC20(assets[i]).transfer(address(receiver), amounts[i]);
        }

        bool success = receiver.executeOperation(assets, amounts, premiums, msg.sender, params);
        require(success);

        for (uint256 i; i < assets.length; i++) {
            IERC20(assets[i]).transferFrom(
                address(receiver),
                address(this),
                amounts[i] + premiums[i]
            );
        }
    }
}",316
RealWorld_TA_23_MockCashGroup_RealWorld_20240803022240.log,23,MockCashGroup,142302,4182,146484,146.0,0.79515,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../internal/markets/CashGroup.sol"";
import ""../global/StorageLayoutV1.sol"";

contract MockCashGroup is StorageLayoutV1 {
    using CashGroup for CashGroupParameters;
    using Market for MarketParameters;

    function setAssetRateMapping(uint256 id, AssetRateStorage calldata rs) external {
        assetToUnderlyingRateMapping[id] = rs;
    }

    function setCashGroup(uint256 id, CashGroupSettings calldata cg) external {
        CashGroup.setCashGroupStorage(id, cg);
    }

    function setMarketState(
        uint256 currencyId,
        uint256 maturity,
        uint256 settlementDate,
        MarketParameters memory ms
    ) external {
        ms.storageSlot = Market.getSlot(currencyId, settlementDate, maturity);
        // ensure that state gets set
        ms.storageState = 0xFF;
        ms.setMarketStorage();
    }

    function getMarketState(
        uint256 id,
        uint256 maturity,
        uint256 blockTime,
        uint256 timeWindow
    ) external view returns (MarketParameters memory) {
        MarketParameters memory market;
        market.loadMarket(id, maturity, blockTime, true, timeWindow);
        return market;
    }

    function getTradedMarket(uint256 index) public pure returns (uint256) {
        return DateTime.getTradedMarket(index);
    }

    function isValidMarketMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) public pure returns (bool) {
        bool isValid = DateTime.isValidMarketMaturity(maxMarketIndex, maturity, blockTime);
        if (maturity < blockTime) assert(!isValid);

        return isValid;
    }

    function isValidMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) public pure returns (bool) {
        bool isValid = DateTime.isValidMaturity(maxMarketIndex, maturity, blockTime);

        return isValid;
    }

    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)
        public
        pure
        returns (uint256, bool)
    {
        (uint256 bitNum, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);
        assert(bitNum <= 256);
        if (isValid) assert(bitNum > 0);

        return (bitNum, isValid);
    }

    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)
        public
        pure
        returns (uint256)
    {
        uint256 maturity = DateTime.getMaturityFromBitNum(blockTime, bitNum);
        assert(maturity > blockTime);

        return maturity;
    }

    function getRateScalar(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        uint256 timeToMaturity
    ) public pure returns (int256) {
        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);

        return rateScalar;
    }

    function getTotalFee(CashGroupParameters memory cashGroup) public pure returns (uint256) {
        return cashGroup.getTotalFee();
    }

    function getReserveFeeShare(CashGroupParameters memory cashGroup) public pure returns (int256) {
        return cashGroup.getReserveFeeShare();
    }

    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 timeToMaturity)
        public
        pure
        returns (uint256)
    {
        return cashGroup.getLiquidityHaircut(timeToMaturity);
    }

    function getfCashHaircut(CashGroupParameters memory cashGroup) public pure returns (uint256) {
        return cashGroup.getfCashHaircut();
    }

    function getDebtBuffer(CashGroupParameters memory cashGroup) public pure returns (uint256) {
        return cashGroup.getDebtBuffer();
    }

    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)
        public
        pure
        returns (uint256)
    {
        return cashGroup.getRateOracleTimeWindow();
    }

    function getSettlementPenalty(CashGroupParameters memory cashGroup)
        public
        pure
        returns (uint256)
    {
        return cashGroup.getSettlementPenalty();
    }

    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup)
        public
        pure
        returns (uint256)
    {
        return cashGroup.getLiquidationfCashHaircut();
    }

    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup)
        public
        pure
        returns (uint256)
    {
        return cashGroup.getLiquidationDebtBuffer();
    }

    function getMarketIndex(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) public pure returns (uint256, bool) {
        return DateTime.getMarketIndex(maxMarketIndex, maturity, blockTime);
    }

    function loadMarket(
        CashGroupParameters memory cashGroup,
        uint256 marketIndex,
        bool needsLiquidity,
        uint256 blockTime
    ) public view returns (MarketParameters memory market) {
        cashGroup.loadMarket(market, marketIndex, needsLiquidity, blockTime);
    }

    function interpolateOracleRate(
        uint256 shortMaturity,
        uint256 longMaturity,
        uint256 shortRate,
        uint256 longRate,
        uint256 assetMaturity
    ) public pure returns (uint256) {
        uint256 rate =
            CashGroup.interpolateOracleRate(
                shortMaturity,
                longMaturity,
                shortRate,
                longRate,
                assetMaturity
            );

        if (shortRate == longRate) {
            assert(rate == shortRate);
        } else if (shortRate < longRate) {
            assert(shortRate < rate && rate < longRate);
        } else {
            assert(shortRate > rate && rate > longRate);
        }

        return rate;
    }

    function calculateOracleRate(
        CashGroupParameters memory cashGroup,
        uint256 assetMaturity,
        uint256 blockTime
    ) public view returns (uint256) {
        return cashGroup.calculateOracleRate(assetMaturity, blockTime);
    }

    function buildCashGroupView(uint256 currencyId)
        public
        view
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupView(currencyId);
    }

    function buildCashGroupStateful(uint256 currencyId)
        public
        returns (CashGroupParameters memory)
    {
        return CashGroup.buildCashGroupStateful(currencyId);
    }

    function deserializeCashGroupStorage(uint256 currencyId)
        public
        view
        returns (CashGroupSettings memory)
    {
        return CashGroup.deserializeCashGroupStorage(currencyId);
    }
}",1448
RealWorld_TA_23_Constants_RealWorld_20240803075027.log,23,Constants,150371,1454,151825,372.0,0.780935,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;

/// @title All shared constants for the Notional system should be declared here.
library Constants {
    // Token precision used for all internal balances, TokenHandler library ensures that we
    // limit the dust amount caused by precision mismatches
    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;

    // ETH will be initialized as the first currency
    uint256 internal constant ETH_CURRENCY_ID = 1;
    int256 internal constant ETH_DECIMAL_PLACES = 18;
    int256 internal constant ETH_DECIMALS = 1e18;

    // Used to when calculating the amount to deleverage of a market when minting nTokens
    uint256 internal constant DELEVERAGE_BUFFER = 30000000; // 300 * Constants.BASIS_POINT

    // Address of the reserve account
    address internal constant RESERVE = address(0);
    // NOTE: this address is hardcoded in the library, must update this on deployment
    address constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;

    // Most significant bit
    bytes32 internal constant MSB =
        0x8000000000000000000000000000000000000000000000000000000000000000;

    // Basis for percentages
    int256 internal constant PERCENTAGE_DECIMALS = 100;
    // Max number of traded markets, also used as the maximum number of assets in a portfolio array
    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;
    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral
    // for a bitmap portfolio
    uint256 internal constant MAX_BITMAP_ASSETS = 20;

    // Internal date representations, note we use a 6/30/360 week/month/year convention here
    uint256 internal constant DAY = 86400;
    // We use six day weeks to ensure that all time references divide evenly
    uint256 internal constant WEEK = DAY * 6;
    uint256 internal constant MONTH = DAY * 30;
    uint256 internal constant QUARTER = DAY * 90;
    uint256 internal constant YEAR = QUARTER * 4;

    // Offsets for each time chunk denominated in days
    uint256 internal constant MAX_DAY_OFFSET = 90;
    uint256 internal constant MAX_WEEK_OFFSET = 360;
    uint256 internal constant MAX_MONTH_OFFSET = 2160;
    uint256 internal constant MAX_QUARTER_OFFSET = 7650;

    // Offsets for each time chunk denominated in bits
    uint256 internal constant WEEK_BIT_OFFSET = 90;
    uint256 internal constant MONTH_BIT_OFFSET = 135;
    uint256 internal constant QUARTER_BIT_OFFSET = 195;

    // This is a constant that represents the time period that all rates are normalized by, 360 days
    uint256 internal constant IMPLIED_RATE_TIME = 31104000;
    // Number of decimal places that rates are stored in, equals 100%
    int256 internal constant RATE_PRECISION = 1e9;
    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);

    // This is the ABDK64x64 representation of RATE_PRECISION
    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)
    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;
    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;

    uint256 internal constant FCASH_ASSET_TYPE = 1;
    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)
    uint256 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;
    uint256 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;

    bytes1 internal constant BOOL_FALSE = 0x00;
    bytes1 internal constant BOOL_TRUE = 0x01;

    // Account context flags
    bytes1 internal constant HAS_ASSET_DEBT = 0x01;
    bytes1 internal constant HAS_CASH_DEBT = 0x02;
    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;
    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;
    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;
    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);

    // nToken Parameters
    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;
    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;
    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;
    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;
    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;
    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;
    uint8 internal constant ASSET_ARRAY_LENGTH = 5;

    // Liquidation parameters
    /// @dev Default portion of collateral that a liquidator is allowed to liquidate, will be higher if the account
    /// requires more collateral to be liquidated
    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;
    /// @dev Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens
    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 10;
    /// @dev Liquidation dust setting used during fCash liquidation
    int256 internal constant LIQUIDATION_DUST = 10;

    // Pause Router liquidation enabled states
    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;
    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;
    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;
    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;

    /* Internal Storage Slot Offsets */
    // Internally used storage slots are set at 1000000 offset from the solidity provisioned storage slots to minimize
    // the possibility of clashing.
    uint256 internal constant ACCOUNT_CONTEXT_STORAGE_OFFSET = 1000001;
    uint256 internal constant NTOKEN_CONTEXT_STORAGE_OFFSET = 1000002;
    uint256 internal constant NTOKEN_ADDRESS_STORAGE_OFFSET = 1000003;
    uint256 internal constant NTOKEN_DEPOSIT_STORAGE_OFFSET = 1000004;
    uint256 internal constant NTOKEN_INIT_STORAGE_OFFSET = 1000005;
    uint256 internal constant BALANCE_STORAGE_OFFSET = 1000006;
    uint256 internal constant TOKEN_STORAGE_OFFSET = 1000007;
    uint256 internal constant SETTLEMENT_RATE_STORAGE_OFFSET = 1000008;
    uint256 internal constant CASH_GROUP_STORAGE_OFFSET = 1000009;
    uint256 internal constant MARKET_STORAGE_OFFSET = 1000010;
    uint256 internal constant ASSETS_BITMAP_STORAGE_OFFSET = 1000011;
    uint256 internal constant IFCASH_STORAGE_OFFSET = 1000012;
    uint256 internal constant PORTFOLIO_ARRAY_STORAGE_OFFSET = 1000013;
    uint256 internal constant NTOKEN_TOTAL_SUPPLY_OFFSET = 1000014;
}",1574
RealWorld_TA_24_MStableYieldSource_RealWorld_20240803101909.log,24,MStableYieldSource,113156,3998,117154,364.0,0.64574,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.2;

import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import { ISavingsContractV2 } from ""@mstable/protocol/contracts/interfaces/ISavingsContract.sol"";

contract MStableYieldSource is IYieldSource, ReentrancyGuard {
    using SafeERC20 for IERC20;

    ISavingsContractV2 public immutable savings;
    IERC20 public immutable mAsset;

    /// @notice mapping of account addresses to interest-bearing mAsset balances. eg imUSD
    mapping(address => uint256) public imBalances;

    /// @notice Emitted on init
    /// @param savings The ISavingsContractV2 to bind to
    event Initialized(ISavingsContractV2 indexed savings);

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    /// @param sponsor The address who sponsored
    /// @param mAssetAmount The amount of deposit token that was sponsored
    event Sponsored(address indexed sponsor, uint256 mAssetAmount);

    /// @notice Emitted when asset tokens are supplied to earn yield
    /// @param from The address who supplied the assets
    /// @param to The new owner of the assets
    /// @param amount The amount of assets supplied
    event Supplied(address indexed from, address indexed to, uint256 amount);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    /// @param from The address who is redeeming
    /// @param requestedAmount The amount that was requested to withdraw
    /// @param actualAmount The actual amount of assets transferred to the address
    event Redeemed(address indexed from, uint256 requestedAmount, uint256 actualAmount);

    /// @notice Approves max spend by the mAsset
    /// @param from The user who triggered approve max
    event ApprovedMax(address indexed from);

    constructor(ISavingsContractV2 _savings) ReentrancyGuard() {
        // As immutable storage variables can not be accessed in the constructor,
        // create in-memory variables that can be used instead.
        IERC20 mAssetMemory = IERC20(_savings.underlying());

        // infinite approve Savings Contract to transfer mAssets from this contract
        mAssetMemory.safeApprove(address(_savings), type(uint256).max);

        // save to immutable storage
        savings = _savings;
        mAsset = mAssetMemory;

        emit Initialized(_savings);
    }

    /// @notice Approves of the max spend amount for the Savings contract.
    function approveMax() public {
        IERC20(savings.underlying()).safeApprove(address(savings), type(uint256).max);

        emit ApprovedMax(msg.sender);
    }

    /// @notice Returns the ERC20 mAsset token used for deposits
    /// @return underlyingMasset Underlying mAsset token address. eg mUSD
    function depositToken() public view override returns (address underlyingMasset) {
        underlyingMasset = address(mAsset);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return mAssets The underlying balance of mAsset tokens. eg mUSD
    function balanceOfToken(address addr) external view override returns (uint256 mAssets) {
        uint256 exchangeRate = savings.exchangeRate();
        mAssets = (imBalances[addr] * exchangeRate) / 1e18;
    }

    /// @notice Deposits mAsset tokens to the savings contract.
    /// @param mAssetAmount The amount of mAsset tokens to be deposited. eg mUSD
    function supplyTokenTo(uint256 mAssetAmount, address to) external override nonReentrant {
        mAsset.safeTransferFrom(msg.sender, address(this), mAssetAmount);
        uint256 creditsIssued = savings.depositSavings(mAssetAmount);
        imBalances[to] += creditsIssued;

        emit Supplied(msg.sender, to, mAssetAmount);
    }

    /// @notice Redeems mAsset tokens from the interest-beaing mAsset.
    ///         eg. redeems mUSD from imUSD.
    /// @param mAssetAmount The amount of mAsset tokens requested to be redeemed. eg mUSD
    /// @return mAssetsActual The actual amount of mAsset tokens that were received from the redeem. eg mUSD
    function redeemToken(uint256 mAssetAmount)
        external
        override
        nonReentrant
        returns (uint256 mAssetsActual)
    {   
        uint256 mAssetBalanceBefore = mAsset.balanceOf(address(this));

        uint256 creditsBurned = savings.redeemUnderlying(mAssetAmount);

        imBalances[msg.sender] -= creditsBurned;
        uint256 mAssetBalanceAfter = mAsset.balanceOf(address(this));
        mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;

        mAsset.safeTransfer(msg.sender, mAssetsActual);

        emit Redeemed(msg.sender, mAssetAmount, mAssetsActual);
    }
}",1142
RealWorld_TA_24_MStableYieldSource_RealWorld_20240803101255.log,24,MStableYieldSource,112549,3176,115725,372.0,0.626265,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity 0.8.2;

import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import { ISavingsContractV2 } from ""@mstable/protocol/contracts/interfaces/ISavingsContract.sol"";

contract MStableYieldSource is IYieldSource, ReentrancyGuard {
    using SafeERC20 for IERC20;

    ISavingsContractV2 public immutable savings;
    IERC20 public immutable mAsset;

    /// @notice mapping of account addresses to interest-bearing mAsset balances. eg imUSD
    mapping(address => uint256) public imBalances;

    /// @notice Emitted on init
    /// @param savings The ISavingsContractV2 to bind to
    event Initialized(ISavingsContractV2 indexed savings);

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    /// @param sponsor The address who sponsored
    /// @param mAssetAmount The amount of deposit token that was sponsored
    event Sponsored(address indexed sponsor, uint256 mAssetAmount);

    /// @notice Emitted when asset tokens are supplied to earn yield
    /// @param from The address who supplied the assets
    /// @param to The new owner of the assets
    /// @param amount The amount of assets supplied
    event Supplied(address indexed from, address indexed to, uint256 amount);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    /// @param from The address who is redeeming
    /// @param requestedAmount The amount that was requested to withdraw
    /// @param actualAmount The actual amount of assets transferred to the address
    event Redeemed(address indexed from, uint256 requestedAmount, uint256 actualAmount);

    /// @notice Approves max spend by the mAsset
    /// @param from The user who triggered approve max
    event ApprovedMax(address indexed from);

    constructor(ISavingsContractV2 _savings) ReentrancyGuard() {
        // As immutable storage variables can not be accessed in the constructor,
        // create in-memory variables that can be used instead.
        IERC20 mAssetMemory = IERC20(_savings.underlying());

        // infinite approve Savings Contract to transfer mAssets from this contract
        mAssetMemory.safeApprove(address(_savings), type(uint256).max);

        // save to immutable storage
        savings = _savings;
        mAsset = mAssetMemory;

        emit Initialized(_savings);
    }

    /// @notice Approves of the max spend amount for the Savings contract.
    function approveMax() public {
        IERC20(savings.underlying()).safeApprove(address(savings), type(uint256).max);

        emit ApprovedMax(msg.sender);
    }

    /// @notice Returns the ERC20 mAsset token used for deposits
    /// @return underlyingMasset Underlying mAsset token address. eg mUSD
    function depositToken() public view override returns (address underlyingMasset) {
        underlyingMasset = address(mAsset);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return mAssets The underlying balance of mAsset tokens. eg mUSD
    function balanceOfToken(address addr) external view override returns (uint256 mAssets) {
        uint256 exchangeRate = savings.exchangeRate();
        mAssets = (imBalances[addr] * exchangeRate) / 1e18;
    }

    /// @notice Deposits mAsset tokens to the savings contract.
    /// @param mAssetAmount The amount of mAsset tokens to be deposited. eg mUSD
    function supplyTokenTo(uint256 mAssetAmount, address to) external override nonReentrant {
        mAsset.safeTransferFrom(msg.sender, address(this), mAssetAmount);
        uint256 creditsIssued = savings.depositSavings(mAssetAmount);
        imBalances[to] += creditsIssued;

        emit Supplied(msg.sender, to, mAssetAmount);
    }

    /// @notice Redeems mAsset tokens from the interest-beaing mAsset.
    ///         eg. redeems mUSD from imUSD.
    /// @param mAssetAmount The amount of mAsset tokens requested to be redeemed. eg mUSD
    /// @return mAssetsActual The actual amount of mAsset tokens that were received from the redeem. eg mUSD
    function redeemToken(uint256 mAssetAmount)
        external
        override
        nonReentrant
        returns (uint256 mAssetsActual)
    {   
        uint256 mAssetBalanceBefore = mAsset.balanceOf(address(this));

        uint256 creditsBurned = savings.redeemUnderlying(mAssetAmount);

        imBalances[msg.sender] -= creditsBurned;
        uint256 mAssetBalanceAfter = mAsset.balanceOf(address(this));
        mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;

        mAsset.safeTransfer(msg.sender, mAssetsActual);

        emit Redeemed(msg.sender, mAssetAmount, mAssetsActual);
    }
}",1142
RealWorld_TA_24_SwappableYieldSource_RealWorld_20240803095823.log,24,SwappableYieldSource,303792,5453,309245,158.0,1.62802,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",3524
RealWorld_TA_24_AssetManager_RealWorld_20240803100439.log,24,AssetManager,61007,1739,62746,125.0,0.339815,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol"";

/**
*  @title Abstract ownable contract with additional assetManager role
 * @notice Contract module based on Ownable which provides a basic access control mechanism, where
 * there is an account (an asset manager) that can be granted exclusive access to
 * specific functions.
 *
 * The asset manager account needs to be set using {setAssetManager}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyAssetManager`, which can be applied to your functions to restrict their use to
 * the asset manager.
 */
abstract contract AssetManager is ContextUpgradeable, OwnableUpgradeable {
    address private _assetManager;

    /**
     * @dev Emitted when _assetManager has been changed.
     * @param previousAssetManager former _assetManager address.
     * @param newAssetManager new _assetManager address.
     */
    event AssetManagerTransferred(address indexed previousAssetManager, address indexed newAssetManager);

    /**
     * @notice Gets current _assetManager.
     * @dev Returns current _assetManager address.
     * @return Current _assetManager address.
     */
    function assetManager() public view virtual returns (address) {
        return _assetManager;
    }

    /**
     * @dev Throws if called by any account other than the owner or asset manager.
     */
    modifier onlyOwnerOrAssetManager() {
        require(assetManager() == _msgSender() || owner() == _msgSender(), ""onlyOwnerOrAssetManager/owner-or-manager"");
        _;
    }

    /**
     * @notice Set or change of asset manager.
     * @dev Throws if called by any account other than the owner.
     * @param _newAssetManager New _assetManager address.
     * @return Boolean to indicate if the operation was successful or not.
     */
    function setAssetManager(address _newAssetManager) public virtual onlyOwner returns (bool) {
        require(_newAssetManager != address(0), ""onlyOwnerOrAssetManager/assetManager-not-zero-address"");

        address _previousAssetManager = _assetManager;
        _assetManager = _newAssetManager;

        emit AssetManagerTransferred(_previousAssetManager, _newAssetManager);
        return true;
    }
}",519
RealWorld_TA_24_SafeERC20WrapperUpgradeable_RealWorld_20240803100244.log,24,SafeERC20WrapperUpgradeable,85339,4016,89355,113.0,0.507015,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol"";

// Mock implementation from OpenZeppelin modified for our usage in tests
// https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/mocks/SafeERC20HelperUpgradeable.sol
contract ERC20ReturnTrueMockUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {
    // solhint-disable func-name-mixedcase
    function __ERC20ReturnTrueMock_init() internal initializer {
        __Context_init_unchained();
        __ERC20ReturnTrueMock_init_unchained();
    }

    // solhint-disable func-name-mixedcase
    function __ERC20ReturnTrueMock_init_unchained() internal initializer {
    }
    mapping (address => uint256) private _allowances;

    // IERC20's functions are not pure, but these mock implementations are: to prevent Solidity from issuing warnings,
    // we write to a dummy state variable.
    uint256 private _dummy;

    function transfer(address, uint256) public override returns (bool) {
        _dummy = 0;
        return true;
    }

    function transferFrom(address, address, uint256) public override returns (bool) {
        _dummy = 0;
        return true;
    }

    function approve(address, uint256) public override returns (bool) {
        _dummy = 0;
        return true;
    }

    function setAllowance(uint256 allowance_) public {
        _allowances[_msgSender()] = allowance_;
    }

    function allowance(address owner, address) public view override returns (uint256) {
        return _allowances[owner];
    }
    uint256[48] private __gap;
}

contract SafeERC20WrapperUpgradeable is Initializable, ContextUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    IERC20Upgradeable private _token;

    // solhint-disable func-name-mixedcase
    function __SafeERC20Wrapper_init(IERC20Upgradeable token) internal initializer {
        __Context_init_unchained();
        __SafeERC20Wrapper_init_unchained(token);
    }

    // solhint-disable func-name-mixedcase
    function __SafeERC20Wrapper_init_unchained(IERC20Upgradeable token) internal initializer {
        _token = token;
    }

    function balanceOf(address account) public view returns (uint256) {
        _token.balanceOf(account);
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _token.safeTransfer(recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _token.safeTransferFrom(sender, recipient, amount);
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _token.safeApprove(spender, amount);
    }

    function increaseAllowance(uint256 amount) public {
        _token.safeIncreaseAllowance(address(0), amount);
    }

    function decreaseAllowance(uint256 amount) public {
        _token.safeDecreaseAllowance(address(0), amount);
    }

    function setAllowance(uint256 allowance_) public {
        ERC20ReturnTrueMockUpgradeable(address(_token)).setAllowance(allowance_);
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _token.allowance(owner, spender);
    }
    uint256[49] private __gap;
}",834
RealWorld_TA_24_SwappableYieldSource_RealWorld_20240803100646.log,24,SwappableYieldSource,303836,5620,309456,367.0,1.63158,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",3524
RealWorld_TA_24_SwappableYieldSourceHarness_RealWorld_20240803100103.log,24,SwappableYieldSourceHarness,39414,3337,42751,99.0,0.26381,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""../SwappableYieldSource.sol"";

/* solium-disable security/no-block-members */
contract SwappableYieldSourceHarness is SwappableYieldSource {
  function requireYieldSource(IYieldSource _yieldSource) public view {
    return _requireYieldSource(_yieldSource);
  }

  function requireDifferentYieldSource(IYieldSource _yieldSource) public view {
    return _requireDifferentYieldSource(_yieldSource);
  }

  function mint(address account, uint256 amount) public returns (bool) {
    _mint(account, amount);
    return true;
  }

  function mintShares(uint256 mintAmount, address to) public {
    return _mintShares(mintAmount, to);
  }

  function burnShares(uint256 burnAmount) public {
    return _burnShares(burnAmount);
  }

  function tokenToShares(uint256 tokens) external returns (uint256) {
    return _tokenToShares(tokens);
  }

  function sharesToToken(uint256 shares) external returns (uint256) {
    return _sharesToToken(shares);
  }
}",246
RealWorld_TA_25_YieldMath_RealWorld_20240803114547.log,25,YieldMath,1203587,68,1203655,366.0,6.019295,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""./Math64x64.sol"";

library Exp64x64 {
  /**
   * Raise given number x into power specified as a simple fraction y/z and then
   * multiply the result by the normalization factor 2^(128 * (1 - y/z)).
   * Revert if z is zero, or if both x and y are zeros.
   *
   * @param x number to raise into given power y/z
   * @param y numerator of the power to raise x into
   * @param z denominator of the power to raise x into
   * @return x raised into power y/z and then multiplied by 2^(128 * (1 - y/z))
   */
  function pow(uint128 x, uint128 y, uint128 z)
  internal pure returns(uint128) {
    unchecked {
      require(z != 0);

      if(x == 0) {
        require(y != 0);
        return 0;
      } else {
        uint256 l =
          uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - log_2(x)) * y / z;
        if(l > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0;
        else return pow_2(uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - l));
      }
    }
  }

  /**
   * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert
   * in case x is zero.
   *
   * @param x number to calculate base 2 logarithm of
   * @return base 2 logarithm of x, multiplied by 2^121
   */
  function log_2(uint128 x)
  internal pure returns(uint128) {
    unchecked {
      require(x != 0);

      uint b = x;

      uint l = 0xFE000000000000000000000000000000;

      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}
      if(b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}
      if(b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}
      if(b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}
      if(b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}
      if(b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}
      if(b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}

      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;} /*
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}
      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) l |= 0x1; */

      return uint128(l);
    }
  }

  /**
   * Calculate 2 raised into given power.
   *
   * @param x power to raise 2 into, multiplied by 2^121
   * @return 2 raised into given power
   */
  function pow_2(uint128 x)
  internal pure returns(uint128) {
    unchecked {
      uint r = 0x80000000000000000000000000000000;
      if(x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;
      if(x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;
      if(x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;
      if(x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;
      if(x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;
      if(x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;
      if(x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;
      if(x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;
      if(x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;
      if(x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;
      if(x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;
      if(x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;
      if(x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;
      if(x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;
      if(x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;
      if(x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;
      if(x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;
      if(x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;
      if(x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;
      if(x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;
      if(x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;
      if(x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;
      if(x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;
      if(x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;
      if(x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;
      if(x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;
      if(x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;
      if(x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;
      if(x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;
      if(x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;
      if(x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;
      if(x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;
      if(x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;
      if(x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;
      if(x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;
      if(x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;
      if(x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;
      if(x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;
      if(x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;
      if(x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;
      if(x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;
      if(x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;
      if(x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;
      if(x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;
      if(x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;
      if(x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;
      if(x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;
      if(x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;
      if(x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;
      if(x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;
      if(x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;
      if(x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;
      if(x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;
      if(x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;
      if(x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;
      if(x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;
      if(x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127; /*
      if(x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;
      if(x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;
      if(x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;
      if(x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;
      if(x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;
      if(x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;
      if(x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;
      if(x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;
      if(x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;
      if(x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;
      if(x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;
      if(x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;
      if(x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;
      if(x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;
      if(x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;
      if(x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;
      if(x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;
      if(x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;
      if(x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;
      if(x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;
      if(x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;
      if(x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;
      if(x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;
      if(x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;
      if(x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;
      if(x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;
      if(x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;
      if(x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;
      if(x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;
      if(x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;
      if(x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;
      if(x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;
      if(x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;
      if(x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;
      if(x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;
      if(x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;
      if(x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;
      if(x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;
      if(x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;
      if(x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;
      if(x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;
      if(x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;
      if(x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;
      if(x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;
      if(x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;
      if(x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;
      if(x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;
      if(x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;
      if(x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;
      if(x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;
      if(x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;
      if(x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;
      if(x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;
      if(x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;
      if(x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;
      if(x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;
      if(x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;
      if(x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;
      if(x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;
      if(x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;
      if(x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;
      if(x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;
      if(x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;
      if(x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127; */

      r >>= 127 -(x >> 121);

      return uint128(r);
    }
  }
}

/**
 * Ethereum smart contract library implementing Yield Math model.
 */
library YieldMath {
  using Math64x64 for int128;
  using Math64x64 for uint128;
  using Math64x64 for int256;
  using Math64x64 for uint256;
  using Exp64x64 for uint128;

  uint128 public constant ONE = 0x10000000000000000; // In 64.64
  uint256 public constant MAX = type(uint128).max;   // Used for overflow checks
  uint256 public constant VAR = 1e12;                // The logarithm math used is not precise to the wei, but can deviate up to 1e12 from the real value.

  /**
   * Calculate the amount of fyToken a user would get for given amount of Base.
   * https://www.desmos.com/calculator/5nf2xuy6yb
   * @param baseReserves base reserves amount
   * @param fyTokenReserves fyToken reserves amount
   * @param baseAmount base amount to be traded
   * @param timeTillMaturity time till maturity in seconds
   * @param k time till maturity coefficient, multiplied by 2^64
   * @param g fee coefficient, multiplied by 2^64
   * @return the amount of fyToken a user would get for given amount of Base
   */
  function fyTokenOutForBaseIn(
    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,
    uint128 timeTillMaturity, int128 k, int128 g)
  public pure returns(uint128) {
    unchecked {
      uint128 a = _computeA(timeTillMaturity, k, g);

      // za = baseReserves ** a
      uint256 za = baseReserves.pow(a, ONE);

      // ya = fyTokenReserves ** a
      uint256 ya = fyTokenReserves.pow(a, ONE);

      // zx = baseReserves + baseAmount
      uint256 zx = uint256(baseReserves) + uint256(baseAmount);
      require(zx <= MAX, ""YieldMath: Too much base in"");

      // zxa = zx ** a
      uint256 zxa = uint128(zx).pow(a, ONE);

      // sum = za + ya - zxa
      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.
      require(sum <= MAX, ""YieldMath: Insufficient fyToken reserves"");

      // result = fyTokenReserves - (sum ** (1/a))
      uint256 result = uint256(fyTokenReserves) - uint256(uint128(sum).pow(ONE, a));
      require(result <= MAX, ""YieldMath: Rounding induced error"");

      result = result > VAR ? result - VAR : 0; // Subtract error guard, flooring the result at zero

      return uint128(result);
    }
  }

  /**
   * Calculate the amount of base a user would get for certain amount of fyToken.
   * https://www.desmos.com/calculator/6jlrre7ybt
   * @param baseReserves base reserves amount
   * @param fyTokenReserves fyToken reserves amount
   * @param fyTokenAmount fyToken amount to be traded
   * @param timeTillMaturity time till maturity in seconds
   * @param k time till maturity coefficient, multiplied by 2^64
   * @param g fee coefficient, multiplied by 2^64
   * @return the amount of Base a user would get for given amount of fyToken
   */
  function baseOutForFYTokenIn(
    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,
    uint128 timeTillMaturity, int128 k, int128 g)
  public pure returns(uint128) {
    unchecked {
      uint128 a = _computeA(timeTillMaturity, k, g);

      // za = baseReserves ** a
      uint256 za = baseReserves.pow(a, ONE);

      // ya = fyTokenReserves ** a
      uint256 ya = fyTokenReserves.pow(a, ONE);

      // yx = fyDayReserves + fyTokenAmount
      uint256 yx = uint256(fyTokenReserves) + uint256(fyTokenAmount);
      require(yx <= MAX, ""YieldMath: Too much fyToken in"");

      // yxa = yx ** a
      uint256 yxa = uint128(yx).pow(a, ONE);

      // sum = za + ya - yxa
      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.
      require(sum <= MAX, ""YieldMath: Insufficient base reserves"");

      // result = baseReserves - (sum ** (1/a))
      uint256 result = uint256(baseReserves) - uint256(uint128(sum).pow(ONE, a));
      require(result <= MAX, ""YieldMath: Rounding induced error"");

      result = result > VAR ? result - VAR : 0; // Subtract error guard, flooring the result at zero

      return uint128(result);
    }
  }

  /**
   * Calculate the amount of fyToken a user could sell for given amount of Base.
   * https://www.desmos.com/calculator/0rgnmtckvy
   * @param baseReserves base reserves amount
   * @param fyTokenReserves fyToken reserves amount
   * @param baseAmount Base amount to be traded
   * @param timeTillMaturity time till maturity in seconds
   * @param k time till maturity coefficient, multiplied by 2^64
   * @param g fee coefficient, multiplied by 2^64
   * @return the amount of fyToken a user could sell for given amount of Base
   */
  function fyTokenInForBaseOut(
    uint128 baseReserves, uint128 fyTokenReserves, uint128 baseAmount,
    uint128 timeTillMaturity, int128 k, int128 g)
  public pure returns(uint128) {
    unchecked {
      uint128 a = _computeA(timeTillMaturity, k, g);

      // za = baseReserves ** a
      uint256 za = baseReserves.pow(a, ONE);

      // ya = fyTokenReserves ** a
      uint256 ya = fyTokenReserves.pow(a, ONE);

      // zx = baseReserves - baseAmount
      uint256 zx = uint256(baseReserves) - uint256(baseAmount);
      require(zx <= MAX, ""YieldMath: Too much base out"");

      // zxa = zx ** a
      uint256 zxa = uint128(zx).pow(a, ONE);

      // sum = za + ya - zxa
      uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.
      require(sum <= MAX, ""YieldMath: Resulting fyToken reserves too high"");

      // result = (sum ** (1/a)) - fyTokenReserves
      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(fyTokenReserves);
      require(result <= MAX, ""YieldMath: Rounding induced error"");

      result = result < MAX - VAR ? result + VAR : MAX; // Add error guard, ceiling the result at max

      return uint128(result);
    }
  }

  /**
   * Calculate the amount of base a user would have to pay for certain amount of fyToken.
   * https://www.desmos.com/calculator/ws5oqj8x5i
   * @param baseReserves Base reserves amount
   * @param fyTokenReserves fyToken reserves amount
   * @param fyTokenAmount fyToken amount to be traded
   * @param timeTillMaturity time till maturity in seconds
   * @param k time till maturity coefficient, multiplied by 2^64
   * @param g fee coefficient, multiplied by 2^64
   * @return the amount of base a user would have to pay for given amount of
   *         fyToken
   */
  function baseInForFYTokenOut(
    uint128 baseReserves, uint128 fyTokenReserves, uint128 fyTokenAmount,
    uint128 timeTillMaturity, int128 k, int128 g)
  public pure returns(uint128) {
    unchecked {
      uint128 a = _computeA(timeTillMaturity, k, g);

      // za = baseReserves ** a
      uint256 za = baseReserves.pow(a, ONE);

      // ya = fyTokenReserves ** a
      uint256 ya = fyTokenReserves.pow(a, ONE);

      // yx = baseReserves - baseAmount
      uint256 yx = uint256(fyTokenReserves) - uint256(fyTokenAmount);
      require(yx <= MAX, ""YieldMath: Too much fyToken out"");

      // yxa = yx ** a
      uint256 yxa = uint128(yx).pow(a, ONE);

      // sum = za + ya - yxa
      uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.
      require(sum <= MAX, ""YieldMath: Resulting base reserves too high"");

      // result = (sum ** (1/a)) - baseReserves
      uint256 result = uint256(uint128(sum).pow(ONE, a)) - uint256(baseReserves);
      require(result <= MAX, ""YieldMath: Rounding induced error"");

      result = result < MAX - VAR ? result + VAR : MAX; // Add error guard, ceiling the result at max

      return uint128(result);
    }
  }

  function _computeA(uint128 timeTillMaturity, int128 k, int128 g) private pure returns (uint128) {
    unchecked {
      // t = k * timeTillMaturity
      int128 t = k.mul(timeTillMaturity.fromUInt());
      require(t >= 0, ""YieldMath: t must be positive""); // Meaning neither T or k can be negative

      // a = (1 - gt)
      int128 a = int128(ONE).sub(g.mul(t));
      require(a > 0, ""YieldMath: Too far from maturity"");
      require(a <= int128(ONE), ""YieldMath: g must be positive"");

      return uint128(a);
    }
  }

  /**
   * Estimate in Base the value of reserves at protocol initialization time.
   *
   * @param baseReserves base reserves amount
   * @param fyTokenReserves fyToken reserves amount
   * @param timeTillMaturity time till maturity in seconds
   * @param k time till maturity coefficient, multiplied by 2^64
   * @param c0 price of base in terms of Base, multiplied by 2^64
   * @return estimated value of reserves
   */
  function initialReservesValue(
    uint128 baseReserves, uint128 fyTokenReserves, uint128 timeTillMaturity,
    int128 k, int128 c0)
  external pure returns(uint128) {
    unchecked {
      uint256 normalizedBaseReserves = c0.mulu(baseReserves);
      require(normalizedBaseReserves <= MAX);

      // a = (1 - k * timeTillMaturity)
      int128 a = int128(ONE).sub(k.mul(timeTillMaturity.fromUInt()));
      require(a > 0);

      uint256 sum =
        uint256(uint128(normalizedBaseReserves).pow(uint128(a), ONE)) +
        uint256(fyTokenReserves.pow(uint128(a), ONE)) >> 1;
      require(sum <= MAX);

      uint256 result = uint256(uint128(sum).pow(ONE, uint128(a))) << 1;
      require(result <= MAX);

      return uint128(result);
    }
  }
}",14123
RealWorld_TA_25_RevertMsgExtractor_RealWorld_20240803125354.log,25,RevertMsgExtractor,36406,1215,37621,373.0,0.20633,"// SPDX-License-Identifier: MIT
// Taken from https://github.com/sushiswap/BoringSolidity/blob/441e51c0544cf2451e6116fe00515e71d7c42e2c/contracts/BoringBatchable.sol

pragma solidity >=0.6.0;


library RevertMsgExtractor {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function getRevertMsg(bytes memory returnData)
        internal pure
        returns (string memory)
    {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            returnData := add(returnData, 0x04)
        }
        return abi.decode(returnData, (string)); // All that remains is the revert string
    }
}",218
RealWorld_TA_25_MinimalTransferHelper_RealWorld_20240803132448.log,25,MinimalTransferHelper,37683,1562,39245,374.0,0.219655,"// SPDX-License-Identifier: MIT
// Taken from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol

pragma solidity >=0.6.0;

import ""../../interfaces/external/IERC20.sol"";
import ""../RevertMsgExtractor.sol"";


// helper methods for transferring ERC20 tokens that do not consistently return true/false
library MinimalTransferHelper {
    /// @notice Transfers tokens from msg.sender to a recipient
    /// @dev Errors with the underlying revert message if transfer fails
    /// @param token The contract address of the token which will be transferred
    /// @param to The recipient of the transfer
    /// @param value The value of the transfer
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));
    }
}",236
RealWorld_TA_25_IWETH9_RealWorld_20240803152221.log,25,IWETH9,23952,1211,25163,373.0,0.14398,"// SPDX-License-Identifier: MIT
import ""./IERC20.sol"";

pragma solidity ^0.8.0;


interface IWETH9 is IERC20 {
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);

    function deposit() external payable;
    function withdraw(uint wad) external;
}",74
RealWorld_TA_25_EmergencyBrake_RealWorld_20240803124129.log,25,EmergencyBrake,135618,4063,139681,377.0,0.75935,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;
import ""./access/AccessControl.sol"";


interface IEmergencyBrake {
    function plan(address target, address[] memory contacts, bytes4[][] memory permissions) external returns (bytes32 txHash);
    function cancel(address target, address[] memory contacts, bytes4[][] memory permissions) external;
    function execute(address target, address[] memory contacts, bytes4[][] memory permissions) external;
    function restore(address target, address[] memory contacts, bytes4[][] memory permissions) external;
    function terminate(address target, address[] memory contacts, bytes4[][] memory permissions) external;
}

/// @dev EmergencyBrake allows to plan for and execute transactions that remove access permissions for a target
/// contract. In an permissioned environment this can be used for pausing components.
/// All contracts in scope of emergency plans must grant ROOT permissions to EmergencyBrake. To mitigate the risk
/// of governance capture, EmergencyBrake has very limited functionality, being able only to revoke existing roles
/// and to restore previously revoked roles. Thus EmergencyBrake cannot grant permissions that weren't there in the 
/// first place. As an additional safeguard, EmergencyBrake cannot revoke or grant ROOT roles.
/// In addition, there is a separation of concerns between the planner and the executor accounts, so that both of them
/// must be compromised simultaneously to execute non-approved emergency plans, and then only creating a denial of service.
contract EmergencyBrake is AccessControl, IEmergencyBrake {
    enum State {UNKNOWN, PLANNED, EXECUTED, TERMINATED}

    event Planned(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);
    event Cancelled(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);
    event Executed(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);
    event Restored(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);
    event Terminated(bytes32 indexed txHash, address indexed target, address[] indexed contacts, bytes4[][] permissions);

    mapping (bytes32 => State) public plans;

    constructor(address planner, address executor) AccessControl() {
        _grantRole(IEmergencyBrake.plan.selector, planner);
        _grantRole(IEmergencyBrake.cancel.selector, planner);
        _grantRole(IEmergencyBrake.execute.selector, executor);
        _grantRole(IEmergencyBrake.restore.selector, planner);
        _grantRole(IEmergencyBrake.terminate.selector, planner);

        // Granting roles (plan, cancel, execute, restore, terminate) is reserved to ROOT
    }

    /// @dev Register an access removal transaction
    function plan(address target, address[] memory contacts, bytes4[][] memory permissions)
        external override auth
        returns (bytes32 txHash)
    {
        require(contacts.length == permissions.length, ""Mismatched inputs"");
        // Removing or granting ROOT permissions is out of bounds for EmergencyBrake
        for (uint256 i = 0; i < contacts.length; i++){
            for (uint256 j = 0; j < permissions[i].length; j++){
                require(
                    permissions[i][j] != ROOT,
                    ""Can't remove ROOT""
                );
            }
        }
        txHash = keccak256(abi.encode(target, contacts, permissions));
        require(plans[txHash] == State.UNKNOWN, ""Emergency already planned for."");
        plans[txHash] = State.PLANNED;
        emit Planned(txHash, target, contacts, permissions);
    }

    /// @dev Erase a planned access removal transaction
    function cancel(address target, address[] memory contacts, bytes4[][] memory permissions)
        external override auth
    {
        require(contacts.length == permissions.length, ""Mismatched inputs"");
        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));
        require(plans[txHash] == State.PLANNED, ""Emergency not planned for."");
        plans[txHash] = State.UNKNOWN;
        emit Cancelled(txHash, target, contacts, permissions);
    }

    /// @dev Execute an access removal transaction
    function execute(address target, address[] memory contacts, bytes4[][] memory permissions)
        external override auth
    {
        require(contacts.length == permissions.length, ""Mismatched inputs"");
        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));
        require(plans[txHash] == State.PLANNED, ""Emergency not planned for."");
        plans[txHash] = State.EXECUTED;

        for (uint256 i = 0; i < contacts.length; i++){
            // AccessControl.sol doesn't revert if revoking permissions that haven't been granted
            // If we don't check, planner and executor can collude to gain access to contacts
            for (uint256 j = 0; j < permissions[i].length; j++){
                require(
                    AccessControl(contacts[i]).hasRole(permissions[i][j], target),
                    ""Permission not found""
                );
            }
            // Now revoke the permissions
            AccessControl(contacts[i]).revokeRoles(permissions[i], target);
        }
        emit Executed(txHash, target, contacts, permissions);
    }

    /// @dev Restore the orchestration from an isolated target
    function restore(address target, address[] memory contacts, bytes4[][] memory permissions)
        external override auth
    {
        require(contacts.length == permissions.length, ""Mismatched inputs"");
        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));
        require(plans[txHash] == State.EXECUTED, ""Emergency plan not executed."");
        plans[txHash] = State.PLANNED;

        for (uint256 i = 0; i < contacts.length; i++){
            AccessControl(contacts[i]).grantRoles(permissions[i], target);
        }
        emit Restored(txHash, target, contacts, permissions);
    }

    /// @dev Remove the restoring option from an isolated target
    function terminate(address target, address[] memory contacts, bytes4[][] memory permissions)
        external override auth
    {
        require(contacts.length == permissions.length, ""Mismatched inputs"");
        bytes32 txHash = keccak256(abi.encode(target, contacts, permissions));
        require(plans[txHash] == State.EXECUTED, ""Emergency plan not executed."");
        plans[txHash] = State.TERMINATED;
        emit Terminated(txHash, target, contacts, permissions);
    }
}",1390
RealWorld_TA_25_WDiv_RealWorld_20240803141416.log,25,WDiv,28363,2459,30822,364.0,0.190995,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library WDiv { // Fixed point arithmetic in 18 decimal units
    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol
    /// @dev Divide an amount by a fixed point factor with 18 decimals
    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = (x * 1e18) / y;
    }
}",113
RealWorld_TA_25_PoolDataTypes_RealWorld_20240803150347.log,25,PoolDataTypes,25601,1312,26913,370.0,0.154245,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.8.0;


library PoolDataTypes {
  enum Operation {
    ROUTE, // 0
    TRANSFER_TO_POOL, // 1
    FORWARD_PERMIT, // 2
    FORWARD_DAI_PERMIT, // 3
    JOIN_ETHER, // 4
    EXIT_ETHER // 5
  }
}",84
RealWorld_TA_25_CompositeMultiOracle_RealWorld_20240803115155.log,25,CompositeMultiOracle,135531,4117,139648,380.0,0.759995,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../../utils/access/AccessControl.sol"";
import ""../../interfaces/vault/IOracle.sol"";
import ""../../math/CastBytes32Bytes6.sol"";


/**
 * @title CompositeMultiOracle
 */
contract CompositeMultiOracle is IOracle, AccessControl {
    using CastBytes32Bytes6 for bytes32;

    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals

    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);
    event PathSet(bytes6 indexed baseId, bytes6 indexed quoteId, bytes6[] indexed path);

    struct Source {
        address source;
        uint8 decimals;
    }

    mapping(bytes6 => mapping(bytes6 => Source)) public sources;
    mapping(bytes6 => mapping(bytes6 => bytes6[])) public paths;

    /**
     * @notice Set or reset an oracle source
     */
    function setSource(bytes6 base, bytes6 quote, address source) external auth {
        _setSource(base, quote, source);
    }

    /**
     * @notice Set or reset a number of oracle sources
     */
    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {
        require(
            bases.length == quotes.length && 
            bases.length == sources_.length,
            ""Mismatched inputs""
        );
        for (uint256 i = 0; i < bases.length; i++) {
            _setSource(bases[i], quotes[i], sources_[i]);
        }
    }

    /**
     * @notice Set or reset an price path
     */
    function setPath(bytes6 base, bytes6 quote, bytes6[] memory path) external auth {
        _setPath(base, quote, path);
    }

    /**
     * @notice Set or reset a number of price paths
     */
    function setPaths(bytes6[] memory bases, bytes6[] memory quotes, bytes6[][] memory paths_) external auth {
        require(
            bases.length == quotes.length && 
            bases.length == paths_.length,
            ""Mismatched inputs""
        );
        for (uint256 i = 0; i < bases.length; i++) {
            _setPath(bases[i], quotes[i], paths_[i]);
        }
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function peek(bytes32 base, bytes32 quote, uint256 amount)
        external view virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price = 1e18;
        bytes6 base_ = base.b6();
        bytes6 quote_ = quote.b6();
        bytes6[] memory path = paths[base_][quote_];
        for (uint256 p = 0; p < path.length; p++) {
            (price, updateTime) = _peek(base_, path[p], price, updateTime);
            base_ = path[p];
        }
        (price, updateTime) = _peek(base_, quote_, price, updateTime);
        value = price * amount / 1e18;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.
     * @return value
     */
    function get(bytes32 base, bytes32 quote, uint256 amount)
        external virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price = 1e18;
        bytes6 base_ = base.b6();
        bytes6 quote_ = quote.b6();
        bytes6[] memory path = paths[base_][quote_];
        for (uint256 p = 0; p < path.length; p++) {
            (price, updateTime) = _get(base_, path[p], price, updateTime);
            base_ = path[p];
        }
        (price, updateTime) = _get(base_, quote_, price, updateTime);
        value = price * amount / 1e18;
    }

    function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)
        private view returns (uint priceOut, uint updateTimeOut)
    {
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");
        (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit
        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals
        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time
    }

    function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)
        private returns (uint priceOut, uint updateTimeOut)
    {
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");
        (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit
        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals
        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time
    }

    function _setSource(bytes6 base, bytes6 quote, address source) internal {
        uint8 decimals_ = IOracle(source).decimals();
        require (decimals_ <= 18, ""Unsupported decimals"");
        sources[base][quote] = Source({
            source: source,
            decimals: decimals_
        });
        emit SourceSet(base, quote, source);
    }

    function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {
        bytes6 base_ = base;
        for (uint256 p = 0; p < path.length; p++) {
            require (sources[base_][path[p]].source != address(0), ""Source not found"");
            base_ = path[p];
        }
        paths[base][quote] = path;
        emit PathSet(base, quote, path);
    }
}",1345
RealWorld_TA_25_CompoundMultiOracle_RealWorld_20240803122255.log,25,CompoundMultiOracle,76669,3137,79806,373.0,0.446085,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../../utils/access/AccessControl.sol"";
import ""../../interfaces/vault/IOracle.sol"";
import ""../../constants/Constants.sol"";
import ""../../math/CastBytes32Bytes6.sol"";
import ""./CTokenInterface.sol"";


contract CompoundMultiOracle is IOracle, AccessControl, Constants {
    using CastBytes32Bytes6 for bytes32;

    event SourceSet(bytes6 indexed baseId, bytes6 indexed kind, address indexed source);

    uint public constant SCALE_FACTOR = 1; // I think we don't need scaling for rate and chi oracles
    uint8 public constant override decimals = 18;

    mapping(bytes6 => mapping(bytes6 => address)) public sources;

    /**
     * @notice Set or reset one source
     */
    function setSource(bytes6 base, bytes6 kind, address source) external auth {
        _setSource(base, kind, source);
    }

    /**
     * @notice Set or reset an oracle source
     */
    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) external auth {
        require(bases.length == kinds.length && kinds.length == sources_.length, ""Mismatched inputs"");
        for (uint256 i = 0; i < bases.length; i++)
            _setSource(bases[i], kinds[i], sources_[i]);
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function peek(bytes32 base, bytes32 kind, uint256 amount)
        external view virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), kind.b6());
        value = price * amount / 1e18;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.
     * @return value
     */
    function get(bytes32 base, bytes32 kind, uint256 amount)
        external virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), kind.b6());
        value = price * amount / 1e18;
    }

    function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {
        uint256 rawPrice;
        address source = sources[base][kind];
        require (source != address(0), ""Source not found"");

        if (kind == RATE.b6()) rawPrice = CTokenInterface(source).borrowIndex();
        else if (kind == CHI.b6()) rawPrice = CTokenInterface(source).exchangeRateStored();
        else revert(""Unknown oracle type"");

        require(rawPrice > 0, ""Compound price is zero"");

        price = rawPrice * SCALE_FACTOR;
        updateTime = block.timestamp;
    }

    function _setSource(bytes6 base, bytes6 kind, address source) internal {
        sources[base][kind] = source;
        emit SourceSet(base, kind, source);
    }
}",671
RealWorld_TA_25_AggregatorV3Interface_RealWorld_20240803115817.log,25,AggregatorV3Interface,35688,1543,37231,364.0,0.2093,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

interface AggregatorV3Interface {

  function decimals() external view returns (uint8);
  function description() external view returns (string memory);
  function version() external view returns (uint256);

  // getRoundData and latestRoundData should both raise ""No data present""
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

}",200
RealWorld_TA_25_WDivUp_RealWorld_20240803143856.log,25,WDivUp,36356,1818,38174,373.0,0.21814,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library WDivUp { // Fixed point arithmetic in 18 decimal units
    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol
    /// @dev Divide x and y, with y being fixed point. If both are integers, the result is a fixed point factor. Rounds up.
    function wdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x * 1e18 + y;            // 101 (1.01) / 1000 (10) -> (101 * 100 + 1000 - 1) / 1000 -> 11 (0.11 = 0.101 rounded up).
        unchecked { z -= 1; }       // Can do unchecked subtraction since division in next line will catch y = 0 case anyway
        z /= y;
    }
}",210
RealWorld_TA_25_TimeLock_RealWorld_20240803124748.log,25,TimeLock,103074,3300,106374,364.0,0.58137,"// SPDX-License-Identifier: MIT
// Inspired on TimeLock.sol from Compound.

pragma solidity ^0.8.0;
import ""./access/AccessControl.sol"";
import ""./RevertMsgExtractor.sol"";

interface ITimeLock {
    function setDelay(uint256 delay_) external;
    function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta) external returns (bytes32 txHash);
    function cancel(address[] calldata targets, bytes[] calldata data) external;
    function execute(address[] calldata targets, bytes[] calldata data) external returns (bytes[] calldata results);
}

contract TimeLock is ITimeLock, AccessControl {

    uint256 public constant GRACE_PERIOD = 14 days;
    uint256 public constant MINIMUM_DELAY = 2 days;
    uint256 public constant MAXIMUM_DELAY = 30 days;

    event DelaySet(uint256 indexed delay);
    event Cancelled(bytes32 indexed txHash, address[] indexed targets, bytes[] data);
    event Executed(bytes32 indexed txHash, address[] indexed targets, bytes[] data);
    event Scheduled(bytes32 indexed txHash, address[] indexed targets, bytes[] data, uint256 eta);

    uint256 public delay;
    mapping (bytes32 => uint256) public transactions;

    constructor(address scheduler, address executor) AccessControl() {
        delay = MINIMUM_DELAY;

        // scheduler can schedule and cancel, executor can execute
        _grantRole(ITimeLock.schedule.selector, scheduler); // bytes4(keccak256(""schedule(address[],bytes[],uint256)""))
        _grantRole(ITimeLock.cancel.selector, scheduler); // bytes4(keccak256(""cancel(address[],bytes[],uint256)""))
        _grantRole(ITimeLock.execute.selector, executor); // bytes4(keccak256(""execute(address[],bytes[],uint256)""))

        // Changing the delay must now be executed through this TimeLock contract
        _grantRole(ITimeLock.setDelay.selector, address(this)); // bytes4(keccak256(""setDelay(uint256)""))

        // Granting roles (schedule, cancel, execute, setDelay) must now be executed through this TimeLock contract
        _grantRole(ROOT, address(this));
        _revokeRole(ROOT, msg.sender);
    }

    /// @dev Change the delay for queueing and executing transactions
    function setDelay(uint256 delay_) external override auth {
        require(delay_ >= MINIMUM_DELAY, ""Must exceed minimum delay."");
        require(delay_ <= MAXIMUM_DELAY, ""Must not exceed maximum delay."");
        delay = delay_;

        emit DelaySet(delay);
    }

    /// @dev Schedule a transaction batch for execution between `eta` and `eta + GRACE_PERIOD`
    function schedule(address[] calldata targets, bytes[] calldata data, uint256 eta)
        external override auth returns (bytes32 txHash)
    {
        require(targets.length == data.length, ""Mismatched inputs"");
        require(eta >= block.timestamp + delay, ""Must satisfy delay.""); // This also prevents setting eta = 0 and messing up the state
        txHash = keccak256(abi.encode(targets, data));
        require(transactions[txHash] == 0, ""Transaction not unknown."");
        transactions[txHash] = eta;
        emit Scheduled(txHash, targets, data, eta);
    }

    /// @dev Cancel a scheduled transaction batch
    function cancel(address[] calldata targets, bytes[] calldata data)
        external override auth
    {
        require(targets.length == data.length, ""Mismatched inputs"");
        bytes32 txHash = keccak256(abi.encode(targets, data));
        require(transactions[txHash] != 0, ""Transaction hasn't been scheduled."");
        delete transactions[txHash];
        emit Cancelled(txHash, targets, data);
    }

    /// @dev Execute a transaction batch
    function execute(address[] calldata targets, bytes[] calldata data)
        external override auth returns (bytes[] memory results)
    {
        require(targets.length == data.length, ""Mismatched inputs"");
        bytes32 txHash = keccak256(abi.encode(targets, data));
        uint256 eta = transactions[txHash];

        require(eta != 0, ""Transaction hasn't been scheduled."");
        require(block.timestamp >= eta, ""ETA not reached."");
        require(block.timestamp <= eta + GRACE_PERIOD, ""Transaction is stale."");

        delete transactions[txHash];

        results = new bytes[](targets.length);
        for (uint256 i = 0; i < targets.length; i++){
            (bool success, bytes memory result) = targets[i].call(data[i]);
            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));
            results[i] = result;
        }
        emit Executed(txHash, targets, data);
    }
}",999
RealWorld_TA_25_IERC20_RealWorld_20240803151000.log,25,IERC20,69378,1497,70875,364.0,0.37683,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",611
RealWorld_TA_25_FYToken_RealWorld_20240803105616.log,25,FYToken,185387,6107,191494,377.0,1.049075,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""erc3156/contracts/interfaces/IERC3156FlashBorrower.sol"";
import ""erc3156/contracts/interfaces/IERC3156FlashLender.sol"";
import ""./utils/token/ERC20Permit.sol"";
import ""./utils/token/SafeERC20Namer.sol"";
import ""./interfaces/vault/IFYToken.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/vault/IOracle.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./math/WMul.sol"";
import ""./math/WDiv.sol"";
import ""./math/CastU256U128.sol"";
import ""./math/CastU256U32.sol"";
import ""./constants/Constants.sol"";


contract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit, Constants {
    using WMul for uint256;
    using WDiv for uint256;
    using CastU256U128 for uint256;
    using CastU256U32 for uint256;

    event SeriesMatured(uint256 chiAtMaturity);
    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);
    event OracleSet(address indexed oracle);

    uint256 constant CHI_NOT_SET = type(uint256).max;

    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years
    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(""ERC3156FlashBorrower.onFlashLoan"");

    IOracle public oracle;                                      // Oracle for the savings rate.
    IJoin public immutable join;                                // Source of redemption funds.
    address public immutable override underlying;
    bytes6 public immutable underlyingId;                             // Needed to access the oracle
    uint256 public immutable override maturity;
    uint256 public chiAtMaturity = CHI_NOT_SET;           // Spot price (exchange rate) between the base and an interest accruing token at maturity 

    constructor(
        bytes6 underlyingId_,
        IOracle oracle_, // Underlying vs its interest-bearing version
        IJoin join_,
        uint256 maturity_,
        string memory name,
        string memory symbol
    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) { // The join asset is this fyToken's underlying, from which we inherit the decimals
        uint256 now_ = block.timestamp;
        require(
            maturity_ > now_ &&
            maturity_ < now_ + MAX_TIME_TO_MATURITY &&
            maturity_ < type(uint32).max,
            ""Invalid maturity""
        );

        underlyingId = underlyingId_;
        join = join_;
        maturity = maturity_;
        underlying = address(IJoin(join_).asset());
        oracle = oracle_;
        emit OracleSet(address(oracle_));
    }

    modifier afterMaturity() {
        require(
            uint32(block.timestamp) >= maturity,
            ""Only after maturity""
        );
        _;
    }

    modifier beforeMaturity() {
        require(
            uint32(block.timestamp) < maturity,
            ""Only before maturity""
        );
        _;
    }

    /// @dev Set the oracle parameter
    function setOracle(IOracle oracle_)
        external
        auth    
    {
        oracle = oracle_;
        emit OracleSet(address(oracle_));
    }

    /// @dev Mature the fyToken by recording the chi.
    /// If called more than once, it will revert.
    function mature()
        external override
        afterMaturity
    {
        require (chiAtMaturity == CHI_NOT_SET, ""Already matured"");
        _mature();
    }

    /// @dev Mature the fyToken by recording the chi.
    function _mature() 
        private
        returns (uint256 _chiAtMaturity)
    {
        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);
        chiAtMaturity = _chiAtMaturity;
        emit SeriesMatured(_chiAtMaturity);
    }

    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.
    function accrual()
        external
        afterMaturity
        returns (uint256)
    {
        return _accrual();
    }

    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.
    /// Note: Call only after checking we are past maturity
    function _accrual()
        private
        returns (uint256 accrual_)
    {
        if (chiAtMaturity == CHI_NOT_SET) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.
            _mature();
        } else {
            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);
            accrual_ = chi.wdiv(chiAtMaturity);
        }
        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)
    }

    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`
    function redeem(address to, uint256 amount)
        external override
        afterMaturity
        returns (uint256 redeemed)
    {
        _burn(msg.sender, amount);
        redeemed = amount.wmul(_accrual());
        join.exit(to, redeemed.u128());
        
        emit Redeemed(msg.sender, to, amount, redeemed);
    }

    /// @dev Mint fyTokens.
    function mint(address to, uint256 amount)
        external override
        beforeMaturity
        auth
    {
        _mint(to, amount);
    }

    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. 
    function burn(address from, uint256 amount)
        external override
        auth
    {
        _burn(from, amount);
    }

    /// @dev Burn fyTokens. 
    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.
    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.
    function _burn(address from, uint256 amount)
        internal override
        returns (bool)
    {
        // First use any tokens locked in this contract
        uint256 available = _balanceOf[address(this)];
        if (available >= amount) {
            return super._burn(address(this), amount);
        } else {
            if (available > 0 ) super._burn(address(this), available);
            unchecked { _decreaseAllowance(from, amount - available); }
            unchecked { return super._burn(from, amount - available); }
        }
    }

    /**
     * @dev From ERC-3156. The amount of currency available to be lended.
     * @param token The loan currency. It must be a FYDai contract.
     * @return The amount of `token` that can be borrowed.
     */
    function maxFlashLoan(address token)
        external view override
        beforeMaturity
        returns (uint256)
    {
        return token == address(this) ? type(uint256).max - _totalSupply : 0;
    }

    /**
     * @dev From ERC-3156. The fee to be charged for a given loan.
     * @param token The loan currency. It must be a FYDai.
     * param amount The amount of tokens lent.
     * @return The amount of `token` to be charged for the loan, on top of the returned principal.
     */
    function flashFee(address token, uint256)
        external view override
        beforeMaturity
        returns (uint256)
    {
        require(token == address(this), ""Unsupported currency"");
        return 0;
    }

    /**
     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.
     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.
     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.
     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.
     * @param token The loan currency. Must be a fyDai contract.
     * @param amount The amount of tokens lent.
     * @param data A data parameter to be passed on to the `receiver` for any custom use.
     */
    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)
        external override
        beforeMaturity
        returns(bool)
    {
        require(token == address(this), ""Unsupported currency"");
        _mint(address(receiver), amount);
        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, ""Non-compliant borrower"");
        _burn(address(receiver), amount);
        return true;
    }
}",1969
RealWorld_TA_25_CastI128U128_RealWorld_20240803140810.log,25,CastI128U128,25521,1331,26852,364.0,0.154225,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library CastI128U128 {
    /// @dev Safely cast an int128 to an uint128
    function u128(int128 x) internal pure returns (uint128 y) {
        require (x >= 0, ""Cast overflow"");
        y = uint128(x);
    }
}",82
RealWorld_TA_25_Math64x64_RealWorld_20240803112103.log,25,Math64x64,747845,68,747913,365.0,3.740585,"// SPDX-License-Identifier: BUSL-1.1
/*
 *  Math 64.64 Smart Contract Library.  Copyright © 2019 by  Consulting.
 * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>
 */
pragma solidity 0.8.1;

/**
 * Smart contract library of mathematical functions operating with signed
 * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is
 * basically a simple fraction whose numerator is signed 128-bit integer and
 * denominator is 2^64.  As long as denominator is always the same, there is no
 * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are
 * represented by int128 type holding only the numerator.
 */
library Math64x64 {
  /*
   * Minimum value signed 64.64-bit fixed point number may have. 
   */
  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;

  /*
   * Maximum value signed 64.64-bit fixed point number may have. 
   */
  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

  /**
   * Convert signed 256-bit integer number into signed 64.64-bit fixed point
   * number.  Revert on overflow.
   *
   * @param x signed 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function fromInt (int256 x) internal pure returns (int128) {
    unchecked {
      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);
      return int128 (x << 64);
    }
  }

  /**
   * Convert signed 64.64 fixed point number into signed 64-bit integer number
   * rounding down.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64-bit integer number
   */
  function toInt (int128 x) internal pure returns (int64) {
    unchecked {
      return int64 (x >> 64);
    }
  }

  /**
   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point
   * number.  Revert on overflow.
   *
   * @param x unsigned 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function fromUInt (uint256 x) internal pure returns (int128) {
    unchecked {
      require (x <= 0x7FFFFFFFFFFFFFFF);
      return int128 (int256 (x << 64));
    }
  }

  /**
   * Convert signed 64.64 fixed point number into unsigned 64-bit integer
   * number rounding down.  Revert on underflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return unsigned 64-bit integer number
   */
  function toUInt (int128 x) internal pure returns (uint64) {
    unchecked {
      require (x >= 0);
      return uint64 (uint128 (x >> 64));
    }
  }

  /**
   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point
   * number rounding down.  Revert on overflow.
   *
   * @param x signed 128.128-bin fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function from128x128 (int256 x) internal pure returns (int128) {
    unchecked {
      int256 result = x >> 64;
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Convert signed 64.64 fixed point number into signed 128.128 fixed point
   * number.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 128.128 fixed point number
   */
  function to128x128 (int128 x) internal pure returns (int256) {
    unchecked {
      return int256 (x) << 64;
    }
  }

  /**
   * Calculate x + y.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function add (int128 x, int128 y) internal pure returns (int128) {
    unchecked {
      int256 result = int256(x) + y;
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Calculate x - y.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function sub (int128 x, int128 y) internal pure returns (int128) {
    unchecked {
      int256 result = int256(x) - y;
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Calculate x * y rounding down.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function mul (int128 x, int128 y) internal pure returns (int128) {
    unchecked {
      int256 result = int256(x) * y >> 64;
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point
   * number and y is signed 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64 fixed point number
   * @param y signed 256-bit integer number
   * @return signed 256-bit integer number
   */
  function muli (int128 x, int256 y) internal pure returns (int256) {
    unchecked {
      if (x == MIN_64x64) {
        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&
          y <= 0x1000000000000000000000000000000000000000000000000);
        return -y << 63;
      } else {
        bool negativeResult = false;
        if (x < 0) {
          x = -x;
          negativeResult = true;
        }
        if (y < 0) {
          y = -y; // We rely on overflow behavior here
          negativeResult = !negativeResult;
        }
        uint256 absoluteResult = mulu (x, uint256 (y));
        if (negativeResult) {
          require (absoluteResult <=
            0x8000000000000000000000000000000000000000000000000000000000000000);
          return -int256 (absoluteResult); // We rely on overflow behavior here
        } else {
          require (absoluteResult <=
            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
          return int256 (absoluteResult);
        }
      }
    }
  }

  /**
   * Calculate x * y rounding down, where x is signed 64.64 fixed point number
   * and y is unsigned 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64 fixed point number
   * @param y unsigned 256-bit integer number
   * @return unsigned 256-bit integer number
   */
  function mulu (int128 x, uint256 y) internal pure returns (uint256) {
    unchecked {
      if (y == 0) return 0;

      require (x >= 0);

      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;
      uint256 hi = uint256 (int256 (x)) * (y >> 128);

      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
      hi <<= 64;

      require (hi <=
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);
      return hi + lo;
    }
  }

  /**
   * Calculate x / y rounding towards zero.  Revert on overflow or when y is
   * zero.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function div (int128 x, int128 y) internal pure returns (int128) {
    unchecked {
      require (y != 0);
      int256 result = (int256 (x) << 64) / y;
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are signed 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x signed 256-bit integer number
   * @param y signed 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function divi (int256 x, int256 y) internal pure returns (int128) {
    unchecked {
      require (y != 0);

      bool negativeResult = false;
      if (x < 0) {
        x = -x; // We rely on overflow behavior here
        negativeResult = true;
      }
      if (y < 0) {
        y = -y; // We rely on overflow behavior here
        negativeResult = !negativeResult;
      }
      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));
      if (negativeResult) {
        require (absoluteResult <= 0x80000000000000000000000000000000);
        return -int128 (absoluteResult); // We rely on overflow behavior here
      } else {
        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
        return int128 (absoluteResult); // We rely on overflow behavior here
      }
    }
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x unsigned 256-bit integer number
   * @param y unsigned 256-bit integer number
   * @return signed 64.64-bit fixed point number
   */
  function divu (uint256 x, uint256 y) internal pure returns (int128) {
    unchecked {
      require (y != 0);
      uint128 result = divuu (x, y);
      require (result <= uint128 (MAX_64x64));
      return int128 (result);
    }
  }

  /**
   * Calculate -x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function neg (int128 x) internal pure returns (int128) {
    unchecked {
      require (x != MIN_64x64);
      return -x;
    }
  }

  /**
   * Calculate |x|.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function abs (int128 x) internal pure returns (int128) {
    unchecked {
      require (x != MIN_64x64);
      return x < 0 ? -x : x;
    }
  }

  /**
   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is
   * zero.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function inv (int128 x) internal pure returns (int128) {
    unchecked {
      require (x != 0);
      int256 result = int256 (0x100000000000000000000000000000000) / x;
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function avg (int128 x, int128 y) internal pure returns (int128) {
    unchecked {
      return int128 ((int256 (x) + int256 (y)) >> 1);
    }
  }

  /**
   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.
   * Revert on overflow or in case x * y is negative.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function gavg (int128 x, int128 y) internal pure returns (int128) {
    unchecked {
      int256 m = int256 (x) * int256 (y);
      require (m >= 0);
      require (m <
          0x4000000000000000000000000000000000000000000000000000000000000000);
      return int128 (sqrtu (uint256 (m)));
    }
  }

  /**
   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number
   * and y is unsigned 256-bit integer number.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @param y uint256 value
   * @return signed 64.64-bit fixed point number
   */
  function pow (int128 x, uint256 y) internal pure returns (int128) {
    unchecked {
      bool negative = x < 0 && y & 1 == 1;

      uint256 absX = uint128 (x < 0 ? -x : x);
      uint256 absResult;
      absResult = 0x100000000000000000000000000000000;

      if (absX <= 0x10000000000000000) {
        absX <<= 63;
        while (y != 0) {
          if (y & 0x1 != 0) {
            absResult = absResult * absX >> 127;
          }
          absX = absX * absX >> 127;

          if (y & 0x2 != 0) {
            absResult = absResult * absX >> 127;
          }
          absX = absX * absX >> 127;

          if (y & 0x4 != 0) {
            absResult = absResult * absX >> 127;
          }
          absX = absX * absX >> 127;

          if (y & 0x8 != 0) {
            absResult = absResult * absX >> 127;
          }
          absX = absX * absX >> 127;

          y >>= 4;
        }

        absResult >>= 64;
      } else {
        uint256 absXShift = 63;
        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }
        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }
        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }
        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }
        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }
        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }

        uint256 resultShift = 0;
        while (y != 0) {
          require (absXShift < 64);

          if (y & 0x1 != 0) {
            absResult = absResult * absX >> 127;
            resultShift += absXShift;
            if (absResult > 0x100000000000000000000000000000000) {
              absResult >>= 1;
              resultShift += 1;
            }
          }
          absX = absX * absX >> 127;
          absXShift <<= 1;
          if (absX >= 0x100000000000000000000000000000000) {
              absX >>= 1;
              absXShift += 1;
          }

          y >>= 1;
        }

        require (resultShift < 64);
        absResult >>= 64 - resultShift;
      }
      int256 result = negative ? -int256 (absResult) : int256 (absResult);
      require (result >= MIN_64x64 && result <= MAX_64x64);
      return int128 (result);
    }
  }

  /**
   * Calculate sqrt (x) rounding down.  Revert if x < 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function sqrt (int128 x) internal pure returns (int128) {
    unchecked {
      require (x >= 0);
      return int128 (sqrtu (uint256 (int256 (x)) << 64));
    }
  }

  /**
   * Calculate binary logarithm of x.  Revert if x <= 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function log_2 (int128 x) internal pure returns (int128) {
    unchecked {
      require (x > 0);

      int256 msb = 0;
      int256 xc = x;
      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }
      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }
      if (xc >= 0x10000) { xc >>= 16; msb += 16; }
      if (xc >= 0x100) { xc >>= 8; msb += 8; }
      if (xc >= 0x10) { xc >>= 4; msb += 4; }
      if (xc >= 0x4) { xc >>= 2; msb += 2; }
      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore

      int256 result = msb - 64 << 64;
      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);
      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {
        ux *= ux;
        uint256 b = ux >> 255;
        ux >>= 127 + b;
        result += bit * int256 (b);
      }

      return int128 (result);
    }
  }

  /**
   * Calculate natural logarithm of x.  Revert if x <= 0.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function ln (int128 x) internal pure returns (int128) {
    unchecked {
      require (x > 0);

      return int128 (int256 (
          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));
    }
  }

  /**
   * Calculate binary exponent of x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function exp_2 (int128 x) internal pure returns (int128) {
    unchecked {
      require (x < 0x400000000000000000); // Overflow

      if (x < -0x400000000000000000) return 0; // Underflow

      uint256 result = 0x80000000000000000000000000000000;

      if (x & 0x8000000000000000 > 0)
        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;
      if (x & 0x4000000000000000 > 0)
        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;
      if (x & 0x2000000000000000 > 0)
        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;
      if (x & 0x1000000000000000 > 0)
        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;
      if (x & 0x800000000000000 > 0)
        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;
      if (x & 0x400000000000000 > 0)
        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;
      if (x & 0x200000000000000 > 0)
        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;
      if (x & 0x100000000000000 > 0)
        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;
      if (x & 0x80000000000000 > 0)
        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;
      if (x & 0x40000000000000 > 0)
        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;
      if (x & 0x20000000000000 > 0)
        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;
      if (x & 0x10000000000000 > 0)
        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;
      if (x & 0x8000000000000 > 0)
        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;
      if (x & 0x4000000000000 > 0)
        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;
      if (x & 0x2000000000000 > 0)
        result = result * 0x1000162E525EE054754457D5995292026 >> 128;
      if (x & 0x1000000000000 > 0)
        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;
      if (x & 0x800000000000 > 0)
        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;
      if (x & 0x400000000000 > 0)
        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;
      if (x & 0x200000000000 > 0)
        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;
      if (x & 0x100000000000 > 0)
        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;
      if (x & 0x80000000000 > 0)
        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;
      if (x & 0x40000000000 > 0)
        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;
      if (x & 0x20000000000 > 0)
        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;
      if (x & 0x10000000000 > 0)
        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;
      if (x & 0x8000000000 > 0)
        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;
      if (x & 0x4000000000 > 0)
        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;
      if (x & 0x2000000000 > 0)
        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;
      if (x & 0x1000000000 > 0)
        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;
      if (x & 0x800000000 > 0)
        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;
      if (x & 0x400000000 > 0)
        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;
      if (x & 0x200000000 > 0)
        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;
      if (x & 0x100000000 > 0)
        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;
      if (x & 0x80000000 > 0)
        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;
      if (x & 0x40000000 > 0)
        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;
      if (x & 0x20000000 > 0)
        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;
      if (x & 0x10000000 > 0)
        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;
      if (x & 0x8000000 > 0)
        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;
      if (x & 0x4000000 > 0)
        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;
      if (x & 0x2000000 > 0)
        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;
      if (x & 0x1000000 > 0)
        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;
      if (x & 0x800000 > 0)
        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;
      if (x & 0x400000 > 0)
        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;
      if (x & 0x200000 > 0)
        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;
      if (x & 0x100000 > 0)
        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;
      if (x & 0x80000 > 0)
        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;
      if (x & 0x40000 > 0)
        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;
      if (x & 0x20000 > 0)
        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;
      if (x & 0x10000 > 0)
        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;
      if (x & 0x8000 > 0)
        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;
      if (x & 0x4000 > 0)
        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;
      if (x & 0x2000 > 0)
        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;
      if (x & 0x1000 > 0)
        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;
      if (x & 0x800 > 0)
        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;
      if (x & 0x400 > 0)
        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;
      if (x & 0x200 > 0)
        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;
      if (x & 0x100 > 0)
        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;
      if (x & 0x80 > 0)
        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;
      if (x & 0x40 > 0)
        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;
      if (x & 0x20 > 0)
        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;
      if (x & 0x10 > 0)
        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;
      if (x & 0x8 > 0)
        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;
      if (x & 0x4 > 0)
        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;
      if (x & 0x2 > 0)
        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;
      if (x & 0x1 > 0)
        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;

      result >>= uint256 (int256 (63 - (x >> 64)));
      require (result <= uint256 (int256 (MAX_64x64)));

      return int128 (int256 (result));
    }
  }

  /**
   * Calculate natural exponent of x.  Revert on overflow.
   *
   * @param x signed 64.64-bit fixed point number
   * @return signed 64.64-bit fixed point number
   */
  function exp (int128 x) internal pure returns (int128) {
    unchecked {
      require (x < 0x400000000000000000); // Overflow

      if (x < -0x400000000000000000) return 0; // Underflow

      return exp_2 (
          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));
    }
  }

  /**
   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit
   * integer numbers.  Revert on overflow or when y is zero.
   *
   * @param x unsigned 256-bit integer number
   * @param y unsigned 256-bit integer number
   * @return unsigned 64.64-bit fixed point number
   */
  function divuu (uint256 x, uint256 y) private pure returns (uint128) {
    unchecked {
      require (y != 0);

      uint256 result;

      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
        result = (x << 64) / y;
      else {
        uint256 msb = 192;
        uint256 xc = x >> 192;
        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }
        if (xc >= 0x10000) { xc >>= 16; msb += 16; }
        if (xc >= 0x100) { xc >>= 8; msb += 8; }
        if (xc >= 0x10) { xc >>= 4; msb += 4; }
        if (xc >= 0x4) { xc >>= 2; msb += 2; }
        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore

        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);
        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

        uint256 hi = result * (y >> 128);
        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);

        uint256 xh = x >> 192;
        uint256 xl = x << 64;

        if (xl < lo) xh -= 1;
        xl -= lo; // We rely on overflow behavior here
        lo = hi << 128;
        if (xl < lo) xh -= 1;
        xl -= lo; // We rely on overflow behavior here

        assert (xh == hi >> 128);

        result += xl / y;
      }

      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
      return uint128 (result);
    }
  }

  /**
   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer
   * number.
   *
   * @param x unsigned 256-bit integer number
   * @return unsigned 128-bit integer number
   */
  function sqrtu (uint256 x) private pure returns (uint128) {
    unchecked {
      if (x == 0) return 0;
      else {
        uint256 xx = x;
        uint256 r = 1;
        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }
        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }
        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }
        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }
        if (xx >= 0x100) { xx >>= 8; r <<= 4; }
        if (xx >= 0x10) { xx >>= 4; r <<= 2; }
        if (xx >= 0x8) { r <<= 1; }
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1; // Seven iterations should be enough
        uint256 r1 = x / r;
        return uint128 (r < r1 ? r : r1);
      }
    }
  }
}",8695
RealWorld_TA_25_WMulUp_RealWorld_20240803142635.log,25,WMulUp,35968,1337,37305,371.0,0.20658,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library WMulUp { // Fixed point arithmetic in 18 decimal units
    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol
    /// @dev Multiply x and y, with y being fixed point. If both are integers, the result is a fixed point factor. Rounds up.
    function wmulup(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x * y + 1e18 - 1;        // Rounds up.  So (again imagining 2 decimal places):
        unchecked { z /= 1e18; }     // 383 (3.83) * 235 (2.35) -> 90005 (9.0005), + 99 (0.0099) -> 90104, / 100 -> 901 (9.01).
    }
}",208
RealWorld_TA_25_Ladle_RealWorld_20240803103742.log,25,Ladle,436945,7059,444004,376.0,2.325905,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;
import ""./interfaces/vault/IFYToken.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/vault/ICauldron.sol"";
import ""./interfaces/vault/IOracle.sol"";
import ""./interfaces/vault/DataTypes.sol"";
import ""./interfaces/yieldspace/IPool.sol"";
import ""./interfaces/external/IERC20.sol"";
import ""./interfaces/external/IERC2612.sol"";
import ""dss-interfaces/src/dss/DaiAbstract.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./utils/token/TransferHelper.sol"";
import ""./interfaces/external/IWETH9.sol"";
import ""./math/WMul.sol"";
import ""./math/CastU256U128.sol"";
import ""./math/CastU128I128.sol"";
import ""./LadleStorage.sol"";


/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.
contract Ladle is LadleStorage, AccessControl() {
    using WMul for uint256;
    using CastU256U128 for uint256;
    using CastU128I128 for uint128;
    using TransferHelper for IERC20;
    using TransferHelper for address payable;

    bytes12 cachedVaultId;

    IWETH9 public immutable weth;

    constructor (ICauldron cauldron, IWETH9 weth_) LadleStorage(cauldron) {
        weth = weth_;
    }

    // ---- Data sourcing ----
    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner
    /// If bytes(0) is passed as the vaultId it tries to load a vault from the cache
    function getVault(bytes12 vaultId_)
        internal view
        returns (bytes12 vaultId, DataTypes.Vault memory vault)
    {
        if (vaultId_ == bytes12(0)) { // We use the cache
            require (cachedVaultId != bytes12(0), ""Vault not cached"");
            vaultId = cachedVaultId;
        } else {
            vaultId = vaultId_;
        }
        vault = cauldron.vaults(vaultId);
        require (vault.owner == msg.sender, ""Only vault owner"");
    } 
    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists
    function getSeries(bytes6 seriesId)
        internal view returns(DataTypes.Series memory series)
    {
        series = cauldron.series(seriesId);
        require (series.fyToken != IFYToken(address(0)), ""Series not found"");
    }

    /// @dev Obtains a join by assetId, and verifies that it exists
    function getJoin(bytes6 assetId)
        internal view returns(IJoin join)
    {
        join = joins[assetId];
        require (join != IJoin(address(0)), ""Join not found"");
    }

    /// @dev Obtains a pool by seriesId, and verifies that it exists
    function getPool(bytes6 seriesId)
        internal view returns(IPool pool)
    {
        pool = pools[seriesId];
        require (pool != IPool(address(0)), ""Pool not found"");
    }

    // ---- Administration ----

    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.
    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.
    function addJoin(bytes6 assetId, IJoin join)
        external
        auth
    {
        address asset = cauldron.assets(assetId);
        require (asset != address(0), ""Asset not found"");
        require (join.asset() == asset, ""Mismatched asset and join"");
        joins[assetId] = join;
        emit JoinAdded(assetId, address(join));
    }

    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.
    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.
    function addPool(bytes6 seriesId, IPool pool)
        external
        auth
    {
        IFYToken fyToken = getSeries(seriesId).fyToken;
        require (fyToken == pool.fyToken(), ""Mismatched pool fyToken and series"");
        require (fyToken.underlying() == address(pool.base()), ""Mismatched pool base and series"");
        pools[seriesId] = pool;
        emit PoolAdded(seriesId, address(pool));
    }

    /// @dev Add or remove a module.
    function setModule(address module, bool set)
        external
        auth
    {
        modules[module] = set;
        emit ModuleSet(module, set);
    }

    /// @dev Set the fee parameter
    function setFee(uint256 fee)
        external
        auth
    {
        borrowingFee = fee;
        emit FeeSet(fee);
    }

    // ---- Batching ----

    /// @dev Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    function batch(bytes[] calldata calls) external payable returns(bytes[] memory results) {
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));
            results[i] = result;
        }

        // build would have populated the cache, this deletes it
        cachedVaultId = bytes12(0);
    }

    // ---- Vault management ----

    /// @dev Generate a vaultId. A keccak256 is cheaper than using a counter with a SSTORE, even accounting for eventual collision retries.
    function _generateVaultId(uint8 salt) private view returns (bytes12) {
        return bytes12(keccak256(abi.encodePacked(msg.sender, block.timestamp, salt)));
    }

    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral
    function build(bytes6 seriesId, bytes6 ilkId, uint8 salt)
        external payable
        returns(bytes12, DataTypes.Vault memory)
    {
        return _build(seriesId, ilkId, salt);
    }

    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral
    // TODO: Include a function that doesn't cache the vault
    function _build(bytes6 seriesId, bytes6 ilkId, uint8 salt)
        private
        returns(bytes12, DataTypes.Vault memory)
    {
        bytes12 vaultId = _generateVaultId(salt);
        try cauldron.build(msg.sender, vaultId, seriesId, ilkId) returns (DataTypes.Vault memory vault) {
            // Store the vault data in the cache
            cachedVaultId = vaultId;
            return (vaultId, vault);
        } catch Error (string memory) {
            return _build(seriesId, ilkId, salt + 1);
        }
    }

    /// @dev Change a vault series or collateral.
    function tweak(bytes12 vaultId_, bytes6 seriesId, bytes6 ilkId)
        external payable
        returns(DataTypes.Vault memory vault)
    {
        (bytes12 vaultId, ) = getVault(vaultId_); // getVault verifies the ownership as well
        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series
        vault = cauldron.tweak(vaultId, seriesId, ilkId);
    }

    /// @dev Give a vault to another user.
    function give(bytes12 vaultId_, address receiver)
        external payable
        returns(DataTypes.Vault memory vault)
    {
        (bytes12 vaultId, ) = getVault(vaultId_);
        vault = cauldron.give(vaultId, receiver);
    }

    /// @dev Destroy an empty vault. Used to recover gas costs.
    function destroy(bytes12 vaultId_)
        external payable
    {
        (bytes12 vaultId, ) = getVault(vaultId_);
        cauldron.destroy(vaultId);
    }

    // ---- Asset and debt management ----

    /// @dev Move collateral and debt between vaults.
    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)
        external payable
    {
        if (ink > 0) require (cauldron.vaults(from).owner == msg.sender, ""Only origin vault owner"");
        if (art > 0) require (cauldron.vaults(to).owner == msg.sender, ""Only destination vault owner"");
        cauldron.stir(from, to, ink, art);
    }

    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user
    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user
    /// Borrow only before maturity.
    function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)
        private
    {
        DataTypes.Series memory series;
        if (art != 0) series = getSeries(vault.seriesId);

        int128 fee;
        if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();

        // Update accounting
        cauldron.pour(vaultId, ink, art + fee);

        // Manage collateral
        if (ink != 0) {
            IJoin ilkJoin = getJoin(vault.ilkId);
            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));
            if (ink < 0) ilkJoin.exit(to, uint128(-ink));
        }

        // Manage debt tokens
        if (art != 0) {
            if (art > 0) series.fyToken.mint(to, uint128(art));
            else series.fyToken.burn(msg.sender, uint128(-art));
        }
    }

    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user
    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user
    /// Borrow only before maturity.
    function pour(bytes12 vaultId_, address to, int128 ink, int128 art)
        external payable
    {
        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);
        _pour(vaultId, vault, to, ink, art);
    }

    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.
    /// The base is obtained by borrowing fyToken and buying base with it in a pool.
    /// Only before maturity.
    function serve(bytes12 vaultId_, address to, uint128 ink, uint128 base, uint128 max)
        external payable
        returns (uint128 art)
    {
        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);
        IPool pool = getPool(vault.seriesId);
        
        art = pool.buyBasePreview(base);
        _pour(vaultId, vault, address(pool), ink.i128(), art.i128());
        pool.buyBase(to, base, max);
    }

    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.
    /// It can add or remove collateral at the same time.
    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.
    /// The debt to repay must be entered as a negative number, as with `pour`.
    /// Debt cannot be acquired with this function.
    function close(bytes12 vaultId_, address to, int128 ink, int128 art)
        external payable
        returns (uint128 base)
    {
        require (art < 0, ""Only repay debt"");                                          // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.

        // Calculate debt in fyToken terms
        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);
        DataTypes.Series memory series = getSeries(vault.seriesId);
        base = cauldron.debtToBase(vault.seriesId, uint128(-art));

        // Update accounting
        cauldron.pour(vaultId, ink, art);

        // Manage collateral
        if (ink != 0) {
            IJoin ilkJoin = getJoin(vault.ilkId);
            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));
            if (ink < 0) ilkJoin.exit(to, uint128(-ink));
        }

        // Manage underlying
        IJoin baseJoin = getJoin(series.baseId);
        baseJoin.join(msg.sender, base);
    }

    /// @dev Repay debt by selling base in a pool and using the resulting fyToken
    /// The base tokens need to be already in the pool, unaccounted for.
    /// Only before maturity. After maturity use close.
    function repay(bytes12 vaultId_, address to, int128 ink, uint128 min)
        external payable
        returns (uint128 art)
    {
        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);
        DataTypes.Series memory series = getSeries(vault.seriesId);
        IPool pool = getPool(vault.seriesId);

        art = pool.sellBase(address(series.fyToken), min);
        _pour(vaultId, vault, to, ink, -(art.i128()));
    }

    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.
    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.
    /// Only before maturity. After maturity use close.
    function repayVault(bytes12 vaultId_, address to, int128 ink, uint128 max)
        external payable
        returns (uint128 base)
    {
        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);
        DataTypes.Series memory series = getSeries(vault.seriesId);
        IPool pool = getPool(vault.seriesId);

        DataTypes.Balances memory balances = cauldron.balances(vaultId);
        base = pool.buyFYToken(address(series.fyToken), balances.art, max);
        _pour(vaultId, vault, to, ink, -(balances.art.i128()));
        pool.retrieveBase(msg.sender);
    }

    /// @dev Change series and debt of a vault.
    function roll(bytes12 vaultId_, bytes6 newSeriesId, uint8 loan, uint128 max)
        external payable
        returns (DataTypes.Vault memory vault, uint128 newDebt)
    {
        bytes12 vaultId;
        (vaultId, vault) = getVault(vaultId_);
        DataTypes.Balances memory balances = cauldron.balances(vaultId);
        DataTypes.Series memory series = getSeries(vault.seriesId);
        DataTypes.Series memory newSeries = getSeries(newSeriesId);
        
        
        {
            IPool pool = getPool(newSeriesId);
            IFYToken fyToken = IFYToken(newSeries.fyToken);
            IJoin baseJoin = getJoin(series.baseId);

            // Calculate debt in fyToken terms
            uint128 base = cauldron.debtToBase(vault.seriesId, balances.art);

            // Mint fyToken to the pool, as a kind of flash loan
            fyToken.mint(address(pool), base * loan);                // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time

            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2
            newDebt = pool.buyBase(address(baseJoin), base, max);
            baseJoin.join(address(baseJoin), base);                  // Repay the old series debt

            pool.retrieveFYToken(address(fyToken));                 // Get the surplus fyToken
            fyToken.burn(address(fyToken), (base * loan) - newDebt);    // Burn the surplus
        }

        newDebt += ((newSeries.maturity - block.timestamp) * uint256(newDebt).wmul(borrowingFee)).u128();  // Add borrowing fee, also stops users form rolling to a mature series

        (vault,) = cauldron.roll(vaultId, newSeriesId, newDebt.i128() - balances.art.i128()); // Change the series and debt for the vault

        return (vault, newDebt);
    }

    // ---- Ladle as a token holder ----

    /// @dev Use fyToken in the Ladle to repay debt.
    function repayLadle(bytes12 vaultId_)
        external payable
        returns (uint256 repaid)
    {
        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);
        DataTypes.Series memory series = getSeries(vault.seriesId);
        DataTypes.Balances memory balances = cauldron.balances(vaultId);
        
        uint256 amount = series.fyToken.balanceOf(address(this));
        repaid = amount <= balances.art ? amount : balances.art;

        // Update accounting
        cauldron.pour(vaultId, 0, -(repaid.u128().i128()));
        series.fyToken.burn(address(this), repaid);
    }

    /// @dev Retrieve any asset or fyToken in the Ladle
    function retrieve(bytes6 id, bool isAsset, address to) 
        external payable
        returns (uint256 amount)
    {
        IERC20 token = IERC20(findToken(id, isAsset));
        amount = token.balanceOf(address(this));
        token.safeTransfer(to, amount);
    }

    // ---- Permit management ----

    /// @dev From an id, which can be an assetId or a seriesId, find the resulting asset or fyToken
    function findToken(bytes6 id, bool isAsset)
        private view returns (address token)
    {
        token = isAsset ? cauldron.assets(id) : address(getSeries(id).fyToken);
        require (token != address(0), ""Token not found"");
    }

    /// @dev Execute an ERC2612 permit for the selected asset or fyToken
    function forwardPermit(bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
        external payable
    {
        IERC2612 token = IERC2612(findToken(id, isAsset));
        token.permit(msg.sender, spender, amount, deadline, v, r, s);
    }

    /// @dev Execute a Dai-style permit for the selected asset or fyToken
    function forwardDaiPermit(bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)
        external payable
    {
        DaiAbstract token = DaiAbstract(findToken(id, isAsset));
        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);
    }

    // ---- Ether management ----

    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.
    receive() external payable { 
        require (msg.sender == address(weth), ""Only receive from WETH"");
    }

    /// @dev Accept Ether, wrap it and forward it to the WethJoin
    /// This function should be called first in a batch, and the Join should keep track of stored reserves
    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail
    function joinEther(bytes6 etherId)
        external payable
        returns (uint256 ethTransferred)
    {
        ethTransferred = address(this).balance;
        IJoin wethJoin = getJoin(etherId);
        weth.deposit{ value: ethTransferred }();
        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);
    }

    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether
    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance
    function exitEther(address payable to)
        external payable
        returns (uint256 ethTransferred)
    {
        ethTransferred = weth.balanceOf(address(this));
        weth.withdraw(ethTransferred);
        to.safeTransferETH(ethTransferred);
    }

    // ---- Pool router ----

    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch
    function transferToPool(bytes6 seriesId, bool isBase, uint128 wad)
        external payable
    {
        IPool pool = getPool(seriesId);
        IERC20 token = isBase ? pool.base() : pool.fyToken();
        token.safeTransferFrom(msg.sender, address(pool), wad);
    }

    /// @dev Allow users to route calls to a pool, to be used with batch
    function route(bytes6 seriesId, bytes memory data)
        external payable
        returns (bytes memory result)
    {
        address pool = address(getPool(seriesId));
        bool success;
        (success, result) = pool.call(data);
        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));
    }

    // ---- FYToken router ----

    /// @dev Allow users to trigger a token transfer to a fyToken through the ladle, to be used with batch
    function transferToFYToken(bytes6 seriesId, uint256 wad)
        external payable
    {
        address fyToken = address(getSeries(seriesId).fyToken);
        IERC20(fyToken).safeTransferFrom(msg.sender, address(fyToken), wad);
    }

    /// @dev Allow users to redeem fyToken, to be used with batch.
    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.
    function redeem(bytes6 seriesId, address to, uint256 wad)
        external payable
        returns (uint256)
    {
        IFYToken fyToken = getSeries(seriesId).fyToken;
        return fyToken.redeem(to, wad != 0 ? wad : fyToken.balanceOf(address(this)));
    }

    // ---- Module router ----

    /// @dev Allow users to use functionality coded in a module, to be used with batch
    /// @notice Modules must not do any changes to the vault (owner, seriesId, ilkId),
    /// it would be disastrous in combination with batch vault caching 
    function moduleCall(address module, bytes memory data)
        external payable
        returns (bytes memory result)
    {
        require (modules[module], ""Unregistered module"");
        bool success;
        (success, result) = module.delegatecall(data);
        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));
    }
}",4967
RealWorld_TA_25_Witch_RealWorld_20240803104401.log,25,Witch,200337,5776,206113,364.0,1.117205,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""./utils/access/AccessControl.sol"";
import ""./interfaces/vault/ILadle.sol"";
import ""./interfaces/vault/ICauldron.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/vault/DataTypes.sol"";
import ""./math/WMul.sol"";
import ""./math/WDiv.sol"";
import ""./math/WDivUp.sol"";
import ""./math/CastU256U128.sol"";
import ""./math/CastU256U32.sol"";


contract Witch is AccessControl() {
    using WMul for uint256;
    using WDiv for uint256;
    using WDivUp for uint256;
    using CastU256U128 for uint256;
    using CastU256U32 for uint256;

    event IlkSet(bytes6 indexed ilkId, uint32 duration, uint64 initialOffer, uint128 dust);
    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);
    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);
  
    struct Auction {
        address owner;
        uint32 start;
    }

    struct Ilk {
        uint32 duration;      // Time that auctions take to go to minimal price and stay there.
        uint64 initialOffer;  // Proportion of collateral that is sold at auction start (1e18 = 100%)
        uint128 dust;         // Minimum collateral that must be left when buying, unless buying all
    }

    // uint32 public duration = 4 * 60 * 60; // Time that auctions take to go to minimal price and stay there.
    // uint64 public initialOffer = 5e17;  // Proportion of collateral that is sold at auction start (1e18 = 100%)
    // uint128 public dust;                     // Minimum collateral that must be left when buying, unless buying all

    ICauldron immutable public cauldron;
    ILadle immutable public ladle;
    mapping(bytes12 => Auction) public auctions;
    mapping(bytes6 => Ilk) public ilks;

    constructor (ICauldron cauldron_, ILadle ladle_) {
        cauldron = cauldron_;
        ladle = ladle_;
    }

    /// @dev Set the auction duration to calculate liquidation prices
    /* function setDuration(uint32 duration_) external auth {
        duration = duration_;
        emit DurationSet(duration_);
    }

    /// @dev Set the proportion of the collateral that will be sold at auction start
    function setInitialOffer(uint64 initialOffer_) external auth {
        require (initialOffer_ <= 1e18, ""Only at or under 100%"");
        initialOffer = initialOffer_;
        emit InitialOfferSet(initialOffer_);
    }

    /// @dev Set the minimum collateral that must be left when buying, unless buying all
    function setDust(uint128 dust_) external auth {
        dust = dust_;
        emit DustSet(dust_);
    } */

    /// @dev Set:
    ///  - the auction duration to calculate liquidation prices
    ///  - the proportion of the collateral that will be sold at auction start
    ///  - the minimum collateral that must be left when buying, unless buying all
    function setIlk(bytes6 ilkId, uint32 duration, uint64 initialOffer, uint128 dust) external auth {
        require (initialOffer <= 1e18, ""Only at or under 100%"");
        ilks[ilkId] = Ilk({
            duration: duration,
            initialOffer: initialOffer,
            dust: dust
        });
        emit IlkSet(ilkId, duration, initialOffer, dust);
    }

    /// @dev Put an undercollateralized vault up for liquidation.
    function auction(bytes12 vaultId)
        external
    {
        require (auctions[vaultId].start == 0, ""Vault already under auction"");
        DataTypes.Vault memory vault = cauldron.vaults(vaultId);
        auctions[vaultId] = Auction({
            owner: vault.owner,
            start: block.timestamp.u32()
        });
        cauldron.grab(vaultId, address(this));
        emit Auctioned(vaultId, block.timestamp.u32());
    }

    /// @dev Pay `base` of the debt in a vault in liquidation, getting at least `min` collateral.
    function buy(bytes12 vaultId, uint128 base, uint128 min)
        external
        returns (uint256 ink)
    {
        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);
        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);
        DataTypes.Series memory series_ = cauldron.series(vault_.seriesId);
        Auction memory auction_ = auctions[vaultId];
        Ilk memory ilk_ = ilks[vault_.ilkId];

        require (balances_.art > 0, ""Nothing to buy"");                                      // Cheapest way of failing gracefully if given a non existing vault
        uint256 art = cauldron.debtFromBase(vault_.seriesId, base);
        {
            uint256 elapsed = uint32(block.timestamp) - auction_.start;                      // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.
            uint256 price = inkPrice(balances_, ilk_.initialOffer, ilk_.duration, elapsed);
            ink = uint256(art).wmul(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.
            require (ink >= min, ""Not enough bought"");
            require (ink == balances_.ink || balances_.ink - ink >= ilk_.dust, ""Leaves dust"");
        }

        cauldron.slurp(vaultId, ink.u128(), art.u128());                                            // Remove debt and collateral from the vault
        settle(msg.sender, vault_.ilkId, series_.baseId, ink.u128(), base);                   // Move the assets
        if (balances_.art - art == 0) {                                                             // If there is no debt left, return the vault with the collateral to the owner
            cauldron.give(vaultId, auction_.owner);
            delete auctions[vaultId];
        }

        emit Bought(vaultId, msg.sender, ink, art);
    }


    /// @dev Pay all debt from a vault in liquidation, getting at least `min` collateral.
    function payAll(bytes12 vaultId, uint128 min)
        external
        returns (uint256 ink)
    {
        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);
        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);
        DataTypes.Series memory series_ = cauldron.series(vault_.seriesId);
        Auction memory auction_ = auctions[vaultId];
        Ilk memory ilk_ = ilks[vault_.ilkId];

        require (balances_.art > 0, ""Nothing to buy"");                                      // Cheapest way of failing gracefully if given a non existing vault
        {
            uint256 elapsed = uint32(block.timestamp) - auction_.start;                      // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.
            uint256 price = inkPrice(balances_, ilk_.initialOffer, ilk_.duration, elapsed);
            ink = uint256(balances_.art).wmul(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.
            require (ink >= min, ""Not enough bought"");
            require (ink == balances_.ink || balances_.ink - ink >= ilk_.dust, ""Leaves dust"");
        }

        cauldron.slurp(vaultId, ink.u128(), balances_.art);                                                     // Remove debt and collateral from the vault
        settle(msg.sender, vault_.ilkId, series_.baseId, ink.u128(), cauldron.debtToBase(vault_.seriesId, balances_.art));                                        // Move the assets
        cauldron.give(vaultId, auction_.owner);

        emit Bought(vaultId, msg.sender, ink, balances_.art); // Still the initially read `art` value, not the updated one
    }

    /// @dev Move base from the buyer to the protocol, and collateral from the protocol to the buyer
    function settle(address user, bytes6 ilkId, bytes6 baseId, uint128 ink, uint128 art)
        private
    {
        if (ink != 0) {                                                                     // Give collateral to the user
            IJoin ilkJoin = ladle.joins(ilkId);
            require (ilkJoin != IJoin(address(0)), ""Join not found"");
            ilkJoin.exit(user, ink);
        }
        if (art != 0) {                                                                     // Take underlying from user
            IJoin baseJoin = ladle.joins(baseId);
            require (baseJoin != IJoin(address(0)), ""Join not found"");
            baseJoin.join(user, art);
        }    
    }

    /// @dev Price of a collateral unit, in underlying, at the present moment, for a given vault
    ///            ink                     min(auction, elapsed)
    /// price = (------- * (p + (1 - p) * -----------------------))
    ///            art                          auction
    function inkPrice(DataTypes.Balances memory balances, uint256 initialOffer_, uint256 duration_, uint256 elapsed)
        private pure
        returns (uint256 price)
    {
            uint256 term1 = uint256(balances.ink).wdiv(balances.art);
            uint256 dividend2 = duration_ < elapsed ? duration_ : elapsed;
            uint256 divisor2 = duration_;
            uint256 term2 = initialOffer_ + (1e18 - initialOffer_).wmul(dividend2.wdiv(divisor2));
            price = term1.wmul(term2);
    }
}",2137
RealWorld_TA_25_SafeERC20Namer_RealWorld_20240803130009.log,25,SafeERC20Namer,99069,1657,100726,361.0,0.528485,"// SPDX-License-Identifier: MIT

pragma solidity >=0.5.0;

import ""../../interfaces/external/IERC20Metadata.sol"";
import ""../AddressStringUtil.sol"";

// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32
// this library will always produce a string symbol to represent the token
library SafeERC20Namer {
    function bytes32ToString(bytes32 x) private pure returns (string memory) {
        bytes memory bytesString = new bytes(32);
        uint256 charCount = 0;
        for (uint256 j = 0; j < 32; j++) {
            bytes1 char = x[j];
            if (char != 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (uint256 j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    // assumes the data is in position 2
    function parseStringData(bytes memory b) private pure returns (string memory) {
        uint256 charCount = 0;
        // first parse the charCount out of the data
        for (uint256 i = 32; i < 64; i++) {
            charCount <<= 8;
            charCount += uint8(b[i]);
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (uint256 i = 0; i < charCount; i++) {
            bytesStringTrimmed[i] = b[i + 64];
        }

        return string(bytesStringTrimmed);
    }

    // uses a heuristic to produce a token name from the address
    // the heuristic returns the full hex of the address string in upper case
    function addressToName(address token) private pure returns (string memory) {
        return AddressStringUtil.toAsciiString(token, 40);
    }

    // uses a heuristic to produce a token symbol from the address
    // the heuristic returns the first 6 hex of the address string in upper case
    function addressToSymbol(address token) private pure returns (string memory) {
        return AddressStringUtil.toAsciiString(token, 6);
    }

    // calls an external view token contract method that returns a symbol or name, and parses the output into a string
    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {
        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));
        // if not implemented, or returns empty data, return empty string
        if (!success || data.length == 0) {
            return """";
        }
        // bytes32 data always has length 32
        if (data.length == 32) {
            bytes32 decoded = abi.decode(data, (bytes32));
            return bytes32ToString(decoded);
        } else if (data.length > 64) {
            return abi.decode(data, (string));
        }
        return """";
    }

    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address
    function tokenSymbol(address token) public view returns (string memory) {
        string memory symbol = callAndParseStringReturn(token, IERC20Metadata.symbol.selector);
        if (bytes(symbol).length == 0) {
            // fallback to 6 uppercase hex of address
            return addressToSymbol(token);
        }
        return symbol;
    }

    // attempts to extract the token name. if it does not implement name, returns a name derived from the address
    function tokenName(address token) public view returns (string memory) {
        string memory name = callAndParseStringReturn(token, IERC20Metadata.name.selector);
        if (bytes(name).length == 0) {
            // fallback to full hex of address
            return addressToName(token);
        }
        return name;
    }

    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.
    /// @param token The address of the ERC-20 token contract.
    /// @return (uint8) Token decimals.
    function tokenDecimals(address token) public view returns (uint8) {
        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Metadata.decimals.selector));
        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
    }
}",954
RealWorld_TA_25_CastU128I128_RealWorld_20240803142022.log,25,CastU128I128,25520,1161,26681,371.0,0.15082,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library CastU128I128 {
    /// @dev Safely cast an uint128 to an int128
    function i128(uint128 x) internal pure returns (int128 y) {
        require (x <= uint128(type(int128).max), ""Cast overflow"");
        y = int128(x);
    }
}",87
RealWorld_TA_25_Strategy_RealWorld_20240803113344.log,25,Strategy,235129,6377,241506,357.0,1.303185,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../utils/access/AccessControl.sol"";
import ""../utils/token/TransferHelper.sol"";
import ""../utils/token/ERC20Rewards.sol"";
import ""../interfaces/vault/DataTypes.sol"";
import ""../interfaces/yieldspace/IPool.sol"";
import ""../interfaces/external/IERC20.sol"";


interface ILadle {
    function joins(bytes6) external view returns (address);
    function cauldron() external view returns (ICauldron);
    function build(bytes6 seriesId, bytes6 ilkId, uint8 salt) external returns (bytes12 vaultId, DataTypes.Vault memory vault);
    function destroy(bytes12 vaultId) external;
    function pour(bytes12 vaultId, address to, int128 ink, int128 art) external;
    function close(bytes12 vaultId, address to, int128 ink, int128 art) external;
}

interface ICauldron {
    function assets(bytes6) external view returns (address);
    function series(bytes6) external view returns (DataTypes.Series memory);
    function balances(bytes12) external view returns (DataTypes.Balances memory);
    function debtToBase(bytes6 seriesId, uint128 art) external view returns (uint128);
}

library CastU128I128 {
    /// @dev Safely cast an uint128 to an int128
    function i128(uint128 x) internal pure returns (int128 y) {
        require (x <= uint128(type(int128).max), ""Cast overflow"");
        y = int128(x);
    }
}

/// @dev The Pool contract exchanges base for fyToken at a price defined by a specific formula.
contract Strategy is AccessControl, ERC20Rewards {
    using TransferHelper for IERC20;
    using CastU256U128 for uint256; // Inherited from ERC20Rewards
    using CastU128I128 for uint128;

    event YieldSet(ILadle ladle, ICauldron cauldron);
    event TokenJoinReset(address join);
    event TokenIdSet(bytes6 id);
    event NextPoolSet(IPool indexed pool, bytes6 indexed seriesId);
    event PoolEnded(address pool);
    event PoolStarted(address pool);
    event Invest(uint256 minted);
    event Divest(uint256 burnt);

    IERC20 public immutable base;                // Base token for this strategy
    bytes6 public baseId;                        // Identifier for the base token in Yieldv2
    address public baseJoin;                     // Yield v2 Join to deposit token when borrowing
    ILadle public ladle;                         // Gateway to the Yield v2 Collateralized Debt Engine
    ICauldron public cauldron;                   // Accounts in the Yield v2 Collateralized Debt Engine
    bytes12 public vaultId;                      // Vault used to borrow fyToken

    IPool public pool;                           // Current pool that this strategy invests in
    bytes6 public seriesId;                      // SeriesId for the current pool in Yield v2
    IFYToken public fyToken;                     // Current fyToken for this strategy

    IPool public nextPool;                       // Next pool that this strategy will invest in
    bytes6 public nextSeriesId;                  // SeriesId for the next pool in Yield v2

    uint256 public cached;                       // LP tokens owned by the strategy after the last operation

    constructor(string memory name, string memory symbol, uint8 decimals, ILadle ladle_, IERC20 base_, bytes6 baseId_)
        ERC20Rewards(name, symbol, decimals)
    { 
        require(
            ladle_.cauldron().assets(baseId_) == address(base_),
            ""Mismatched baseId""
        );
        base = base_;
        baseId = baseId_;
        baseJoin = ladle_.joins(baseId_);

        ladle = ladle_;
        cauldron = ladle_.cauldron();
    }

    modifier beforeMaturity() {
        require (
            fyToken.maturity() >= uint32(block.timestamp),
            ""Only before maturity""
        );
        _;
    }

    modifier afterMaturity() {
        require (
            fyToken == IFYToken(address(0)) || fyToken.maturity() < uint32(block.timestamp),
            ""Only after maturity""
        );
        _;
    }

    /// @dev Set a new Ladle and Cauldron
    /// @notice Use with extreme caution, only for Ladle replacements
    function setYield(ILadle ladle_, ICauldron cauldron_)
        public
        afterMaturity
        auth
    {
        ladle = ladle_;
        cauldron = ladle_.cauldron();
        emit YieldSet(ladle_, cauldron_);
    }

    /// @dev Set a new base token id
    /// @notice Use with extreme caution, only for token reconfigurations in Cauldron
    function setTokenId(bytes6 baseId_)
        public
        afterMaturity
        auth
    {
        require(
            ladle.cauldron().assets(baseId_) == address(base),
            ""Mismatched baseId""
        );
        baseId = baseId_;
        emit TokenIdSet(baseId_);
    }

    /// @dev Reset the base token join
    /// @notice Use with extreme caution, only for Join replacements
    function resetTokenJoin()
        public
        afterMaturity
        auth
    {
        baseJoin = ladle.joins(baseId);
        emit TokenJoinReset(baseJoin);
    }

    /// @dev Set the next pool to invest in
    function setNextPool(IPool pool_, bytes6 seriesId_) 
        public
        auth
    {
        require(
            base == pool_.base(),
            ""Mismatched base""
        );
        DataTypes.Series memory series = cauldron.series(seriesId_);
        require(
            series.fyToken == pool_.fyToken(),
            ""Mismatched seriesId""
        );

        nextPool = pool_;
        nextSeriesId = seriesId_;

        emit NextPoolSet(pool_, seriesId_);
    }

    /// @dev Start the strategy investments in the next pool
    /// @notice When calling this function for the first pool, some underlying needs to be transferred to the strategy first, using a batchable router.
    function startPool()
        public
    {
        require(pool == IPool(address(0)), ""Current pool exists"");
        require(nextPool != IPool(address(0)), ""Next pool not set"");

        pool = nextPool;
        fyToken = pool.fyToken();
        seriesId = nextSeriesId;

        delete nextPool;
        delete nextSeriesId;

        (vaultId, ) = ladle.build(seriesId, baseId, 0);

        // Find pool proportion p = tokenReserves/(tokenReserves + fyTokenReserves)
        // Deposit (investment * p) base to borrow (investment * p) fyToken
        //   (investment * p) fyToken + (investment * (1 - p)) base = investment
        //   (investment * p) / ((investment * p) + (investment * (1 - p))) = p
        //   (investment * (1 - p)) / ((investment * p) + (investment * (1 - p))) = 1 - p

        uint256 baseBalance = base.balanceOf(address(this));
        require(baseBalance > 0, ""No funds to start with"");

        uint256 baseInPool = base.balanceOf(address(pool));
        uint256 fyTokenInPool = fyToken.balanceOf(address(pool));
        
        uint256 baseToPool = (baseBalance * baseInPool) / (baseInPool + fyTokenInPool);  // Rounds down
        uint256 fyTokenToPool = baseBalance - baseToPool;        // fyTokenToPool is rounded up

        // Borrow fyToken with base as collateral
        base.safeTransfer(baseJoin, fyTokenToPool);
        int128 fyTokenToPool_ = fyTokenToPool.u128().i128();
        ladle.pour(vaultId, address(pool), fyTokenToPool_, fyTokenToPool_);

        // Mint LP tokens with (investment * p) fyToken and (investment * (1 - p)) base
        base.safeTransfer(address(pool), baseToPool);
        (,, cached) = pool.mint(address(this), true, 0); // We don't care about slippage

        if (_totalSupply == 0) _mint(msg.sender, cached); // Initialize the strategy if needed

        emit PoolStarted(address(pool));
    }

    /// @dev Divest out of a pool once it has matured
    function endPool()
        public
        afterMaturity
    {
        uint256 toDivest = pool.balanceOf(address(this));
        
        // Burn lpTokens
        IERC20(address(pool)).safeTransfer(address(pool), toDivest);
        (,, uint256 fyTokenDivested) = pool.burn(address(this), 0, 0); // We don't care about slippage
        
        // Repay with fyToken as much as possible
        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);
        uint256 debt = balances_.art;
        uint256 toRepay = (debt >= fyTokenDivested) ? fyTokenDivested : debt;
        if (toRepay > 0) {
            IERC20(address(fyToken)).safeTransfer(address(fyToken), toRepay);
            int128 toRepay_ = toRepay.u128().i128();
            ladle.pour(vaultId, address(this), 0, -toRepay_);
            debt -= toRepay;
        }

        // Redeem any fyToken surplus
        uint256 toRedeem = fyTokenDivested - toRepay;
        if (toRedeem > 0) {
            IERC20(address(fyToken)).safeTransfer(address(fyToken), toRedeem);
            fyToken.redeem(address(this), toRedeem);
        }

        // Repay with underlying if there is still any debt
        if (debt > 0) {
            base.safeTransfer(address(baseJoin), cauldron.debtToBase(seriesId, debt.u128())); // The strategy can't lose money due to the pool invariant, there will always be enough if we get here.
            int128 debt_ = debt.u128().i128();
            ladle.close(vaultId, address(this), 0, -debt_);   // Takes a fyToken amount as art parameter
        }

        // Withdraw all collateral
        ladle.pour(vaultId, address(this), -(balances_.ink.i128()), 0);

        emit PoolEnded(address(pool));

        // Clear up
        delete pool;
        delete fyToken;
        delete seriesId;
        delete cached;
        
        ladle.destroy(vaultId);
        delete vaultId;
    }

    /// @dev Mint strategy tokens.
    /// @notice The lp tokens that the user contributes need to have been transferred previously, using a batchable router.
    function mint(address to)
        public
        beforeMaturity
        returns (uint256 minted)
    {
        // minted = supply * value(deposit) / value(strategy)
        uint256 deposit = pool.balanceOf(address(this)) - cached;
        minted = _totalSupply * deposit / cached;
        cached += deposit;

        _mint(to, minted);
    }

    /// @dev Burn strategy tokens to withdraw lp tokens. The lp tokens obtained won't be of the same pool that the investor deposited,
    /// if the strategy has swapped to another pool.
    /// @notice The strategy tokens that the user burns need to have been transferred previously, using a batchable router.
    function burn(address to)
        public
        returns (uint256 withdrawal)
    {
        // strategy * burnt/supply = withdrawal
        uint256 burnt = _balanceOf[address(this)];
        withdrawal = cached * burnt / _totalSupply;
        cached -= withdrawal;

        _burn(address(this), burnt);
        IERC20(address(pool)).safeTransfer(to, withdrawal);
    }
}",2563
RealWorld_TA_25_ERC20Permit_RealWorld_20240803131838.log,25,ERC20Permit,80443,1751,82194,368.0,0.437235,"// SPDX-License-Identifier: MIT
// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol
pragma solidity ^0.8.0;

import ""./ERC20.sol"";
import ""../../interfaces/external/IERC2612.sol"";

/**
 * @dev Extension of {ERC20} that allows token holders to use their tokens
 * without sending any transactions by setting {IERC20-allowance} with a
 * signature using the {permit} method, and then spend them via
 * {IERC20-transferFrom}.
 *
 * The {permit} signature mechanism conforms to the {IERC2612} interface.
 */
abstract contract ERC20Permit is ERC20, IERC2612 {
    mapping (address => uint256) public override nonces;

    bytes32 public immutable PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private immutable _DOMAIN_SEPARATOR;
    uint256 public immutable deploymentChainId;

    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {
        uint256 chainId;
        assembly {chainId := chainid()}
        deploymentChainId = chainId;
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);
    }

    /// @dev Calculate the DOMAIN_SEPARATOR.
    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(version())),
                chainId,
                address(this)
            )
        );
    }

    /// @dev Return the DOMAIN_SEPARATOR.
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        uint256 chainId;
        assembly {chainId := chainid()}
        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    /// @dev Setting the version as a function so that it can be overriden
    function version() public pure virtual returns(string memory) { return ""1""; }

    /**
     * @dev See {IERC2612-permit}.
     *
     * In cases where the free option is not a concern, deadline can simply be
     * set to uint(-1), so it should be seen as an optional parameter
     */
    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external virtual override {
        require(deadline >= block.timestamp, ""ERC20Permit: expired deadline"");

        uint256 chainId;
        assembly {chainId := chainid()}

        bytes32 hashStruct = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                owner,
                spender,
                amount,
                nonces[owner]++,
                deadline
            )
        );

        bytes32 hash = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId),
                hashStruct
            )
        );

        address signer = ecrecover(hash, v, r, s);
        require(
            signer != address(0) && signer == owner,
            ""ERC20Permit: invalid signature""
        );

        _setAllowance(owner, spender, amount);
    }
}",756
RealWorld_TA_25_LadleStorage_RealWorld_20240803111453.log,25,LadleStorage,40196,1654,41850,368.0,0.23406,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;
import ""./interfaces/vault/ICauldron.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/yieldspace/IPool.sol"";


/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.
contract LadleStorage {
    ICauldron public immutable cauldron;
    uint256 public borrowingFee;

    mapping (bytes6 => IJoin)                   public joins;            // Join contracts available to manage assets. The same Join can serve multiple assets (ETH-A, ETH-B, etc...)
    mapping (bytes6 => IPool)                   public pools;            // Pool contracts available to manage series. 12 bytes still free.
    mapping (address => bool)                   public modules;          // Trusted contracts to execute anything on.

    event JoinAdded(bytes6 indexed assetId, address indexed join);
    event PoolAdded(bytes6 indexed seriesId, address indexed pool);
    event ModuleSet(address indexed module, bool indexed set);
    event FeeSet(uint256 fee);

    constructor (ICauldron cauldron_) {
        cauldron = cauldron_;
    }
}",256
RealWorld_TA_25_CTokenInterface_RealWorld_20240803121038.log,25,CTokenInterface,33367,1535,34902,362.0,0.197535,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.5.16;

interface CTokenInterface {
    /**
     * @notice Accumulator of the total earned interest rate since the opening of the market
     */
    function borrowIndex() external view returns (uint);

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() external returns (uint);
    
    /**
     * @notice Calculates the exchange rate from the underlying to the CToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() external view returns (uint);
}",173
RealWorld_TA_25_PoolFactory_RealWorld_20240803113943.log,25,PoolFactory,87499,1913,89412,362.0,0.475755,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../interfaces/yieldspace/IPoolFactory.sol"";
import ""./Pool.sol"";


/// @dev The PoolFactory can deterministically create new pool instances.
contract PoolFactory is IPoolFactory {
  /// Pre-hashing the bytecode allows calculatePoolAddress to be cheaper, and
  /// makes client-side address calculation easier
  bytes32 public constant override POOL_BYTECODE_HASH = keccak256(type(Pool).creationCode);

  address private _nextBase;
  address private _nextFYToken;

  /// @dev Returns true if `account` is a contract.
  function isContract(address account) internal view returns (bool) {
      // This method relies on extcodesize, which returns 0 for contracts in
      // construction, since the code is only stored at the end of the
      // constructor execution.

      uint256 size;
      // solhint-disable-next-line no-inline-assembly
      assembly { size := extcodesize(account) }
      return size > 0;
  }

  /// @dev Calculate the deterministic addreess of a pool, based on the base token & fy token.
  /// @param base Address of the base token (such as Base).
  /// @param fyToken Address of the fixed yield token (such as fyToken).
  /// @return The calculated pool address.
  function calculatePoolAddress(address base, address fyToken) external view override returns (address) {
    return _calculatePoolAddress(base, fyToken);
  }

  /// @dev Create2 calculation
  function _calculatePoolAddress(address base, address fyToken)
    private view returns (address calculatedAddress)
  {
    calculatedAddress = address(uint160(uint256(keccak256(abi.encodePacked(
      bytes1(0xff),
      address(this),
      keccak256(abi.encodePacked(base, fyToken)),
      POOL_BYTECODE_HASH
    )))));
  }

  /// @dev Calculate the addreess of a pool, and return address(0) if not deployed.
  /// @param base Address of the base token (such as Base).
  /// @param fyToken Address of the fixed yield token (such as fyToken).
  /// @return pool The deployed pool address.
  function getPool(address base, address fyToken) external view override returns (address pool) {
    pool = _calculatePoolAddress(base, fyToken);

    if(!isContract(pool)) {
      pool = address(0);
    }
  }

  /// @dev Deploys a new pool.
  /// base & fyToken are written to temporary storage slots to allow for simpler
  /// address calculation, while still allowing the Pool contract to store the values as
  /// immutable.
  /// @param base Address of the base token (such as Base).
  /// @param fyToken Address of the fixed yield token (such as fyToken).
  /// @return pool The pool address.
  function createPool(address base, address fyToken) external override returns (address) {
    _nextBase = base;
    _nextFYToken = fyToken;
    Pool pool = new Pool{salt: keccak256(abi.encodePacked(base, fyToken))}();
    _nextBase = address(0);
    _nextFYToken = address(0);

    pool.transferOwnership(msg.sender);
    
    emit PoolCreated(base, fyToken, address(pool));

    return address(pool);
  }

  /// @dev Only used by the Pool constructor.
  /// @return The base token for the currently-constructing pool.
  function nextBase() external view override returns (address) {
    return _nextBase;
  }

  /// @dev Only used by the Pool constructor.
  /// @return The fytoken for the currently-constructing pool.
  function nextFYToken() external view override returns (address) {
    return _nextFYToken;
  }
}",820
RealWorld_TA_25_CTokenMultiOracle_RealWorld_20240803121642.log,25,CTokenMultiOracle,103487,4837,108324,371.0,0.614175,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../../utils/access/AccessControl.sol"";
import ""../../interfaces/vault/IOracle.sol"";
import ""../../constants/Constants.sol"";
import ""../../math/CastBytes32Bytes6.sol"";
import ""./CTokenInterface.sol"";


contract CTokenMultiOracle is IOracle, AccessControl, Constants {
    using CastBytes32Bytes6 for bytes32;

    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals

    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);

    struct Source {
        address source;
        uint8 decimals;
        bool inverse;
    }

    mapping(bytes6 => mapping(bytes6 => Source)) public sources;

    /**
     * @notice Set or reset an oracle source and its inverse
     */
    function setSource(bytes6 cTokenId, bytes6 underlying, address cToken) external auth {
        _setSource(cTokenId, underlying, cToken);
    }

    /**
     * @notice Set or reset a number of oracle sources and their inverses
     */
    function setSources(bytes6[] memory cTokenIds, bytes6[] memory underlyings, address[] memory cTokens) external auth {
        require(
            cTokenIds.length == underlyings.length && 
            cTokenIds.length == cTokens.length,
            ""Mismatched inputs""
        );
        for (uint256 i = 0; i < cTokenIds.length; i++) {
            _setSource(cTokenIds[i], underlyings[i], cTokens[i]);
        }
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function peek(bytes32 base, bytes32 quote, uint256 amount)
        external view virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), quote.b6());
        value = price * amount / 1e18;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function get(bytes32 base, bytes32 quote, uint256 amount)
        external virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _get(base.b6(), quote.b6());
        value = price * amount / 1e18;
    }

    function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {
        uint256 rawPrice;
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");

        rawPrice = CTokenInterface(source.source).exchangeRateStored();

        require(rawPrice > 0, ""Compound price is zero"");

        if (source.inverse == true) {
            price = 10 ** (source.decimals + 18) / uint(rawPrice);
        } else {
            price = uint(rawPrice) * 10 ** (18 - source.decimals);
        }

        updateTime = block.timestamp; // We should get the timestamp
    }

    function _get(bytes6 base, bytes6 quote) private returns (uint price, uint updateTime) {
        uint256 rawPrice;
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");

        rawPrice = CTokenInterface(source.source).exchangeRateCurrent();

        require(rawPrice > 0, ""Compound price is zero"");

        if (source.inverse == true) {
            price = 10 ** (source.decimals + 18) / uint(rawPrice);
        } else {
            price = uint(rawPrice) * 10 ** (18 - source.decimals);
        }

        updateTime = block.timestamp; // We should get the timestamp
    }

    function _setSource(bytes6 cTokenId, bytes6 underlying, address source) internal {
        uint8 decimals_ = 18; // Does the borrowing rate have 18 decimals?
        require (decimals_ <= 18, ""Unsupported decimals"");
        sources[cTokenId][underlying] = Source({
            source: source,
            decimals: decimals_,
            inverse: false
        });
        sources[underlying][cTokenId] = Source({
            source: source,
            decimals: decimals_,
            inverse: true
        });
        emit SourceSet(cTokenId, underlying, source);
        emit SourceSet(underlying, cTokenId, source);
    }
}",974
RealWorld_TA_25_CastBytes32Bytes6_RealWorld_20240803140159.log,25,CastBytes32Bytes6,23817,1508,25325,368.0,0.149245,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library CastBytes32Bytes6 {
    function b6(bytes32 x) internal pure returns (bytes6 y){
        require (bytes32(y = bytes6(x)) == x, ""Cast overflow"");
    }
}",65
RealWorld_TA_25_CastU256U128_RealWorld_20240803144511.log,25,CastU256U128,25408,1249,26657,371.0,0.15202,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library CastU256U128 {
    /// @dev Safely cast an uint256 to an uint128
    function u128(uint256 x) internal pure returns (uint128 y) {
        require (x <= type(uint128).max, ""Cast overflow"");
        y = uint128(x);
    }
}",85
RealWorld_TA_25_IPool_RealWorld_20240803145124.log,25,IPool,52279,2230,54509,375.0,0.305995,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.8.0;
import ""../external/IERC20.sol"";
import ""../external/IERC2612.sol"";
import ""../vault/IFYToken.sol"";


interface IPool is IERC20, IERC2612 {
    function base() external view returns(IERC20);
    function fyToken() external view returns(IFYToken);
    function maturity() external view returns(uint32);
    function getBaseBalance() external view returns(uint112);
    function getFYTokenBalance() external view returns(uint112);
    function retrieveBase(address to) external returns(uint128 retrieved);
    function retrieveFYToken(address to) external returns(uint128 retrieved);
    function sellBase(address to, uint128 min) external returns(uint128);
    function buyBase(address to, uint128 baseOut, uint128 max) external returns(uint128);
    function sellFYToken(address to, uint128 min) external returns(uint128);
    function buyFYToken(address to, uint128 fyTokenOut, uint128 max) external returns(uint128);
    function sellBasePreview(uint128 baseIn) external view returns(uint128);
    function buyBasePreview(uint128 baseOut) external view returns(uint128);
    function sellFYTokenPreview(uint128 fyTokenIn) external view returns(uint128);
    function buyFYTokenPreview(uint128 fyTokenOut) external view returns(uint128);
    function mint(address to, bool calculateFromBase, uint256 minTokensMinted) external returns (uint256, uint256, uint256);
    function mintWithBase(address to, uint256 fyTokenToBuy, uint256 minTokensMinted) external returns (uint256, uint256, uint256);
    function burn(address to, uint256 minBaseOut, uint256 minFYTokenOut) external returns (uint256, uint256, uint256);
    function burnForBase(address to, uint256 minBaseOut) external returns (uint256, uint256);
}",408
RealWorld_TA_25_IERC20Metadata_RealWorld_20240803152837.log,25,IERC20Metadata,31674,1435,33109,367.0,0.18707,"// SPDX-License-Identifier: MIT
// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol

pragma solidity ^0.8.0;

import ""./IERC20.sol"";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}",161
RealWorld_TA_25_ERC20Rewards_RealWorld_20240803131240.log,25,ERC20Rewards,163426,4159,167585,356.0,0.90031,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""./ERC20Permit.sol"";
import ""../access/AccessControl.sol"";
import ""../RevertMsgExtractor.sol"";


library CastU256U32 {
    /// @dev Safely cast an uint256 to an uint32
    function u32(uint256 x) internal pure returns (uint32 y) {
        require (x <= type(uint32).max, ""Cast overflow"");
        y = uint32(x);
    }
}

library CastU256U128 {
    /// @dev Safely cast an uint256 to an uint128
    function u128(uint256 x) internal pure returns (uint128 y) {
        require (x <= type(uint128).max, ""Cast overflow"");
        y = uint128(x);
    }
}

/// @dev A token inheriting from ERC20Rewards will reward token holders with a rewards token.
/// The rewarded amount will be a fixed wei per second, distributed proportionally to token holders
/// by the size of their holdings.
contract ERC20Rewards is AccessControl, ERC20Permit {
    using CastU256U32 for uint256;
    using CastU256U128 for uint256;

    event RewardsSet(IERC20 rewardsToken, uint32 start, uint32 end, uint256 rate);
    event RewardsPerTokenUpdated(uint256 accumulated);
    event UserRewardsUpdated(address user, uint256 userRewards, uint256 paidRewardPerToken);
    event Claimed(address receiver, uint256 claimed);

    struct RewardsPeriod {
        uint32 start;                                   // Start time for the current rewardsToken schedule
        uint32 end;                                     // End time for the current rewardsToken schedule
    }

    struct RewardsPerToken {
        uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18
        uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated
        uint96 rate;                                    // Wei rewarded per second among all token holders
    }

    struct UserRewards {
        uint128 accumulated;                            // Accumulated rewards for the user until the checkpoint
        uint128 checkpoint;                             // RewardsPerToken the last time the user rewards were updated
    }

    IERC20 public rewardsToken;                         // Token used as rewards
    RewardsPeriod public rewardsPeriod;                 // Period in which rewards are accumulated by users

    RewardsPerToken public rewardsPerToken;             // Accumulator to track rewards per token               
    mapping (address => UserRewards) public rewards;    // Rewards accumulated by users
    
    constructor(string memory name, string memory symbol, uint8 decimals)
        ERC20Permit(name, symbol, decimals)
    { }

    /// @dev Return the earliest of two timestamps
    function earliest(uint32 x, uint32 y) internal pure returns (uint32 z) {
        z = (x < y) ? x : y;
    }

    /// @dev Return the latest of two timestamps
    function latest(uint32 x, uint32 y) internal pure returns (uint32 z) {
        z = (x > y) ? x : y;
    }

    /// @dev Set a rewards schedule
    function setRewards(IERC20 rewardsToken_, uint32 start, uint32 end, uint96 rate)
        public
        auth
    {
        // A new rewards program can be set if one is not running
        require(
            block.timestamp.u32() < rewardsPeriod.start || block.timestamp.u32() > rewardsPeriod.end,
            ""Ongoing rewards""
        );

        // If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token
        rewardsToken = rewardsToken_;

        rewardsPeriod.start = start;
        rewardsPeriod.end = end;

        // If setting up a new rewards program, the rewardsPerToken.accumulated is used and built upon
        // New rewards start accumulating from the new rewards program start
        // Any unaccounted rewards from last program can still be added to the user rewards
        // Any unclaimed rewards can still be claimed
        rewardsPerToken.lastUpdated = start;
        rewardsPerToken.rate = rate;

        emit RewardsSet(rewardsToken, start, end, rate);
    }

    /// @dev Update the rewards per token accumulator.
    /// @notice Needs to be called on each liquidity event
    function _updateRewardsPerToken() internal returns (uint128) {
        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;
        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;

        // We skip the calculations if we can
        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;
        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;

        // Find out the unaccounted period
        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);
        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on

        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.
        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision
        rewardsPerToken_.lastUpdated = end;
        rewardsPerToken = rewardsPerToken_;
        
        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);

        return rewardsPerToken_.accumulated;
    }

    /// @dev Accumulate rewards for an user.
    /// @notice Needs to be called on each liquidity event, or when user balances change.
    function _updateUserRewards(address user) internal returns (uint128) {
        UserRewards memory userRewards_ = rewards[user];
        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;
        
        // Calculate and update the new value user reserves. _balanceOf[user] casts it into uint256, which is desired.
        userRewards_.accumulated = (userRewards_.accumulated + _balanceOf[user] * (rewardsPerToken_.accumulated - userRewards_.checkpoint) / 1e18).u128(); // We must scale down the rewards by the precision factor
        userRewards_.checkpoint = rewardsPerToken_.accumulated;
        rewards[user] = userRewards_;
        emit UserRewardsUpdated(user, userRewards_.accumulated, userRewards_.checkpoint);

        return userRewards_.accumulated;
    }

    /// @dev Mint tokens, after accumulating rewards for an user and update the rewards per token accumulator.
    function _mint(address dst, uint256 wad)
        internal virtual override
        returns (bool)
    {
        _updateRewardsPerToken();
        _updateUserRewards(dst);
        return super._mint(dst, wad);
    }

    /// @dev Burn tokens, after accumulating rewards for an user and update the rewards per token accumulator.
    function _burn(address src, uint256 wad)
        internal virtual override
        returns (bool)
    {
        _updateRewardsPerToken();
        _updateUserRewards(src);
        return super._burn(src, wad);
    }

    /// @dev Transfer tokens, after updating rewards for source and destination.
    function _transfer(address src, address dst, uint wad) internal virtual override returns (bool) {
        _updateRewardsPerToken();
        _updateUserRewards(src);
        _updateUserRewards(dst);
        return super._transfer(src, dst, wad);
    }

    /// @dev Claim all rewards from caller into a given address
    function claim(address to)
        external
        returns (uint256 claiming)
    {
        _updateRewardsPerToken();
        claiming = _updateUserRewards(msg.sender);
        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero
        rewardsToken.transfer(to, claiming);
        emit Claimed(to, claiming);
    }
}",1724
RealWorld_TA_25_WMul_RealWorld_20240803135552.log,25,WMul,27653,1461,29114,365.0,0.167485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library WMul {
    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol
    /// @dev Multiply an amount by a fixed point factor with 18 decimals, rounds down.
    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x * y;
        unchecked { z /= 1e18; }
    }
}",110
RealWorld_TA_25_FYTokenFactory_RealWorld_20240803110235.log,25,FYTokenFactory,42384,2379,44763,365.0,0.2595,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""./interfaces/vault/IOracle.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/vault/IFYTokenFactory.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./FYToken.sol"";


/// @dev The FYTokenFactory creates new FYToken instances.
contract FYTokenFactory is IFYTokenFactory, AccessControl {

  /// @dev Deploys a new fyToken.
  /// @return fyToken The fyToken address.
  function createFYToken(
    bytes6 baseId,
    IOracle oracle,
    IJoin baseJoin,
    uint32 maturity,
    string memory name,
    string memory symbol
  )
    external override
    auth
    returns (address)
  {
    FYToken fyToken = new FYToken(
      baseId,
      oracle,
      baseJoin,
      maturity,
      name,     // Derive from base and maturity, perhaps
      symbol    // Derive from base and maturity, perhaps
    );

    fyToken.grantRole(fyToken.ROOT(), msg.sender);
    fyToken.renounceRole(fyToken.ROOT(), address(this));
    
    emit FYTokenCreated(address(fyToken), baseJoin.asset(), maturity);

    return address(fyToken);
  }
}",278
RealWorld_TA_25_Constants_RealWorld_20240803122910.log,25,Constants,22001,1397,23398,365.0,0.137945,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

contract Constants {
    bytes32 CHI = ""chi"";
    bytes32 RATE = ""rate"";
}",42
RealWorld_TA_25_AccessControl_RealWorld_20240803134323.log,25,AccessControl,189369,2458,191827,373.0,0.996005,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;


/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes4` identifier. These are expected to be the 
 * signatures for all the functions in the contract. Special roles should be exposed
 * in the external API and be unique:
 *
 * ```
 * bytes4 public constant ROOT = 0x00000000;
 * ```
 *
 * Roles represent restricted access to a function call. For that purpose, use {auth}:
 *
 * ```
 * function foo() public auth {
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `ROOT`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {setRoleAdmin}.
 *
 * WARNING: The `ROOT` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
contract AccessControl {
    struct RoleData {
        mapping (address => bool) members;
        bytes4 adminRole;
    }

    mapping (bytes4 => RoleData) private _roles;

    bytes4 public constant ROOT = 0x00000000;
    bytes4 public constant LOCK = 0xFFFFFFFF; // Used to disable further permissioning of a function

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role
     *
     * `ROOT` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call.
     */
    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. 
     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.
     */
    constructor () {
        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender
        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree
    }

    /**
     * @dev Each function in the contract has its own role, identified by their msg.sig signature.
     * ROOT can give and remove access to each function, lock any further access being granted to
     * a specific action, or even create other roles to delegate admin control over a function.
     */
    modifier auth() {
        require (_hasRole(msg.sig, msg.sender), ""Access denied"");
        _;
    }

    /**
     * @dev Allow only if the caller has been granted the admin role of `role`.
     */
    modifier admin(bytes4 role) {
        require (_hasRole(_getRoleAdmin(role), msg.sender), ""Only admin"");
        _;
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes4 role, address account) external view returns (bool) {
        return _hasRole(role, account);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes4 role) external view returns (bytes4) {
        return _getRoleAdmin(role);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.

     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {
        _setRoleAdmin(role, adminRole);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes4 role, address account) external virtual admin(role) {
        _grantRole(role, account);
    }

    
    /**
     * @dev Grants all of `role` in `roles` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - For each `role` in `roles`, the caller must have ``role``'s admin role.
     */
    function grantRoles(bytes4[] memory roles, address account) external virtual {
        for (uint256 i = 0; i < roles.length; i++) {
            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), ""Only admin"");
            _grantRole(roles[i], account);
        }
    }

    /**
     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.

     * Emits a {RoleAdminChanged} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function lockRole(bytes4 role) external virtual admin(role) {
        _setRoleAdmin(role, LOCK);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes4 role, address account) external virtual admin(role) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes all of `role` in `roles` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - For each `role` in `roles`, the caller must have ``role``'s admin role.
     */
    function revokeRoles(bytes4[] memory roles, address account) external virtual {
        for (uint256 i = 0; i < roles.length; i++) {
            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), ""Only admin"");
            _revokeRole(roles[i], account);
        }
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes4 role, address account) external virtual {
        require(account == msg.sender, ""Renounce only for self"");

        _revokeRole(role, account);
    }

    function _hasRole(bytes4 role, address account) internal view returns (bool) {
        return _roles[role].members[account];
    }

    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {
        return _roles[role].adminRole;
    }

    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {
        if (_getRoleAdmin(role) != adminRole) {
            _roles[role].adminRole = adminRole;
            emit RoleAdminChanged(role, adminRole);
        }
    }

    function _grantRole(bytes4 role, address account) internal {
        if (!_hasRole(role, account)) {
            _roles[role].members[account] = true;
            emit RoleGranted(role, account, msg.sender);
        }
    }

    function _revokeRole(bytes4 role, address account) internal {
        if (_hasRole(role, account)) {
            _roles[role].members[account] = false;
            emit RoleRevoked(role, account, msg.sender);
        }
    }
}",2027
RealWorld_TA_25_IERC2612_RealWorld_20240803151607.log,25,IERC2612,58048,1563,59611,371.0,0.3215,"// SPDX-License-Identifier: MIT
// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/
pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC2612 standard as defined in the EIP.
 *
 * Adds the {permit} method, which can be used to change one's
 * {IERC20-allowance} without having to send a transaction, by signing a
 * message. This allows users to spend tokens without having to hold Ether.
 *
 * See https://eips.ethereum.org/EIPS/eip-2612.
 */
interface IERC2612 {
    /**
     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,
     * given `owner`'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;

    /**
     * @dev Returns the current ERC2612 nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);
}",479
RealWorld_TA_25_CastU256I256_RealWorld_20240803134938.log,25,CastU256I256,25534,1194,26728,372.0,0.15155,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library CastU256I256 {
    /// @dev Safely cast an uint256 to an int256
    function i256(uint256 x) internal pure returns (int256 y) {
        require (x <= uint256(type(int256).max), ""Cast overflow"");
        y = int256(x);
    }
}",87
RealWorld_TA_25_CastU256U32_RealWorld_20240803143248.log,25,CastU256U32,25377,1275,26652,366.0,0.152385,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;


library CastU256U32 {
    /// @dev Safely cast an uint256 to an u32
    function u32(uint256 x) internal pure returns (uint32 y) {
        require (x <= type(uint32).max, ""Cast overflow"");
        y = uint32(x);
    }
}",85
RealWorld_TA_25_IPoolFactory_RealWorld_20240803145741.log,25,IPoolFactory,29203,1364,30567,364.0,0.173295,"// SPDX-License-Identifier: MIT
pragma solidity >= 0.8.0;


interface IPoolFactory {
  event PoolCreated(address indexed base, address indexed fyToken, address pool);

  function POOL_BYTECODE_HASH() external pure returns (bytes32);
  function calculatePoolAddress(address base, address fyToken) external view returns (address);
  function getPool(address base, address fyToken) external view returns (address);
  function createPool(address base, address fyToken) external returns (address);
  function nextBase() external view returns (address);
  function nextFYToken() external view returns (address);
}",128
RealWorld_TA_25_JoinFactory_RealWorld_20240803105007.log,25,JoinFactory,32691,1609,34300,367.0,0.195635,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""./interfaces/vault/IJoinFactory.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./Join.sol"";


/// @dev The JoinFactory creates new join instances.
contract JoinFactory is IJoinFactory, AccessControl {

  /// @dev Deploys a new join.
  /// @param asset Address of the asset token.
  /// @return join The join address.
  function createJoin(address asset)
    external override
    auth
    returns (address)
  {
    Join join = new Join(asset);

    join.grantRole(join.ROOT(), msg.sender);
    join.renounceRole(join.ROOT(), address(this));
    
    emit JoinCreated(asset, address(join));

    return address(join);
  }
}",169
RealWorld_TA_25_Wand_RealWorld_20240803110842.log,25,Wand,168243,3635,171878,369.0,0.913915,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;
import ""./interfaces/vault/ICauldronGov.sol"";
import ""./interfaces/vault/ILadleGov.sol"";
import ""./interfaces/vault/IMultiOracleGov.sol"";
import ""./interfaces/vault/IJoinFactory.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/vault/IFYTokenFactory.sol"";
import ""./interfaces/vault/IFYToken.sol"";
import ""./interfaces/vault/DataTypes.sol"";
import ""./interfaces/yieldspace/IPoolFactory.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./constants/Constants.sol"";
import ""./math/CastBytes32Bytes6.sol"";


interface IOwnable {
    function transferOwnership(address) external;
}

/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient governance features.
contract Wand is AccessControl, Constants {
    using CastBytes32Bytes6 for bytes32;

    event Point(bytes32 indexed param, address value);

    bytes4 public constant JOIN = bytes4(keccak256(""join(address,uint128)""));
    bytes4 public constant EXIT = bytes4(keccak256(""exit(address,uint128)""));
    bytes4 public constant MINT = bytes4(keccak256(""mint(address,uint256)""));
    bytes4 public constant BURN = bytes4(keccak256(""burn(address,uint256)""));

    ICauldronGov public cauldron;
    ILadleGov public ladle;
    address public witch;
    IPoolFactory public poolFactory;
    IJoinFactory public joinFactory;
    IFYTokenFactory public fyTokenFactory;

    constructor (
        ICauldronGov cauldron_,
        ILadleGov ladle_,
        address witch_,
        IPoolFactory poolFactory_,
        IJoinFactory joinFactory_,
        IFYTokenFactory fyTokenFactory_
    ) {
        cauldron = cauldron_;
        ladle = ladle_;
        witch = witch_;
        poolFactory = poolFactory_;
        joinFactory = joinFactory_;
        fyTokenFactory = fyTokenFactory_;
    }

    /// @dev Point to a different cauldron, ladle, witch, poolFactory, joinFactory or fyTokenFactory
    function point(bytes32 param, address value) external auth {
        if (param == ""cauldron"") cauldron = ICauldronGov(value);
        else if (param == ""ladle"") ladle = ILadleGov(value);
        else if (param == ""witch"") witch = value;
        else if (param == ""poolFactory"") poolFactory = IPoolFactory(value);
        else if (param == ""joinFactory"") joinFactory = IJoinFactory(value);
        else if (param == ""fyTokenFactory"") fyTokenFactory = IFYTokenFactory(value);
        else revert(""Unrecognized parameter"");
        emit Point(param, value);
    }

    /// @dev Add an existing asset to the protocol, meaning:
    ///  - Add the asset to the cauldron
    ///  - Deploy a new Join, and integrate it with the Ladle
    ///  - If the asset is a base, integrate its rate source
    ///  - If the asset is a base, integrate a spot source and set a debt ceiling for any provided ilks
    function addAsset(
        bytes6 assetId,
        address asset
    ) external auth {
        // Add asset to cauldron, deploy new Join, and add it to the ladle
        require (address(asset) != address(0), ""Asset required"");
        cauldron.addAsset(assetId, asset);
        AccessControl join = AccessControl(joinFactory.createJoin(asset));  // We need the access control methods of Join
        bytes4[] memory sigs = new bytes4[](2);
        sigs[0] = JOIN;
        sigs[1] = EXIT;
        join.grantRoles(sigs, address(ladle));
        join.grantRole(join.ROOT(), msg.sender);
        // join.renounceRole(join.ROOT(), address(this));  // Wand requires ongoing rights to set up permissions to joins
        ladle.addJoin(assetId, address(join));
    }

    /// @dev Make a base asset out of a generic asset, by adding rate and chi oracles.
    /// This assumes CompoundMultiOracles, which deliver both rate and chi.
    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) external auth {
        require (address(oracle) != address(0), ""Oracle required"");
        require (rateSource != address(0), ""Rate source required"");
        require (chiSource != address(0), ""Chi source required"");

        oracle.setSource(assetId, RATE.b6(), rateSource);
        oracle.setSource(assetId, CHI.b6(), chiSource);
        cauldron.setRateOracle(assetId, IOracle(address(oracle)));
        
        AccessControl baseJoin = AccessControl(address(ladle.joins(assetId)));
        baseJoin.grantRole(JOIN, witch); // Give the Witch permission to join base
    }

    /// @dev Make an ilk asset out of a generic asset, by adding a spot oracle against a base asset, collateralization ratio, and debt ceiling.
    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) external auth {
        oracle.setSource(baseId, ilkId, spotSource);
        cauldron.setSpotOracle(baseId, ilkId, IOracle(address(oracle)), ratio);
        cauldron.setDebtLimits(baseId, ilkId, max, min, dec);

        AccessControl ilkJoin = AccessControl(address(ladle.joins(ilkId)));
        ilkJoin.grantRole(EXIT, witch); // Give the Witch permission to exit ilk
    }

    /// @dev Add an existing series to the protocol, by deploying a FYToken, and registering it in the cauldron with the approved ilks
    /// This must be followed by a call to addPool
    function addSeries(
        bytes6 seriesId,
        bytes6 baseId,
        uint32 maturity,
        bytes6[] memory ilkIds,
        string memory name,
        string memory symbol
    ) external auth {
        address base = cauldron.assets(baseId);
        require(base != address(0), ""Base not found"");

        IJoin baseJoin = ladle.joins(baseId);
        require(address(baseJoin) != address(0), ""Join not found"");

        IOracle oracle = cauldron.rateOracles(baseId);
        require(address(oracle) != address(0), ""Chi oracle not found"");

        AccessControl fyToken = AccessControl(fyTokenFactory.createFYToken(
            baseId,
            oracle,
            baseJoin,
            maturity,
            name,     // Derive from base and maturity, perhaps
            symbol    // Derive from base and maturity, perhaps
        ));

        // Allow the fyToken to pull from the base join for redemption
        bytes4[] memory sigs = new bytes4[](1);
        sigs[0] = EXIT;
        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));

        // Allow the ladle to issue and cancel fyToken
        sigs = new bytes4[](2);
        sigs[0] = MINT;
        sigs[1] = BURN;
        fyToken.grantRoles(sigs, address(ladle));

        // Pass ownership of the fyToken to msg.sender
        fyToken.grantRole(fyToken.ROOT(), msg.sender);
        fyToken.renounceRole(fyToken.ROOT(), address(this));

        // Add fyToken/series to the Cauldron and approve ilks for the series
        cauldron.addSeries(seriesId, baseId, IFYToken(address(fyToken)));
        cauldron.addIlks(seriesId, ilkIds);

        // Create the pool for the base and fyToken
        poolFactory.createPool(base, address(fyToken));
        IOwnable pool = IOwnable(poolFactory.calculatePoolAddress(base, address(fyToken)));
        

        // Pass ownership of pool to msg.sender
        pool.transferOwnership(msg.sender);

        // Register pool in Ladle
        ladle.addPool(seriesId, address(pool));
    }
}",1765
RealWorld_TA_25_TransferHelper_RealWorld_20240803133104.log,25,TransferHelper,62141,2863,65004,364.0,0.367965,"// SPDX-License-Identifier: MIT
// Taken from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol

pragma solidity >=0.6.0;

import ""../../interfaces/external/IERC20.sol"";
import ""../RevertMsgExtractor.sol"";


// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    /// @notice Transfers tokens from msg.sender to a recipient
    /// @dev Errors with the underlying revert message if transfer fails
    /// @param token The contract address of the token which will be transferred
    /// @param to The recipient of the transfer
    /// @param value The value of the transfer
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));
    }

    /// @notice Transfers tokens from the targeted address to the given destination
    /// @dev Errors with the underlying revert message if transfer fails
    /// @param token The contract address of the token to be transferred
    /// @param from The originating address from which the tokens will be transferred
    /// @param to The destination address of the transfer
    /// @param value The amount to be transferred
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));
    }

    /// @notice Transfers ETH to the recipient address
    /// @dev Errors with the underlying revert message if transfer fails
    /// @param to The destination of the transfer
    /// @param value The value to be transferred
    function safeTransferETH(address payable to, uint256 value) internal {
        (bool success, bytes memory data) = to.call{value: value}(new bytes(0));
        if (!success) revert(RevertMsgExtractor.getRevertMsg(data));
    }
}",522
RealWorld_TA_25_Cauldron_RealWorld_20240803102609.log,25,Cauldron,448684,5794,454478,323.0,2.3593,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;
import ""./interfaces/vault/IFYToken.sol"";
import ""./interfaces/vault/IOracle.sol"";
import ""./interfaces/vault/DataTypes.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./math/WMul.sol"";
import ""./math/WDiv.sol"";
import ""./math/CastU128I128.sol"";
import ""./math/CastI128U128.sol"";
import ""./math/CastU256U128.sol"";
import ""./math/CastU256U32.sol"";
import ""./math/CastU256I256.sol"";

library CauldronMath {
    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.
    function add(uint128 x, int128 y) internal pure returns (uint128 z) {
        require (y > 0 || x >= uint128(-y), ""Result below zero"");
        z = y > 0 ? x + uint128(y) : x - uint128(-y);
    }
}

contract Cauldron is AccessControl() {
    using CauldronMath for uint128;
    using WMul for uint256;
    using WDiv for uint256;
    using CastU128I128 for uint128;
    using CastI128U128 for int128;
    using CastU256U128 for uint256;
    using CastU256U32 for uint256;
    using CastU256I256 for uint256;

    event AssetAdded(bytes6 indexed assetId, address indexed asset);
    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);
    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);
    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);
    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);
    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);

    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);
    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);
    event VaultDestroyed(bytes12 indexed vaultId);
    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);

    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);
    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);
    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);

    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);

    // ==== Configuration data ====
    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.
    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).
    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series

    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying
    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles

    // ==== Protocol data ====
    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.
    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series

    // ==== User data ====
    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier
    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets

    // ==== Administration ====

    /// @dev Add a new Asset.
    function addAsset(bytes6 assetId, address asset)
        external
        auth
    {
        require (assetId != bytes6(0), ""Asset id is zero"");
        require (assets[assetId] == address(0), ""Id already used"");
        assets[assetId] = asset;
        emit AssetAdded(assetId, address(asset));
    }

    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.
    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)
        external
        auth
    {
        require (assets[baseId] != address(0), ""Base not found"");
        require (assets[ilkId] != address(0), ""Ilk not found"");
        DataTypes.Debt memory debt_ = debt[baseId][ilkId];
        debt_.max = max;
        debt_.min = min;
        debt_.dec = dec;
        debt[baseId][ilkId] = debt_;
        emit DebtLimitsSet(baseId, ilkId, max, min, dec);
    }

    /// @dev Set a rate oracle. Can be reset.
    function setRateOracle(bytes6 baseId, IOracle oracle)
        external
        auth
    {
        require (assets[baseId] != address(0), ""Base not found"");
        rateOracles[baseId] = oracle;
        emit RateOracleAdded(baseId, address(oracle));
    }

    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.
    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)
        external
        auth
    {
        require (assets[baseId] != address(0), ""Base not found"");
        require (assets[ilkId] != address(0), ""Ilk not found"");
        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({
            oracle: oracle,
            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%
        });                                                                                 // Allows to replace an existing oracle.
        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);
    }

    /// @dev Add a new series
    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)
        external
        auth
    {
        require (seriesId != bytes6(0), ""Series id is zero"");
        address base = assets[baseId];
        require (base != address(0), ""Base not found"");
        require (fyToken != IFYToken(address(0)), ""Series need a fyToken"");
        require (fyToken.underlying() == base, ""Mismatched series and base"");
        require (rateOracles[baseId] != IOracle(address(0)), ""Rate oracle not found"");
        require (series[seriesId].fyToken == IFYToken(address(0)), ""Id already used"");
        series[seriesId] = DataTypes.Series({
            fyToken: fyToken,
            maturity: fyToken.maturity().u32(),
            baseId: baseId
        });
        emit SeriesAdded(seriesId, baseId, address(fyToken));
    }

    /// @dev Add a new Ilk (approve an asset as collateral for a series).
    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)
        external
        auth
    {
        DataTypes.Series memory series_ = series[seriesId];
        require (
            series_.fyToken != IFYToken(address(0)),
            ""Series not found""
        );
        for (uint256 i = 0; i < ilkIds.length; i++) {
            require (
                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),
                ""Spot oracle not found""
            );
            ilks[seriesId][ilkIds[i]] = true;
            emit IlkAdded(seriesId, ilkIds[i]);
        }
    }

    // ==== Vault management ====

    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral
    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)
        external
        auth
        returns(DataTypes.Vault memory vault)
    {
        require (vaultId != bytes12(0), ""Vault id is zero"");
        require (seriesId != bytes12(0), ""Series id is zero"");
        require (ilkId != bytes12(0), ""Ilk id is zero"");
        require (vaults[vaultId].seriesId == bytes6(0), ""Vault already exists"");   // Series can't take bytes6(0) as their id
        require (ilks[seriesId][ilkId] == true, ""Ilk not added to series"");
        vault = DataTypes.Vault({
            owner: owner,
            seriesId: seriesId,
            ilkId: ilkId
        });
        vaults[vaultId] = vault;

        emit VaultBuilt(vaultId, owner, seriesId, ilkId);
    }

    /// @dev Destroy an empty vault. Used to recover gas costs.
    function destroy(bytes12 vaultId)
        external
        auth
    {
        DataTypes.Balances memory balances_ = balances[vaultId];
        require (balances_.art == 0 && balances_.ink == 0, ""Only empty vaults"");
        delete vaults[vaultId];
        emit VaultDestroyed(vaultId);
    }

    /// @dev Change a vault series and/or collateral types.
    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)
        internal
    {
        require (vault.seriesId != bytes6(0), ""Series id is zero"");
        require (vault.ilkId != bytes6(0), ""Ilk id is zero"");
        require (ilks[vault.seriesId][vault.ilkId] == true, ""Ilk not added to series"");

        vaults[vaultId] = vault;
        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);
    }

    /// @dev Change a vault series and/or collateral types.
    /// We can change the series if there is no debt, or assets if there are no assets
    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)
        external
        auth
        returns(DataTypes.Vault memory vault)
    {
        DataTypes.Balances memory balances_ = balances[vaultId];
        vault = vaults[vaultId];
        if (seriesId != vault.seriesId) {
            require (balances_.art == 0, ""Only with no debt"");
            vault.seriesId = seriesId;
        }
        if (ilkId != vault.ilkId) {
            require (balances_.ink == 0, ""Only with no collateral"");
            vault.ilkId = ilkId;
        }
        _tweak(vaultId, vault);
    }

    /// @dev Transfer a vault to another user.
    function _give(bytes12 vaultId, address receiver)
        internal
        returns(DataTypes.Vault memory vault)
    {
        require (vaultId != bytes12(0), ""Vault id is zero"");
        vault = vaults[vaultId];
        vault.owner = receiver;
        vaults[vaultId] = vault;
        emit VaultGiven(vaultId, receiver);
    }

    /// @dev Transfer a vault to another user.
    function give(bytes12 vaultId, address receiver)
        external
        auth
        returns(DataTypes.Vault memory vault)
    {
        vault = _give(vaultId, receiver);
    }

    // ==== Asset and debt management ====

    function vaultData(bytes12 vaultId, bool getSeries)
        internal
        view
        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)
    {
        vault_ = vaults[vaultId];
        require (vault_.seriesId != bytes6(0), ""Vault not found"");
        if (getSeries) series_ = series[vault_.seriesId];
        balances_ = balances[vaultId];
    }

    /// @dev Convert a debt amount for a series from base to fyToken terms.
    /// @notice Think about rounding if using, since we are dividing.
    function debtFromBase(bytes6 seriesId, uint128 base)
        external
        returns (uint128 art)
    {
        if (uint32(block.timestamp) >= series[seriesId].maturity) {
            DataTypes.Series memory series_ = series[seriesId];
            art = uint256(base).wdiv(_accrual(seriesId, series_)).u128();
        } else {
            art = base;
        }
    }

    /// @dev Convert a debt amount for a series from fyToken to base terms
    function debtToBase(bytes6 seriesId, uint128 art)
        external
        returns (uint128 base)
    {
        if (uint32(block.timestamp) >= series[seriesId].maturity) {
            DataTypes.Series memory series_ = series[seriesId];
            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();
        } else {
            base = art;
        }
    }

    /// @dev Move collateral and debt between vaults.
    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)
        external
        auth
        returns (DataTypes.Balances memory, DataTypes.Balances memory)
    {
        require (from != to, ""Identical vaults"");
        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);
        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);

        if (ink > 0) {
            require (vaultFrom.ilkId == vaultTo.ilkId, ""Different collateral"");
            balancesFrom.ink -= ink;
            balancesTo.ink += ink;
        }
        if (art > 0) {
            require (vaultFrom.seriesId == vaultTo.seriesId, ""Different series"");
            balancesFrom.art -= art;
            balancesTo.art += art;
        }

        balances[from] = balancesFrom;
        balances[to] = balancesTo;

        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, ""Undercollateralized at origin"");
        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, ""Undercollateralized at destination"");

        emit VaultStirred(from, to, ink, art);
        return (balancesFrom, balancesTo);
    }

    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user
    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user
    function _pour(
        bytes12 vaultId,
        DataTypes.Vault memory vault_,
        DataTypes.Balances memory balances_,
        DataTypes.Series memory series_,
        int128 ink,
        int128 art
    )
        internal returns (DataTypes.Balances memory)
    {
        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.
        if (ink != 0) {
            balances_.ink = balances_.ink.add(ink);
        }

        // Modify vault and global debt records. If debt increases, check global limit.
        if (art != 0) {
            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];
            balances_.art = balances_.art.add(art);
            debt_.sum = debt_.sum.add(art);
            uint128 dust = debt_.min * uint128(10) ** debt_.dec;
            uint128 line = debt_.max * uint128(10) ** debt_.dec;
            require (balances_.art == 0 || balances_.art >= dust, ""Min debt not reached"");
            if (art > 0) require (debt_.sum <= line, ""Max debt exceeded"");
            debt[series_.baseId][vault_.ilkId] = debt_;
        }
        balances[vaultId] = balances_;

        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);
        return balances_;
    }

    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.
    /// To be used by debt management contracts.
    function pour(bytes12 vaultId, int128 ink, int128 art)
        external
        auth
        returns (DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);

        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);

        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe
            require(_level(vault_, balances_, series_) >= 0, ""Undercollateralized"");
        return balances_;
    }

    /// @dev Give an uncollateralized vault to another user.
    /// To be used for liquidation engines.
    function grab(bytes12 vaultId, address receiver)
        external
        auth
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);
        require(_level(vault_, balances_, series_) < 0, ""Not undercollateralized"");
        _give(vaultId, receiver);
    }

    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.
    /// To be used by liquidation engines.
    function slurp(bytes12 vaultId, uint128 ink, uint128 art)
        external
        auth
        returns (DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);

        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));

        return balances_;
    }

    /// @dev Change series and debt of a vault.
    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.
    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)
        external
        auth
        returns (DataTypes.Vault memory, DataTypes.Balances memory)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);
        DataTypes.Series memory newSeries_ = series[newSeriesId];
        require (oldSeries_.baseId == newSeries_.baseId, ""Mismatched bases in series"");
        
        // Change the vault series
        vault_.seriesId = newSeriesId;
        _tweak(vaultId, vault_);

        // Change the vault balances
        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);

        require(_level(vault_, balances_, newSeries_) >= 0, ""Undercollateralized"");
        emit VaultRolled(vaultId, newSeriesId, balances_.art);

        return (vault_, balances_);
    }

    // ==== Accounting ====

    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.
    function level(bytes12 vaultId)
        external
        returns (int256)
    {
        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);

        return _level(vault_, balances_, series_);
    }

    /// @dev Record the borrowing rate at maturity for a series
    function mature(bytes6 seriesId)
        external
    {
        require (ratesAtMaturity[seriesId] == 0, ""Already matured"");
        DataTypes.Series memory series_ = series[seriesId];
        _mature(seriesId, series_);
    }

    /// @dev Record the borrowing rate at maturity for a series
    function _mature(bytes6 seriesId, DataTypes.Series memory series_)
        internal
    {
        require (uint32(block.timestamp) >= series_.maturity, ""Only after maturity"");
        IOracle rateOracle = rateOracles[series_.baseId];
        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(""rate""), 1e18);
        ratesAtMaturity[seriesId] = rateAtMaturity;
        emit SeriesMatured(seriesId, rateAtMaturity);
    }

    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.
    function accrual(bytes6 seriesId)
        external
        returns (uint256)
    {
        DataTypes.Series memory series_ = series[seriesId];
        return _accrual(seriesId, series_);
    }

    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.
    /// Note: Call only after checking we are past maturity
    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)
        private
        returns (uint256 accrual_)
    {
        uint256 rateAtMaturity = ratesAtMaturity[seriesId];
        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.
            _mature(seriesId, series_);
        } else {
            IOracle rateOracle = rateOracles[series_.baseId];
            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(""rate""), 1e18);
            accrual_ = rate.wdiv(rateAtMaturity);
        }
        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)
    }

    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.
    function _level(
        DataTypes.Vault memory vault_,
        DataTypes.Balances memory balances_,
        DataTypes.Series memory series_
    )
        internal
        returns (int256)
    {
        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];
        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals
        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot

        if (uint32(block.timestamp) >= series_.maturity) {
            uint256 accrual_ = _accrual(vault_.seriesId, series_);
            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();
        }

        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();
    }
}",5041
RealWorld_TA_25_ERC20_RealWorld_20240803130612.log,25,ERC20,165683,3002,168685,386.0,0.888455,"// SPDX-License-Identifier: MIT
// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.

pragma solidity ^0.8.0;
import ""../../interfaces/external/IERC20Metadata.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 * 
 * Calls to {transferFrom} do not check for allowance if the caller is the owner
 * of the funds. This allows to reduce the number of approvals that are necessary.
 *
 * Finally, {transferFrom} does not decrease the allowance if it is set to
 * type(uint256).max. This reduces the gas costs without any likely impact.
 */
contract ERC20 is IERC20Metadata {
    uint256                                           internal  _totalSupply;
    mapping (address => uint256)                      internal  _balanceOf;
    mapping (address => mapping (address => uint256)) internal  _allowance;
    string                                            public override name = ""???"";
    string                                            public override symbol = ""???"";
    uint8                                             public override decimals = 18;

    /**
     *  @dev Sets the values for {name}, {symbol} and {decimals}.
     */
    constructor(string memory name_, string memory symbol_, uint8 decimals_) {
        name = name_;
        symbol = symbol_;
        decimals = decimals_;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() external view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address guy) external view virtual override returns (uint256) {
        return _balanceOf[guy];
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) external view virtual override returns (uint256) {
        return _allowance[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     */
    function approve(address spender, uint wad) external virtual override returns (bool) {
        return _setAllowance(msg.sender, spender, wad);
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - the caller must have a balance of at least `wad`.
     */
    function transfer(address dst, uint wad) external virtual override returns (bool) {
        return _transfer(msg.sender, dst, wad);
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `src` must have a balance of at least `wad`.
     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least
     * `wad`.
     */
    /// if_succeeds {:msg ""TransferFrom - decrease allowance""} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;
    function transferFrom(address src, address dst, uint wad) external virtual override returns (bool) {
        _decreaseAllowance(src, wad);

        return _transfer(src, dst, wad);
    }

    /**
     * @dev Moves tokens `wad` from `src` to `dst`.
     * 
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `src` must have a balance of at least `amount`.
     */
    /// if_succeeds {:msg ""Transfer - src decrease""} old(_balanceOf[src]) >= _balanceOf[src];
    /// if_succeeds {:msg ""Transfer - dst increase""} _balanceOf[dst] >= old(_balanceOf[dst]);
    /// if_succeeds {:msg ""Transfer - supply""} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];
    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {
        require(_balanceOf[src] >= wad, ""ERC20: Insufficient balance"");
        unchecked { _balanceOf[src] = _balanceOf[src] - wad; }
        _balanceOf[dst] = _balanceOf[dst] + wad;

        emit Transfer(src, dst, wad);

        return true;
    }

    /**
     * @dev Sets the allowance granted to `spender` by `owner`.
     *
     * Emits an {Approval} event indicating the updated allowance.
     */
    function _setAllowance(address owner, address spender, uint wad) internal virtual returns (bool) {
        _allowance[owner][spender] = wad;
        emit Approval(owner, spender, wad);

        return true;
    }

    /**
     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX
     *
     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.
     *
     * Requirements:
     *
     * - `spender` must have allowance for the caller of at least
     * `wad`, unless src == msg.sender
     */
    /// if_succeeds {:msg ""Decrease allowance - underflow""} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];
    function _decreaseAllowance(address src, uint wad) internal virtual returns (bool) {
        if (src != msg.sender) {
            uint256 allowed = _allowance[src][msg.sender];
            if (allowed != type(uint).max) {
                require(allowed >= wad, ""ERC20: Insufficient approval"");
                unchecked { _setAllowance(src, msg.sender, allowed - wad); }
            }
        }

        return true;
    }

    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     */
    /// if_succeeds {:msg ""Mint - balance overflow""} old(_balanceOf[dst]) >= _balanceOf[dst];
    /// if_succeeds {:msg ""Mint - supply overflow""} old(_totalSupply) >= _totalSupply;
    function _mint(address dst, uint wad) internal virtual returns (bool) {
        _balanceOf[dst] = _balanceOf[dst] + wad;
        _totalSupply = _totalSupply + wad;
        emit Transfer(address(0), dst, wad);

        return true;
    }

    /**
     * @dev Destroys `wad` tokens from `src`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `src` must have at least `wad` tokens.
     */
    /// if_succeeds {:msg ""Burn - balance underflow""} old(_balanceOf[src]) <= _balanceOf[src];
    /// if_succeeds {:msg ""Burn - supply underflow""} old(_totalSupply) <= _totalSupply;
    function _burn(address src, uint wad) internal virtual returns (bool) {
        unchecked {
            require(_balanceOf[src] >= wad, ""ERC20: Insufficient balance"");
            _balanceOf[src] = _balanceOf[src] - wad;
            _totalSupply = _totalSupply - wad;
            emit Transfer(src, address(0), wad);
        }

        return true;
    }
}",1799
RealWorld_TA_25_AddressStringUtil_RealWorld_20240803123517.log,25,AddressStringUtil,42823,1187,44010,370.0,0.237855,"// SPDX-License-Identifier: MIT

pragma solidity >=0.5.0;

library AddressStringUtil {
    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)
    function toAsciiString(address addr, uint256 len) internal pure returns (string memory) {
        require(len % 2 == 0 && len > 0 && len <= 40, ""AddressStringUtil: INVALID_LEN"");
        bytes memory s = new bytes(len);
        uint256 addrNum = uint256(uint160(addr));
        for (uint256 ii = 0; ii < len ; ii +=2) {
            uint8 b = uint8(addrNum >> (4 * (38 - ii)));
            s[ii] = char(b >> 4);
            s[ii + 1] = char(b & 0x0f);
        }
        return string(s);
    }

    // hi and lo are only 4 bits and between 0 and 16
    // this method converts those values to the unicode/ascii code point for the hex representation
    // uses upper case for the characters
    function char(uint8 b) private pure returns (bytes1 c) {
        if (b < 10) {
            return bytes1(b + 0x30);
        } else {
            return bytes1(b + 0x37);
        }
    }
}",290
RealWorld_TA_25_Pool_RealWorld_20240803112710.log,25,Pool,566505,5098,571603,392.0,2.934485,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../utils/access/Ownable.sol"";
import ""../interfaces/external/IERC20.sol"";
import ""../interfaces/external/IERC20Metadata.sol"";
import ""../utils/token/ERC20Permit.sol"";
import ""../utils/token/SafeERC20Namer.sol"";
import ""../utils/token/MinimalTransferHelper.sol"";
import ""../interfaces/yieldspace/IPool.sol"";
import ""../interfaces/yieldspace/IPoolFactory.sol"";
import ""../interfaces/vault/IFYToken.sol"";
import ""./YieldMath.sol"";


library SafeCast256 {
    /// @dev Safely cast an uint256 to an uint112
    function u112(uint256 x) internal pure returns (uint112 y) {
        require (x <= type(uint112).max, ""Cast overflow"");
        y = uint112(x);
    }

    /// @dev Safely cast an uint256 to an uint128
    function u128(uint256 x) internal pure returns (uint128 y) {
        require (x <= type(uint128).max, ""Cast overflow"");
        y = uint128(x);
    }

    /// @dev Safe casting from uint256 to int256
    function i256(uint256 x) internal pure returns(int256) {
        require(x <= uint256(type(int256).max), ""Cast overflow"");
        return int256(x);
    }
}

library SafeCast128 {
    /// @dev Safely cast an uint128 to an int128
    function i128(uint128 x) internal pure returns (int128 y) {
        require (x <= uint128(type(int128).max), ""Cast overflow"");
        y = int128(x);
    }

    /// @dev Safely cast an uint128 to an uint112
    function u112(uint128 x) internal pure returns (uint112 y) {
        require (x <= uint128(type(uint112).max), ""Cast overflow"");
        y = uint112(x);
    }
}


/// @dev The Pool contract exchanges base for fyToken at a price defined by a specific formula.
contract Pool is IPool, ERC20Permit, Ownable {
    using SafeCast256 for uint256;
    using SafeCast128 for uint128;
    using MinimalTransferHelper for IERC20;

    event Trade(uint32 maturity, address indexed from, address indexed to, int256 bases, int256 fyTokens);
    event Liquidity(uint32 maturity, address indexed from, address indexed to, int256 bases, int256 fyTokens, int256 poolTokens);
    event Sync(uint112 baseCached, uint112 fyTokenCached, uint256 cumulativeBalancesRatio);
    event ParameterSet(bytes32 parameter, int128 k);

    int128 private k1 = int128(uint128(uint256((1 << 64))) / 315576000); // 1 / Seconds in 10 years, in 64.64
    int128 private g1 = int128(uint128(uint256((950 << 64))) / 1000); // To be used when selling base to the pool. All constants are `ufixed`, to divide them they must be converted to uint256
    int128 private k2 = int128(uint128(uint256((1 << 64))) / 315576000); // k is stored twice to be able to recover with 1 SLOAD alongside both g1 and g2
    int128 private g2 = int128(uint128(uint256((1000 << 64))) / 950); // To be used when selling fyToken to the pool. All constants are `ufixed`, to divide them they must be converted to uint256
    uint32 public immutable override maturity;

    IERC20 public immutable override base;
    IFYToken public immutable override fyToken;

    uint112 private baseCached;              // uses single storage slot, accessible via getCache
    uint112 private fyTokenCached;           // uses single storage slot, accessible via getCache
    uint32  private blockTimestampLast;      // uses single storage slot, accessible via getCache

    uint256 public cumulativeBalancesRatio;  // Fixed point factor with 27 decimals (ray)

    constructor()
        ERC20Permit(
            string(abi.encodePacked(""Yield "", SafeERC20Namer.tokenName(IPoolFactory(msg.sender).nextFYToken()), "" LP Token"")),
            string(abi.encodePacked(SafeERC20Namer.tokenSymbol(IPoolFactory(msg.sender).nextFYToken()), ""LP"")),
            SafeERC20Namer.tokenDecimals(IPoolFactory(msg.sender).nextBase())
        )
    {
        IFYToken _fyToken = IFYToken(IPoolFactory(msg.sender).nextFYToken());
        fyToken = _fyToken;
        base = IERC20(IPoolFactory(msg.sender).nextBase());

        uint256 _maturity = _fyToken.maturity();
        require (_maturity <= type(uint32).max, ""Pool: Maturity too far in the future"");
        maturity = uint32(_maturity);
    }

    /// @dev Trading can only be done before maturity
    modifier beforeMaturity() {
        require(
            block.timestamp < maturity,
            ""Pool: Too late""
        );
        _;
    }

    // ---- Administration ----

    /// @dev Set the k, g1 or g2 parameters
    function setParameter(bytes32 parameter, int128 value)
        external onlyOwner
    {
        if (parameter == ""k"") k1 = k2 = value;
        else if (parameter == ""g1"") g1 = value;
        else if (parameter == ""g2"") g2 = value;
        else revert(""Pool: Unrecognized parameter"");
        emit ParameterSet(parameter, value);
    }

    /// @dev Get k
    function getK()
        external view
        returns (int128)
    {
        assert(k1 == k2);
        return k1;
    }

    /// @dev Get g1
    function getG1()
        external view
        returns (int128)
    {
        return g1;
    }

    /// @dev Get g2
    function getG2()
        external view
        returns (int128)
    {
        return g2;
    }

    // ---- Balances management ----

    /// @dev Updates the cache to match the actual balances.
    function sync() external {
        _update(getBaseBalance(), getFYTokenBalance(), baseCached, fyTokenCached);
    }

    /// @dev Returns the cached balances & last updated timestamp.
    /// @return Cached base token balance.
    /// @return Cached virtual FY token balance.
    /// @return Timestamp that balances were last cached.
    function getCache()
        external view
        returns (uint112, uint112, uint32)
    {
        return (baseCached, fyTokenCached, blockTimestampLast);
    }

    /// @dev Returns the ""virtual"" fyToken balance, which is the real balance plus the pool token supply.
    function getFYTokenBalance()
        public view override
        returns(uint112)
    {
        return (fyToken.balanceOf(address(this)) + _totalSupply).u112();
    }

    /// @dev Returns the base balance
    function getBaseBalance()
        public view override
        returns(uint112)
    {
        return base.balanceOf(address(this)).u112();
    }

    /// @dev Retrieve any base tokens not accounted for in the cache
    function retrieveBase(address to)
        external override
        returns(uint128 retrieved)
    {
        retrieved = getBaseBalance() - baseCached; // Cache can never be above balances
        base.safeTransfer(to, retrieved);
        // Now the current balances match the cache, so no need to update the TWAR
    }

    /// @dev Retrieve any fyTokens not accounted for in the cache
    function retrieveFYToken(address to)
        external override
        returns(uint128 retrieved)
    {
        retrieved = getFYTokenBalance() - fyTokenCached; // Cache can never be above balances
        IERC20(address(fyToken)).safeTransfer(to, retrieved);
        // Now the balances match the cache, so no need to update the TWAR
    }

    /// @dev Update cache and, on the first call per block, ratio accumulators
    function _update(uint128 baseBalance, uint128 fyBalance, uint112 _baseCached, uint112 _fyTokenCached) private {
        uint32 blockTimestamp = uint32(block.timestamp);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _baseCached != 0 && _fyTokenCached != 0) {
            // We multiply by 1e27 here so that r = t * y/x is a fixed point factor with 27 decimals 
            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27;
            cumulativeBalancesRatio += scaledFYTokenCached  * timeElapsed / _baseCached;
        }
        baseCached = baseBalance.u112();
        fyTokenCached = fyBalance.u112();
        blockTimestampLast = blockTimestamp;
        emit Sync(baseCached, fyTokenCached, cumulativeBalancesRatio);
    }

    // ---- Liquidity ----

    /// @dev Mint liquidity tokens in exchange for adding base and fyToken
    /// The amount of liquidity tokens to mint is calculated from the amount of unaccounted for base tokens in this contract.
    /// A proportional amount of fyTokens needs to be present in this contract, also unaccounted for.
    /// @param to Wallet receiving the minted liquidity tokens.
    /// @param calculateFromBase Calculate the amount of tokens to mint from the base tokens available, leaving a fyToken surplus.
    /// @param minTokensMinted Minimum amount of liquidity tokens received.
    /// @return The amount of liquidity tokens minted.
    function mint(address to, bool calculateFromBase, uint256 minTokensMinted)
        external override
        returns (uint256, uint256, uint256)
    {
        return _mintInternal(to, calculateFromBase, 0, minTokensMinted);
    }

    /// @dev Mint liquidity tokens in exchange for adding only base
    /// The amount of liquidity tokens is calculated from the amount of fyToken to buy from the pool.
    /// The base tokens need to be present in this contract, unaccounted for.
    /// @param to Wallet receiving the minted liquidity tokens.
    /// @param fyTokenToBuy Amount of `fyToken` being bought in the Pool, from this we calculate how much base it will be taken in.
    /// @param minTokensMinted Minimum amount of liquidity tokens received.
    /// @return The amount of liquidity tokens minted.
    function mintWithBase(address to, uint256 fyTokenToBuy, uint256 minTokensMinted)
        external override
        returns (uint256, uint256, uint256)
    {
        return _mintInternal(to, false, fyTokenToBuy, minTokensMinted);
    }

    /// @dev Mint liquidity tokens in exchange for adding only base, if fyTokenToBuy > 0.
    /// If fyTokenToBuy == 0, mint liquidity tokens for both basea and fyToken.
    /// @param to Wallet receiving the minted liquidity tokens.
    /// @param calculateFromBase Calculate the amount of tokens to mint from the base tokens available, leaving a fyToken surplus.
    /// @param fyTokenToBuy Amount of `fyToken` being bought in the Pool, from this we calculate how much base it will be taken in.
    /// @param minTokensMinted Minimum amount of liquidity tokens received.
    /// @return The amount of liquidity tokens minted.
    function _mintInternal(address to, bool calculateFromBase, uint256 fyTokenToBuy, uint256 minTokensMinted)
        internal
        returns (uint256, uint256, uint256)
    {
        // Gather data
        uint256 supply = _totalSupply;
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply

        // Calculate trade
        uint256 tokensMinted;
        uint256 baseIn;
        uint256 baseReturned;
        uint256 fyTokenIn;

        if (supply == 0) {
            require (calculateFromBase && fyTokenToBuy == 0, ""Pool: Initialize only from base"");
            baseIn = base.balanceOf(address(this)) - _baseCached;
            tokensMinted = baseIn;   // If supply == 0 we are initializing the pool and tokensMinted == baseIn; fyTokenIn == 0
        } else {
            // There is an optional virtual trade before the mint
            uint256 baseToSell;
            if (fyTokenToBuy > 0) {     // calculateFromBase == true and fyTokenToBuy > 0 can't happen in this implementation. To implement a virtual trade and calculateFromBase the trade would need to be a BaseToBuy parameter.
                baseToSell = _buyFYTokenPreview(
                    fyTokenToBuy.u128(),
                    _baseCached,
                    _fyTokenCached
                ); 
            }

            if (calculateFromBase) {   // We use all the available base tokens, surplus is in fyTokens
                baseIn = base.balanceOf(address(this)) - _baseCached;
                tokensMinted = (supply * baseIn) / _baseCached;
                fyTokenIn = (_realFYTokenCached * tokensMinted) / supply;
                require(_realFYTokenCached + fyTokenIn <= fyToken.balanceOf(address(this)), ""Pool: Not enough fyToken in"");
            } else {                   // We use all the available fyTokens, plus a virtual trade if it happened, surplus is in base tokens
                fyTokenIn = fyToken.balanceOf(address(this)) - _realFYTokenCached;
                tokensMinted = (supply * (fyTokenToBuy + fyTokenIn)) / (_realFYTokenCached - fyTokenToBuy);
                baseIn = baseToSell + ((_baseCached + baseToSell) * tokensMinted) / supply;
                uint256 _baseBalance = base.balanceOf(address(this));
                require(_baseBalance - _baseCached >= baseIn, ""Pool: Not enough base token in"");
                
                // If we did a trade means we came in through `mintWithBase`, and want to return the base token surplus
                if (fyTokenToBuy > 0) baseReturned = (_baseBalance - _baseCached) - baseIn;
            }
        }

        // Slippage
        require (tokensMinted >= minTokensMinted, ""Pool: Not enough tokens minted"");

        // Update TWAR
        _update(
            (_baseCached + baseIn).u128(),
            (_fyTokenCached + fyTokenIn + tokensMinted).u128(), // Account for the ""virtual"" fyToken from the new minted LP tokens
            _baseCached,
            _fyTokenCached
        );

        // Execute mint
        _mint(to, tokensMinted);

        // Return any unused base if we did a trade, meaning slippage was involved.
        if (supply > 0 && fyTokenToBuy > 0) base.safeTransfer(to, baseReturned);

        emit Liquidity(maturity, msg.sender, to, -(baseIn.i256()), -(fyTokenIn.i256()), tokensMinted.i256());
        return (baseIn, fyTokenIn, tokensMinted);
    }

    /// @dev Burn liquidity tokens in exchange for base and fyToken.
    /// The liquidity tokens need to be in this contract.
    /// @param to Wallet receiving the base and fyToken.
    /// @return The amount of tokens burned and returned (tokensBurned, bases, fyTokens).
    function burn(address to, uint256 minBaseOut, uint256 minFYTokenOut)
        external override
        returns (uint256, uint256, uint256)
    {
        return _burnInternal(to, false, minBaseOut, minFYTokenOut);
    }

    /// @dev Burn liquidity tokens in exchange for base.
    /// The liquidity provider needs to have called `pool.approve`.
    /// @param to Wallet receiving the base and fyToken.
    /// @return tokensBurned The amount of lp tokens burned.
    /// @return baseOut The amount of base tokens returned.
    function burnForBase(address to, uint256 minBaseOut)
        external override
        returns (uint256 tokensBurned, uint256 baseOut)
    {
        (tokensBurned, baseOut, ) = _burnInternal(to, true, minBaseOut, 0);
    }


    /// @dev Burn liquidity tokens in exchange for base.
    /// The liquidity provider needs to have called `pool.approve`.
    /// @param to Wallet receiving the base and fyToken.
    /// @param tradeToBase Whether the resulting fyToken should be traded for base tokens.
    /// @return tokensBurned The amount of pool tokens burned.
    /// @return tokenOut The amount of base tokens returned.
    /// @return fyTokenOut The amount of fyTokens returned.
    function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)
        internal
        returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)
    {
        
        tokensBurned = _balanceOf[address(this)];
        uint256 supply = _totalSupply;
        uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one
        uint256 baseBalance = base.balanceOf(address(this));
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);

        // Calculate trade
        tokenOut = (tokensBurned * baseBalance) / supply;
        fyTokenOut = (tokensBurned * fyTokenBalance) / supply;

        if (tradeToBase) {
            (int128 _k, int128 _g2) = (k2, g2);
            tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell
                _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn
                _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn
                fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained
                maturity - uint32(block.timestamp),                         // This can't be called after maturity
                _k,
                _g2
            );
            fyTokenOut = 0;
        }

        // Slippage
        require (tokenOut >= minBaseOut, ""Pool: Not enough base tokens obtained"");
        require (fyTokenOut >= minFYTokenOut, ""Pool: Not enough fyToken obtained"");

        // Update TWAR
        _update(
            (baseBalance - tokenOut).u128(),
            (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),
            _baseCached,
            _fyTokenCached
        );

        // Transfer assets
        _burn(address(this), tokensBurned);
        base.safeTransfer(to, tokenOut);
        if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);

        emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));
    }

    // ---- Trading ----

    /// @dev Sell base for fyToken.
    /// The trader needs to have transferred the amount of base to sell to the pool before in the same transaction.
    /// @param to Wallet receiving the fyToken being bought
    /// @param min Minimm accepted amount of fyToken
    /// @return Amount of fyToken that will be deposited on `to` wallet
    function sellBase(address to, uint128 min)
        external override
        returns(uint128)
    {
        // Calculate trade
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        uint112 _baseBalance = getBaseBalance();
        uint112 _fyTokenBalance = getFYTokenBalance();
        uint128 baseIn = _baseBalance - _baseCached;
        uint128 fyTokenOut = _sellBasePreview(
            baseIn,
            _baseCached,
            _fyTokenBalance
        );

        // Slippage check
        require(
            fyTokenOut >= min,
            ""Pool: Not enough fyToken obtained""
        );

        // Update TWAR
        _update(
            _baseBalance,
            _fyTokenBalance - fyTokenOut,
            _baseCached,
            _fyTokenCached
        );

        // Transfer assets
        IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);

        emit Trade(maturity, msg.sender, to, -(baseIn.i128()), fyTokenOut.i128());
        return fyTokenOut;
    }

    /// @dev Returns how much fyToken would be obtained by selling `baseIn` base
    /// @param baseIn Amount of base hypothetically sold.
    /// @return Amount of fyToken hypothetically bought.
    function sellBasePreview(uint128 baseIn)
        external view override
        returns(uint128)
    {
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        return _sellBasePreview(baseIn, _baseCached, _fyTokenCached);
    }

    /// @dev Returns how much fyToken would be obtained by selling `baseIn` base
    function _sellBasePreview(
        uint128 baseIn,
        uint112 baseBalance,
        uint112 fyTokenBalance
    )
        private view
        beforeMaturity
        returns(uint128)
    {
        (int128 _k, int128 _g1) = (k1, g1);
        uint128 fyTokenOut = YieldMath.fyTokenOutForBaseIn(
            baseBalance,
            fyTokenBalance,
            baseIn,
            maturity - uint32(block.timestamp),             // This can't be called after maturity
            _k,
            _g1
        );

        require(
            fyTokenBalance - fyTokenOut >= baseBalance + baseIn,
            ""Pool: fyToken balance too low""
        );

        return fyTokenOut;
    }

    /// @dev Buy base for fyToken
    /// The trader needs to have called `fyToken.approve`
    /// @param to Wallet receiving the base being bought
    /// @param tokenOut Amount of base being bought that will be deposited in `to` wallet
    /// @param max Maximum amount of fyToken that will be paid for the trade
    /// @return Amount of fyToken that will be taken from caller
    function buyBase(address to, uint128 tokenOut, uint128 max)
        external override
        returns(uint128)
    {
        // Calculate trade
        uint128 fyTokenBalance = getFYTokenBalance();
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        uint128 fyTokenIn = _buyBasePreview(
            tokenOut,
            _baseCached,
            _fyTokenCached
        );
        require(
            fyTokenBalance - _fyTokenCached >= fyTokenIn,
            ""Pool: Not enough fyToken in""
        );

        // Slippage check
        require(
            fyTokenIn <= max,
            ""Pool: Too much fyToken in""
        );

        // Update TWAR
        _update(
            _baseCached - tokenOut,
            _fyTokenCached + fyTokenIn,
            _baseCached,
            _fyTokenCached
        );

        // Transfer assets
        base.safeTransfer(to, tokenOut);

        emit Trade(maturity, msg.sender, to, tokenOut.i128(), -(fyTokenIn.i128()));
        return fyTokenIn;
    }

    /// @dev Returns how much fyToken would be required to buy `tokenOut` base.
    /// @param tokenOut Amount of base hypothetically desired.
    /// @return Amount of fyToken hypothetically required.
    function buyBasePreview(uint128 tokenOut)
        external view override
        returns(uint128)
    {
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        return _buyBasePreview(tokenOut, _baseCached, _fyTokenCached);
    }

    /// @dev Returns how much fyToken would be required to buy `tokenOut` base.
    function _buyBasePreview(
        uint128 tokenOut,
        uint112 baseBalance,
        uint112 fyTokenBalance
    )
        private view
        beforeMaturity
        returns(uint128)
    {
        (int128 _k, int128 _g2) = (k2, g2);
        return YieldMath.fyTokenInForBaseOut(
            baseBalance,
            fyTokenBalance,
            tokenOut,
            maturity - uint32(block.timestamp),             // This can't be called after maturity
            _k,
            _g2
        );
    }

    /// @dev Sell fyToken for base
    /// The trader needs to have transferred the amount of fyToken to sell to the pool before in the same transaction.
    /// @param to Wallet receiving the base being bought
    /// @param min Minimm accepted amount of base
    /// @return Amount of base that will be deposited on `to` wallet
    function sellFYToken(address to, uint128 min)
        external override
        returns(uint128)
    {
        // Calculate trade
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        uint112 _fyTokenBalance = getFYTokenBalance();
        uint112 _baseBalance = getBaseBalance();
        uint128 fyTokenIn = _fyTokenBalance - _fyTokenCached;
        uint128 baseOut = _sellFYTokenPreview(
            fyTokenIn,
            _baseCached,
            _fyTokenCached
        );

        // Slippage check
        require(
            baseOut >= min,
            ""Pool: Not enough base obtained""
        );

        // Update TWAR
        _update(
            _baseBalance - baseOut,
            _fyTokenBalance,
            _baseCached,
            _fyTokenCached
        );

        // Transfer assets
        base.safeTransfer(to, baseOut);

        emit Trade(maturity, msg.sender, to, baseOut.i128(), -(fyTokenIn.i128()));
        return baseOut;
    }

    /// @dev Returns how much base would be obtained by selling `fyTokenIn` fyToken.
    /// @param fyTokenIn Amount of fyToken hypothetically sold.
    /// @return Amount of base hypothetically bought.
    function sellFYTokenPreview(uint128 fyTokenIn)
        external view override
        returns(uint128)
    {
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        return _sellFYTokenPreview(fyTokenIn, _baseCached, _fyTokenCached);
    }

    /// @dev Returns how much base would be obtained by selling `fyTokenIn` fyToken.
    function _sellFYTokenPreview(
        uint128 fyTokenIn,
        uint112 baseBalance,
        uint112 fyTokenBalance
    )
        private view
        beforeMaturity
        returns(uint128)
    {
        (int128 _k, int128 _g2) = (k2, g2);
        return YieldMath.baseOutForFYTokenIn(
            baseBalance,
            fyTokenBalance,
            fyTokenIn,
            maturity - uint32(block.timestamp),             // This can't be called after maturity
            _k,
            _g2
        );
    }

    /// @dev Buy fyToken for base
    /// The trader needs to have called `base.approve`
    /// @param to Wallet receiving the fyToken being bought
    /// @param fyTokenOut Amount of fyToken being bought that will be deposited in `to` wallet
    /// @param max Maximum amount of base token that will be paid for the trade
    /// @return Amount of base that will be taken from caller's wallet
    function buyFYToken(address to, uint128 fyTokenOut, uint128 max)
        external override
        returns(uint128)
    {
        // Calculate trade
        uint128 baseBalance = getBaseBalance();
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        uint128 baseIn = _buyFYTokenPreview(
            fyTokenOut,
            _baseCached,
            _fyTokenCached
        );
        require(
            baseBalance - _baseCached >= baseIn,
            ""Pool: Not enough base token in""
        );

        // Slippage check
        require(
            baseIn <= max,
            ""Pool: Too much base token in""
        );

        // Update TWAR
        _update(
            _baseCached + baseIn,
            _fyTokenCached - fyTokenOut,
            _baseCached,
            _fyTokenCached
        );

        // Transfer assets
        IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);

        emit Trade(maturity, msg.sender, to, -(baseIn.i128()), fyTokenOut.i128());
        return baseIn;
    }

    /// @dev Returns how much base would be required to buy `fyTokenOut` fyToken.
    /// @param fyTokenOut Amount of fyToken hypothetically desired.
    /// @return Amount of base hypothetically required.
    function buyFYTokenPreview(uint128 fyTokenOut)
        external view override
        returns(uint128)
    {
        (uint112 _baseCached, uint112 _fyTokenCached) =
            (baseCached, fyTokenCached);
        return _buyFYTokenPreview(fyTokenOut, _baseCached, _fyTokenCached);
    }

    /// @dev Returns how much base would be required to buy `fyTokenOut` fyToken.
    function _buyFYTokenPreview(
        uint128 fyTokenOut,
        uint128 baseBalance,
        uint128 fyTokenBalance
    )
        private view
        beforeMaturity
        returns(uint128)
    {
        (int128 _k, int128 _g1) = (k1, g1);
        uint128 baseIn = YieldMath.baseInForFYTokenOut(
            baseBalance,
            fyTokenBalance,
            fyTokenOut,
            maturity - uint32(block.timestamp),             // This can't be called after maturity
            _k,
            _g1
        );

        require(
            fyTokenBalance - fyTokenOut >= baseBalance + baseIn,
            ""Pool: fyToken balance too low""
        );

        return baseIn;
    }
}",6560
RealWorld_TA_25_Join_RealWorld_20240803103135.log,25,Join,129075,5328,134403,365.0,0.751935,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""erc3156/contracts/interfaces/IERC3156FlashBorrower.sol"";
import ""erc3156/contracts/interfaces/IERC3156FlashLender.sol"";
import ""./interfaces/vault/IJoin.sol"";
import ""./interfaces/vault/IJoinFactory.sol"";
import ""./interfaces/external/IERC20.sol"";
import ""./utils/access/AccessControl.sol"";
import ""./utils/token/TransferHelper.sol"";
import ""./math/WMul.sol"";
import ""./math/CastU256U128.sol"";


contract Join is IJoin, IERC3156FlashLender, AccessControl() {
    using TransferHelper for IERC20;
    using WMul for uint256;
    using CastU256U128 for uint256;

    event FlashFeeFactorSet(uint256 indexed fee);

    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(""ERC3156FlashBorrower.onFlashLoan"");
    uint256 constant FLASH_LOANS_DISABLED = type(uint256).max;

    address public immutable override asset;
    uint256 public storedBalance;
    uint256 public flashFeeFactor = FLASH_LOANS_DISABLED; // Fee on flash loans, as a percentage in fixed point with 18 decimals. Flash loans disabled by default.

    constructor(address asset_) {
        asset = asset_;
    }

    /// @dev Set the flash loan fee factor
    function setFlashFeeFactor(uint256 flashFeeFactor_)
        external
        auth
    {
        flashFeeFactor = flashFeeFactor_;
        emit FlashFeeFactorSet(flashFeeFactor_);
    }

    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.
    function join(address user, uint128 amount)
        external override
        auth
        returns (uint128)
    {
        return _join(user, amount);
    }

    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.
    function _join(address user, uint128 amount)
        internal
        returns (uint128)
    {
        IERC20 token = IERC20(asset);
        uint256 _storedBalance = storedBalance;
        uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows
        storedBalance = _storedBalance + amount;
        unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }
        return amount;        
    }

    /// @dev Transfer `amount` `asset` to `user`
    function exit(address user, uint128 amount)
        external override
        auth
        returns (uint128)
    {
        return _exit(user, amount);
    }

    /// @dev Transfer `amount` `asset` to `user`
    function _exit(address user, uint128 amount)
        internal
        returns (uint128)
    {
        IERC20 token = IERC20(asset);
        storedBalance -= amount;
        token.safeTransfer(user, amount);
        return amount;
    }

    /// @dev Retrieve any tokens other than the `asset`. Useful for airdropped tokens.
    function retrieve(IERC20 token, address to)
        external
        auth
    {
        require(address(token) != address(asset), ""Use exit for asset"");
        token.safeTransfer(to, token.balanceOf(address(this)));
    }

    /**
     * @dev From ERC-3156. The amount of currency available to be lended.
     * @param token The loan currency. It must be a FYDai contract.
     * @return The amount of `token` that can be borrowed.
     */
    function maxFlashLoan(address token)
        external view override
        returns (uint256)
    {
        return token == asset ? storedBalance : 0;
    }

    /**
     * @dev From ERC-3156. The fee to be charged for a given loan.
     * @param token The loan currency. It must be the asset.
     * @param amount The amount of tokens lent.
     * @return The amount of `token` to be charged for the loan, on top of the returned principal.
     */
    function flashFee(address token, uint256 amount)
        external view override
        returns (uint256)
    {
        require(token == asset, ""Unsupported currency"");
        return _flashFee(amount);
    }

    /**
     * @dev The fee to be charged for a given loan.
     * @param amount The amount of tokens lent.
     * @return The amount of `token` to be charged for the loan, on top of the returned principal.
     */
    function _flashFee(uint256 amount) internal view returns (uint256) {
        return amount.wmul(flashFeeFactor);
    }

    /**
     * @dev From ERC-3156. Loan `amount` `asset` to `receiver`, which needs to return them plus fee to this contract within the same transaction.
     * If the principal + fee are transferred to this contract, they won't be pulled from the receiver.
     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.
     * @param token The loan currency. Must be a fyDai contract.
     * @param amount The amount of tokens lent.
     * @param data A data parameter to be passed on to the `receiver` for any custom use.
     */
    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)
        external override
        returns(bool)
    {
        require(token == asset, ""Unsupported currency"");
        uint128 _amount = amount.u128();
        uint128 _fee = _flashFee(amount).u128();
        _exit(address(receiver), _amount);

        require(receiver.onFlashLoan(msg.sender, token, _amount, _fee, data) == FLASH_LOAN_RETURN, ""Non-compliant borrower"");

        _join(address(receiver), _amount + _fee);
        return true;
    }
}",1298
RealWorld_TA_25_ChainlinkMultiOracle_RealWorld_20240803120423.log,25,ChainlinkMultiOracle,91516,4077,95593,372.0,0.53912,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.1;

import ""../../utils/access/AccessControl.sol"";
import ""../../interfaces/vault/IOracle.sol"";
import ""../../math/CastBytes32Bytes6.sol"";
import ""./AggregatorV3Interface.sol"";


/**
 * @title ChainlinkMultiOracle
 */
contract ChainlinkMultiOracle is IOracle, AccessControl {
    using CastBytes32Bytes6 for bytes32;

    uint8 public constant override decimals = 18;   // All prices are converted to 18 decimals

    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);

    struct Source {
        address source;
        uint8 decimals;
        bool inverse;
    }

    mapping(bytes6 => mapping(bytes6 => Source)) public sources;

    /**
     * @notice Set or reset an oracle source and its inverse
     */
    function setSource(bytes6 base, bytes6 quote, address source) external auth {
        _setSource(base, quote, source);
    }

    /**
     * @notice Set or reset a number of oracle sources and their inverses
     */
    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {
        require(
            bases.length == quotes.length && 
            bases.length == sources_.length,
            ""Mismatched inputs""
        );
        for (uint256 i = 0; i < bases.length; i++) {
            _setSource(bases[i], quotes[i], sources_[i]);
        }
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @return value
     */
    function peek(bytes32 base, bytes32 quote, uint256 amount)
        external view virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), quote.b6());
        value = price * amount / 1e18;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.
     * @return value
     */
    function get(bytes32 base, bytes32 quote, uint256 amount)
        external virtual override
        returns (uint256 value, uint256 updateTime)
    {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), quote.b6());
        value = price * amount / 1e18;
    }

    function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {
        int rawPrice;
        uint80 roundId;
        uint80 answeredInRound;
        Source memory source = sources[base][quote];
        require (source.source != address(0), ""Source not found"");
        (roundId, rawPrice,, updateTime, answeredInRound) = AggregatorV3Interface(source.source).latestRoundData();
        require(rawPrice > 0, ""Chainlink price <= 0"");
        require(updateTime != 0, ""Incomplete round"");
        require(answeredInRound >= roundId, ""Stale price"");
        if (source.inverse == true) {
            price = 10 ** (source.decimals + 18) / uint(rawPrice);
        } else {
            price = uint(rawPrice) * 10 ** (18 - source.decimals);
        }  
    }

    function _setSource(bytes6 base, bytes6 quote, address source) internal {
        uint8 decimals_ = AggregatorV3Interface(source).decimals();
        require (decimals_ <= 18, ""Unsupported decimals"");
        sources[base][quote] = Source({
            source: source,
            decimals: decimals_,
            inverse: false
        });
        sources[quote][base] = Source({
            source: source,
            decimals: decimals_,
            inverse: true
        });
        emit SourceSet(base, quote, source);
        emit SourceSet(quote, base, source);
    }
}",842
RealWorld_TA_25_Ownable_RealWorld_20240803133711.log,25,Ownable,32296,1778,34074,369.0,0.19704,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);

    constructor () {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), owner);
    }

    /// @dev Throws if called by any account other than the owner.
    modifier onlyOwner() {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /// @dev Transfers ownership of the contract to a new account (`newOwner`).
    /// Can only be called by the current owner.
    function transferOwnership(address newOwner) public onlyOwner {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}",167
RealWorld_TA_26_BridgeMockup_RealWorld_20240803160306.log,26,BridgeMockup,48274,4463,52737,117.0,0.33063,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""hardhat/console.sol"";

// this is only for ganache testing. Public chain deployments will use the existing Realitio contracts.

contract BridgeMockup {
    address public oracleProxyMainnetAddress;
    address public oracleProxyXdaiAddress;

    function requireToPassMessage(
        address _RCProxyAddress,
        bytes calldata _data,
        uint256 _gasLimit
    ) external {
        _gasLimit;
        (bool _success, ) = _RCProxyAddress.call{value: (0)}(_data);
        // this is for a sepcific test where the oracleProxyMainnetAddress is
        // scrambled intentionally
        if (
            0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 !=
            oracleProxyMainnetAddress
        ) {
            require(_success, ""Bridge failed"");
        }
    }

    function messageSender() external view returns (address) {
        // console.log(""oracleProxyXdaiAddress is"", oracleProxyXdaiAddress);
        if (msg.sender == oracleProxyMainnetAddress) {
            return oracleProxyXdaiAddress;
        } else {
            return oracleProxyMainnetAddress;
        }
    }

    function setProxyL1Address(address _newAddress) external {
        oracleProxyMainnetAddress = _newAddress;
    }

    function setProxyL2Address(address _newAddress) external {
        oracleProxyXdaiAddress = _newAddress;
    }
}",331
RealWorld_TA_26_NativeMetaTransaction_RealWorld_20240803161603.log,26,NativeMetaTransaction,75705,2907,78612,102.0,0.436665,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import {EIP712Base} from ""./EIP712Base.sol"";

contract NativeMetaTransaction is EIP712Base {
    bytes32 private constant META_TRANSACTION_TYPEHASH =
        keccak256(
            bytes(
                ""MetaTransaction(uint256 nonce,address from,bytes functionSignature)""
            )
        );
    event MetaTransactionExecuted(
        address userAddress,
        address relayerAddress,
        bytes functionSignature
    );
    mapping(address => uint256) nonces;

    /*
     * Meta transaction structure.
     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas
     * He should call the desired function directly in that case.
     */
    struct MetaTransaction {
        uint256 nonce;
        address from;
        bytes functionSignature;
    }

    function executeMetaTransaction(
        address userAddress,
        bytes memory functionSignature,
        bytes32 sigR,
        bytes32 sigS,
        uint8 sigV
    ) public payable returns (bytes memory) {
        MetaTransaction memory metaTx = MetaTransaction({
            nonce: nonces[userAddress],
            from: userAddress,
            functionSignature: functionSignature
        });

        require(
            verify(userAddress, metaTx, sigR, sigS, sigV),
            ""Signer and signature do not match""
        );

        // increase nonce for user (to avoid re-use)
        nonces[userAddress] = nonces[userAddress] + (1);

        emit MetaTransactionExecuted(
            userAddress,
            msg.sender,
            functionSignature
        );

        // Append userAddress and relayer address at the end to extract it from calling context
        (bool success, bytes memory returnData) = address(this).call(
            abi.encodePacked(functionSignature, userAddress)
        );
        require(success, ""Function call not successful"");

        return returnData;
    }

    function hashMetaTransaction(MetaTransaction memory metaTx)
        internal
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    META_TRANSACTION_TYPEHASH,
                    metaTx.nonce,
                    metaTx.from,
                    keccak256(metaTx.functionSignature)
                )
            );
    }

    function getNonce(address user) public view returns (uint256 nonce) {
        nonce = nonces[user];
    }

    function verify(
        address signer,
        MetaTransaction memory metaTx,
        bytes32 sigR,
        bytes32 sigS,
        uint8 sigV
    ) internal view returns (bool) {
        require(signer != address(0), ""NativeMetaTransaction: INVALID_SIGNER"");
        return
            signer ==
            ecrecover(
                toTypedMessageHash(hashMetaTransaction(metaTx)),
                sigV,
                sigR,
                sigS
            );
    }

    function msgSender() internal view returns (address payable sender) {
        if (msg.sender == address(this)) {
            assembly {
                sender := shr(96, calldataload(sub(calldatasize(), 20)))
            }
        } else {
            sender = payable(msg.sender);
        }
        return sender;
    }
}",673
RealWorld_TA_26_IRealitio_RealWorld_20240803163239.log,26,IRealitio,30028,1518,31546,82.0,0.1805,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

/// @title Realit.io contract interface
interface IRealitio {
    function askQuestion(
        uint256 template_id,
        string calldata question,
        address arbitrator,
        uint32 timeout,
        uint32 opening_ts,
        uint256 nonce
    ) external payable returns (bytes32);

    function resultFor(bytes32 question_id) external view returns (bytes32);

    function isFinalized(bytes32 question_id) external view returns (bool);

    function getContentHash(bytes32 question_id)
        external
        view
        returns (bytes32);
}",137
RealWorld_TA_26_RCMarket_RealWorld_20240803155859.log,26,RCMarket,897240,1152,898392,155.0,4.50924,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCLeaderboard.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)
    /// @dev minimum rental value per day, setting to 24mil means 1 USDC/hour
    uint256 public constant MIN_RENTAL_VALUE = 24_000_000;
    /// @dev the number of cards in this market
    uint256 public override numberOfCards;
    /// @dev current market state, Closed -> Open -> Locked -> Withdraw
    States public override state;
    /// @dev type of event.
    Mode public override mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev how many nfts to award to the leaderboard
    uint256 public override nftsToAward;
    /// @dev the unique token id for each card
    uint256[] public tokenIds;

    // CONTRACT VARIABLES
    IRCTreasury public override treasury;
    IRCFactory public override factory;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;

    // PRICE, DEPOSITS, RENT
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public override rentCollectedPerUser;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public
        override rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public override totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public override exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public override minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev maximum number of times to calculate rent in one transaction
    uint256 public override maxRentIterations;
    /// @dev maximum number of times to calculate rent and continue locking the market
    uint256 public maxRentIterationsToLockMarket;

    struct Card {
        /// @dev how many seconds each user has held each card for, for determining winnings
        mapping(address => uint256) timeHeld;
        /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
        uint256 totalTimeHeld;
        /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
        uint256 timeLastCollected;
        /// @dev to track who has owned it the most (for giving NFT to winner)
        address longestOwner;
        /// @dev to track the card timeHeldLimit for the current owner
        uint256 cardTimeLimit;
        /// @dev card price in wei
        uint256 cardPrice;
        /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
        uint256 rentCollectedPerCard;
        /// @dev prevent users claiming twice
        mapping(address => bool) userAlreadyClaimed; // cardID // user // bool
        /// @dev has this card affiliate been paid
        bool cardAffiliatePaid;
    }
    mapping(uint256 => Card) public card;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public override marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    uint32 public override oracleResolutionTime;

    // PAYOUT VARIABLES
    /// @dev the winning card if known, otherwise type(uint256).max
    uint256 public override winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public override userAlreadyWithdrawn;
    /// @dev the artist
    address public override artistAddress;
    uint256 public override artistCut;
    bool public override artistPaid;
    /// @dev the affiliate
    address public override affiliateAddress;
    uint256 public override affiliateCut;
    bool public override affiliatePaid;
    /// @dev the winner
    uint256 public override winnerCut;
    /// @dev the market creator
    address public override marketCreatorAddress;
    uint256 public override creatorCut;
    bool public override creatorPaid;
    /// @dev card specific recipients
    address[] public override cardAffiliateAddresses;
    uint256 public override cardAffiliateCut;
    /// @dev keeps track of which card is next to complete the
    /// @dev .. accounting for when locking the market
    uint256 public override cardAccountingIndex;
    /// @dev has the market locking accounting been completed yet
    bool public override accountingComplete;

    // ORACLE VARIABLES
    bytes32 public override questionId;
    address public override arbitrator;
    uint32 public override timeout; // the time allowed for the answer to be corrected

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 minRentalDayDivisor,
        uint256 minimumPriceIncreasePercent,
        uint256 nftsToAward
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _artistAddress where to send artist's cut, if any (zero address is valid)
    /// @param _affiliateAddress where to send affiliate's cut, if any (zero address is valid)
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any (zero address is valid)
    /// @param _marketCreatorAddress where to send market creator's cut, if any (zero address is valid)
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        Mode _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion,
        uint256 _nftsToAward
    ) external override initializer {
        mode = Mode(_mode);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();
        leaderboard = factory.leaderboard();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();
        maxRentIterationsToLockMarket = factory.maxRentIterationsToLockMarket();

        // Initialize!
        winningOutcome = type(uint256).max; // default invalid

        // assign arguments to public variables
        numberOfCards = _numberOfCards;
        nftsToAward = _nftsToAward;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();
        for (uint256 i = 0; i < _numberOfCards; i++) {
            tokenIds.push(type(uint256).max);
        }

        // reduce artist cut to zero if zero address set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero address set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                    break;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == Mode.WINNER_TAKES_ALL) {
            winnerCut =
                (((uint256(PER_MILLE) - artistCut) - creatorCut) -
                    affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(
            minRentalDayDivisor,
            minimumPriceIncreasePercent,
            nftsToAward
        );
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
        _;
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        require(_cardId < numberOfCards, ""Card does not exist"");
        if (tokenExists(_cardId)) {
            uint256 _tokenId = getTokenId(_cardId);
            return nfthub.ownerOf(_tokenId);
        } else {
            return address(this);
        }
    }

    /// @notice transfer ERC 721 between users
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = getTokenId(_cardId);

        nfthub.transferNft(_from, _to, _tokenId);
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externally by Orderbook
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        card[_cardId].cardTimeLimit = _timeLimit;
        card[_cardId].cardPrice = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        uint256 templateId = 2; //template 2 works for all RealityCards questions
        uint256 nonce = 0; // We don't need to ask it again, always use 0
        bytes32 questionHash = keccak256(
            abi.encodePacked(templateId, _oracleResolutionTime, _question)
        );
        questionId = keccak256(
            abi.encodePacked(
                questionHash,
                arbitrator,
                timeout,
                address(this),
                nonce
            )
        );
        if (realitio.getContentHash(questionId) != questionHash) {
            // check if our questionHash matches an existing questionId
            // otherwise ask the question.
            questionId = realitio.askQuestion(
                templateId,
                _question,
                arbitrator,
                timeout,
                _oracleResolutionTime,
                nonce
            );
        }
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view override returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external override {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external override {
        require(
            treasury.checkPermission(keccak256(""OWNER""), msgSender()),
            ""Not authorised""
        );
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice Checks whether the competition has ended, if so moves to LOCKED state
    /// @notice May require multiple calls as all accounting must be completed before
    /// @notice the market should be locked.
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public override {
        _checkState(States.OPEN);
        require(
            uint256(marketLockingTime) <= block.timestamp,
            ""Market has not finished""
        );

        bool cardAccountingComplete = false;
        uint256 rentIterationCounter = 0;
        // do a final rent collection before the contract is locked down
        while (cardAccountingIndex < numberOfCards && !accountingComplete) {
            (cardAccountingComplete, rentIterationCounter) = _collectRent(
                cardAccountingIndex,
                rentIterationCounter
            );
            if (cardAccountingComplete) {
                cardAccountingComplete = false;
                cardAccountingIndex++;
            }
            if (cardAccountingIndex == numberOfCards) {
                accountingComplete = true;
                break;
            }
            if (rentIterationCounter >= maxRentIterations) {
                break;
            }
        }
        // check the accounting is complete but only continue if we haven't used much gas so far
        /// @dev using gasleft() would be nice, but it causes problems with tx gas estimations
        if (
            accountingComplete &&
            rentIterationCounter < maxRentIterationsToLockMarket
        ) {
            // and check that the orderbook has shut the market
            if (orderbook.closeMarket()) {
                // now lock the market
                _incrementState();

                for (uint256 i = 0; i < numberOfCards; i++) {
                    if (tokenExists(i)) {
                        // bring the cards back to the market so the winners get the satisfaction of claiming them
                        _transferCard(ownerOf(i), address(this), i);
                    }
                    emit LogLongestOwner(i, card[i].longestOwner);
                }
                emit LogContractLocked(true);
            }
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            /// @dev implementing our own SafeCast as this is the only place we need it
            uint256 _blockTimestamp = uint32(block.timestamp);
            require(_blockTimestamp <= type(uint32).max, ""Overflow"");
            marketLockingTime = uint32(_blockTimestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external override {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (card[winningOutcome].totalTimeHeld > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @notice users on the leaderboard can make a copy of it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external override {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(
            !treasury.marketPaused(address(this)) && !treasury.globalPause(),
            ""Market is Paused""
        );
        address _user = msgSender();
        require(!card[_card].userAlreadyClaimed[_user], ""Already claimed"");
        card[_card].userAlreadyClaimed[_user] = true;
        if (_user == card[_card].longestOwner) {
            _transferCard(ownerOf(_card), card[_card].longestOwner, _card);
        } else {
            leaderboard.claimNFT(_user, _card);
            factory.mintCopyOfNFT(_user, _card);
        }
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut = ((((uint256(PER_MILLE) - artistCut) -
            affiliateCut) - cardAffiliateCut) - winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (card[winningOutcome].longestOwner == msgSender() && winnerCut > 0) {
            _winningsToTransfer =
                (totalRentCollected * winnerCut) /
                (PER_MILLE);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected -
                    card[winningOutcome].rentCollectedPerCard) *
                    _remainingCut) /
                PER_MILLE;
            _winningsToTransfer +=
                (rentCollectedPerUserPerCard[msgSender()][winningOutcome] *
                    _remainingCut) /
                PER_MILLE;
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (PER_MILLE);
        }
        uint256 _winnersTimeHeld = card[winningOutcome].timeHeld[msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / card[winningOutcome].totalTimeHeld);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut = ((uint256(PER_MILLE) - artistCut) -
            affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted = (_rentCollected * _remainingCut) /
            (PER_MILLE);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        treasury.payout(_recipient, _amount);
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external override {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external override {
        _checkState(States.WITHDRAW);
        require(card[winningOutcome].totalTimeHeld > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external override {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external override {
        _checkState(States.WITHDRAW);
        require(!card[_card].cardAffiliatePaid, ""Card affiliate already paid"");
        card[_card].cardAffiliatePaid = true;
        uint256 _cardAffiliatePayment = (card[_card].rentCollectedPerCard *
            cardAffiliateCut) / (PER_MILLE);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (PER_MILLE);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent a specifc card
    function collectRent(uint256 _cardId) external override returns (bool) {
        _checkState(States.OPEN);
        bool _success;
        (_success, ) = _collectRent(_cardId, 0);
        if (_success) {
            return true;
        }
        return false;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external override {
        _checkState(States.OPEN);
        // check that not being front run
        uint256 _actualSumOfPrices = 0;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (card[i].cardPrice == 0) {
                _actualSumOfPrices += MIN_RENTAL_VALUE;
            } else {
                _actualSumOfPrices +=
                    (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) /
                    100;
            }
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (card[i].cardPrice > 0) {
                    _newPrice =
                        (card[i].cardPrice *
                            (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public override autoUnlock autoLock {
        // if the market isn't open then don't do anything else, not reverting
        // .. will allow autoLock to process the accounting to lock the market
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            // if the NFT hasn't been minted, we should probably do that
            if (!tokenExists(_card)) {
                tokenIds[_card] = nfthub.totalSupply();
                factory.mintMarketNFT(_card);
            }

            address _user = msgSender();

            // prevent re-renting, this limits (but doesn't eliminate) a frontrunning attack
            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            // restrict certain markets to specific whitelists
            require(
                treasury.marketWhitelistCheck(_user),
                ""Not approved for this market""
            );

            // if the user is foreclosed then delete some old bids
            // .. this could remove their foreclosure
            if (treasury.isForeclosed(_user)) {
                orderbook.removeUserFromOrderbook(_user);
            }
            require(
                !treasury.isForeclosed(_user),
                ""Can't rent while foreclosed""
            );
            if (ownerOf(_card) == _user) {
                // the owner may only increase by more than X% or reduce their price
                uint256 _requiredPrice = (card[_card].cardPrice *
                    (minimumPriceIncreasePercent + 100)) / (100);
                require(
                    _newPrice >= _requiredPrice ||
                        _newPrice < card[_card].cardPrice,
                    ""Invalid price""
                );
            }

            // do some cleaning up before we collect rent or check their bidRate
            orderbook.removeOldBids(_user);

            /// @dev ignore the return value and let the user post the bid for the sake of UX
            _collectRent(_card, 0);

            // check sufficient deposit
            uint256 _userTotalBidRate = (treasury.userTotalBids(_user) -
                orderbook.getBidValue(_user, _card)) + _newPrice;
            require(
                treasury.userDeposit(_user) >=
                    _userTotalBidRate / minRentalDayDivisor,
                ""Insufficient deposit""
            );

            _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.addBidToOrderbook(
                _user,
                _card,
                _newPrice,
                _timeHeldLimit,
                _startingPosition
            );

            treasury.updateLastRentalTime(_user);
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
        override
    {
        _checkState(States.OPEN);
        address _user = msgSender();
        bool rentCollected;
        (rentCollected, ) = _collectRent(_card, 0);
        if (rentCollected) {
            _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                card[_card].cardTimeLimit = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @dev doesn't revert if non-existant bid because user might be trying to exitAll()
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // collectRent first
        /// @dev ignore the return value and let the user exit the bid for the sake of UX
        _collectRent(_card, 0);

        if (ownerOf(_card) == _msgSender) {
            // block frontrunning attack
            exitedTimestamp[_msgSender] = block.timestamp;

            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                // block frontrunning attack
                exitedTimestamp[_msgSender] = block.timestamp;

                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liquidity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liquidity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        address _msgSender = msgSender();
        if (_msgSender != address(factory)) {
            _sponsorAddress = _msgSender;
        }
        _sponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        treasury.sponsor(_sponsorAddress, _amount);
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            card[i].rentCollectedPerCard =
                card[i].rentCollectedPerCard +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit) internal view {
        if (_timeHeldLimit != 0) {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
        }
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    /// @param _card the card id to collect rent for
    /// @return true if the rent collection was completed, (ownership updated to the current time)
    function _collectRent(uint256 _card, uint256 _counter)
        internal
        returns (bool, uint256)
    {
        bool shouldContinue = true;
        while (_counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            _counter++;
        }
        return (!shouldContinue, _counter);
    }

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    /// @param _card the card id to collect rent for
    /// @return true if we should repeat the rent collection
    function _collectRentAction(uint256 _card) internal returns (bool) {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            card[_card].timeLastCollected < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed = treasury.collectRentUser(
                _user,
                _timeOfThisCollection
            );

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp = card[_card].timeLastCollected +
                card[_card].cardTimeLimit;

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit = card[_card].cardTimeLimit != 0 &&
                _cardTimeLimitTimestamp < block.timestamp;

            // outputs
            bool _newOwner = false;
            uint256 _refundTime = 0; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure and Time limit
            ┌───────────┬─┬─┬─┬─┐
            │Case       │1│2│3│4│
            ├───────────┼─┼─┼─┼─┤
            │Foreclosure│0│0│1│1│
            │Time Limit │0│1│0│1│
            └───────────┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && _limitHit) {
                // CASE 2
                // didn't foreclose AND
                // did hit time limit
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (_foreclosed && !_limitHit) {
                // CASE 3
                // did foreclose AND
                // didn't hit time limit
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && _limitHit) {
                // CASE 4
                // did foreclose AND
                // did hit time limit
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount = (_refundTime * card[_card].cardPrice) /
                    1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            card[_card].timeLastCollected = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed = (card[_card].cardPrice *
            (_timeOfCollection - card[_card].timeLastCollected)) / 1 days;
        uint256 _timeHeldToIncrement = (_timeOfCollection -
            card[_card].timeLastCollected);

        // if the user has a timeLimit, adjust it as necessary
        if (card[_card].cardTimeLimit != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            card[_card].cardTimeLimit -= _timeHeldToIncrement;
        }

        // update time
        card[_card].timeHeld[_user] += _timeHeldToIncrement;
        card[_card].totalTimeHeld += _timeHeldToIncrement;
        card[_card].timeLastCollected = _timeOfCollection;

        // longest owner tracking
        if (
            card[_card].timeHeld[_user] >
            card[_card].timeHeld[card[_card].longestOwner]
        ) {
            card[_card].longestOwner = _user;
        }

        // update amounts
        /// @dev get back the actual rent collected, it may be less than owed
        uint256 _rentCollected = treasury.payRent(_rentOwed);
        card[_card].rentCollectedPerCard += _rentCollected;
        rentCollectedPerUserPerCard[_user][_card] += _rentCollected;
        rentCollectedPerUser[_user] += _rentCollected;
        totalRentCollected += _rentCollected;

        leaderboard.updateLeaderboard(
            _user,
            _card,
            card[_card].timeHeld[_user]
        );
        emit LogRentCollection(
            _rentCollected,
            _timeHeldToIncrement,
            _card,
            _user
        );
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        state = States(uint256(state) + 1);
        emit LogStateChange(uint256(state));
    }

    /// @notice returns the tokenId (the unique NFT index) given the cardId (the market specific index)
    /// @param _card the market specific index of the card
    /// @return _tokenId the unique NFT index
    function getTokenId(uint256 _card)
        public
        view
        override
        returns (uint256 _tokenId)
    {
        require(tokenExists(_card));
        return tokenIds[_card];
    }

    /*╔═════════════════════════════════╗
      ║       VIEW FUNCTIONS            ║
      ╚═════════════════════════════════╝*/

    /// @notice Check if the NFT has been minted yet
    /// @param _card the market specific index of the card
    /// @return true if the NFT has been minted
    function tokenExists(uint256 _card) internal view returns (bool) {
        return tokenIds[_card] != type(uint256).max;
    }

    /// @dev a simple getter for the time a user has held a given card
    function timeHeld(uint256 _card, address _user)
        external
        view
        override
        returns (uint256)
    {
        return card[_card].timeHeld[_user];
    }

    /// @dev a simple getter for the time a card last had rent collected
    function timeLastCollected(uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        return card[_card].timeLastCollected;
    }

    /// @dev a simple getter for the longest owner of a card
    function longestOwner(uint256 _card)
        external
        view
        override
        returns (address)
    {
        return card[_card].longestOwner;
    }

    /*╔═════════════════════════════════╗
      ║          BACKUP MODE            ║
      ╚═════════════════════════════════╝*/
    /// @dev in the event of failures in the UI we need a simple reliable way to poll
    /// @dev ..the contracts for relevant info, this view function helps facilitate this.

    /// @dev quick and easy view function to get all market data relevant to the UI
    function getMarketInfo()
        external
        view
        returns (
            States,
            string memory,
            uint256,
            uint256,
            address[] memory,
            uint256[] memory
        )
    {
        address[] memory _owners = new address[](numberOfCards);
        uint256[] memory _prices = new uint256[](numberOfCards);
        for (uint256 i = 0; i < numberOfCards; i++) {
            _owners[i] = ownerOf(i);
            _prices[i] = card[i].cardPrice;
        }
        return (
            state,
            factory.ipfsHash(address(this)),
            winningOutcome,
            totalRentCollected,
            _owners,
            _prices
        );
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external override {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        state = States.WITHDRAW;
        orderbook.closeMarket();
        emit LogStateChange(uint256(state));
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",10971
RealWorld_TA_26_RCNftHubL2_RealWorld_20240803161032.log,26,RCNftHubL2,174806,4598,179404,137.0,0.96599,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""hardhat/console.sol"";
import ""../interfaces/IRCMarket.sol"";
import ""../interfaces/IRCTreasury.sol"";
import ""../interfaces/IRCFactory.sol"";
import ""../lib/NativeMetaTransaction.sol"";
import ""../interfaces/IRCNftHubL2.sol"";

/// @title Reality Cards NFT Hub- Layer 2 side
/// @author Andrew Stanger & Daniel Chilvers
contract RCNftHubL2 is
    Ownable,
    ERC721,
    ERC721URIStorage,
    ERC721Enumerable,
    AccessControl,
    NativeMetaTransaction,
    IRCNftHubL2
{
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    /// @dev so only markets can move NFTs
    mapping(address => bool) public isMarket;
    /// @dev the market each NFT belongs to
    mapping(uint256 => address) public override marketTracker;

    /// @dev governance variables
    IRCFactory public factory;
    IRCTreasury public treasury;
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant DEPOSITOR_ROLE = keccak256(""DEPOSITOR_ROLE"");
    mapping(uint256 => bool) public withdrawnTokens;
    event TransferWithMetadata(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId,
        bytes metaData
    );

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    constructor(address _factoryAddress, address childChainManager)
        ERC721(""RealityCards"", ""RC"")
    {
        require(
            childChainManager != address(0),
            ""Must add childChainManager address""
        );
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsNftHubL2"", ""1"");
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(DEPOSITOR_ROLE, childChainManager);
        factory = IRCFactory(_factoryAddress);
        treasury = factory.treasury();
    }

    /*╔═════════════════════════════════╗
      ║          ADD MARKETS            ║
      ╚═════════════════════════════════╝*/

    /// @dev so only markets can change ownership
    function addMarket(address _newMarket) external override {
        require(msgSender() == address(factory), ""Not factory"");
        isMarket[_newMarket] = true;
    }

    /*╔═════════════════════════════════╗
      ║          GOVERNANCE             ║
      ╚═════════════════════════════════╝*/

    /// @dev address of RC factory contract, so only factory can mint
    function setFactory(address _newAddress) external onlyUberOwner {
        require(_newAddress != address(0), ""Must set an address"");
        factory = IRCFactory(_newAddress);
        treasury = factory.treasury();
    }

    function setTokenURI(uint256 _tokenId, string calldata _tokenURI)
        external
        onlyUberOwner
    {
        _setTokenURI(_tokenId, _tokenURI);
    }

    /*╔═════════════════════════════════╗
      ║        CORE FUNCTIONS           ║
      ╚═════════════════════════════════╝*/

    // FACTORY ONLY
    function mint(
        address _originalOwner,
        uint256 _tokenId,
        string calldata _tokenURI
    ) external override {
        require(
            !withdrawnTokens[_tokenId],
            ""ChildMintableERC721: TOKEN_EXISTS_ON_ROOT_CHAIN""
        );
        require(msgSender() == address(factory), ""Not factory"");
        marketTracker[_tokenId] = _originalOwner;
        _mint(_originalOwner, _tokenId);
        _setTokenURI(_tokenId, _tokenURI);
    }

    // MARKET ONLY
    function transferNft(
        address _currentOwner,
        address _newOwner,
        uint256 _tokenId
    ) external override {
        require(marketTracker[_tokenId] == msgSender(), ""Not market"");
        _transfer(_currentOwner, _newOwner, _tokenId);
    }

    /*╔═════════════════════════════════╗
      ║        MATIC MINTABLE           ║
      ╚═════════════════════════════════╝*/

    function deposit(address user, bytes calldata depositData)
        external
        override
        onlyRole(DEPOSITOR_ROLE)
    {
        // deposit single
        if (depositData.length == 32) {
            uint256 tokenId = abi.decode(depositData, (uint256));
            withdrawnTokens[tokenId] = false;
            _mint(user, tokenId);

            // deposit batch
        } else {
            uint256[] memory tokenIds = abi.decode(depositData, (uint256[]));
            uint256 length = tokenIds.length;
            for (uint256 i = 0; i < length; i++) {
                withdrawnTokens[tokenIds[i]] = false;
                _mint(user, tokenIds[i]);
            }
        }
    }

    function withdraw(uint256 tokenId) external override {
        require(
            _msgSender() == ownerOf(tokenId),
            ""ChildMintableERC721: INVALID_TOKEN_OWNER""
        );
        withdrawnTokens[tokenId] = true;
        _burn(tokenId);
    }

    function withdrawWithMetadata(uint256 tokenId) external override {
        require(
            msgSender() == ownerOf(tokenId),
            ""ChildMintableERC721: INVALID_TOKEN_OWNER""
        );
        withdrawnTokens[tokenId] = true;

        // Encoding metadata associated with tokenId & emitting event
        emit TransferWithMetadata(
            ownerOf(tokenId),
            address(0),
            tokenId,
            this.encodeTokenMetadata(tokenId)
        );

        _burn(tokenId);
    }

    function encodeTokenMetadata(uint256 tokenId)
        external
        view
        virtual
        returns (bytes memory)
    {
        return abi.encode(tokenURI(tokenId));
    }

    /*╔═════════════════════════════════╗
      ║           OVERRIDES             ║
      ╚═════════════════════════════════╝*/
    /// @dev ensures NFTs can only be moved when market is resolved
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721Enumerable, ERC721) {
        super._beforeTokenTransfer(from, to, tokenId);

        if (
            msgSender() != address(factory) &&
            msgSender() != marketTracker[tokenId]
        ) {
            IRCMarket market = IRCMarket(marketTracker[tokenId]);
            require(
                market.state() == IRCMarket.States.WITHDRAW ||
                    market.state() == IRCMarket.States.LOCKED,
                ""Incorrect state""
            );
        }
    }

    function _burn(uint256 _tokenId)
        internal
        override(ERC721, ERC721URIStorage)
    {
        super._burn(_tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControl, ERC721, ERC721Enumerable)
        returns (bool)
    {
        return
            interfaceId == type(IRCNftHubL2).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function ownerOf(uint256 tokenId)
        public
        view
        virtual
        override(ERC721, IRCNftHubL2)
        returns (address)
    {
        return ERC721.ownerOf(tokenId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override(ERC721, ERC721URIStorage, IRCNftHubL2)
        returns (string memory)
    {
        return ERC721URIStorage.tokenURI(tokenId);
    }

    function totalSupply()
        public
        view
        virtual
        override(ERC721Enumerable, IRCNftHubL2)
        returns (uint256)
    {
        return ERC721Enumerable.totalSupply();
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",2047
RealWorld_TA_26_IRCLeaderboard_RealWorld_20240803162321.log,26,IRCLeaderboard,28661,1317,29978,84.0,0.169645,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""./IRCTreasury.sol"";
import ""./IRCMarket.sol"";

interface IRCLeaderboard {
    function treasury() external view returns (IRCTreasury);

    function market() external view returns (IRCMarket);

    function NFTsToAward(address _market) external view returns (uint256);

    function updateLeaderboard(
        address _user,
        uint256 _card,
        uint256 _timeHeld
    ) external;

    function claimNFT(address _user, uint256 _card) external;
}",128
RealWorld_TA_26_IRCOrderbook_RealWorld_20240803162801.log,26,IRCOrderbook,67769,1755,69524,88.0,0.373945,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""./IRCTreasury.sol"";

interface IRCOrderbook {
    struct Bid {
        address market;
        address next;
        address prev;
        uint64 card;
        uint128 price;
        uint64 timeHeldLimit;
    }

    function index(
        address _market,
        address _user,
        uint256 _token
    ) external view returns (uint256);

    function ownerOf(address, uint256) external view returns (address);

    function closedMarkets(uint256) external view returns (address);

    function userClosedMarketIndex(address) external view returns (uint256);

    function treasury() external view returns (IRCTreasury);

    function maxSearchIterations() external view returns (uint256);

    function maxDeletions() external view returns (uint256);

    function cleaningLoops() external view returns (uint256);

    function marketCloseLimit() external view returns (uint256);

    function nonce() external view returns (uint256);

    function cleanWastePile() external;

    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view returns (Bid memory);

    function setTreasuryAddress(address _newTreasury) external;

    function addBidToOrderbook(
        address _user,
        uint256 _token,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external;

    function removeBidFromOrderbook(address _user, uint256 _token) external;

    function closeMarket() external returns (bool);

    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)
        external;

    function getBidValue(address _user, uint256 _token)
        external
        view
        returns (uint256);

    function getTimeHeldlimit(address _user, uint256 _token)
        external
        returns (uint256);

    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) external view returns (bool);

    function setTimeHeldlimit(
        address _user,
        uint256 _token,
        uint256 _timeHeldLimit
    ) external;

    function removeUserFromOrderbook(address _user) external;

    function removeOldBids(address _user) external;

    function reduceTimeHeldLimit(
        address _user,
        uint256 _token,
        uint256 _timeToReduce
    ) external;

    function setDeletionLimit(uint256 _deletionLimit) external;

    function setCleaningLimit(uint256 _cleaningLimit) external;

    function setSearchLimit(uint256 _searchLimit) external;

    function setMarketCloseLimit(uint256 _marketCloseLimit) external;
}",590
RealWorld_TA_26_tokenMockup_RealWorld_20240803160655.log,26,tokenMockup,26569,1708,28277,103.0,0.167005,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol"";
import ""hardhat/console.sol"";

contract tokenMockup is ERC20PresetFixedSupply {
    constructor(
        string memory name,
        string memory symbol,
        uint256 supply,
        address owner
    ) ERC20PresetFixedSupply(name, symbol, supply, owner) {}
}",103
RealWorld_TA_26_SelfDestructMockup_RealWorld_20240803160505.log,26,SelfDestructMockup,25397,3150,28547,108.0,0.189985,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""hardhat/console.sol"";

// to test force sending Ether to Treasury

contract SelfDestructMockup {
    function killme(address payable _address) public {
        selfdestruct(_address);
    }

    receive() external payable {}
}",70
RealWorld_TA_26_IRCNftHubL2_RealWorld_20240803162622.log,26,IRCNftHubL2,32876,2343,35219,96.0,0.21124,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

interface IRCNftHubL2 {
    function marketTracker(uint256) external view returns (address);

    function ownerOf(uint256) external view returns (address);

    function tokenURI(uint256) external view returns (string memory);

    function addMarket(address) external;

    function totalSupply() external view returns (uint256 nftCount);

    function mint(
        address,
        uint256,
        string calldata
    ) external;

    function transferNft(
        address,
        address,
        uint256
    ) external;

    function deposit(address user, bytes calldata depositData) external;

    function withdraw(uint256 tokenId) external;

    function withdrawWithMetadata(uint256 tokenId) external;
}",167
RealWorld_TA_26_IRCMarket_RealWorld_20240803162137.log,26,IRCMarket,111451,2923,114374,102.0,0.615715,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""./IRCNftHubL2.sol"";
import ""./IRCTreasury.sol"";
import ""./IRCFactory.sol"";
import ""./IRCLeaderboard.sol"";
import ""./IRealitio.sol"";
import ""./IRCOrderbook.sol"";

interface IRCMarket {
    enum States {
        CLOSED,
        OPEN,
        LOCKED,
        WITHDRAW
    }
    enum Mode {
        CLASSIC,
        WINNER_TAKES_ALL,
        SAFE_MODE
    }

    function getWinnerFromOracle() external;

    function setAmicableResolution(uint256 _winningOutcome) external;

    function lockMarket() external;

    function claimCard(uint256 _card) external;

    function rentAllCards(uint256 _maxSumOfPrices) external;

    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) external;

    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external;

    function collectRent(uint256 _cardId) external returns (bool);

    function exitAll() external;

    function exit(uint256) external;

    function sponsor(address _sponsor, uint256 _amount) external;

    function sponsor(uint256 _amount) external;

    function circuitBreaker() external;

    // payouts
    function withdraw() external;

    function payArtist() external;

    function payMarketCreator() external;

    function payAffiliate() external;

    function payCardAffiliate(uint256) external;

    // view functions
    function nfthub() external view returns (IRCNftHubL2);

    function treasury() external view returns (IRCTreasury);

    function factory() external view returns (IRCFactory);

    function leaderboard() external view returns (IRCLeaderboard);

    function orderbook() external view returns (IRCOrderbook);

    function realitio() external view returns (IRealitio);

    function mode() external view returns (Mode);

    function isMarket() external view returns (bool);

    function numberOfCards() external view returns (uint256);

    function nftsToAward() external view returns (uint256);

    function ownerOf(uint256 tokenId) external view returns (address);

    function state() external view returns (States);

    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);

    function cardAccountingIndex() external view returns (uint256);

    function accountingComplete() external view returns (bool);

    // prices, deposits, rent

    function rentCollectedPerUser(address) external view returns (uint256);

    function rentCollectedPerUserPerCard(address, uint256)
        external
        view
        returns (uint256);

    function totalRentCollected() external view returns (uint256);

    function exitedTimestamp(address) external view returns (uint256);

    //parameters

    function minimumPriceIncreasePercent() external view returns (uint256);

    function minRentalDayDivisor() external view returns (uint256);

    function maxRentIterations() external view returns (uint256);

    // time
    function timeHeld(uint256 _card, address _user)
        external
        view
        returns (uint256);

    function timeLastCollected(uint256 _card) external view returns (uint256);

    function longestOwner(uint256 _card) external view returns (address);

    function marketOpeningTime() external view returns (uint32);

    function marketLockingTime() external view returns (uint32);

    function oracleResolutionTime() external view returns (uint32);

    // payout settings
    function winningOutcome() external view returns (uint256);

    function userAlreadyWithdrawn(address) external view returns (bool);

    function artistAddress() external view returns (address);

    function artistCut() external view returns (uint256);

    function artistPaid() external view returns (bool);

    function affiliateAddress() external view returns (address);

    function affiliateCut() external view returns (uint256);

    function affiliatePaid() external view returns (bool);

    function winnerCut() external view returns (uint256);

    function marketCreatorAddress() external view returns (address);

    function creatorCut() external view returns (uint256);

    function creatorPaid() external view returns (bool);

    function cardAffiliateAddresses(uint256) external view returns (address);

    function cardAffiliateCut() external view returns (uint256);

    // oracle

    function questionId() external view returns (bytes32);

    function arbitrator() external view returns (address);

    function timeout() external view returns (uint32);

    function isFinalized() external view returns (bool);

    // setup
    function initialize(
        Mode _mode,
        uint32[] calldata _timestamps,
        uint256 _numberOfCards,
        address _artistAddress,
        address _affiliateAddress,
        address[] calldata _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion,
        uint256 _nftsToAward
    ) external;

    function transferCard(
        address _oldOwner,
        address _newOwner,
        uint256 _token,
        uint256 _price,
        uint256 _timeLimit
    ) external;
}",1111
RealWorld_TA_26_RCNftHubL1_RealWorld_20240803161251.log,26,RCNftHubL1,69385,2174,71559,101.0,0.390405,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""hardhat/console.sol"";
import ""../lib/NativeMetaTransaction.sol"";
import ""../interfaces/IRCNftHubL1.sol"";

/// @title Reality Cards NFT Hub- mainnet side
/// @author Andrew Stanger & Daniel Chilvers
contract RCNftHubL1 is
    ERC721URIStorage,
    AccessControl,
    NativeMetaTransaction,
    IRCNftHubL1
{
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    bytes32 public constant PREDICATE_ROLE = keccak256(""PREDICATE_ROLE"");

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    constructor(address _predicate) ERC721(""RealityCards"", ""RC"") {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsNftHubL1"", ""1"");
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(PREDICATE_ROLE, _predicate);
    }

    /*╔═════════════════════════════════╗
      ║        CORE FUNCTIONS           ║
      ╚═════════════════════════════════╝*/

    function mint(address user, uint256 tokenId)
        external
        override
        onlyRole(PREDICATE_ROLE)
    {
        _mint(user, tokenId);
    }

    function mint(
        address user,
        uint256 tokenId,
        bytes calldata metaData
    ) external override onlyRole(PREDICATE_ROLE) {
        _mint(user, tokenId);

        setTokenMetadata(tokenId, metaData);
    }

    function setTokenMetadata(uint256 tokenId, bytes memory data)
        internal
        virtual
    {
        string memory uri = abi.decode(data, (string));
        _setTokenURI(tokenId, uri);
    }

    function setTokenURI(uint256 _tokenId, string calldata _tokenURI)
        external
        onlyRole(DEFAULT_ADMIN_ROLE)
    {
        _setTokenURI(_tokenId, _tokenURI);
    }

    function exists(uint256 tokenId) external view override returns (bool) {
        return _exists(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AccessControl, ERC721)
        returns (bool)
    {
        return
            interfaceId == type(IRCNftHubL1).interfaceId ||
            super.supportsInterface(interfaceId);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",682
RealWorld_TA_26_RCLeaderboard_RealWorld_20240803154438.log,26,RCLeaderboard,232032,5613,237645,160.0,1.27242,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""hardhat/console.sol"";
import ""./interfaces/IRCLeaderboard.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Leaderboard
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCLeaderboard is NativeMetaTransaction, IRCLeaderboard {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // Contracts and Permissions
    IRCTreasury public override treasury;
    IRCMarket public override market;
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");

    // Leaderboard tracking
    struct Leaderboard {
        address next;
        address prev;
        address market;
        uint256 card;
        uint256 timeHeld;
    }
    mapping(address => Leaderboard[]) public leaderboard;
    mapping(address => mapping(address => mapping(uint256 => uint256))) leaderboardIndex;
    mapping(address => mapping(uint256 => uint256)) public leaderboardLength;
    mapping(address => uint256) public override NFTsToAward;

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToLeaderboard(address _user, address _market, uint256 _card);
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromLeaderboard(
        address _user,
        address _market,
        uint256 _card
    );

    /*╔═════════════════════════════════╗
      ║         CONSTRUCTOR             ║
      ╚═════════════════════════════════╝*/

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }
    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║      Leaderboard Tracking       ║
      ╚═════════════════════════════════╝*/

    /// @notice adds a new market to the leaderboard
    /// @param _market the address of the market to add
    /// @param _cardCount the number of cards in the market
    /// @param _nftsToAward how many users on the leaderboard can claim an NFT
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _nftsToAward
    ) internal {
        NFTsToAward[_market] = _nftsToAward;
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Leaderboard memory _newRecord;
            _newRecord.card = i;
            _newRecord.next = _market;
            _newRecord.prev = _market;
            _newRecord.market = _market;
            _newRecord.timeHeld = type(uint256).max;
            leaderboardIndex[_market][_market][i] = leaderboard[_market].length;
            leaderboard[_market].push(_newRecord);
        }
    }

    /// @notice update a users timeHeld on the leaderboard
    /// @param _user the user to update
    /// @param _card the card number to update
    /// @param _timeHeld how long (total) the user has held the card
    function updateLeaderboard(
        address _user,
        uint256 _card,
        uint256 _timeHeld
    ) external override onlyMarkets {
        address _market = msgSender();

        // check if the market has been initialised
        if (!userIsOnLeaderboard(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _nftsToAward = IRCMarket(_market).nftsToAward();
            addMarket(_market, _cardCount, _nftsToAward);
        }

        // is the leaderboard full yet?
        if (leaderboardLength[_market][_card] < NFTsToAward[_market]) {
            // leaderboard isn't full, just add them
            if (userIsOnLeaderboard(_user, _market, _card)) {
                // user is already on the leaderboard, remove them first
                removeFromLeaderboard(_user, _market, _card);
            }
            addToLeaderboard(_user, _market, _card, _timeHeld);
            emit LogAddToLeaderboard(_user, _market, _card);
        } else {
            // leaderboard is full
            address lastUserOnLeaderboard = leaderboard[_market][
                leaderboardIndex[_market][_market][_card]
            ].prev;
            uint256 minimumTimeOnLeaderboard = leaderboard[
                lastUserOnLeaderboard
            ][leaderboardIndex[lastUserOnLeaderboard][_market][_card]].timeHeld;

            // does this user deserve to be on the leaderboard?
            if (_timeHeld > minimumTimeOnLeaderboard) {
                // user deserves to be on leaderboard
                if (userIsOnLeaderboard(_user, _market, _card)) {
                    // user is already on the leaderboard, remove them first
                    removeFromLeaderboard(_user, _market, _card);
                } else {
                    // bump the last user off the leaderboard to make space
                    removeFromLeaderboard(
                        lastUserOnLeaderboard,
                        _market,
                        _card
                    );
                    emit LogRemoveFromLeaderboard(
                        lastUserOnLeaderboard,
                        _market,
                        _card
                    );
                }
                // now add them in the correct position
                addToLeaderboard(_user, _market, _card, _timeHeld);
                emit LogAddToLeaderboard(_user, _market, _card);
            }
        }
    }

    /// @dev add a user to the leaderboard
    function addToLeaderboard(
        address _user,
        address _market,
        uint256 _card,
        uint256 _timeHeld
    ) internal {
        Leaderboard memory _currRecord = leaderboard[_market][
            leaderboardIndex[_market][_market][_card]
        ];
        address _nextUser = _currRecord.next;
        // find the correct position
        // TODO would it be better on average to search the leaderboard from the bottom?
        while (
            _timeHeld <
            leaderboard[_nextUser][leaderboardIndex[_nextUser][_market][_card]]
                .timeHeld &&
            _nextUser != _market
        ) {
            _currRecord = leaderboard[_nextUser][
                leaderboardIndex[_nextUser][_market][_card]
            ];
            _nextUser = _currRecord.next;
        }

        address _prevUser = leaderboard[_nextUser][
            leaderboardIndex[_nextUser][_market][_card]
        ].prev;

        // create new record
        Leaderboard memory _newRecord;
        _newRecord.card = _card;
        _newRecord.market = _market;
        _newRecord.next = _nextUser;
        _newRecord.prev = _prevUser;
        _newRecord.timeHeld = _timeHeld;

        // insert in linked list
        leaderboard[_nextUser][leaderboardIndex[_nextUser][_market][_card]]
            .prev = _user;
        leaderboard[_prevUser][leaderboardIndex[_prevUser][_market][_card]]
            .next = _user;
        leaderboard[_user].push(_newRecord);

        //update the index to help find the record later
        leaderboardIndex[_user][_market][_card] = leaderboard[_user].length - 1;

        leaderboardLength[_market][_card]++;
    }

    /// @dev remove a user from the leaderboard
    function removeFromLeaderboard(
        address _user,
        address _market,
        uint256 _card
    ) internal {
        uint256 _index = leaderboardIndex[_user][_market][_card];
        address _nextUser = leaderboard[_user][_index].next;
        address _prevUser = leaderboard[_user][_index].prev;

        // unlink from list
        leaderboard[_nextUser][leaderboardIndex[_nextUser][_market][_card]]
            .prev = _prevUser;
        leaderboard[_prevUser][leaderboardIndex[_prevUser][_market][_card]]
            .next = _nextUser;

        // overwrite array element
        uint256 _lastRecord = leaderboard[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            leaderboard[_user][_index] = leaderboard[_user][_lastRecord];
        }
        leaderboard[_user].pop();

        // update the index to help find the record later
        leaderboardIndex[_user][_market][_card] = 0;
        if (leaderboard[_user].length != 0 && _index != _lastRecord) {
            leaderboardIndex[_user][leaderboard[_user][_index].market][
                leaderboard[_user][_index].card
            ] = _index;
        }

        leaderboardLength[_market][_card]--;
    }

    /// @notice check if a user is on the leaderboard
    /// @param _user the user address to check
    /// @param _market the market address to check
    /// @param _card the cardId to check
    function userIsOnLeaderboard(
        address _user,
        address _market,
        uint256 _card
    ) public view returns (bool) {
        if (leaderboard[_user].length != 0) {
            // user is on a leaderboard
            if (leaderboardIndex[_user][_market][_card] != 0) {
                // user is on the leaderboard with this card
                return true;
            } else {
                if (
                    leaderboard[_user][0].market == _market &&
                    leaderboard[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    /// @notice check if a user is on the leaderboard so they can claim an NFT
    // TODO the longest owner will never get deleted because they can't call claimNFT
    function claimNFT(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        require(
            userIsOnLeaderboard(_user, _market, _card),
            ""Not in leaderboard""
        );
        /// @dev we don't need to keep a record now, removing will offset
        /// @dev .. some of the gas which will be needed for minting.
        removeFromLeaderboard(_user, _market, _card);
    }

    /// @notice returns the full leaderboard list
    /// @dev useful for debugging, uncomment the console.logs
    function printLeaderboard(address _market, uint256 _card)
        external
        view
        returns (address[] memory)
    {
        address[] memory leaderboardList = new address[](
            leaderboardLength[_market][_card]
        );
        Leaderboard memory _currRecord = leaderboard[_market][
            leaderboardIndex[_market][_market][_card]
        ];
        address _nextUser = _currRecord.next;
        uint256 i = 0;
        // console.log(""Market address "", _market);
        while (_nextUser != _market) {
            leaderboardList[i] = _nextUser;
            // console.log(""Printing orderbook "", _nextUser);
            _currRecord = leaderboard[_nextUser][
                leaderboardIndex[_nextUser][_market][_card]
            ];
            _nextUser = _currRecord.next;
            i++;
        }
        // console.log("" done printing orderbook"");
        return leaderboardList;
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",2636
RealWorld_TA_26_EIP712Base_RealWorld_20240803161434.log,26,EIP712Base,66194,1570,67764,87.0,0.36237,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";

contract EIP712Base is Initializable {
    struct EIP712Domain {
        string name;
        string version;
        address verifyingContract;
        bytes32 salt;
    }

    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
        keccak256(
            bytes(
                ""EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)""
            )
        );
    bytes32 internal domainSeperator;
    uint256 private cachedChainId;
    string private cachedName;
    string private cachedVersion;

    // supposed to be called once while initializing.
    // one of the contractsa that inherits this contract follows proxy pattern
    // so it is not possible to do this in a constructor
    function _initializeEIP712(string memory name, string memory version)
        internal
        initializer
    {
        cachedChainId = getChainId();
        cachedName = name;
        cachedVersion = version;
        _setDomainSeperator(name, version);
    }

    function _setDomainSeperator(string memory name, string memory version)
        internal
    {
        domainSeperator = keccak256(
            abi.encode(
                EIP712_DOMAIN_TYPEHASH,
                keccak256(bytes(name)),
                keccak256(bytes(version)),
                address(this),
                bytes32(getChainId())
            )
        );
    }

    function getDomainSeperator() public view returns (bytes32) {
        if (getChainId() == cachedChainId) {
            return domainSeperator;
        } else {
            return
                keccak256(
                    abi.encode(
                        EIP712_DOMAIN_TYPEHASH,
                        keccak256(bytes(cachedName)),
                        keccak256(bytes(cachedVersion)),
                        address(this),
                        bytes32(getChainId())
                    )
                );
        }
    }

    function getChainId() public view returns (uint256) {
        return block.chainid;
    }

    /**
     * Accept message hash and returns hash message in EIP712 compatible form
     * So that it can be used to recover signer from signature signed using EIP712 formatted data
     * https://eips.ethereum.org/EIPS/eip-712
     * ""\\x19"" makes the encoding deterministic
     * ""\\x01"" is the version byte to make it compatible to EIP-191
     */
    function toTypedMessageHash(bytes32 messageHash)
        internal
        view
        returns (bytes32)
    {
        return
            keccak256(
                abi.encodePacked(""\x19\x01"", getDomainSeperator(), messageHash)
            );
    }
}",571
RealWorld_TA_26_IRCBridge_RealWorld_20240803163108.log,26,IRCBridge,22210,1508,23718,89.0,0.14121,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

interface IRCBridge {
    function withdrawToMainnet(address _user, uint256 _amount) external;
}",43
RealWorld_TA_26_IERC20Dai_RealWorld_20240803162448.log,26,IERC20Dai,76971,2065,79036,91.0,0.426155,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
 * the optional functions; to access them see {ERC20Detailed}.
 */
interface IERC20Dai {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount)
        external
        returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    function permit(
        address holder,
        address spender,
        uint256 nonce,
        uint256 expiry,
        bool allowed,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",701
RealWorld_TA_26_IRCFactory_RealWorld_20240803161747.log,26,IRCFactory,110623,3211,113834,112.0,0.617335,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""./IRealitio.sol"";
import ""./IRCTreasury.sol"";
import ""./IRCMarket.sol"";
import ""./IRCNftHubL2.sol"";
import ""./IRCOrderbook.sol"";
import ""./IRCLeaderboard.sol"";

interface IRCFactory {
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address);

    function mintCopyOfNFT(address _user, uint256 _tokenId) external;

    // view functions

    function nfthub() external view returns (IRCNftHubL2);

    function ipfsHash(address) external view returns (string memory);

    function slugToAddress(string memory) external view returns (address);

    function addressToSlug(address) external view returns (string memory);

    function marketInfoResults() external view returns (uint256);

    function treasury() external view returns (IRCTreasury);

    function orderbook() external view returns (IRCOrderbook);

    function leaderboard() external view returns (IRCLeaderboard);

    function realitio() external view returns (IRealitio);

    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        returns (address[] memory);

    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        returns (address);

    function referenceContractAddress() external view returns (address);

    function referenceContractVersion() external view returns (uint256);

    function sponsorshipRequired() external view returns (uint256);

    function advancedWarning() external view returns (uint32);

    function maximumDuration() external view returns (uint32);

    function minimumDuration() external view returns (uint32);

    function marketCreationGovernorsOnly() external view returns (bool);

    function approvedAffiliatesOnly() external view returns (bool);

    function approvedArtistsOnly() external view returns (bool);

    function arbitrator() external view returns (address);

    function timeout() external view returns (uint32);

    function cardLimit() external view returns (uint256);

    function getPotDistribution() external view returns (uint256[5] memory);

    function minimumPriceIncreasePercent() external view returns (uint256);

    function nftsToAward() external view returns (uint256);

    function isMarketApproved(address) external view returns (bool);

    function marketPausedDefaultState() external view returns (bool);

    function mintMarketNFT(uint256 _card) external;

    function getOracleSettings()
        external
        view
        returns (
            IRealitio oracle,
            address arbitratorAddress,
            uint32 _timeout
        );

    // only Governors
    function changeMarketApproval(address _market) external;

    function addArtist(address _newArtist) external;

    function removeArtist(address _oldArtist) external;

    function addAffiliate(address _newAffiliate) external;

    function removeAffiliate(address _oldAffiliate) external;

    // only Owner
    function setMarketPausedDefaultState(bool _state) external;

    function setTimeout(uint32 _newTimeout) external;

    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        external;

    function setArbitrator(address _newAddress) external;

    function setRealitioAddress(address _newAddress) external;

    function maxRentIterations() external view returns (uint256);

    function maxRentIterationsToLockMarket() external view returns (uint256);

    function setCardLimit(uint256 _cardLimit) external;

    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;

    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;

    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external;

    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) external;

    function changeMarketCreationGovernorsOnly() external;

    function changeApprovedArtistsOnly() external;

    function changeApprovedAffilliatesOnly() external;

    function setSponsorshipRequired(uint256 _amount) external;

    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external;

    function setMarketInfoResults(uint256 _results) external;

    // only UberOwner
    function setReferenceContractAddress(address _newAddress) external;

    function setOrderbookAddress(IRCOrderbook _newAddress) external;

    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;

    function setNftHubAddress(IRCNftHubL2 _newAddress) external;
}",1099
RealWorld_TA_26_RCTreasury_RealWorld_20240803155652.log,26,RCTreasury,698333,646,698979,125.0,3.504585,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public override orderbook;
    /// @dev leaderboard instance
    IRCLeaderboard public override leaderboard;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev the Factory so only the Factory can add new markets
    IRCFactory public override factory;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public override marketBalance;
    /// @dev a quick check if a user is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 public override marketBalanceTopup;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    /// @dev intended for beta use only, will be disabled after launch
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    /// @dev allow markets to be restricted to a certain role
    mapping(address => bytes32) public marketWhitelist;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent, claim or upgrade any cards for specific market
    mapping(address => bool) public override marketPaused;
    /// @dev if true, owner has locked the market pause (Governors are locked out)
    mapping(address => bool) public override lockMarketPaused;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        /* setup AccessControl

                         UBER_OWNER
            ┌───────────┬────┴─────┬────────────┬─────────┐
            │           │          │            │         │
          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD
            │           │
         GOVERNOR     MARKET
            │
         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE
        */
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1_000_000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks() {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyRole(OWNER)
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @dev this is only a soft check, it is possible to exceed this limit
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add/Remove multiple users to the whitelist
    /// @param _users an array of users to add or remove
    /// @param add true to add the users
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    /// @notice Some markets may be restricted to certain roles,
    /// @notice This function checks if the user has the role requried for a given market
    /// @dev Used for the markets to check themselves
    /// @param _user The user to check
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        // factory is also an OWNER and GOVERNOR to use the proxy functions
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised
        erc20.safeTransfer(msg.sender, _balance);
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // step 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        // do some cleaning up first, it might help avoid their foreclosure
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            // foreclose user, this is requred to remove them from the orderbook
            isForeclosed[_msgSender] = true;
            // remove them from the orderbook
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        /// @dev return the amount just incase it was adjusted
        return _amount;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        // update the last rental time
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        // check if this is their first rental (no previous rental calculation)
        if (user[_user].lastRentCalc == 0) {
            // we need to start their clock ticking, update their last rental calculation time
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice provides the sum total of a users bids across all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                // they have enough funds, just collect the extra
                // we can be sure of this because it was checked they can cover the minimum rental
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    // send an event for the UI to have a timestamp
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calculation and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calculates the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                // calculate how long they can own the new card for
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    // new bid is after user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    // new bid is before user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    // The user couldn't afford to own the new card up to their last
                    // .. rent calculation, we can't rewind their rent calculation because
                    // .. of gas limits (there could be many markets having taken rent).
                    // Therefore unfortunately we can't give any ownership to this user as
                    // .. this could mean getting caught in a loop we may not be able to
                    // .. exit because of gas limits (there could be many users in this
                    // .. situation and we can't leave any unaccounted for).
                    // This means we return 0 to signify that the user can't afford this
                    // .. new ownership.
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                // if no rentals they'll foreclose after the heat death of the universe
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepositLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets available balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    /// @notice checks if the user should still be foreclosed
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",8609
RealWorld_TA_26_RCFactory_RealWorld_20240803155119.log,26,RCFactory,616909,7110,624019,232.0,3.226745,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    /////// CONTRACT VARIABLES ///////
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRCLeaderboard public override leaderboard;
    IRealitio public override realitio;
    /// @dev reference contract
    address public override referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public override referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(IRCMarket.Mode => address[]) public marketAddresses;

    ////// BACKUP MODE //////
    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data
    /// @dev the IPFS hash for each market
    mapping(address => string) public override ipfsHash;
    /// @dev the slug each market is hosted at
    mapping(string => address) public override slugToAddress;
    mapping(address => string) public override addressToSlug;
    /// @dev the number of results to return in the backup view function
    uint256 public override marketInfoResults;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms initial pot
    uint256 public override sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev The number of users that are allowed to mint an NFT
    uint256 public override nftsToAward;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public override advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public override maximumDuration;
    /// @dev market closing time must be at least this many seconds after opening
    uint32 public override minimumDuration;
    /// @dev if false, anyone can create markets
    bool public override marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public override approvedAffiliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public override approvedArtistsOnly = true;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the maximum number of rent collections to have performed before locking the market
    uint256 public override maxRentIterationsToLockMarket;
    /// @dev the address of the arbitrator
    address public override arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public override timeout;
    /// @dev if true markets default to the paused state
    bool public override marketPausedDefaultState;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public override cardLimit;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;

    ///// OTHER /////
    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)
    /// @dev store the tokenURIs for when we need to mint them
    /// @dev we may want the original and the copies to have slightly different metadata
    /// @dev so we append the metadata for the copies to the end of this array
    mapping(address => mapping(uint256 => string)) tokenURIs;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        IRCMarket.Mode mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool approved);
    event LogMarketTimeRestrictions(
        uint256 _newAdvancedWarning,
        uint256 _newMinimumDuration,
        uint256 _newMaximumDuration
    );
    event LogMintNFTCopy(
        uint256 _originalTokenId,
        address _newOwner,
        uint256 _newTokenId
    );
    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    constructor(
        IRCTreasury _treasury,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasury) != address(0), ""Must set Address"");
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // store contract instances
        treasury = _treasury;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setMinimumPriceIncreasePercent(10); // 10%
        setNumberOfNFTsToAward(3);
        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes
        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /// @notice fetch the current oracle, arbitrator and timeout settings
    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    /// @return Oracle Address
    /// @return Arbitrator Address
    /// @return Question timeout in seconds
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }

    /// @notice Returns market addresses and ipfs hashes
    /// @dev used for the UI backup mode
    /// @param _mode return markets only in the given mode
    /// @param _state return markets only in the given state
    /// @param _skipResults the number of results to skip
    function getMarketInfo(
        IRCMarket.Mode _mode,
        uint256 _state,
        uint256 _skipResults
    )
        external
        view
        returns (
            address[] memory,
            string[] memory,
            string[] memory,
            uint256[] memory
        )
    {
        uint256 _marketIndex = marketAddresses[_mode].length;
        uint256 _resultNumber = 0;
        address[] memory _marketAddresses = new address[](marketInfoResults);
        string[] memory _ipfsHashes = new string[](marketInfoResults);
        uint256[] memory _potSizes = new uint256[](marketInfoResults);
        string[] memory _slugs = new string[](marketInfoResults);
        while (_resultNumber < marketInfoResults && _marketIndex > 1) {
            _marketIndex--;
            address _market = marketAddresses[_mode][_marketIndex];
            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {
                if (_resultNumber < _skipResults) {
                    _resultNumber++;
                } else {
                    _marketAddresses[_resultNumber] = _market;
                    _ipfsHashes[_resultNumber] = ipfsHash[_market];
                    _slugs[_resultNumber] = addressToSlug[_market];
                    _potSizes[_resultNumber] = IRCMarket(_market)
                        .totalRentCollected();
                    _resultNumber++;
                }
            }
        }
        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyOwner() {
        require(treasury.checkPermission(OWNER, msgSender()), ""Not approved"");
        _;
    }
    modifier onlyGovernors() {
        require(
            treasury.checkPermission(GOVERNOR, msgSender()),
            ""Not approved""
        );
        _;
    }
    modifier onlyMarkets() {
        require(treasury.checkPermission(MARKET, msgSender()), ""Not approved"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in MegaBip (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public override onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                PER_MILLE,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice how many NFTs will be awarded to the leaderboard
    /// @param _nftsToAward the number of NFTs to award
    function setNumberOfNFTsToAward(uint256 _nftsToAward)
        public
        override
        onlyOwner
    {
        nftsToAward = _nftsToAward;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _cardLimit the limit to set
    function setCardLimit(uint256 _cardLimit) public override onlyOwner {
        cardLimit = _cardLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
        maxRentIterationsToLockMarket = _rentLimitLocking;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public override onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public override onlyOwner {
        // event is emitted from the Oracle when the question is asked
        timeout = _newTimeout;
    }

    function setMarketPausedDefaultState(bool _state)
        external
        override
        onlyOwner
    {
        marketPausedDefaultState = _state;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external override onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external override onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external override onlyOwner {
        approvedAffiliatesOnly = !approvedAffiliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount)
        external
        override
        onlyOwner
    {
        sponsorshipRequired = _amount;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external override onlyOwner {
        advancedWarning = _newAdvancedWarning;
        minimumDuration = _newMinimumDuration;
        maximumDuration = _newMaximumDuration;
        emit LogMarketTimeRestrictions(
            _newAdvancedWarning,
            _newMinimumDuration,
            _newMaximumDuration
        );
    }

    /// @notice Allow the owner to update a token URI.
    /// @param _market the market address the token belongs to
    /// @param _cardId the index 0 card id of the token to change
    /// @param _newTokenURI the new URI to set
    /// @param _newCopyTokenURI the new URI to set for the copy
    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external override onlyOwner {
        IRCMarket.Mode _mode = IRCMarket(_market).mode();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        tokenURIs[_market][_cardId] = _newTokenURI;
        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;
        string[] memory _tokenURIs = new string[](_numberOfCards);
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            _tokenURIs[i] = tokenURIs[_market][i];
        }
        uint32[] memory _timestamps = new uint32[](3);
        _timestamps[0] = IRCMarket(_market).marketOpeningTime();
        _timestamps[1] = IRCMarket(_market).marketLockingTime();
        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();

        // reuse this event so the frontend can pickup the change
        emit LogMarketCreated2(
            _market,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            ipfsHash[_market],
            _timestamps,
            nfthub.totalSupply()
        );
    }

    /// @notice change how many results are returned from getMarketInfo
    /// @dev would be better to pass this as a parameter in getMarketInfo
    /// @dev .. however we are limited because of stack too deep errors
    function setMarketInfoResults(uint256 _results)
        external
        override
        onlyOwner
    {
        // no event needed, only used for the backup view mode
        marketInfoResults = _results;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market)
        external
        override
        onlyGovernors
    {
        require(_market != address(0), ""Must set Address"");
        // check it's an RC contract
        require(treasury.checkPermission(MARKET, _market), ""Not Market"");
        isMarketApproved[_market] = !isMarketApproved[_market];
        // governors shouldn't have the ability to pause a market, only un-pause.
        // .. if a governor accidentally approves a market they should seek
        // .. assistance from the owner to decide if it should be paused.
        treasury.unPauseMarket(_market);
        // the market will however be hidden from the UI in the meantime
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /*╔═════════════════════════════════╗
      ║   GOVERNANCE - Role management  ║
      ╚═════════════════════════════════╝*/
    /// @dev the following functions could all be performed directly on the treasury
    /// @dev .. they are here as an interim solution to give governors an easy way
    /// @dev .. to change all their parameters via the block explorer.

    /// @notice Grant the artist role to an address
    /// @param _newArtist the address to grant the role of artist
    function addArtist(address _newArtist) external override onlyGovernors {
        treasury.grantRole(ARTIST, _newArtist);
    }

    /// @notice Remove the artist role from an address
    /// @param _oldArtist the address to revoke the role of artist
    function removeArtist(address _oldArtist) external override onlyGovernors {
        treasury.revokeRole(ARTIST, _oldArtist);
    }

    /// @notice Grant the affiliate role to an address
    /// @param _newAffiliate the address to grant the role of affiliate
    function addAffiliate(address _newAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.grantRole(AFFILIATE, _newAffiliate);
    }

    /// @notice Remove the affiliate role from an address
    /// @param _oldAffiliate the address to revoke the role of affiliate
    function removeAffiliate(address _oldAffiliate)
        external
        override
        onlyGovernors
    {
        treasury.revokeRole(AFFILIATE, _oldAffiliate);
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades, this is separated so owner can be
    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    /// @notice change the reference contract for the contract logic
    /// @param _newAddress the address of the new reference contract to set
    function setReferenceContractAddress(address _newAddress)
        external
        override
        onlyUberOwner
    {
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        require(newContractVariable.isMarket(), ""Not Market"");
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice where the NFTs live
    /// @param _newAddress the address to set
    function setNftHubAddress(IRCNftHubL2 _newAddress)
        external
        override
        onlyUberOwner
    {
        require(address(_newAddress) != address(0), ""Must set Address"");
        nfthub = _newAddress;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newOrderbook the address to set
    /// @dev set by the treasury to ensure all contracts use the same orderbook
    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        orderbook = _newOrderbook;
    }

    /// @notice set the address of the leaderboard contract
    /// @param _newLeaderboard the address to set
    /// @dev set by the treasury to ensure all contracts use the same leaderboard
    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)
        external
        override
    {
        require(
            treasury.checkPermission(TREASURY, msgSender()),
            ""Not approved""
        );
        leaderboard = _newLeaderboard;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all
    /// @param _ipfsHash the IPFS location of the market metadata
    /// @param _slug the URL subdomain in the UI
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata, originals followed by copies
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliates cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        // check nfthub has been set
        require(address(nfthub) != address(0), ""Nfthub not set"");

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check the number of NFTs to mint is within limits
        /// @dev we want different tokenURIs for originals and copies
        /// @dev ..the copies are appended to the end of the array
        /// @dev ..so half the array length if the number of tokens.
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        // affiliate
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        // tell Treasury and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        // update internals
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        // initialize the market
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        // store token URIs
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    function _checkTimestamps(uint32[] memory _timestamps) internal view {
        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            // different statements to give clearer revert messages
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        require(
            _timestamps[0] + minimumDuration < _timestamps[1] &&
                block.timestamp + minimumDuration < _timestamps[1],
            ""Market lock must be after opening""
        );
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );
    }

    /// @notice Called by the markets to mint the original NFTs
    /// @param _card the card id to be minted
    function mintMarketNFT(uint256 _card) external override onlyMarkets {
        uint256 nftHubMintCount = nfthub.totalSupply();
        address _market = msgSender();
        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);
        emit LogMintNFT(_card, _market, nftHubMintCount);
    }

    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard
    /// @param _user the user to award the NFT to
    /// @param _cardId the tokenId to copy
    function mintCopyOfNFT(address _user, uint256 _cardId)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        uint256 _newTokenId = nfthub.totalSupply();
        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();
        nfthub.mint(
            _user,
            _newTokenId,
            tokenURIs[_market][(_cardId + _numberOfCards)]
        );
        emit LogMintNFTCopy(_cardId, _user, _newTokenId);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",7456
RealWorld_TA_26_IRCTreasury_RealWorld_20240803161941.log,26,IRCTreasury,89801,3387,93188,113.0,0.516745,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./IRCOrderbook.sol"";
import ""./IRCLeaderboard.sol"";
import ""./IRCFactory.sol"";

interface IRCTreasury {
    function setTokenAddress(address _newToken) external;

    function grantRole(string memory role, address account) external;

    function grantRole(bytes32, address) external;

    function revokeRole(string memory role, address account) external;

    function revokeRole(bytes32, address) external;

    function collectRentUser(address _user, uint256 _timeToCollectTo)
        external
        returns (uint256 newTimeLastCollectedOnForeclosure);

    function topupMarketBalance(uint256 _amount) external;

    function assessForeclosure(address _user) external;

    // view functions
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view returns (uint256);

    function bridgeAddress() external view returns (address);

    function checkPermission(bytes32, address) external view returns (bool);

    function erc20() external view returns (IERC20);

    function factory() external view returns (IRCFactory);

    function orderbook() external view returns (IRCOrderbook);

    function leaderboard() external view returns (IRCLeaderboard);

    function isForeclosed(address) external view returns (bool);

    function userTotalBids(address) external view returns (uint256);

    function userDeposit(address) external view returns (uint256);

    function totalDeposits() external view returns (uint256);

    function marketPot(address) external view returns (uint256);

    function totalMarketPots() external view returns (uint256);

    function marketBalance() external view returns (uint256);

    function marketBalanceTopup() external view returns (uint256);

    function minRentalDayDivisor() external view returns (uint256);

    function maxContractBalance() external view returns (uint256);

    function globalPause() external view returns (bool);

    function addMarket(address _market, bool paused) external;

    function marketPaused(address) external view returns (bool);

    function batchWhitelist(address[] calldata _users, bool add) external;

    function marketWhitelistCheck(address _user) external returns (bool);

    function lockMarketPaused(address _market) external view returns (bool);

    function setBridgeAddress(address _newAddress) external;

    function setOrderbookAddress(address _newAddress) external;

    function setLeaderboardAddress(address _newAddress) external;

    function setFactoryAddress(address _newFactory) external;

    function deposit(uint256 _amount, address _user) external returns (bool);

    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;

    function checkSponsorship(address sender, uint256 _amount) external view;

    //only orderbook
    function increaseBidRate(address _user, uint256 _price) external;

    function decreaseBidRate(address _user, uint256 _price) external;

    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external;

    // only owner
    function setMinRental(uint256 _newDivisor) external;

    function setMaxContractBalance(uint256) external;

    function changeGlobalPause() external;

    function changePauseMarket(address _market, bool _paused) external;

    function toggleWhitelist() external;

    // only factory
    function unPauseMarket(address _market) external;

    // only markets
    function payRent(uint256) external returns (uint256);

    function payout(address, uint256) external returns (bool);

    function refundUser(address _user, uint256 _refund) external;

    function sponsor(address _sponsor, uint256 _amount) external;

    function updateLastRentalTime(address) external;
}",853
RealWorld_TA_26_IRCNftHubL1_RealWorld_20240803162932.log,26,IRCNftHubL1,25701,1758,27459,94.0,0.163665,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

interface IRCNftHubL1 {
    function mint(address user, uint256 tokenId) external;

    function mint(
        address user,
        uint256 tokenId,
        bytes calldata metaData
    ) external;

    function exists(uint256 tokenId) external view returns (bool);
}",78
RealWorld_TA_26_RCOrderbook_RealWorld_20240803154721.log,26,RCOrderbook,654542,6892,661434,235.0,3.41055,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";

/// @title Reality Cards Orderbook
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    /// @dev a record of a users single bid.
    /// @dev now declared in the interface, left here for reference
    // struct Bid {
    //     address market;
    //     address next;
    //     address prev;
    //     uint64 card;
    //     uint128 price;
    //     uint64 timeHeldLimit;
    // }

    /// @dev maps a user address to an array of their bids
    mapping(address => Bid[]) public user;
    /// @dev index of a bid record in the user array, User|Market|Token->Index
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    /// @dev record of market specific variables
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    /// @dev map a market address to a market record
    mapping(address => Market) public market;
    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    /// @dev an array of closed markets, used to reduce user bid rates
    address[] public override closedMarkets;
    /// @dev how far through the array a given user is, saves iterating the whole array every time.
    mapping(address => uint256) public override userClosedMarketIndex;

    ///// GOVERNANCE VARIABLES /////
    /// @dev the current treasury
    IRCTreasury public override treasury;
    /// @dev max number of searches to place an order in the book
    /// @dev current estimates place limit around 2000 but 1000 is sufficient
    uint256 public override maxSearchIterations = 1000;
    /// @dev max number of records to delete in one transaction
    uint256 public override maxDeletions = 70;
    /// @dev number of bids a user should clean when placing a new bid
    uint256 public override cleaningLoops = 2;
    /// @dev max number of market records to put into the waste pile in one go
    uint256 public override marketCloseLimit = 70;
    /// @dev nonce emitted with orderbook insertions, for frontend sorting
    uint256 public override nonce;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    /*╔═════════════════════════════════╗
      ║          MODIFIERS              ║
      ╚═════════════════════════════════╝*/

    /// @notice only allow markets to call certain functions
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    /*╔═════════════════════════════════╗
      ║         CONSTRUCTOR             ║
      ╚═════════════════════════════════╝*/

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    /*╔═════════════════════════════════╗
      ║         GOVERNANCE              ║
      ╚═════════════════════════════════╝*/

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    /*╔═════════════════════════════════════╗
      ║             INSERTIONS              ║
      ║ functions that add to the orderbook ║
      ╚═════════════════════════════════════╝*/

    /// @notice adds a new market to the orderbook
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    /// @notice adds or updates a bid in the orderbook
    /// @param _user the user placing the bid
    /// @param _card the card to place the bid on
    /// @param _price the price of the new bid
    /// @param _timeHeldLimit an optional time limit for the bid
    /// @param _prevUserAddress to help find where to insert the bid
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        // each new bid can help clean up some junk
        cleanWastePile();

        if (user[_user].length == 0) {
            //users first bid, skip already closed markets
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            // old bid exists, update it
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            // new bid, add it
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    /// @dev finds the correct location in the orderbook for a given bid
    /// @dev returns an adjusted (lowered) bid price if necessary.
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            // break loop if match price above AND above price below (so if either is false, continue, hence OR )
            // if match previous then must be greater than next to continue
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            // break loop if price x% above below
            _price < _requiredPrice &&
            // break loop if hits max iterations
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        // if previous price is zero it must be the market and this is a new owner
        // .. then don't reduce their price, we already checked they are 10% higher
        // .. than the previous owner.
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    /// @dev add a new bid to the orderbook
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // create new record
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // insert in linked list
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link
        user[_user].push(_newBid);

        // update the index to help find the record later
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    /// @dev updates a bid that is already in the orderbook
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        // TODO no need to unlink and relink if bid doesn't change position in orderbook
        // unlink current bid
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        // find new position
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // update price, save old price for rental rate adjustment later
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // relink bid
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            // if owner before and after, update the price difference
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            // if owner before and not after, remove the old price
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            // if not owner before but is owner after, add new price
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    /*╔══════════════════════════════════════════╗
      ║                DELETIONS                 ║      
      ║ functions that remove from the orderbook ║
      ╚══════════════════════════════════════════╝*/

    /// @notice removes a single bid from the orderbook - onlyMarkets
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    /// @dev removes a single bid from the orderbook, doesn't update ownership
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        // extract from linked list
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        // return next users price to check they're eligible later
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        // update rate
        treasury.decreaseBidRate(_user, _currUser.price);

        // overwrite array element
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        // update the index to help find the record later
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    /// @notice find the next valid owner of a given card - onlyMarkets
    /// @param _card the card to remove
    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        // the market is the head of the list, the next bid is therefore the owner
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        // delete current owner
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            // delete next bid if foreclosed
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            // the old owner is dead, long live the new owner
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            // we hit the limit, save the old owner, we'll try again next time
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards
    /// @notice .. as the markets will need to finish the accounting for them first.
    /// @param _user the user whose bids to start deleting
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                // If the prev record isn't the market, this is only a bid (not owned) so we can delete
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    /// @notice reduces the rentalRates of the card owners when a market closes
    /// @dev too many bidders to reduce all bid rates also
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        // check if the market was ever added to the orderbook
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; // start on the last record so we can easily pop()
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    // store last bid for later
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    // detach market from rest of list
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    // insert bids in the waste pile
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    // reduce owners rental rate
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                // remove the market record
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    /// @notice Remove bids in closed markets for a given user
    /// @notice this can reduce the users bidRate and chance to foreclose
    /// @param _user the address of the users bids to remove
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                // Just do the whole market at once
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        // reduce bidRate
                        uint256 _price = user[_user][_index].price;

                        // preserve linked list
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        // no point overwriting itself
                        if (_index != _lastRecord) {
                            // overwrite array element
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        // update the index to help find the record later
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        // count deletions
                        _loopCounter++;
                    } else {
                        // iterations cost gas also
                        // after enough increment the loopCounter
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    /// @dev remove bids in closed markets, not user specific
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                // extract from linked list
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                // overwrite array element
                uint256 _lastRecord = user[_user].length - 1;
                // no point overwriting itself
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                // update the index to help find the record later
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    /*╔═════════════════════════════════╗
      ║        HELPER FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice check if a bid exists
    /// @param _user the address of the user
    /// @param _market the address of the market
    /// @param _card the card index
    /// @return if the bid exists or not
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            //some bids exist
            if (index[_user][_market][_card] != 0) {
                // this bid exists
                return true;
            } else {
                // check bid isn't index 0
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    /// @dev just to pass old tests, not needed otherwise
    /// @dev but also useful to have so probably will stay
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7831
RealWorld_TA_26_RCFull_RealWorld_20240803154205.log,26,RCFull,334921,3539,338460,150.0,1.745385,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

// Just a handy file to copy/paste into remix

interface IRCFactory {
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address);

    function mintCopyOfNFT(address _user, uint256 _tokenId) external;

    // view functions

    function nfthub() external view returns (address);

    function ipfsHash(address) external view returns (string memory);

    function slugToAddress(string memory) external view returns (address);

    function addressToSlug(address) external view returns (string memory);

    function marketInfoResults() external view returns (uint256);

    function treasury() external view returns (address);

    function orderbook() external view returns (address);

    function leaderboard() external view returns (address);

    function realitio() external view returns (address);

    function getAllMarkets(IRCMarket.Mode _mode)
        external
        view
        returns (address[] memory);

    function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        returns (address);

    function referenceContractAddress() external view returns (address);

    function referenceContractVersion() external view returns (uint256);

    function sponsorshipRequired() external view returns (uint256);

    function advancedWarning() external view returns (uint32);

    function maximumDuration() external view returns (uint32);

    function minimumDuration() external view returns (uint32);

    function marketCreationGovernorsOnly() external view returns (bool);

    function approvedAffiliatesOnly() external view returns (bool);

    function approvedArtistsOnly() external view returns (bool);

    function arbitrator() external view returns (address);

    function timeout() external view returns (uint32);

    function cardLimit() external view returns (uint256);

    function getPotDistribution() external view returns (uint256[5] memory);

    function minimumPriceIncreasePercent() external view returns (uint256);

    function nftsToAward() external view returns (uint256);

    function isMarketApproved(address) external view returns (bool);

    function marketPausedDefaultState() external view returns (bool);

    function mintMarketNFT(uint256 _card) external;

    function getOracleSettings()
        external
        view
        returns (
            IRealitio oracle,
            address arbitratorAddress,
            uint32 _timeout
        );

    // only Governors
    function changeMarketApproval(address _market) external;

    function addArtist(address _newArtist) external;

    function removeArtist(address _oldArtist) external;

    function addAffiliate(address _newAffiliate) external;

    function removeAffiliate(address _oldAffiliate) external;

    // only Owner
    function setMarketPausedDefaultState(bool _state) external;

    function setTimeout(uint32 _newTimeout) external;

    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)
        external;

    function setArbitrator(address _newAddress) external;

    function setRealitioAddress(address _newAddress) external;

    function maxRentIterations() external view returns (uint256);

    function maxRentIterationsToLockMarket() external view returns (uint256);

    function setCardLimit(uint256 _cardLimit) external;

    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;

    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;

    function updateTokenURI(
        address _market,
        uint256 _cardId,
        string calldata _newTokenURI,
        string calldata _newCopyTokenURI
    ) external;

    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) external;

    function changeMarketCreationGovernorsOnly() external;

    function changeApprovedArtistsOnly() external;

    function changeApprovedAffilliatesOnly() external;

    function setSponsorshipRequired(uint256 _amount) external;

    function setMarketTimeRestrictions(
        uint32 _newAdvancedWarning,
        uint32 _newMinimumDuration,
        uint32 _newMaximumDuration
    ) external;

    function setMarketInfoResults(uint256 _results) external;

    // only UberOwner
    function setReferenceContractAddress(address _newAddress) external;

    function setOrderbookAddress(IRCOrderbook _newAddress) external;

    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;

    function setNftHubAddress(IRCNftHubL2 _newAddress) external;
}

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IRCTreasury {
    function setTokenAddress(address _newToken) external;

    function grantRole(string memory role, address account) external;

    function grantRole(bytes32, address) external;

    function revokeRole(string memory role, address account) external;

    function revokeRole(bytes32, address) external;

    function collectRentUser(address _user, uint256 _timeToCollectTo)
        external
        returns (uint256 newTimeLastCollectedOnForeclosure);

    function topupMarketBalance(uint256 _amount) external;

    function assessForeclosure(address _user) external;

    // view functions
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view returns (uint256);

    function bridgeAddress() external view returns (address);

    function checkPermission(bytes32, address) external view returns (bool);

    function erc20() external view returns (IERC20);

    function factory() external view returns (IRCFactory);

    function orderbook() external view returns (IRCOrderbook);

    function leaderboard() external view returns (IRCLeaderboard);

    function isForeclosed(address) external view returns (bool);

    function userTotalBids(address) external view returns (uint256);

    function userDeposit(address) external view returns (uint256);

    function totalDeposits() external view returns (uint256);

    function marketPot(address) external view returns (uint256);

    function totalMarketPots() external view returns (uint256);

    function marketBalance() external view returns (uint256);

    function marketBalanceTopup() external view returns (uint256);

    function minRentalDayDivisor() external view returns (uint256);

    function maxContractBalance() external view returns (uint256);

    function globalPause() external view returns (bool);

    function addMarket(address _market, bool paused) external;

    function marketPaused(address) external view returns (bool);

    function batchWhitelist(address[] calldata _users, bool add) external;

    function marketWhitelistCheck(address _user) external returns (bool);

    function lockMarketPaused(address _market) external view returns (bool);

    function setBridgeAddress(address _newAddress) external;

    function setOrderbookAddress(address _newAddress) external;

    function setLeaderboardAddress(address _newAddress) external;

    function setFactoryAddress(address _newFactory) external;

    function deposit(uint256 _amount, address _user) external returns (bool);

    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;

    function checkSponsorship(address sender, uint256 _amount) external view;

    //only orderbook
    function increaseBidRate(address _user, uint256 _price) external;

    function decreaseBidRate(address _user, uint256 _price) external;

    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external;

    // only owner
    function setMinRental(uint256 _newDivisor) external;

    function setMaxContractBalance(uint256) external;

    function changeGlobalPause() external;

    function changePauseMarket(address _market, bool _paused) external;

    function toggleWhitelist() external;

    // only factory
    function unPauseMarket(address _market) external;

    // only markets
    function payRent(uint256) external returns (uint256);

    function payout(address, uint256) external returns (bool);

    function refundUser(address _user, uint256 _refund) external;

    function sponsor(address _sponsor, uint256 _amount) external;

    function updateLastRentalTime(address) external;
}

interface IRCMarket {
    enum States {
        CLOSED,
        OPEN,
        LOCKED,
        WITHDRAW
    }
    enum Mode {
        CLASSIC,
        WINNER_TAKES_ALL,
        SAFE_MODE
    }

    function getWinnerFromOracle() external;

    function setAmicableResolution(uint256 _winningOutcome) external;

    function lockMarket() external;

    function claimCard(uint256 _card) external;

    function rentAllCards(uint256 _maxSumOfPrices) external;

    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) external;

    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external;

    function collectRent(uint256 _cardId) external returns (bool);

    function exitAll() external;

    function exit(uint256) external;

    function sponsor(address _sponsor, uint256 _amount) external;

    function sponsor(uint256 _amount) external;

    function circuitBreaker() external;

    // payouts
    function withdraw() external;

    function payArtist() external;

    function payMarketCreator() external;

    function payAffiliate() external;

    function payCardAffiliate(uint256) external;

    // view functions
    function nfthub() external view returns (IRCNftHubL2);

    function treasury() external view returns (IRCTreasury);

    function factory() external view returns (IRCFactory);

    function leaderboard() external view returns (IRCLeaderboard);

    function orderbook() external view returns (IRCOrderbook);

    function realitio() external view returns (IRealitio);

    function mode() external view returns (Mode);

    function isMarket() external view returns (bool);

    function numberOfCards() external view returns (uint256);

    function nftsToAward() external view returns (uint256);

    function ownerOf(uint256 tokenId) external view returns (address);

    function state() external view returns (States);

    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);

    function cardAccountingIndex() external view returns (uint256);

    function accountingComplete() external view returns (bool);

    // prices, deposits, rent

    function rentCollectedPerUser(address) external view returns (uint256);

    function rentCollectedPerUserPerCard(address, uint256)
        external
        view
        returns (uint256);

    function totalRentCollected() external view returns (uint256);

    function exitedTimestamp(address) external view returns (uint256);

    //parameters

    function minimumPriceIncreasePercent() external view returns (uint256);

    function minRentalDayDivisor() external view returns (uint256);

    function maxRentIterations() external view returns (uint256);

    // time
    function timeHeld(uint256 _card, address _user)
        external
        view
        returns (uint256);

    function timeLastCollected(uint256 _card) external view returns (uint256);

    function longestOwner(uint256 _card) external view returns (address);

    function marketOpeningTime() external view returns (uint32);

    function marketLockingTime() external view returns (uint32);

    function oracleResolutionTime() external view returns (uint32);

    // payout settings
    function winningOutcome() external view returns (uint256);

    function userAlreadyWithdrawn(address) external view returns (bool);

    function artistAddress() external view returns (address);

    function artistCut() external view returns (uint256);

    function artistPaid() external view returns (bool);

    function affiliateAddress() external view returns (address);

    function affiliateCut() external view returns (uint256);

    function affiliatePaid() external view returns (bool);

    function winnerCut() external view returns (uint256);

    function marketCreatorAddress() external view returns (address);

    function creatorCut() external view returns (uint256);

    function creatorPaid() external view returns (bool);

    function cardAffiliateAddresses(uint256) external view returns (address);

    function cardAffiliateCut() external view returns (uint256);

    // oracle

    function questionId() external view returns (bytes32);

    function arbitrator() external view returns (address);

    function timeout() external view returns (uint32);

    function isFinalized() external view returns (bool);

    // setup
    function initialize(
        Mode _mode,
        uint32[] calldata _timestamps,
        uint256 _numberOfCards,
        address _artistAddress,
        address _affiliateAddress,
        address[] calldata _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion,
        uint256 _nftsToAward
    ) external;

    function transferCard(
        address _oldOwner,
        address _newOwner,
        uint256 _token,
        uint256 _price,
        uint256 _timeLimit
    ) external;
}

interface IRCOrderbook {
    struct Bid {
        address market;
        address next;
        address prev;
        uint64 card;
        uint128 price;
        uint64 timeHeldLimit;
    }

    function index(
        address _market,
        address _user,
        uint256 _token
    ) external view returns (uint256);

    function ownerOf(address, uint256) external view returns (address);

    function closedMarkets(uint256) external view returns (address);

    function userClosedMarketIndex(address) external view returns (uint256);

    function treasury() external view returns (IRCTreasury);

    function maxSearchIterations() external view returns (uint256);

    function maxDeletions() external view returns (uint256);

    function cleaningLoops() external view returns (uint256);

    function marketCloseLimit() external view returns (uint256);

    function nonce() external view returns (uint256);

    function cleanWastePile() external;

    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view returns (Bid memory);

    function setTreasuryAddress(address _newTreasury) external;

    function addBidToOrderbook(
        address _user,
        uint256 _token,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external;

    function removeBidFromOrderbook(address _user, uint256 _token) external;

    function closeMarket() external returns (bool);

    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)
        external;

    function getBidValue(address _user, uint256 _token)
        external
        view
        returns (uint256);

    function getTimeHeldlimit(address _user, uint256 _token)
        external
        returns (uint256);

    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) external view returns (bool);

    function setTimeHeldlimit(
        address _user,
        uint256 _token,
        uint256 _timeHeldLimit
    ) external;

    function removeUserFromOrderbook(address _user) external;

    function removeOldBids(address _user) external;

    function reduceTimeHeldLimit(
        address _user,
        uint256 _token,
        uint256 _timeToReduce
    ) external;

    function setDeletionLimit(uint256 _deletionLimit) external;

    function setCleaningLimit(uint256 _cleaningLimit) external;

    function setSearchLimit(uint256 _searchLimit) external;

    function setMarketCloseLimit(uint256 _marketCloseLimit) external;
}

interface IRCLeaderboard {
    function treasury() external view returns (IRCTreasury);

    function market() external view returns (IRCMarket);

    function NFTsToAward(address _market) external view returns (uint256);

    function updateLeaderboard(
        address _user,
        uint256 _card,
        uint256 _timeHeld
    ) external;

    function claimNFT(address _user, uint256 _card) external;
}

interface IRealitio {
    function askQuestion(
        uint256 template_id,
        string calldata question,
        address arbitrator,
        uint32 timeout,
        uint32 opening_ts,
        uint256 nonce
    ) external payable returns (bytes32);

    function resultFor(bytes32 question_id) external view returns (bytes32);

    function isFinalized(bytes32 question_id) external view returns (bool);

    function getContentHash(bytes32 question_id)
        external
        view
        returns (bytes32);
}

interface IRCNftHubL2 {
    function marketTracker(uint256) external view returns (address);

    function ownerOf(uint256) external view returns (address);

    function tokenURI(uint256) external view returns (string memory);

    function addMarket(address) external;

    function totalSupply() external view returns (uint256 nftCount);

    function mint(
        address,
        uint256,
        string calldata
    ) external;

    function transferNft(
        address,
        address,
        uint256
    ) external;

    function deposit(address user, bytes calldata depositData) external;

    function withdraw(uint256 tokenId) external;

    function withdrawWithMetadata(uint256 tokenId) external;
}",3813
RealWorld_TA_26_Migrations_RealWorld_20240803155514.log,26,Migrations,28708,1696,30404,95.0,0.17746,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

contract Migrations {
    address public owner;
    uint256 public last_completed_migration;

    constructor() {
        owner = msg.sender;
    }

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function setCompleted(uint256 completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    }
}",118
RealWorld_TA_26_DaiMockup_RealWorld_20240803160137.log,26,DaiMockup,27199,1600,28799,87.0,0.167995,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""hardhat/console.sol"";

contract DaiMockup {
    function approve(address _address, uint256 _amount)
        external
        pure
        returns (bool)
    {
        _address;
        _amount;
        return true;
    }

    function transferFrom(
        address,
        address,
        uint256
    ) public pure returns (bool) {
        return true;
    }
}",103
RealWorld_TA_26_RealitioMockup_RealWorld_20240803160840.log,26,RealitioMockup,86591,3169,89760,110.0,0.496335,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""hardhat/console.sol"";

contract RealitioMockup is Ownable {
    struct Question {
        bytes32 content_hash;
        uint256 template_id;
        string question;
        address arbitrator;
        uint32 timeout;
        uint32 opening_ts;
        uint256 answer;
        bool finalised;
    }
    mapping(bytes32 => Question) public questions;
    mapping(address => bytes32) public marketQuestion;

    event LogNewQuestion(
        bytes32 indexed question_id,
        address indexed user,
        uint256 template_id,
        string question,
        bytes32 indexed content_hash,
        address arbitrator,
        uint32 timeout,
        uint32 opening_ts,
        uint256 nonce,
        uint256 created
    );

    /// @notice set the result using the question_id
    function setResult(bytes32 question_id, uint256 _result)
        external
        onlyOwner
    {
        questions[question_id].answer = _result;
        questions[question_id].finalised = true;
    }

    /// @notice set the result using the market address
    function setResult(address _market, uint256 _result) external onlyOwner {
        bytes32 _question_id = getMarketQuestionId(_market);
        questions[_question_id].answer = _result;
        questions[_question_id].finalised = true;
    }

    function askQuestion(
        uint256 template_id,
        string calldata question,
        address arbitrator,
        uint32 timeout,
        uint32 opening_ts,
        uint256 nonce
    ) external payable returns (bytes32) {
        bytes32 content_hash = keccak256(
            abi.encodePacked(template_id, opening_ts, question)
        );
        bytes32 question_id = keccak256(
            abi.encodePacked(
                content_hash,
                arbitrator,
                timeout,
                msg.sender,
                nonce
            )
        );

        questions[question_id].content_hash = content_hash;
        questions[question_id].template_id = template_id;
        questions[question_id].question = question;
        questions[question_id].arbitrator = arbitrator;
        questions[question_id].timeout = timeout;
        questions[question_id].opening_ts = opening_ts;

        marketQuestion[msg.sender] = question_id;

        emit LogNewQuestion(
            question_id,
            msg.sender,
            template_id,
            question,
            content_hash,
            arbitrator,
            timeout,
            opening_ts,
            nonce,
            block.timestamp
        );
        return question_id;
    }

    function resultFor(bytes32 question_id) external view returns (bytes32) {
        require(
            questions[question_id].finalised == true,
            ""Question not finalised""
        );
        return bytes32(questions[question_id].answer);
    }

    function isFinalized(bytes32 question_id) external view returns (bool) {
        return questions[question_id].finalised;
    }

    function getContentHash(bytes32 question_id) public view returns (bytes32) {
        return questions[question_id].content_hash;
    }

    function getTimeout(bytes32 question_id) public view returns (uint32) {
        return questions[question_id].timeout;
    }

    function getMarketQuestionId(address _market)
        public
        view
        returns (bytes32)
    {
        return marketQuestion[_market];
    }

    function getMarketQuestion(address _market)
        public
        view
        returns (string memory)
    {
        uint256 _length = bytes(questions[marketQuestion[_market]].question)
            .length;
        string memory _question = new string(_length);
        _question = questions[marketQuestion[_market]].question;
        return _question;
    }
}",799
RealWorld_TA_27_TestUniswapLiquidity_RealWorld_20240803164715.log,27,TestUniswapLiquidity,55554,4303,59857,108.0,0.36383,"pragma solidity ^0.6.6;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract TestUniswapLiquidity is Ownable {
	address router;

	constructor(address _uni_router) public {
		router = _uni_router;
	}

	function redeemLiquidityETH(
		address token,
		uint256 liquidity,
		uint256 amountTokenMin,
		uint256 amountETHMin,
		address to,
		uint256 deadline
	) public onlyOwner {
		address pair =
			UniswapV2Library.pairFor(
				IUniswapV2Router02(router).factory(),
				token,
				IUniswapV2Router02(router).WETH()
			);
		IUniswapV2Pair(pair).approve(router, 2**256 - 1);

		IUniswapV2Router02(router).removeLiquidityETH(
			token,
			liquidity,
			amountTokenMin,
			amountETHMin,
			to,
			deadline
		);
	}

	function redeemLiquidity(
		address tokenA,
		address tokenB,
		uint256 liquidity,
		uint256 amountAMin,
		uint256 amountBMin,
		address to,
		uint256 deadline
	) public onlyOwner {
		IUniswapV2Router02(router).removeLiquidity(
			tokenA,
			tokenB,
			liquidity,
			amountAMin,
			amountBMin,
			to,
			deadline
		);
	}

	function transferTokens(
		address _to,
		uint256 _a,
		uint256 _b,
		address state_tokenContract
	) public onlyOwner {
		IERC20(state_tokenContract).transfer(_to, _a + _b);
	}
}",443
RealWorld_TA_27_TestLogicContract_RealWorld_20240803165628.log,27,TestLogicContract,31384,2390,33774,94.0,0.20472,"pragma solidity ^0.6.6;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract TestLogicContract is Ownable {
	address state_tokenContract;

	constructor(address _tokenContract) public {
		state_tokenContract = _tokenContract;
	}

	function transferTokens(
		address _to,
		uint256 _a,
		uint256 _b
	) public onlyOwner {
		IERC20(state_tokenContract).transfer(_to, _a + _b);
		console.log(""Sent Tokens"");
	}
}",164
RealWorld_TA_27_TestERC20A_RealWorld_20240803165201.log,27,TestERC20A,45224,1361,46585,83.0,0.25334,"pragma solidity ^0.6.6;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

// One of three testing coins
contract TestERC20A is ERC20 {
	constructor() public ERC20(""Bitcoin MAX"", ""MAX"") {
		_mint(0xc783df8a850f42e7F7e57013759C285caa701eB6, 10000);
		_mint(0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4, 10000);
		_mint(0xE5904695748fe4A84b40b3fc79De2277660BD1D3, 10000);
		_mint(0x92561F28Ec438Ee9831D00D1D59fbDC981b762b2, 10000);
		_mint(0x2fFd013AaA7B5a7DA93336C2251075202b33FB2B, 10000);
		// this is the EtherBase address for our testnet miner in
		// tests/assets/ETHGenesis.json so it wil have both a lot
		// of ETH and a lot of erc20 tokens to test with
		_mint(0xBf660843528035a5A4921534E156a27e64B231fE, 100000000000000000000000000);
	}
}",324
RealWorld_TA_27_Gravity_RealWorld_20240803163715.log,27,Gravity,439824,5748,445572,167.0,2.31408,"pragma solidity ^0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";
import ""./CosmosToken.sol"";

pragma experimental ABIEncoderV2;

// This is being used purely to avoid stack too deep errors
struct LogicCallArgs {
	// Transfers out to the logic contract
	uint256[] transferAmounts;
	address[] transferTokenContracts;
	// The fees (transferred to msg.sender)
	uint256[] feeAmounts;
	address[] feeTokenContracts;
	// The arbitrary logic call
	address logicContractAddress;
	bytes payload;
	// Invalidation metadata
	uint256 timeOut;
	bytes32 invalidationId;
	uint256 invalidationNonce;
}

// This is used purely to avoid stack too deep errors
// represents everything about a given validator set
struct ValsetArgs {
	// the validators in this set, represented by an Ethereum address
	address[] validators;
	// the powers of the given validators in the same order as above
	uint256[] powers;
	// the nonce of this validator set
	uint256 valsetNonce;
	// the reward amount denominated in the below reward token, can be
	// set to zero
	uint256 rewardAmount;
	// the reward token, should be set to the zero address if not being used
	address rewardToken;
}

contract Gravity is ReentrancyGuard {
	using SafeMath for uint256;
	using SafeERC20 for IERC20;

	// These are updated often
	bytes32 public state_lastValsetCheckpoint;
	mapping(address => uint256) public state_lastBatchNonces;
	mapping(bytes32 => uint256) public state_invalidationMapping;
	uint256 public state_lastValsetNonce = 0;
	// event nonce zero is reserved by the Cosmos module as a special
	// value indicating that no events have yet been submitted
	uint256 public state_lastEventNonce = 1;

	// These are set once at initialization
	bytes32 public state_gravityId;
	uint256 public state_powerThreshold;

	// TransactionBatchExecutedEvent and SendToCosmosEvent both include the field _eventNonce.
	// This is incremented every time one of these events is emitted. It is checked by the
	// Cosmos module to ensure that all events are received in order, and that none are lost.
	//
	// ValsetUpdatedEvent does not include the field _eventNonce because it is never submitted to the Cosmos
	// module. It is purely for the use of relayers to allow them to successfully submit batches.
	event TransactionBatchExecutedEvent(
		uint256 indexed _batchNonce,
		address indexed _token,
		uint256 _eventNonce
	);
	event SendToCosmosEvent(
		address indexed _tokenContract,
		address indexed _sender,
		bytes32 indexed _destination,
		uint256 _amount,
		uint256 _eventNonce
	);
	event ERC20DeployedEvent(
		// FYI: Can't index on a string without doing a bunch of weird stuff
		string _cosmosDenom,
		address indexed _tokenContract,
		string _name,
		string _symbol,
		uint8 _decimals,
		uint256 _eventNonce
	);
	event ValsetUpdatedEvent(
		uint256 indexed _newValsetNonce,
		uint256 _eventNonce,
		uint256 _rewardAmount,
		address _rewardToken,
		address[] _validators,
		uint256[] _powers
	);
	event LogicCallEvent(
		bytes32 _invalidationId,
		uint256 _invalidationNonce,
		bytes _returnData,
		uint256 _eventNonce
	);

	// TEST FIXTURES
	// These are here to make it easier to measure gas usage. They should be removed before production
	function testMakeCheckpoint(
		ValsetArgs memory _valsetArgs,
		bytes32 _gravityId
	) public pure {
		makeCheckpoint(_valsetArgs, _gravityId);
	}

	function testCheckValidatorSignatures(
		address[] memory _currentValidators,
		uint256[] memory _currentPowers,
		uint8[] memory _v,
		bytes32[] memory _r,
		bytes32[] memory _s,
		bytes32 _theHash,
		uint256 _powerThreshold
	) public pure {
		checkValidatorSignatures(
			_currentValidators,
			_currentPowers,
			_v,
			_r,
			_s,
			_theHash,
			_powerThreshold
		);
	}

	// END TEST FIXTURES

	function lastBatchNonce(address _erc20Address) public view returns (uint256) {
		return state_lastBatchNonces[_erc20Address];
	}

	function lastLogicCallNonce(bytes32 _invalidation_id) public view returns (uint256) {
		return state_invalidationMapping[_invalidation_id];
	}

	// Utility function to verify geth style signatures
	function verifySig(
		address _signer,
		bytes32 _theHash,
		uint8 _v,
		bytes32 _r,
		bytes32 _s
	) private pure returns (bool) {
		bytes32 messageDigest =
			keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", _theHash));
		return _signer == ecrecover(messageDigest, _v, _r, _s);
	}

	// Make a new checkpoint from the supplied validator set
	// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,
	// instead of storing the information directly. This saves on storage and gas.
	// The format of the checkpoint is:
	// h(gravityId, ""checkpoint"", valsetNonce, validators[], powers[])
	// Where h is the keccak256 hash function.
	// The validator powers must be decreasing or equal. This is important for checking the signatures on the
	// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.
	function makeCheckpoint(
		ValsetArgs memory _valsetArgs,
		bytes32 _gravityId
	) private pure returns (bytes32) {
		// bytes32 encoding of the string ""checkpoint""
		bytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;

		bytes32 checkpoint =
			keccak256(abi.encode(_gravityId, methodName, _valsetArgs.valsetNonce, _valsetArgs.validators, _valsetArgs.powers, _valsetArgs.rewardAmount, _valsetArgs.rewardToken));

		return checkpoint;
	}

	function checkValidatorSignatures(
		// The current validator set and their powers
		address[] memory _currentValidators,
		uint256[] memory _currentPowers,
		// The current validator's signatures
		uint8[] memory _v,
		bytes32[] memory _r,
		bytes32[] memory _s,
		// This is what we are checking they have signed
		bytes32 _theHash,
		uint256 _powerThreshold
	) private pure {
		uint256 cumulativePower = 0;

		for (uint256 i = 0; i < _currentValidators.length; i++) {
			// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation
			// (In a valid signature, it is either 27 or 28)
			if (_v[i] != 0) {
				// Check that the current validator has signed off on the hash
				require(
					verifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),
					""Validator signature does not match.""
				);

				// Sum up cumulative power
				cumulativePower = cumulativePower + _currentPowers[i];

				// Break early to avoid wasting gas
				if (cumulativePower > _powerThreshold) {
					break;
				}
			}
		}

		// Check that there was enough power
		require(
			cumulativePower > _powerThreshold,
			""Submitted validator set signatures do not have enough power.""
		);
		// Success
	}

	// This updates the valset by checking that the validators in the current valset have signed off on the
	// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash
	// generated from the new valset.
	// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over
	// the new valset.
	function updateValset(
		// The new version of the validator set
		ValsetArgs memory _newValset,
		// The current validators that approve the change
		ValsetArgs memory _currentValset,
		// These are arrays of the parts of the current validator's signatures
		uint8[] memory _v,
		bytes32[] memory _r,
		bytes32[] memory _s
	) public nonReentrant {
		// CHECKS

		// Check that the valset nonce is greater than the old one
		require(
			_newValset.valsetNonce > _currentValset.valsetNonce,
			""New valset nonce must be greater than the current nonce""
		);

		// Check that new validators and powers set is well-formed
		require(_newValset.validators.length == _newValset.powers.length, ""Malformed new validator set"");

		// Check that current validators, powers, and signatures (v,r,s) set is well-formed
		require(
			_currentValset.validators.length == _currentValset.powers.length &&
				_currentValset.validators.length == _v.length &&
				_currentValset.validators.length == _r.length &&
				_currentValset.validators.length == _s.length,
			""Malformed current validator set""
		);

		// Check that the supplied current validator set matches the saved checkpoint
		require(
			makeCheckpoint(
				_currentValset,
				state_gravityId
			) == state_lastValsetCheckpoint,
			""Supplied current validators and powers do not match checkpoint.""
		);

		// Check that enough current validators have signed off on the new validator set
		bytes32 newCheckpoint =
			makeCheckpoint(_newValset, state_gravityId);

		checkValidatorSignatures(
			_currentValset.validators,
			_currentValset.powers,
			_v,
			_r,
			_s,
			newCheckpoint,
			state_powerThreshold
		);

		// ACTIONS

		// Stored to be used next time to validate that the valset
		// supplied by the caller is correct.
		state_lastValsetCheckpoint = newCheckpoint;

		// Store new nonce
		state_lastValsetNonce = _newValset.valsetNonce;

		// Send submission reward to msg.sender if reward token is a valid value
		if (_newValset.rewardToken != address(0) && _newValset.rewardAmount != 0) {
			IERC20(_newValset.rewardToken).safeTransfer(msg.sender, _newValset.rewardAmount);
		}

		// LOGS

		state_lastEventNonce = state_lastEventNonce.add(1);
		emit ValsetUpdatedEvent(_newValset.valsetNonce, state_lastEventNonce, _newValset.rewardAmount, _newValset.rewardToken, _newValset.validators, _newValset.powers);
	}

	// submitBatch processes a batch of Cosmos -> Ethereum transactions by sending the tokens in the transactions
	// to the destination addresses. It is approved by the current Cosmos validator set.
	// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over
	// the batch.
	function submitBatch(
		// The validators that approve the batch
		ValsetArgs memory _currentValset,
		// These are arrays of the parts of the validators signatures
		uint8[] memory _v,
		bytes32[] memory _r,
		bytes32[] memory _s,
		// The batch of transactions
		uint256[] memory _amounts,
		address[] memory _destinations,
		uint256[] memory _fees,
		uint256 _batchNonce,
		address _tokenContract,
		// a block height beyond which this batch is not valid
		// used to provide a fee-free timeout
		uint256 _batchTimeout
	) public nonReentrant {
		// CHECKS scoped to reduce stack depth
		{
			// Check that the batch nonce is higher than the last nonce for this token
			require(
				state_lastBatchNonces[_tokenContract] < _batchNonce,
				""New batch nonce must be greater than the current nonce""
			);

			// Check that the block height is less than the timeout height
			require(
				block.number < _batchTimeout,
				""Batch timeout must be greater than the current block height""
			);

			// Check that current validators, powers, and signatures (v,r,s) set is well-formed
			require(
				_currentValset.validators.length == _currentValset.powers.length &&
					_currentValset.validators.length == _v.length &&
					_currentValset.validators.length == _r.length &&
					_currentValset.validators.length == _s.length,
				""Malformed current validator set""
			);

			// Check that the supplied current validator set matches the saved checkpoint
			require(
				makeCheckpoint(
					_currentValset,
					state_gravityId
				) == state_lastValsetCheckpoint,
				""Supplied current validators and powers do not match checkpoint.""
			);

			// Check that the transaction batch is well-formed
			require(
				_amounts.length == _destinations.length && _amounts.length == _fees.length,
				""Malformed batch of transactions""
			);

			// Check that enough current validators have signed off on the transaction batch and valset
			checkValidatorSignatures(
				_currentValset.validators,
				_currentValset.powers,
				_v,
				_r,
				_s,
				// Get hash of the transaction batch and checkpoint
				keccak256(
					abi.encode(
						state_gravityId,
						// bytes32 encoding of ""transactionBatch""
						0x7472616e73616374696f6e426174636800000000000000000000000000000000,
						_amounts,
						_destinations,
						_fees,
						_batchNonce,
						_tokenContract,
						_batchTimeout
					)
				),
				state_powerThreshold
			);

			// ACTIONS

			// Store batch nonce
			state_lastBatchNonces[_tokenContract] = _batchNonce;

			{
				// Send transaction amounts to destinations
				uint256 totalFee;
				for (uint256 i = 0; i < _amounts.length; i++) {
					IERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);
					totalFee = totalFee.add(_fees[i]);
				}

				// Send transaction fees to msg.sender
				IERC20(_tokenContract).safeTransfer(msg.sender, totalFee);
			}
		}

		// LOGS scoped to reduce stack depth
		{
			state_lastEventNonce = state_lastEventNonce.add(1);
			emit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);
		}
	}

	// This makes calls to contracts that execute arbitrary logic
	// First, it gives the logic contract some tokens
	// Then, it gives msg.senders tokens for fees
	// Then, it calls an arbitrary function on the logic contract
	// invalidationId and invalidationNonce are used for replay prevention.
	// They can be used to implement a per-token nonce by setting the token
	// address as the invalidationId and incrementing the nonce each call.
	// They can be used for nonce-free replay prevention by using a different invalidationId
	// for each call.
	function submitLogicCall(
		// The validators that approve the call
		ValsetArgs memory _currentValset,
		// These are arrays of the parts of the validators signatures
		uint8[] memory _v,
		bytes32[] memory _r,
		bytes32[] memory _s,
		LogicCallArgs memory _args
	) public nonReentrant {
		// CHECKS scoped to reduce stack depth
		{
			// Check that the call has not timed out
			require(block.number < _args.timeOut, ""Timed out"");

			// Check that the invalidation nonce is higher than the last nonce for this invalidation Id
			require(
				state_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,
				""New invalidation nonce must be greater than the current nonce""
			);

			// Check that current validators, powers, and signatures (v,r,s) set is well-formed
			require(
			    _currentValset.validators.length == _currentValset.powers.length &&
					_currentValset.validators.length == _v.length &&
					_currentValset.validators.length == _r.length &&
					_currentValset.validators.length == _s.length,
				""Malformed current validator set""
			);

			// Check that the supplied current validator set matches the saved checkpoint
			require(
				makeCheckpoint(
					_currentValset,
					state_gravityId
				) == state_lastValsetCheckpoint,
				""Supplied current validators and powers do not match checkpoint.""
			);

			// Check that the token transfer list is well-formed
			require(
				_args.transferAmounts.length == _args.transferTokenContracts.length,
				""Malformed list of token transfers""
			);

			// Check that the fee list is well-formed
			require(
				_args.feeAmounts.length == _args.feeTokenContracts.length,
				""Malformed list of fees""
			);
		}

		bytes32 argsHash =
			keccak256(
				abi.encode(
					state_gravityId,
					// bytes32 encoding of ""logicCall""
					0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,
					_args.transferAmounts,
					_args.transferTokenContracts,
					_args.feeAmounts,
					_args.feeTokenContracts,
					_args.logicContractAddress,
					_args.payload,
					_args.timeOut,
					_args.invalidationId,
					_args.invalidationNonce
				)
			);

		{
			// Check that enough current validators have signed off on the transaction batch and valset
			checkValidatorSignatures(
				_currentValset.validators,
				_currentValset.powers,
				_v,
				_r,
				_s,
				// Get hash of the transaction batch and checkpoint
				argsHash,
				state_powerThreshold
			);
		}

		// ACTIONS

		// Update invaldiation nonce
		state_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;

		// Send tokens to the logic contract
		for (uint256 i = 0; i < _args.transferAmounts.length; i++) {
			IERC20(_args.transferTokenContracts[i]).safeTransfer(
				_args.logicContractAddress,
				_args.transferAmounts[i]
			);
		}

		// Make call to logic contract
		bytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);

		// Send fees to msg.sender
		for (uint256 i = 0; i < _args.feeAmounts.length; i++) {
			IERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);
		}

		// LOGS scoped to reduce stack depth
		{
			state_lastEventNonce = state_lastEventNonce.add(1);
			emit LogicCallEvent(
				_args.invalidationId,
				_args.invalidationNonce,
				returnData,
				state_lastEventNonce
			);
		}
	}

	function sendToCosmos(
		address _tokenContract,
		bytes32 _destination,
		uint256 _amount
	) public nonReentrant {
		IERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);
		state_lastEventNonce = state_lastEventNonce.add(1);
		emit SendToCosmosEvent(
			_tokenContract,
			msg.sender,
			_destination,
			_amount,
			state_lastEventNonce
		);
	}

	function deployERC20(
		string memory _cosmosDenom,
		string memory _name,
		string memory _symbol,
		uint8 _decimals
	) public {
		// Deploy an ERC20 with entire supply granted to Gravity.sol
		CosmosERC20 erc20 = new CosmosERC20(address(this), _name, _symbol, _decimals);

		// Fire an event to let the Cosmos module know
		state_lastEventNonce = state_lastEventNonce.add(1);
		emit ERC20DeployedEvent(
			_cosmosDenom,
			address(erc20),
			_name,
			_symbol,
			_decimals,
			state_lastEventNonce
		);
	}

	constructor(
		// A unique identifier for this gravity instance to use in signatures
		bytes32 _gravityId,
		// How much voting power is needed to approve operations
		uint256 _powerThreshold,
		// The validator set, not in valset args format since many of it's
		// arguments would never be used in this case
		address[] memory _validators,
        uint256[] memory _powers
	) public {
		// CHECKS

		// Check that validators, powers, and signatures (v,r,s) set is well-formed
		require(_validators.length == _powers.length, ""Malformed current validator set"");

		// Check cumulative power to ensure the contract has sufficient power to actually
		// pass a vote
		uint256 cumulativePower = 0;
		for (uint256 i = 0; i < _powers.length; i++) {
			cumulativePower = cumulativePower + _powers[i];
			if (cumulativePower > _powerThreshold) {
				break;
			}
		}
		require(
			cumulativePower > _powerThreshold,
			""Submitted validator set signatures do not have enough power.""
		);

		ValsetArgs memory _valset;
		_valset = ValsetArgs(_validators, _powers, 0, 0, address(0));
		
		bytes32 newCheckpoint = makeCheckpoint(_valset, _gravityId);

		// ACTIONS

		state_gravityId = _gravityId;
		state_powerThreshold = _powerThreshold;
		state_lastValsetCheckpoint = newCheckpoint;

		// LOGS

		emit ValsetUpdatedEvent(state_lastValsetNonce, state_lastEventNonce, 0, address(0), _validators, _powers);
	}
}",5024
RealWorld_TA_27_ReentrantERC20_RealWorld_20240803164522.log,27,ReentrantERC20,47770,4542,52312,110.0,0.32969,"pragma solidity ^0.6.6;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./Gravity.sol"";

pragma experimental ABIEncoderV2;

// Reentrant evil erc20
contract ReentrantERC20 {
    address state_gravityAddress;

    constructor(address _gravityAddress) public {
        state_gravityAddress = _gravityAddress;
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        // _currentValidators, _currentPowers, _currentValsetNonce, _v, _r, _s, _args);(
        address[] memory addresses = new address[](0);
        bytes32[] memory bytes32s = new bytes32[](0);
        uint256[] memory uint256s = new uint256[](0);
        address blankAddress = address(0);
        bytes memory bytess = new bytes(0);
        uint256 zero = 0;
        LogicCallArgs memory args;
        ValsetArgs memory valset;

        {
            args = LogicCallArgs(
                uint256s,
                addresses,
                uint256s,
                addresses,
                address(0),
                bytess,
                zero,
                bytes32(0),
                zero
            );
        }

        {
            valset = ValsetArgs(addresses, uint256s, zero, zero, blankAddress);
        }
        
        Gravity(state_gravityAddress).submitLogicCall(
            valset,
            new uint8[](0), 
            bytes32s, 
            bytes32s,
            args
        );
    }
}",330
RealWorld_TA_27_SimpleLogicBatch_RealWorld_20240803164135.log,27,SimpleLogicBatch,47858,3701,51559,111.0,0.31331,"pragma solidity ^0.6.6;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

import ""hardhat/console.sol"";


// This middleware allows arbitrary logic batches, executed by a single
// logic contract taking a single token.
// It would be trivial to pass an array of multiple token contracts and
// an array of multiple logic contracts, but we are not doing it here to
// save gas.
contract SimpleLogicBatchMiddleware is Ownable {
	using SafeERC20 for IERC20;

	event LogicCallEvent(
		address _logicContract,
		address _tokenContract,
		bool _success,
		bytes _returnData
	);

	function logicBatch(
		uint256[] memory _amounts,
		bytes[] memory _payloads,
		address _logicContract,
		address _tokenContract
	) public onlyOwner {
		// Send transaction amounts to destinations
		console.log(""number of _amounts:%s"", _amounts.length);
		for (uint256 i = 0; i < _amounts.length; i++) {
			console.log(""Transfering %s"",_amounts[i]);

			IERC20(_tokenContract).safeTransfer(_logicContract, _amounts[i]);
            bytes memory returnData= Address.functionCall(_logicContract,_payloads[i]);
			emit LogicCallEvent(_tokenContract, _logicContract, true, returnData);
		}
	}
}",348
RealWorld_TA_27_TestERC20C_RealWorld_20240803164905.log,27,TestERC20C,45608,1426,47034,83.0,0.25656,"pragma solidity ^0.6.6;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

// One of three testing coins
contract TestERC20C is ERC20 {
	constructor() public ERC20(""Byecoin"", ""BYE"") {
		_mint(0xc783df8a850f42e7F7e57013759C285caa701eB6, 10000);
		_mint(0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4, 10000);
		_mint(0xE5904695748fe4A84b40b3fc79De2277660BD1D3, 10000);
		_mint(0x92561F28Ec438Ee9831D00D1D59fbDC981b762b2, 10000);
		_mint(0x2fFd013AaA7B5a7DA93336C2251075202b33FB2B, 10000);
		// this is the EtherBase address for our testnet miner in
		// tests/assets/ETHGenesis.json so it wil have both a lot
		// of ETH and a lot of erc20 tokens to test with
		_mint(0xBf660843528035a5A4921534E156a27e64B231fE, 100000000000000000000000000);
	}
}",326
RealWorld_TA_27_CosmosToken_RealWorld_20240803164005.log,27,CosmosToken,27417,2209,29626,88.0,0.181265,"pragma solidity ^0.6.6;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract CosmosERC20 is ERC20 {
	uint256 MAX_UINT = 2**256 - 1;

	constructor(
		address _gravityAddress,
		string memory _name,
		string memory _symbol,
		uint8 _decimals
	) public ERC20(_name, _symbol) {
		_setupDecimals(_decimals);
		_mint(_gravityAddress, MAX_UINT);
	}
}",108
RealWorld_TA_27_TestERC20B_RealWorld_20240803165030.log,27,TestERC20B,45677,1411,47088,89.0,0.256605,"pragma solidity ^0.6.6;
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

// One of three testing coins
contract TestERC20B is ERC20 {
	constructor() public ERC20(""2 Ethereum"", ""E2H"") {
		_mint(0xc783df8a850f42e7F7e57013759C285caa701eB6, 10000);
		_mint(0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4, 10000);
		_mint(0xE5904695748fe4A84b40b3fc79De2277660BD1D3, 10000);
		_mint(0x92561F28Ec438Ee9831D00D1D59fbDC981b762b2, 10000);
		_mint(0x2fFd013AaA7B5a7DA93336C2251075202b33FB2B, 10000);
		// this is the EtherBase address for our testnet miner in
		// tests/assets/ETHGenesis.json so it wil have both a lot
		// of ETH and a lot of erc20 tokens to test with
		_mint(0xBf660843528035a5A4921534E156a27e64B231fE, 100000000000000000000000000);
	}
}",326
RealWorld_TA_27_TestTokenBatchMiddleware copy_RealWorld_20240803165455.log,27,TestTokenBatchMiddleware copy,31743,2693,34436,91.0,0.212575,"pragma solidity ^0.6.6;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract TestTokenBatchMiddleware is Ownable {
	using SafeERC20 for IERC20;

	function submitBatch(
		uint256[] memory _amounts,
		address[] memory _destinations,
		address _tokenContract
	) public onlyOwner {
		// Send transaction amounts to destinations
		for (uint256 i = 0; i < _amounts.length; i++) {
			IERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);
		}
	}
}",163
RealWorld_TA_27_HashingTest_RealWorld_20240803164328.log,27,HashingTest,82432,3735,86167,111.0,0.48686,"pragma solidity ^0.6.6;

import ""hardhat/console.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract HashingTest {
	using SafeMath for uint256;

	bytes32 public lastCheckpoint;
	address[] public state_validators;
	uint256[] public state_powers;
	uint256 public state_nonce;

	function IterativeHash(
		address[] memory _validators,
		uint256[] memory _powers,
		uint256 _valsetNonce,
		bytes32 _gravityId
	) public {
		// bytes32 encoding of the string ""checkpoint""
		bytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;

		bytes32 checkpoint = keccak256(abi.encode(_gravityId, methodName, _valsetNonce));

		// Iterative hashing of valset
		{
			for (uint256 i = 0; i < _validators.length; i = i.add(1)) {
				// Check that validator powers are decreasing or equal (this allows the next
				// caller to break out of signature evaluation ASAP to save more gas)
				if (i != 0) {
					require(
						!(_powers[i] > _powers[i - 1]),
						""Validator power must not be higher than previous validator in batch""
					);
				}
				checkpoint = keccak256(abi.encode(checkpoint, _validators[i], _powers[i]));
			}
		}

		lastCheckpoint = checkpoint;
	}

	function ConcatHash(
		address[] memory _validators,
		uint256[] memory _powers,
		uint256 _valsetNonce,
		bytes32 _gravityId
	) public {
		// bytes32 encoding of the string ""checkpoint""
		bytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;

		bytes32 idHash = keccak256(abi.encode(_gravityId, methodName, _valsetNonce));

		bytes32 validatorHash = keccak256(abi.encode(_validators));

		bytes32 powersHash = keccak256(abi.encode(_powers));

		bytes32 checkpoint = keccak256(abi.encode(idHash, validatorHash, powersHash));

		lastCheckpoint = checkpoint;
	}

	function ConcatHash2(
		address[] memory _validators,
		uint256[] memory _powers,
		uint256 _valsetNonce,
		bytes32 _gravityId
	) public {
		// bytes32 encoding of the string ""checkpoint""
		bytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;

		bytes32 checkpoint = keccak256(
			abi.encode(_gravityId, methodName, _valsetNonce, _validators, _powers)
		);

		lastCheckpoint = checkpoint;
	}

	function JustSaveEverything(
		address[] memory _validators,
		uint256[] memory _powers,
		uint256 _valsetNonce
	) public {
		state_validators = _validators;
		state_powers = _powers;
		state_nonce = _valsetNonce;
	}

	function JustSaveEverythingAgain(
		address[] memory _validators,
		uint256[] memory _powers,
		uint256 _valsetNonce
	) public {
		state_validators = _validators;
		state_powers = _powers;
		state_nonce = _valsetNonce;
	}
}",736
RealWorld_TA_27_SigningTest_RealWorld_20240803165326.log,27,SigningTest,38170,1770,39940,87.0,0.22625,"pragma solidity ^0.6.6;

import ""hardhat/console.sol"";

contract SigningTest {
	function checkSignature(
		address _signer,
		bytes32 _theHash,
		uint8 _v,
		bytes32 _r,
		bytes32 _s
	) public view {
		bytes32 messageDigest = keccak256(abi.encode(""\x19Ethereum Signed Message:\n32"", _theHash));

		console.log(""signer"");
		console.logAddress(_signer);
		console.log(""theHash"");
		console.logBytes32(_theHash);
		console.log(""v"");
		console.logUint(_v);
		console.log(""r"");
		console.logBytes32(_r);
		console.log(""s"");
		console.logBytes32(_s);
		console.log(""ecrecover"");
		console.logAddress(ecrecover(messageDigest, _v, _r, _s));
		console.log(""address"");
		console.logAddress(_signer);

		require(_signer == ecrecover(messageDigest, _v, _r, _s), ""Signature does not match."");
	}
}",229
RealWorld_TA_28_DummyERC20A_RealWorld_20240803200251.log,28,DummyERC20A,52776,2975,55751,104.0,0.32338,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.6.8;

/**
 * Dummy ERC20 token.
 */
contract DummyERC20A {
    uint256 t;
    
    mapping(address => uint256) b;
    mapping(address => mapping(address => uint256)) a;

    string public name;
    string public symbol;
    uint public decimals;

    function myAddress() public returns (address) {
        return address(this);
    }

    function add(uint a, uint b) internal pure returns (uint256) {
        uint c = a + b;
        require (c >= a);
        return c;
    }

    function sub(uint a, uint b) internal pure returns (uint256) {
        require (a >= b);
        return a - b;
    }

    function totalSupply() external view returns (uint256) {
        return t;
    }

    function balanceOf(address account) external view returns (uint256) {
        return b[account];
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        b[msg.sender] = sub(b[msg.sender], amount);
        b[recipient] = add(b[recipient], amount);
        return true;
    }

    function allowance(address owner, address spender) external view returns (uint256) {
        return a[owner][spender];
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        a[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        b[sender] = sub(b[sender], amount);
        b[recipient] = add(b[recipient], amount);
        a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
        return true;
    }
}",392
RealWorld_TA_28_IUniswapV2Router01_RealWorld_20240803173210.log,28,IUniswapV2Router01,81305,2089,83394,95.0,0.448305,"pragma solidity 0.6.12;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}",774
RealWorld_TA_28_IWhiteList_RealWorld_20240803193017.log,28,IWhiteList,25168,2015,27183,95.0,0.16614,"pragma solidity 0.6.12;

// ----------------------------------------------------------------------------
// White List interface
// ----------------------------------------------------------------------------

interface IWhiteList {
    function isInWhiteList(address account) external view returns (bool);
    function addWhiteList(address[] calldata accounts) external ;
    function removeWhiteList(address[] calldata accounts) external ;
    function initWhiteList(address accessControl) external ;

}",76
RealWorld_TA_28_IMasterContract_RealWorld_20240803193601.log,28,IMasterContract,25657,1601,27258,86.0,0.160305,"pragma solidity 0.6.12;

interface IMasterContract {
    /// @notice Init function that gets called from `BoringFactory.deploy`.
    /// Also kown as the constructor for cloned contracts.
    /// Any ETH send to `BoringFactory.deploy` ends up here.
    /// @param data Can be abi encoded arguments or anything else.
    function init(bytes calldata data) external payable;
}",84
RealWorld_TA_28_DutchAuction_RealWorld_20240803182426.log,28,DutchAuction,518817,6974,525791,182.0,2.733565,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;


//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's Dutch Auction
//
// A declining price auction with fair price discovery. 
//
// Inspired by DutchSwap's Dutch Auctions
// https://github.com/deepyr/DutchSwap
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi, Kusatoshi, SSMikazu 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""../OpenZeppelin/utils/ReentrancyGuard.sol"";
import ""../Access/MISOAccessControls.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../Utils/BoringBatchable.sol"";
import ""../Utils/BoringMath.sol"";
import ""../Utils/BoringERC20.sol"";
import ""../Utils/Documents.sol"";
import ""../interfaces/IPointList.sol"";
import ""../interfaces/IMisoMarket.sol"";

/// @notice Attribution to delta.financial
/// @notice Attribution to dutchswap.com

contract DutchAuction is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;
    using BoringERC20 for IERC20;

    /// @notice MISOMarket template id for the factory contract.
    /// @dev For different marketplace types, this must be incremented.
    uint256 public constant override marketTemplate = 2;
    /// @dev The placeholder ETH address.
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @notice Main market variables.
    struct MarketInfo {
        uint64 startTime;
        uint64 endTime;
        uint128 totalTokens;
    }
    MarketInfo public marketInfo;

    /// @notice Market price variables.
    struct MarketPrice {
        uint128 startPrice;
        uint128 minimumPrice;
    }
    MarketPrice public marketPrice;

    /// @notice Market dynamic variables.
    struct MarketStatus {
        uint128 commitmentsTotal;
        bool finalized;
        bool usePointList;
    }

    MarketStatus public marketStatus;

    /// @notice The token being sold.
    address public auctionToken; 
    /// @notice The currency the auction accepts for payment. Can be ETH or token address.
    address public paymentCurrency;  
    /// @notice Where the auction funds will get paid.
    address payable public wallet;  
    /// @notice Address that manages auction approvals.
    address public pointList;

    /// @notice The commited amount of accounts.
    mapping(address => uint256) public commitments; 
    /// @notice Amount of tokens to claim per address.
    mapping(address => uint256) public claimed;

    /// @notice Event for updating auction times.  Needs to be before auction starts.
    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); 
    /// @notice Event for updating auction prices. Needs to be before auction starts.
    event AuctionPriceUpdated(uint256 startPrice, uint256 minimumPrice); 
    /// @notice Event for updating auction wallet. Needs to be before auction starts.
    event AuctionWalletUpdated(address wallet); 

    /// @notice Event for adding a commitment.
    event AddedCommitment(address addr, uint256 commitment);   
    /// @notice Event for finalization of the auction.
    event AuctionFinalized();
    /// @notice Event for cancellation of the auction.
    event AuctionCancelled();

    /**
     * @notice Initializes main contract variables and transfers funds for the auction.
     * @dev Init function.
     * @param _funder The address that funds the token for crowdsale.
     * @param _token Address of the token being sold.
     * @param _totalTokens The total number of tokens to sell in auction.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.
     * @param _startPrice Starting price of the auction.
     * @param _minimumPrice The minimum auction price.
     * @param _admin Address that can finalize auction.
     * @param _pointList Address that will manage auction approvals.
     * @param _wallet Address where collected funds will be forwarded to.
     */
    function initAuction(
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _startPrice,
        uint256 _minimumPrice,
        address _admin,
        address _pointList,
        address payable _wallet
    ) public {
        require(_startTime < 10000000000, ""DutchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""DutchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""DutchAuction: start time is before current time"");
        require(_endTime > _startTime, ""DutchAuction: end time must be older than start price"");
        require(_totalTokens > 0,""DutchAuction: total tokens must be greater than zero"");
        require(_startPrice > _minimumPrice, ""DutchAuction: start price must be higher than minimum price"");
        require(_minimumPrice > 0, ""DutchAuction: minimum price must be greater than 0""); 
        require(_admin != address(0), ""DutchAuction: admin is the zero address"");
        require(_wallet != address(0), ""DutchAuction: wallet is the zero address"");
        require(IERC20(_token).decimals() == 18, ""DutchAuction: Token does not have 18 decimals"");
        if (_paymentCurrency != ETH_ADDRESS) {
            require(IERC20(_paymentCurrency).decimals() > 0, ""DutchAuction: Payment currency is not ERC20"");
        }

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        marketInfo.totalTokens = BoringMath.to128(_totalTokens);

        marketPrice.startPrice = BoringMath.to128(_startPrice);
        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);

        auctionToken = _token;
        paymentCurrency = _paymentCurrency;
        wallet = _wallet;

        initAccessControls(_admin);

        _setList(_pointList);
        _safeTransferFrom(_token, _funder, _totalTokens);
    }



    /**
     Dutch Auction Price Function
     ============================
     
     Start Price -----
                      \
                       \
                        \
                         \ ------------ Clearing Price
                        / \            = AmountRaised/TokenSupply
         Token Price  --   \
                     /      \
                   --        ----------- Minimum Price
     Amount raised /          End Time
    */

    /**
     * @notice Calculates the average price of each token from all commitments.
     * @return Average token price.
     */
    function tokenPrice() public view returns (uint256) {
        return uint256(marketStatus.commitmentsTotal)
            .mul(1e18).div(uint256(marketInfo.totalTokens));
    }

    /**
     * @notice Returns auction price in any time.
     * @return Fixed start price or minimum price if outside of auction time, otherwise calculated current price.
     */
    function priceFunction() public view returns (uint256) {
        /// @dev Return Auction Price
        if (block.timestamp <= uint256(marketInfo.startTime)) {
            return uint256(marketPrice.startPrice);
        }
        if (block.timestamp >= uint256(marketInfo.endTime)) {
            return uint256(marketPrice.minimumPrice);
        }

        return _currentPrice();
    }

    /**
     * @notice The current clearing price of the Dutch auction.
     * @return The bigger from tokenPrice and priceFunction.
     */
    function clearingPrice() public view returns (uint256) {
        /// @dev If auction successful, return tokenPrice
        if (tokenPrice() > priceFunction()) {
            return tokenPrice();
        }
        return priceFunction();
    }


    ///--------------------------------------------------------
    /// Commit to buying tokens!
    ///--------------------------------------------------------

    receive() external payable {
        revertBecauseUserDidNotProvideAgreement();
    }

    /** 
     * @dev Attribution to the awesome delta.financial contracts
    */  
    function marketParticipationAgreement() public pure returns (string memory) {
        return ""I understand that I'm interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings"";
    }
    /** 
     * @dev Not using modifiers is a purposeful choice for code readability.
    */ 
    function revertBecauseUserDidNotProvideAgreement() internal pure {
        revert(""No agreement provided, please review the smart contract before interacting with it"");
    }

    /**
     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.
     * @param _beneficiary Auction participant ETH address.
     */
    function commitEth(
        address payable _beneficiary,
        bool readAndAgreedToMarketParticipationAgreement
    )
        public payable
    {
        require(paymentCurrency == ETH_ADDRESS, ""DutchAuction: payment currency is not ETH address""); 
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        // Get ETH able to be committed
        uint256 ethToTransfer = calculateCommitment(msg.value);

        /// @notice Accept ETH Payments.
        uint256 ethToRefund = msg.value.sub(ethToTransfer);
        if (ethToTransfer > 0) {
            _addCommitment(_beneficiary, ethToTransfer);
        }
        /// @notice Return any ETH to be refunded.
        if (ethToRefund > 0) {
            _beneficiary.transfer(ethToRefund);
        }

        /// @notice Revert if commitmentsTotal exceeds the balance
        require(marketStatus.commitmentsTotal <= address(this).balance, ""DutchAuction: The committed ETH exceeds the balance"");
    }

    /**
     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.
     * @param _amount Amount of tokens to commit.
     */
    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {
        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);
    }


    /**
     * @notice Checks how much is user able to commit and processes that commitment.
     * @dev Users must approve contract prior to committing tokens to auction.
     * @param _from User ERC20 address.
     * @param _amount Amount of approved ERC20 tokens.
     */
    function commitTokensFrom(
        address _from,
        uint256 _amount,
        bool readAndAgreedToMarketParticipationAgreement
    )
        public   nonReentrant  
    {
        require(address(paymentCurrency) != ETH_ADDRESS, ""DutchAuction: Payment currency is not a token"");
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        uint256 tokensToTransfer = calculateCommitment(_amount);
        if (tokensToTransfer > 0) {
            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);
            _addCommitment(_from, tokensToTransfer);
        }
    }

    /**
     * @notice Calculates the pricedrop factor.
     * @return Value calculated from auction start and end price difference divided the auction duration.
     */
    function priceDrop() public view returns (uint256) {
        MarketInfo memory _marketInfo = marketInfo;
        MarketPrice memory _marketPrice = marketPrice;

        uint256 numerator = uint256(_marketPrice.startPrice.sub(_marketPrice.minimumPrice));
        uint256 denominator = uint256(_marketInfo.endTime.sub(_marketInfo.startTime));
        return numerator / denominator;
    }


   /**
     * @notice How many tokens the user is able to claim.
     * @param _user Auction participant address.
     * @return claimerCommitment User commitments reduced by already claimed tokens.
     */
    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {
        if (commitments[_user] == 0) return 0;
        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));

        claimerCommitment = commitments[_user].mul(uint256(marketInfo.totalTokens)).div(uint256(marketStatus.commitmentsTotal));
        claimerCommitment = claimerCommitment.sub(claimed[_user]);

        if(claimerCommitment > unclaimedTokens){
            claimerCommitment = unclaimedTokens;
        }
    }

    /**
     * @notice Calculates total amount of tokens committed at current auction price.
     * @return Number of tokens commited.
     */
    function totalTokensCommitted() public view returns (uint256) {
        return uint256(marketStatus.commitmentsTotal).mul(1e18).div(clearingPrice());
    }

    /**
     * @notice Calculates the amout able to be committed during an auction.
     * @param _commitment Commitment user would like to make.
     * @return committed Amount allowed to commit.
     */
    function calculateCommitment(uint256 _commitment) public view returns (uint256 committed) {
        uint256 maxCommitment = uint256(marketInfo.totalTokens).mul(clearingPrice()).div(1e18);
        if (uint256(marketStatus.commitmentsTotal).add(_commitment) > maxCommitment) {
            return maxCommitment.sub(uint256(marketStatus.commitmentsTotal));
        }
        return _commitment;
    }

    /**
     * @notice Checks if the auction is open.
     * @return True if current time is greater than startTime and less than endTime.
     */
    function isOpen() public view returns (bool) {
        return block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime);
    }

    /**
     * @notice Successful if tokens sold equals totalTokens.
     * @return True if tokenPrice is bigger or equal clearingPrice.
     */
    function auctionSuccessful() public view returns (bool) {
        return tokenPrice() >= clearingPrice();
    }

    /**
     * @notice Checks if the auction has ended.
     * @return True if auction is successful or time has ended.
     */
    function auctionEnded() public view returns (bool) {
        return auctionSuccessful() || block.timestamp > uint256(marketInfo.endTime);
    }

    /**
     * @return Returns true if market has been finalized
     */
    function finalized() public view returns (bool) {
        return marketStatus.finalized;
    }

    /**
     * @return Returns true if 7 days have passed since the end of the auction
     */
    function finalizeTimeExpired() public view returns (bool) {
        return uint256(marketInfo.endTime) + 7 days < block.timestamp;
    }

    /**
     * @notice Calculates price during the auction.
     * @return Current auction price.
     */
    function _currentPrice() private view returns (uint256) {
        uint256 priceDiff = block.timestamp.sub(uint256(marketInfo.startTime)).mul(priceDrop());
        return uint256(marketPrice.startPrice).sub(priceDiff);
    }

    /**
     * @notice Updates commitment for this address and total commitment of the auction.
     * @param _addr Bidders address.
     * @param _commitment The amount to commit.
     */
    function _addCommitment(address _addr, uint256 _commitment) internal {
        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), ""DutchAuction: outside auction hours"");
        MarketStatus storage status = marketStatus;
        
        uint256 newCommitment = commitments[_addr].add(_commitment);
        if (status.usePointList) {
            require(IPointList(pointList).hasPoints(_addr, newCommitment));
        }
        
        commitments[_addr] = newCommitment;
        status.commitmentsTotal = BoringMath.to128(uint256(status.commitmentsTotal).add(_commitment));
        emit AddedCommitment(_addr, _commitment);
    }


    //--------------------------------------------------------
    // Finalize Auction
    //--------------------------------------------------------


    /**
     * @notice Cancel Auction
     * @dev Admin can cancel the auction before it starts
     */
    function cancelAuction() public   nonReentrant  
    {
        require(hasAdminRole(msg.sender));
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""DutchAuction: auction already finalized"");
        require( uint256(status.commitmentsTotal) == 0, ""DutchAuction: auction already committed"" );
        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));
        status.finalized = true;
        emit AuctionCancelled();
    }

    /**
     * @notice Auction finishes successfully above the reserve.
     * @dev Transfer contract funds to initialized wallet.
     */
    function finalize() public   nonReentrant  
    {

        require(hasAdminRole(msg.sender) 
                || hasSmartContractRole(msg.sender) 
                || wallet == msg.sender
                || finalizeTimeExpired(), ""DutchAuction: sender must be an admin"");
        MarketStatus storage status = marketStatus;

        require(!status.finalized, ""DutchAuction: auction already finalized"");
        if (auctionSuccessful()) {
            /// @dev Successful auction
            /// @dev Transfer contributed tokens to wallet.
            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));
        } else {
            /// @dev Failed auction
            /// @dev Return auction tokens back to wallet.
            require(block.timestamp > uint256(marketInfo.endTime), ""DutchAuction: auction has not finished yet""); 
            _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));
        }
        status.finalized = true;
        emit AuctionFinalized();
    }


    /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.
    function withdrawTokens() public  {
        withdrawTokens(msg.sender);
    }

   /**
     * @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.
     * @dev Withdraw tokens only after auction ends.
     * @param beneficiary Whose tokens will be withdrawn.
     */
    function withdrawTokens(address payable beneficiary) public   nonReentrant  {
        if (auctionSuccessful()) {
            require(marketStatus.finalized, ""DutchAuction: not finalized"");
            /// @dev Successful auction! Transfer claimed tokens.
            uint256 tokensToClaim = tokensClaimable(beneficiary);
            require(tokensToClaim > 0, ""DutchAuction: No tokens to claim""); 
            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);
            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);
        } else {
            /// @dev Auction did not meet reserve price.
            /// @dev Return committed funds back to user.
            require(block.timestamp > uint256(marketInfo.endTime), ""DutchAuction: auction has not finished yet"");
            uint256 fundsCommitted = commitments[beneficiary];
            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas
            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);
        }
    }


    //--------------------------------------------------------
    // Documents
    //--------------------------------------------------------

    function setDocument(string calldata _name, string calldata _data) external {
        require(hasAdminRole(msg.sender) );
        _setDocument( _name, _data);
    }

    function setDocuments(string[] calldata _name, string[] calldata _data) external {
        require(hasAdminRole(msg.sender) );
        uint256 numDocs = _name.length;
        for (uint256 i = 0; i < numDocs; i++) {
            _setDocument( _name[i], _data[i]);
        }
    }

    function removeDocument(string calldata _name) external {
        require(hasAdminRole(msg.sender));
        _removeDocument(_name);
    }


    //--------------------------------------------------------
    // Point Lists
    //--------------------------------------------------------


    function setList(address _list) external {
        require(hasAdminRole(msg.sender));
        _setList(_list);
    }

    function enableList(bool _status) external {
        require(hasAdminRole(msg.sender));
        marketStatus.usePointList = _status;
    }

    function _setList(address _pointList) private {
        if (_pointList != address(0)) {
            pointList = _pointList;
            marketStatus.usePointList = true;
        }
    }

    //--------------------------------------------------------
    // Setter Functions
    //--------------------------------------------------------

    /**
     * @notice Admin can set start and end time through this function.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     */
    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {
        require(hasAdminRole(msg.sender));
        require(_startTime < 10000000000, ""DutchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""DutchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""DutchAuction: start time is before current time"");
        require(_endTime > _startTime, ""DutchAuction: end time must be older than start time"");
        require(marketStatus.commitmentsTotal == 0, ""DutchAuction: auction cannot have already started"");

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        
        emit AuctionTimeUpdated(_startTime,_endTime);
    }

    /**
     * @notice Admin can set start and min price through this function.
     * @param _startPrice Auction start price.
     * @param _minimumPrice Auction minimum price.
     */
    function setAuctionPrice(uint256 _startPrice, uint256 _minimumPrice) external {
        require(hasAdminRole(msg.sender));
        require(_startPrice > _minimumPrice, ""DutchAuction: start price must be higher than minimum price"");
        require(_minimumPrice > 0, ""DutchAuction: minimum price must be greater than 0""); 
        require(marketStatus.commitmentsTotal == 0, ""DutchAuction: auction cannot have already started"");

        marketPrice.startPrice = BoringMath.to128(_startPrice);
        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);

        emit AuctionPriceUpdated(_startPrice,_minimumPrice);
    }

    /**
     * @notice Admin can set the auction wallet through this function.
     * @param _wallet Auction wallet is where funds will be sent.
     */
    function setAuctionWallet(address payable _wallet) external {
        require(hasAdminRole(msg.sender));
        require(_wallet != address(0), ""DutchAuction: wallet is the zero address"");

        wallet = _wallet;

        emit AuctionWalletUpdated(_wallet);
    }


   //--------------------------------------------------------
    // Market Launchers
    //--------------------------------------------------------

    /**
     * @notice Decodes and hands auction data to the initAuction function.
     * @param _data Encoded data for initialization.
     */

    function init(bytes calldata _data) external override payable {

    }

    function initMarket(
        bytes calldata _data
    ) public override {
        (
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _startPrice,
        uint256 _minimumPrice,
        address _admin,
        address _pointList,
        address payable _wallet
        ) = abi.decode(_data, (
            address,
            address,
            uint256,
            uint256,
            uint256,
            address,
            uint256,
            uint256,
            address,
            address,
            address
        ));
        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _startPrice, _minimumPrice, _admin, _pointList, _wallet);
    }

    /**
     * @notice Collects data to initialize the auction and encodes them.
     * @param _funder The address that funds the token for crowdsale.
     * @param _token Address of the token being sold.
     * @param _totalTokens The total number of tokens to sell in auction.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.
     * @param _startPrice Starting price of the auction.
     * @param _minimumPrice The minimum auction price.
     * @param _admin Address that can finalize auction.
     * @param _pointList Address that will manage auction approvals.
     * @param _wallet Address where collected funds will be forwarded to.
     * @return _data All the data in bytes format.
     */
    function getAuctionInitData(
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _startPrice,
        uint256 _minimumPrice,
        address _admin,
        address _pointList,
        address payable _wallet
    )
        external 
        pure
        returns (bytes memory _data)
    {
            return abi.encode(
                _funder,
                _token,
                _totalTokens,
                _startTime,
                _endTime,
                _paymentCurrency,
                _startPrice,
                _minimumPrice,
                _admin,
                _pointList,
                _wallet
            );
    }
        
    function getBaseInformation() external view returns(
        address, 
        uint64,
        uint64,
        bool 
    ) {
        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);
    }

    function getTotalTokens() external view returns(uint256) {
        return uint256(marketInfo.totalTokens);
    }

}",5994
RealWorld_TA_28_IWETH9_RealWorld_20240803193439.log,28,IWETH9,22674,1497,24171,80.0,0.14331,"pragma solidity 0.6.12;

import ""./IERC20.sol"";

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint) external;
    function transfer(address, uint) external returns (bool);

}",51
RealWorld_TA_28_MintableToken_RealWorld_20240803184648.log,28,MintableToken,90158,2687,92845,98.0,0.50453,"pragma solidity 0.6.12;

import ""../OpenZeppelin/access/AccessControl.sol"";
import ""./ERC20/ERC20Burnable.sol"";
import ""./ERC20/ERC20Pausable.sol"";
import ""../interfaces/IMisoToken.sol"";

// ---------------------------------------------------------------------
//
// From the MISO Token Factory
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

contract MintableToken is AccessControl, ERC20Burnable, ERC20Pausable, IMisoToken {
    
    /// @notice Miso template id for the token factory.
    /// @dev For different token types, this must be incremented.
    uint256 public constant override tokenTemplate = 2;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant PAUSER_ROLE = keccak256(""PAUSER_ROLE"");

    function initToken(string memory _name, string memory _symbol, address _owner, uint256 _initialSupply) public {
        _initERC20(_name, _symbol);
        _setupRole(DEFAULT_ADMIN_ROLE, _owner);
        _setupRole(MINTER_ROLE, _owner);
        _setupRole(PAUSER_ROLE, _owner);
        _mint(msg.sender, _initialSupply);
    }

    function init(bytes calldata _data) external override payable {}

   function initToken(
        bytes calldata _data
    ) public override {
        (string memory _name,
        string memory _symbol,
        address _owner,
        uint256 _initialSupply) = abi.decode(_data, (string, string, address, uint256));

        initToken(_name,_symbol,_owner,_initialSupply);
    }

   /** 
     * @dev Generates init data for Token Factory
     * @param _name - Token name
     * @param _symbol - Token symbol
     * @param _owner - Contract owner
     * @param _initialSupply Amount of tokens minted on creation
  */
    function getInitData(
        string calldata _name,
        string calldata _symbol,
        address _owner,
        uint256 _initialSupply
    )
        external
        pure
        returns (bytes memory _data)
    {
        return abi.encode(_name, _symbol, _owner, _initialSupply);
    }



    /**
     * @dev Creates `amount` new tokens for `to`.
     *
     * See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, uint256 amount) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), ""MintableToken: must have minter role to mint"");
        _mint(to, amount);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC20Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""MintableToken: must have pauser role to pause"");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC20Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), ""MintableToken: must have pauser role to unpause"");
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {
        super._beforeTokenTransfer(from, to, amount);
    }
}",854
RealWorld_TA_28_IMisoCrowdsale_RealWorld_20240803194020.log,28,IMisoCrowdsale,26131,1796,27927,86.0,0.166575,"pragma solidity 0.6.12;

interface IMisoCrowdsale {
    function initCrowdsale(
        address _funder,
        address _token,
        address _paymentCurrency,
        uint256 _tokenSupply,
        uint256 _startDate,
        uint256 _endDate,
        uint256 _rate,
        uint256 _goal,
        address _operator,
        address payable _wallet
    ) external;
}",87
RealWorld_TA_28_BoringMath_RealWorld_20240803175821.log,28,BoringMath,89314,1382,90696,81.0,0.47421,"pragma solidity 0.6.12;

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b > 0, ""BoringMath: Div zero"");
        c = a / b;
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }

    function to16(uint256 a) internal pure returns (uint16 c) {
        require(a <= uint16(-1), ""BoringMath: uint16 Overflow"");
        c = uint16(a);
    }

}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath16 {
    function add(uint16 a, uint16 b) internal pure returns (uint16 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint16 a, uint16 b) internal pure returns (uint16 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}",847
RealWorld_TA_28_Owned_RealWorld_20240803175650.log,28,Owned,38605,2578,41183,89.0,0.244585,"pragma solidity 0.6.12;


// import ""../../interfaces/IERC20.sol"";


contract Owned {

    address private mOwner;   
    bool private initialised;    
    address public newOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    function _initOwned(address _owner) internal {
        require(!initialised);
        mOwner = address(uint160(_owner));
        initialised = true;
        emit OwnershipTransferred(address(0), mOwner);
    }

    function owner() public view returns (address) {
        return mOwner;
    }
    function isOwner() public view returns (bool) {
        return msg.sender == mOwner;
    }

    function transferOwnership(address _newOwner) public {
        require(isOwner());
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(mOwner, newOwner);
        mOwner = address(uint160(newOwner));
        newOwner = address(0);
    }
}",231
RealWorld_TA_28_TimelockController_RealWorld_20240803185555.log,28,TimelockController,234784,3777,238561,128.0,1.24946,"pragma solidity >=0.6.9 <0.8.0;
pragma experimental ABIEncoderV2;

import ""./../math/SafeMath.sol"";
import ""./AccessControl.sol"";

/**
 * @dev Contract module which acts as a timelocked controller. When set as the
 * owner of an `Ownable` smart contract, it enforces a timelock on all
 * `onlyOwner` maintenance operations. This gives time for users of the
 * controlled contract to exit before a potentially dangerous maintenance
 * operation is applied.
 *
 * By default, this contract is self administered, meaning administration tasks
 * have to go through the timelock process. The proposer (resp executor) role
 * is in charge of proposing (resp executing) operations. A common use case is
 * to position this {TimelockController} as the owner of a smart contract, with
 * a multisig or a DAO as the sole proposer.
 *
 * _Available since v3.3._
 */
contract TimelockController is AccessControl {

    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(""TIMELOCK_ADMIN_ROLE"");
    bytes32 public constant PROPOSER_ROLE = keccak256(""PROPOSER_ROLE"");
    bytes32 public constant EXECUTOR_ROLE = keccak256(""EXECUTOR_ROLE"");
    uint256 internal constant _DONE_TIMESTAMP = uint256(1);

    mapping(bytes32 => uint256) private _timestamps;
    uint256 private _minDelay;

    /**
     * @dev Emitted when a call is scheduled as part of operation `id`.
     */
    event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay);

    /**
     * @dev Emitted when a call is performed as part of operation `id`.
     */
    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);

    /**
     * @dev Emitted when operation `id` is cancelled.
     */
    event Cancelled(bytes32 indexed id);

    /**
     * @dev Emitted when the minimum delay for future operations is modified.
     */
    event MinDelayChange(uint256 oldDuration, uint256 newDuration);

    /**
     * @dev Initializes the contract with a given `minDelay`.
     */
    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors) public {
        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);
        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);
        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);

        // deployer + self administration
        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());
        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));

        // register proposers
        for (uint256 i = 0; i < proposers.length; ++i) {
            _setupRole(PROPOSER_ROLE, proposers[i]);
        }

        // register executors
        for (uint256 i = 0; i < executors.length; ++i) {
            _setupRole(EXECUTOR_ROLE, executors[i]);
        }

        _minDelay = minDelay;
        emit MinDelayChange(0, minDelay);
    }

    /**
     * @dev Modifier to make a function callable only by a certain role. In
     * addition to checking the sender's role, `address(0)` 's role is also
     * considered. Granting a role to `address(0)` is equivalent to enabling
     * this role for everyone.
     */
    modifier onlyRole(bytes32 role) {
        require(hasRole(role, _msgSender()) || hasRole(role, address(0)), ""TimelockController: sender requires permission"");
        _;
    }

    /**
     * @dev Contract might receive/hold ETH as part of the maintenance process.
     */
    receive() external payable {}

    /**
     * @dev Returns whether an id correspond to a registered operation. This
     * includes both Pending, Ready and Done operations.
     */
    function isOperation(bytes32 id) public view virtual returns (bool pending) {
        return getTimestamp(id) > 0;
    }

    /**
     * @dev Returns whether an operation is pending or not.
     */
    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {
        return getTimestamp(id) > _DONE_TIMESTAMP;
    }

    /**
     * @dev Returns whether an operation is ready or not.
     */
    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {
        uint256 timestamp = getTimestamp(id);
        // solhint-disable-next-line not-rely-on-time
        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;
    }

    /**
     * @dev Returns whether an operation is done or not.
     */
    function isOperationDone(bytes32 id) public view virtual returns (bool done) {
        return getTimestamp(id) == _DONE_TIMESTAMP;
    }

    /**
     * @dev Returns the timestamp at with an operation becomes ready (0 for
     * unset operations, 1 for done operations).
     */
    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {
        return _timestamps[id];
    }

    /**
     * @dev Returns the minimum delay for an operation to become valid.
     *
     * This value can be changed by executing an operation that calls `updateDelay`.
     */
    function getMinDelay() public view virtual returns (uint256 duration) {
        return _minDelay;
    }

    /**
     * @dev Returns the identifier of an operation containing a single
     * transaction.
     */
    function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {
        return keccak256(abi.encode(target, value, data, predecessor, salt));
    }

    /**
     * @dev Returns the identifier of an operation containing a batch of
     * transactions.
     */
    function hashOperationBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {
        return keccak256(abi.encode(targets, values, datas, predecessor, salt));
    }

    /**
     * @dev Schedule an operation containing a single transaction.
     *
     * Emits a {CallScheduled} event.
     *
     * Requirements:
     *
     * - the caller must have the 'proposer' role.
     */
    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _schedule(id, delay);
        emit CallScheduled(id, 0, target, value, data, predecessor, delay);
    }

    /**
     * @dev Schedule an operation containing a batch of transactions.
     *
     * Emits one {CallScheduled} event per transaction in the batch.
     *
     * Requirements:
     *
     * - the caller must have the 'proposer' role.
     */
    function scheduleBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {
        require(targets.length == values.length, ""TimelockController: length mismatch"");
        require(targets.length == datas.length, ""TimelockController: length mismatch"");

        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);
        _schedule(id, delay);
        for (uint256 i = 0; i < targets.length; ++i) {
            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);
        }
    }

    /**
     * @dev Schedule an operation that is to becomes valid after a given delay.
     */
    function _schedule(bytes32 id, uint256 delay) private {
        require(!isOperation(id), ""TimelockController: operation already scheduled"");
        require(delay >= getMinDelay(), ""TimelockController: insufficient delay"");
        // solhint-disable-next-line not-rely-on-time
        _timestamps[id] = SafeMath.add(block.timestamp, delay);
    }

    /**
     * @dev Cancel an operation.
     *
     * Requirements:
     *
     * - the caller must have the 'proposer' role.
     */
    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {
        require(isOperationPending(id), ""TimelockController: operation cannot be cancelled"");
        delete _timestamps[id];

        emit Cancelled(id);
    }

    /**
     * @dev Execute an (ready) operation containing a single transaction.
     *
     * Emits a {CallExecuted} event.
     *
     * Requirements:
     *
     * - the caller must have the 'executor' role.
     */
    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {
        bytes32 id = hashOperation(target, value, data, predecessor, salt);
        _beforeCall(predecessor);
        _call(id, 0, target, value, data);
        _afterCall(id);
    }

    /**
     * @dev Execute an (ready) operation containing a batch of transactions.
     *
     * Emits one {CallExecuted} event per transaction in the batch.
     *
     * Requirements:
     *
     * - the caller must have the 'executor' role.
     */
    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {
        require(targets.length == values.length, ""TimelockController: length mismatch"");
        require(targets.length == datas.length, ""TimelockController: length mismatch"");

        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);
        _beforeCall(predecessor);
        for (uint256 i = 0; i < targets.length; ++i) {
            _call(id, i, targets[i], values[i], datas[i]);
        }
        _afterCall(id);
    }

    /**
     * @dev Checks before execution of an operation's calls.
     */
    function _beforeCall(bytes32 predecessor) private view {
        require(predecessor == bytes32(0) || isOperationDone(predecessor), ""TimelockController: missing dependency"");
    }

    /**
     * @dev Checks after execution of an operation's calls.
     */
    function _afterCall(bytes32 id) private {
        require(isOperationReady(id), ""TimelockController: operation is not ready"");
        _timestamps[id] = _DONE_TIMESTAMP;
    }

    /**
     * @dev Execute an operation's call.
     *
     * Emits a {CallExecuted} event.
     */
    function _call(bytes32 id, uint256 index, address target, uint256 value, bytes calldata data) private {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success,) = target.call{value: value}(data);
        require(success, ""TimelockController: underlying transaction reverted"");

        emit CallExecuted(id, index, target, value, data);
    }

    /**
     * @dev Changes the minimum timelock duration for future operations.
     *
     * Emits a {MinDelayChange} event.
     *
     * Requirements:
     *
     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing
     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.
     */
    function updateDelay(uint256 newDelay) external virtual {
        require(msg.sender == address(this), ""TimelockController: caller must be timelock"");
        emit MinDelayChange(_minDelay, newDelay);
        _minDelay = newDelay;
    }
}",2576
RealWorld_TA_28_Context_RealWorld_20240803185941.log,28,Context,20334,2520,22854,97.0,0.15207,"pragma solidity 0.6.12;

import ""../utils/Context.sol"";",16
RealWorld_TA_28_SafeMath_RealWorld_20240803191607.log,28,SafeMath,161444,1291,162735,88.0,0.83304,"pragma solidity 0.6.12;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b > a) return (false, 0);
        return (true, a - b);
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, ""SafeMath: subtraction overflow"");
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: division by zero"");
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""SafeMath: modulo by zero"");
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        return a - b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryDiv}.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        return a % b;
    }
}",1719
RealWorld_TA_28_MISOMarket_RealWorld_20240803171108.log,28,MISOMarket,292670,5639,298309,164.0,1.57613,"pragma solidity 0.6.12;

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's MISO Marketplace
//
// A factory to conveniently deploy your own source code verified auctions
//
// Inspired by Bokky's EtherVendingMachince.io
// https://github.com/bokkypoobah/FixedSupplyTokenFactory
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""./Access/MISOAccessControls.sol"";
import ""./Utils/BoringMath.sol"";
import ""./Utils/SafeTransfer.sol"";
import ""./interfaces/IMisoMarket.sol"";
import ""./interfaces/IERC20.sol"";
import ""./interfaces/IBentoBoxFactory.sol"";


contract MISOMarket is SafeTransfer {

    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;

    /// @notice Responsible for access rights to the contract.
    MISOAccessControls public accessControls;
    bytes32 public constant MARKET_MINTER_ROLE = keccak256(""MARKET_MINTER_ROLE"");

    /// @notice Whether market has been initialized or not.
    bool private initialised;

    /// @notice Struct to track Auction template.
    struct Auction {
        bool exists;
        uint64 templateId;
        uint128 index;
    }

    /// @notice Auctions created using factory.
    address[] public auctions;

    /// @notice Template id to track respective auction template.
    uint256 public auctionTemplateId;

    IBentoBoxFactory public bentoBox;

    /// @notice Mapping from market template id to market template address.
    mapping(uint256 => address) private auctionTemplates;

    /// @notice Mapping from market template address to market template id.
    mapping(address => uint256) private auctionTemplateToId;

    // /// @notice mapping from template type to template id
    mapping(uint256 => uint256) public currentTemplateId;

    /// @notice Mapping from auction created through this contract to Auction struct.
    mapping(address => Auction) public auctionInfo;

    /// @notice Struct to define fees.
    struct MarketFees {
        uint128 minimumFee;
        uint32 integratorFeePct;
    }

    /// @notice Minimum fee to create a farm through the factory.
    MarketFees public marketFees;

    /// @notice Contract locked status. If locked, only minters can deploy
    bool public locked;

    ///@notice Any donations if set are sent here.
    address payable public misoDiv;

    ///@notice Event emitted when first initializing the Market factory.
    event MisoInitMarket(address sender);

    /// @notice Event emitted when template is added to factory.
    event AuctionTemplateAdded(address newAuction, uint256 templateId);

    /// @notice Event emitted when auction template is removed.
    event AuctionTemplateRemoved(address auction, uint256 templateId);

    /// @notice Event emitted when auction is created using template id.
    event MarketCreated(address indexed owner, address indexed addr, address marketTemplate);

    constructor() public {
    }

    /**
     * @notice Initializes the market with a list of auction templates.
     * @dev Can only be initialized once.
     * @param _accessControls Sets address to get the access controls from.
     * @param _templates Initial array of MISOMarket templates.
     */
    function initMISOMarket(address _accessControls, address _bentoBox, address[] memory _templates) external {
        require(!initialised);
        require(_accessControls != address(0), ""initMISOMarket: accessControls cannot be set to zero"");
        require(_bentoBox != address(0), ""initMISOMarket: bentoBox cannot be set to zero"");

        accessControls = MISOAccessControls(_accessControls);
        bentoBox = IBentoBoxFactory(_bentoBox);

        auctionTemplateId = 0;
        for(uint i = 0; i < _templates.length; i++) {
            _addAuctionTemplate(_templates[i]);
        }
        locked = true;
        initialised = true;
        emit MisoInitMarket(msg.sender);
    }

    /**
     * @notice Sets the minimum fee.
     * @param _amount Fee amount.
     */
    function setMinimumFee(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOMarket: Sender must be operator""
        );
        marketFees.minimumFee = BoringMath.to128(_amount);
    }

    /**
     * @notice Sets the factory to be locked or unlocked.
     * @param _locked bool.
     */
    function setLocked(bool _locked) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOMarket: Sender must be admin""
        );
        locked = _locked;
    }


    /**
     * @notice Sets integrator fee percentage.
     * @param _amount Percentage amount.
     */
    function setIntegratorFeePct(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOMarket: Sender must be operator""
        );
        /// @dev this is out of 1000, ie 25% = 250
        require(_amount <= 1000, ""MISOMarket: Percentage is out of 1000"");
        marketFees.integratorFeePct = BoringMath.to32(_amount);
    }

    /**
     * @notice Sets dividend address.
     * @param _divaddr Dividend address.
     */
    function setDividends(address payable _divaddr) external {
        require(accessControls.hasAdminRole(msg.sender), ""MISOMarket.setDev: Sender must be operator"");
        require(_divaddr != address(0));
        misoDiv = _divaddr;
    }

    /**
     * @notice Sets the current template ID for any type.
     * @param _templateType Type of template.
     * @param _templateId The ID of the current template for that type
     */
    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOMarket: Sender must be admin""
        );
        require(auctionTemplates[_templateId] != address(0), ""MISOMarket: incorrect _templateId"");
        require(IMisoMarket(auctionTemplates[_templateId]).marketTemplate() == _templateType, ""MISOMarket: incorrect _templateType"");
        currentTemplateId[_templateType] = _templateId;
    }


    /**
     * @notice Used to check whether an address has the minter role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasMarketMinterRole(address _address) public view returns (bool) {
        return accessControls.hasRole(MARKET_MINTER_ROLE, _address);
    }


    /**
     * @notice Creates a new MISOMarket from template _templateId and transfers fees.
     * @param _templateId Id of the crowdsale template to create.
     * @param _integratorFeeAccount Address to pay the fee to.
     * @return newMarket Market address.
     */
    function deployMarket(
        uint256 _templateId,
        address payable _integratorFeeAccount
    )
        public payable returns (address newMarket)
    {
        /// @dev If the contract is locked, only admin and minters can deploy. 
        if (locked) {
            require(accessControls.hasAdminRole(msg.sender) 
                    || accessControls.hasMinterRole(msg.sender)
                    || hasMarketMinterRole(msg.sender),
                ""MISOMarket: Sender must be minter if locked""
            );
        }

        MarketFees memory _marketFees = marketFees;
        address auctionTemplate = auctionTemplates[_templateId];
        require(msg.value >= uint256(_marketFees.minimumFee), ""MISOMarket: Failed to transfer minimumFee"");
        require(auctionTemplate != address(0), ""MISOMarket: Auction template doesn't exist"");
        uint256 integratorFee = 0;
        uint256 misoFee = msg.value;
        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {
            integratorFee = misoFee * uint256(_marketFees.integratorFeePct) / 1000;
            misoFee = misoFee - integratorFee;
        }

        /// @dev Deploy using the BentoBox factory. 
        newMarket = bentoBox.deploy(auctionTemplate, """", false);
        auctionInfo[newMarket] = Auction(true, BoringMath.to64(_templateId), BoringMath.to128(auctions.length));
        auctions.push(newMarket);
        emit MarketCreated(msg.sender, newMarket, auctionTemplate);
        if (misoFee > 0) {
            misoDiv.transfer(misoFee);
        }
        if (integratorFee > 0) {
            _integratorFeeAccount.transfer(integratorFee);
        }
    }

    /**
     * @notice Creates a new MISOMarket using _templateId.
     * @dev Initializes auction with the parameters passed.
     * @param _templateId Id of the auction template to create.
     * @param _token The token address to be sold.
     * @param _tokenSupply Amount of tokens to be sold at market.
     * @param _integratorFeeAccount Address to send refferal bonus, if set.
     * @param _data Data to be sent to template on Init.
     * @return newMarket Market address.
     */
    function createMarket(
        uint256 _templateId,
        address _token,
        uint256 _tokenSupply,
        address payable _integratorFeeAccount,
        bytes calldata _data
    )
        external payable returns (address newMarket)
    {
        newMarket = deployMarket(_templateId, _integratorFeeAccount);
        if (_tokenSupply > 0) {
            _safeTransferFrom(_token, msg.sender, _tokenSupply);
            require(IERC20(_token).approve(newMarket, _tokenSupply), ""1"");
        }
        IMisoMarket(newMarket).initMarket(_data);

        if (_tokenSupply > 0) {
            uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
            if (remainingBalance > 0) {
                _safeTransfer(_token, msg.sender, remainingBalance);
            }
        }
        return newMarket;
    }

    /**
     * @notice Function to add an auction template to create through factory.
     * @dev Should have operator access.
     * @param _template Auction template to create an auction.
     */
    function addAuctionTemplate(address _template) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOMarket: Sender must be operator""
        );
        _addAuctionTemplate(_template);    
    }

    /**
     * @dev Function to remove an auction template.
     * @dev Should have operator access.
     * @param _templateId Refers to template that is to be deleted.
     */
    function removeAuctionTemplate(uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOMarket: Sender must be operator""
        );
        address template = auctionTemplates[_templateId];
        uint256 templateType = IMisoMarket(template).marketTemplate();
        if (currentTemplateId[templateType] == _templateId) {
            delete currentTemplateId[templateType];
        }   
        auctionTemplates[_templateId] = address(0);
        delete auctionTemplateToId[template];
        emit AuctionTemplateRemoved(template, _templateId);
    }

    /**
     * @notice Function to add an auction template to create through factory.
     * @param _template Auction template address to create an auction.
     */
    function _addAuctionTemplate(address _template) internal {
        require(_template != address(0), ""MISOMarket: Incorrect template"");
        require(auctionTemplateToId[_template] == 0, ""MISOMarket: Template already added"");
        uint256 templateType = IMisoMarket(_template).marketTemplate();
        require(templateType > 0, ""MISOMarket: Incorrect template code "");
        auctionTemplateId++;

        auctionTemplates[auctionTemplateId] = _template;
        auctionTemplateToId[_template] = auctionTemplateId;
        currentTemplateId[templateType] = auctionTemplateId;
        emit AuctionTemplateAdded(_template, auctionTemplateId);
    }

    /**
     * @notice Get the address based on template ID.
     * @param _templateId Auction template ID.
     * @return Address of the required template ID.
     */
    function getAuctionTemplate(uint256 _templateId) external view returns (address) {
        return auctionTemplates[_templateId];
    }

    /**
     * @notice Get the ID based on template address.
     * @param _auctionTemplate Auction template address.
     * @return ID of the required template address.
     */
    function getTemplateId(address _auctionTemplate) external view returns (uint256) {
        return auctionTemplateToId[_auctionTemplate];
    }

    /**
     * @notice Get the total number of auctions in the factory.
     * @return Auction count.
     */
    function numberOfAuctions() external view returns (uint) {
        return auctions.length;
    }

    function minimumFee() external view returns(uint128) {
        return marketFees.minimumFee;
    }

    function getMarkets() external view returns(address[] memory) {
        return auctions;
    }

    function getMarketTemplateId(address _auction) external view returns(uint64) {
        return auctionInfo[_auction].templateId;
    }
}",3304
RealWorld_TA_28_Counters_RealWorld_20240803190407.log,28,Counters,47182,1201,48383,93.0,0.25993,"pragma solidity 0.6.12;

import ""../math/SafeMath.sol"";

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}
 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never
 * directly accessed.
 */
library Counters {
    using SafeMath for uint256;

    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        // The {SafeMath} overflow check can be skipped here, see the comment at the top
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}",343
RealWorld_TA_28_IBentoBoxFactory_RealWorld_20240803193314.log,28,IBentoBoxFactory,27101,2107,29208,83.0,0.177645,"pragma solidity 0.6.12;

interface IBentoBoxFactory {
    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable returns (address cloneAddress) ;
    function masterContractApproved(address, address) external view returns (bool);
    function masterContractOf(address) external view returns (address);
    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;
}",100
RealWorld_TA_28_IMisoTemplate_RealWorld_20240803193154.log,28,IMisoTemplate,20877,1361,22238,78.0,0.131605,"pragma solidity 0.6.12;

interface IMisoTemplate {
    function initData(
        bytes calldata data
    ) external;
}",29
RealWorld_TA_28_ERC20_RealWorld_20240803184026.log,28,ERC20,272350,3266,275616,124.0,1.42707,"pragma solidity 0.6.12;

import ""../OpenZeppelin/GSN/Context.sol"";
import ""../OpenZeppelin/math/SafeMath.sol"";
import ""../interfaces/IERC20.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */

contract ERC20 is IERC20, Context {
    using SafeMath for uint256;
    bytes32 public DOMAIN_SEPARATOR;

    mapping (address => uint256) private _balances;
    mapping(address => uint256) public nonces;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;
    bool private _initialized;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */
    function _initERC20(string memory name_, string memory symbol_) internal {
        require(!_initialized, ""ERC20: token has already been initialized!"");
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(abi.encode(keccak256(""EIP712Domain(uint256 chainId,address verifyingContract)""), chainId, address(this)));
 
        _initialized = true;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

  // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""ERC20: Owner cannot be 0"");
        require(block.timestamp < deadline, ""ERC20: Expired"");
        bytes32 digest =
            keccak256(
                abi.encodePacked(
                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                    DOMAIN_SEPARATOR,
                    keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))
                )
            );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == owner_, ""ERC20: Invalid Signature"");
        _approve(owner_, spender, value);

    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}",3038
RealWorld_TA_28_Pausable_RealWorld_20240803190241.log,28,Pausable,58880,1479,60359,84.0,0.32398,"pragma solidity 0.6.12;

import ""./Context.sol"";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor () internal {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!paused(), ""Pausable: paused"");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(paused(), ""Pausable: not paused"");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}",482
RealWorld_TA_28_IRewarder_RealWorld_20240803193851.log,28,IRewarder,26171,2095,28266,87.0,0.172755,"pragma solidity 0.6.12;

import ""../Utils/BoringERC20.sol"";

interface IRewarder {
    using BoringERC20 for IERC20;
    function onSushiReward (uint256 pid, address user, uint256 sushiAmount) external;
    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external returns (IERC20[] memory , uint256[] memory);
}",86
RealWorld_TA_28_ERC20Pausable_RealWorld_20240803185002.log,28,ERC20Pausable,34124,1742,35866,83.0,0.20546,"pragma solidity ^0.6.0;

import ""../ERC20.sol"";
import ""../../OpenZeppelin/utils/Pausable.sol"";

/**
 * @dev ERC20 token with pausable token transfers, minting and burning.
 *
 * Useful for scenarios such as preventing trades until the end of an evaluation
 * period, or having an emergency switch for freezing all token transfers in the
 * event of a large bug.
 */
abstract contract ERC20Pausable is ERC20, Pausable {
    /**
     * @dev See {ERC20-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        require(!paused(), ""ERC20Pausable: token transfer while paused"");
    }
}",186
RealWorld_TA_28_UniswapV2Factory_RealWorld_20240803171647.log,28,UniswapV2Factory,66797,2239,69036,147.0,0.378765,"pragma solidity =0.6.12;

import './interfaces/IUniswapV2Factory.sol';
import './UniswapV2Pair.sol';

contract UniswapV2Factory is IUniswapV2Factory {
    address public override feeTo;
    address public override feeToSetter;
    address public override migrator;

    mapping(address => mapping(address => address)) public override getPair;
    address[] public override allPairs;

    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    constructor(address _feeToSetter) public {
        feeToSetter = _feeToSetter;
    }

    function allPairsLength() external override view returns (uint) {
        return allPairs.length;
    }

    function pairCodeHash() external override pure returns (bytes32) {
        return keccak256(type(UniswapV2Pair).creationCode);
    }

    function createPair(address tokenA, address tokenB) external override returns (address pair) {
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient
        bytes memory bytecode = type(UniswapV2Pair).creationCode;
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
        UniswapV2Pair(pair).initialize(token0, token1);
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // populate mapping in the reverse direction
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }

    function setFeeTo(address _feeTo) external override {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeTo = _feeTo;
    }

    function setMigrator(address _migrator) external override {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        migrator = _migrator;
    }

    function setFeeToSetter(address _feeToSetter) external override {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeToSetter = _feeToSetter;
    }

}",582
RealWorld_TA_28_Strings_RealWorld_20240803191318.log,28,Strings,38027,1102,39129,77.0,0.212175,"pragma solidity 0.6.12;

/**
 * @dev String operations.
 */
library Strings {
    /**
     * @dev Converts a `uint256` to its ASCII `string` representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }
}",234
RealWorld_TA_28_USDC_RealWorld_20240803184232.log,28,USDC,286944,3701,290645,130.0,1.50874,"pragma solidity 0.6.12;

import ""../OpenZeppelin/GSN/Context.sol"";
import ""../OpenZeppelin/math/SafeMath.sol"";
import ""../OpenZeppelin/utils/Address.sol"";
import ""../interfaces/IERC20.sol"";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin guidelines: functions revert instead
 * of returning `false` on failure. This behavior is nonetheless conventional
 * and does not conflict with the expectations of ERC20 applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */

contract USDC is IERC20, Context {
    using SafeMath for uint256;
    using Address for address;
    bytes32 public DOMAIN_SEPARATOR;

    mapping (address => uint256) private _balances;
    mapping(address => uint256) public nonces;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;
    uint8 private _decimals;
    bool private _initialized;

    /**
     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
     * a default value of 18.
     *
     * To select a different value for {decimals}, use {_setupDecimals}.
     *
     * All three of these values are immutable: they can only be set once during
     * construction.
     */


    /// @dev First set the token variables. This can only be done once
    function initToken(string memory _name, string memory _symbol, address _owner, uint256 _initialSupply) public  {
        _initERC20(_name, _symbol);
        _mint(msg.sender, _initialSupply);
    }
    function init(bytes calldata _data) external  payable {}

   function initToken(
        bytes calldata _data
    ) public  {
        (string memory _name,
        string memory _symbol,
        address _owner,
        uint256 _initialSupply) = abi.decode(_data, (string, string, address, uint256));

        initToken(_name,_symbol,_owner,_initialSupply);
    }


    function _initERC20(string memory name_, string memory symbol_) internal {
        require(!_initialized, ""ERC20: token has already been initialized!"");
        _name = name_;
        _symbol = symbol_;
        _decimals = 6;
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(abi.encode(keccak256(""EIP712Domain(uint256 chainId,address verifyingContract)""), chainId, address(this)));
 
        _initialized = true;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5,05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
     * called.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

  // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""ERC20: Owner cannot be 0"");
        require(block.timestamp < deadline, ""ERC20: Expired"");
        bytes32 digest =
            keccak256(
                abi.encodePacked(
                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                    DOMAIN_SEPARATOR,
                    keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))
                )
            );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == owner_, ""ERC20: Invalid Signature"");
        _approve(owner_, spender, value);

    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Sets {decimals} to a value other than the default one of 18.
     *
     * WARNING: This function should only be called from the constructor. Most
     * applications that interact with token contracts will not expect
     * {decimals} to ever change, and may work incorrectly if it does.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}",3207
RealWorld_TA_28_IMisoToken_RealWorld_20240803195146.log,28,IMisoToken,22500,1575,24075,80.0,0.144,"pragma solidity 0.6.12;

interface IMisoToken {
    function init(bytes calldata data) external payable;
    function initToken( bytes calldata data ) external;
    function tokenTemplate() external view returns (uint256);

}",50
RealWorld_TA_28_ListFactory_RealWorld_20240803174435.log,28,ListFactory,150321,4457,154778,119.0,0.840745,"pragma solidity 0.6.12;

import ""../OpenZeppelin/math/SafeMath.sol"";
import ""../Utils/Owned.sol"";
import ""../Utils/CloneFactory.sol"";
import ""../interfaces/IERC20.sol"";
import ""../interfaces/IPointList.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""./MISOAccessControls.sol"";

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's List Factory
//
// A factory for deploying all sorts of list based contracts
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------


contract ListFactory is CloneFactory, SafeTransfer {
    using SafeMath for uint;

    /// @notice Responsible for access rights to the contract.
    MISOAccessControls public accessControls;

    /// @notice Whether market has been initialized or not.
    bool private initialised;

    /// @notice Address of the point list template.
    address public pointListTemplate;

    /// @notice New point list address.
    address public newAddress;

    /// @notice Minimum fee number.
    uint256 public minimumFee;

    /// @notice Tracks if list is made by the factory.
    mapping(address => bool) public isChild;

    /// @notice An array of list addresses.
    address[] public lists;

    /// @notice Any MISO dividends collected are sent here.
    address payable public misoDiv;

    /// @notice Event emitted when point list is deployed.
    event PointListDeployed(address indexed operator, address indexed addr, address pointList, address owner);

    /// @notice Event emitted when factory is deprecated.
    event FactoryDeprecated(address newAddress);

    /// @notice Event emitted when minimum fee is updated.
    event MinimumFeeUpdated(uint oldFee, uint newFee);

    /// @notice Event emitted when point list factory is initialised.
    event MisoInitListFactory();

    /**
     * @notice Initializes point list factory variables.
     * @param _accessControls Access control contract address.
     * @param _pointListTemplate Point list template address.
     * @param _minimumFee Minimum fee number.
     */
    function initListFactory(address _accessControls, address _pointListTemplate, uint256 _minimumFee) external  {
        require(!initialised);
        require(_accessControls != address(0), ""Incorrect access controls"");
        require(_pointListTemplate != address(0), ""Incorrect list template"");
        accessControls = MISOAccessControls(_accessControls);
        pointListTemplate = _pointListTemplate;
        minimumFee = _minimumFee;
        initialised = true;
        emit MisoInitListFactory();
    }

    /**
     * @notice Gets the number of point lists created by factory.
     * @return uint Number of point lists.
     */
    function numberOfChildren() external view returns (uint) {
        return lists.length;
    }

    /**
     * @notice Deprecates factory.
     * @param _newAddress Blank address.
     */
    function deprecateFactory(address _newAddress) external {
        require(accessControls.hasAdminRole(msg.sender), ""ListFactory: Sender must be admin"");
        require(newAddress == address(0));
        emit FactoryDeprecated(_newAddress);
        newAddress = _newAddress;
    }

    /**
     * @notice Sets minimum fee.
     * @param _minimumFee Minimum fee number.
     */
    function setMinimumFee(uint256 _minimumFee) external {
        require(accessControls.hasAdminRole(msg.sender), ""ListFactory: Sender must be admin"");
        emit MinimumFeeUpdated(minimumFee, _minimumFee);
        minimumFee = _minimumFee;
    }

    /**
     * @notice Sets dividend address.
     * @param _divaddr Dividend address.
     */
    function setDividends(address payable _divaddr) external  {
        require(accessControls.hasAdminRole(msg.sender), ""MISOTokenFactory: Sender must be Admin"");
        misoDiv = _divaddr;
    }

    /**
     * @notice Deploys new point list.
     * @param _listOwner List owner address.
     * @param _accounts An array of account addresses.
     * @param _amounts An array of corresponding point amounts.
     * @return pointList Point list address.
     */
    function deployPointList(
        address _listOwner,
        address[] memory _accounts,
        uint256[] memory _amounts
    )
        external payable returns (address pointList)
    {
        require(msg.value >= minimumFee);
        pointList = createClone(pointListTemplate);
        if (_accounts.length > 0) {
            IPointList(pointList).initPointList(address(this));
            IPointList(pointList).setPoints(_accounts, _amounts);
            MISOAccessControls(pointList).addAdminRole(_listOwner);
            MISOAccessControls(pointList).removeAdminRole(address(this));
        } else {
            IPointList(pointList).initPointList(_listOwner);
        }
        isChild[address(pointList)] = true;
        lists.push(address(pointList));
        emit PointListDeployed(msg.sender, address(pointList), pointListTemplate, _listOwner);
        if (msg.value > 0) {
            misoDiv.transfer(msg.value);
        }
    }

    /**
     * @notice Funtion for transfering any ERC20 token.
     * @param _tokenAddress Address to send from.
     * @param _tokens Number of tokens.
     * @return success True.
     */
    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens) external returns (bool success) {
        require(accessControls.hasAdminRole(msg.sender), ""ListFactory: Sender must be operator"");
        _safeTransfer(_tokenAddress, misoDiv, _tokens);
        return true;
    }

    receive () external payable {
        revert();
    }
}",1581
RealWorld_TA_28_BoringERC20_RealWorld_20240803180142.log,28,BoringERC20,82926,2525,85451,99.0,0.46513,"pragma solidity 0.6.12;
import ""../interfaces/IERC20.sol"";

// solhint-disable avoid-low-level-calls

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.
    /// @param token The address of the ERC-20 token contract.
    /// @return (string) Token symbol.
    function safeSymbol(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));
        return success && data.length > 0 ? abi.decode(data, (string)) : ""???"";
    }

    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.
    /// @param token The address of the ERC-20 token contract.
    /// @return (string) Token name.
    function safeName(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));
        return success && data.length > 0 ? abi.decode(data, (string)) : ""???"";
    }

    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.
    /// @param token The address of the ERC-20 token contract.
    /// @return (uint8) Token decimals.
    function safeDecimals(IERC20 token) internal view returns (uint8) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));
        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
    }

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}",766
RealWorld_TA_28_Address_RealWorld_20240803190842.log,28,Address,166039,1989,168028,97.0,0.869975,"pragma solidity 0.6.12;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1767
RealWorld_TA_28_UniswapV2Library_RealWorld_20240803172052.log,28,UniswapV2Library,114411,2215,116626,95.0,0.616355,"pragma solidity 0.6.12;

import './interfaces/IUniswapV2Pair.sol';

import ""./libraries/SafeMath.sol"";

library UniswapV2Library {
    using SafeMathUniswap for uint;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                pairCodeHash // init code hash
            ))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path, bytes32 pairCodeHash) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path, bytes32 pairCodeHash) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}",1151
RealWorld_TA_28_HyperbolicAuction_RealWorld_20240803181750.log,28,HyperbolicAuction,506949,7852,514801,193.0,2.691785,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

                   
//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's Hyperbolic Auction
////
// A declining price auction with fair price discovery on a hyperbolic curve.
//
// Inspired by DutchSwap's Dutch Auctions
// https://github.com/deepyr/DutchSwap
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi, Kusatoshi, SSMikazu 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------


import ""../OpenZeppelin/utils/ReentrancyGuard.sol"";
import ""../Access/MISOAccessControls.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../Utils/BoringBatchable.sol"";
import ""../Utils/BoringERC20.sol"";
import ""../Utils/BoringMath.sol"";
import ""../Utils/Documents.sol"";
import ""../interfaces/IPointList.sol"";
import ""../interfaces/IMisoMarket.sol"";

/// @notice Attribution to delta.financial
/// @notice Attribution to dutchswap.com

contract HyperbolicAuction is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {
    using BoringERC20 for IERC20;
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;

    // MISOMarket template id.
    /// @dev For different marketplace types, this must be incremented.
    uint256 public constant override marketTemplate = 4;
    /// @dev The placeholder ETH address.
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @notice Main market variables.
    struct MarketInfo {
        uint64 startTime;
        uint64 endTime;
        uint128 totalTokens;
    }
    MarketInfo public marketInfo;

    /// @notice Market price variables.
    struct MarketPrice {
        uint128 minimumPrice;
        uint128 alpha;
        // GP: Can be added later as exponent factor
        // uint16 factor;
    }
    MarketPrice public marketPrice;

    /// @notice Market dynamic variables.
    struct MarketStatus {
        uint128 commitmentsTotal;
        bool finalized;
        bool usePointList;

    }
    MarketStatus public marketStatus;

    /// @notice The token being sold.
    address public auctionToken; 
    /// @notice The currency the auction accepts for payment. Can be ETH or token address.
    address public paymentCurrency;  
    /// @notice Where the auction funds will get paid.
    address payable public wallet;  
    /// @notice Address that manages auction approvals.
    address public pointList;

    /// @notice The commited amount of accounts.
    mapping(address => uint256) public commitments;
    /// @notice Amount of tokens to claim per address.
    mapping(address => uint256) public claimed;

    /// @notice Event for updating auction times.  Needs to be before auction starts.
    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); 
    /// @notice Event for updating auction prices. Needs to be before auction starts.
    event AuctionPriceUpdated( uint256 minimumPrice); 
    /// @notice Event for updating auction wallet. Needs to be before auction starts.
    event AuctionWalletUpdated(address wallet); 

    event AddedCommitment(address addr, uint256 commitment);

    /// @notice Event for finalization of the auction.
    event AuctionFinalized();
    /// @notice Event for cancellation of the auction.
    event AuctionCancelled();

    /**
     * @notice Initializes main contract variables and transfers funds for the auction.
     * @dev Init function
     * @param _funder The address that funds the token for crowdsale
     * @param _token Address of the token being sold
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address
     * @param _totalTokens The total number of tokens to sell in auction
     * @param _startTime Auction start time
     * @param _endTime Auction end time
     * @param _factor Inflection point of the auction
     * @param _minimumPrice The minimum auction price
     * @param _admin Address that can finalize auction.
     * @param _pointList Address that will manage auction approvals.
     * @param _wallet Address where collected funds will be forwarded to
     */
    function initAuction(
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _factor,
        uint256 _minimumPrice,
        address _admin,
        address _pointList,
        address payable _wallet
    ) public {
        require(_startTime < 10000000000, ""HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""HyperbolicAuction: start time is before current time"");
        require(_totalTokens > 0,""HyperbolicAuction: total tokens must be greater than zero"");
        require(_endTime > _startTime, ""HyperbolicAuction: end time must be older than start time"");
        require(_minimumPrice > 0, ""HyperbolicAuction: minimum price must be greater than 0""); 
        require(_wallet != address(0), ""HyperbolicAuction: wallet is the zero address"");
        require(_admin != address(0), ""HyperbolicAuction: admin is the zero address"");
        require(_token != address(0), ""HyperbolicAuction: token is the zero address"");
        require(IERC20(_token).decimals() == 18, ""HyperbolicAuction: Token does not have 18 decimals"");
        if (_paymentCurrency != ETH_ADDRESS) {
            require(IERC20(_paymentCurrency).decimals() > 0, ""HyperbolicAuction: Payment currency is not ERC20"");
        }

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        marketInfo.totalTokens = BoringMath.to128(_totalTokens);

        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);

        auctionToken = _token;
        paymentCurrency = _paymentCurrency;
        wallet = _wallet;

        initAccessControls(_admin);
        
        _setList(_pointList);

         // factor = exponent which can later be used to alter the curve
        uint256 _duration = _endTime - _startTime;
        uint256 _alpha = _duration.mul(_minimumPrice);
        marketPrice.alpha = BoringMath.to128(_alpha);

        _safeTransferFrom(_token, _funder, _totalTokens);
    }


    ///--------------------------------------------------------
    /// Auction Pricing
    ///--------------------------------------------------------

    /**
     * @notice Calculates the average price of each token from all commitments.
     * @return Average token price.
     */
    function tokenPrice() public view returns (uint256) {
        return uint256(marketStatus.commitmentsTotal)
            .mul(1e18).div(uint256(marketInfo.totalTokens));
    }

    /**
     * @notice Returns auction price in any time.
     * @return Fixed start price or minimum price if outside of auction time, otherwise calculated current price.
     */
    function priceFunction() public view returns (uint256) {
        /// @dev Return Auction Price
        if (block.timestamp <= uint256(marketInfo.startTime)) {
            return uint256(-1);
        }
        if (block.timestamp >= uint256(marketInfo.endTime)) {
            return uint256(marketPrice.minimumPrice);
        }
        return _currentPrice();
    }

    /// @notice The current clearing price of the Hyperbolic auction
    function clearingPrice() public view returns (uint256) {
        /// @dev If auction successful, return tokenPrice
        if (tokenPrice() > priceFunction()) {
            return tokenPrice();
        }
        return priceFunction();
    }

    /**
     * @notice Calculates price during the auction.
     * @return Current auction price.
     */
    function _currentPrice() private view returns (uint256) {
        uint256 elapsed = block.timestamp.sub(uint256(marketInfo.startTime));
        uint256 currentPrice = uint256(marketPrice.alpha).div(elapsed);
        return currentPrice;
    }

    ///--------------------------------------------------------
    /// Commit to buying tokens!
    ///--------------------------------------------------------

    /**
     * @notice Buy Tokens by committing ETH to this contract address
     * @dev Needs sufficient gas limit for additional state changes
     */
    receive() external payable {
        revertBecauseUserDidNotProvideAgreement();
    }

    /** 
     * @dev Attribution to the awesome delta.financial contracts
    */  
    function marketParticipationAgreement() public pure returns (string memory) {
        return ""I understand that I'm interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings"";
    }
    /** 
     * @dev Not using modifiers is a purposeful choice for code readability.
    */ 
    function revertBecauseUserDidNotProvideAgreement() internal pure {
        revert(""No agreement provided, please review the smart contract before interacting with it"");
    }

    /**
     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.
     * @param _beneficiary Auction participant ETH address.
     */
    function commitEth(
        address payable _beneficiary,
        bool readAndAgreedToMarketParticipationAgreement
    ) 
        public payable
    {
        require(paymentCurrency == ETH_ADDRESS, ""HyperbolicAuction: payment currency is not ETH address""); 
        // Get ETH able to be committed
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        require(msg.value > 0, ""HyperbolicAuction: Value must be higher than 0"");
        uint256 ethToTransfer = calculateCommitment(msg.value);

        /// @notice Accept ETH Payments.
        uint256 ethToRefund = msg.value.sub(ethToTransfer);
        if (ethToTransfer > 0) {
            _addCommitment(_beneficiary, ethToTransfer);
        }
        /// @notice Return any ETH to be refunded.
        if (ethToRefund > 0) {
            _beneficiary.transfer(ethToRefund);
        }

        /// @notice Revert if commitmentsTotal exceeds the balance
        require(marketStatus.commitmentsTotal <= address(this).balance, ""DutchAuction: The committed ETH exceeds the balance"");
    }

    /**
     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.
     * @param _amount Amount of tokens to commit.
     */
    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {
        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);
    }

    /// @dev Users must approve contract prior to committing tokens to auction
    function commitTokensFrom(
        address _from,
        uint256 _amount,
        bool readAndAgreedToMarketParticipationAgreement
    )
        public   nonReentrant  
    {
        require(paymentCurrency != ETH_ADDRESS, ""HyperbolicAuction: payment currency is not a token"");
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        uint256 tokensToTransfer = calculateCommitment(_amount);
        if (tokensToTransfer > 0) {
            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);
            _addCommitment(_from, tokensToTransfer);
        }
    }

    /**
     * @notice Calculates total amount of tokens committed at current auction price.
     * @return Number of tokens commited.
     */
    function totalTokensCommitted() public view returns (uint256) {
        return uint256(marketStatus.commitmentsTotal).mul(1e18).div(clearingPrice());
    }

    /**
     * @notice Calculates the amout able to be committed during an auction.
     * @param _commitment Commitment user would like to make.
     * @return Amount allowed to commit.
     */
    function calculateCommitment(uint256 _commitment) public view returns (uint256 ) {
        uint256 maxCommitment = uint256(marketInfo.totalTokens).mul(clearingPrice()).div(1e18);
        if (uint256(marketStatus.commitmentsTotal).add(_commitment) > maxCommitment) {
            return maxCommitment.sub(uint256(marketStatus.commitmentsTotal));
        }
        return _commitment;
    }


    /**
     * @notice Updates commitment for this address and total commitment of the auction.
     * @param _addr Bidders address.
     * @param _commitment The amount to commit.
     */
    function _addCommitment(address _addr, uint256 _commitment) internal {
        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), ""HyperbolicAuction: outside auction hours""); 
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""HyperbolicAuction: auction already finalized"");

        uint256 newCommitment = commitments[_addr].add(_commitment);
        if (status.usePointList) {
            require(IPointList(pointList).hasPoints(_addr, newCommitment));
        }

        commitments[_addr] = newCommitment;
        status.commitmentsTotal = BoringMath.to128(uint256(status.commitmentsTotal).add(_commitment));
        emit AddedCommitment(_addr, _commitment);
    }


    ///--------------------------------------------------------
    /// Finalize Auction
    ///--------------------------------------------------------

    /**
     * @notice Successful if tokens sold equals totalTokens.
     * @return True if tokenPrice is bigger or equal clearingPrice.
     */
    function auctionSuccessful() public view returns (bool) {
        return tokenPrice() >= clearingPrice();
    }

    /**
     * @notice Checks if the auction has ended.
     * @return True if auction is successful or time has ended.
     */
    function auctionEnded() public view returns (bool) {
        return auctionSuccessful() || block.timestamp > uint256(marketInfo.endTime);
    }

    /**
     * @return Returns true if market has been finalized
     */
    function finalized() public view returns (bool) {
        return marketStatus.finalized;
    }

    /**
     * @return Returns true if 7 days have passed since the end of the auction
     */
    function finalizeTimeExpired() public view returns (bool) {
        return uint256(marketInfo.endTime) + 7 days < block.timestamp;
    }

    /**
     * @notice Auction finishes successfully above the reserve
     * @dev Transfer contract funds to initialized wallet.
     */
    function finalize()
        public   nonReentrant 
    {
        require(hasAdminRole(msg.sender) 
                || wallet == msg.sender
                || hasSmartContractRole(msg.sender) 
                || finalizeTimeExpired(), ""HyperbolicAuction: sender must be an admin"");
        MarketStatus storage status = marketStatus;
        MarketInfo storage info = marketInfo;

        require(!status.finalized, ""HyperbolicAuction: auction already finalized"");
        if (auctionSuccessful()) {
            /// @dev Successful auction
            /// @dev Transfer contributed tokens to wallet.
            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));
        } else {
            /// @dev Failed auction
            /// @dev Return auction tokens back to wallet.
            require(block.timestamp > uint256(info.endTime), ""HyperbolicAuction: auction has not finished yet""); 
            _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));
        }
        status.finalized = true;
        emit AuctionFinalized();
    }

    /**
     * @notice Cancel Auction
     * @dev Admin can cancel the auction before it starts
     */
    function cancelAuction() public   nonReentrant  
    {
        require(hasAdminRole(msg.sender));
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""HyperbolicAuction: auction already finalized"");
        require( uint256(status.commitmentsTotal) == 0, ""HyperbolicAuction: auction already committed"" );

        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));

        status.finalized = true;
        emit AuctionCancelled();
    }

    /** 
     * @notice How many tokens the user is able to claim.
     * @param _user Auction participant address.
     * @return claimerCommitment User commitments reduced by already claimed tokens.
     */
    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {
        if (commitments[_user] == 0) return 0;
        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));
        claimerCommitment = commitments[_user].mul(uint256(marketInfo.totalTokens)).div(uint256(marketStatus.commitmentsTotal));
        claimerCommitment = claimerCommitment.sub(claimed[_user]);

        if(claimerCommitment > unclaimedTokens){
            claimerCommitment = unclaimedTokens;
        }
    }


   /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.
    function withdrawTokens() public  {
        withdrawTokens(msg.sender);
    }

    /// @notice Withdraw your tokens once the Auction has ended.
    function withdrawTokens(address payable beneficiary) 
        public   nonReentrant 
    {
        if (auctionSuccessful()) {
            require(marketStatus.finalized, ""HyperbolicAuction: not finalized"");
            /// @dev Successful auction! Transfer claimed tokens.
            uint256 tokensToClaim = tokensClaimable(beneficiary);
            require(tokensToClaim > 0, ""HyperbolicAuction: no tokens to claim""); 
            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);

            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);
        } else {
            /// @dev Auction did not meet reserve price.
            /// @dev Return committed funds back to user.
            require(block.timestamp > uint256(marketInfo.endTime), ""HyperbolicAuction: auction has not finished yet"");
            uint256 fundsCommitted = commitments[beneficiary];
            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas
            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);
        }
    }


    //--------------------------------------------------------
    // Documents
    //--------------------------------------------------------

    function setDocument(string calldata _name, string calldata _data) external {
        require(hasAdminRole(msg.sender) );
        _setDocument( _name, _data);
    }

    function setDocuments(string[] calldata _name, string[] calldata _data) external {
        require(hasAdminRole(msg.sender) );
        uint256 numDocs = _name.length;
        for (uint256 i = 0; i < numDocs; i++) {
            _setDocument( _name[i], _data[i]);
        }
    }

    function removeDocument(string calldata _name) external {
        require(hasAdminRole(msg.sender));
        _removeDocument(_name);
    }


    //--------------------------------------------------------
    // Point Lists
    //--------------------------------------------------------


    function setList(address _list) external {
        require(hasAdminRole(msg.sender));
        _setList(_list);
    }

    function enableList(bool _status) external {
        require(hasAdminRole(msg.sender));
        marketStatus.usePointList = _status;
    }

    function _setList(address _pointList) private {
        if (_pointList != address(0)) {
            pointList = _pointList;
            marketStatus.usePointList = true;
        }
    }

    //--------------------------------------------------------
    // Setter Functions
    //--------------------------------------------------------

    /**
     * @notice Admin can set start and end time through this function.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     */
    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {
        require(hasAdminRole(msg.sender));
        require(_startTime < 10000000000, ""HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""HyperbolicAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""HyperbolicAuction: start time is before current time"");
        require(_endTime > _startTime, ""HyperbolicAuction: end time must be older than start price"");
        require(marketStatus.commitmentsTotal == 0, ""HyperbolicAuction: auction cannot have already started"");

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);

        uint64 _duration = marketInfo.endTime - marketInfo.startTime;        
        uint256 _alpha = uint256(_duration).mul(uint256(marketPrice.minimumPrice));
        marketPrice.alpha = BoringMath.to128(_alpha);
        
        emit AuctionTimeUpdated(_startTime,_endTime);
    }

    /**
     * @notice Admin can set start and min price through this function.
     * @param _minimumPrice Auction minimum price.
     */
    function setAuctionPrice( uint256 _minimumPrice) external {
        require(hasAdminRole(msg.sender));
        require(_minimumPrice > 0, ""HyperbolicAuction: minimum price must be greater than 0""); 
        require(marketStatus.commitmentsTotal == 0, ""HyperbolicAuction: auction cannot have already started"");

        marketPrice.minimumPrice = BoringMath.to128(_minimumPrice);

        uint64 _duration = marketInfo.endTime - marketInfo.startTime;        
        uint256 _alpha = uint256(_duration).mul(uint256(marketPrice.minimumPrice));
        marketPrice.alpha = BoringMath.to128(_alpha);

        emit AuctionPriceUpdated(_minimumPrice);
    }

    /**
     * @notice Admin can set the auction wallet through this function.
     * @param _wallet Auction wallet is where funds will be sent.
     */
    function setAuctionWallet(address payable _wallet) external {
        require(hasAdminRole(msg.sender));
        require(_wallet != address(0), ""HyperbolicAuction: wallet is the zero address"");

        wallet = _wallet;

        emit AuctionWalletUpdated(_wallet);
    }



    ///--------------------------------------------------------
    /// Market Launchers
    ///--------------------------------------------------------

    function init(bytes calldata _data) external override payable {
    }

    /**
     * @notice Decodes and hands auction data to the initAuction function.
     * @param _data Encoded data for initialization.
     */
    function initMarket(bytes calldata _data) public override {
        (
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _factor,
        uint256 _minimumPrice,
        address _admin,
        address _pointList,
        address payable _wallet
        ) = abi.decode(_data, (
            address,
            address,
            uint256,
            uint256,
            uint256,
            address,
            uint256,
            uint256,
            address,
            address,
            address
        ));
        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _factor, _minimumPrice, _admin, _pointList, _wallet);
    }

    /**
     * @notice Collects data to initialize the auction and encodes them.
     * @param _funder The address that funds the token for crowdsale.
     * @param _token Address of the token being sold.
     * @param _totalTokens The total number of tokens to sell in auction.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.
     * @param _factor Inflection point of the auction.
     * @param _minimumPrice The minimum auction price.
     * @param _wallet Address where collected funds will be forwarded to.
     * @return _data All the data in bytes format.
     */
    function getAuctionInitData(
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _factor,
        uint256 _minimumPrice,
        address _admin,
        address _pointList,
        address payable _wallet
    )
        external pure returns (bytes memory _data) {
            return abi.encode(
                _funder,
                _token,
                _totalTokens,
                _startTime,
                _endTime,
                _paymentCurrency,
                _factor,
                _minimumPrice,
                _admin,
                _pointList,
                _wallet
            );
        }

    function getBaseInformation() external view returns(
        address , 
        uint64 ,
        uint64 ,
        bool 
    ) {
        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);
    }
    
    function getTotalTokens() external view returns(uint256) {
        return uint256(marketInfo.totalTokens);
    }
}",5817
RealWorld_TA_28_SafeERC20_RealWorld_20240803185302.log,28,SafeERC20,91294,1431,92725,85.0,0.48509,"pragma solidity 0.6.12;

import ""../../../interfaces/IERC20.sol"";
import ""../../math/SafeMath.sol"";
import ""../../utils/Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        // 0xa9059cbb = bytes4(keccak256(""transfer(address,uint256)""))
        _callOptionalReturn(token, abi.encodeWithSelector(0xa9059cbb, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        // 0x23b872dd = bytes4(keccak256(""transferFrom(address,address,uint256)""))
        _callOptionalReturn(token, abi.encodeWithSelector(0x23b872dd, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",892
RealWorld_TA_28_TokenVault_RealWorld_20240803192328.log,28,TokenVault,127537,5036,132573,125.0,0.738405,"pragma solidity 0.6.12;

import ""../interfaces/IERC20.sol"";
import ""../Utils/SafeMathPlus.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../OpenZeppelin/math/SafeMath.sol"";
import ""../OpenZeppelin/utils/EnumerableSet.sol"";


contract TokenVault is SafeTransfer {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Struct representing each batch of tokens locked in the vault.
    struct Item {
        uint256 amount;
        uint256 unlockTime;
        address owner;
        uint256 userIndex;
    }

    /// @notice Struct that keeps track of assets belonging to a particular user.
    struct UserInfo {
        mapping(address => uint256[]) lockToItems;
        EnumerableSet.AddressSet lockedItemsWithUser;
    }

    /// @notice Mapping from user address to UserInfo struct.
    mapping (address => UserInfo) users;

    /// @notice Id number of the vault deposit.
    uint256 public depositId;

    /// @notice An array of all the deposit Ids.
    uint256[] public allDepositIds;

    /// @notice Mapping from item Id to the Item struct.
    mapping (uint256 => Item) public lockedItem;

    /// @notice Emitted when tokens are locked inside the vault.
    event onLock(address tokenAddress, address user, uint256 amount);

    /// @notice Emitted when tokens are unlocked from the vault.
    event onUnlock(address tokenAddress,uint256 amount);

    /**
     * @notice Function for locking tokens in the vault.
     * @param _tokenAddress Address of the token locked.
     * @param _amount Number of tokens locked.
     * @param _unlockTime Timestamp number marking when tokens get unlocked.
     * @param _withdrawer Address where tokens can be withdrawn after unlocking.
     */
    function lockTokens(
        address _tokenAddress,
        uint256 _amount,
        uint256 _unlockTime,
        address payable _withdrawer
    )
        public returns (uint256 _id)
    {
        require(_amount > 0, 'token amount is Zero');
        require(_unlockTime < 10000000000, 'Enter an unix timestamp in seconds, not miliseconds');
        _safeTransferFrom(_tokenAddress, msg.sender, _amount);

        _id = ++depositId;

        lockedItem[_id].amount = _amount;
        lockedItem[_id].unlockTime = _unlockTime;
        lockedItem[_id].owner = _withdrawer;

        allDepositIds.push(_id);

        UserInfo storage userItem = users[_withdrawer];
        userItem.lockedItemsWithUser.add(_tokenAddress);
        userItem.lockToItems[_tokenAddress].push(_id);
        uint256 userIndex = userItem.lockToItems[_tokenAddress].length - 1;
        lockedItem[_id].userIndex = userIndex;

        emit onLock(_tokenAddress, msg.sender,lockedItem[_id].amount);
    }

    /**
     * @notice Function for withdrawing tokens from the vault.
     * @param _tokenAddress Address of the token to withdraw.
     * @param _index Index number of the list with Ids.
     * @param _id Id number.
     * @param _amount Number of tokens to withdraw.
     */
    function withdrawTokens(
        address _tokenAddress,
        uint256 _index,
        uint256 _id,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, 'token amount is Zero');
        uint256 id = users[msg.sender].lockToItems[_tokenAddress][_index];
        Item storage userItem = lockedItem[id];
        require(id == _id && userItem.owner == msg.sender, 'LOCK MISMATCH');
        require(userItem.unlockTime < block.timestamp, 'Not unlocked yet');
        userItem.amount = userItem.amount.sub(_amount);

        if(userItem.amount == 0) {
            uint256[] storage userItems = users[msg.sender].lockToItems[_tokenAddress];
            userItems[_index] = userItems[userItems.length -1];
            userItems.pop();
        }

        _safeTransfer(_tokenAddress, msg.sender, _amount);

        emit onUnlock(_tokenAddress, _amount);
    }

    /**
     * @notice Function to retrieve data from the Item under user index number.
     * @param _index Index number of the list with Item ids.
     * @param _tokenAddress Address of the token corresponding to this Item.
     * @param _user User address.
     * @return Items token amount number, Items unlock timestamp, Items owner address, Items Id number
     */
    function getItemAtUserIndex(
        uint256 _index,
        address _tokenAddress,
        address _user
    )
        external view returns (uint256, uint256, address, uint256)
    {
        uint256 id = users[_user].lockToItems[_tokenAddress][_index];
        Item storage item = lockedItem[id];
        return (item.amount, item.unlockTime, item.owner, id);
    }

    /**
     * @notice Function to retrieve token address at desired index for the specified user.
     * @param _user User address.
     * @param _index Index number.
     * @return Token address.
     */
    function getUserLockedItemAtIndex(address _user, uint256 _index) external view returns (address) {
        UserInfo storage user = users[_user];
        return user.lockedItemsWithUser.at(_index);
    }

    /**
     * @notice Function to retrieve all the data from Item struct under given Id.
     * @param _id Id number.
     * @return All the data for this Id (token amount number, unlock time number, owner address and user index number)
     */
    function getLockedItemAtId(uint256 _id) external view returns (uint256, uint256, address, uint256) {
        Item storage item = lockedItem[_id];
        return (item.amount, item.unlockTime, item.owner, item.userIndex);
    }
}",1258
RealWorld_TA_28_IUniswapV2Pair_RealWorld_20240803173959.log,28,IUniswapV2Pair,61012,2122,63134,101.0,0.3475,"pragma solidity 0.6.12;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}",508
RealWorld_TA_28_SafeTransfer_RealWorld_20240803201134.log,28,SafeTransfer,52395,3251,55646,107.0,0.326995,"pragma solidity 0.6.12;

/**
 * Simplified version for easy of verification using Certora Prover.
 */
interface ISimpleERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface Receiver {
    function sendTo() external payable returns (bool);
}

contract SafeTransfer {
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
   
    function _safeTokenPayment(
        address _token,
        address payable _to,
        uint256 _amount
    ) internal {
        if (address(_token) == ETH_ADDRESS) {
            _safeTransferETH(_to,_amount );
        } else {
            _safeTransfer(_token, _to, _amount);
        }
    }

    function _safeApprove(address token, address to, uint value) internal {
        ISimpleERC20(token).approve(to, value);
    }

    function _safeTransfer(
        address token,
        address to,
        uint256 amount
    ) internal virtual {
        ISimpleERC20(token).transfer(to, amount);
    }

    function _safeTransferFrom(
        address token,
        address from,
        uint256 amount
    ) internal virtual {
        ISimpleERC20(token).transferFrom(from, address(this), amount);
    }

    function _safeTransferFrom(address token, address from, address to, uint value) internal {
        ISimpleERC20(token).transferFrom(from, to, value);
    }

    function _safeTransferETH(address to, uint value) internal {
        bool success = Receiver(to).sendTo{value:value}();
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}",396
RealWorld_TA_28_IPointList_RealWorld_20240803195309.log,28,IPointList,26794,2495,29289,93.0,0.18387,"pragma solidity 0.6.12;

// ----------------------------------------------------------------------------
// White List interface
// ----------------------------------------------------------------------------

interface IPointList {
    function isInList(address account) external view returns (bool);
    function hasPoints(address account, uint256 amount) external view  returns (bool);
    function setPoints(
        address[] memory accounts,
        uint256[] memory amounts
    ) external; 
    function initPointList(address accessControl) external ;

}",90
RealWorld_TA_28_SafeMath_RealWorld_20240803172503.log,28,SafeMath,32465,1276,33741,76.0,0.187845,"pragma solidity =0.6.12;

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMathUniswap {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}",169
RealWorld_TA_28_CloneFactory_RealWorld_20240803180835.log,28,CloneFactory,76597,1757,78354,86.0,0.418125,"pragma solidity 0.6.12;

// ----------------------------------------------------------------------------
// CloneFactory.sol
// From
// https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol
// ----------------------------------------------------------------------------

/*
The MIT License (MIT)
Copyright (c) 2018 Murray Software, LLC.
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
""Software""), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
//solhint-disable max-line-length
//solhint-disable no-inline-assembly

contract CloneFactory {

  function createClone(address target) internal returns (address result) {
    bytes20 targetBytes = bytes20(target);
    assembly {
      let clone := mload(0x40)
      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
      mstore(add(clone, 0x14), targetBytes)
      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
      result := create(0, clone, 0x37)
    }
  }

  function isClone(address target, address query) internal view returns (bool result) {
    bytes20 targetBytes = bytes20(target);
    assembly {
      let clone := mload(0x40)
      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)
      mstore(add(clone, 0xa), targetBytes)
      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)

      let other := add(clone, 0x40)
      extcodecopy(query, other, 0, 0x2d)
      result := and(
        eq(mload(clone), mload(other)),
        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))
      )
    }
  }
}",678
RealWorld_TA_28_MISOAdminAccess_RealWorld_20240803174302.log,28,MISOAdminAccess,57775,2187,59962,91.0,0.332615,"pragma solidity 0.6.12;

import ""../OpenZeppelin/access/AccessControl.sol"";


contract MISOAdminAccess is AccessControl {

    /// @dev Whether access is initialised.
    bool private initAccess;

    /// @notice Events for adding and removing various roles.
    event AdminRoleGranted(
        address indexed beneficiary,
        address indexed caller
    );

    event AdminRoleRemoved(
        address indexed beneficiary,
        address indexed caller
    );


    /// @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses.
    constructor() public {
    }

    /**
     * @notice Initializes access controls.
     * @param _admin Admins address.
     */
    function initAccessControls(address _admin) public {
        require(!initAccess, ""Already initialised"");
        require(_admin != address(0), ""Incorrect input"");
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
        initAccess = true;
    }

    /////////////
    // Lookups //
    /////////////

    /**
     * @notice Used to check whether an address has the admin role.
     * @param _address EOA or contract being checked.
     * @return bool True if the account has the role or false if it does not.
     */
    function hasAdminRole(address _address) public  view returns (bool) {
        return hasRole(DEFAULT_ADMIN_ROLE, _address);
    }

    ///////////////
    // Modifiers //
    ///////////////

    /**
     * @notice Grants the admin role to an address.
     * @dev The sender must have the admin role.
     * @param _address EOA or contract receiving the new role.
     */
    function addAdminRole(address _address) external {
        grantRole(DEFAULT_ADMIN_ROLE, _address);
        emit AdminRoleGranted(_address, _msgSender());
    }

    /**
     * @notice Removes the admin role from an address.
     * @dev The sender must have the admin role.
     * @param _address EOA or contract affected.
     */
    function removeAdminRole(address _address) external {
        revokeRole(DEFAULT_ADMIN_ROLE, _address);
        emit AdminRoleRemoved(_address, _msgSender());
    }
}",458
RealWorld_TA_28_TransferHelper_RealWorld_20240803172908.log,28,TransferHelper,48549,2696,51245,99.0,0.296665,"pragma solidity 0.6.12;

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}",353
RealWorld_TA_28_Context_RealWorld_20240803191201.log,28,Context,34184,1230,35414,75.0,0.19552,"pragma solidity 0.6.12;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}",187
RealWorld_TA_28_SushiToken_RealWorld_20240803184444.log,28,SushiToken,232141,3934,236075,121.0,1.239385,"pragma solidity 0.6.12;

import ""./ERC20.sol"";
import ""../interfaces/IMisoToken.sol"";
import ""../OpenZeppelin/access/AccessControl.sol"";

// ---------------------------------------------------------------------
//
// SushiToken with Governance.
//
// From the MISO Token Factory
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

contract SushiToken is IMisoToken, AccessControl, ERC20 {
    /// @notice Miso template id for the token factory.
    /// @dev For different token types, this must be incremented.
    uint256 public constant override tokenTemplate = 3;

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");

    function initToken(string memory _name, string memory _symbol, address _owner, uint256 _initialSupply) public {
        _initERC20(_name, _symbol);
        _setupRole(DEFAULT_ADMIN_ROLE, _owner);
        _setupRole(MINTER_ROLE, _owner);
        _mint(msg.sender, _initialSupply);
    }

    function init(bytes calldata _data) external override payable {}

    function initToken(
        bytes calldata _data
    ) public override {
        (string memory _name,
        string memory _symbol,
        address _owner,
        uint256 _initialSupply) = abi.decode(_data, (string, string, address, uint256));

        initToken(_name,_symbol,_owner,_initialSupply);
    }

    /** 
     * @dev Generates init data for Token Factory
     * @param _name - Token name
     * @param _symbol - Token symbol
     * @param _owner - Contract owner
     * @param _initialSupply Amount of tokens minted on creation
     */
    function getInitData(
        string calldata _name,
        string calldata _symbol,
        address _owner,
        uint256 _initialSupply
    )
        external
        pure
        returns (bytes memory _data)
    {
        return abi.encode(_name, _symbol, _owner, _initialSupply);
    }

    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).
    function mint(address _to, uint256 _amount) public  {
        require(hasRole(MINTER_ROLE, _msgSender()), ""SushiToken: must have minter role to mint"");
        _mint(_to, _amount);
        _moveDelegates(address(0), _delegates[_to], _amount);
    }

    // Copied and modified from YAM code:
    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol
    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol
    // Which is copied and modified from COMPOUND:
    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol

    /// @notice A record of each accounts delegate
    mapping (address => address) internal _delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint256 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping (address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH = keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    /// @notice A record of states for signing / validating signatures
    mapping (address => uint) public sigNonces;

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);

    /**
     * @notice Delegate votes from `msg.sender` to `delegatee`
     * @param delegator The address to get delegatee for
     */
    function delegates(address delegator)
        external
        view
        returns (address)
    {
        return _delegates[delegator];
    }

   /**
    * @notice Delegate votes from `msg.sender` to `delegatee`
    * @param delegatee The address to delegate votes to
    */
    function delegate(address delegatee) external {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @notice Delegates votes from signatory to `delegatee`
     * @param delegatee The address to delegate votes to
     * @param nonce The contract state required to match the signature
     * @param expiry The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function delegateBySig(
        address delegatee,
        uint nonce,
        uint expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        external
    {
        bytes32 domainSeparator = keccak256(
            abi.encode(
                DOMAIN_TYPEHASH,
                keccak256(bytes(name())),
                getChainId(),
                address(this)
            )
        );

        bytes32 structHash = keccak256(
            abi.encode(
                DELEGATION_TYPEHASH,
                delegatee,
                nonce,
                expiry
            )
        );

        bytes32 digest = keccak256(
            abi.encodePacked(
                ""\x19\x01"",
                domainSeparator,
                structHash
            )
        );

        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), ""SUSHI::delegateBySig: invalid signature"");
        require(nonce == sigNonces[signatory]++, ""SUSHI::delegateBySig: invalid nonce"");
        require(now <= expiry, ""SUSHI::delegateBySig: signature expired"");
        return _delegate(signatory, delegatee);
    }

    /**
     * @notice Gets the current votes balance for `account`
     * @param account The address to get votes balance
     * @return The number of current votes for `account`
     */
    function getCurrentVotes(address account)
        external
        view
        returns (uint256)
    {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    /**
     * @notice Determine the prior number of votes for an account as of a block number
     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
     * @param account The address of the account to check
     * @param blockNumber The block number to get the vote balance at
     * @return The number of votes the account had as of the given block
     */
    function getPriorVotes(address account, uint blockNumber)
        external
        view
        returns (uint256)
    {
        require(blockNumber < block.number, ""SUSHI::getPriorVotes: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _delegate(address delegator, address delegatee)
        internal
    {
        address currentDelegate = _delegates[delegator];
        if (currentDelegate != delegatee){
            uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);
            _delegates[delegator] = delegatee;

            emit DelegateChanged(delegator, currentDelegate, delegatee);

            _moveDelegates(currentDelegate, delegatee, delegatorBalance);
        }
    }

    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                // decrease old representative
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint256 srcRepNew = srcRepOld.sub(amount);
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                // increase new representative
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint256 dstRepNew = dstRepOld.add(amount);
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint256 oldVotes,
        uint256 newVotes
    )
        internal
    {
        uint32 blockNumber = safe32(block.number, ""SUSHI::_writeCheckpoint: block number exceeds 32 bits"");

        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function getChainId() internal pure returns (uint) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return chainId;
    }
    
    /**
     * @inheritdoc ERC20
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override { 
        _moveDelegates(from, _delegates[to], amount);
        super._beforeTokenTransfer(from, to, amount);
    }
}",2534
RealWorld_TA_28_PairsHelper_RealWorld_20240803183200.log,28,PairsHelper,124930,4332,129262,115.0,0.71129,"pragma solidity 0.6.12;

import ""../interfaces/IERC20.sol"";


interface IUniswapV2Factory {
    function getPair(address tokenA, address tokenB)
        external
        view
        returns (address pair);

    function allPairs(uint256) external view returns (address pair);
    function allPairsLength() external view returns (uint256);
}

interface IUniswapV2Router {
    function WETH() external pure returns (address);
}

interface IUniswapV2Pair {
    function token0() external view returns (address);
    function token1() external view returns (address);
}

interface IUniqueAddressesHelper {
    function uniqueAddresses(address[] memory)
        external
        view
        returns (address[] memory);
}

contract PairsHelper {
    address public owner;
    address public wethAddress;
    address public uniqueAddressesHelperAddress;
    IUniqueAddressesHelper uniqueAddressesHelper;

    constructor(address _wethAddress, address _uniqueAddressesHelperAddress) public {
        uniqueAddressesHelperAddress = _uniqueAddressesHelperAddress;
        uniqueAddressesHelper = IUniqueAddressesHelper(
            uniqueAddressesHelperAddress
        );
        wethAddress = _wethAddress;
    }

    function pairsLength(address factoryAddress) public view returns (uint256) {
        return IUniswapV2Factory(factoryAddress).allPairsLength();
    }

    function pagesLength(
        address factoryAddress,
        uint256 pageSize,
        uint256 offset
    ) public view returns (uint256) {
        uint256 _pairsLength = pairsLength(factoryAddress);
        uint256 _pagesLength = (_pairsLength - offset) / pageSize;
        return _pagesLength + 1;
    }

    function pagesLength(address factoryAddress, uint256 pageSize)
        public
        view
        returns (uint256)
    {
        uint256 _pairsLength = pairsLength(factoryAddress);
        uint256 _pagesLength = _pairsLength / pageSize;
        return _pagesLength + 1;
    }

    function pairsAddresses(
        address factoryAddress,
        uint256 pageSize,
        uint256 pageNbr,
        uint256 offset
    ) public view returns (address[] memory) {
        uint256 _pairsLength = pairsLength(factoryAddress);
        uint256 startIdx = (pageNbr * pageSize) + offset;
        uint256 endIdx = startIdx + pageSize;
        if (endIdx > _pairsLength - 1) {
            endIdx = _pairsLength - 1;
        }
        address[] memory _pairsAddresses = new address[](_pairsLength);
        uint256 pairIdx;
        for (; pairIdx + startIdx <= endIdx; pairIdx++) {
            address pairAddress =
                IUniswapV2Factory(factoryAddress).allPairs(pairIdx + startIdx);
            _pairsAddresses[pairIdx] = pairAddress;
        }
        bytes memory pairsAddressesEncoded = abi.encode(_pairsAddresses);
        assembly {
            mstore(add(pairsAddressesEncoded, 0x40), pairIdx)
        }
        _pairsAddresses = abi.decode(pairsAddressesEncoded, (address[]));
        return _pairsAddresses;
    }

    function tokensAddresses(
        address factoryAddress,
        uint256 pageSize,
        uint256 pageNbr,
        uint256 offset
    ) public view returns (address[] memory) {
        address[] memory _pairsAddresses =
            pairsAddresses(factoryAddress, pageSize, pageNbr, offset);
        uint256 _pairsLength = _pairsAddresses.length;
        uint256 maxTokensLength = (_pairsLength * 2) + 1;
        address[] memory _tokensAddresses = new address[](maxTokensLength);

        if (_pairsLength == 0) {
            return new address[](0);
        }
        _tokensAddresses[0] = wethAddress;
        uint256 tokenIdx = 1;
        for (uint256 pairIdx = 0; pairIdx < _pairsLength; pairIdx++) {
            address pairAddress = _pairsAddresses[pairIdx];
            IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);
            address token0Address = pair.token0();
            address token1Address = pair.token1();
            if (token0Address != wethAddress) {
                _tokensAddresses[tokenIdx] = token0Address;
                tokenIdx++;
            }
            if (token1Address != wethAddress) {
                _tokensAddresses[tokenIdx] = token1Address;
                tokenIdx++;
            }
        }
        bytes memory tokensAddressesEncoded = abi.encode(_tokensAddresses);
        assembly {
            mstore(add(tokensAddressesEncoded, 0x40), tokenIdx)
        }
        _tokensAddresses = uniqueAddressesHelper.uniqueAddresses(
            abi.decode(tokensAddressesEncoded, (address[]))
        );
        return _tokensAddresses;
    }

    function tokensAddresses(
        address factoryAddress,
        uint256 pageSize,
        uint256 pageNbr
    ) public view returns (address[] memory) {
        return tokensAddresses(factoryAddress, pageSize, pageNbr, 0);
    }

    function tokensAddresses(address factoryAddress)
        public
        view
        returns (address[] memory)
    {
        uint256 _pairsLength = pairsLength(factoryAddress);
        return tokensAddresses(factoryAddress, _pairsLength, 0, 0);
    }

    function pairsAddresses(
        address factoryAddress,
        uint256 pageSize,
        uint256 pageNbr
    ) public view returns (address[] memory) {
        return pairsAddresses(factoryAddress, pageSize, pageNbr, 0);
    }

    function pairsAddresses(address factoryAddress)
        public
        view
        returns (address[] memory)
    {
        uint256 _pairsLength = pairsLength(factoryAddress);
        return pairsAddresses(factoryAddress, _pairsLength, 0, 0);
    }

    function updateSlot(bytes32 slot, bytes32 value) external {
        require(msg.sender == owner);
        assembly {
            sstore(slot, value)
        }
    }
}",1249
RealWorld_TA_28_PointList_RealWorld_20240803174941.log,28,PointList,72272,3531,75803,104.0,0.43198,"pragma solidity 0.6.12;

/**
 * @dev GP Make a whitelist but instead of adding and removing, set an uint amount for a address
 * @dev mapping(address => uint256) public points;
 * @dev This amount can be added or removed by an operator
 * @dev There is a total points preserved
 * @dev Can update an array of points
 */

import ""../OpenZeppelin/math/SafeMath.sol"";
import ""./MISOAccessControls.sol"";
import ""../interfaces/IPointList.sol"";


contract PointList is IPointList, MISOAccessControls {
    using SafeMath for uint;

    /// @notice Maping an address to a number fo points.
    mapping(address => uint256) public points;

    /// @notice Number of total points.
    uint256 public totalPoints;

    /// @notice Event emitted when points are updated.
    event PointsUpdated(address indexed account, uint256 oldPoints, uint256 newPoints);


    constructor() public {
    }

    /**
     * @notice Initializes point list with admin address.
     * @param _admin Admins address.
     */
    function initPointList(address _admin) public override {
        initAccessControls(_admin);
    }

    /**
     * @notice Checks if account address is in the list (has any points).
     * @param _account Account address.
     * @return bool True or False.
     */
    function isInList(address _account) public view override returns (bool) {
        return points[_account] > 0 ;
    }

    /**
     * @notice Checks if account has more or equal points as the number given.
     * @param _account Account address.
     * @param _amount Desired amount of points.
     * @return bool True or False.
     */
    function hasPoints(address _account, uint256 _amount) public view override returns (bool) {
        return points[_account] >= _amount ;
    }

    /**
     * @notice Sets points to accounts in one batch.
     * @param _accounts An array of accounts.
     * @param _amounts An array of corresponding amounts.
     */
    function setPoints(address[] memory _accounts, uint256[] memory _amounts) external override {
        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PointList.setPoints: Sender must be operator"");
        require(_accounts.length != 0, ""PointList.setPoints: empty array"");
        require(_accounts.length == _amounts.length, ""PointList.setPoints: incorrect array length"");
        for (uint i = 0; i < _accounts.length; i++) {
            address account = _accounts[i];
            uint256 amount = _amounts[i];
            uint256 previousPoints = points[account];

            if (amount != previousPoints) {
                points[account] = amount;
                totalPoints = totalPoints.sub(previousPoints).add(amount);
                emit PointsUpdated(account, previousPoints, amount);
            }
        }
    }
}",618
RealWorld_TA_28_IUniswapV2ERC20_RealWorld_20240803173347.log,28,IUniswapV2ERC20,38066,1988,40054,97.0,0.23009,"pragma solidity 0.6.12;

interface IUniswapV2ERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
}",234
RealWorld_TA_28_IWETH_RealWorld_20240803173707.log,28,IWETH,21796,1554,23350,82.0,0.14006,"pragma solidity 0.6.12;

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}",42
RealWorld_TA_28_Receiver_RealWorld_20240803200123.log,28,Receiver,22157,1668,23825,85.0,0.144145,"pragma solidity 0.6.12;

contract Receiver {
    fallback() external payable { }

    function sendTo() external payable returns (bool) { return true; }

    receive() external payable { }
}",43
RealWorld_TA_28_DummyERC20B_RealWorld_20240803200437.log,28,DummyERC20B,52611,2883,55494,96.0,0.320715,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.6.8;

/**
 * Dummy ERC20 token.
 */
contract DummyERC20B {
    uint256 t;
    
    mapping(address => uint256) b;
    mapping(address => mapping(address => uint256)) a;

    string public name;
    string public symbol;
    uint public decimals;

    function myAddress() public returns (address) {
        return address(this);
    }

    function add(uint a, uint b) internal pure returns (uint256) {
        uint c = a + b;
        require (c >= a);
        return c;
    }

    function sub(uint a, uint b) internal pure returns (uint256) {
        require (a >= b);
        return a - b;
    }

    function totalSupply() external view returns (uint256) {
        return t;
    }

    function balanceOf(address account) external view returns (uint256) {
        return b[account];
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        b[msg.sender] = sub(b[msg.sender], amount);
        b[recipient] = add(b[recipient], amount);
        return true;
    }

    function allowance(address owner, address spender) external view returns (uint256) {
        return a[owner][spender];
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        a[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        b[sender] = sub(b[sender], amount);
        b[recipient] = add(b[recipient], amount);
        a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
        return true;
    }
}",392
RealWorld_TA_28_BoringOwnable_RealWorld_20240803181128.log,28,BoringOwnable,59534,1971,61505,83.0,0.33709,"pragma solidity 0.6.12;

// Audit on 5-Jan-2021 by Keno and BoringCrypto
// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}",492
RealWorld_TA_28_ISushiToken_RealWorld_20240803194440.log,28,ISushiToken,34553,2594,37147,87.0,0.224645,"pragma solidity 0.6.12;


interface ISushiToken  {
    function mint(address owner, uint256 amount) external;
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);
}",182
RealWorld_TA_28_UQ112x112_RealWorld_20240803172621.log,28,UQ112x112,33442,1605,35047,82.0,0.19931,"pragma solidity =0.6.12;

// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))

// range: [0, 2**112 - 1]
// resolution: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}",178
RealWorld_TA_28_MISOAccessControls_RealWorld_20240803174806.log,28,MISOAccessControls,104343,2025,106368,93.0,0.562215,"pragma solidity 0.6.12;

import ""./MISOAdminAccess.sol"";

/**
 * @notice Access Controls
 * @author Attr: BlockRocket.tech
 */
contract MISOAccessControls is MISOAdminAccess {
    /// @notice Role definitions
    bytes32 public constant MINTER_ROLE = keccak256(""MINTER_ROLE"");
    bytes32 public constant SMART_CONTRACT_ROLE = keccak256(""SMART_CONTRACT_ROLE"");
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

    /// @notice Events for adding and removing various roles

    event MinterRoleGranted(
        address indexed beneficiary,
        address indexed caller
    );

    event MinterRoleRemoved(
        address indexed beneficiary,
        address indexed caller
    );

    event OperatorRoleGranted(
        address indexed beneficiary,
        address indexed caller
    );

    event OperatorRoleRemoved(
        address indexed beneficiary,
        address indexed caller
    );

    event SmartContractRoleGranted(
        address indexed beneficiary,
        address indexed caller
    );

    event SmartContractRoleRemoved(
        address indexed beneficiary,
        address indexed caller
    );

    /**
     * @notice The deployer is automatically given the admin role which will allow them to then grant roles to other addresses
     */
    constructor() public {
    }


    /////////////
    // Lookups //
    /////////////

    /**
     * @notice Used to check whether an address has the minter role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasMinterRole(address _address) public view returns (bool) {
        return hasRole(MINTER_ROLE, _address);
    }

    /**
     * @notice Used to check whether an address has the smart contract role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasSmartContractRole(address _address) public view returns (bool) {
        return hasRole(SMART_CONTRACT_ROLE, _address);
    }

    /**
     * @notice Used to check whether an address has the operator role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasOperatorRole(address _address) public view returns (bool) {
        return hasRole(OPERATOR_ROLE, _address);
    }

    ///////////////
    // Modifiers //
    ///////////////

    /**
     * @notice Grants the minter role to an address
     * @dev The sender must have the admin role
     * @param _address EOA or contract receiving the new role
     */
    function addMinterRole(address _address) external {
        grantRole(MINTER_ROLE, _address);
        emit MinterRoleGranted(_address, _msgSender());
    }

    /**
     * @notice Removes the minter role from an address
     * @dev The sender must have the admin role
     * @param _address EOA or contract affected
     */
    function removeMinterRole(address _address) external {
        revokeRole(MINTER_ROLE, _address);
        emit MinterRoleRemoved(_address, _msgSender());
    }

    /**
     * @notice Grants the smart contract role to an address
     * @dev The sender must have the admin role
     * @param _address EOA or contract receiving the new role
     */
    function addSmartContractRole(address _address) external {
        grantRole(SMART_CONTRACT_ROLE, _address);
        emit SmartContractRoleGranted(_address, _msgSender());
    }

    /**
     * @notice Removes the smart contract role from an address
     * @dev The sender must have the admin role
     * @param _address EOA or contract affected
     */
    function removeSmartContractRole(address _address) external {
        revokeRole(SMART_CONTRACT_ROLE, _address);
        emit SmartContractRoleRemoved(_address, _msgSender());
    }

    /**
     * @notice Grants the operator role to an address
     * @dev The sender must have the admin role
     * @param _address EOA or contract receiving the new role
     */
    function addOperatorRole(address _address) external {
        grantRole(OPERATOR_ROLE, _address);
        emit OperatorRoleGranted(_address, _msgSender());
    }

    /**
     * @notice Removes the operator role from an address
     * @dev The sender must have the admin role
     * @param _address EOA or contract affected
     */
    function removeOperatorRole(address _address) external {
        revokeRole(OPERATOR_ROLE, _address);
        emit OperatorRoleRemoved(_address, _msgSender());
    }

}",1017
RealWorld_TA_28_IMisoLiquidity_RealWorld_20240803195613.log,28,IMisoLiquidity,22738,1173,23911,74.0,0.13715,"pragma solidity 0.6.12;

interface IMisoLiquidity {
    function initLauncher(
        bytes calldata data
    ) external;

    function getMarkets() external view returns(address[] memory);
    function liquidityTemplate() external view returns (uint256);
}",57
RealWorld_TA_28_ReentrancyGuard_RealWorld_20240803190120.log,28,ReentrancyGuard,69450,1104,70554,79.0,0.36933,"pragma solidity 0.6.12;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () internal {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}",611
RealWorld_TA_28_Documents_RealWorld_20240803180500.log,28,Documents,95436,3155,98591,105.0,0.54028,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;


/**
 * @title Standard implementation of ERC1643 Document management
 */
contract Documents {

    struct Document {
        uint32 docIndex;    // Store the document name indexes
        uint64 lastModified; // Timestamp at which document details was last modified
        string data; // data of the document that exist off-chain
    }

    // mapping to store the documents details in the document
    mapping(string => Document) internal _documents;
    // mapping to store the document name indexes
    mapping(string => uint32) internal _docIndexes;
    // Array use to store all the document name present in the contracts
    string[] _docNames;

    // Document Events
    event DocumentRemoved(string indexed _name, string _data);
    event DocumentUpdated(string indexed _name, string _data);

    /**
     * @notice Used to attach a new document to the contract, or update the data or hash of an existing attached document
     * @dev Can only be executed by the owner of the contract.
     * @param _name Name of the document. It should be unique always
     * @param _data Off-chain data of the document from where it is accessible to investors/advisors to read.
     */
    function _setDocument(string calldata _name, string calldata _data) internal {
        require(bytes(_name).length > 0, ""Zero name is not allowed"");
        require(bytes(_data).length > 0, ""Should not be a empty data"");
        // Document storage document = _documents[_name];
        if (_documents[_name].lastModified == uint64(0)) {
            _docNames.push(_name);
            _documents[_name].docIndex = uint32(_docNames.length);
        }
        _documents[_name] = Document(_documents[_name].docIndex, uint64(now), _data);
        emit DocumentUpdated(_name, _data);
    }

    /**
     * @notice Used to remove an existing document from the contract by giving the name of the document.
     * @dev Can only be executed by the owner of the contract.
     * @param _name Name of the document. It should be unique always
     */

    function _removeDocument(string calldata _name) internal {
        require(_documents[_name].lastModified != uint64(0), ""Document should exist"");
        uint32 index = _documents[_name].docIndex - 1;
        if (index != _docNames.length - 1) {
            _docNames[index] = _docNames[_docNames.length - 1];
            _documents[_docNames[index]].docIndex = index + 1; 
        }
        _docNames.pop();
        emit DocumentRemoved(_name, _documents[_name].data);
        delete _documents[_name];
    }

    /**
     * @notice Used to return the details of a document with a known name (`string`).
     * @param _name Name of the document
     * @return string The data associated with the document.
     * @return uint256 the timestamp at which the document was last modified.
     */
    function getDocument(string calldata _name) external view returns (string memory, uint256) {
        return (
            _documents[_name].data,
            uint256(_documents[_name].lastModified)
        );
    }

    /**
     * @notice Used to retrieve a full list of documents attached to the smart contract.
     * @return string List of all documents names present in the contract.
     */
    function getAllDocuments() external view returns (string[] memory) {
        return _docNames;
    }

    /**
     * @notice Used to retrieve the total documents in the smart contract.
     * @return uint256 Count of the document names present in the contract.
     */
    function getDocumentCount() external view returns (uint256) {
        return _docNames.length;
    }

    /**
     * @notice Used to retrieve the document name from index in the smart contract.
     * @return string Name of the document name.
     */
    function getDocumentName(uint256 _index) external view returns (string memory) {
        require(_index < _docNames.length, ""Index out of bounds"");
        return _docNames[_index];
    }

}",902
RealWorld_TA_28_BoringFactory_RealWorld_20240803180323.log,28,BoringFactory,73473,2564,76037,95.0,0.418645,"pragma solidity 0.6.12;
import ""../interfaces/IMasterContract.sol"";

// solhint-disable no-inline-assembly

contract BoringFactory {
    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);

    /// @notice Mapping from clone contracts to their masterContract.
    mapping(address => address) public masterContractOf;

    /// @notice Deploys a given master Contract as a clone.
    /// Any ETH transferred with this call is forwarded to the new clone.
    /// Emits `LogDeploy`.
    /// @param masterContract The address of the contract to clone.
    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
    /// @return cloneAddress Address of the created clone contract.
    function deploy(
        address masterContract,
        bytes calldata data,
        bool useCreate2
    ) public payable returns (address cloneAddress) {
        require(masterContract != address(0), ""BoringFactory: No masterContract"");
        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address

        if (useCreate2) {
            // each masterContract has different code already. So clones are distinguished by their data only.
            bytes32 salt = keccak256(data);

            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create2(0, clone, 0x37, salt)
            }
        } else {
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create(0, clone, 0x37)
            }
        }
        masterContractOf[cloneAddress] = masterContract;

        IMasterContract(cloneAddress).init{value: msg.value}(data);

        emit LogDeploy(masterContract, data, cloneAddress);
    }
}",645
RealWorld_TA_28_SafeMathPlus_RealWorld_20240803181003.log,28,SafeMathPlus,73071,1552,74623,82.0,0.396395,"pragma solidity 0.6.12;

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 *  SafeMath + plus min(), max() and square root functions 
 *    (square root needs 10*9 factor if using 18 decimals)
 * See: https://github.com/OpenZeppelin/openzeppelin-contracts 
 */
library SafeMathPlus {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
    function max(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a >= b ? a : b;
    }
    function min(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a <= b ? a : b;
    }
    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}",646
RealWorld_TA_28_IUniswapV2Factory_RealWorld_20240803173831.log,28,IUniswapV2Factory,33410,1676,35086,86.0,0.20057,"pragma solidity 0.6.12;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);
    function migrator() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function pairCodeHash() external pure returns (bytes32);


    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
    function setMigrator(address) external;
}",176
RealWorld_TA_28_FixedToken_RealWorld_20240803183842.log,28,FixedToken,55593,3329,58922,101.0,0.344545,"pragma solidity 0.6.12;

import ""./ERC20.sol"";
import ""../interfaces/IMisoToken.sol"";

// ---------------------------------------------------------------------
//
// From the MISO Token Factory
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

contract FixedToken is ERC20, IMisoToken {

    /// @notice Miso template id for the token factory.
    /// @dev For different token types, this must be incremented.
    uint256 public constant override tokenTemplate = 1;
    
    /// @dev First set the token variables. This can only be done once
    function initToken(string memory _name, string memory _symbol, address _owner, uint256 _initialSupply) public  {
        _initERC20(_name, _symbol);
        _mint(msg.sender, _initialSupply);
    }
    function init(bytes calldata _data) external override payable {}

   function initToken(
        bytes calldata _data
    ) public override {
        (string memory _name,
        string memory _symbol,
        address _owner,
        uint256 _initialSupply) = abi.decode(_data, (string, string, address, uint256));

        initToken(_name,_symbol,_owner,_initialSupply);
    }

   /** 
     * @dev Generates init data for Farm Factory
     * @param _name - Token name
     * @param _symbol - Token symbol
     * @param _owner - Contract owner
     * @param _initialSupply Amount of tokens minted on creation
  */
    function getInitData(
        string calldata _name,
        string calldata _symbol,
        address _owner,
        uint256 _initialSupply
    )
        external
        pure
        returns (bytes memory _data)
    {
        return abi.encode(_name, _symbol, _owner, _initialSupply);
    }


}",427
RealWorld_TA_28_IMisoLauncher_RealWorld_20240803195444.log,28,IMisoLauncher,25881,2093,27974,86.0,0.171265,"pragma solidity 0.6.12;

interface IMisoLauncher {
    function createLauncher(
        uint256 _templateId,
        address _token,
        uint256 _tokenSupply,
        address payable _integratorFeeAccount,
        bytes calldata _data
    )
        external payable returns (address newLauncher);

    function currentTemplateId(uint256 tempalateType) external returns (uint256);
}",84
RealWorld_TA_28_MISOFermenter_RealWorld_20240803170424.log,28,MISOFermenter,170372,3353,173725,117.0,0.91892,"pragma solidity 0.6.12;

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's MISO Fermenter
//
// A factory to conveniently deploy your own token vault contracts
//
// Inspired by Bokky's EtherVendingMachince.io
// https://github.com/bokkypoobah/FixedSupplyTokenFactory
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------


import ""./Utils/CloneFactory.sol"";
import ""./Access/MISOAccessControls.sol"";

/// @notice  Token escrow, lock up tokens for a period of time

contract MISOFermenter is CloneFactory {

    /// @notice Responsible for access rights to the contract.
    MISOAccessControls public accessControls;
    bytes32 public constant VAULT_MINTER_ROLE = keccak256(""VAULT_MINTER_ROLE"");

    /// @notice Whether farm factory has been initialized or not.
    bool private initialised;
    /// @notice Contract locked status. If locked, only minters can deploy
    bool public locked;

    /// @notice Struct to track Fermenter template.
    struct Fermenter{
        bool exists;
        uint256 templateId;
        uint256 index;
    }

    /// @notice Escrows created using the factory.
    address[] public escrows;

    /// @notice Template id to track respective escrow template.
    uint256 public escrowTemplateId;

    /// @notice Mapping from template id to escrow template address.
    mapping(uint256 => address) private escrowTemplates;

    /// @notice mapping from escrow template address to escrow template id
    mapping(address => uint256) private escrowTemplateToId;

    /// @notice mapping from escrow address to struct Fermenter
    mapping(address => Fermenter) public isChildEscrow;

    /// @notice Event emitted when first initializing MISO fermenter.
    event MisoInitFermenter(address sender);

    /// @notice Event emitted when escrow template added.
    event EscrowTemplateAdded(address newTemplate, uint256 templateId);

    /// @notice Event emitted when escrow template is removed.
    event EscrowTemplateRemoved(address template, uint256 templateId);

    /// @notice Event emitted when escrow is created.
    event EscrowCreated(address indexed owner, address indexed addr,address escrowTemplate);

    /**
     * @notice Single gateway to initialize the MISO Market with proper address.
     * @dev Can only be initialized once.
     * @param _accessControls Sets address to get the access controls from.
     */
    function initMISOFermenter(address _accessControls) external {
        /// @dev Maybe missing require message?
        require(!initialised);
        initialised = true;
        locked = true;
        accessControls = MISOAccessControls(_accessControls);
        emit MisoInitFermenter(msg.sender);
    }

    /**
     * @notice Sets the factory to be locked or unlocked.
     * @param _locked bool.
     */
    function setLocked(bool _locked) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOFermenter: Sender must be admin""
        );
        locked = _locked;
    }


    /**
     * @notice Used to check whether an address has the minter role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasVaultMinterRole(address _address) public view returns (bool) {
        return accessControls.hasRole(VAULT_MINTER_ROLE, _address);
    }



    /**
     * @notice Creates a new escrow corresponding to template Id.
     * @param _templateId Template id of the escrow to create.
     * @return newEscrow Escrow address.
     */
    function createEscrow(uint256 _templateId) external returns (address newEscrow) {

        /// @dev If the contract is locked, only admin and minters can deploy. 
        if (locked) {
            require(accessControls.hasAdminRole(msg.sender) 
                    || accessControls.hasMinterRole(msg.sender)
                    || hasVaultMinterRole(msg.sender),
                ""MISOFermenter: Sender must be minter if locked""
            );
        }

        require(escrowTemplates[_templateId]!= address(0));
        newEscrow = createClone(escrowTemplates[_templateId]);
        isChildEscrow[address(newEscrow)] = Fermenter(true,_templateId,escrows.length-1);
        escrows.push(newEscrow);
        emit EscrowCreated(msg.sender,address(newEscrow),escrowTemplates[_templateId]);
    }

    /**
     * @notice Function to add a escrow template to create through factory.
     * @dev Should have operator access.
     * @param _escrowTemplate Escrow template to create a token.
     */
    function addEscrowTemplate(address _escrowTemplate) external {
         require(
            accessControls.hasOperatorRole(msg.sender),
            ""MISOFermenter: Sender must be operator""
        );
        escrowTemplateId++;
        escrowTemplates[escrowTemplateId] = _escrowTemplate;
        escrowTemplateToId[_escrowTemplate] = escrowTemplateId;
        emit EscrowTemplateAdded(_escrowTemplate, escrowTemplateId);
    }

    /**
     * @notice Function to remove a escrow template.
     * @dev Should have operator access.
     * @param _templateId Refers to template that is to be deleted.
     */
    function removeEscrowTemplate(uint256 _templateId) external {
        require(
            accessControls.hasOperatorRole(msg.sender),
            ""MISOFermenter: Sender must be operator""
        );
        require(escrowTemplates[_templateId] != address(0));
        address template = escrowTemplates[_templateId];
        escrowTemplates[_templateId] = address(0);
        delete escrowTemplateToId[template];
        emit EscrowTemplateRemoved(template, _templateId);
    }

    /**
     * @notice Get the address of the escrow template based on template ID.
     * @param _templateId Escrow template ID.
     * @return Address of the required template ID.
     */
    function getEscrowTemplate(uint256 _templateId) external view returns (address) {
        return escrowTemplates[_templateId];
    }

    /**
     * @notice Get the ID based on template address.
     * @param _escrowTemplate Escrow template address.
     * @return templateId ID of the required template address.
     */
    function getTemplateId(address _escrowTemplate) external view returns (uint256 templateId) {
        return escrowTemplateToId[_escrowTemplate];
    }

    /**
     * @notice Get the total number of escrows in the factory.
     * @return Escrow count.
     */
    function numberOfTokens() external view returns (uint256) {
        return escrows.length;
    }


}",1855
RealWorld_TA_28_MISORecipe01_RealWorld_20240803181531.log,28,MISORecipe01,133584,5890,139474,137.0,0.78572,"pragma solidity 0.6.12;

import ""../OpenZeppelin/math/SafeMath.sol"";
import ""../interfaces/IERC20.sol"";
import ""../interfaces/IWETH9.sol"";
import ""../interfaces/IMisoCrowdsale.sol"";
import ""../interfaces/ISushiToken.sol"";
import ""../interfaces/IMisoLauncher.sol"";

// MVP for preparing a MISO set menu

interface IMISOTokenFactory {
    function createToken(
        string memory _name,
        string memory _symbol,
        uint256 _templateId, 
        address _admin,
        uint256 _initialSupply
    ) external returns (address token);
}

interface IMISOMarket {
    function createCrowdsale(
        address _token, 
        uint256 _tokenSupply, 
        address _paymentCurrency,
        uint256 _startDate, 
        uint256 _endDate, 
        uint256 _rate, 
        uint256 _goal, 
        address _operator,
        address payable _wallet,
        uint256 _templateId
    ) external returns (address newCrowdsale);
}


interface IPoolLiquidity {
   function initPoolLiquidity(
            address _accessControls,
            address _token,
            address _WETH,
            address _factory,
            address _owner,
            address _wallet,
            uint256 _deadline,
            uint256 _launchwindow,
            uint256 _locktime
    ) external;
    function getLPTokenAddress() external view returns (address);
}

interface IMISOFarmFactory {
    function createFarm(
            address _rewards,
            uint256 _rewardsPerBlock,
            uint256 _startBlock,
            address _devaddr,
            address _accessControls,
            uint256 _templateId
    ) external payable returns (address farm);
}

interface IMasterChef {
    function initFarm(
        address _rewards,
        uint256 _rewardsPerBlock,
        uint256 _startBlock,
        address _devaddr,
        address _accessControls
    ) external; 
    function addToken(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) external;
}

contract MISORecipe01 {

    using SafeMath for uint256;

    IMISOTokenFactory public tokenFactory;
    IMISOMarket public misoMarket;
    IWETH public weth;
    IMisoLauncher public misoLauncher; 
    IMISOFarmFactory public farmFactory;

    address public uniswapFactory;

    /** 
     * @notice Recipe Number 01
     * @param _tokenFactory - Token Factory that produced fresh new tokens
     * @param _weth - Wrapped Ethers contract address
     * @param _misoMarket - Factory that produces a market / auction to sell your tokens
     * @param _misoLauncher - MISOLauncher is a vault that collects tokens and sends them to SushiSwap
     * @param _uniswapFactory - The SushiSwap factory to create new pools
     * @param _farmFactory - A factory that makes farms that can stake and reward your new tokens
    ""*/
    constructor(
        address _tokenFactory,
        address _weth,
        address _misoMarket,
        address _misoLauncher,
        address _uniswapFactory,
        address _farmFactory
    ) public {
        tokenFactory = IMISOTokenFactory(_tokenFactory);
        weth = IWETH(_weth);
        misoMarket = IMISOMarket(_misoMarket);
        misoLauncher = IMisoLauncher(_misoLauncher);
        uniswapFactory = _uniswapFactory;
        farmFactory = IMISOFarmFactory(_farmFactory);

    }

    /** 
     * @dev Gateway to prepare a MISO recipe
     *   
    */
    function prepareMiso(
        string calldata _name,
        string calldata _symbol,
        address accessControl
    )
        external payable
    {
        uint256 tokensToMint = 1000;
        uint256 tokensToMarket = 300;
        // Mintable token
        ISushiToken token = ISushiToken(tokenFactory.createToken(_name, _symbol, 1, msg.sender, tokensToMint));

        token.approve(address(misoMarket), tokensToMarket);

        // Scope for adding liquidity
        uint256 templateId = misoLauncher.currentTemplateId(1);
        IPoolLiquidity poolLiquidity = IPoolLiquidity(misoLauncher.createLauncher(templateId,address(token),0,address(0),""""));

        {
        address operator = msg.sender;
        address payable wallet = msg.sender;

        uint256 duration = 1000;
        uint256 launchwindow = 100;
        uint256 deadline = 200;
        uint256 locktime = 60;
        uint256 tokensToLiquidity = 1000;

        poolLiquidity.initPoolLiquidity(accessControl,
            address(token),
            address(weth),
            uniswapFactory,
            operator,
            wallet,
            deadline,
            launchwindow,
            locktime); 
        
        token.transfer(address(poolLiquidity),tokensToLiquidity);

        }

        // Scope for creating crowdsale
        {
        uint256 startTime = block.timestamp + 5;
        uint256 endTime = block.timestamp + 100;
        uint256 marketRate = 100;
        uint256 marketGoal = 200;
        address payable wallet = msg.sender;

        IMisoCrowdsale crowdsale = IMisoCrowdsale(misoMarket.createCrowdsale(
            address(token), 
            tokensToMarket, 
            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE,
            startTime, 
            endTime, 
            marketRate,
            marketGoal, 
            address(poolLiquidity), 
            wallet, 
            2
        ));
        }

        // Scope for creating farm
        {
        address payable devAddr = msg.sender;
        uint256 tokensToFarm = 10;
        IMasterChef farm = IMasterChef(farmFactory.createFarm{value: msg.value}(
                address(token),
                1e18,  // rewardsPerBlock
                block.number + 10, // startBlock
                devAddr,
                accessControl,
                1));

        
        token.transfer(address(farm),tokensToFarm);
        uint256 allocPoint = 10;
        address lpToken = poolLiquidity.getLPTokenAddress();
        farm.addToken(allocPoint, IERC20(lpToken), false);

        }

    }

}",1377
RealWorld_TA_28_IMisoFarm_RealWorld_20240803194733.log,28,IMisoFarm,22107,1542,23649,82.0,0.141375,"pragma solidity 0.6.12;

interface IMisoFarm {

    function initFarm(
        bytes calldata data
    ) external;
    function farmTemplate() external view returns (uint256);

}",42
RealWorld_TA_28_IUniswapV2Callee_RealWorld_20240803174142.log,28,IUniswapV2Callee,21904,1125,23029,78.0,0.13202,"pragma solidity 0.6.12;

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}",46
RealWorld_TA_28_SafeCast_RealWorld_20240803191437.log,28,SafeCast,157873,1258,159131,88.0,0.814525,"pragma solidity 0.6.12;


/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library SafeCast {

    /**
     * @dev Returns the downcasted uint128 from uint256, reverting on
     * overflow (when the input is greater than largest uint128).
     *
     * Counterpart to Solidity's `uint128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     */
    function toUint128(uint256 value) internal pure returns (uint128) {
        require(value < 2**128, ""SafeCast: value doesn\'t fit in 128 bits"");
        return uint128(value);
    }

    /**
     * @dev Returns the downcasted uint64 from uint256, reverting on
     * overflow (when the input is greater than largest uint64).
     *
     * Counterpart to Solidity's `uint64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     */
    function toUint64(uint256 value) internal pure returns (uint64) {
        require(value < 2**64, ""SafeCast: value doesn\'t fit in 64 bits"");
        return uint64(value);
    }

    /**
     * @dev Returns the downcasted uint32 from uint256, reverting on
     * overflow (when the input is greater than largest uint32).
     *
     * Counterpart to Solidity's `uint32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     */
    function toUint32(uint256 value) internal pure returns (uint32) {
        require(value < 2**32, ""SafeCast: value doesn\'t fit in 32 bits"");
        return uint32(value);
    }

    /**
     * @dev Returns the downcasted uint16 from uint256, reverting on
     * overflow (when the input is greater than largest uint16).
     *
     * Counterpart to Solidity's `uint16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     */
    function toUint16(uint256 value) internal pure returns (uint16) {
        require(value < 2**16, ""SafeCast: value doesn\'t fit in 16 bits"");
        return uint16(value);
    }

    /**
     * @dev Returns the downcasted uint8 from uint256, reverting on
     * overflow (when the input is greater than largest uint8).
     *
     * Counterpart to Solidity's `uint8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     */
    function toUint8(uint256 value) internal pure returns (uint8) {
        require(value < 2**8, ""SafeCast: value doesn\'t fit in 8 bits"");
        return uint8(value);
    }

    /**
     * @dev Converts a signed int256 into an unsigned uint256.
     *
     * Requirements:
     *
     * - input must be greater than or equal to 0.
     */
    function toUint256(int256 value) internal pure returns (uint256) {
        require(value >= 0, ""SafeCast: value must be positive"");
        return uint256(value);
    }

    /**
     * @dev Returns the downcasted int128 from int256, reverting on
     * overflow (when the input is less than smallest int128 or
     * greater than largest int128).
     *
     * Counterpart to Solidity's `int128` operator.
     *
     * Requirements:
     *
     * - input must fit into 128 bits
     *
     * _Available since v3.1._
     */
    function toInt128(int256 value) internal pure returns (int128) {
        require(value >= -2**127 && value < 2**127, ""SafeCast: value doesn\'t fit in 128 bits"");
        return int128(value);
    }

    /**
     * @dev Returns the downcasted int64 from int256, reverting on
     * overflow (when the input is less than smallest int64 or
     * greater than largest int64).
     *
     * Counterpart to Solidity's `int64` operator.
     *
     * Requirements:
     *
     * - input must fit into 64 bits
     *
     * _Available since v3.1._
     */
    function toInt64(int256 value) internal pure returns (int64) {
        require(value >= -2**63 && value < 2**63, ""SafeCast: value doesn\'t fit in 64 bits"");
        return int64(value);
    }

    /**
     * @dev Returns the downcasted int32 from int256, reverting on
     * overflow (when the input is less than smallest int32 or
     * greater than largest int32).
     *
     * Counterpart to Solidity's `int32` operator.
     *
     * Requirements:
     *
     * - input must fit into 32 bits
     *
     * _Available since v3.1._
     */
    function toInt32(int256 value) internal pure returns (int32) {
        require(value >= -2**31 && value < 2**31, ""SafeCast: value doesn\'t fit in 32 bits"");
        return int32(value);
    }

    /**
     * @dev Returns the downcasted int16 from int256, reverting on
     * overflow (when the input is less than smallest int16 or
     * greater than largest int16).
     *
     * Counterpart to Solidity's `int16` operator.
     *
     * Requirements:
     *
     * - input must fit into 16 bits
     *
     * _Available since v3.1._
     */
    function toInt16(int256 value) internal pure returns (int16) {
        require(value >= -2**15 && value < 2**15, ""SafeCast: value doesn\'t fit in 16 bits"");
        return int16(value);
    }

    /**
     * @dev Returns the downcasted int8 from int256, reverting on
     * overflow (when the input is less than smallest int8 or
     * greater than largest int8).
     *
     * Counterpart to Solidity's `int8` operator.
     *
     * Requirements:
     *
     * - input must fit into 8 bits.
     *
     * _Available since v3.1._
     */
    function toInt8(int256 value) internal pure returns (int8) {
        require(value >= -2**7 && value < 2**7, ""SafeCast: value doesn\'t fit in 8 bits"");
        return int8(value);
    }

    /**
     * @dev Converts an unsigned uint256 into a signed int256.
     *
     * Requirements:
     *
     * - input must be less than or equal to maxInt256.
     */
    function toInt256(uint256 value) internal pure returns (int256) {
        require(value < 2**255, ""SafeCast: value doesn't fit in an int256"");
        return int256(value);
    }
}",1685
RealWorld_TA_28_Arrays_RealWorld_20240803190720.log,28,Arrays,46976,1398,48374,80.0,0.26284,"pragma solidity 0.6.12;

import ""../math/Math.sol"";

/**
 * @dev Collection of functions related to array types.
 */
library Arrays {
   /**
     * @dev Searches a sorted `array` and returns the first index that contains
     * a value greater or equal to `element`. If no such index exists (i.e. all
     * values in the array are strictly less than `element`), the array length is
     * returned. Time complexity O(log n).
     *
     * `array` is expected to be sorted in ascending order, and to contain no
     * repeated elements.
     */
    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid] > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1] == element) {
            return low - 1;
        } else {
            return low;
        }
    }
}",337
RealWorld_TA_28_IMisoMarket_RealWorld_20240803194857.log,28,IMisoMarket,22578,1382,23960,82.0,0.14053,"pragma solidity 0.6.12;

interface IMisoMarket {

    function init(bytes calldata data) external payable;
    function initMarket( bytes calldata data ) external;
    function marketTemplate() external view returns (uint256);

}",50
RealWorld_TA_28_UniswapV2Pair_RealWorld_20240803172229.log,28,UniswapV2Pair,242628,6613,249241,152.0,1.3454,"pragma solidity =0.6.12;

import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';


interface IMigrator {
    // Return the desired amount of liquidity token that the migrator wants.
    function desiredLiquidity() external view returns (uint256);
}

contract UniswapV2Pair is UniswapV2ERC20 {
    using SafeMathUniswap  for uint;
    using UQ112x112 for uint224;

    uint public constant MINIMUM_LIQUIDITY = 10**3;
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));

    address public factory;
    address public token0;
    address public token1;

    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

    uint private unlocked = 1;
    modifier lock() {
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
        _;
        unlocked = 1;
    }

    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    constructor() public {
        factory = msg.sender;
    }

    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }

    // update reserves and, on the first call per block, price accumulators
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            // * never overflows, and + overflow is desired
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }

    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
        address feeTo = IUniswapV2Factory(factory).feeTo();
        feeOn = feeTo != address(0);
        uint _kLast = kLast; // gas savings
        if (feeOn) {
            if (_kLast != 0) {
                uint rootK = MathUniswap.sqrt(uint(_reserve0).mul(_reserve1));
                uint rootKLast = MathUniswap.sqrt(_kLast);
                if (rootK > rootKLast) {
                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                    uint denominator = rootK.mul(5).add(rootKLast);
                    uint liquidity = numerator / denominator;
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }

    // this low-level function should be called from a contract which performs important safety checks
    function mint(address to) external lock returns (uint liquidity) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));
        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            address migrator = IUniswapV2Factory(factory).migrator();
            if (msg.sender == migrator) {
                liquidity = IMigrator(migrator).desiredLiquidity();
                require(liquidity > 0 && liquidity != uint256(-1), ""Bad desired liquidity"");
            } else {
                require(migrator == address(0), ""Must not have migrator"");
                liquidity = MathUniswap.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
            }
        } else {
            liquidity = MathUniswap.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
        }
        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
        _mint(to, liquidity);

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Mint(msg.sender, amount0, amount1);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to) external lock returns (uint amount0, uint amount1) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        address _token0 = token0;                                // gas savings
        address _token1 = token1;                                // gas savings
        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));
        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));
        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Burn(msg.sender, amount0, amount1, to);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));
        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));
        }
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }

    // force balances to match reserves
    function skim(address to) external lock {
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        _safeTransfer(_token0, to, IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0));
        _safeTransfer(_token1, to, IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1));
    }

    // force reserves to match balances
    function sync() external lock {
        _update(IERC20Uniswap(token0).balanceOf(address(this)), IERC20Uniswap(token1).balanceOf(address(this)), reserve0, reserve1);
    }
}",2688
RealWorld_TA_28_MISOHelper_RealWorld_20240803183358.log,28,MISOHelper,477906,3848,481754,153.0,2.46649,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""../Access/MISOAccessControls.sol"";

//==================
//    Uniswap V2       
//==================

interface IUniswapFactory {
    function getPair(address token0, address token1) external view returns (address);
}

interface IUniswapPair {
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner) external view returns (uint);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);
}

//==================
//    Documents       
//==================

interface IDocument {
    function getDocument(string calldata _name) external view returns (string memory, uint256);
    function getDocumentCount() external view returns (uint256);
    function getDocumentName(uint256 index) external view returns (string memory);    
}

contract DocumentHepler {
    struct Document {
        string name;
        string data;
        uint256 lastModified;
    }

    function getDocuments(address _document) public view returns(Document[] memory) {
        IDocument document = IDocument(_document);
        uint256 documentCount = document.getDocumentCount();

        Document[] memory documents = new Document[](documentCount);

        for(uint256 i = 0; i < documentCount; i++) {
            string memory documentName = document.getDocumentName(i);
            (
                documents[i].data,
                documents[i].lastModified
            ) = document.getDocument(documentName);
            documents[i].name = documentName;
        }
        return documents;
    }
}


//==================
//     Tokens
//==================

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}

interface IMisoTokenFactory {
    function getTokens() external view returns (address[] memory);
    function tokens(uint256) external view returns (address);
    function numberOfTokens() external view returns (uint256);
} 

contract TokenHelper {
    struct TokenInfo {
        address addr;
        uint256 decimals;
        string name;
        string symbol;
    }

    function getTokensInfo(address[] memory addresses) public view returns (TokenInfo[] memory)
    {
        TokenInfo[] memory infos = new TokenInfo[](addresses.length);

        for (uint256 i = 0; i < addresses.length; i++) {
            infos[i] = getTokenInfo(addresses[i]);
        }

        return infos;
    }

    function getTokenInfo(address _address) public view returns (TokenInfo memory) {
        TokenInfo memory info;
        IERC20 token = IERC20(_address);

        info.addr = _address;
        info.name = token.name();
        info.symbol = token.symbol();
        info.decimals = token.decimals();

        return info;
    }

    function allowance(address _token, address _owner, address _spender) public view returns(uint256) {
        return IERC20(_token).allowance(_owner, _spender);
    }

}


//==================
//      Base
//==================

contract BaseHelper {
    IMisoMarketFactory public market;
    IMisoTokenFactory public tokenFactory;
    IMisoFarmFactory public farmFactory;
    address public launcher;

    /// @notice Responsible for access rights to the contract
    MISOAccessControls public accessControls;

    function setContracts(
        address _tokenFactory,
        address _market,
        address _launcher,
        address _farmFactory
    ) public {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOHelper: Sender must be Admin""
        );
        if (_market != address(0)) {
            market = IMisoMarketFactory(_market);
        }
        if (_tokenFactory != address(0)) {
            tokenFactory = IMisoTokenFactory(_tokenFactory);
        }
        if (_launcher != address(0)) {
            launcher = _launcher;
        }
        if (_farmFactory != address(0)) {
            farmFactory = IMisoFarmFactory(_farmFactory);
        }
    }
}


//==================
//      Farms       
//==================

interface IMisoFarmFactory {
    function getTemplateId(address _farm) external view returns(uint256);
    function numberOfFarms() external view returns(uint256);
    function farms(uint256 _farmId) external view returns(address);
}

interface IFarm {
    function poolInfo(uint256 pid) external view returns(
        address lpToken,
        uint256 allocPoint,
        uint256 lastRewardBlock,
        uint256 accRewardsPerShare
    );
    function rewards() external view returns(address);
    function poolLength() external view returns (uint256);
    function rewardsPerBlock() external view returns (uint256);
    function bonusMultiplier() external view returns (uint256);
    function userInfo(uint256 pid, address _user) external view returns (uint256, uint256);
    function pendingRewards(uint256 _pid, address _user) external view returns (uint256);
}

contract FarmHelper is BaseHelper, TokenHelper {
    struct FarmInfo {
        address addr;
        uint256 templateId;
        uint256 rewardsPerBlock;
        uint256 bonusMultiplier;
        TokenInfo rewardToken;
        PoolInfo[] pools;
    }

    struct PoolInfo {
        address lpToken;
        uint256 allocPoint;
        uint256 lastRewardBlock;
        uint256 accRewardsPerShare;
        uint256 totalStaked;
        TokenInfo stakingToken;
    }

    struct UserPoolInfo {
        address farm;
        uint256 pid;
        uint256 totalStaked;
        uint256 lpBalance;
        uint256 lpAllowance;
        uint256 rewardDebt;
        uint256 pendingRewards;
    }

    struct UserPoolsInfo {
        address farm;
        uint256[] pids;
        uint256[] totalStaked;
        uint256[] pendingRewards;
    }

    function getPools(address _farm) public view returns(PoolInfo[] memory) {
        IFarm farm = IFarm(_farm);
        uint256 poolLength = farm.poolLength();
        PoolInfo[] memory pools = new PoolInfo[](poolLength);
        
        for(uint256 i = 0; i < poolLength; i++) {
            (
                pools[i].lpToken,
                pools[i].allocPoint,
                pools[i].lastRewardBlock,
                pools[i].accRewardsPerShare
            ) = farm.poolInfo(i);
            pools[i].totalStaked = IERC20(pools[i].lpToken).balanceOf(_farm);
            pools[i].stakingToken = getTokenInfo(pools[i].lpToken);
        }
        return pools;
    }


    function getFarms() public view returns(FarmInfo[] memory) {
        uint256 numberOfFarms = farmFactory.numberOfFarms();

        FarmInfo[] memory infos = new FarmInfo[](numberOfFarms);

        for (uint256 i = 0; i < numberOfFarms; i++) {
            address farmAddr = farmFactory.farms(i);
            uint256 templateId = farmFactory.getTemplateId(farmAddr);
            infos[i] = _farmInfo(farmAddr);
        }

        return infos;
    }

    function getFarms(
        uint256 pageSize,
        uint256 pageNbr,
        uint256 offset
    ) public view returns(FarmInfo[] memory) {
        uint256 numberOfFarms = farmFactory.numberOfFarms();
        uint256 startIdx = (pageNbr * pageSize) + offset;
        uint256 endIdx = startIdx + pageSize;

        FarmInfo[] memory infos;

        if (endIdx > numberOfFarms) {
            endIdx = numberOfFarms;
        }
        if(endIdx < startIdx) {
            return infos;
        }
        infos = new FarmInfo[](endIdx - startIdx);

        for (uint256 farmIdx = 0; farmIdx + startIdx < endIdx; farmIdx++) {
            address farmAddr = farmFactory.farms(farmIdx + startIdx);
            infos[farmIdx] = _farmInfo(farmAddr);
        }

        return infos;
    }

    function getFarms(
        uint256 pageSize,
        uint256 pageNbr
    ) public view returns(FarmInfo[] memory) {
        return getFarms(pageSize, pageNbr, 0);
    }

    function _farmInfo(address _farmAddr) private view returns(FarmInfo memory farmInfo) {
            IFarm farm = IFarm(_farmAddr);

            farmInfo.addr = _farmAddr;
            farmInfo.templateId = farmFactory.getTemplateId(_farmAddr);
            farmInfo.rewardsPerBlock = farm.rewardsPerBlock();
            farmInfo.bonusMultiplier = farm.bonusMultiplier();
            farmInfo.rewardToken = getTokenInfo(farm.rewards());
            farmInfo.pools = getPools(_farmAddr);
    }

    function getFarmDetail(address _farm, address _user) 
        public
        view
        returns(FarmInfo memory farmInfo, UserPoolInfo[] memory userInfos) 
    {
        IFarm farm = IFarm(_farm);
        farmInfo.addr = _farm;
        farmInfo.templateId = farmFactory.getTemplateId(_farm);
        farmInfo.rewardsPerBlock = farm.rewardsPerBlock();
        farmInfo.bonusMultiplier = farm.bonusMultiplier();
        farmInfo.rewardToken = getTokenInfo(farm.rewards());
        farmInfo.pools = getPools(_farm);

        if(_user != address(0)) {
            PoolInfo[] memory pools = farmInfo.pools;
            userInfos = new UserPoolInfo[](pools.length);
            for(uint i = 0; i < pools.length; i++) {
                UserPoolInfo memory userInfo = userInfos[i];
                address stakingToken = pools[i].stakingToken.addr;
                (userInfo.totalStaked, userInfo.rewardDebt) = farm.userInfo(i, _user);
                userInfo.lpBalance = IERC20(stakingToken).balanceOf(_user);
                userInfo.lpAllowance = IERC20(stakingToken).allowance(_user, _farm);
                userInfo.pendingRewards = farm.pendingRewards(i, _user);
                (userInfo.totalStaked,) = farm.userInfo(i, _user);
                userInfo.farm = _farm;
                userInfo.pid = i;
                userInfos[i] = userInfo;
            }
        }
        return (farmInfo, userInfos);
    }

    function getUserPoolsInfos(address _user) public view returns(UserPoolsInfo[] memory) {
        uint256 numberOfFarms = farmFactory.numberOfFarms();

        UserPoolsInfo[] memory infos = new UserPoolsInfo[](numberOfFarms);

        for (uint256 i = 0; i < numberOfFarms; i++) {
            address farmAddr = farmFactory.farms(i);
            IFarm farm = IFarm(farmAddr);
            uint256 poolLength = farm.poolLength();
            uint256[] memory totalStaked = new uint256[](poolLength);
            uint256[] memory pendingRewards = new uint256[](poolLength);
            uint256[] memory pids = new uint256[](poolLength);

            for(uint256 j = 0; j < poolLength; j++) {
                (address stakingToken,,,) = farm.poolInfo(j);
                (totalStaked[j],) = farm.userInfo(j, _user);
                pendingRewards[j] = farm.pendingRewards(j, _user);
                pids[j] = j;
            }
            infos[i].totalStaked = totalStaked;
            infos[i].pendingRewards = pendingRewards;
            infos[i].pids = pids;
            infos[i].farm = farmAddr;
        }
        return infos;
    }
}

//==================
//     Markets       
//==================

interface IBaseAuction {
    function getBaseInformation() external view returns (
            address auctionToken,
            uint64 startTime,
            uint64 endTime,
            bool finalized
        );
}

interface IMisoMarketFactory {
    function getMarketTemplateId(address _auction) external view returns(uint64);
    function getMarkets() external view returns(address[] memory);
    function numberOfAuctions() external view returns(uint256);
    function auctions(uint256) external view returns(address);
}

interface IMisoMarket {
    function paymentCurrency() external view returns (address) ;
    function auctionToken() external view returns (address) ;
    function marketPrice() external view returns (uint128, uint128);
    function marketInfo()
        external
        view
        returns (
        uint64 startTime,
        uint64 endTime,
        uint128 totalTokens
        );
    function auctionSuccessful() external view returns (bool);
    function commitments(address user) external view returns (uint256);
    function claimed(address user) external view returns (uint256);
    function tokensClaimable(address user) external view returns (uint256);
    function hasAdminRole(address user) external view returns (bool);
}

interface ICrowdsale is IMisoMarket {
    function marketStatus() external view returns(
        uint128 commitmentsTotal,
        bool finalized,
        bool usePointList
    );
}

interface IDutchAuction is IMisoMarket {
    function marketStatus() external view returns(
        uint128 commitmentsTotal,
        bool finalized,
        bool usePointList
    );
    // function totalTokensCommitted() external view returns (uint256);
    // function clearingPrice() external view returns (uint256);
}

interface IBatchAuction is IMisoMarket {
    function marketStatus() external view returns(
        uint256 commitmentsTotal,
        uint256 minimumCommitmentAmount,
        bool finalized,
        bool usePointList
    );
}

interface IHyperbolicAuction is IMisoMarket {
    function marketStatus() external view returns(
        uint128 commitmentsTotal,
        bool finalized,
        bool usePointList
    );
}

contract MarketHelper is BaseHelper, TokenHelper, DocumentHepler {

    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    struct CrowdsaleInfo {
        address addr;
        address paymentCurrency;
        uint128 commitmentsTotal;
        uint128 totalTokens;
        uint128 rate;
        uint128 goal;
        uint64 startTime;
        uint64 endTime;
        bool finalized;
        bool usePointList;
        bool auctionSuccessful;
        TokenInfo tokenInfo;
        TokenInfo paymentCurrencyInfo;
        Document[] documents;
    }

    struct DutchAuctionInfo {
        address addr;
        address paymentCurrency;
        uint64 startTime;
        uint64 endTime;
        uint128 totalTokens;
        uint128 startPrice;
        uint128 minimumPrice;
        uint128 commitmentsTotal;
        // uint256 totalTokensCommitted;
        bool finalized;
        bool usePointList;
        bool auctionSuccessful;
        TokenInfo tokenInfo;
        TokenInfo paymentCurrencyInfo;
        Document[] documents;
    }

    struct BatchAuctionInfo {
        address addr;
        address paymentCurrency;
        uint64 startTime;
        uint64 endTime;
        uint128 totalTokens;
        uint256 commitmentsTotal;
        uint256 minimumCommitmentAmount;
        bool finalized;
        bool usePointList;
        bool auctionSuccessful;
        TokenInfo tokenInfo;
        TokenInfo paymentCurrencyInfo;
        Document[] documents;
    }

    struct HyperbolicAuctionInfo {
        address addr;
        address paymentCurrency;
        uint64 startTime;
        uint64 endTime;
        uint128 totalTokens;
        uint128 minimumPrice;
        uint128 alpha;
        uint128 commitmentsTotal;
        bool finalized;
        bool usePointList;
        bool auctionSuccessful;
        TokenInfo tokenInfo;
        TokenInfo paymentCurrencyInfo;
        Document[] documents;
    }

    struct MarketBaseInfo {
        address addr;
        uint64 templateId;
        uint64 startTime;
        uint64 endTime;
        bool finalized;
        TokenInfo tokenInfo;
    }

    struct PLInfo {
        TokenInfo token0;
        TokenInfo token1;
        address pairToken;
        address operator;
        uint256 locktime;
        uint256 unlock;
        uint256 deadline;
        uint256 launchwindow;
        uint256 expiry;
        uint256 liquidityAdded;
        uint256 launched;
    }

    struct UserMarketInfo {
        uint256 commitments;
        uint256 tokensClaimable;
        uint256 claimed;
        bool isAdmin;
    }

    function getMarkets(
        uint256 pageSize,
        uint256 pageNbr,
        uint256 offset
    ) public view returns (MarketBaseInfo[] memory) {
        uint256 marketsLength = market.numberOfAuctions();
        uint256 startIdx = (pageNbr * pageSize) + offset;
        uint256 endIdx = startIdx + pageSize;
        MarketBaseInfo[] memory infos;
        if (endIdx > marketsLength) {
            endIdx = marketsLength;
        }
        if(endIdx < startIdx) {
            return infos;
        }
        infos = new MarketBaseInfo[](endIdx - startIdx);

        for (uint256 marketIdx = 0; marketIdx + startIdx < endIdx; marketIdx++) {
            address marketAddress = market.auctions(marketIdx + startIdx);
            infos[marketIdx] = _getMarketInfo(marketAddress);
        }

        return infos;
    }

    function getMarkets(
        uint256 pageSize,
        uint256 pageNbr
    ) public view returns (MarketBaseInfo[] memory) {
        return getMarkets(pageSize, pageNbr, 0);
    }

    function getMarkets() public view returns (MarketBaseInfo[] memory) {
        address[] memory markets = market.getMarkets();
        MarketBaseInfo[] memory infos = new MarketBaseInfo[](markets.length);

        for (uint256 i = 0; i < markets.length; i++) {
            MarketBaseInfo memory marketInfo = _getMarketInfo(markets[i]);
            infos[i] = marketInfo;
        }

        return infos;
    }

    function _getMarketInfo(address _marketAddress) private view returns (MarketBaseInfo memory marketInfo) {
            uint64 templateId = market.getMarketTemplateId(_marketAddress);
            address auctionToken;
            uint64 startTime;
            uint64 endTime;
            bool finalized;
            (auctionToken, startTime, endTime, finalized) = IBaseAuction(_marketAddress)
                .getBaseInformation();
            TokenInfo memory tokenInfo = getTokenInfo(auctionToken);

            marketInfo.addr = _marketAddress;
            marketInfo.templateId = templateId;
            marketInfo.startTime = startTime;
            marketInfo.endTime = endTime;
            marketInfo.finalized = finalized;
            marketInfo.tokenInfo = tokenInfo;  
    }

    function getCrowdsaleInfo(address _crowdsale) public view returns (CrowdsaleInfo memory) {
        ICrowdsale crowdsale = ICrowdsale(_crowdsale);
        CrowdsaleInfo memory info;

        info.addr = address(crowdsale);
        (info.commitmentsTotal, info.finalized, info.usePointList) = crowdsale.marketStatus();
        (info.startTime, info.endTime, info.totalTokens) = crowdsale.marketInfo();
        (info.rate, info.goal) = crowdsale.marketPrice();
        (info.auctionSuccessful) = crowdsale.auctionSuccessful();
        info.tokenInfo = getTokenInfo(crowdsale.auctionToken());

        address paymentCurrency = crowdsale.paymentCurrency();
        TokenInfo memory paymentCurrencyInfo;
        if(paymentCurrency == ETH_ADDRESS) {
            paymentCurrencyInfo = _getETHInfo();
        } else {
            paymentCurrencyInfo = getTokenInfo(paymentCurrency);
        }
        info.paymentCurrencyInfo = paymentCurrencyInfo;

        info.documents = getDocuments(_crowdsale);

        return info;
    }

    function getDutchAuctionInfo(address payable _dutchAuction) public view returns (DutchAuctionInfo memory)
    {
        IDutchAuction dutchAuction = IDutchAuction(_dutchAuction);
        DutchAuctionInfo memory info;

        info.addr = address(dutchAuction);
        (info.startTime, info.endTime, info.totalTokens) = dutchAuction.marketInfo();
        (info.startPrice, info.minimumPrice) = dutchAuction.marketPrice();
        (info.auctionSuccessful) = dutchAuction.auctionSuccessful();
        (
            info.commitmentsTotal,
            info.finalized,
            info.usePointList
        ) = dutchAuction.marketStatus();
        info.tokenInfo = getTokenInfo(dutchAuction.auctionToken());

        address paymentCurrency = dutchAuction.paymentCurrency();
        TokenInfo memory paymentCurrencyInfo;
        if(paymentCurrency == ETH_ADDRESS) {
            paymentCurrencyInfo = _getETHInfo();
        } else {
            paymentCurrencyInfo = getTokenInfo(paymentCurrency);
        }
        info.paymentCurrencyInfo = paymentCurrencyInfo;
        info.documents = getDocuments(_dutchAuction);

        return info;
    }

    function getBatchAuctionInfo(address payable _batchAuction) public view returns (BatchAuctionInfo memory) 
    {
        IBatchAuction batchAuction = IBatchAuction(_batchAuction);
        BatchAuctionInfo memory info;
        
        info.addr = address(batchAuction);
        (info.startTime, info.endTime, info.totalTokens) = batchAuction.marketInfo();
        (info.auctionSuccessful) = batchAuction.auctionSuccessful();
        (
            info.commitmentsTotal,
            info.minimumCommitmentAmount,
            info.finalized,
            info.usePointList
        ) = batchAuction.marketStatus();
        info.tokenInfo = getTokenInfo(batchAuction.auctionToken());
        address paymentCurrency = batchAuction.paymentCurrency();
        TokenInfo memory paymentCurrencyInfo;
        if(paymentCurrency == ETH_ADDRESS) {
            paymentCurrencyInfo = _getETHInfo();
        } else {
            paymentCurrencyInfo = getTokenInfo(paymentCurrency);
        }
        info.paymentCurrencyInfo = paymentCurrencyInfo;
        info.documents = getDocuments(_batchAuction);

        return info;
    }

    function getHyperbolicAuctionInfo(address payable _hyperbolicAuction) public view returns (HyperbolicAuctionInfo memory)
    {
        IHyperbolicAuction hyperbolicAuction = IHyperbolicAuction(_hyperbolicAuction);
        HyperbolicAuctionInfo memory info;

        info.addr = address(hyperbolicAuction);
        (info.startTime, info.endTime, info.totalTokens) = hyperbolicAuction.marketInfo();
        (info.minimumPrice, info.alpha) = hyperbolicAuction.marketPrice();
        (info.auctionSuccessful) = hyperbolicAuction.auctionSuccessful();
        (
            info.commitmentsTotal,
            info.finalized,
            info.usePointList
        ) = hyperbolicAuction.marketStatus();
        info.tokenInfo = getTokenInfo(hyperbolicAuction.auctionToken());
        
        address paymentCurrency = hyperbolicAuction.paymentCurrency();
        TokenInfo memory paymentCurrencyInfo;
        if(paymentCurrency == ETH_ADDRESS) {
            paymentCurrencyInfo = _getETHInfo();
        } else {
            paymentCurrencyInfo = getTokenInfo(paymentCurrency);
        }
        info.paymentCurrencyInfo = paymentCurrencyInfo;
        info.documents = getDocuments(_hyperbolicAuction);

        return info;
    }

    function getUserMarketInfo(address _action, address _user) public view returns(UserMarketInfo memory userInfo) {
        IMisoMarket market = IMisoMarket(_action);
        userInfo.commitments = market.commitments(_user);
        userInfo.tokensClaimable = market.tokensClaimable(_user);
        userInfo.claimed = market.claimed(_user);
        userInfo.isAdmin = market.hasAdminRole(_user);
    }

    function _getETHInfo() private pure returns(TokenInfo memory token) {
            token.addr = ETH_ADDRESS;
            token.name = ""ETHEREUM"";
            token.symbol = ""ETH"";
            token.decimals = 18;
    }

}

contract MISOHelper is MarketHelper, FarmHelper {

    constructor(
        address _accessControls,
        address _tokenFactory,
        address _market,
        address _launcher,
        address _farmFactory
    ) public { 
        require(_accessControls != address(0));
        accessControls = MISOAccessControls(_accessControls);
        tokenFactory = IMisoTokenFactory(_tokenFactory);
        market = IMisoMarketFactory(_market);
        launcher = _launcher;
        farmFactory = IMisoFarmFactory(_farmFactory);
    }

    function getTokens() public view returns(TokenInfo[] memory) {
        address[] memory tokens = tokenFactory.getTokens();
        TokenInfo[] memory infos = getTokensInfo(tokens);

        infos = getTokensInfo(tokens);

        return infos;
    }

    function getTokens(
        uint256 pageSize,
        uint256 pageNbr,
        uint256 offset
    ) public view returns(TokenInfo[] memory) {
        uint256 tokensLength = tokenFactory.numberOfTokens();

        uint256 startIdx = (pageNbr * pageSize) + offset;
        uint256 endIdx = startIdx + pageSize;
        TokenInfo[] memory infos;
        if (endIdx > tokensLength) {
            endIdx = tokensLength;
        }
        if(endIdx < startIdx) {
            return infos;
        }
        infos = new TokenInfo[](endIdx - startIdx);

        for (uint256 tokenIdx = 0; tokenIdx + startIdx < endIdx; tokenIdx++) {
            address tokenAddress = tokenFactory.tokens(tokenIdx + startIdx);
            infos[tokenIdx] = getTokenInfo(tokenAddress);
        }

        return infos;
    }

    function getTokens(
        uint256 pageSize,
        uint256 pageNbr
    ) public view returns(TokenInfo[] memory) {
        return getTokens(pageSize, pageNbr, 0);
    }

}",5477
RealWorld_TA_28_MISOTokenFactory_RealWorld_20240803170845.log,28,MISOTokenFactory,261291,5330,266621,141.0,1.413055,"pragma solidity 0.6.12;

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's MISO Token Factory
//
// A factory to conveniently deploy your own source code verified  token contracts
//
// Inspired by Bokky's EtherVendingMachince.io
// https://github.com/bokkypoobah/FixedSupplyTokenFactory
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------


import ""./Utils/CloneFactory.sol"";
import ""./interfaces/IMisoToken.sol"";
import ""./Access/MISOAccessControls.sol"";
import ""./Utils/SafeTransfer.sol"";
import ""./interfaces/IERC20.sol"";

contract MISOTokenFactory is CloneFactory, SafeTransfer{
    
    /// @notice Responsible for access rights to the contract
    MISOAccessControls public accessControls;
    bytes32 public constant TOKEN_MINTER_ROLE = keccak256(""TOKEN_MINTER_ROLE"");

    /// @notice Whether token factory has been initialized or not.
    bool private initialised;

    /// @notice Struct to track Token template.
    struct Token {
        bool exists;
        uint256 templateId;
        uint256 index;
    }

    /// @notice Mapping from auction address created through this contract to Auction struct.
    mapping(address => Token) public tokenInfo;

    /// @notice Array of tokens created using the factory.
    address[] public tokens;

    /// @notice Template id to track respective token template.
    uint256 public tokenTemplateId;

    /// @notice Mapping from token template id to token template address.
    mapping(uint256 => address) private tokenTemplates;

    /// @notice mapping from token template address to token template id
    mapping(address => uint256) private tokenTemplateToId;

    /// @notice mapping from template type to template id
    mapping(uint256 => uint256) public currentTemplateId;

    /// @notice Minimum fee to create a token through the factory.
    uint256 public minimumFee;
    uint256 public integratorFeePct;

    /// @notice Contract locked status. If locked, only minters can deploy
    bool public locked;

    /// @notice Any MISO dividends collected are sent here.
    address payable public misoDiv;

    /// @notice Event emitted when first initializing Miso Token Factory.
    event MisoInitTokenFactory(address sender);

    /// @notice Event emitted when a token is created using template id.
    event TokenCreated(address indexed owner, address indexed addr, address tokenTemplate);
    
    /// @notice event emitted when a token is initialized using template id
    event TokenInitialized(address indexed addr, uint256 templateId, bytes data);

    /// @notice Event emitted when a token template is added.
    event TokenTemplateAdded(address newToken, uint256 templateId);

    /// @notice Event emitted when a token template is removed.
    event TokenTemplateRemoved(address token, uint256 templateId);

    constructor() public {
    }

    /**
     * @notice Single gateway to initialize the MISO Token Factory with proper address.
     * @dev Can only be initialized once.
     * @param _accessControls Sets address to get the access controls from.
     */
    /// @dev GP: Migrate to the BentoBox.
    function initMISOTokenFactory(address _accessControls) external  {
        require(!initialised);
        initialised = true;
        locked = true;
        accessControls = MISOAccessControls(_accessControls);
        emit MisoInitTokenFactory(msg.sender);
    }

    /**
     * @notice Sets the minimum fee.
     * @param _amount Fee amount.
     */
    function setMinimumFee(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOTokenFactory: Sender must be operator""
        );
        minimumFee = _amount;
    }

    /**
     * @notice Sets integrator fee percentage.
     * @param _amount Percentage amount.
     */
    function setIntegratorFeePct(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOTokenFactory: Sender must be operator""
        );
        /// @dev this is out of 1000, ie 25% = 250
        require(
            _amount <= 1000, 
            ""MISOTokenFactory: Range is from 0 to 1000""
        );
        integratorFeePct = _amount;
    }

    /**
     * @notice Sets dividend address.
     * @param _divaddr Dividend address.
     */
    function setDividends(address payable _divaddr) external  {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOTokenFactory: Sender must be operator""
        );
        require(_divaddr != address(0));
        misoDiv = _divaddr;
    }    
    
    /**
     * @notice Sets the factory to be locked or unlocked.
     * @param _locked bool.
     */
    function setLocked(bool _locked) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOTokenFactory: Sender must be admin""
        );
        locked = _locked;
    }


    /**
     * @notice Sets the current template ID for any type.
     * @param _templateType Type of template.
     * @param _templateId The ID of the current template for that type
     */
    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOTokenFactory: Sender must be admin""
        );
        require(tokenTemplates[_templateId] != address(0), ""MISOMarket: incorrect _templateId"");
        require(IMisoToken(tokenTemplates[_templateId]).tokenTemplate() == _templateType, ""MISOMarket: incorrect _templateType"");
        currentTemplateId[_templateType] = _templateId;
    }

    /**
     * @notice Used to check whether an address has the minter role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasTokenMinterRole(address _address) public view returns (bool) {
        return accessControls.hasRole(TOKEN_MINTER_ROLE, _address);
    }



    /**
     * @notice Creates a token corresponding to template id and transfers fees.
     * @dev Initializes token with parameters passed
     * @param _templateId Template id of token to create.
     * @param _integratorFeeAccount Address to pay the fee to.
     * @return token Token address.
     */
    function deployToken(
        uint256 _templateId,
        address payable _integratorFeeAccount
    )
        public payable returns (address token)
    {
        /// @dev If the contract is locked, only admin and minters can deploy. 
        if (locked) {
            require(accessControls.hasAdminRole(msg.sender) 
                    || accessControls.hasMinterRole(msg.sender)
                    || hasTokenMinterRole(msg.sender),
                ""MISOTokenFactory: Sender must be minter if locked""
            );
        }
        require(msg.value >= minimumFee, ""MISOTokenFactory: Failed to transfer minimumFee"");
        require(tokenTemplates[_templateId] != address(0));
        uint256 integratorFee = 0;
        uint256 misoFee = msg.value;
        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {
            integratorFee = misoFee * integratorFeePct / 1000;
            misoFee = misoFee - integratorFee;
        }
        token = createClone(tokenTemplates[_templateId]);
        /// @dev GP: Triple check the token index is correct.
        tokenInfo[token] = Token(true, _templateId, tokens.length);
        tokens.push(token);
        emit TokenCreated(msg.sender, token, tokenTemplates[_templateId]);
        if (misoFee > 0) {
            misoDiv.transfer(misoFee);
        }
        if (integratorFee > 0) {
            _integratorFeeAccount.transfer(integratorFee);
        }
    }

    /**
     * @notice Creates a token corresponding to template id.
     * @dev Initializes token with parameters passed.
     * @param _templateId Template id of token to create.
     * @param _integratorFeeAccount Address to pay the fee to.
     * @param _data Data to be passed to the token contract for init.
     * @return token Token address.
     */
    function createToken(
        uint256 _templateId,
        address payable _integratorFeeAccount,
        bytes calldata _data
    )
        external payable returns (address token)
    {
        emit TokenInitialized(address(token), _templateId, _data);
        token = deployToken(_templateId, _integratorFeeAccount);
        IMisoToken(token).initToken(_data);
        uint256 initialTokens = IERC20(token).balanceOf(address(this));
        if (initialTokens > 0 ) {
            _safeTransfer(token, msg.sender, initialTokens);
        }
    }

    /**
     * @notice Function to add a token template to create through factory.
     * @dev Should have operator access.
     * @param _template Token template to create a token.
     */
    function addTokenTemplate(address _template) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOTokenFactory: Sender must be operator""
        );
        uint256 templateType = IMisoToken(_template).tokenTemplate();
        require(templateType > 0, ""MISOLauncher: Incorrect template code "");
        require(tokenTemplateToId[_template] == 0, ""MISOTokenFactory: Template exists"");
        tokenTemplateId++;
        tokenTemplates[tokenTemplateId] = _template;
        tokenTemplateToId[_template] = tokenTemplateId;
        currentTemplateId[templateType] = tokenTemplateId;
        emit TokenTemplateAdded(_template, tokenTemplateId);

    }

    /**
     * @notice Function to remove a token template.
     * @dev Should have operator access.
     * @param _templateId Refers to template that is to be deleted.
    */
    function removeTokenTemplate(uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOTokenFactory: Sender must be operator""
        );
        require(tokenTemplates[_templateId] != address(0));
        address template = tokenTemplates[_templateId];
        uint256 templateType = IMisoToken(tokenTemplates[_templateId]).tokenTemplate();
        if (currentTemplateId[templateType] == _templateId) {
            delete currentTemplateId[templateType];
        }
        tokenTemplates[_templateId] = address(0);
        delete tokenTemplateToId[template];
        emit TokenTemplateRemoved(template, _templateId);
    }

    /**
     * @notice Get the total number of tokens in the factory.
     * @return Token count.
     */
    function numberOfTokens() external view returns (uint256) {
        return tokens.length;
    }

    function getTokens() external view returns (address[] memory) {
        return tokens;
    }

    /**
     * @notice Get the address based on template ID.
     * @param _templateId Token template ID.
     * @return Address of the required template ID.
     */
    function getTokenTemplate(uint256 _templateId) external view returns (address ) {
        return tokenTemplates[_templateId];
    }

    /**
     * @notice Get the ID based on template address.
     * @param _tokenTemplate Token template address.
     * @return ID of the required template address.
     */
    function getTemplateId(address _tokenTemplate) external view returns (uint256) {
        return tokenTemplateToId[_tokenTemplate];
    }
}",2904
RealWorld_TA_28_Math_RealWorld_20240803172746.log,28,Math,33146,1644,34790,79.0,0.19861,"pragma solidity =0.6.12;

// a library for performing various math operations

library MathUniswap {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}",174
RealWorld_TA_28_DummyWeth_RealWorld_20240803200752.log,28,DummyWeth,56619,4011,60630,111.0,0.363315,"// SPDX-License-Identifier: agpl-3.0
pragma solidity ^0.6.8;

/**
 * Dummy Weth token.
 */
contract DummyWeth {
    uint256 t;
    
    mapping(address => uint256) b;
    mapping(address => mapping(address => uint256)) a;

    string public name;
    string public symbol;
    uint public decimals;

    function myAddress() public returns (address) {
        return address(this);
    }

    function add(uint a, uint b) internal pure returns (uint256) {
        uint c = a + b;
        require (c >= a);
        return c;
    }
    function sub(uint a, uint b) internal pure returns (uint256) {
        require (a >= b);
        return a - b;
    }

    function totalSupply() external view returns (uint256) {
        return t;
    }

    function balanceOf(address account) external view returns (uint256) {
        return b[account];
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        b[msg.sender] = sub(b[msg.sender], amount);
        b[recipient] = add(b[recipient], amount);
        return true;
    }

    function allowance(address owner, address spender) external view returns (uint256) {
        return a[owner][spender];
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        a[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        b[sender] = sub(b[sender], amount);
        b[recipient] = add(b[recipient], amount);
        a[sender][msg.sender] = sub(a[sender][msg.sender], amount);
        return true;
    }
    
    // WETH
    function deposit() external payable {
        // assume succeeds
    }

    function withdraw(uint256) external {
        // assume succeeds
    }
}",426
RealWorld_TA_28_IUniswapV2Router02_RealWorld_20240803173526.log,28,IUniswapV2Router02,41551,2046,43597,99.0,0.248675,"pragma solidity 0.6.12;

import './IUniswapV2Router01.sol';

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}",291
RealWorld_TA_28_TokenList_RealWorld_20240803174637.log,28,TokenList,47045,2167,49212,87.0,0.278565,"pragma solidity 0.6.12;

import ""../interfaces/IPointList.sol"";
import ""../interfaces/IERC20.sol"";

/**
 * @notice TokenPointList - MISO Point List that references a given `token` balance to return approvals.
 */
contract TokenList {
    /// @notice Token contract for point list reference - can be ERC20, ERC721 or other tokens with `balanceOf()` check.
    IERC20 public token;
    
    /// @notice Whether initialised or not.
    bool private initialised;

    constructor() public {
    }

    /**
     * @notice Initializes token point list with reference token.
     * @param _token Token address.
     */
    function initPointList(IERC20 _token) public {
        require(!initialised, ""Already initialised"");
        token = _token;
        initialised = true;
    }

    /**
     * @notice Checks if account address is in the list (has any tokens).
     * @param _account Account address.
     * @return bool True or False.
     */
    function isInList(address _account) public view returns (bool) {
        return token.balanceOf(_account) > 0;
    }

    /**
     * @notice Checks if account has more or equal points (tokens) as the number given.
     * @param _account Account address.
     * @param _amount Desired amount of points.
     * @return bool True or False.
     */
    function hasPoints(address _account, uint256 _amount) public view returns (bool) {
        return token.balanceOf(_account) >= _amount;
    }
}",329
RealWorld_TA_28_WETH9_RealWorld_20240803175516.log,28,WETH9,66772,2645,69417,92.0,0.38676,"// Copyright (C) 2015, 2016, 2017 Dapphub

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity 0.6.12;

contract WETH9 {
    string public name     = ""Wrapped Ether"";
    string public symbol   = ""WETH"";
    uint8  public decimals = 18;

    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    receive() external payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }

    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",589
RealWorld_TA_28_IMisoAuction_RealWorld_20240803193729.log,28,IMisoAuction,33734,1484,35218,80.0,0.19835,"pragma solidity 0.6.12;

interface IMisoAuction {


    function initAuction(
        address _funder,
        address _token,
        uint256 _tokenSupply,
        uint256 _startDate,
        uint256 _endDate,
        address _paymentCurrency,
        uint256 _startPrice,
        uint256 _minimumPrice,
        address _operator,
        address _pointList,
        address payable _wallet
    ) external;
    function auctionSuccessful() external view returns (bool);
    function finalized() external view returns (bool);
    function wallet() external view returns (address);
    function paymentCurrency() external view returns (address);
    function auctionToken() external view returns (address);

    function finalize() external;
    function tokenPrice() external view returns (uint256);
    function getTotalTokens() external view returns (uint256);
}",176
RealWorld_TA_28_SafeTransfer_RealWorld_20240803180648.log,28,SafeTransfer,84239,3572,87811,105.0,0.492635,"pragma solidity 0.6.12;

contract SafeTransfer {

    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Helper function to handle both ETH and ERC20 payments
    function _safeTokenPayment(
        address _token,
        address payable _to,
        uint256 _amount
    ) internal {
        if (address(_token) == ETH_ADDRESS) {
            _safeTransferETH(_to,_amount );
        } else {
            _safeTransfer(_token, _to, _amount);
        }
    }


    /// @dev Helper function to handle both ETH and ERC20 payments
    function _tokenPayment(
        address _token,
        address payable _to,
        uint256 _amount
    ) internal {
        if (address(_token) == ETH_ADDRESS) {
            _to.transfer(_amount);
        } else {
            _safeTransfer(_token, _to, _amount);
        }
    }


    /// @dev Transfer helper from UniswapV2 Router
    function _safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }


    /**
     * There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2
     * Im trying to make it a habit to put external calls last (reentrancy)
     * You can put this in an internal function if you like.
     */
    function _safeTransfer(
        address token,
        address to,
        uint256 amount
    ) internal virtual {
        // solium-disable-next-line security/no-low-level-calls
        (bool success, bytes memory data) =
            token.call(
                // 0xa9059cbb = bytes4(keccak256(""transfer(address,uint256)""))
                abi.encodeWithSelector(0xa9059cbb, to, amount)
            );
        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed
    }

    function _safeTransferFrom(
        address token,
        address from,
        uint256 amount
    ) internal virtual {
        // solium-disable-next-line security/no-low-level-calls
        (bool success, bytes memory data) =
            token.call(
                // 0x23b872dd = bytes4(keccak256(""transferFrom(address,address,uint256)""))
                abi.encodeWithSelector(0x23b872dd, from, address(this), amount)
            );
        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed
    }

    function _safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function _safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }


}",772
RealWorld_TA_28_EnumerableSet_RealWorld_20240803191021.log,28,EnumerableSet,208907,1291,210198,97.0,1.070355,"pragma solidity 0.6.12;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;

        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) { // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        require(set._values.length > index, ""EnumerableSet: index out of bounds"");
        return set._values[index];
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }


    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

   /**
    * @dev Returns the value stored at position `index` in the set. O(1).
    *
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }
}",2264
RealWorld_TA_28_DutchAuctionHarness_RealWorld_20240803195730.log,28,DutchAuctionHarness,61465,5759,67224,144.0,0.422505,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""../../contracts/Auctions/DutchAuction.sol"";

/*
 * Harness for the DutchAuction to support the Certora Prover.
 * Contains some simplifications and helper getter methods.
 */
contract DutchAuctionHarness is DutchAuction {
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    mapping(uint256 => uint256) public currentPrice;
    mapping(uint256 => uint256) public tokenPrice_;

    ////////////////////////////////////////////////////////////
    //                         Getters                        //
    ////////////////////////////////////////////////////////////

    function tokenBalanceOf(address token, address user) public returns (uint256) {
        if (token == ETH_ADDRESS) {
                return address(user).balance;
        } else {
            return IERC20(token).balanceOf(user);
        }
    }

    function getCommitmentsTotal() public returns (uint256) {
        return marketStatus.commitmentsTotal;
    }

    function getStartPrice() public returns (uint256) {
        return marketPrice.startPrice;
    }

    ////////////////////////////////////////////////////////////
    //                     Simplifications                    //
    ////////////////////////////////////////////////////////////

    function _currentPrice() internal override view returns (uint256) {
        uint256 price = currentPrice[block.timestamp];
        require(price <= marketPrice.startPrice);
        require(price >= marketPrice.minimumPrice); 
        return price;
    }

    function clearingPrice() public override view returns (uint256) {
        uint256 tokenPrice_ = tokenPrice();
        uint256 priceFunction_ = priceFunction(); 
        if (tokenPrice_ > priceFunction_) {
            return tokenPrice_;
        }
        return priceFunction_;
    }

    function batch(bytes[] calldata calls, bool revertOnFail) external override payable
            returns (bool[] memory successes, bytes[] memory results) { }


    function batchCommitEth(address payable _beneficiary1, bool readAndAgreedToMarketParticipationAgreement1, address payable _beneficiary2, 
                        bool readAndAgreedToMarketParticipationAgreement2) external payable
    {

        commitEth( _beneficiary1, readAndAgreedToMarketParticipationAgreement1);
        commitEth( _beneficiary2, readAndAgreedToMarketParticipationAgreement2);
                 
    }

}",491
RealWorld_TA_28_AccessControl_RealWorld_20240803185806.log,28,AccessControl,165375,1659,167034,93.0,0.860055,"pragma solidity 0.6.12;

import ""../utils/EnumerableSet.sol"";
import ""../utils/Context.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to grant"");

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to revoke"");

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}",1750
RealWorld_TA_28_Documents_RealWorld_20240803200615.log,28,Documents,50089,2287,52376,94.0,0.296185,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

/**
 * @title Simplified version of the Document.sol for verification with
 *        Certora Prover.
 */
contract Documents {
    function _setDocument(string calldata _name, string calldata _data) internal { }

    /**
     * @notice Used to remove an existing document from the contract by giving the name of the document.
     * @dev Can only be executed by the owner of the contract.
     * @param _name Name of the document. It should be unique always
     */
    function _removeDocument(string calldata _name) internal { }

    /**
     * @notice Used to return the details of a document with a known name (`string`).
     * @param _name Name of the document
     * @return string The data associated with the document.
     * @return uint256 the timestamp at which the document was last modified.
     */
    function getDocument(string calldata _name) external view returns (string memory, uint256) { }

    /**
     * @notice Used to retrieve a full list of documents attached to the smart contract.
     * @return string List of all documents names present in the contract.
     */
    function getAllDocuments() external view returns (string[] memory) { }

    /**
     * @notice Used to retrieve the total documents in the smart contract.
     * @return uint256 Count of the document names present in the contract.
     */
    function getDocumentCount() external view returns (uint256) { }

    /**
     * @notice Used to retrieve the document name from index in the smart contract.
     * @return string Name of the document name.
     */
    function getDocumentName(uint256 _index) external view returns (string memory) { }
}",373
RealWorld_TA_28_GnosisSafeFactory_RealWorld_20240803192535.log,28,GnosisSafeFactory,105033,3432,108465,117.0,0.593805,"pragma solidity 0.6.12;

import ""../Access/MISOAccessControls.sol"";
import ""../interfaces/IGnosisProxyFactory.sol"";
import ""../interfaces/ISafeGnosis.sol"";
import ""../interfaces/IERC20.sol"";


contract GnosisSafeFactory {

    /// @notice ISafeGnosis interface.
    ISafeGnosis public safeGnosis;

    /// @notice IGnosisProxyFactory interface.
    IGnosisProxyFactory public proxyFactory;

    /// @notice MISOAccessControls interface.
    MISOAccessControls public accessControls;

    /// @notice Whether initialized or not.
    bool private initialised;

    /// @notice Mapping from user address to Gnosis Safe interface.
    mapping(address => ISafeGnosis) userToProxy;

    /// @notice Emitted when Gnosis Safe is created.
    event GnosisSafeCreated(address indexed user, address indexed proxy, address safeGnosis, address proxyFactory);

    /// @notice Emitted when Gnosis Vault is initialized.
    event MisoInitGnosisVault(address sender);

    /// @notice Emitted when Gnosis Safe is updated.
    event SafeGnosisUpdated(address indexed sender, address oldSafeGnosis, address newSafeGnosis);

    /// @notice Emitted when Proxy Factory is updated.
    event ProxyFactoryUpdated(address indexed sender, address oldProxyFactory, address newProxyFactory);

    /**
     * @notice Initializes Gnosis Vault with safe, proxy and accesscontrols contracts.
     * @param _accessControls AccessControls contract address.
     * @param _safeGnosis SafeGnosis contract address.
     * @param _proxyFactory ProxyFactory contract address.
     */
    function initGnosisVault(address _accessControls, address _safeGnosis, address _proxyFactory) public {
        require(!initialised);
        safeGnosis = ISafeGnosis(_safeGnosis);
        proxyFactory = IGnosisProxyFactory(_proxyFactory);
        accessControls = MISOAccessControls(_accessControls);
        initialised = true;
        emit MisoInitGnosisVault(msg.sender);
    }

    /**
     * @notice Function that can change Gnosis Safe contract address.
     * @param _safeGnosis SafeGnosis contract address.
     */
    function setSafeGnosis(address _safeGnosis) external {
        require(accessControls.hasOperatorRole(msg.sender), ""GnosisVault.setSafeGnosis: Sender must be operator"");
        address oldSafeGnosis = address(safeGnosis);
        safeGnosis = ISafeGnosis(_safeGnosis);
        emit SafeGnosisUpdated(msg.sender, oldSafeGnosis, address(safeGnosis));
    }

    /**
     * @notice Function that can change Proxy Factory contract address.
     * @param _proxyFactory ProxyFactory contract address.
     */
    function setProxyFactory(address _proxyFactory) external {
        require(accessControls.hasOperatorRole(msg.sender), ""GnosisVault.setProxyFactory: Sender must be operator"");
        address oldProxyFactory = address(proxyFactory);
        proxyFactory = IGnosisProxyFactory(_proxyFactory);
        emit ProxyFactoryUpdated(msg.sender, oldProxyFactory, address(proxyFactory));
    }

    /**
     * @notice Function for creating a new safe.
     * @param _owners List of Safe owners.
     * @param _threshold Number of required confirmations for a Safe transaction.
     * @param to Contract address for optional delegate call.
     * @param data Data payload for optional delegate call.
     * @param fallbackHandler Handler for fallback calls to this contract.
     * @param paymentToken Token that should be used for the payment (0 is ETH).
     * @param payment Value that should be paid.
     * @param paymentReceiver Address that should receive the payment (or 0 if tx.origin).
     */
    function createSafe(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    )
        public returns (ISafeGnosis proxy)
    {
        bytes memory safeGnosisData = abi.encode(""setup(address[],uint256,address,bytes,address,address,uint256,address)"",
        _owners,_threshold,to,data,fallbackHandler,paymentToken,payment,paymentReceiver);
        proxy = proxyFactory.createProxy(
            safeGnosis,
            safeGnosisData
        );
        userToProxy[msg.sender] = proxy;
        emit GnosisSafeCreated(msg.sender, address(proxy), address(safeGnosis), address(proxyFactory));
        return proxy;
    }
    /// GP: Can we also use the proxy with a nonce? Incase we need it.
    /// GP: Can we have a simplifed version with a few things already set? eg an ETH by default verision.
    /// GP: Can we set empty data or preset the feedback handler? Whats the minimum feilds required?
}",1014
RealWorld_TA_28_Timelock_RealWorld_20240803175944.log,28,Timelock,135507,3909,139416,116.0,0.755715,"// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol
// Copyright 2020 Compound Labs, Inc.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

pragma solidity 0.6.12;

import ""../OpenZeppelin/math/SafeMath.sol"";

contract Timelock {
    using SafeMath for uint;

    event NewAdmin(address indexed newAdmin);
    event NewPendingAdmin(address indexed newPendingAdmin);
    event NewDelay(uint indexed newDelay);
    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);
    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);
    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);

    uint public constant GRACE_PERIOD = 14 days;
    uint public constant MINIMUM_DELAY = 2 days;
    uint public constant MAXIMUM_DELAY = 30 days;

    address public admin;
    address public pendingAdmin;
    uint public delay;
    bool public admin_initialized;

    mapping (bytes32 => bool) public queuedTransactions;


    constructor(address admin_, uint delay_) public {
        require(delay_ >= MINIMUM_DELAY, ""Timelock::constructor: Delay must exceed minimum delay."");
        require(delay_ <= MAXIMUM_DELAY, ""Timelock::constructor: Delay must not exceed maximum delay."");

        admin = admin_;
        delay = delay_;
        admin_initialized = false;
    }

    receive() external payable { }

    function setDelay(uint delay_) public {
        require(msg.sender == address(this), ""Timelock::setDelay: Call must come from Timelock."");
        require(delay_ >= MINIMUM_DELAY, ""Timelock::setDelay: Delay must exceed minimum delay."");
        require(delay_ <= MAXIMUM_DELAY, ""Timelock::setDelay: Delay must not exceed maximum delay."");
        delay = delay_;

        emit NewDelay(delay);
    }

    function acceptAdmin() public {
        require(msg.sender == pendingAdmin, ""Timelock::acceptAdmin: Call must come from pendingAdmin."");
        admin = msg.sender;
        pendingAdmin = address(0);

        emit NewAdmin(admin);
    }

    function setPendingAdmin(address pendingAdmin_) public {
        // allows one time setting of admin for deployment purposes
        if (admin_initialized) {
            require(msg.sender == address(this), ""Timelock::setPendingAdmin: Call must come from Timelock."");
        } else {
            require(msg.sender == admin, ""Timelock::setPendingAdmin: First call must come from admin."");
            admin_initialized = true;
        }
        pendingAdmin = pendingAdmin_;

        emit NewPendingAdmin(pendingAdmin);
    }

    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {
        require(msg.sender == admin, ""Timelock::queueTransaction: Call must come from admin."");
        require(eta >= getBlockTimestamp().add(delay), ""Timelock::queueTransaction: Estimated execution block must satisfy delay."");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;

        emit QueueTransaction(txHash, target, value, signature, data, eta);
        return txHash;
    }

    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {
        require(msg.sender == admin, ""Timelock::cancelTransaction: Call must come from admin."");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = false;

        emit CancelTransaction(txHash, target, value, signature, data, eta);
    }

    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {
        require(msg.sender == admin, ""Timelock::executeTransaction: Call must come from admin."");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        require(queuedTransactions[txHash], ""Timelock::executeTransaction: Transaction hasn't been queued."");
        require(getBlockTimestamp() >= eta, ""Timelock::executeTransaction: Transaction hasn't surpassed time lock."");
        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), ""Timelock::executeTransaction: Transaction is stale."");

        queuedTransactions[txHash] = false;

        bytes memory callData;

        if (bytes(signature).length == 0) {
            callData = data;
        } else {
            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        }

        // solium-disable-next-line security/no-call-value
        (bool success, bytes memory returnData) = target.call.value(value)(callData);
    
        require(success, ""Timelock::executeTransaction: Transaction execution reverted."");

        emit ExecuteTransaction(txHash, target, value, signature, data, eta);

        return returnData;
    }

    function getBlockTimestamp() internal view returns (uint) {
        // solium-disable-next-line security/no-block-members
        return block.timestamp;
    }
}",1383
RealWorld_TA_28_ERC20Burnable_RealWorld_20240803184828.log,28,ERC20Burnable,40967,2119,43086,92.0,0.247215,"pragma solidity ^0.6.0;

import ""../ERC20.sol"";

/**
 * @dev Extension of {ERC20} that allows token holders to destroy both their own
 * tokens and those that they have an allowance for, in a way that can be
 * recognized off-chain (via event analysis).
 */
abstract contract ERC20Burnable is ERC20 {
    /**
     * @dev Destroys `amount` tokens from the caller.
     *
     * See {ERC20-_burn}.
     */
    function burn(uint256 amount) public virtual {
        _burn(_msgSender(), amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, deducting from the callers
     * allowance.
     *
     * See {ERC20-_burn} and {ERC20-allowance}.
     *
     * Requirements:
     *
     * - the caller must have allowance for ``accounts``s tokens of at least
     * `amount`.
     */
    function burnFrom(address account, uint256 amount) public virtual {
        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, ""ERC20: burn amount exceeds allowance"");

        _approve(account, _msgSender(), decreasedAllowance);
        _burn(account, amount);
    }
}",264
RealWorld_TA_28_Crowdsale_RealWorld_20240803182731.log,28,Crowdsale,530345,13677,544022,267.0,2.925265,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's Crowdsale
//
// A fixed price token swap contract. 
//
// Inspired by the Open Zeppelin crowsdale and delta.financial
// https://github.com/OpenZeppelin/openzeppelin-contracts
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi, Kusatoshi, SSMikazu 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""../OpenZeppelin/utils/ReentrancyGuard.sol"";
import ""../Access/MISOAccessControls.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../Utils/BoringBatchable.sol"";
import ""../Utils/BoringERC20.sol"";
import ""../Utils/BoringMath.sol"";
import ""../Utils/Documents.sol"";
import ""../interfaces/IPointList.sol"";
import ""../interfaces/IMisoMarket.sol"";


contract Crowdsale is IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents , ReentrancyGuard  {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;
    using BoringERC20 for IERC20;

    /// @notice MISOMarket template id for the factory contract.
    /// @dev For different marketplace types, this must be incremented.
    uint256 public constant override marketTemplate = 1;

    /// @notice The placeholder ETH address.
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @notice The decimals of the auction token.
    uint256 private constant AUCTION_TOKEN_DECIMALS = 1e18;

    /** 
    * @notice rate - How many token units a buyer gets per token or wei.
    * The rate is the conversion between wei and the smallest and indivisible token unit.
    * So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK
    * 1 wei will give you 1 unit, or 0.001 TOK.
    */
    /// @notice goal - Minimum amount of funds to be raised in weis or tokens.
    struct MarketPrice {
        uint128 rate;
        uint128 goal; 
    }
    MarketPrice public marketPrice;

    /// @notice Starting time of crowdsale.
    /// @notice Ending time of crowdsale.
    /// @notice Total number of tokens to sell.
    struct MarketInfo {
        uint64 startTime;
        uint64 endTime; 
        uint128 totalTokens;
    }
    MarketInfo public marketInfo;

    /// @notice Amount of wei raised.
    /// @notice Whether crowdsale has been initialized or not.
    /// @notice Whether crowdsale has been finalized or not.
    struct MarketStatus {
        uint128 commitmentsTotal;
        bool finalized;
        bool usePointList;
    }
    MarketStatus public marketStatus;

    /// @notice The token being sold.
    address public auctionToken;
    /// @notice Address where funds are collected.
    address payable public wallet;
    /// @notice The currency the crowdsale accepts for payment. Can be ETH or token address.
    address public paymentCurrency;
    /// @notice Address that manages auction approvals.
    address public pointList;

    /// @notice The commited amount of accounts.
    mapping(address => uint256) public commitments;
    /// @notice Amount of tokens to claim per address.
    mapping(address => uint256) public claimed;

    /// @notice Event for updating auction times.  Needs to be before auction starts.
    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); 
    /// @notice Event for updating auction prices. Needs to be before auction starts.
    event AuctionPriceUpdated(uint256 rate, uint256 goal); 
    /// @notice Event for updating auction wallet. Needs to be before auction starts.
    event AuctionWalletUpdated(address wallet); 

    /// @notice Event for adding a commitment.
    event AddedCommitment(address addr, uint256 commitment);
    
    /// @notice Event for finalization of the crowdsale
    event AuctionFinalized();
    /// @notice Event for cancellation of the auction.
    event AuctionCancelled();

    /**
     * @notice Initializes main contract variables and transfers funds for the sale.
     * @dev Init function.
     * @param _funder The address that funds the token for crowdsale.
     * @param _token Address of the token being sold.
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.
     * @param _totalTokens The total number of tokens to sell in crowdsale.
     * @param _startTime Crowdsale start time.
     * @param _endTime Crowdsale end time.
     * @param _rate Number of token units a buyer gets per wei or token.
     * @param _goal Minimum amount of funds to be raised in weis or tokens.
     * @param _admin Address that can finalize auction.
     * @param _pointList Address that will manage auction approvals.
     * @param _wallet Address where collected funds will be forwarded to.
     */
    function initCrowdsale(
        address _funder,
        address _token,
        address _paymentCurrency,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        uint256 _rate,
        uint256 _goal,
        address _admin,
        address _pointList,
        address payable _wallet
    ) public {
        require(_startTime < 10000000000, ""Crowdsale: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""Crowdsale: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""Crowdsale: start time is before current time"");
        require(_endTime > _startTime, ""Crowdsale: start time is not before end time"");
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(_admin != address(0), ""Crowdsale: admin is the zero address"");
        require(_totalTokens > 0, ""Crowdsale: total tokens is 0"");
        require(_goal > 0, ""Crowdsale: goal is 0"");
        require(IERC20(_token).decimals() == 18, ""Crowdsale: Token does not have 18 decimals"");
        if (_paymentCurrency != ETH_ADDRESS) {
            require(IERC20(_paymentCurrency).decimals() > 0, ""Crowdsale: Payment currency is not ERC20"");
        }

        marketPrice.rate = BoringMath.to128(_rate);
        marketPrice.goal = BoringMath.to128(_goal);

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        marketInfo.totalTokens = BoringMath.to128(_totalTokens);

        auctionToken = _token;
        paymentCurrency = _paymentCurrency;
        wallet = _wallet;

        initAccessControls(_admin);

        _setList(_pointList);
        
        require(_getTokenAmount(_goal) <= _totalTokens, ""Crowdsale: goal should be equal to or lower than total tokens"");

        _safeTransferFrom(_token, _funder, _totalTokens);
    }


    ///--------------------------------------------------------
    /// Commit to buying tokens!
    ///--------------------------------------------------------

    receive() external payable {
        revertBecauseUserDidNotProvideAgreement();
    }

    /** 
     * @dev Attribution to the awesome delta.financial contracts
    */  
    function marketParticipationAgreement() public pure returns (string memory) {
        return ""I understand that I am interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings"";
    }
    /** 
     * @dev Not using modifiers is a purposeful choice for code readability.
    */ 
    function revertBecauseUserDidNotProvideAgreement() internal pure {
        revert(""No agreement provided, please review the smart contract before interacting with it"");
    }

    /**
     * @notice Checks the amount of ETH to commit and adds the commitment. Refunds the buyer if commit is too high.
     * @dev low level token purchase with ETH ***DO NOT OVERRIDE***
     * This function has a non-reentrancy guard, so it should not be called by
     * another `nonReentrant` function.
     * @param _beneficiary Recipient of the token purchase.
     */
    function commitEth(
        address payable _beneficiary,
        bool readAndAgreedToMarketParticipationAgreement
    ) 
        public payable   nonReentrant    
    {
        require(paymentCurrency == ETH_ADDRESS, ""Crowdsale: Payment currency is not ETH""); 
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }

        /// @dev Get ETH able to be committed.
        uint256 ethToTransfer = calculateCommitment(msg.value);

        /// @dev Accept ETH Payments.
        uint256 ethToRefund = msg.value.sub(ethToTransfer);
        if (ethToTransfer > 0) {
            _addCommitment(_beneficiary, ethToTransfer);
        }

        /// @dev Return any ETH to be refunded.
        if (ethToRefund > 0) {
            _beneficiary.transfer(ethToRefund);
        }

        /// @notice Revert if commitmentsTotal exceeds the balance
        require(marketStatus.commitmentsTotal <= address(this).balance, ""DutchAuction: The committed ETH exceeds the balance"");
    }

    /**
     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.
     * @param _amount Amount of tokens to commit.
     */
    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {
        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);
    }

    /**
     * @notice Checks how much is user able to commit and processes that commitment.
     * @dev Users must approve contract prior to committing tokens to auction.
     * @param _from User ERC20 address.
     * @param _amount Amount of approved ERC20 tokens.
     */
    function commitTokensFrom(
        address _from,
        uint256 _amount,
        bool readAndAgreedToMarketParticipationAgreement
    ) 
        public   nonReentrant  
    {
        require(address(paymentCurrency) != ETH_ADDRESS, ""Crowdsale: Payment currency is not a token"");
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        uint256 tokensToTransfer = calculateCommitment(_amount);
        if (tokensToTransfer > 0) {
            _safeTransferFrom(paymentCurrency, msg.sender, tokensToTransfer);
            _addCommitment(_from, tokensToTransfer);
        }
    }

    /**
     * @notice Checks if the commitment does not exceed the goal of this sale.
     * @param _commitment Number of tokens to be commited.
     * @return committed The amount able to be purchased during a sale.
     */
    function calculateCommitment(uint256 _commitment)
        public
        view
        returns (uint256 committed)
    {
        uint256 tokens = _getTokenAmount(_commitment);
        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));
        if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {
            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));
        }
        return _commitment;
    }

    /**
     * @notice Updates commitment of the buyer and the amount raised, emits an event.
     * @param _addr Recipient of the token purchase.
     * @param _commitment Value in wei or token involved in the purchase.
     */
    function _addCommitment(address _addr, uint256 _commitment) internal {
        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), ""Crowdsale: outside auction hours"");
        require(_addr != address(0), ""Crowdsale: beneficiary is the zero address"");

        uint256 newCommitment = commitments[_addr].add(_commitment);
        if (marketStatus.usePointList) {
            require(IPointList(pointList).hasPoints(_addr, newCommitment));
        }

        commitments[_addr] = newCommitment;

        /// @dev Update state.
        marketStatus.commitmentsTotal = BoringMath.to128(uint256(marketStatus.commitmentsTotal).add(_commitment));

        emit AddedCommitment(_addr, _commitment);
    }

    function withdrawTokens() public  {
        withdrawTokens(msg.sender);
    }

    /**
     * @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.
     * @dev Withdraw tokens only after crowdsale ends.
     * @param beneficiary Whose tokens will be withdrawn.
     */
    function withdrawTokens(address payable beneficiary) public   nonReentrant  {    
        if (auctionSuccessful()) {
            require(marketStatus.finalized, ""Crowdsale: not finalized"");
            /// @dev Successful auction! Transfer claimed tokens.
            uint256 tokensToClaim = tokensClaimable(beneficiary);
            require(tokensToClaim > 0, ""Crowdsale: no tokens to claim""); 
            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);
            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);
        } else {
            /// @dev Auction did not meet reserve price.
            /// @dev Return committed funds back to user.
            require(block.timestamp > uint256(marketInfo.endTime), ""Crowdsale: auction has not finished yet"");
            uint256 accountBalance = commitments[beneficiary];
            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas
            _safeTokenPayment(paymentCurrency, beneficiary, accountBalance);
        }
    }

    /**
     * @notice Adjusts users commitment depending on amount already claimed and unclaimed tokens left.
     * @return claimerCommitment How many tokens the user is able to claim.
     */
    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {
        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));
        claimerCommitment = _getTokenAmount(commitments[_user]);
        claimerCommitment = claimerCommitment.sub(claimed[_user]);

        if(claimerCommitment > unclaimedTokens){
            claimerCommitment = unclaimedTokens;
        }
    }
    
    //--------------------------------------------------------
    // Finalize Auction
    //--------------------------------------------------------
    
    /**
     * @notice Manually finalizes the Crowdsale.
     * @dev Must be called after crowdsale ends, to do some extra finalization work.
     * Calls the contracts finalization function.
     */
    function finalize() public nonReentrant {
        require(            
            hasAdminRole(msg.sender) 
            || wallet == msg.sender
            || hasSmartContractRole(msg.sender) 
            || finalizeTimeExpired(),
            ""Crowdsale: sender must be an admin""
        );
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""Crowdsale: already finalized"");
        MarketInfo storage info = marketInfo;
        require(auctionEnded(), ""Crowdsale: Has not finished yet""); 

        if (auctionSuccessful()) {
            /// @dev Successful auction
            /// @dev Transfer contributed tokens to wallet.
            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));
            /// @dev Transfer unsold tokens to wallet.
            uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));
            uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);
            if(unsoldTokens > 0) {
                _safeTokenPayment(auctionToken, wallet, unsoldTokens);
            }
        } else {
            /// @dev Failed auction
            /// @dev Return auction tokens back to wallet.
            _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));
        }

        status.finalized = true;

        emit AuctionFinalized();
    }

    /**
     * @notice Cancel Auction
     * @dev Admin can cancel the auction before it starts
     */
    function cancelAuction() public   nonReentrant  
    {
        require(hasAdminRole(msg.sender));
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""Crowdsale: already finalized"");
        require( uint256(status.commitmentsTotal) == 0, ""Crowdsale: Funds already raised"" );

        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));

        status.finalized = true;
        emit AuctionCancelled();
    }

    function tokenPrice() public view returns (uint256) {
        return uint256(marketPrice.rate); 
    }

    function _getTokenPrice(uint256 _amount) internal view returns (uint256) {
        return _amount.mul(uint256(marketPrice.rate)).div(AUCTION_TOKEN_DECIMALS);   
    }

    function getTokenAmount(uint256 _amount) public view returns (uint256) {
        _getTokenAmount(_amount);
    }

    /**
     * @notice Calculates the number of tokens to purchase.
     * @dev Override to extend the way in which ether is converted to tokens.
     * @param _amount Value in wei or token to be converted into tokens.
     * @return tokenAmount Number of tokens that can be purchased with the specified amount.
     */
    function _getTokenAmount(uint256 _amount) internal view returns (uint256) {
        return _amount.mul(AUCTION_TOKEN_DECIMALS).div(uint256(marketPrice.rate));
    }

    /**
     * @notice Checks if the sale is open.
     * @return isOpen True if the crowdsale is open, false otherwise.
     */
    function isOpen() public view returns (bool) {
        return block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime);
    }

    /**
     * @notice Checks if the sale minimum amount was raised.
     * @return auctionSuccessful True if the commitmentsTotal is equal or higher than goal.
     */
    function auctionSuccessful() public view returns (bool) {
        return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal);
    }

    /**
     * @notice Checks if the sale has ended.
     * @return auctionEnded True if sold out or time has ended.
     */
    function auctionEnded() public view returns (bool) {
        return block.timestamp > uint256(marketInfo.endTime) || 
        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);
    }

    /**
     * @notice Checks if the sale has been finalised.
     * @return bool True if sale has been finalised.
     */
    function finalized() public view returns (bool) {
        return marketStatus.finalized;
    }

    /**
     * @return True if 7 days have passed since the end of the auction
    */
    function finalizeTimeExpired() public view returns (bool) {
        return uint256(marketInfo.endTime) + 7 days < block.timestamp;
    }
    

    //--------------------------------------------------------
    // Documents
    //--------------------------------------------------------

    function setDocument(string calldata _name, string calldata _data) external {
        require(hasAdminRole(msg.sender) );
        _setDocument( _name, _data);
    }

    function setDocuments(string[] calldata _name, string[] calldata _data) external {
        require(hasAdminRole(msg.sender) );
        uint256 numDocs = _name.length;
        for (uint256 i = 0; i < numDocs; i++) {
            _setDocument( _name[i], _data[i]);
        }
    }

    function removeDocument(string calldata _name) external {
        require(hasAdminRole(msg.sender));
        _removeDocument(_name);
    }

    //--------------------------------------------------------
    // Point Lists
    //--------------------------------------------------------


    function setList(address _list) external {
        require(hasAdminRole(msg.sender));
        _setList(_list);
    }

    function enableList(bool _status) external {
        require(hasAdminRole(msg.sender));
        marketStatus.usePointList = _status;
    }

    function _setList(address _pointList) private {
        if (_pointList != address(0)) {
            pointList = _pointList;
            marketStatus.usePointList = true;
        }
    }

    //--------------------------------------------------------
    // Setter Functions
    //--------------------------------------------------------

    /**
     * @notice Admin can set start and end time through this function.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     */
    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {
        require(hasAdminRole(msg.sender));
        require(_startTime < 10000000000, ""Crowdsale: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""Crowdsale: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""Crowdsale: start time is before current time"");
        require(_endTime > _startTime, ""Crowdsale: end time must be older than start price"");

        require(marketStatus.commitmentsTotal == 0, ""Crowdsale: auction cannot have already started"");

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        
        emit AuctionTimeUpdated(_startTime,_endTime);
    }

    /**
     * @notice Admin can set auction price through this function.
     * @param _rate Price per token.
     * @param _goal Minimum amount raised and goal for the auction.
     */
    function setAuctionPrice(uint256 _rate, uint256 _goal) external {
        require(hasAdminRole(msg.sender));
        require(_goal > 0, ""Crowdsale: goal is 0"");
        require(_rate > 0, ""Crowdsale: rate is 0"");
        require(marketStatus.commitmentsTotal == 0, ""Crowdsale: auction cannot have already started"");
        marketPrice.rate = BoringMath.to128(_rate);
        marketPrice.goal = BoringMath.to128(_goal);
        require(_getTokenAmount(_goal) <= uint256(marketInfo.totalTokens), ""Crowdsale: minimum target exceeds hard cap"");

        emit AuctionPriceUpdated(_rate,_goal);
    }

    /**
     * @notice Admin can set the auction wallet through this function.
     * @param _wallet Auction wallet is where funds will be sent.
     */
    function setAuctionWallet(address payable _wallet) external {
        require(hasAdminRole(msg.sender));
        require(_wallet != address(0), ""Crowdsale: wallet is the zero address"");
        wallet = _wallet;

        emit AuctionWalletUpdated(_wallet);
    }


    //--------------------------------------------------------
    // Market Launchers
    //--------------------------------------------------------

    function init(bytes calldata _data) external override payable {

    }

    /**
     * @notice Decodes and hands Crowdsale data to the initCrowdsale function.
     * @param _data Encoded data for initialization.
     */
    function initMarket(bytes calldata _data) public override {
        (
        address _funder,
        address _token,
        address _paymentCurrency,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        uint256 _rate,
        uint256 _goal,
        address _admin,
        address _pointList,
        address payable _wallet
        ) = abi.decode(_data, (
            address,
            address,
            address,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            address,
            address,
            address
            )
        );
    
        initCrowdsale(_funder, _token, _paymentCurrency, _totalTokens, _startTime, _endTime, _rate, _goal, _admin, _pointList, _wallet);
    }

    /**
     * @notice Collects data to initialize the crowd sale.
     * @param _funder The address that funds the token for crowdsale.
     * @param _token Address of the token being sold.
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.
     * @param _totalTokens The total number of tokens to sell in crowdsale.
     * @param _startTime Crowdsale start time.
     * @param _endTime Crowdsale end time.
     * @param _rate Number of token units a buyer gets per wei or token.
     * @param _goal Minimum amount of funds to be raised in weis or tokens.
     * @param _admin Address that can finalize crowdsale.
     * @param _pointList Address that will manage auction approvals.
     * @param _wallet Address where collected funds will be forwarded to.
     * @return _data All the data in bytes format.
     */
    function getCrowdsaleInitData(
        address _funder,
        address _token,
        address _paymentCurrency,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        uint256 _rate,
        uint256 _goal,
        address _admin,
        address _pointList,
        address payable _wallet
    )
        external pure returns (bytes memory _data)
    {
        return abi.encode(
            _funder,
            _token,
            _paymentCurrency,
            _totalTokens,
            _startTime,
            _endTime,
            _rate,
            _goal,
            _admin,
            _pointList,
            _wallet
            );
    }
    
    function getBaseInformation() external view returns(
        address, 
        uint64,
        uint64,
        bool 
    ) {
        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);
    }

    function getTotalTokens() external view returns(uint256) {
        return uint256(marketInfo.totalTokens);
    }
}",5972
RealWorld_TA_28_Math_RealWorld_20240803191859.log,28,Math,36486,1404,37890,87.0,0.21051,"pragma solidity 0.6.12;

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow, so we distribute
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
}",214
RealWorld_TA_28_IGnosisProxyFactory_RealWorld_20240803192734.log,28,IGnosisProxyFactory,22715,1411,24126,80.0,0.141795,"pragma solidity 0.6.12;
import ""./ISafeGnosis.sol"";
interface IGnosisProxyFactory {
    function createProxy(
        ISafeGnosis masterCopy, bytes memory data) external returns(ISafeGnosis proxy);

 
}",50
RealWorld_TA_28_MISOMasterChef_RealWorld_20240803181253.log,28,MISOMasterChef,302038,5098,307136,156.0,1.61215,"pragma solidity 0.6.12;


//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------


import ""../interfaces/IERC20.sol"";
import ""../OpenZeppelin/token/ERC20/SafeERC20.sol"";
import ""../OpenZeppelin/utils/EnumerableSet.sol"";
import ""../OpenZeppelin/math/SafeMath.sol"";
import ""../OpenZeppelin/access/Ownable.sol"";

import ""../Access/MISOAccessControls.sol"";
import ""../interfaces/IMisoFarm.sol"";
import ""../Utils/SafeTransfer.sol"";


// MasterChef is the master of Rewards. He can make Rewards and he is a fair guy.
//
// Note that its ownable and the owner wields tremendous power. The ownership
// will be transferred to a governance smart contract once tokens are sufficiently
// distributed and the community can show to govern itself.
//
// Have fun reading it. Hopefully its bug-free. God bless.
//
// MISO Update - Removed LP migrator
// MISO Update - Removed minter - Contract holds token
// MISO Update - Dev tips parameterised
// MISO Update - Replaced owner with access controls
// MISO Update - Added SafeTransfer

contract MISOMasterChef is IMisoFarm, MISOAccessControls, SafeTransfer {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;


    // Info of each user.
    struct UserInfo {
        uint256 amount;     // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of tokens
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accRewardsPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Heres what happens:
        //   1. The pools `accRewardsPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. Users `amount` gets updated.
        //   4. Users `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken;             // Address of LP token contract.
        uint256 allocPoint;         // How many allocation points assigned to this pool. tokens to distribute per block.
        uint256 lastRewardBlock;    // Last block number that tokens distribution occurs.
        uint256 accRewardsPerShare; // Accumulated tokens per share, times 1e12. See below.
    }

    // The rewards token
    IERC20 public rewards;
    // Dev address.
    address public devaddr;
    // Percentage amount to be tipped to devs.
    uint256 public devPercentage;
    // Tips owed to develpers.
    uint256 public tips;
    // uint256 public devPaid;
    
    // Block number when bonus tokens period ends.
    uint256 public bonusEndBlock;
    // Reward tokens created per block.
    uint256 public rewardsPerBlock;
    // Bonus muliplier for early rewards makers.
    uint256 public bonusMultiplier;
    // Total rewards debt.
    uint256 public totalRewardDebt;

    // MISOFarmFactory template id
    uint256 public constant override farmTemplate = 1;
    // For initial setup
    bool private initialised;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping (uint256 => mapping (address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint;
    // The block number when rewards mining starts.
    uint256 public startBlock;

    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);

    function initFarm(
        address _rewards,
        uint256 _rewardsPerBlock,
        uint256 _startBlock,
        address _devaddr,
        address _admin
    ) public {
        require(!initialised);
        rewards = IERC20(_rewards);
        totalAllocPoint = 0;
        rewardsPerBlock = _rewardsPerBlock;
        startBlock = _startBlock;
        devaddr = _devaddr;
        initAccessControls(_admin);
        initialised = true;
    }

    function initFarm(
        bytes calldata _data
    ) public override {
        (address _rewards,
        uint256 _rewardsPerBlock,
        uint256 _startBlock,
        address _devaddr,
        address _admin) = abi.decode(_data, (address, uint256, uint256, address, address));
        initFarm(_rewards,_rewardsPerBlock,_startBlock,_devaddr,_admin );
    }


    /** 
     * @dev Generates init data for Farm Factory
     * @param _rewards Rewards token address
     * @param _rewardsPerBlock - Rewards per block for the whole farm
     * @param _startBlock - Starting block
     * @param _divaddr Any donations if set are sent here
     * @param _accessControls Gives right to access
     */
    function getInitData(
            address _rewards,
            uint256 _rewardsPerBlock,
            uint256 _startBlock,
            address _divaddr,
            address _accessControls
    )
        external
        pure
        returns (bytes memory _data)
    {
        return abi.encode(_rewards, _rewardsPerBlock, _startBlock, _divaddr, _accessControls);
    }


    function setBonus(
        uint256 _bonusEndBlock,
        uint256 _bonusMultiplier
    ) public {
        require(
            hasAdminRole(msg.sender),
            ""MasterChef.setBonus: Sender must be admin""
        );

        bonusEndBlock = _bonusEndBlock;
        bonusMultiplier = _bonusMultiplier;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function addToken(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public  {
        require(
            hasAdminRole(msg.sender),
            ""MasterChef.addToken: Sender must be admin""
        );
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(PoolInfo({
            lpToken: _lpToken,
            allocPoint: _allocPoint,
            lastRewardBlock: lastRewardBlock,
            accRewardsPerShare: 0
        }));
    }

    // Update the given pools token allocation point. Can only be called by the operator.
    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public  {
        require(
            hasOperatorRole(msg.sender) ,
            ""MasterChef.set: Sender must be admin""
        );
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);
        poolInfo[_pid].allocPoint = _allocPoint;
    }


    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {
        uint256 remaining = blocksRemaining();
        uint multiplier = 0;
        if (remaining == 0) {
            return 0;
        } 
        if (_to <= bonusEndBlock) {
            multiplier = _to.sub(_from).mul(bonusMultiplier);
        } else if (_from >= bonusEndBlock) {
            multiplier = _to.sub(_from);
        } else {
            multiplier = bonusEndBlock.sub(_from).mul(bonusMultiplier).add(
                _to.sub(bonusEndBlock)
            );
        }

        if (multiplier > remaining ) {
            multiplier = remaining;
        }
        return multiplier;
    }

    // View function to see pending tokens on frontend.
    function pendingRewards(uint256 _pid, address _user) external view returns (uint256) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accRewardsPerShare = pool.accRewardsPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint256 rewardsAccum = multiplier.mul(rewardsPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accRewardsPerShare = accRewardsPerShare.add(rewardsAccum.mul(1e12).div(lpSupply));
        }
        return user.amount.mul(accRewardsPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 rewardsAccum = multiplier.mul(rewardsPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        if (devPercentage > 0) {
            tips = tips.add(rewardsAccum.mul(devPercentage).div(1000));
        }
        totalRewardDebt = totalRewardDebt.add(rewardsAccum);
        pool.accRewardsPerShare = pool.accRewardsPerShare.add(rewardsAccum.mul(1e12).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for rewards allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user.amount.mul(pool.accRewardsPerShare).div(1e12).sub(user.rewardDebt);
            if(pending > 0) {
                totalRewardDebt = totalRewardDebt.sub(pending);
                safeRewardsTransfer(msg.sender, pending);
            }
        }
        if(_amount > 0) {
            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);
            user.amount = user.amount.add(_amount);
        }
        user.rewardDebt = user.amount.mul(pool.accRewardsPerShare).div(1e12);
        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accRewardsPerShare).div(1e12).sub(user.rewardDebt);
        if(pending > 0) {
            totalRewardDebt = totalRewardDebt.sub(pending);
            safeRewardsTransfer(msg.sender, pending);
        }
        if(_amount > 0) {
            user.amount = user.amount.sub(_amount);
            pool.lpToken.safeTransfer(address(msg.sender), _amount);
        }
        user.rewardDebt = user.amount.mul(pool.accRewardsPerShare).div(1e12);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;
        pool.lpToken.safeTransfer(address(msg.sender), amount);
        emit EmergencyWithdraw(msg.sender, _pid, amount);
    }

    // Safe rewards transfer function, just in case if rounding error causes pool to not have enough tokens.
    function safeRewardsTransfer(address _to, uint256 _amount) internal {
        uint256 rewardsBal = rewards.balanceOf(address(this));
        if (_amount > rewardsBal) {
            _safeTransfer(address(rewards), _to, rewardsBal);
        } else {
            _safeTransfer(address(rewards), _to, _amount);
        }
    }

    function tokensRemaining() public view returns(uint256) {
        return rewards.balanceOf(address(this));
    }

    function tokenDebt() public view returns(uint256) {
        return  totalRewardDebt.add(tips);
    }


    // Returns the number of blocks remaining with the current rewards balance
    function blocksRemaining() public view returns (uint256){
        if (tokensRemaining() <= tokenDebt()) {
            return 0;
        }
        uint256 rewardsBal = tokensRemaining().sub(tokenDebt()) ;
        if (rewardsPerBlock > 0) {
            if (devPercentage > 0) {
                rewardsBal = rewardsBal.mul(1000).div(devPercentage.add(1000));
            }
            return rewardsBal / rewardsPerBlock;
        } else {
            return 0;
        }
    }

    // Claims any rewards for the developers, if set
    function claimTips() public {
        require(msg.sender == devaddr, ""dev: wut?"");
        require(tips > 0, ""dev: broke"");
        uint256 claimable = tips;
        // devPaid = devPaid.add(claimable);
        tips = 0;
        safeRewardsTransfer(devaddr, claimable);
    }

    // Update dev address by the previous dev.
    function dev(address _devaddr) public {
        require(msg.sender == devaddr, ""dev: wut?"");
        devaddr = _devaddr;
    }

    // Update dev percentage.
    function setDevPercentage(uint256 _devPercentage) public {
        require(msg.sender == devaddr, ""dev: wut?"");
        devPercentage = _devPercentage;
    }

    
}",3418
RealWorld_TA_28_IMasterChef_RealWorld_20240803194313.log,28,IMasterChef,37053,1766,38819,85.0,0.220585,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""../Utils/BoringERC20.sol"";

interface IMasterChef {
    using BoringERC20 for IERC20;
    struct UserInfo {
        uint256 amount;     // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
    }

    struct PoolInfo {
        IERC20 lpToken;           // Address of LP token contract.
        uint256 allocPoint;       // How many allocation points assigned to this pool. SUSHIs to distribute per block.
        uint256 lastRewardBlock;  // Last block number that SUSHIs distribution occurs.
        uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.
    }

    function poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);
    function totalAllocPoint() external view returns (uint256);
    function deposit(uint256 _pid, uint256 _amount) external;
}",220
RealWorld_TA_28_Ownable_RealWorld_20240803185429.log,28,Ownable,58438,1364,59802,84.0,0.31947,"pragma solidity 0.6.12;

import ""../utils/Context.sol"";
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}",481
RealWorld_TA_28_IMisoTokenFactory_RealWorld_20240803194610.log,28,IMisoTokenFactory,21752,1134,22886,80.0,0.13144,"pragma solidity 0.6.12;

interface IMisoTokenFactory {
    function numberOfTokens() external view returns (uint256);
    function getTokens() external view returns (address[] memory);
}",41
RealWorld_TA_28_MISOFarmFactory_RealWorld_20240803170623.log,28,MISOFarmFactory,254050,4300,258350,140.0,1.35625,"pragma solidity 0.6.12;
                                                                                                                                                                                                                    
//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's MISO Farm Factory
//
// A factory to conveniently deploy your own token farming contracts
//
// Inspired by Bokky's EtherVendingMachince.io
// https://github.com/bokkypoobah/FixedSupplyTokenFactory
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------


import ""./Utils/CloneFactory.sol"";
import ""./interfaces/IMisoFarm.sol"";
import ""./Access/MISOAccessControls.sol"";

contract MISOFarmFactory is CloneFactory {

    /// @notice Responsible for access rights to the contract.
    MISOAccessControls public accessControls;
    bytes32 public constant FARM_MINTER_ROLE = keccak256(""FARM_MINTER_ROLE"");

    /// @notice Whether farm factory has been initialized or not.
    bool private initialised;
    /// @notice Contract locked status. If locked, only minters can deploy
    bool public locked;

    /// @notice Struct to track Farm template.
    struct Farm {
        bool exists;
        uint256 templateId;
        uint256 index;
    }

    /// @notice Mapping from auction created through this contract to Auction struct.
    mapping(address => Farm) public farmInfo;

    /// @notice Farms created using the factory.
    address[] public farms;

    /// @notice Template id to track respective farm template.
    uint256 public farmTemplateId;

    /// @notice Mapping from template id to farm template address.
    mapping(uint256 => address) private farmTemplates;

    /// @notice mapping from farm template address to farm template id
    mapping(address => uint256) private farmTemplateToId;

    // /// @notice mapping from template type to template id
    mapping(uint256 => uint256) public currentTemplateId;

    /// @notice Minimum fee to create a farm through the factory.
    uint256 public minimumFee;
    uint256 public integratorFeePct;

    /// @notice Any MISO dividends collected are sent here.
    address payable public misoDiv;

    /// @notice Event emitted when first initializing the Miso Farm Factory.
    event MisoInitFarmFactory(address sender);

    /// @notice Event emitted when a farm is created using template id.
    event FarmCreated(address indexed owner, address indexed addr, address farmTemplate);

    /// @notice Event emitted when farm template is added to factory.
    event FarmTemplateAdded(address newFarm, uint256 templateId);

    /// @notice Event emitted when farm template is removed.
    event FarmTemplateRemoved(address farm, uint256 templateId);

    /**
     * @notice Single gateway to initialize the MISO Farm factory with proper address.
     * @dev Can only be initialized once
     * @param _accessControls Sets address to get the access controls from.
     * @param _misoDiv Sets address to send the dividends.
     * @param _minimumFee Sets a minimum fee for creating farm in the factory.
     * @param _integratorFeePct Fee to UI integration
     */
    function initMISOFarmFactory(
        address _accessControls,
        address payable _misoDiv,
        uint256 _minimumFee,
        uint256 _integratorFeePct
    )
        external
    {
        /// @dev Maybe missing require message?
        require(!initialised);
        require(_misoDiv != address(0));
        locked = true;
        initialised = true;
        misoDiv = _misoDiv;
        minimumFee = _minimumFee;
        integratorFeePct = _integratorFeePct;
        accessControls = MISOAccessControls(_accessControls);
        emit MisoInitFarmFactory(msg.sender);
    }

    /**
     * @notice Sets the minimum fee.
     * @param _amount Fee amount.
     */
    function setMinimumFee(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOFarmFactory: Sender must be operator""
        );
        minimumFee = _amount;
    }

    /**
     * @notice Sets integrator fee percentage.
     * @param _amount Percentage amount.
     */
    function setIntegratorFeePct(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOFarmFactory: Sender must be operator""
        );
        /// @dev this is out of 1000, ie 25% = 250
        require(
            _amount <= 1000, 
            ""MISOFarmFactory: Range is from 0 to 1000""
        );
        integratorFeePct = _amount;
    }

    /**
     * @notice Sets dividend address.
     * @param _divaddr Dividend address.
     */
    function setDividends(address payable _divaddr) external  {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOFarmFactory: Sender must be operator""
        );
        require(_divaddr != address(0));
        misoDiv = _divaddr;
    }

    /**
     * @notice Sets the factory to be locked or unlocked.
     * @param _locked bool.
     */
    function setLocked(bool _locked) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOFarmFactory: Sender must be admin""
        );
        locked = _locked;
    }


    /**
     * @notice Sets the current template ID for any type.
     * @param _templateType Type of template.
     * @param _templateId The ID of the current template for that type
     */
    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOFarmFactory: Sender must be admin""
        );
        currentTemplateId[_templateType] = _templateId;
    }

    /**
     * @notice Used to check whether an address has the minter role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasFarmMinterRole(address _address) public view returns (bool) {
        return accessControls.hasRole(FARM_MINTER_ROLE, _address);
    }



    /**
     * @notice Deploys a farm corresponding to the _templateId and transfers fees.
     * @param _templateId Template id of the farm to create.
     * @param _integratorFeeAccount Address to pay the fee to.
     * @return farm address.
     */
    function deployFarm(
        uint256 _templateId,
        address payable _integratorFeeAccount
    )
        public payable returns (address farm)
    {
        /// @dev If the contract is locked, only admin and minters can deploy. 
        if (locked) {
            require(accessControls.hasAdminRole(msg.sender) 
                    || accessControls.hasMinterRole(msg.sender)
                    || hasFarmMinterRole(msg.sender),
                ""MISOFarmFactory: Sender must be minter if locked""
            );
        }

        require(msg.value >= minimumFee, ""MISOFarmFactory: Failed to transfer minimumFee"");
        require(farmTemplates[_templateId] != address(0));
        uint256 integratorFee = 0;
        uint256 misoFee = msg.value;
        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {
            integratorFee = misoFee * integratorFeePct / 1000;
            misoFee = misoFee - integratorFee;
        }
        farm = createClone(farmTemplates[_templateId]);
        farmInfo[address(farm)] = Farm(true, _templateId, farms.length);
        farms.push(address(farm));
        emit FarmCreated(msg.sender, address(farm), farmTemplates[_templateId]);
        if (misoFee > 0) {
            misoDiv.transfer(misoFee);
        }
        if (integratorFee > 0) {
            _integratorFeeAccount.transfer(integratorFee);
        }
    }

    /**
     * @notice Creates a farm corresponding to the _templateId.
     * @dev Initializes farm with the parameters passed.
     * @param _templateId Template id of the farm to create.
     * @param _integratorFeeAccount Address to pay the fee to.
     * @param _data Data to be passed to the farm contract for init.
     * @return farm address.
     */
    function createFarm(
        uint256 _templateId,
        address payable _integratorFeeAccount,
        bytes calldata _data
    )
        external payable returns (address farm)
    {
        farm = deployFarm(_templateId, _integratorFeeAccount);
        IMisoFarm(farm).initFarm(_data);
    }

    /**
     * @notice Function to add a farm template to create through factory.
     * @dev Should have operator access.
     * @param _template Farm template address to create a farm.
     */
    function addFarmTemplate(address _template) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOFarmFactory: Sender must be operator""
        );
        require(farmTemplateToId[_template] == 0, ""MISOFarmFactory: Template already added"");
        uint256 templateType = IMisoFarm(_template).farmTemplate();
        require(templateType > 0, ""MISOFarmFactory: Incorrect template code "");
        farmTemplateId++;
        farmTemplates[farmTemplateId] = _template;
        farmTemplateToId[_template] = farmTemplateId;
        currentTemplateId[templateType] = farmTemplateId;
        emit FarmTemplateAdded(_template, farmTemplateId);

    }

     /**
     * @notice Function to remove a farm template.
     * @dev Should have operator access.
     * @param _templateId Refers to template ID that is to be deleted.
     */
    function removeFarmTemplate(uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOFarmFactory: Sender must be operator""
        );
        require(farmTemplates[_templateId] != address(0));
        address template = farmTemplates[_templateId];
        farmTemplates[_templateId] = address(0);
        delete farmTemplateToId[template];
        emit FarmTemplateRemoved(template, _templateId);
    }

    /**
     * @notice Get the address based on template ID.
     * @param _farmTemplate Farm template ID.
     * @return Address of the required template ID.
     */
    function getFarmTemplate(uint256 _farmTemplate) external view returns (address) {
        return farmTemplates[_farmTemplate];
    }

    /**
     * @notice Get the ID based on template address.
     * @param _farmTemplate Farm template address.
     * @return ID of the required template address.
     */
    function getTemplateId(address _farmTemplate) external view returns (uint256) {
        return farmTemplateToId[_farmTemplate];
    }

    /**
     * @notice Get the total number of farms in the factory.
     * @return Farms count.
     */
    function numberOfFarms() external view returns (uint256) {
        return farms.length;
    }

    /**
     * @notice Get all farm created in the factory.
     * @return created farms.
     */
    function getFarms() external view returns(address[] memory) {
        return farms;
    }
}",2830
RealWorld_TA_28_BoringBatchable_RealWorld_20240803175322.log,28,BoringBatchable,77496,3502,80998,112.0,0.45752,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable no-inline-assembly

// Audit on 5-Jan-2021 by Keno and BoringCrypto

import ""./BoringERC20.sol"";

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}",692
RealWorld_TA_28_MISOLauncher_RealWorld_20240803171354.log,28,MISOLauncher,280974,5450,286424,170.0,1.51387,"pragma solidity 0.6.12;

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's MISO Launcher
//
// A factory to conveniently deploy your own liquidity contracts
//
// Inspired by Bokky's EtherVendingMachince.io
// https://github.com/bokkypoobah/FixedSupplyTokenFactory
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""./Utils/SafeTransfer.sol"";
import ""./Utils/BoringMath.sol"";
import ""./Access/MISOAccessControls.sol"";
import ""./interfaces/IERC20.sol"";
import ""./interfaces/IMisoLiquidity.sol"";
import ""./interfaces/IBentoBoxFactory.sol"";


contract MISOLauncher is SafeTransfer {

    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;

    /// @notice Responsible for access rights to the contract.
    MISOAccessControls public accessControls;
    bytes32 public constant LAUNCHER_MINTER_ROLE = keccak256(""LAUNCHER_MINTER_ROLE"");

    /// @notice Whether launcher has been initialized or not.
    bool private initialised;

    /// @notice Struct to track Auction template.
    struct Launcher {
        bool exists;
        uint64 templateId;
        uint128 index;
    }

    /// @notice All the launchers created using factory.
    address[] public launchers;

    /// @notice Template id to track respective auction template.
    uint256 public launcherTemplateId;

    /// @notice Address for Wrapped Ether.
    address public WETH;
    IBentoBoxFactory public bentoBox;

    /// @notice Mapping from template id to launcher template address.
    mapping(uint256 => address) private launcherTemplates;

    /// @notice mapping from launcher template address to launcher template id
    mapping(address => uint256) private launcherTemplateToId;

    // /// @notice mapping from template type to template id
    mapping(uint256 => uint256) public currentTemplateId;

    /// @notice Mapping from auction created through this contract to Auction struct.
    mapping(address => Launcher) public launcherInfo;

    /// @notice Struct to define fees.
    struct LauncherFees {
        uint128 minimumFee;
        uint32 integratorFeePct;
    }

    /// @notice Minimum fee to create a launcher through the factory.
    LauncherFees public launcherFees;

    /// @notice Contract locked status. If locked, only minters can deploy
    bool public locked;

    ///@notice Any donations if set are sent here.
    address payable public misoDiv;

    /// @notice Event emitted when first intializing the liquidity launcher.
    event MisoInitLauncher(address sender);

    /// @notice Event emitted when launcher is created using template id.
    event LauncherCreated(address indexed owner, address indexed addr, address launcherTemplate);

    /// @notice Event emitted when launcher template is added to factory.
    event LauncherTemplateAdded(address newLauncher, uint256 templateId);

    /// @notice Event emitted when launcher template is removed.
    event LauncherTemplateRemoved(address launcher, uint256 templateId);

    constructor() public {
    }

    /**
     * @notice Single gateway to initialize the MISO Launcher with proper address.
     * @dev Can only be initialized once.
     * @param _accessControls Sets address to get the access controls from.
     */
    function initMISOLauncher(address _accessControls, address _WETH, address _bentoBox) external {
        require(!initialised);
        require(_WETH != address(0), ""initMISOLauncher: WETH cannot be set to zero"");
        require(_accessControls != address(0), ""initMISOLauncher: accessControls cannot be set to zero"");
        require(_bentoBox != address(0), ""initMISOLauncher: bentoBox cannot be set to zero"");

        accessControls = MISOAccessControls(_accessControls);
        bentoBox = IBentoBoxFactory(_bentoBox); 
        WETH = _WETH;
        locked = true;
        initialised = true;

        emit MisoInitLauncher(msg.sender);
    }

    /**
     * @notice Sets the minimum fee.
     * @param _amount Fee amount.
     */
    function setMinimumFee(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOLauncher: Sender must be operator""
        );
        launcherFees.minimumFee = BoringMath.to128(_amount);
    }

    /**
     * @notice Sets integrator fee percentage.
     * @param _amount Percentage amount.
     */
    function setIntegratorFeePct(uint256 _amount) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOLauncher: Sender must be operator""
        );
        /// @dev this is out of 1000, ie 25% = 250
        require(_amount <= 1000, ""MISOLauncher: Percentage is out of 1000"");
        launcherFees.integratorFeePct = BoringMath.to32(_amount);
    }

    /**
     * @notice Sets dividend address.
     * @param _divaddr Dividend address.
     */
    function setDividends(address payable _divaddr) external {
        require(accessControls.hasAdminRole(msg.sender), ""MISOLauncher.setDev: Sender must be operator"");
        require(_divaddr != address(0));
        misoDiv = _divaddr;
    }
    /**
     * @notice Sets the factory to be locked or unlocked.
     * @param _locked bool.
     */
    function setLocked(bool _locked) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOLauncher: Sender must be admin""
        );
        locked = _locked;
    }

    /**
     * @notice Sets the current template ID for any type.
     * @param _templateType Type of template.
     * @param _templateId The ID of the current template for that type
     */
    function setCurrentTemplateId(uint256 _templateType, uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOLauncher: Sender must be admin""
        );
        currentTemplateId[_templateType] = _templateId;
    }

    /**
     * @notice Used to check whether an address has the minter role
     * @param _address EOA or contract being checked
     * @return bool True if the account has the role or false if it does not
     */
    function hasLauncherMinterRole(address _address) public view returns (bool) {
        return accessControls.hasRole(LAUNCHER_MINTER_ROLE, _address);
    }



    /**
     * @notice Creates a launcher corresponding to _templateId.
     * @param _templateId Template id of the launcher to create.
     * @param _integratorFeeAccount Address to pay the fee to.
     * @return launcher  Launcher address.
     */
    function deployLauncher(
        uint256 _templateId,
        address payable _integratorFeeAccount
    )
        public payable returns (address launcher)
    {
        /// @dev If the contract is locked, only admin and minters can deploy. 
        if (locked) {
            require(accessControls.hasAdminRole(msg.sender) 
                    || accessControls.hasMinterRole(msg.sender)
                    || hasLauncherMinterRole(msg.sender),
                ""MISOLauncher: Sender must be minter if locked""
            );
        }

        LauncherFees memory _launcherFees = launcherFees;
        address launcherTemplate = launcherTemplates[_templateId];
        require(msg.value >= uint256(_launcherFees.minimumFee), ""MISOLauncher: Failed to transfer minimumFee"");
        require(launcherTemplate != address(0), ""MISOLauncher: Launcher template doesn't exist"");
        uint256 integratorFee = 0;
        uint256 misoFee = msg.value;
        if (_integratorFeeAccount != address(0) && _integratorFeeAccount != misoDiv) {
            integratorFee = misoFee * uint256(_launcherFees.integratorFeePct) / 1000;
            misoFee = misoFee - integratorFee;
        }
        /// @dev Deploy using the BentoBox factory. 
        launcher = bentoBox.deploy(launcherTemplate, """", false);
        launcherInfo[address(launcher)] = Launcher(true, BoringMath.to64(_templateId), BoringMath.to128(launchers.length));
        launchers.push(address(launcher));
        emit LauncherCreated(msg.sender, address(launcher), launcherTemplates[_templateId]);
        if (misoFee > 0) {
            misoDiv.transfer(misoFee);
        }
        if (integratorFee > 0) {
            _integratorFeeAccount.transfer(integratorFee);
        }
    }


    /**
     * @notice Creates a new MISOLauncher using _templateId.
     * @dev Initializes auction with the parameters passed.
     * @param _templateId Id of the auction template to create.
     * @param _token The token address to be sold.
     * @param _tokenSupply Amount of tokens to be sold at market.
     * @param _integratorFeeAccount Address to send refferal bonus, if set.
     * @param _data Data to be sent to template on Init.
     * @return newLauncher Launcher address.
     */
    function createLauncher(
        uint256 _templateId,
        address _token,
        uint256 _tokenSupply,
        address payable _integratorFeeAccount,
        bytes calldata _data
    )
        external payable returns (address newLauncher)
    {

        newLauncher = deployLauncher(_templateId, _integratorFeeAccount);
        if (_tokenSupply > 0) {
            _safeTransferFrom(_token, msg.sender, _tokenSupply);
            require(IERC20(_token).approve(newLauncher, _tokenSupply), ""1"");
        }
        IMisoLiquidity(newLauncher).initLauncher(_data);

        if (_tokenSupply > 0) {
            uint256 remainingBalance = IERC20(_token).balanceOf(address(this));
            if (remainingBalance > 0) {
                _safeTransfer(_token, msg.sender, remainingBalance);
            }
        }
        return newLauncher;
    }


    /**
     * @notice Function to add a launcher template to create through factory.
     * @dev Should have operator access
     * @param _template Launcher template address.
    */
    function addLiquidityLauncherTemplate(address _template) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOLauncher: Sender must be operator""
        );
        uint256 templateType = IMisoLiquidity(_template).liquidityTemplate();
        require(templateType > 0, ""MISOLauncher: Incorrect template code "");
        launcherTemplateId++;

        launcherTemplates[launcherTemplateId] = _template;
        launcherTemplateToId[_template] = launcherTemplateId;
        currentTemplateId[templateType] = launcherTemplateId;
        emit LauncherTemplateAdded(_template, launcherTemplateId);

    }

    /**
     * @dev Function to remove a launcher template from factory.
     * @dev Should have operator access.
     * @param _templateId Id of the template to be deleted.
     */
    function removeLiquidityLauncherTemplate(uint256 _templateId) external {
        require(
            accessControls.hasAdminRole(msg.sender) ||
            accessControls.hasOperatorRole(msg.sender),
            ""MISOLauncher: Sender must be operator""
        );
        require(launcherTemplates[_templateId] != address(0));
        address _template = launcherTemplates[_templateId];
        launcherTemplates[_templateId] = address(0);
        delete launcherTemplateToId[_template];
        emit LauncherTemplateRemoved(_template, _templateId);
    }

    /**
     * @notice Get the address based on launcher template ID.
     * @param _templateId Launcher template ID.
     * @return address of the required template ID.
     */
    function getLiquidityLauncherTemplate(uint256 _templateId) external view returns (address) {
        return launcherTemplates[_templateId];
    }

    function getTemplateId(address _launcherTemplate) external view returns (uint256) {
        return launcherTemplateToId[_launcherTemplate];
    }

    /**
     * @notice Get the total number of launchers in the contract.
     * @return uint256 Launcher count.
     */
    function numberOfLiquidityLauncherContracts() external view returns (uint256) {
        return launchers.length;
    }

    function minimumFee() external view returns(uint128) {
        return launcherFees.minimumFee;
    }

    function getLauncherTemplateId(address _launcher) external view returns(uint64) {
        return launcherInfo[_launcher].templateId;
    }
    function getLaunchers() external view returns(address[] memory) {
        return launchers;
    }


}",3142
RealWorld_TA_28_IMisoFermenter_RealWorld_20240803194148.log,28,IMisoFermenter,20684,1384,22068,83.0,0.1311,"pragma solidity 0.6.12;

interface IMisoFermenter {
    function initERC20Vault() external;
}",27
RealWorld_TA_28_PostAuctionLauncher_RealWorld_20240803192028.log,28,PostAuctionLauncher,328607,8015,336622,178.0,1.803335,"pragma solidity 0.6.12;


//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's Post Auction Launcher
//
// A post auction contract that takes the proceeds and creates a liquidity pool
//
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""../OpenZeppelin/utils/ReentrancyGuard.sol"";
import ""../Access/MISOAccessControls.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../Utils/BoringMath.sol"";
import ""../UniswapV2/UniswapV2Library.sol"";
import ""../UniswapV2/interfaces/IUniswapV2Pair.sol"";
import ""../UniswapV2/interfaces/IUniswapV2Factory.sol"";
import ""../interfaces/IWETH9.sol"";
import ""../interfaces/IERC20.sol"";
import ""../interfaces/IMisoAuction.sol"";



contract PostAuctionLauncher is MISOAccessControls, SafeTransfer, ReentrancyGuard {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;
    using BoringMath32 for uint32;
    using BoringMath16 for uint16;


    /// @notice Number of seconds per day.
    uint256 private constant SECONDS_PER_DAY = 24 * 60 * 60;
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant LIQUIDITY_PRECISION = 10000;
    
    /// @notice MISOLiquidity template id.
    uint256 public constant liquidityTemplate = 3;

    /// @notice First Token address.
    IERC20 public token1;
    /// @notice Second Token address.
    IERC20 public token2;
    /// @notice Uniswap V2 factory address.
    IUniswapV2Factory public factory;
    /// @notice WETH contract address.
    address private immutable weth;


    /// @notice LP pair address.
    address public tokenPair;
    /// @notice Withdraw wallet address.
    address public wallet;
    /// @notice Token market contract address.
    IMisoAuction public market;

    struct LauncherInfo {
        uint32 locktime;
        uint64 unlock;
        uint16 liquidityPercent;
        bool launched;
        uint128 liquidityAdded;
    }
    LauncherInfo public launcherInfo;

    /// @notice Emitted when LP contract is initialised.
    event InitLiquidityLauncher(address indexed token1, address indexed token2, address factory, address sender);
    /// @notice Emitted when LP is launched.
    event LiquidityAdded(uint256 liquidity);
    /// @notice Emitted when wallet is updated.
    event WalletUpdated(address indexed wallet);
    /// @notice Emitted when launcher is cancelled.
    event LauncherCancelled(address indexed wallet);

    constructor (address _weth) public {
        weth = _weth;
    }


    /**
     * @notice Initializes main contract variables (requires launchwindow to be more than 2 days.)
     * @param _market Auction address for launcher.
     * @param _factory Uniswap V2 factory address.
     * @param _admin Contract owner address.
     * @param _wallet Withdraw wallet address.
     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.
     * @param _locktime How long the liquidity will be locked. Number of seconds.
     */
    function initAuctionLauncher(
            address _market,
            address _factory,
            address _admin,
            address _wallet,
            uint256 _liquidityPercent,
            uint256 _locktime
    )
        public
    {
        require(_locktime < 10000000000, 'PostAuction: Enter an unix timestamp in seconds, not miliseconds');
        require(_liquidityPercent <= LIQUIDITY_PRECISION, 'PostAuction: Liquidity percentage greater than 100.00% (>10000)');
        require(_liquidityPercent > 0, 'PostAuction: Liquidity percentage equals zero');
        require(_admin != address(0), ""PostAuction: admin is the zero address"");
        require(_wallet != address(0), ""PostAuction: wallet is the zero address"");

        initAccessControls(_admin);

        market = IMisoAuction(_market);
        token1 = IERC20(market.paymentCurrency());
        token2 = IERC20(market.auctionToken());

        if (address(token1) == ETH_ADDRESS) {
            token1 = IERC20(weth);
        }

        uint256 d1 = uint256(token1.decimals());
        uint256 d2 = uint256(token2.decimals());
        require(d2 >= d1);

        factory = IUniswapV2Factory(_factory);
        bytes32 pairCodeHash = IUniswapV2Factory(_factory).pairCodeHash();
        tokenPair = UniswapV2Library.pairFor(_factory, address(token1), address(token2), pairCodeHash);
   
        wallet = _wallet;
        launcherInfo.liquidityPercent = BoringMath.to16(_liquidityPercent);
        launcherInfo.locktime = BoringMath.to32(_locktime);

        uint256 initalTokenAmount = market.getTotalTokens().mul(_liquidityPercent).div(LIQUIDITY_PRECISION);
        _safeTransferFrom(address(token2), msg.sender, initalTokenAmount);

        emit InitLiquidityLauncher(address(token1), address(token2), address(_factory), _admin);
    }

    receive() external payable {
        if(msg.sender != weth ){
             depositETH();
        }
    }

    /// @notice Deposits ETH to the contract.
    function depositETH() public payable {
        require(address(token1) == weth || address(token2) == weth, ""PostAuction: Launcher not accepting ETH"");
        if (msg.value > 0 ) {
            IWETH(weth).deposit{value : msg.value}();
        }
    }

    /**
     * @notice Deposits first Token to the contract.
     * @param _amount Number of tokens to deposit.
     */
    function depositToken1(uint256 _amount) external returns (bool success) {
        return _deposit( address(token1), msg.sender, _amount);
    }

    /**
     * @notice Deposits second Token to the contract.
     * @param _amount Number of tokens to deposit.
     */
    function depositToken2(uint256 _amount) external returns (bool success) {
        return _deposit( address(token2), msg.sender, _amount);
    }

    /**
     * @notice Deposits Tokens to the contract.
     * @param _amount Number of tokens to deposit.
     * @param _from Where the tokens to deposit will come from.
     * @param _token Token address.
     */
    function _deposit(address _token, address _from, uint _amount) internal returns (bool success) {
        require(!launcherInfo.launched, ""PostAuction: Must first launch liquidity"");
        require(launcherInfo.liquidityAdded == 0, ""PostAuction: Liquidity already added"");

        require(_amount > 0, ""PostAuction: Token amount must be greater than 0"");
        _safeTransferFrom(_token, _from, _amount);
        return true;
    }


    /**
     * @notice Checks if market wallet is set to this launcher
     */
    function marketConnected() public view returns (bool)  {
        return market.wallet() == address(this);
    }

    /**
     * @notice Finalizes Token sale and launches LP.
     * @return liquidity Number of LPs.
     */
    function finalize() external nonReentrant returns (uint256 liquidity) {
        // GP: Can we remove admin, let anyone can finalise and launch?
        // require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PostAuction: Sender must be operator"");
        require(marketConnected(), ""PostAuction: Auction must have this launcher address set as the destination wallet"");
        require(!launcherInfo.launched);

        if (!market.finalized()) {
            market.finalize();
        }
        require(market.finalized());

        launcherInfo.launched = true;
        if (!market.auctionSuccessful() ) {
            return 0;
        }

        /// @dev if the auction is settled in weth, wrap any contract balance 
        uint256 launcherBalance = address(this).balance;
        if (launcherBalance > 0 ) {
            IWETH(weth).deposit{value : launcherBalance}();
        }
        
        (uint256 token1Amount, uint256 token2Amount) =  getTokenAmounts();

        /// @dev cannot start a liquidity pool with no tokens on either side
        if (token1Amount == 0 || token2Amount == 0 ) {
            return 0;
        }

        address pair = factory.getPair(address(token1), address(token2));
        if(pair == address(0)) {
            createPool();
        }

        /// @dev add liquidity to pool via the pair directly
        _safeTransfer(address(token1), tokenPair, token1Amount);
        _safeTransfer(address(token2), tokenPair, token2Amount);
        liquidity = IUniswapV2Pair(tokenPair).mint(address(this));
        launcherInfo.liquidityAdded = BoringMath.to128(uint256(launcherInfo.liquidityAdded).add(liquidity));

        /// @dev if unlock time not yet set, add it.
        if (launcherInfo.unlock == 0 ) {
            launcherInfo.unlock = BoringMath.to64(block.timestamp + uint256(launcherInfo.locktime));
        }
        emit LiquidityAdded(liquidity);
    }


    function getTokenAmounts() public view returns (uint256 token1Amount, uint256 token2Amount) {
        token1Amount = getToken1Balance().mul(uint256(launcherInfo.liquidityPercent)).div(LIQUIDITY_PRECISION);
        token2Amount = getToken2Balance(); 

        uint256 tokenPrice = market.tokenPrice();  
        uint256 d2 = uint256(token2.decimals());
        uint256 maxToken1Amount = token2Amount.mul(tokenPrice).div(10**(d2));
        uint256 maxToken2Amount = token1Amount
                                    .mul(10**(d2))
                                    .div(tokenPrice);

        /// @dev if more than the max.
        if (token2Amount > maxToken2Amount) {
            token2Amount =  maxToken2Amount;
        } 
        /// @dev if more than the max.
        if (token1Amount > maxToken1Amount) {
            token1Amount =  maxToken1Amount;
        }

    }

    /**
     * @notice Withdraws LPs from the contract.
     * @return liquidity Number of LPs.
     */
    function withdrawLPTokens() external returns (uint256 liquidity) {
        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PostAuction: Sender must be operator"");
        require(launcherInfo.launched, ""PostAuction: Must first launch liquidity"");
        require(block.timestamp >= uint256(launcherInfo.unlock), ""PostAuction: Liquidity is locked"");
        liquidity = IERC20(tokenPair).balanceOf(address(this));
        require(liquidity > 0, ""PostAuction: Liquidity must be greater than 0"");
        _safeTransfer(tokenPair, wallet, liquidity);
    }

    /// @notice Withraws deposited tokens and ETH from the contract to wallet.
    function withdrawDeposits() external {
        require(hasAdminRole(msg.sender) || hasOperatorRole(msg.sender), ""PostAuction: Sender must be operator"");
        require(launcherInfo.launched, ""PostAuction: Must first launch liquidity"");

        uint256 token1Amount = getToken1Balance();
        if (token1Amount > 0 ) {
            _safeTransfer(address(token1), wallet, token1Amount);
        }
        uint256 token2Amount = getToken2Balance();
        if (token2Amount > 0 ) {
            _safeTransfer(address(token2), wallet, token2Amount);
        }
    }

    // TODO     
    // GP: Sweep non relevant ERC20s / ETH


    //--------------------------------------------------------
    // Setter functions
    //--------------------------------------------------------


    /**
     * @notice Admin can set the wallet through this function.
     * @param _wallet Wallet is where funds will be sent.
     */
    function setWallet(address payable _wallet) external {
        require(hasAdminRole(msg.sender));
        require(_wallet != address(0), ""Wallet is the zero address"");

        wallet = _wallet;

        emit WalletUpdated(_wallet);
    }

    function cancelLauncher() external {
        require(hasAdminRole(msg.sender));
        require(!launcherInfo.launched);

        launcherInfo.launched = true;
        emit LauncherCancelled(msg.sender);

    }

    //--------------------------------------------------------
    // Helper functions
    //--------------------------------------------------------

    /**
     * @notice Creates new SLP pair through SushiSwap.
     */
    function createPool() public {
        factory.createPair(address(token1), address(token2));
    }

    //--------------------------------------------------------
    // Getter functions
    //--------------------------------------------------------

    /**
     * @notice Gets the number of first token deposited into this contract.
     * @return uint256 Number of WETH.
     */
    function getToken1Balance() public view returns (uint256) {
         return token1.balanceOf(address(this));
    }

    /**
     * @notice Gets the number of second token deposited into this contract.
     * @return uint256 Number of WETH.
     */
    function getToken2Balance() public view returns (uint256) {
         return token2.balanceOf(address(this));
    }

    /**
     * @notice Returns LP token address..
     * @return address LP address.
     */
    function getLPTokenAddress() public view returns (address) {
        return tokenPair;
    }
    /**
     * @notice Returns LP Token balance.
     * @return uint256 LP Token balance.
     */
    function getLPBalance() public view returns (uint256) {
         return IERC20(tokenPair).balanceOf(address(this));
    }


    //--------------------------------------------------------
    // Init functions
    //--------------------------------------------------------


    /**
     * @notice Decodes and hands auction data to the initAuction function.
     * @param _data Encoded data for initialization.
     */

    function init(bytes calldata _data) external payable {

    }

    function initLauncher(
        bytes calldata _data
    ) public {
        (
            address _market,
            address _factory,
            address _admin,
            address _wallet,
            uint256 _liquidityPercent,
            uint256 _locktime
        ) = abi.decode(_data, (
            address,
            address,
            address,
            address,
            uint256,
            uint256
        ));
        initAuctionLauncher( _market, _factory,_admin,_wallet,_liquidityPercent,_locktime);
    }

    /**
     * @notice Collects data to initialize the auction and encodes them.
     * @param _market Auction address for launcher.
     * @param _factory Uniswap V2 factory address.
     * @param _admin Contract owner address.
     * @param _wallet Withdraw wallet address.
     * @param _liquidityPercent Percentage of payment currency sent to liquidity pool.
     * @param _locktime How long the liquidity will be locked. Number of seconds.
     * @return _data All the data in bytes format.
     */
    function getLauncherInitData(
            address _market,
            address _factory,
            address _admin,
            address _wallet,
            uint256 _liquidityPercent,
            uint256 _locktime
    )
        external 
        pure
        returns (bytes memory _data)
    {
            return abi.encode(_market,
                                _factory,
                                _admin,
                                _wallet,
                                _liquidityPercent,
                                _locktime
            );
    }

}",3728
RealWorld_TA_28_TokenTimelock_RealWorld_20240803185127.log,28,TokenTimelock,54182,2667,56849,93.0,0.32425,"pragma solidity 0.6.12;

import ""./SafeERC20.sol"";

/**
 * @dev A token holder contract that will allow a beneficiary to extract the
 * tokens after a given release time.
 *
 * Useful for simple vesting schedules like ""advisors get all of their tokens
 * after 1 year"".
 */
contract TokenTimelock {
    using SafeERC20 for IERC20;

    // ERC20 basic token contract being held
    IERC20 private _token;

    // beneficiary of tokens after they are released
    address private _beneficiary;

    // timestamp when token release is enabled
    uint256 private _releaseTime;

    constructor (IERC20 token_, address beneficiary_, uint256 releaseTime_) public {
        // solhint-disable-next-line not-rely-on-time
        require(releaseTime_ > block.timestamp, ""TokenTimelock: release time is before current time"");
        _token = token_;
        _beneficiary = beneficiary_;
        _releaseTime = releaseTime_;
    }

    /**
     * @return the token being held.
     */
    function token() public view virtual returns (IERC20) {
        return _token;
    }

    /**
     * @return the beneficiary of the tokens.
     */
    function beneficiary() public view virtual returns (address) {
        return _beneficiary;
    }

    /**
     * @return the time when the tokens are released.
     */
    function releaseTime() public view virtual returns (uint256) {
        return _releaseTime;
    }

    /**
     * @notice Transfers tokens held by timelock to beneficiary.
     */
    function release() public virtual {
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp >= releaseTime(), ""TokenTimelock: current time is before release time"");

        uint256 amount = token().balanceOf(address(this));
        require(amount > 0, ""TokenTimelock: no tokens to release"");

        token().safeTransfer(beneficiary(), amount);
    }
}",422
RealWorld_TA_28_ISafeGnosis_RealWorld_20240803195022.log,28,ISafeGnosis,30858,1734,32592,81.0,0.18897,"pragma solidity 0.6.12;

interface ISafeGnosis{
     function setup(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    )
        external;

    function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
       //ENUM.Operation?
        uint256 operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes calldata signatures
    )
        external
        payable
        returns (bool success);

}",150
RealWorld_TA_28_IERC20_RealWorld_20240803192857.log,28,IERC20,33066,1294,34360,78.0,0.19121,"pragma solidity 0.6.12;

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",176
RealWorld_TA_28_MISOAccessFactory_RealWorld_20240803175127.log,28,MISOAccessFactory,101593,3997,105590,113.0,0.587905,"pragma solidity 0.6.12;

import ""../Utils/CloneFactory.sol"";
import ""./MISOAccessControls.sol"";


contract MISOAccessFactory is CloneFactory {

    /// @notice Responsible for access rights to the contract.
    MISOAccessControls public accessControls;

    /// @notice Address of the template for access controls.
    address public accessControlTemplate;

    /// @notice Whether initialized or not.
    bool private initialised;

    /// @notice Minimum fee number.
    uint256 public minimumFee;

    /// @notice Devs address.
    address public devaddr;

    /// @notice AccessControls created using the factory.
    address[] public children;

    /// @notice Tracks if a contract is made by the factory.
    mapping(address => bool) public isChild;

    /// @notice Event emitted when first initializing Miso AccessControl Factory.
    event MisoInitAccessFactory(address sender);

    /// @notice Event emitted when a access is created using template id.
    event AccessControlCreated(address indexed owner,  address accessControls, address admin, address accessTemplate);

    /// @notice Event emitted when a access template is added.
    event AccessControlTemplateAdded(address oldAccessControl, address newAccessControl);

    /// @notice Event emitted when a access template is removed.
    event AccessControlTemplateRemoved(address access, uint256 templateId);

    /// @notice Event emitted when a access template is removed.
    event MinimumFeeUpdated(uint oldFee, uint newFee);

    /// @notice Event emitted when a access template is removed.
    event DevAddressUpdated(address oldDev, address newDev);


    constructor() public {
    }

    /**
     * @notice Single gateway to initialize the MISO AccessControl Factory with proper address and set minimum fee.
     * @dev Can only be initialized once.
     * @param _minimumFee Minimum fee number.
     * @param _accessControls Address of the access controls.
     */
    function initMISOAccessFactory(uint256 _minimumFee, address _accessControls) external {
        require(!initialised);
        initialised = true;
        minimumFee = _minimumFee;
        accessControls = MISOAccessControls(_accessControls);
        emit MisoInitAccessFactory(msg.sender);
    }

    /// @notice Get the total number of children in the factory.
    function numberOfChildren() external view returns (uint256) {
        return children.length;
    }

    /**
     * @notice Creates access corresponding to template id.
     * @dev Initializes access with parameters passed.
     * @param _admin Address of admin access.
     */
    function deployAccessControl(address _admin) external payable returns (address access) {
        require(msg.value >= minimumFee, ""Minimum fee needs to be paid."");
        require(accessControlTemplate != address(0), ""Access control template does not exist"");
        access = createClone(accessControlTemplate);
        isChild[address(access)] = true;
        children.push(address(access));
        MISOAccessControls(access).initAccessControls(_admin);
        emit AccessControlCreated(msg.sender, address(access), _admin, accessControlTemplate);
        if (msg.value > 0) {
            payable(devaddr).transfer(msg.value);
        }
    }

    /**
     * @notice Function to add new contract templates for the factory.
     * @dev Should have operator access.
     * @param _template Template to create new access controls.
     */
    function updateAccessTemplate(address _template) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOAccessFactory.updateAccessTemplate: Sender must be admin""
        );
        require(_template != address(0));
        emit AccessControlTemplateAdded(_template, accessControlTemplate);
        accessControlTemplate = _template;
    }

    /**
     * @notice Sets dev address.
     * @dev Should have operator access.
     * @param _devaddr Devs address.
     */
    function setDev(address _devaddr) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOAccessFactory.setMinimumFee: Sender must be admin""
        );
        emit DevAddressUpdated(devaddr, _devaddr);
        devaddr = _devaddr;
    }

    /**
     * @notice Sets minimum fee.
     * @dev Should have operator access.
     * @param _minimumFee Minimum fee number.
     */
    function setMinimumFee(uint256 _minimumFee) external {
        require(
            accessControls.hasAdminRole(msg.sender),
            ""MISOAccessFactory.setMinimumFee: Sender must be admin""
        );
        emit MinimumFeeUpdated(minimumFee, _minimumFee);
        minimumFee = _minimumFee;
    }
}",959
RealWorld_TA_28_IERC20_RealWorld_20240803173049.log,28,IERC20,32140,1400,33540,79.0,0.1887,"pragma solidity 0.6.12;

interface IERC20Uniswap {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}",164
RealWorld_TA_28_SignedSafeMath_RealWorld_20240803191738.log,28,SignedSafeMath,75186,1430,76616,79.0,0.40453,"pragma solidity 0.6.12;

library SignedSafeMath {
    int256 constant private _INT256_MIN = -2**255;

    /**
     * @dev Returns the multiplication of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(int256 a, int256 b) internal pure returns (int256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        require(!(a == -1 && b == _INT256_MIN), ""SignedSafeMath: multiplication overflow"");

        int256 c = a * b;
        require(c / a == b, ""SignedSafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two signed integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(int256 a, int256 b) internal pure returns (int256) {
        require(b != 0, ""SignedSafeMath: division by zero"");
        require(!(b == -1 && a == _INT256_MIN), ""SignedSafeMath: division overflow"");

        int256 c = a / b;

        return c;
    }

    /**
     * @dev Returns the subtraction of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a - b;
        require((b >= 0 && c <= a) || (b < 0 && c > a), ""SignedSafeMath: subtraction overflow"");

        return c;
    }

    /**
     * @dev Returns the addition of two signed integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(int256 a, int256 b) internal pure returns (int256) {
        int256 c = a + b;
        require((b >= 0 && c >= a) || (b < 0 && c < a), ""SignedSafeMath: addition overflow"");

        return c;
    }

    function toUInt256(int256 a) internal pure returns (uint256) {
        require(a >= 0, ""Integer < 0"");
        return uint256(a);
    }
}",682
RealWorld_TA_28_UniswapV2ERC20_RealWorld_20240803171916.log,28,UniswapV2ERC20,83966,2364,86330,94.0,0.46711,"pragma solidity =0.6.12;

import './libraries/SafeMath.sol';

contract UniswapV2ERC20 {
    using SafeMathUniswap for uint;

    string public constant name = 'SushiSwap LP Token';
    string public constant symbol = 'SLP';
    uint8 public constant decimals = 18;
    uint  public totalSupply;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint) public nonces;

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    constructor() public {
        uint chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function _mint(address to, uint value) internal {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint value) internal {
        balanceOf[from] = balanceOf[from].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(from, address(0), value);
    }

    function _approve(address owner, address spender, uint value) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(address from, address to, uint value) private {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint value) external returns (bool) {
        if (allowance[from][msg.sender] != uint(-1)) {
            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        }
        _transfer(from, to, value);
        return true;
    }

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    }
}",773
RealWorld_TA_28_BatchAuction_RealWorld_20240803182105.log,28,BatchAuction,415934,6673,422607,198.0,2.21313,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

//----------------------------------------------------------------------------------
//    I n s t a n t
//
//        .:mmm.         .:mmm:.       .ii.  .:SSSSSSSSSSSSS.     .oOOOOOOOOOOOo.  
//      .mMM'':Mm.     .:MM'':Mm:.     .II:  :SSs..........     .oOO'''''''''''OOo.
//    .:Mm'   ':Mm.   .:Mm'   'MM:.    .II:  'sSSSSSSSSSSSSS:.  :OO.           .OO:
//  .'mMm'     ':MM:.:MMm'     ':MM:.  .II:  .:...........:SS.  'OOo:.........:oOO'
//  'mMm'        ':MMmm'         'mMm:  II:  'sSSSSSSSSSSSSS'     'oOOOOOOOOOOOO'  
//
//----------------------------------------------------------------------------------
//
// Chef Gonpachi's Batch Auction
//
// An auction where contributions are swaped for a batch of tokens pro-rata
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// Made for Sushi.com 
// 
// Enjoy. (c) Chef Gonpachi, Kusatoshi, SSMikazu 2021 
// <https://github.com/chefgonpachi/MISO/>
//
// ---------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0                        
// ---------------------------------------------------------------------

import ""../OpenZeppelin/utils/ReentrancyGuard.sol"";
import ""../Access/MISOAccessControls.sol"";
import ""../Utils/SafeTransfer.sol"";
import ""../Utils/BoringBatchable.sol"";
import ""../Utils/BoringMath.sol"";
import ""../Utils/BoringERC20.sol"";
import ""../Utils/Documents.sol"";
import ""../interfaces/IPointList.sol"";
import ""../interfaces/IMisoMarket.sol"";

/// @notice Attribution to delta.financial
/// @notice Attribution to dutchswap.com


contract BatchAuction is  IMisoMarket, MISOAccessControls, BoringBatchable, SafeTransfer, Documents, ReentrancyGuard  {

    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringMath64 for uint64;
    using BoringERC20 for IERC20;

    /// @notice MISOMarket template id for the factory contract.
    /// @dev For different marketplace types, this must be incremented.
    uint256 public constant override marketTemplate = 3;

    /// @dev The placeholder ETH address.
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @notice Main market variables.
    struct MarketInfo {
        uint64 startTime;
        uint64 endTime; 
        uint128 totalTokens;
    }
    MarketInfo public marketInfo;

    /// @notice Market dynamic variables.
    struct MarketStatus {
        uint128 commitmentsTotal;
        uint128 minimumCommitmentAmount;
        bool finalized;
        bool usePointList;
    }

    MarketStatus public marketStatus;

    address public auctionToken;
    /// @notice The currency the crowdsale accepts for payment. Can be ETH or token address.
    address public paymentCurrency;
    /// @notice Address that manages auction approvals.
    address public pointList;
    address payable public wallet; // Where the auction funds will get paid

    mapping(address => uint256) public commitments;
    /// @notice Amount of tokens to claim per address.
    mapping(address => uint256) public claimed;

    /// @notice Event for updating auction times.  Needs to be before auction starts.
    event AuctionTimeUpdated(uint256 startTime, uint256 endTime); 
    /// @notice Event for updating auction prices. Needs to be before auction starts.
    event AuctionPriceUpdated(uint256 minimumCommitmentAmount); 
    /// @notice Event for updating auction wallet. Needs to be before auction starts.
    event AuctionWalletUpdated(address wallet); 

    /// @notice Event for adding a commitment.
    event AddedCommitment(address addr, uint256 commitment);
    /// @notice Event for finalization of the auction.
    event AuctionFinalized();
    /// @notice Event for cancellation of the auction.
    event AuctionCancelled();

    /**
     * @notice Initializes main contract variables and transfers funds for the auction.
     * @dev Init function.
     * @param _funder The address that funds the token for crowdsale.
     * @param _token Address of the token being sold.
     * @param _totalTokens The total number of tokens to sell in auction.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     * @param _paymentCurrency The currency the crowdsale accepts for payment. Can be ETH or token address.
     * @param _minimumCommitmentAmount Minimum amount collected at which the auction will be successful.
     * @param _admin Address that can finalize auction.
     * @param _wallet Address where collected funds will be forwarded to.
     */
    function initAuction(
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _minimumCommitmentAmount,
        address _admin,
        address _pointList,
        address payable _wallet
    ) public {
        require(_startTime < 10000000000, ""BatchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""BatchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""BatchAuction: start time is before current time"");
        require(_endTime > _startTime, ""BatchAuction: end time must be older than start time"");
        require(_totalTokens > 0,""BatchAuction: total tokens must be greater than zero"");
        require(_admin != address(0), ""BatchAuction: admin is the zero address"");
        require(_wallet != address(0), ""BatchAuction: wallet is the zero address"");
        require(IERC20(_token).decimals() == 18, ""BatchAuction: Token does not have 18 decimals"");
        if (_paymentCurrency != ETH_ADDRESS) {
            require(IERC20(_paymentCurrency).decimals() > 0, ""BatchAuction: Payment currency is not ERC20"");
        }

        marketStatus.minimumCommitmentAmount = BoringMath.to128(_minimumCommitmentAmount);
        
        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        marketInfo.totalTokens = BoringMath.to128(_totalTokens);

        auctionToken = _token;
        paymentCurrency = _paymentCurrency;
        wallet = _wallet;

        initAccessControls(_admin);

        _setList(_pointList);
        _safeTransferFrom(auctionToken, _funder, _totalTokens);
    }


    ///--------------------------------------------------------
    /// Commit to buying tokens!
    ///--------------------------------------------------------

    receive() external payable {
        revertBecauseUserDidNotProvideAgreement();
    }
    
    /** 
     * @dev Attribution to the awesome delta.financial contracts
    */  
    function marketParticipationAgreement() public pure returns (string memory) {
        return ""I understand that I am interacting with a smart contract. I understand that tokens commited are subject to the token issuer and local laws where applicable. I have reviewed the code of this smart contract and understand it fully. I agree to not hold developers or other people associated with the project liable for any losses or misunderstandings"";
    }
    /** 
     * @dev Not using modifiers is a purposeful choice for code readability.
    */ 
    function revertBecauseUserDidNotProvideAgreement() internal pure {
        revert(""No agreement provided, please review the smart contract before interacting with it"");
    }

    /**
     * @notice Commit ETH to buy tokens on auction.
     * @param _beneficiary Auction participant ETH address.
     */
    function commitEth(address payable _beneficiary, bool readAndAgreedToMarketParticipationAgreement) public payable {
        require(paymentCurrency == ETH_ADDRESS, ""BatchAuction: payment currency is not ETH"");

        require(msg.value > 0, ""BatchAuction: Value must be higher than 0"");
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        _addCommitment(_beneficiary, msg.value);

        /// @notice Revert if commitmentsTotal exceeds the balance
        require(marketStatus.commitmentsTotal <= address(this).balance, ""DutchAuction: The committed ETH exceeds the balance"");
    }

    /**
     * @notice Buy Tokens by commiting approved ERC20 tokens to this contract address.
     * @param _amount Amount of tokens to commit.
     */
    function commitTokens(uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public {
        commitTokensFrom(msg.sender, _amount, readAndAgreedToMarketParticipationAgreement);
    }

    /**
     * @notice Checks if amout not 0 and makes the transfer and adds commitment.
     * @dev Users must approve contract prior to committing tokens to auction.
     * @param _from User ERC20 address.
     * @param _amount Amount of approved ERC20 tokens.
     */
    function commitTokensFrom(address _from, uint256 _amount, bool readAndAgreedToMarketParticipationAgreement) public   nonReentrant  {
        require(paymentCurrency != ETH_ADDRESS, ""BatchAuction: Payment currency is not a token"");
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }
        require(_amount> 0, ""BatchAuction: Value must be higher than 0"");
        _safeTransferFrom(paymentCurrency, msg.sender, _amount);
        _addCommitment(_from, _amount);

    }


    /// @notice Commits to an amount during an auction
    /**
     * @notice Updates commitment for this address and total commitment of the auction.
     * @param _addr Auction participant address.
     * @param _commitment The amount to commit.
     */
    function _addCommitment(address _addr, uint256 _commitment) internal {
        require(block.timestamp >= marketInfo.startTime && block.timestamp <= marketInfo.endTime, ""BatchAuction: outside auction hours""); 

        uint256 newCommitment = commitments[_addr].add(_commitment);
        if (marketStatus.usePointList) {
            require(IPointList(pointList).hasPoints(_addr, newCommitment));
        }
        commitments[_addr] = newCommitment;
        marketStatus.commitmentsTotal = BoringMath.to128(uint256(marketStatus.commitmentsTotal).add(_commitment));
        emit AddedCommitment(_addr, _commitment);
    }

    /**
     * @notice Calculates amount of auction tokens for user to receive.
     * @param amount Amount of tokens to commit.
     * @return Auction token amount.
     */
    function _getTokenAmount(uint256 amount) internal view returns (uint256) { 
        if (marketStatus.commitmentsTotal == 0) return 0;
        return amount.mul(1e18).div(tokenPrice());
    }

    /**
     * @notice Calculates the price of each token from all commitments.
     * @return Token price.
     */
    function tokenPrice() public view returns (uint256) {
        return uint256(marketStatus.commitmentsTotal)
            .mul(1e18).div(uint256(marketInfo.totalTokens));
    }


    ///--------------------------------------------------------
    /// Finalize Auction
    ///--------------------------------------------------------

    /// @notice Auction finishes successfully above the reserve
    /// @dev Transfer contract funds to initialized wallet.
    function finalize() public    nonReentrant 
    {
        require(hasAdminRole(msg.sender) 
                || wallet == msg.sender
                || hasSmartContractRole(msg.sender) 
                || finalizeTimeExpired(),  ""BatchAuction: Sender must be admin"");
        require(!marketStatus.finalized, ""BatchAuction: Auction has already finalized"");
        require(block.timestamp > marketInfo.endTime, ""BatchAuction: Auction has not finished yet"");
        if (auctionSuccessful()) {
            /// @dev Successful auction
            /// @dev Transfer contributed tokens to wallet.
            _safeTokenPayment(paymentCurrency, wallet, uint256(marketStatus.commitmentsTotal));
        } else {
            /// @dev Failed auction
            /// @dev Return auction tokens back to wallet.
            _safeTokenPayment(auctionToken, wallet, marketInfo.totalTokens);
        }
        marketStatus.finalized = true;
        emit AuctionFinalized();
    }

    /**
     * @notice Cancel Auction
     * @dev Admin can cancel the auction before it starts
     */
    function cancelAuction() public   nonReentrant  
    {
        require(hasAdminRole(msg.sender));
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""Crowdsale: already finalized"");
        require( uint256(status.commitmentsTotal) == 0, ""Crowdsale: Funds already raised"" );

        _safeTokenPayment(auctionToken, wallet, uint256(marketInfo.totalTokens));

        status.finalized = true;
        emit AuctionCancelled();
    }

    /// @notice Withdraws bought tokens, or returns commitment if the sale is unsuccessful.
    function withdrawTokens() public  {
        withdrawTokens(msg.sender);
    }

    /// @notice Withdraw your tokens once the Auction has ended.
    function withdrawTokens(address payable beneficiary) public   nonReentrant  {
        if (auctionSuccessful()) {
            require(marketStatus.finalized, ""BatchAuction: not finalized"");
            /// @dev Successful auction! Transfer claimed tokens.
            uint256 tokensToClaim = tokensClaimable(beneficiary);
            require(tokensToClaim > 0, ""BatchAuction: No tokens to claim"");
            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);

            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);
        } else {
            /// @dev Auction did not meet reserve price.
            /// @dev Return committed funds back to user.
            require(block.timestamp > marketInfo.endTime, ""BatchAuction: Auction has not finished yet"");
            uint256 fundsCommitted = commitments[beneficiary];
            require(fundsCommitted > 0, ""BatchAuction: No funds committed"");
            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas
            _safeTokenPayment(paymentCurrency, beneficiary, fundsCommitted);
        }
    }


    /**
     * @notice How many tokens the user is able to claim.
     * @param _user Auction participant address.
     * @return  claimerCommitment Tokens left to claim.
     */
    function tokensClaimable(address _user) public view returns (uint256 claimerCommitment) {
        if (commitments[_user] == 0) return 0;
        uint256 unclaimedTokens = IERC20(auctionToken).balanceOf(address(this));
        claimerCommitment = _getTokenAmount(commitments[_user]);
        claimerCommitment = claimerCommitment.sub(claimed[_user]);

        if(claimerCommitment > unclaimedTokens){
            claimerCommitment = unclaimedTokens;
        }
    }
    
    /**
     * @notice Checks if raised more than minimum amount.
     * @return True if tokens sold greater than or equals to the minimum commitment amount.
     */
    function auctionSuccessful() public view returns (bool) {
        return uint256(marketStatus.commitmentsTotal) >= uint256(marketStatus.minimumCommitmentAmount) && uint256(marketStatus.commitmentsTotal) > 0;
    }

    /**
     * @notice Checks if the auction has ended.
     * @return bool True if current time is greater than auction end time.
     */
    function auctionEnded() public view returns (bool) {
        return block.timestamp > marketInfo.endTime;
    }

    /**
     * @notice Checks if the auction has been finalised.
     * @return bool True if auction has been finalised.
     */
    function finalized() public view returns (bool) {
        return marketStatus.finalized;
    }

    /// @notice Returns true if 7 days have passed since the end of the auction
    function finalizeTimeExpired() public view returns (bool) {
        return uint256(marketInfo.endTime) + 7 days < block.timestamp;
    }


    //--------------------------------------------------------
    // Documents
    //--------------------------------------------------------

    function setDocument(string calldata _name, string calldata _data) external {
        require(hasAdminRole(msg.sender) );
        _setDocument( _name, _data);
    }

    function setDocuments(string[] calldata _name, string[] calldata _data) external {
        require(hasAdminRole(msg.sender) );
        uint256 numDocs = _name.length;
        for (uint256 i = 0; i < numDocs; i++) {
            _setDocument( _name[i], _data[i]);
        }
    }

    function removeDocument(string calldata _name) external {
        require(hasAdminRole(msg.sender));
        _removeDocument(_name);
    }


    //--------------------------------------------------------
    // Point Lists
    //--------------------------------------------------------


    function setList(address _list) external {
        require(hasAdminRole(msg.sender));
        _setList(_list);
    }

    function enableList(bool _status) external {
        require(hasAdminRole(msg.sender));
        marketStatus.usePointList = _status;
    }

    function _setList(address _pointList) private {
        if (_pointList != address(0)) {
            pointList = _pointList;
            marketStatus.usePointList = true;
        }
    }

    //--------------------------------------------------------
    // Setter Functions
    //--------------------------------------------------------

    /**
     * @notice Admin can set start and end time through this function.
     * @param _startTime Auction start time.
     * @param _endTime Auction end time.
     */
    function setAuctionTime(uint256 _startTime, uint256 _endTime) external {
        require(hasAdminRole(msg.sender));
        require(_startTime < 10000000000, ""BatchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_endTime < 10000000000, ""BatchAuction: enter an unix timestamp in seconds, not miliseconds"");
        require(_startTime >= block.timestamp, ""BatchAuction: start time is before current time"");
        require(_endTime > _startTime, ""BatchAuction: end time must be older than start price"");

        require(marketStatus.commitmentsTotal == 0, ""BatchAuction: auction cannot have already started"");

        marketInfo.startTime = BoringMath.to64(_startTime);
        marketInfo.endTime = BoringMath.to64(_endTime);
        
        emit AuctionTimeUpdated(_startTime,_endTime);
    }

    /**
     * @notice Admin can set start and min price through this function.
     * @param _minimumCommitmentAmount Auction minimum raised target.
     */
    function setAuctionPrice(uint256 _minimumCommitmentAmount) external {
        require(hasAdminRole(msg.sender));

        require(marketStatus.commitmentsTotal == 0, ""BatchAuction: auction cannot have already started"");

        marketStatus.minimumCommitmentAmount = BoringMath.to128(_minimumCommitmentAmount);

        emit AuctionPriceUpdated(_minimumCommitmentAmount);
    }

    /**
     * @notice Admin can set the auction wallet through this function.
     * @param _wallet Auction wallet is where funds will be sent.
     */
    function setAuctionWallet(address payable _wallet) external {
        require(hasAdminRole(msg.sender));
        require(_wallet != address(0), ""BatchAuction: wallet is the zero address"");

        wallet = _wallet;

        emit AuctionWalletUpdated(_wallet);
    }


    //--------------------------------------------------------
    // Market Launchers
    //--------------------------------------------------------

    function init(bytes calldata _data) external override payable {
    }

    function initMarket(
        bytes calldata _data
    ) public override {
        (
        address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _minimumCommitmentAmount,
        address _admin,
        address _pointList,
        address payable _wallet
        ) = abi.decode(_data, (
            address,
            address,
            uint256,
            uint256,
            uint256,
            address,
            uint256,
            address,
            address,
            address
        ));
        initAuction(_funder, _token, _totalTokens, _startTime, _endTime, _paymentCurrency, _minimumCommitmentAmount, _admin, _pointList,  _wallet);
    }

     function getBatchAuctionInitData(
       address _funder,
        address _token,
        uint256 _totalTokens,
        uint256 _startTime,
        uint256 _endTime,
        address _paymentCurrency,
        uint256 _minimumCommitmentAmount,
        address _admin,
        address _pointList,
        address payable _wallet
    )
        external
        pure
        returns (bytes memory _data)
    {
        return abi.encode(
            _funder,
            _token,
            _totalTokens,
            _startTime,
            _endTime,
            _paymentCurrency,
            _minimumCommitmentAmount,
            _admin,
            _pointList,
            _wallet
            );
    }

    function getBaseInformation() external view returns(
        address token, 
        uint64 startTime,
        uint64 endTime,
        bool marketFinalized
    ) {
        return (auctionToken, marketInfo.startTime, marketInfo.endTime, marketStatus.finalized);
    }

    function getTotalTokens() external view returns(uint256) {
        return uint256(marketInfo.totalTokens);
    }

}",4740
RealWorld_TA_28_Wallet_RealWorld_20240803195956.log,28,Wallet,22164,1815,23979,85.0,0.14712,"pragma solidity 0.6.12;

contract Wallet {
    fallback() external payable { }

    function sendTo() external payable returns (bool) { return true; }

    receive() external payable { }
}",43
RealWorld_TA_28_EnumerableMap_RealWorld_20240803190542.log,28,EnumerableMap,217262,1583,218845,95.0,1.11797,"pragma solidity 0.6.12;

/**
 * @dev Library for managing an enumerable variant of Solidity's
 * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
 * type.
 *
 * Maps have the following properties:
 *
 * - Entries are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Entries are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableMap for EnumerableMap.UintToAddressMap;
 *
 *     // Declare a set state variable
 *     EnumerableMap.UintToAddressMap private myMap;
 * }
 * ```
 *
 * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are
 * supported.
 */
library EnumerableMap {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct MapEntry {
        bytes32 _key;
        bytes32 _value;
    }

    struct Map {
        // Storage of map keys and values
        MapEntry[] _entries;

        // Position of the entry defined by a key in the `entries` array, plus 1
        // because index 0 means a key is not in the map.
        mapping (bytes32 => uint256) _indexes;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex == 0) { // Equivalent to !contains(map, key)
            map._entries.push(MapEntry({ _key: key, _value: value }));
            // The entry is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            map._indexes[key] = map._entries.length;
            return true;
        } else {
            map._entries[keyIndex - 1]._value = value;
            return false;
        }
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex != 0) { // Equivalent to contains(map, key)
            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one
            // in the array, and then remove the last entry (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = keyIndex - 1;
            uint256 lastIndex = map._entries.length - 1;

            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            MapEntry storage lastEntry = map._entries[lastIndex];

            // Move the last entry to the index where the entry to delete is
            map._entries[toDeleteIndex] = lastEntry;
            // Update the index for the moved entry
            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved entry was stored
            map._entries.pop();

            // Delete the index for the deleted slot
            delete map._indexes[key];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key) private view returns (bool) {
        return map._indexes[key] != 0;
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._entries.length;
    }

   /**
    * @dev Returns the key-value pair stored at position `index` in the map. O(1).
    *
    * Note that there are no guarantees on the ordering of entries inside the
    * array, and it may change when more entries are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {
        require(map._entries.length > index, ""EnumerableMap: index out of bounds"");

        MapEntry storage entry = map._entries[index];
        return (entry._key, entry._value);
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     */
    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {
        uint256 keyIndex = map._indexes[key];
        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)
        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        uint256 keyIndex = map._indexes[key];
        require(keyIndex != 0, ""EnumerableMap: nonexistent key""); // Equivalent to contains(map, key)
        return map._entries[keyIndex - 1]._value; // All indexes are 1-based
    }

    /**
     * @dev Same as {_get}, with a custom error message when `key` is not in the map.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {_tryGet}.
     */
    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {
        uint256 keyIndex = map._indexes[key];
        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)
        return map._entries[keyIndex - 1]._value; // All indexes are 1-based
    }

    // UintToAddressMap

    struct UintToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {
        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {
        return _remove(map._inner, bytes32(key));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {
        return _contains(map._inner, bytes32(key));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(UintToAddressMap storage map) internal view returns (uint256) {
        return _length(map._inner);
    }

   /**
    * @dev Returns the element stored at position `index` in the set. O(1).
    * Note that there are no guarantees on the ordering of values inside the
    * array, and it may change when more values are added or removed.
    *
    * Requirements:
    *
    * - `index` must be strictly less than {length}.
    */
    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (uint256(key), address(uint160(uint256(value))));
    }

    /**
     * @dev Tries to returns the value associated with `key`.  O(1).
     * Does not revert if `key` is not in the map.
     *
     * _Available since v3.4._
     */
    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {
        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));
        return (success, address(uint160(uint256(value))));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {
        return address(uint160(uint256(_get(map._inner, bytes32(key)))));
    }

    /**
     * @dev Same as {get}, with a custom error message when `key` is not in the map.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryGet}.
     */
    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {
        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));
    }
}",2357
RealWorld_TA_28_MISOAccessControls_RealWorld_20240803200945.log,28,MISOAccessControls,35186,3547,38733,107.0,0.24687,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

/*
 * Harness to simplify:
 *      1. contracts/Access/MISOAdminAccess.sol
 *      2. contracts/Access/MISOAccessControls.sol
 */
contract MISOAccessControls {
    bool initialized; 
    address admin;

    function initAccessControls(address _admin) public {
        require(!initialized);
        initialized = true;
        admin = _admin;
    }

    function isInitialized() public returns (bool) {
        return initialized;
    } 
    
    function hasAdminRole(address _address) public view returns (bool) {
        return admin == _address;
    }

    mapping (address => bool) hasRoleSMART_CONTRACT_ROLE;
    function hasSmartContractRole(address _address) public view returns (bool) {
        return hasRoleSMART_CONTRACT_ROLE[_address];
    }
}",184
RealWorld_TA_28_CalculationsSushiswap_RealWorld_20240803183634.log,28,CalculationsSushiswap,154748,4819,159567,126.0,0.87012,"pragma solidity 0.6.12;

import ""../interfaces/IERC20.sol"";


interface PriceRouter {
    function getAmountsOut(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256[] memory amounts);
    function WETH() external view returns (address);
}

interface Pair {
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function getReserves()
        external
        view
        returns (
            uint112,
            uint112,
            uint32
        );
}


contract CalculationsSushiswap {
    address public primaryRouterAddress;
    address public primaryFactoryAddress;
    address public secondaryRouterAddress;
    address public secondaryFactoryAddress;
    address public wethAddress;
    address public usdcAddress;
    PriceRouter primaryRouter;
    PriceRouter secondaryRouter;

    address ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    address zeroAddress = 0x0000000000000000000000000000000000000000;

    constructor(
        address _primaryRouterAddress,
        address _primaryFactoryAddress,
        address _secondaryRouterAddress,
        address _secondaryFactoryAddress,
        address _usdcAddress
    ) public {
        primaryRouterAddress = _primaryRouterAddress;
        primaryFactoryAddress = _primaryFactoryAddress;
        secondaryRouterAddress = _secondaryRouterAddress;
        secondaryFactoryAddress = _secondaryFactoryAddress;
        usdcAddress = _usdcAddress;
        primaryRouter = PriceRouter(primaryRouterAddress);
        secondaryRouter = PriceRouter(secondaryRouterAddress);
        wethAddress = primaryRouter.WETH();
    }

  function getNormalizedValueUsdc(address tokenAddress, uint256 amount)
        external
        view
        returns (uint256)
    {
        IERC20 token = IERC20(tokenAddress);
        uint256 tokenDecimals = token.decimals();

        uint256 usdcDecimals = 6;
        uint256 decimalsAdjustment;
        if (tokenDecimals >= usdcDecimals) {
            decimalsAdjustment = tokenDecimals - usdcDecimals;
        } else {
            decimalsAdjustment = usdcDecimals - tokenDecimals;
        }
        uint256 price = getPriceUsdc(tokenAddress);
        uint256 value;
        if (decimalsAdjustment > 0) {
            value =
                (amount * price * (10**decimalsAdjustment)) /
                10**(decimalsAdjustment + tokenDecimals);
        } else {
            value = (amount * price) / 10**usdcDecimals;
        }
        return value;
    }


    // Uniswap/Sushiswap
    function getPriceUsdc(address tokenAddress) public view returns (uint256) {
        if (isLpToken(tokenAddress)) {
            return getLpTokenPriceUsdc(tokenAddress);
        }
        return getPriceFromRouterUsdc(tokenAddress);
    }

    function getPriceFromRouter(address token0Address, address token1Address)
        public
        view
        returns (uint256)
    {
        // Convert ETH address (0xEeee...) to WETH
        if (token0Address == ethAddress) {
            token0Address = wethAddress;
        }
        if (token1Address == ethAddress) {
            token1Address = wethAddress;
        }

        address[] memory path;
        uint8 numberOfJumps;
        bool inputTokenIsWeth =
            token0Address == wethAddress || token1Address == wethAddress;
        if (inputTokenIsWeth) {
            // path = [token0, weth] or [weth, token1]
            numberOfJumps = 1;
            path = new address[](numberOfJumps + 1);
            path[0] = token0Address;
            path[1] = token1Address;
        } else {
            // path = [token0, weth, token1]
            numberOfJumps = 2;
            path = new address[](numberOfJumps + 1);
            path[0] = token0Address;
            path[1] = wethAddress;
            path[2] = token1Address;
        }

        IERC20 token0 = IERC20(token0Address);
        uint256 amountIn = 10**uint256(token0.decimals());
        uint256[] memory amountsOut;

        bool fallbackRouterExists = secondaryRouterAddress != zeroAddress;
        if (fallbackRouterExists) {
            try primaryRouter.getAmountsOut(amountIn, path) returns (
                uint256[] memory _amountsOut
            ) {
                amountsOut = _amountsOut;
            } catch {
                amountsOut = secondaryRouter.getAmountsOut(amountIn, path);
            }
        } else {
            amountsOut = primaryRouter.getAmountsOut(amountIn, path);
        }

        // Return raw price (without fees)
        uint256 amountOut = amountsOut[amountsOut.length - 1];
        uint256 feeBips = 30; // .3% per swap
        amountOut = (amountOut * 10000) / (10000 - (feeBips * numberOfJumps));
        return amountOut;
    }



    function getPriceFromRouterUsdc(address tokenAddress)
        public
        view
        returns (uint256)
    {
        return getPriceFromRouter(tokenAddress, usdcAddress);
    }

    function isLpToken(address tokenAddress) public view returns (bool) {
        Pair lpToken = Pair(tokenAddress);
        try lpToken.factory() {
            return true;
        } catch {
            return false;
        }
    }

    function getRouterForLpToken(address tokenAddress)
        public
        view
        returns (PriceRouter)
    {
        Pair lpToken = Pair(tokenAddress);
        address factoryAddress = lpToken.factory();
        if (factoryAddress == primaryFactoryAddress) {
            return primaryRouter;
        } else if (factoryAddress == secondaryFactoryAddress) {
            return secondaryRouter;
        }
        revert();
    }

    function getLpTokenTotalLiquidityUsdc(address tokenAddress)
        public
        view
        returns (uint256)
    {
        Pair pair = Pair(tokenAddress);
        address token0Address = pair.token0();
        address token1Address = pair.token1();
        IERC20 token0 = IERC20(token0Address);
        IERC20 token1 = IERC20(token1Address);
        uint8 token0Decimals = token0.decimals();
        uint8 token1Decimals = token1.decimals();
        uint256 token0Price = getPriceUsdc(token0Address);
        uint256 token1Price = getPriceUsdc(token1Address);
        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();
        uint256 totalLiquidity =
            ((reserve0 / 10**token0Decimals) * token0Price) +
                ((reserve1 / 10**token1Decimals) * token1Price);
        return totalLiquidity;
    }

    function getLpTokenPriceUsdc(address tokenAddress)
        public
        view
        returns (uint256)
    {
        Pair pair = Pair(tokenAddress);
        uint256 totalLiquidity = getLpTokenTotalLiquidityUsdc(tokenAddress);
        uint256 totalSupply = pair.totalSupply();
        uint8 pairDecimals = pair.decimals();
        uint256 pricePerLpTokenUsdc =
            (totalLiquidity * 10**pairDecimals) / totalSupply;
        return pricePerLpTokenUsdc;
    }
}",1645
RealWorld_TA_29_ERC20Mock_RealWorld_20240803213501.log,29,ERC20Mock,35045,3831,38876,116.0,0.251845,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20Mock is ERC20 {
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    constructor(
        string memory name,
        string memory symbol,
        uint256 supply
    ) ERC20(name, symbol) {
        _mint(msg.sender, supply);
    }

    receive() external payable {
        deposit();
    }

    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        _burn(msg.sender, wad);
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }
}",188
RealWorld_TA_29_WETH9_RealWorld_20240803213209.log,29,WETH9,23255,1680,24935,83.0,0.149875,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""./ERC20Mock.sol"";

contract WETH9 is ERC20Mock {
    constructor() ERC20Mock(""WETH9"", ""WETH9"", 0) {}
}",60
RealWorld_TA_29_TridentMathConsumerMock_RealWorld_20240803213334.log,29,TridentMathConsumerMock,23901,1604,25505,84.0,0.151585,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""../libraries/TridentMath.sol"";

contract TridentMathConsumerMock {
    function sqrt(uint256 x) public pure returns (uint256) {
        return TridentMath.sqrt(x);
    }
}",63
RealWorld_TA_29_Migrator_RealWorld_20240803214125.log,29,Migrator,53057,3972,57029,122.0,0.344725,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../pool/ConstantProductPool.sol"";
import ""../pool/ConstantProductPoolFactory.sol"";
import ""../deployer/MasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/IBentoBoxMinimal.sol"";

interface IERC20 {
    function totalSupply() external returns (uint256);
}

contract Migrator {
    address public chef;
    ConstantProductPoolFactory public factory;
    IBentoBoxMinimal public bentoBox;
    uint256 public desiredLiquidity = type(uint256).max;

    constructor(
        address _chef,
        IBentoBoxMinimal _bentoBox,
        ConstantProductPoolFactory _factory
    ) {
        chef = _chef;
        bentoBox = _bentoBox;
        factory = _factory;
    }

    function migrate(ConstantProductPool orig) public returns (IPool) {
        require(msg.sender == chef, ""!chef"");

        address token0 = orig.token0();
        address token1 = orig.token1();

        bytes memory deployData = abi.encode(token0, token1, 10, false);

        IPool pair = IPool(factory.configAddress(keccak256(deployData)));

        if (address(pair) == (address(0))) {
            pair = IPool(factory.deployPool(deployData));
        }

        require(IERC20(address(pair)).totalSupply() == 0, ""pair must have no existing supply"");

        uint256 lp = orig.balanceOf(msg.sender);

        if (lp == 0) return pair;

        orig.transferFrom(msg.sender, address(orig), lp);

        desiredLiquidity = lp;

        orig.burn(abi.encode(address(pair), false));

        pair.mint(abi.encode(msg.sender));

        desiredLiquidity = type(uint256).max;

        return pair;
    }
}",395
RealWorld_TA_29_HybridPool_RealWorld_20240803220941.log,29,HybridPool,469501,5967,475468,218.0,2.466845,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""../libraries/MathUtils.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with hybrid like-kind formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares. However, the stableswap invariant is applied to the underlying amounts.
///      The API uses the underlying amounts.
contract HybridPool is IPool, TridentERC20 {
    using MathUtils for uint256;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;
    uint8 internal constant PRECISION = 112;

    /// @dev Constant value used as max loop limit.
    uint256 private constant MAX_LOOP_LIMIT = 256;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;
    uint256 public immutable A;
    uint256 internal immutable N_A; // @dev 2 * A.
    uint256 internal constant A_PRECISION = 100;

    /// @dev Multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS.
    /// For example, TBTC has 18 decimals, so the multiplier should be 1. WBTC
    /// has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10.
    uint256 public immutable token0PrecisionMultiplier;
    uint256 public immutable token1PrecisionMultiplier;
    
    uint256 public barFee;

    uint128 internal reserve0;
    uint128 internal reserve1;

    bytes32 public constant override poolIdentifier = ""Trident:HybridPool"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));
        
        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(a != 0, ""ZERO_A"");
        
        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));
        (, bytes memory _decimals0) = _token0.staticcall(abi.encodeWithSelector(0x313ce567)); // @dev 'decimals()'.
        (, bytes memory _decimals1) = _token1.staticcall(abi.encodeWithSelector(0x313ce567)); // @dev 'decimals()'.

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        A = a;
        N_A = 2 * a;
        token0PrecisionMultiplier = 10**(decimals - abi.decode(_decimals0, (uint8)));
        token1PrecisionMultiplier = 10**(decimals - abi.decode(_decimals1, (uint8)));
        unlocked = 1;
    }
    
    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 newLiq = _computeLiquidity(balance0 - fee0, balance1 - fee1);
        
        if (_totalSupply == 0) {
            liquidity = newLiq - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            uint256 oldLiq = _computeLiquidity(_reserve0, _reserve1);
            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _updateReserves();
        emit Mint(msg.sender, amount0, amount1, recipient);
    }
    
    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];
        
        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);

        balance0 -= _toShare(token0, amount0);
        balance1 -= _toShare(token1, amount1);
        
        _updateReserves();

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        emit Burn(msg.sender, amount0, amount1, recipient);
    }
    
    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;
        
        _burn(address(this), liquidity);
        
        if (tokenOut == token1) {
            // @dev Swap `token0` for `token1`.
            // @dev Calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
            uint256 fee = _handleFee(token0, amount0);
            amount1 += _getAmountOut(amount0 - fee, _reserve0 - amount0, _reserve1 - amount1, true);
            _transfer(token1, amount1, recipient, unwrapBento);
            balance0 -= _toShare(token0, amount0);
            amountOut = amount1;
            amount0 = 0;
        } else {
            // @dev Swap `token1` for `token0`.
            require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
            uint256 fee = _handleFee(token1, amount1);
            amount0 += _getAmountOut(amount1 - fee, _reserve0 - amount0, _reserve1 - amount1, false);
            _transfer(token0, amount0, recipient, unwrapBento);
            balance1 -= _toShare(token1, amount1);
            amountOut = amount0;
            amount1 = 0;
        }
        _updateReserves();
        emit Burn(msg.sender, amount0, amount1, recipient);
    }
    
    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;
        
        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = balance0 - _reserve0;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = balance1 - _reserve1;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Swaps one token for another with payload. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        address tokenOut;
        uint256 fee;
        
        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = _toAmount(token0, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
            _processSwap(token1, recipient, amountOut, context, unwrapBento);
            uint256 balance0 = _toAmount(token0, __balance(token0));
            require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = _toAmount(token1, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
            _processSwap(token0, recipient, amountOut, context, unwrapBento);
            uint256 balance1 = _toAmount(token1, __balance(token1));
            require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        }
        _transfer(tokenIn, fee, barFeeTo, false);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }
    
    function _processSwap(
        address tokenOut,
        address to,
        uint256 amountOut,
        bytes memory data,
        bool unwrapBento
    ) internal {
        _transfer(tokenOut, amountOut, to, unwrapBento);
        if (data.length != 0) ITridentCallee(msg.sender).tridentSwapCallback(data);
    }
    
    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = (reserve0, reserve1);
        _reserve0 = _toAmount(token0, _reserve0);
        _reserve1 = _toAmount(token1, _reserve1);
    }
    
    function _updateReserves() internal {
        (uint256 _reserve0, uint256 _reserve1) = _balance();
        require(_reserve0 < type(uint128).max && _reserve1 < type(uint128).max, ""OVERFLOW"");
        reserve0 = uint128(_reserve0);
        reserve1 = uint128(_reserve1);
        emit Sync(_reserve0, _reserve1);
    }
    
    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        balance0 = _toAmount(token0, __balance(token0));
        balance1 = _toAmount(token1, __balance(token1));
    }
    
    function __balance(address token) internal view returns (uint256 balance) {
        // @dev balanceOf(address,address).
        (, bytes memory ___balance) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, 
            token, address(this)));
        balance = abi.decode(___balance, (uint256));
    }

    function _toAmount(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toAmount(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toAmount.selector,
            token, input, false));
        output = abi.decode(_output, (uint256));
    }
    
    function _toShare(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toShare(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toShare.selector,
            token, input, false));
        output = abi.decode(_output, (uint256));
    }
 
    function _getAmountOut(
        uint256 amountIn,
        uint256 _reserve0,
        uint256 _reserve1,
        bool token0In
    ) internal view returns (uint256 dy) {
        uint256 xpIn;
        uint256 xpOut;
        
        if (token0In) {
            xpIn = _reserve0 * token0PrecisionMultiplier;
            xpOut = _reserve1 * token1PrecisionMultiplier;
            amountIn *= token0PrecisionMultiplier;
        } else {
            xpIn = _reserve1 * token1PrecisionMultiplier;
            xpOut = _reserve0 * token0PrecisionMultiplier;
            amountIn *= token1PrecisionMultiplier;
        }
        uint256 d = _computeLiquidityFromAdjustedBalances(xpIn, xpOut);
        uint256 x = xpIn + amountIn;
        uint256 y = _getY(x, d);
        dy = xpOut - y - 1;
        dy /= (token0In ? token1PrecisionMultiplier : token0PrecisionMultiplier);
    }

    function _transfer(
        address token,
        uint256 amount,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            // @dev withdraw(address,address,address,uint256,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, 
            token, address(this), to, amount, 0));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            // @dev transfer(address,address,address,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, 
                token, address(this), to, _toShare(token, amount)));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
    /// See the StableSwap paper for details.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L319.
    /// @return liquidity The invariant, at the precision of the pool.
    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {
        uint256 xp0 = _reserve0 * token0PrecisionMultiplier;
        uint256 xp1 = _reserve1 * token1PrecisionMultiplier;
        liquidity = _computeLiquidityFromAdjustedBalances(xp0, xp1);
    }

    function _computeLiquidityFromAdjustedBalances(uint256 xp0, uint256 xp1) internal view returns (uint256 computed) {
        uint256 s = xp0 + xp1;
        
        if (s == 0) {
            computed = 0;
        }
        uint256 prevD;
        uint256 D = s;
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            uint256 dP = (((D * D) / xp0) * D) / xp1 / 4;
            prevD = D;
            D = (((N_A * s) / A_PRECISION + 2 * dP) * D) / ((N_A / A_PRECISION - 1) * D + 3 * dP);
            if (D.within1(prevD)) {
                break;
            }
        }
        computed = D;
    }

    /// @notice Calculate the new balances of the tokens given the indexes of the token
    /// that is swapped from (FROM) and the token that is swapped to (TO).
    /// This function is used as a helper function to calculate how much TO token
    /// the user should receive on swap.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L432.
    /// @param x The new total amount of FROM token.
    /// @return y The amount of TO token that should remain in the pool.
    function _getY(uint256 x, uint256 D) internal view returns (uint256 y) {
        uint256 c = (D * D) / (x * 2);
        c = (c * D) / ((N_A * 2) / A_PRECISION);
        uint256 b = x + ((D * A_PRECISION) / N_A);
        uint256 yPrev;
        y = D;
        // @dev Iterative approximation.
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - D);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    /// @notice Calculate the price of a token in the pool given
    /// precision-adjusted balances and a particular D and precision-adjusted
    /// array of balances.
    /// @dev This is accomplished via solving the quadratic equation iteratively.
    /// See the StableSwap paper and Curve.fi implementation for further details.
    /// x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
    /// x_1**2 + b*x_1 = c
    /// x_1 = (x_1**2 + c) / (2*x_1 + b)
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L276.
    /// @return y The price of the token, in the same precision as in xp.
    function _getYD(
        uint256 s, // @dev xpOut.
        uint256 d
    ) internal view returns (uint256 y) {
        uint256 c = (d * d) / (s * 2);
        c = (c * d) / ((N_A * 2) / A_PRECISION);

        uint256 b = s + ((d * A_PRECISION) / N_A);
        uint256 yPrev;
        y = d;
        
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - d);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }
    
    function _handleFee(address tokenIn, uint256 amountIn) internal returns (uint256 fee) {
        fee = (amountIn * swapFee) / MAX_FEE;
        uint256 _barFee = (fee * barFee) / MAX_FEE;
        _transfer(tokenIn, _barFee, barFeeTo, false);
    }
    
    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }
    
    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }
    
    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        amountIn = _toAmount(tokenIn, amountIn);
        amountIn -= (amountIn * swapFee) / MAX_FEE;
        
        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);
        }
    }

    function getReserves()
        public
        view
        returns (
            uint256 _reserve0,
            uint256 _reserve1
        )
    {
        (_reserve0, _reserve1) = _getReserves();
    }
}",5377
RealWorld_TA_29_FranchisedHybridPool_RealWorld_20240803221321.log,29,FranchisedHybridPool,474725,5816,480541,227.0,2.489945,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""../../libraries/MathUtils.sol"";
import ""./TridentFranchisedERC20.sol"";

/// @notice Trident exchange franchised pool template with hybrid like-kind formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares. However, the stableswap invariant is applied to the underlying amounts.
///      The API uses the underlying amounts.
contract FranchisedHybridPool is IPool, TridentFranchisedERC20 {
    using MathUtils for uint256;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;
    uint8 internal constant PRECISION = 112;

    /// @dev Constant value used as max loop limit.
    uint256 internal constant MAX_LOOP_LIMIT = 256;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;
    uint256 public immutable A;
    uint256 internal immutable N_A; // @dev 2 * A.
    uint256 internal constant A_PRECISION = 100;

    /// @dev Multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS.
    /// For example, TBTC has 18 decimals, so the multiplier should be 1. WBTC
    /// has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10.
    uint256 public immutable token0PrecisionMultiplier;
    uint256 public immutable token1PrecisionMultiplier;

    uint256 public barFee;

    uint128 internal reserve0;
    uint128 internal reserve1;

    bytes32 public constant override poolIdentifier = ""Trident:FranchisedHybrid"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, uint256 a, address _whiteListManager, address _operator, bool _level2) = abi.decode(
            _deployData,
            (address, address, uint256, uint256, address, address, bool)
        );

        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(a != 0, ""ZERO_A"");

        TridentFranchisedERC20.initialize(_whiteListManager, _operator, _level2);

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));
        (, bytes memory _decimals0) = _token0.staticcall(abi.encodeWithSelector(0x313ce567)); // @dev 'decimals()'.
        (, bytes memory _decimals1) = _token1.staticcall(abi.encodeWithSelector(0x313ce567)); // @dev 'decimals()'.

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        A = a;
        N_A = 2 * a;
        token0PrecisionMultiplier = 10**(decimals - abi.decode(_decimals0, (uint8)));
        token1PrecisionMultiplier = 10**(decimals - abi.decode(_decimals1, (uint8)));
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;

        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 newLiq = _computeLiquidity(balance0 - fee0, balance1 - fee1);

        if (_totalSupply == 0) {
            liquidity = newLiq - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY);
        } else {
            uint256 oldLiq = _computeLiquidity(_reserve0, _reserve1);
            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _updateReserves();
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        _checkWhiteList(recipient);
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);

        balance0 -= _toShare(token0, amount0);
        balance1 -= _toShare(token1, amount1);

        _updateReserves();

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});

        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);

        if (tokenOut == token1) {
            // @dev Swap `token0` for `token1`.
            // @dev Calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
            uint256 fee = _handleFee(token0, amount0);
            amount1 += _getAmountOut(amount0 - fee, _reserve0 - amount0, _reserve1 - amount1, true);
            _transfer(token1, amount1, recipient, unwrapBento);
            balance0 -= _toShare(token0, amount0);
            amountOut = amount1;
            amount0 = 0;
        } else {
            // @dev Swap `token1` for `token0`.
            require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
            uint256 fee = _handleFee(token1, amount1);
            amount0 += _getAmountOut(amount1 - fee, _reserve0 - amount0, _reserve1 - amount1, false);
            _transfer(token0, amount0, recipient, unwrapBento);
            balance1 -= _toShare(token1, amount1);
            amountOut = amount0;
            amount1 = 0;
        }
        _updateReserves();
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        if (level2) _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;

        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = balance0 - _reserve0;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = balance1 - _reserve1;
            uint256 fee = _handleFee(tokenIn, amountIn);
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another with payload. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        if (level2) _checkWhiteList(recipient);
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        address tokenOut;
        uint256 fee;

        if (tokenIn == token0) {
            tokenOut = token1;
            amountIn = _toAmount(token0, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, true);
            _processSwap(token1, recipient, amountOut, context, unwrapBento);
            uint256 balance0 = _toAmount(token0, __balance(token0));
            require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        } else {
            require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
            tokenOut = token0;
            amountIn = _toAmount(token1, amountIn);
            fee = (amountIn * swapFee) / MAX_FEE;
            amountOut = _getAmountOut(amountIn - fee, _reserve0, _reserve1, false);
            _processSwap(token0, recipient, amountOut, context, unwrapBento);
            uint256 balance1 = _toAmount(token1, __balance(token1));
            require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
        }
        _transfer(tokenIn, fee, barFeeTo, false);
        _updateReserves();
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _processSwap(
        address tokenOut,
        address to,
        uint256 amountOut,
        bytes memory data,
        bool unwrapBento
    ) internal {
        _transfer(tokenOut, amountOut, to, unwrapBento);
        if (data.length != 0) ITridentCallee(msg.sender).tridentSwapCallback(data);
    }

    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = (reserve0, reserve1);
        _reserve0 = _toAmount(token0, _reserve0);
        _reserve1 = _toAmount(token1, _reserve1);
    }

    function _updateReserves() internal {
        (uint256 _reserve0, uint256 _reserve1) = _balance();
        require(_reserve0 < type(uint128).max && _reserve1 < type(uint128).max, ""OVERFLOW"");
        reserve0 = uint128(_reserve0);
        reserve1 = uint128(_reserve1);
        emit Sync(_reserve0, _reserve1);
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        balance0 = _toAmount(token0, __balance(token0));
        balance1 = _toAmount(token1, __balance(token1));
    }

    function __balance(address token) internal view returns (uint256 balance) {
        // @dev balanceOf(address,address).
        (, bytes memory ___balance) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, token, address(this)));
        balance = abi.decode(___balance, (uint256));
    }

    function _toAmount(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toAmount(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toAmount.selector, token, input, false));
        output = abi.decode(_output, (uint256));
    }

    function _toShare(address token, uint256 input) internal view returns (uint256 output) {
        // @dev toShare(address,uint256,bool).
        (, bytes memory _output) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.toShare.selector, token, input, false));
        output = abi.decode(_output, (uint256));
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 _reserve0,
        uint256 _reserve1,
        bool token0In
    ) internal view returns (uint256 dy) {
        uint256 xpIn;
        uint256 xpOut;

        if (token0In) {
            xpIn = _reserve0 * token0PrecisionMultiplier;
            xpOut = _reserve1 * token1PrecisionMultiplier;
            amountIn *= token0PrecisionMultiplier;
        } else {
            xpIn = _reserve1 * token1PrecisionMultiplier;
            xpOut = _reserve0 * token0PrecisionMultiplier;
            amountIn *= token1PrecisionMultiplier;
        }
        uint256 d = _computeLiquidityFromAdjustedBalances(xpIn, xpOut);
        uint256 x = xpIn + amountIn;
        uint256 y = _getY(x, d);
        dy = xpOut - y - 1;
        dy /= (token0In ? token1PrecisionMultiplier : token0PrecisionMultiplier);
    }

    function _transfer(
        address token,
        uint256 amount,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            // @dev withdraw(address,address,address,uint256,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, token, address(this), to, amount, 0));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            // @dev transfer(address,address,address,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, token, address(this), to, _toShare(token, amount)));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
    /// See the StableSwap paper for details.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L319.
    /// @return liquidity The invariant, at the precision of the pool.
    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {
        uint256 xp0 = _reserve0 * token0PrecisionMultiplier;
        uint256 xp1 = _reserve1 * token1PrecisionMultiplier;
        liquidity = _computeLiquidityFromAdjustedBalances(xp0, xp1);
    }

    function _computeLiquidityFromAdjustedBalances(uint256 xp0, uint256 xp1) internal view returns (uint256 computed) {
        uint256 s = xp0 + xp1;

        if (s == 0) {
            computed = 0;
        }
        uint256 prevD;
        uint256 D = s;
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            uint256 dP = (((D * D) / xp0) * D) / xp1 / 4;
            prevD = D;
            D = (((N_A * s) / A_PRECISION + 2 * dP) * D) / ((N_A / A_PRECISION - 1) * D + 3 * dP);
            if (D.within1(prevD)) {
                break;
            }
        }
        computed = D;
    }

    /// @notice Calculate the new balances of the tokens given the indexes of the token
    /// that is swapped from (FROM) and the token that is swapped to (TO).
    /// This function is used as a helper function to calculate how much TO token
    /// the user should receive on swap.
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L432.
    /// @param x The new total amount of FROM token.
    /// @return y The amount of TO token that should remain in the pool.
    function _getY(uint256 x, uint256 D) internal view returns (uint256 y) {
        uint256 c = (D * D) / (x * 2);
        c = (c * D) / ((N_A * 2) / A_PRECISION);
        uint256 b = x + ((D * A_PRECISION) / N_A);
        uint256 yPrev;
        y = D;
        // @dev Iterative approximation.
        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - D);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    /// @notice Calculate the price of a token in the pool given
    /// precision-adjusted balances and a particular D and precision-adjusted
    /// array of balances.
    /// @dev This is accomplished via solving the quadratic equation iteratively.
    /// See the StableSwap paper and Curve.fi implementation for further details.
    /// x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
    /// x_1**2 + b*x_1 = c
    /// x_1 = (x_1**2 + c) / (2*x_1 + b)
    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L276.
    /// @return y The price of the token, in the same precision as in xp.
    function _getYD(
        uint256 s, // @dev xpOut.
        uint256 d
    ) internal view returns (uint256 y) {
        uint256 c = (d * d) / (s * 2);
        c = (c * d) / ((N_A * 2) / A_PRECISION);

        uint256 b = s + ((d * A_PRECISION) / N_A);
        uint256 yPrev;
        y = d;

        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
            yPrev = y;
            y = (y * y + c) / (y * 2 + b - d);
            if (y.within1(yPrev)) {
                break;
            }
        }
    }

    function _handleFee(address tokenIn, uint256 amountIn) internal returns (uint256 fee) {
        fee = (amountIn * swapFee) / MAX_FEE;
        uint256 _barFee = (fee * barFee) / MAX_FEE;
        _transfer(tokenIn, _barFee, barFeeTo, false);
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;

        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint256 _reserve0, uint256 _reserve1) = _getReserves();
        amountIn = _toAmount(tokenIn, amountIn);
        amountIn -= (amountIn * swapFee) / MAX_FEE;

        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);
        }
    }

    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) {
        (_reserve0, _reserve1) = _getReserves();
    }
}",5436
RealWorld_TA_29_IBentoBoxMinimal_RealWorld_20240803223631.log,29,IBentoBoxMinimal,77115,2046,79161,94.0,0.426495,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Minimal BentoBox vault interface. 
/// @dev `token` is aliased as `address` from `IERC20` for simplicity.
interface IBentoBoxMinimal {
    /// @notice Balance per ERC-20 token per account in shares.
    function balanceOf(address, address) external view returns (uint256);
    
    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        address token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share);
    
    /// @dev Helper function to represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        address token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount);
    
    /// @notice Registers this contract so that users can approve it for BentoBox.
    function registerProtocol() external;

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external payable returns (uint256 amountOut, uint256 shareOut);

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external returns (uint256 amountOut, uint256 shareOut);

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    function transfer(
        address token,
        address from,
        address to,
        uint256 share
    ) external;
}",699
RealWorld_TA_29_HybridPoolFactory_RealWorld_20240803215612.log,29,HybridPoolFactory,42286,1880,44166,100.0,0.24903,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./HybridPool.sol"";
import ""./PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Hybrid Pool with configurations.
/// @author Mudit Gupta.
contract HybridPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address tokenA, address tokenB, uint256 swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));
        if (tokenA > tokenB) {
            (tokenA, tokenB) = (tokenB, tokenA);
            _deployData = abi.encode(tokenA, tokenB, swapFee, a);
        }
        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new HybridPool{salt: salt}(_deployData, masterDeployer));
        _registerPool(pool, tokens, salt);
    }
}",282
RealWorld_TA_29_WhiteListManager_RealWorld_20240803222026.log,29,WhiteListManager,126625,3473,130098,134.0,0.702585,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

contract WhiteListManager {
    event WhiteListAccount(address indexed operator, address indexed account, bool approved);
    event SetMerkleRoot(address operator, bytes32 merkleRoot);
    event JoinWithMerkle(address operator, uint256 indexed index, address indexed account);

    /// @notice EIP-712 related variables and functions.
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH = keccak256(""SetWhitelisting(address account,bool approved,uint256 deadline)"");
    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    bytes32 private immutable _DOMAIN_SEPARATOR;
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    mapping(address => mapping(address => bool)) public whitelistedAccounts;

    /// @notice Merkle root variables.
    mapping(address => bytes32) public merkleRoot;
    /// @notice Packed array of booleans.
    mapping(address => mapping(uint256 => uint256)) internal whitelistedBitMap;

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32 domainSeperator) {
        domainSeperator = keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""WhiteListManager""), chainId, address(this)));
    }

    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {
        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);
    }

    constructor() {
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = block.chainid);
    }

    function whitelistAccount(address user, bool approved) external {
        _whitelistAccount(msg.sender, user, approved);
    }

    function _whitelistAccount(
        address operator,
        address account,
        bool approved
    ) private {
        whitelistedAccounts[operator][account] = approved;
        emit WhiteListAccount(operator, account, approved);
    }

    /// @notice Approves or revokes whitelisting for accounts.
    /// @param operator The address of the operator that approves or revokes access.
    /// @param account The address who gains or loses access.
    /// @param approved If 'true', approves access - if 'false', revokes access.
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function setWhitelisting(
        address operator,
        address account,
        bool approved,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // @dev Checks:
        require(account != address(0), ""ACCOUNT_NOT_SET"");
        // - also, ecrecover returns address(0) on failure. So we check this, even if the modifier should prevent it:
        require(operator != address(0), ""OPERATOR_NULL"");
        require(deadline >= block.timestamp && deadline <= (block.timestamp + 1 weeks), ""EXPIRED"");

        bytes32 digest = keccak256(
            abi.encodePacked(
                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                DOMAIN_SEPARATOR(),
                keccak256(abi.encode(APPROVAL_SIGNATURE_HASH, account, approved, deadline))
            )
        );

        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == operator, ""INVALID_SIGNATURE"");

        _whitelistAccount(operator, account, approved);
    }

    /// **** WHITELISTING
    /// @dev Adapted from OpenZeppelin utilities and Uniswap merkle distributor.
    function isWhitelisted(address operator, uint256 index) public view returns (bool success) {
        uint256 whitelistedWordIndex = index / 256;
        uint256 whitelistedBitIndex = index % 256;
        uint256 claimedWord = whitelistedBitMap[operator][whitelistedWordIndex];
        uint256 mask = (1 << whitelistedBitIndex);
        success = claimedWord & mask == mask;
    }

    function joinWhitelist(
        address operator,
        uint256 index,
        address account,
        bytes32[] calldata merkleProof
    ) external {
        require(!isWhitelisted(operator, index), ""CLAIMED"");
        bytes32 node = keccak256(abi.encodePacked(index, account));
        bytes32 computedHash = node;
        for (uint256 i = 0; i < merkleProof.length; i++) {
            bytes32 proofElement = merkleProof[i];
            if (computedHash <= proofElement) {
                // @dev Hash(current computed hash + current element of the proof).
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                // @dev Hash(current element of the proof + current computed hash).
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        // @dev Check if the computed hash (root) is equal to the provided root.
        require(computedHash == merkleRoot[operator], ""NOT_ROOTED"");
        uint256 whitelistedWordIndex = index / 256;
        uint256 whitelistedBitIndex = index % 256;
        whitelistedBitMap[operator][whitelistedWordIndex] = whitelistedBitMap[operator][whitelistedWordIndex] | (1 << whitelistedBitIndex);
        _whitelistAccount(operator, account, true);
        emit JoinWithMerkle(operator, index, account);
    }

    function setMerkleRoot(bytes32 _merkleRoot) external {
        // @dev Set the new merkle root.
        merkleRoot[msg.sender] = _merkleRoot;
        emit SetMerkleRoot(msg.sender, _merkleRoot);
    }
}",1295
RealWorld_TA_29_FranchisedIndexPool_RealWorld_20240803221711.log,29,FranchisedIndexPool,346292,6416,352708,192.0,1.85978,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""./TridentFranchisedERC20.sol"";

/// @notice Trident exchange franchised pool template with constant mean formula for swapping among an array of ERC-20 tokens.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract FranchisedIndexPool is IPool, TridentFranchisedERC20 {
    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);
    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);

    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;

    uint256 internal constant BASE = 10**18;
    uint256 internal constant MIN_TOKENS = 2;
    uint256 internal constant MAX_TOKENS = 8;
    uint256 internal constant MIN_FEE = BASE / 10**6;
    uint256 internal constant MAX_FEE = BASE / 10;
    uint256 internal constant MIN_WEIGHT = BASE;
    uint256 internal constant MAX_WEIGHT = BASE * 50;
    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;
    uint256 internal constant MIN_BALANCE = BASE / 10**12;
    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;
    uint256 internal constant MIN_POW_BASE = 1;
    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;
    uint256 internal constant POW_PRECISION = BASE / 10**10;
    uint256 internal constant MAX_IN_RATIO = BASE / 2;
    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;

    uint136 internal totalWeight;
    address[] internal tokens;

    uint256 public barFee;

    bytes32 public constant override poolIdentifier = ""Trident:FranchisedIndex"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(address => Record) public records;
    struct Record {
        uint120 reserve;
        uint136 weight;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee, address _whiteListManager, address _operator, bool _level2) = abi.decode(
            _deployData,
            (address[], uint136[], uint256, address, address, bool)
        );
        // @dev Factory ensures that the tokens are sorted.
        require(_tokens.length == _weights.length, ""INVALID_ARRAYS"");
        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, ""INVALID_TOKENS_LENGTH"");

        TridentFranchisedERC20.initialize(_whiteListManager, _operator, _level2);

        for (uint256 i = 0; i < _tokens.length; i++) {
            require(_tokens[i] != address(0), ""ZERO_ADDRESS"");
            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, ""INVALID_WEIGHT"");
            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});
            tokens.push(_tokens[i]);
            totalWeight += _weights[i];
        }

        require(totalWeight <= MAX_TOTAL_WEIGHT, ""MAX_TOTAL_WEIGHT"");
        // @dev This burns initial LP supply.
        _mint(address(0), INIT_POOL_SUPPLY);

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));

        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));
        _checkWhiteList(recipient);
        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked {
                // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));
        _checkWhiteList(recipient);
        uint256 ratio = _div(toBurn, totalSupply);

        withdrawnAmounts = new TokenAmount[](tokens.length);

        _burn(address(this), toBurn);

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenOut = tokens[i];
            uint256 balance = records[tokenOut].reserve;
            uint120 amountOut = uint120(_mul(ratio, balance));
            require(amountOut != 0, ""ZERO_OUT"");
            // @dev This is safe from underflow - only logged amounts handled.
            unchecked {
                records[tokenOut].reserve -= amountOut;
            }
            _transfer(tokenOut, amountOut, recipient, unwrapBento);
            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});
            emit Burn(msg.sender, tokenOut, amountOut, recipient);
        }
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, address, bool, uint256));
        _checkWhiteList(recipient);
        Record storage outRecord = records[tokenOut];

        amountOut = _computeSingleOutGivenPoolIn(outRecord.reserve, outRecord.weight, totalSupply, totalWeight, toBurn, swapFee);

        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), ""MAX_OUT_RATIO"");
        // @dev This is safe from underflow - only logged amounts handled.
        unchecked {
            outRecord.reserve -= uint120(amountOut);
        }
        _burn(address(this), toBurn);
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Burn(msg.sender, tokenOut, amountOut, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(
            data,
            (address, address, address, bool, uint256)
        );
        if (level2) _checkWhiteList(recipient);
        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked {
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, address, bool, uint256, bytes)
        );
        if (level2) _checkWhiteList(recipient);
        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);

        ITridentCallee(msg.sender).tridentSwapCallback(context);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked {
            // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _balance(address token) internal view returns (uint256 balance) {
        (, bytes memory data) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, token, address(this)));
        balance = abi.decode(data, (uint256));
    }

    function _getAmountOut(
        uint256 tokenInAmount,
        uint256 tokenInBalance,
        uint256 tokenInWeight,
        uint256 tokenOutBalance,
        uint256 tokenOutWeight
    ) internal view returns (uint256 amountOut) {
        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);
        // @dev This is safe from under/overflow - only logged amounts handled.
        unchecked {
            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));
            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);
            uint256 b = _compute(a, weightRatio);
            uint256 c = BASE - b;
            amountOut = _mul(tokenOutBalance, c);
        }
    }

    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {
        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, ""INVALID_BASE"");

        uint256 whole = (exp / BASE) * BASE;
        uint256 remain = exp - whole;
        uint256 wholePow = _pow(base, whole / BASE);

        if (remain == 0) output = wholePow;

        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);
        output = _mul(wholePow, partialResult);
    }

    function _computeSingleOutGivenPoolIn(
        uint256 tokenOutBalance,
        uint256 tokenOutWeight,
        uint256 _totalSupply,
        uint256 _totalWeight,
        uint256 toBurn,
        uint256 _swapFee
    ) internal pure returns (uint256 amountOut) {
        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);
        uint256 newPoolSupply = _totalSupply - toBurn;
        uint256 poolRatio = _div(newPoolSupply, _totalSupply);
        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));
        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);
        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;
        uint256 zaz = (BASE - normalizedWeight) * _swapFee;
        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));
    }

    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {
        output = n % 2 != 0 ? a : BASE;
        for (n /= 2; n != 0; n /= 2) a = a * a;
        if (n % 2 != 0) output = output * a;
    }

    function _powApprox(
        uint256 base,
        uint256 exp,
        uint256 precision
    ) internal pure returns (uint256 sum) {
        uint256 a = exp;
        (uint256 x, bool xneg) = _subFlag(base, BASE);
        uint256 term = BASE;
        sum = term;
        bool negative;

        for (uint256 i = 1; term >= precision; i++) {
            uint256 bigK = i * BASE;
            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));
            term = _mul(term, _mul(c, x));
            term = _div(term, bigK);
            if (term == 0) break;
            if (xneg) negative = !negative;
            if (cneg) negative = !negative;
            if (negative) {
                sum = sum - term;
            } else {
                sum = sum + term;
            }
        }
    }

    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {
        // @dev This is safe from underflow - if/else flow performs checks.
        unchecked {
            if (a >= b) {
                (difference, flag) = (a - b, false);
            } else {
                (difference, flag) = (b - a, true);
            }
        }
    }

    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * b;
        uint256 c1 = c0 + (BASE / 2);
        c2 = c1 / BASE;
    }

    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * BASE;
        uint256 c1 = c0 + (b / 2);
        c2 = c1 / b;
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = tokens;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {
        (uint256 tokenInAmount, uint256 tokenInBalance, uint256 tokenInWeight, uint256 tokenOutBalance, uint256 tokenOutWeight) = abi.decode(
            data,
            (uint256, uint256, uint256, uint256, uint256)
        );
        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);
    }

    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {
        uint256 length = tokens.length;
        reserves = new uint256[](length);
        weights = new uint136[](length);
        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.
        unchecked {
            for (uint256 i = 0; i < length; i++) {
                reserves[i] = records[tokens[i]].reserve;
                weights[i] = records[tokens[i]].weight;
            }
        }
    }
}",3872
RealWorld_TA_29_PoolDeployer_RealWorld_20240803220425.log,29,PoolDeployer,59365,3493,62858,120.0,0.366685,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool deployer for whitelisted template factories.
/// @author Mudit Gupta.
abstract contract PoolDeployer {
    address public immutable masterDeployer;

    mapping(address => mapping(address => address[])) public pools;
    mapping(bytes32 => address) public configAddress;

    modifier onlyMaster() {
        require(msg.sender == masterDeployer, ""UNAUTHORIZED_DEPLOYER"");
        _;
    }

    constructor(address _masterDeployer) {
        require(_masterDeployer != address(0), ""ZERO_ADDRESS"");
        masterDeployer = _masterDeployer;
    }

    function _registerPool(
        address pool,
        address[] memory tokens,
        bytes32 salt
    ) internal onlyMaster {
        require(configAddress[salt] == address(0), ""POOL_ALREADY_DEPLOYED"");
        // @dev Store the address of the deployed contract.
        configAddress[salt] = pool;
        // @dev Attacker used underflow, it was not very effective. poolimon!
        // null token array would cause deployment to fail via out of bounds memory axis/gas limit.
        unchecked {
            for (uint256 i; i < tokens.length - 1; i++) {
                require(tokens[i] < tokens[i + 1], ""INVALID_TOKEN_ORDER"");
                for (uint256 j = i + 1; j < tokens.length; j++) {
                    pools[tokens[i]][tokens[j]].push(pool);
                    pools[tokens[j]][tokens[i]].push(pool);
                }
            }
        }
    }

    function poolsCount(address token0, address token1) external view returns (uint256 count) {
        count = pools[token0][token1].length;
    }

    function getPools(
        address token0,
        address token1,
        uint256 startIndex,
        uint256 endIndex
    ) external view returns (address[] memory pairPools) {
        pairPools = new address[](endIndex - startIndex);
        for (uint256 i = 0; startIndex < endIndex; i++) {
            pairPools[i] = pools[token0][token1][startIndex];
            startIndex++;
        }
    }
}",469
RealWorld_TA_29_PoolTemplate_RealWorld_20240803215127.log,29,PoolTemplate,25359,1385,26744,85.0,0.154495,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

/**
 * @author Mudit Gupta
 */
contract PoolTemplate {
    uint256 public immutable configValue;
    address public immutable anotherConfigValue;

    constructor(bytes memory _data) {
        (configValue, anotherConfigValue) = abi.decode(_data, (uint256, address));
    }
}",84
RealWorld_TA_29_FranchisedConstantProductPool_RealWorld_20240803222242.log,29,FranchisedConstantProductPool,379649,7147,386796,223.0,2.041185,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IBentoBoxMinimal.sol"";
import ""../../interfaces/IMasterDeployer.sol"";
import ""../../interfaces/IPool.sol"";
import ""../../interfaces/ITridentCallee.sol"";
import ""../../libraries/TridentMath.sol"";
import ""./TridentFranchisedERC20.sol"";

/// @notice Trident exchange franchised pool template with constant product formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract FranchisedConstantProductPool is IPool, TridentFranchisedERC20 {
    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 1000;

    uint8 internal constant PRECISION = 112;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 internal constant MAX_FEE_SQUARE = 100000000;
    uint256 internal constant E18 = uint256(10)**18;
    uint256 public immutable swapFee;
    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;

    uint256 public barFee;
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast;

    uint112 internal reserve0;
    uint112 internal reserve1;
    uint32 internal blockTimestampLast;

    bytes32 public constant override poolIdentifier = ""Trident:FranchisedCP"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport, address _whiteListManager, address _operator, bool _level2) = abi.decode(
            _deployData,
            (address, address, uint256, bool, address, address, bool)
        );

        // @dev Factory ensures that the tokens are sorted.
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_token0 != address(this), ""INVALID_TOKEN"");
        require(_token1 != address(this), ""INVALID_TOKEN"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");

        TridentFranchisedERC20.initialize(_whiteListManager, _operator, _level2);

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        // @dev This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.
        unchecked {
            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;
        }
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
        if (_twapSupport) blockTimestampLast = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1));

        if (_totalSupply == 0) {
            _mint(address(0), MINIMUM_LIQUIDITY);
            liquidity = computed - MINIMUM_LIQUIDITY;
        } else {
            uint256 k = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            liquidity = ((computed - k) * _totalSupply) / k;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);
        // @dev This is safe from underflow - amounts are lesser figures derived from balances.
        unchecked {
            balance0 -= amount0;
            balance1 -= amount1;
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        unchecked {
            if (tokenOut == token1) {
                // @dev Swap `token0` for `token1`
                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);
                _transfer(token1, amount1, recipient, unwrapBento);
                balance1 -= amount1;
                amountOut = amount1;
                amount0 = 0;
            } else {
                // @dev Swap `token1` for `token0`.
                require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);
                _transfer(token0, amount0, recipient, unwrapBento);
                balance0 -= amount0;
                amountOut = amount0;
                amount1 = 0;
            }
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        if (level2) _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;
        unchecked {
            if (tokenIn == token0) {
                tokenOut = token1;
                amountIn = balance0 - _reserve0;
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                balance1 -= amountOut;
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                tokenOut = token0;
                amountIn = balance1 - reserve1;
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                balance0 -= amountOut;
            }
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        if (level2) _checkWhiteList(recipient);
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        unchecked {
            if (tokenIn == token0) {
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                _transfer(token1, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                _transfer(token0, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);
            }
        }
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _getReserves()
        internal
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        // @dev balanceOf(address,address).
        (, bytes memory _balance0) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token0, address(this)));
        balance0 = abi.decode(_balance0, (uint256));
        // @dev balanceOf(address,address).
        (, bytes memory _balance1) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token1, address(this)));
        balance1 = abi.decode(_balance1, (uint256));
    }

    function _update(
        uint256 balance0,
        uint256 balance1,
        uint112 _reserve0,
        uint112 _reserve1,
        uint32 _blockTimestampLast
    ) internal {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, ""OVERFLOW"");
        if (blockTimestampLast == 0) {
            // @dev TWAP support is disabled for gas efficiency.
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
        } else {
            uint32 blockTimestamp = uint32(block.timestamp % 2**32);
            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {
                unchecked {
                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;
                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;
                    price0CumulativeLast += price0 * timeElapsed;
                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;
                    price1CumulativeLast += price1 * timeElapsed;
                }
            }
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
            blockTimestampLast = blockTimestamp;
        }
        emit Sync(balance0, balance1);
    }

    function _mintFee(
        uint112 _reserve0,
        uint112 _reserve1,
        uint256 _totalSupply
    ) internal returns (uint256 liquidity) {
        uint256 _kLast = kLast;
        if (_kLast != 0) {
            uint256 computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            if (computed > _kLast) {
                // @dev `barFee` % of increase in liquidity.
                // It's going to be slightly less than `barFee` % in reality due to the math.
                liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;
                if (liquidity != 0) {
                    _mint(barFeeTo, liquidity);
                }
            }
        }
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 reserveAmountIn,
        uint256 reserveAmountOut
    ) internal view returns (uint256 amountOut) {
        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;
        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();
        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
        }
    }

    function getReserves()
        public
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        return _getReserves();
    }
}",4268
RealWorld_TA_29_TridentHelper_RealWorld_20240803214920.log,29,TridentHelper,152033,4315,156348,125.0,0.846465,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../TridentRouter.sol"";

/// @notice Trident router helper contract.
contract TridentHelper {
    /// @notice ERC-20 token for wrapped ETH (v9).
    address internal immutable wETH;

    constructor(address _wETH) {
        wETH = _wETH;
    }

    /// @notice Provides batch function calls for this contract and returns the data from all of them if they all succeed.
    /// Adapted from https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol, License-Identifier: GPL-2.0-or-later.
    /// @dev The `msg.value` should not be trusted for any method callable from this function.
    /// @param data ABI-encoded params for each of the calls to make to this contract.
    /// @return results The results from each of the calls passed in via `data`.
    function batch(bytes[] calldata data) external payable returns (bytes[] memory results) {
        results = new bytes[](data.length);
        // We only allow one exactInputSingle call to be made in a single batch call.
        // This is not really needed but we want to save users from signing malicious payloads.
        // We also don't want nested batch calls.
        bool swapCalled;
        for (uint256 i = 0; i < data.length; i++) {
            bytes4 selector = getSelector(data[i]);
            if (selector == TridentRouter.exactInputSingle.selector || selector == TridentRouter.exactInputSingleWithNativeToken.selector) {
                require(!swapCalled, ""Swap called twice"");
                swapCalled = true;
            } else {
                require(selector != this.batch.selector, ""Nested Batch"");
            }

            (bool success, bytes memory result) = address(this).delegatecall(data[i]);
            if (!success) {
                // @dev Next 5 lines from https://ethereum.stackexchange.com/a/83577.
                if (result.length < 68) revert();
                assembly {
                    result := add(result, 0x04)
                }
                revert(abi.decode(result, (string)));
            }
            results[i] = result;
        }
    }

    /// @notice Provides gas-optimized balance check on this contract to avoid redundant extcodesize check in addition to returndatasize check.
    /// @param token Address of ERC-20 token.
    /// @return balance Token amount held by this contract.
    function balanceOfThis(address token) internal view returns (uint256 balance) {
        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, address(this))); // @dev balanceOf(address).
        require(success && data.length >= 32, ""BALANCE_OF_FAILED"");
        balance = abi.decode(data, (uint256));
    }

    /// @notice Provides EIP-2612 signed approval for this contract to spend user tokens.
    /// @param token Address of ERC-20 token.
    /// @param amount Token amount to grant spending right over.
    /// @param deadline Termination for signed approval (UTC timestamp in seconds).
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permitThis(
        address token,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        (bool success, ) = token.call(abi.encodeWithSelector(0xd505accf, msg.sender, address(this), amount, deadline, v, r, s)); // @dev permit(address,address,uint256,uint256,uint8,bytes32,bytes32).
        require(success, ""PERMIT_FAILED"");
    }

    /// @notice Provides DAI-derived signed approval for this contract to spend user tokens.
    /// @param token Address of ERC-20 token.
    /// @param nonce Token owner's nonce - increases at each call to {permit}.
    /// @param expiry Termination for signed approval - UTC timestamp in seconds.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permitThisAllowed(
        address token,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        (bool success, ) = token.call(abi.encodeWithSelector(0x8fcbaf0c, msg.sender, address(this), nonce, expiry, true, v, r, s)); // @dev permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32).
        require(success, ""PERMIT_FAILED"");
    }

    /// @notice Provides 'safe' ERC-20 {transfer} for tokens that don't consistently return true/false.
    /// @param token Address of ERC-20 token.
    /// @param recipient Account to send tokens to.
    /// @param amount Token amount to send.
    function safeTransfer(
        address token,
        address recipient,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount)); // @dev transfer(address,uint256).
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""TRANSFER_FAILED"");
    }

    /// @notice Provides 'safe' ERC-20 {transferFrom} for tokens that don't consistently return true/false.
    /// @param token Address of ERC-20 token.
    /// @param sender Account to send tokens from.
    /// @param recipient Account to send tokens to.
    /// @param amount Token amount to send.
    function safeTransferFrom(
        address token,
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount)); // @dev transferFrom(address,address,uint256).
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""TRANSFER_FROM_FAILED"");
    }

    /// @notice Provides low-level `wETH` {withdraw}.
    /// @param amount Token amount to unwrap into ETH.
    function withdrawFromWETH(uint256 amount) internal {
        (bool success, bytes memory data) = wETH.call(abi.encodeWithSelector(0x2e1a7d4d, amount)); // @dev withdraw(uint256).
        require(success && data.length >= 32, ""WITHDRAW_FROM_WETH_FAILED"");
    }

    /// @notice Provides 'safe' ETH transfer.
    /// @param recipient Account to send ETH to.
    /// @param amount ETH amount to send.
    function safeTransferETH(address recipient, uint256 amount) internal {
        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""ETH_TRANSFER_FAILED"");
    }

    /**
     * @notice function to extract the selector of a bytes calldata
     * @param _data the calldata bytes
     */
    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) {
        assembly {
            sig := mload(add(_data, 32))
        }
    }
}",1565
RealWorld_TA_29_ITridentCallee_RealWorld_20240803222843.log,29,ITridentCallee,23537,1161,24698,84.0,0.140905,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool callback interface.
interface ITridentCallee {
    function tridentSwapCallback(bytes calldata data) external;

    function tridentMintCallback(bytes calldata data) external;
}",66
RealWorld_TA_29_IndexPool_RealWorld_20240803220627.log,29,IndexPool,341874,6463,348337,192.0,1.83863,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IBentoBoxMinimal.sol"";
import ""../interfaces/IMasterDeployer.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with constant mean formula for swapping among an array of ERC-20 tokens.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract IndexPool is IPool, TridentERC20 {
    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);
    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);

    uint256 public immutable swapFee;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;

    uint256 internal constant BASE = 10**18;
    uint256 internal constant MIN_TOKENS = 2;
    uint256 internal constant MAX_TOKENS = 8;
    uint256 internal constant MIN_FEE = BASE / 10**6;
    uint256 internal constant MAX_FEE = BASE / 10;
    uint256 internal constant MIN_WEIGHT = BASE;
    uint256 internal constant MAX_WEIGHT = BASE * 50;
    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;
    uint256 internal constant MIN_BALANCE = BASE / 10**12;
    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;
    uint256 internal constant MIN_POW_BASE = 1;
    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;
    uint256 internal constant POW_PRECISION = BASE / 10**10;
    uint256 internal constant MAX_IN_RATIO = BASE / 2;
    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;
    
    uint136 internal totalWeight;
    address[] internal tokens;
    
    uint256 public barFee;
    
    bytes32 public constant override poolIdentifier = ""Trident:Index"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    mapping(address => Record) public records;
    struct Record {
        uint120 reserve;
        uint136 weight;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee) = abi.decode(
            _deployData,
            (address[], uint136[], uint256)
        );
        // @dev Factory ensures that the tokens are sorted.
        require(_tokens.length == _weights.length, ""INVALID_ARRAYS"");
        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");
        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, ""INVALID_TOKENS_LENGTH"");

        for (uint256 i = 0; i < _tokens.length; i++) {
            require(_tokens[i] != address(0), ""ZERO_ADDRESS"");
            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, ""INVALID_WEIGHT"");
            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});
            tokens.push(_tokens[i]);
            totalWeight += _weights[i];
        }
        
        require(totalWeight <= MAX_TOTAL_WEIGHT, ""MAX_TOTAL_WEIGHT"");
        // @dev This burns initial LP supply.
        _mint(address(0), INIT_POOL_SUPPLY); 

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));
        
        swapFee = _swapFee;
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
    }
    
    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));
        
        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked { // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }
    
    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));
        
        uint256 ratio = _div(toBurn, totalSupply);
        
        withdrawnAmounts = new TokenAmount[](tokens.length);
        
        _burn(address(this), toBurn);

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenOut = tokens[i];
            uint256 balance = records[tokenOut].reserve;
            uint120 amountOut = uint120(_mul(ratio, balance));
            require(amountOut != 0, ""ZERO_OUT"");
            // @dev This is safe from underflow - only logged amounts handled.
            unchecked {
                records[tokenOut].reserve -= amountOut;
            }
            _transfer(tokenOut, amountOut, recipient, unwrapBento);
            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});
            emit Burn(msg.sender, tokenOut, amountOut, recipient);
        }
    }
    
    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(
            data,
            (address, address, bool, uint256)
        );

        Record storage outRecord = records[tokenOut];

        amountOut = _computeSingleOutGivenPoolIn(
            outRecord.reserve,
            outRecord.weight,
            totalSupply,
            totalWeight,
            toBurn,
            swapFee
        );

        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), ""MAX_OUT_RATIO"");
        // @dev This is safe from underflow - only logged amounts handled.
        unchecked {
            outRecord.reserve -= uint120(amountOut);
        }
        _burn(address(this), toBurn);
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Burn(msg.sender, tokenOut, amountOut, recipient);
    }
    
    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(
            data,
            (address, address, address, bool, uint256)
        );

        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked { // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (
            address tokenIn,
            address tokenOut,
            address recipient,
            bool unwrapBento,
            uint256 amountIn,
            bytes memory context
        ) = abi.decode(data, (address, address, address, bool, uint256, bytes));

        Record storage inRecord = records[tokenIn];
        Record storage outRecord = records[tokenOut];

        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), ""MAX_IN_RATIO"");

        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);

        ITridentCallee(msg.sender).tridentSwapCallback(context);
        // @dev Check Trident router has sent `amountIn` for skim into pool.
        unchecked { // @dev This is safe from under/overflow - only logged amounts handled.
            require(_balance(tokenIn) >= amountIn + inRecord.reserve, ""NOT_RECEIVED"");
            inRecord.reserve += uint120(amountIn);
            outRecord.reserve -= uint120(amountOut);
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }
    
    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }
    
    function _balance(address token) internal view returns (uint256 balance) {
        (, bytes memory data) = bento.staticcall(abi.encodeWithSelector(IBentoBoxMinimal.balanceOf.selector, 
            token, address(this)));
        balance = abi.decode(data, (uint256));
    }

    function _getAmountOut(
        uint256 tokenInAmount,
        uint256 tokenInBalance,
        uint256 tokenInWeight,
        uint256 tokenOutBalance,
        uint256 tokenOutWeight
    ) internal view returns (uint256 amountOut) {
        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);
        // @dev This is safe from under/overflow - only logged amounts handled.
        unchecked {
            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));
            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);
            uint256 b = _compute(a, weightRatio);
            uint256 c = BASE - b;
            amountOut = _mul(tokenOutBalance, c);
        }
    }

    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {
        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, ""INVALID_BASE"");
        
        uint256 whole = (exp / BASE) * BASE;   
        uint256 remain = exp - whole;
        uint256 wholePow = _pow(base, whole / BASE);
        
        if (remain == 0) output = wholePow;
        
        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);
        output = _mul(wholePow, partialResult);
    }

    function _computeSingleOutGivenPoolIn(
        uint256 tokenOutBalance,
        uint256 tokenOutWeight,
        uint256 _totalSupply,
        uint256 _totalWeight,
        uint256 toBurn,
        uint256 _swapFee
    ) internal pure returns (uint256 amountOut) {
        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);
        uint256 newPoolSupply = _totalSupply - toBurn;
        uint256 poolRatio = _div(newPoolSupply, _totalSupply);
        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));
        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);
        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;
        uint256 zaz = (BASE - normalizedWeight) * _swapFee;
        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));
    }
    
    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {
        output = n % 2 != 0 ? a : BASE;
        for (n /= 2; n != 0; n /= 2) 
            a = a * a;
            if (n % 2 != 0) output = output * a;
    }
    
    function _powApprox(uint256 base, uint256 exp, uint256 precision) internal pure returns (uint256 sum) {
        uint256 a = exp;
        (uint256 x, bool xneg) = _subFlag(base, BASE);
        uint256 term = BASE;
        sum = term;
        bool negative;

        for (uint256 i = 1; term >= precision; i++) {
            uint256 bigK = i * BASE;
            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));
            term = _mul(term, _mul(c, x));
            term = _div(term, bigK);
            if (term == 0) break;
            if (xneg) negative = !negative;
            if (cneg) negative = !negative;
            if (negative) {
                sum = sum - term;
            } else {
                sum = sum + term;
            }
        }
    }
    
    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {
        // @dev This is safe from underflow - if/else flow performs checks. 
        unchecked {
            if (a >= b) {
                (difference, flag) = (a - b, false);
            } else {
                (difference, flag) = (b - a, true);
            }
        }
    }
    
    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * b;
        uint256 c1 = c0 + (BASE / 2);
        c2 = c1 / BASE;
    }
    
    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {
        uint256 c0 = a * BASE;
        uint256 c1 = c0 + (b / 2);
        c2 = c1 / b;
    }
    
    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.withdraw.selector, 
                token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            (bool success, ) = bento.call(abi.encodeWithSelector(IBentoBoxMinimal.transfer.selector, 
                token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }
    
    function getAssets() public view override returns (address[] memory assets) {
        assets = tokens;
    }
    
    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {
        (
            uint256 tokenInAmount,
            uint256 tokenInBalance,
            uint256 tokenInWeight,
            uint256 tokenOutBalance,
            uint256 tokenOutWeight
        ) = abi.decode(data, (uint256, uint256, uint256, uint256, uint256));
        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);
    }
    
    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {
        uint256 length = tokens.length;
        reserves = new uint256[](length);
        weights = new uint136[](length);
        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.
        unchecked {
            for (uint256 i = 0; i < length; i++) {
                reserves[i] = records[tokens[i]].reserve;
                weights[i] = records[tokens[i]].weight;
            }
        }
    }
}",3816
RealWorld_TA_29_MasterDeployer_RealWorld_20240803213954.log,29,MasterDeployer,62410,1940,64350,89.0,0.35085,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IPoolFactory.sol"";
import ""../utils/TridentOwnable.sol"";

/// @notice Trident pool deployer contract with template factory whitelist.
/// @author Mudit Gupta.
contract MasterDeployer is TridentOwnable {
    event DeployPool(address indexed _factory, address indexed pool);
    event AddToWhitelist(address indexed _factory);
    event RemoveFromWhitelist(address indexed _factory);
    event BarFeeUpdated(uint256 indexed _barFee);
    event MigratorUpdated(address indexed _migrator);

    uint256 public barFee;
    address public migrator;

    address public immutable barFeeTo;
    address public immutable bento;

    uint256 internal constant MAX_FEE = 10000; // @dev 100%.

    mapping(address => bool) public pools;

    mapping(address => bool) public whitelistedFactories;

    constructor(
        uint256 _barFee,
        address _barFeeTo,
        address _bento
    ) {
        require(_barFee <= MAX_FEE, ""INVALID_BAR_FEE"");
        require(_barFeeTo != address(0), ""ZERO_ADDRESS"");
        require(_bento != address(0), ""ZERO_ADDRESS"");

        barFee = _barFee;
        barFeeTo = _barFeeTo;
        bento = _bento;
    }

    function deployPool(address _factory, bytes calldata _deployData) external returns (address pool) {
        require(whitelistedFactories[_factory], ""FACTORY_NOT_WHITELISTED"");
        pool = IPoolFactory(_factory).deployPool(_deployData);
        pools[pool] = true;
        emit DeployPool(_factory, pool);
    }

    function addToWhitelist(address _factory) external onlyOwner {
        whitelistedFactories[_factory] = true;
        emit AddToWhitelist(_factory);
    }

    function removeFromWhitelist(address _factory) external onlyOwner {
        whitelistedFactories[_factory] = false;
        emit RemoveFromWhitelist(_factory);
    }

    function setBarFee(uint256 _barFee) external onlyOwner {
        require(_barFee <= MAX_FEE, ""INVALID_BAR_FEE"");
        barFee = _barFee;
        emit BarFeeUpdated(_barFee);
    }

    function setMigrator(address _migrator) external onlyOwner {
        migrator = _migrator;
        emit MigratorUpdated(_migrator);
    }
}",536
RealWorld_TA_29_IndexPoolFactory_RealWorld_20240803215754.log,29,IndexPoolFactory,35084,2205,37289,94.0,0.21952,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./IndexPool.sol"";
import ""./PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Index Pool with configurations.
/// @author Mudit Gupta
contract IndexPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address[] memory tokens, , ) = abi.decode(_deployData, (address[], uint256[], uint256));

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new IndexPool{salt: salt}(_deployData, masterDeployer));
        _registerPool(pool, tokens, salt);
    }
}",194
RealWorld_TA_29_TridentERC20_RealWorld_20240803215430.log,29,TridentERC20,124618,2471,127089,100.0,0.67251,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool ERC-20 with EIP-2612 extension.
/// @author Adapted from RariCapital, https://github.com/Rari-Capital/solmate/blob/main/src/erc20/ERC20.sol,
/// License-Identifier: AGPL-3.0-only.
abstract contract TridentERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 amount);
    event Transfer(address indexed sender, address indexed recipient, uint256 amount);

    string public constant name = ""Sushi LP Token"";
    string public constant symbol = ""SLP"";
    uint8 public constant decimals = 18;

    uint256 public totalSupply;
    /// @notice owner -> balance mapping.
    mapping(address => uint256) public balanceOf;
    /// @notice owner -> spender -> allowance mapping.
    mapping(address => mapping(address => uint256)) public allowance;

    /// @notice The EIP-712 typehash for this contract's {permit} struct.
    bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    /// @notice The EIP-712 typehash for this contract's domain.
    bytes32 public immutable DOMAIN_SEPARATOR;
    /// @notice owner -> nonce mapping used in {permit}.
    mapping(address => uint256) public nonces;

    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                block.chainid,
                address(this)
            )
        );
    }

    /// @notice Approves `amount` from `msg.sender` to be spent by `spender`.
    /// @param spender Address of the party that can pull tokens from `msg.sender`'s account.
    /// @param amount The maximum collective `amount` that `spender` can pull.
    /// @return (bool) Returns 'true' if succeeded.
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `msg.sender` to `recipient`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transfer(address recipient, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `sender` to `recipient`. Caller needs approval from `from`.
    /// @param sender Address to pull tokens `from`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        if (allowance[sender][msg.sender] != type(uint256).max) {
            allowance[sender][msg.sender] -= amount;
        }
        balanceOf[sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(sender, recipient, amount);
        return true;
    }

    /// @notice Triggers an approval from `owner` to `spender`.
    /// @param owner The address to approve from.
    /// @param spender The address to be approved.
    /// @param amount The number of tokens that are approved (2^256-1 means infinite).
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline)))
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_PERMIT_SIGNATURE"");
        allowance[recoveredAddress][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address recipient, uint256 amount) internal {
        totalSupply += amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(address(0), recipient, amount);
    }

    function _burn(address sender, uint256 amount) internal {
        balanceOf[sender] -= amount;
        // @dev This is safe from underflow - users won't ever
        // have a balance larger than `totalSupply`.
        unchecked {
            totalSupply -= amount;
        }
        emit Transfer(sender, address(0), amount);
    }
}",1260
RealWorld_TA_29_TridentRouter_RealWorld_20240803212905.log,29,TridentRouter,361436,5303,366739,181.0,1.91324,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./interfaces/IBentoBoxMinimal.sol"";
import ""./interfaces/IPool.sol"";
import ""./interfaces/ITridentRouter.sol"";
import ""./utils/TridentHelper.sol"";
import ""./deployer/MasterDeployer.sol"";

//import ""hardhat/console.sol"";

/// @notice Router contract that helps in swapping across Trident pools.
contract TridentRouter is ITridentRouter, TridentHelper {
    /// @notice BentoBox token vault.
    IBentoBoxMinimal public immutable bento;
    MasterDeployer public immutable masterDeployer;

    /// @dev Used to ensure that `tridentSwapCallback` is called only by the authorized address.
    /// These are set when someone calls a flash swap and reset afterwards.
    address internal cachedMsgSender;
    address internal cachedPool;

    mapping(address => bool) internal whitelistedPools;

    constructor(
        IBentoBoxMinimal _bento,
        MasterDeployer _masterDeployer,
        address _wETH
    ) TridentHelper(_wETH) {
        _bento.registerProtocol();
        bento = _bento;
        masterDeployer = _masterDeployer;
    }

    receive() external payable {
        require(msg.sender == wETH);
    }

    /// @notice Swaps token A to token B directly. Swaps are done on `bento` tokens.
    /// @param params This includes the address of token A, pool, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pool for the swap.
    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.
    function exactInputSingle(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Prefund the pool with token A.
        bento.transfer(params.tokenIn, msg.sender, params.pool, params.amountIn);
        // @dev Trigger the swap in the pool.
        amountOut = IPool(params.pool).swap(params.data);
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B indirectly by using multiple hops.
    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pools for the swaps.
    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.
    function exactInput(ExactInputParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Pay the first pool directly.
        bento.transfer(params.tokenIn, msg.sender, params.path[0].pool, params.amountIn);
        // @dev Call every pool in the path.
        // Pool `N` should transfer its output tokens to pool `N+1` directly.
        // The last pool should transfer its output tokens to the user.
        // If the user wants to unwrap `wETH`, the final destination should be this contract and
        // a batch call should be made to `unwrapWETH`.
        for (uint256 i; i < params.path.length; i++) {
            // We don't necessarily need this check but saving users from themseleves.
            isWhiteListed(params.path[i].pool);
            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);
        }
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B by using callbacks.
    /// @param path Addresses of the pools and data required by the pools for the swaps.
    /// @param amountOutMinimum Minimum amount of token B after the swap.
    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.
    /// This function will unlikely be used in production but it shows how to use callbacks. One use case will be arbitrage.
    function exactInputLazy(uint256 amountOutMinimum, Path[] calldata path) public payable returns (uint256 amountOut) {
        // @dev Call every pool in the path.
        // Pool `N` should transfer its output tokens to pool `N+1` directly.
        // The last pool should transfer its output tokens to the user.
        for (uint256 i; i < path.length; i++) {
            isWhiteListed(path[i].pool);
            // @dev The cached `msg.sender` is used as the funder when the callback happens.
            cachedMsgSender = msg.sender;
            // @dev The cached pool must be the address that calls the callback.
            cachedPool = path[i].pool;
            amountOut = IPool(path[i].pool).flashSwap(path[i].data);
        }
        // @dev Resets the `cachedPool` to get a refund.
        // `1` is used as the default value to avoid the storage slot being released.
        cachedMsgSender = address(1);
        cachedPool = address(1);
        require(amountOut >= amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B directly. It's the same as `exactInputSingle` except
    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.
    /// @param params This includes the address of token A, pool, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pool for the swap.
    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.
    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.
        _depositToBentoBox(params.tokenIn, params.pool, params.amountIn);
        // @dev Trigger the swap in the pool.
        amountOut = IPool(params.pool).swap(params.data);
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps token A to token B indirectly by using multiple hops. It's the same as `exactInput` except
    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.
    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,
    /// minimum amount of token B after the swap and data required by the pools for the swaps.
    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.
    function exactInputWithNativeToken(ExactInputParams calldata params) public payable returns (uint256 amountOut) {
        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.
        _depositToBentoBox(params.tokenIn, params.path[0].pool, params.amountIn);
        // @dev Call every pool in the path.
        // Pool `N` should transfer its output tokens to pool `N+1` directly.
        // The last pool should transfer its output tokens to the user.
        for (uint256 i; i < params.path.length; i++) {
            isWhiteListed(params.path[i].pool);
            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);
        }
        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.
        require(amountOut >= params.amountOutMinimum, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Swaps multiple input tokens to multiple output tokens using multiple paths, in different percentages.
    /// For example, you can swap 50 DAI + 100 USDC into 60% ETH and 40% BTC.
    /// @param params This includes everything needed for the swap. Look at the `ComplexPathParams` struct for more details.
    /// @dev This function is not optimized for single swaps and should only be used in complex cases where
    /// the amounts are large enough that minimizing slippage by using multiple paths is worth the extra gas.
    function complexPath(ComplexPathParams calldata params) public payable {
        // @dev Deposit all initial tokens to respective pools and initiate the swaps.
        // Input tokens come from the user - output goes to following pools.
        for (uint256 i; i < params.initialPath.length; i++) {
            if (params.initialPath[i].native) {
                _depositToBentoBox(params.initialPath[i].tokenIn, params.initialPath[i].pool, params.initialPath[i].amount);
            } else {
                bento.transfer(params.initialPath[i].tokenIn, msg.sender, params.initialPath[i].pool, params.initialPath[i].amount);
            }
            isWhiteListed(params.initialPath[i].pool);
            IPool(params.initialPath[i].pool).swap(params.initialPath[i].data);
        }
        // @dev Do all the middle swaps. Input comes from previous pools - output goes to following pools.
        for (uint256 i; i < params.percentagePath.length; i++) {
            uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));
            uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)**8;
            bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);
            isWhiteListed(params.percentagePath[i].pool);
            IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);
        }
        // @dev Do all the final swaps. Input comes from previous pools - output goes to the user.
        for (uint256 i; i < params.output.length; i++) {
            uint256 balanceShares = bento.balanceOf(params.output[i].token, address(this));
            require(balanceShares >= params.output[i].minAmount, ""TOO_LITTLE_RECEIVED"");
            if (params.output[i].unwrapBento) {
                bento.withdraw(params.output[i].token, address(this), params.output[i].to, 0, balanceShares);
            } else {
                bento.transfer(params.output[i].token, address(this), params.output[i].to, balanceShares);
            }
        }
    }

    /// @notice Add liquidity to a pool.
    /// @param tokenInput Token address and amount to add as liquidity.
    /// @param pool Pool address to add liquidity to.
    /// @param minLiquidity Minimum output liquidity - caps slippage.
    /// @param data Data required by the pool to add liquidity.
    function addLiquidity(
        TokenInput[] memory tokenInput,
        address pool,
        uint256 minLiquidity,
        bytes calldata data
    ) public payable returns (uint256 liquidity) {
        isWhiteListed(pool);
        // @dev Send all input tokens to the pool.
        for (uint256 i; i < tokenInput.length; i++) {
            if (tokenInput[i].native) {
                _depositToBentoBox(tokenInput[i].token, pool, tokenInput[i].amount);
            } else {
                bento.transfer(tokenInput[i].token, msg.sender, pool, tokenInput[i].amount);
            }
        }
        liquidity = IPool(pool).mint(data);
        require(liquidity >= minLiquidity, ""NOT_ENOUGH_LIQUIDITY_MINTED"");
    }

    /// @notice Add liquidity to a pool using callbacks - same as `addLiquidity`, but now with callbacks.
    /// @dev The input tokens are sent to the pool during the callback.
    function addLiquidityLazy(
        address pool,
        uint256 minLiquidity,
        bytes calldata data
    ) public payable returns (uint256 liquidity) {
        isWhiteListed(pool);
        cachedMsgSender = msg.sender;
        cachedPool = pool;
        // @dev The pool must ensure that there's not too much slippage.
        liquidity = IPool(pool).mint(data);
        cachedMsgSender = address(1);
        cachedPool = address(1);
        require(liquidity >= minLiquidity, ""NOT_ENOUGH_LIQUIDITY_MINTED"");
    }

    /// @notice Burn liquidity tokens to get back `bento` tokens.
    /// @param pool Pool address.
    /// @param liquidity Amount of liquidity tokens to burn.
    /// @param data Data required by the pool to burn liquidity.
    /// @param minWithdrawals Minimum amount of `bento` tokens to be returned.
    function burnLiquidity(
        address pool,
        uint256 liquidity,
        bytes calldata data,
        IPool.TokenAmount[] memory minWithdrawals
    ) public {
        isWhiteListed(pool);
        safeTransferFrom(pool, msg.sender, pool, liquidity);
        IPool.TokenAmount[] memory withdrawnLiquidity = IPool(pool).burn(data);
        for (uint256 i; i < minWithdrawals.length; i++) {
            uint256 j;
            for (; j < withdrawnLiquidity.length; j++) {
                if (withdrawnLiquidity[j].token == minWithdrawals[i].token) {
                    require(withdrawnLiquidity[j].amount >= minWithdrawals[i].amount, ""TOO_LITTLE_RECEIVED"");
                    break;
                }
            }
            // @dev A token that is present in `minWithdrawals` is missing from `withdrawnLiquidity`.
            require(j < withdrawnLiquidity.length, ""INCORRECT_TOKEN_WITHDRAWN"");
        }
    }

    /// @notice Burn liquidity tokens to get back `bento` tokens.
    /// @dev The tokens are swapped automatically and the output is in a single token.
    /// @param pool Pool address.
    /// @param liquidity Amount of liquidity tokens to burn.
    /// @param data Data required by the pool to burn liquidity.
    /// @param minWithdrawal Minimum amount of tokens to be returned.
    function burnLiquiditySingle(
        address pool,
        uint256 liquidity,
        bytes calldata data,
        uint256 minWithdrawal
    ) public {
        isWhiteListed(pool);
        // @dev Use 'liquidity = 0' for prefunding.
        safeTransferFrom(pool, msg.sender, pool, liquidity);
        uint256 withdrawn = IPool(pool).burnSingle(data);
        require(withdrawn >= minWithdrawal, ""TOO_LITTLE_RECEIVED"");
    }

    /// @notice Used by the pool 'flashSwap' functionality to take input tokens from the user.
    function tridentSwapCallback(bytes calldata data) external {
        require(msg.sender == cachedPool, ""UNAUTHORIZED_CALLBACK"");
        TokenInput memory tokenInput = abi.decode(data, (TokenInput));
        // @dev Transfer the requested tokens to the pool.
        if (tokenInput.native) {
            _depositFromUserToBentoBox(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);
        } else {
            bento.transfer(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);
        }
        // @dev Resets the `msg.sender`'s authorization.
        cachedMsgSender = address(1);
    }

    /// @notice Can be used by the pool 'mint' functionality to take tokens from the user.
    function tridentMintCallback(bytes calldata data) external {
        require(msg.sender == cachedPool, ""UNAUTHORIZED_CALLBACK"");
        TokenInput[] memory tokenInput = abi.decode(data, (TokenInput[]));
        // @dev Transfer the requested tokens to the pool.
        for (uint256 i; i < tokenInput.length; i++) {
            if (tokenInput[i].native) {
                _depositFromUserToBentoBox(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);
            } else {
                bento.transfer(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);
            }
        }
        // @dev Resets the `msg.sender`'s authorization.
        cachedMsgSender = address(1);
    }

    /// @notice Recover mistakenly sent `bento` tokens.
    function sweepBentoBoxToken(
        address token,
        uint256 amount,
        address recipient
    ) external {
        bento.transfer(token, address(this), recipient, amount);
    }

    /// @notice Recover mistakenly sent ERC-20 tokens.
    function sweepNativeToken(
        address token,
        uint256 amount,
        address recipient
    ) external {
        safeTransfer(token, recipient, amount);
    }

    /// @notice Recover mistakenly sent ETH.
    function refundETH() external payable {
        if (address(this).balance != 0) safeTransferETH(msg.sender, address(this).balance);
    }

    /// @notice Unwrap this contract's `wETH` into ETH
    function unwrapWETH(uint256 amountMinimum, address recipient) external {
        uint256 balanceWETH = balanceOfThis(wETH);
        require(balanceWETH >= amountMinimum, ""INSUFFICIENT_WETH"");
        if (balanceWETH != 0) {
            withdrawFromWETH(balanceWETH);
            safeTransferETH(recipient, balanceWETH);
        }
    }

    function _depositToBentoBox(
        address token,
        address recipient,
        uint256 amount
    ) internal {
        if (token == wETH && address(this).balance != 0) {
            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);
            if (address(this).balance >= underlyingAmount) {
                // @dev Deposit ETH into `recipient` `bento` account.
                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);
                return;
            }
        }
        // @dev Deposit ERC-20 token into `recipient` `bento` account.
        bento.deposit(token, msg.sender, recipient, 0, amount);
    }

    function _depositFromUserToBentoBox(
        address token,
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        if (token == wETH && address(this).balance != 0) {
            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);
            if (address(this).balance >= underlyingAmount) {
                // @dev Deposit ETH into `recipient` `bento` account.
                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);
                return;
            }
        }
        // @dev Deposit ERC-20 token into `recipient` `bento` account.
        bento.deposit(token, sender, recipient, 0, amount);
    }

    function isWhiteListed(address pool) internal {
        if (!whitelistedPools[pool]) {
            require(masterDeployer.pools(pool), ""INVALID POOL"");
            whitelistedPools[pool] = true;
        }
    }
}",4127
RealWorld_TA_29_TridentMath_RealWorld_20240803214624.log,29,TridentMath,61575,1389,62964,88.0,0.335655,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident sqrt helper library.
library TridentMath {
    /// @notice Calculate sqrt (x) rounding down, where `x` is unsigned 256-bit integer number.
    /// @dev Adapted from https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol, 
    /// © 2019 ABDK Consulting, License-Identifier: BSD-4-Clause.
    /// @param x Unsigned 256-bit integer number.
    /// @return result Sqrt result.
    function sqrt(uint256 x) internal pure returns (uint256 result) {
        unchecked {
            if (x == 0) result = 0;
            else {
                uint256 xx = x;
                uint256 r = 1;
                if (xx >= 0x100000000000000000000000000000000) {
                    xx >>= 128;
                    r <<= 64;
                }
                if (xx >= 0x10000000000000000) {
                    xx >>= 64;
                    r <<= 32;
                }
                if (xx >= 0x100000000) {
                    xx >>= 32;
                    r <<= 16;
                }
                if (xx >= 0x10000) {
                    xx >>= 16;
                    r <<= 8;
                }
                if (xx >= 0x100) {
                    xx >>= 8;
                    r <<= 4;
                }
                if (xx >= 0x10) {
                    xx >>= 4;
                    r <<= 2;
                }
                if (xx >= 0x8) {
                    r <<= 1;
                }
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1;
                r = (r + x / r) >> 1; // @dev Seven iterations should be enough.
                uint256 r1 = x / r;
                result = r < r1 ? r : r1;
            }
        }
    }
}",509
RealWorld_TA_29_IMasterDeployer_RealWorld_20240803223009.log,29,IMasterDeployer,25819,1362,27181,91.0,0.156335,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool deployer interface.
interface IMasterDeployer {
    function barFee() external view returns (uint256);
    
    function barFeeTo() external view returns (address);
    
    function bento() external view returns (address);
    
    function migrator() external view returns (address);
}",88
RealWorld_TA_29_MathUtils_RealWorld_20240803214455.log,29,MathUtils,42687,1746,44433,86.0,0.248355,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice A library that contains functions for calculating differences between two uint256.
/// @author Adapted from https://github.com/saddle-finance/saddle-contract/blob/master/contracts/MathUtils.sol.
library MathUtils {
    /// @notice Compares a and b and returns 'true' if the difference between a and b
    /// is less than 1 or equal to each other.
    /// @param a uint256 to compare with.
    /// @param b uint256 to compare with.
    /// @return wn 'True' if the difference between a and b is less than 1 or equal,
    /// otherwise return 'false'.
    function within1(uint256 a, uint256 b) internal pure returns (bool wn) {
        wn = difference(a, b) <= 1;
    }

    /// @notice Calculates absolute difference between a and b.
    /// @param a uint256 to compare with.
    /// @param b uint256 to compare with.
    /// @return diff Difference between a and b.
    function difference(uint256 a, uint256 b) internal pure returns (uint256 diff) {
        unchecked {
            if (a > b) {
                diff = a - b;
            }
            diff = b - a;
        }
    }
}",287
RealWorld_TA_29_TridentFranchisedERC20_RealWorld_20240803222628.log,29,TridentFranchisedERC20,144389,4018,148407,133.0,0.802305,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../../interfaces/IWhiteListManager.sol"";

/// @notice Trident franchised pool ERC-20 with EIP-2612 extension.
/// @author Adapted from RariCapital, https://github.com/Rari-Capital/solmate/blob/main/src/erc20/ERC20.sol,
/// License-Identifier: AGPL-3.0-only.
abstract contract TridentFranchisedERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 amount);
    event Transfer(address indexed sender, address indexed recipient, uint256 amount);

    string public constant name = ""Sushi Franchised LP Token"";
    string public constant symbol = ""SLP"";
    uint8 public constant decimals = 18;

    address public whiteListManager;
    address public operator;
    bool public level2;

    uint256 public totalSupply;
    /// @notice owner -> balance mapping.
    mapping(address => uint256) public balanceOf;
    /// @notice owner -> spender -> allowance mapping.
    mapping(address => mapping(address => uint256)) public allowance;

    /// @notice The EIP-712 typehash for this contract's {permit} struct.
    bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    /// @notice The EIP-712 typehash for this contract's domain.
    bytes32 public immutable DOMAIN_SEPARATOR;
    /// @notice owner -> nonce mapping used in {permit}.
    mapping(address => uint256) public nonces;

    constructor() {
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                keccak256(bytes(name)),
                keccak256(bytes(""1"")),
                block.chainid,
                address(this)
            )
        );
    }

    /// @dev Initializes whitelist settings from pool.
    function initialize(
        address _whiteListManager,
        address _operator,
        bool _level2
    ) internal {
        whiteListManager = _whiteListManager;
        operator = _operator;
        if (_level2) level2 = true;
    }

    /// @notice Approves `amount` from `msg.sender` to be spent by `spender`.
    /// @param spender Address of the party that can pull tokens from `msg.sender`'s account.
    /// @param amount The maximum collective `amount` that `spender` can pull.
    /// @return (bool) Returns 'true' if succeeded.
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `msg.sender` to `recipient`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transfer(address recipient, uint256 amount) external returns (bool) {
        if (level2) _checkWhiteList(recipient);
        balanceOf[msg.sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `sender` to `recipient`. Caller needs approval from `from`.
    /// @param sender Address to pull tokens `from`.
    /// @param recipient The address to move tokens to.
    /// @param amount The token `amount` to move.
    /// @return (bool) Returns 'true' if succeeded.
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool) {
        if (level2) _checkWhiteList(recipient);
        if (allowance[sender][msg.sender] != type(uint256).max) {
            allowance[sender][msg.sender] -= amount;
        }
        balanceOf[sender] -= amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(sender, recipient, amount);
        return true;
    }

    /// @notice Triggers an approval from `owner` to `spender`.
    /// @param owner The address to approve from.
    /// @param spender The address to be approved.
    /// @param amount The number of tokens that are approved (2^256-1 means infinite).
    /// @param deadline The time at which to expire the signature.
    /// @param v The recovery byte of the signature.
    /// @param r Half of the ECDSA signature pair.
    /// @param s Half of the ECDSA signature pair.
    function permit(
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");
        bytes32 digest = keccak256(
            abi.encodePacked(""\x19\x01"", DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline)))
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_PERMIT_SIGNATURE"");
        allowance[recoveredAddress][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _mint(address recipient, uint256 amount) internal {
        totalSupply += amount;
        // @dev This is safe from overflow - the sum of all user
        // balances can't exceed 'type(uint256).max'.
        unchecked {
            balanceOf[recipient] += amount;
        }
        emit Transfer(address(0), recipient, amount);
    }

    function _burn(address sender, uint256 amount) internal {
        balanceOf[sender] -= amount;
        // @dev This is safe from underflow - users won't ever
        // have a balance larger than `totalSupply`.
        unchecked {
            totalSupply -= amount;
        }
        emit Transfer(sender, address(0), amount);
    }

    /// @dev Checks `whiteListManager` for pool `operator` and given user `account`.
    function _checkWhiteList(address account) internal view {
        (, bytes memory _whitelisted) = whiteListManager.staticcall(abi.encodeWithSelector(IWhiteListManager.whitelistedAccounts.selector, operator, account));
        bool whitelisted = abi.decode(_whitelisted, (bool));
        require(whitelisted, ""NOT_WHITELISTED"");
    }
}",1487
RealWorld_TA_29_PoolFactory_RealWorld_20240803215255.log,29,PoolFactory,26962,1857,28819,93.0,0.17195,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.2;

import ""../interfaces/IPoolFactory.sol"";

import ""./PoolTemplate.sol"";

/**
 * @author Mudit Gupta
 */
contract PoolFactory is IPoolFactory {
    // Consider deploying via an upgradable proxy to allow upgrading pools in the future

    function deployPool(bytes memory _deployData) external override returns (address) {
        return address(new PoolTemplate(_deployData));
    }
}",101
RealWorld_TA_29_IWhiteListManager_RealWorld_20240803223807.log,29,IWhiteListManager,23388,1472,24860,83.0,0.14638,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident franchised pool whitelist manager interface.
interface IWhiteListManager {
    function whitelistedAccounts(address operator, address account) external returns (bool);
}",58
RealWorld_TA_29_IPool_RealWorld_20240803223142.log,29,IPool,73668,1759,75427,105.0,0.40352,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.5.0;
pragma experimental ABIEncoderV2;

/// @notice Trident pool interface.
interface IPool {
    /// @notice Executes a swap from one token to another.
    /// @dev The input tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return finalAmountOut The amount of output tokens that were sent to the user.
    function swap(bytes calldata data) external returns (uint256 finalAmountOut);

    /// @notice Executes a swap from one token to another with a callback.
    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.
    /// @param data ABI-encoded params that the pool requires.
    /// @return finalAmountOut The amount of output tokens that were sent to the user.
    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);

    /// @notice Mints liquidity tokens.
    /// @dev The input tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return liquidity The amount of liquidity tokens that were minted for the user.
    function mint(bytes calldata data) external returns (uint256 liquidity);

    /// @notice Burns liquidity tokens.
    /// @dev The input LP tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.
    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);

    /// @notice Burns liquidity tokens for a single output token.
    /// @dev The input LP tokens must've already been sent to the pool.
    /// @param data ABI-encoded params that the pool requires.
    /// @return amountOut The amount of output tokens that were sent to the user.
    function burnSingle(bytes calldata data) external returns (uint256 amountOut);

    /// @return A unique identifier for the pool type.
    function poolIdentifier() external pure returns (bytes32);

    /// @return An array of tokens supported by the pool.
    function getAssets() external view returns (address[] memory);

    /// @notice Simulates a trade and returns the expected output.
    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.
    /// @param data ABI-encoded params that the pool requires.
    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.
    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);

    /// @dev This event must be emitted on all swaps.
    event Swap(
        address indexed recipient,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut
    );
    
    /// @dev This struct frames output tokens for burns.
    struct TokenAmount {
        address token;
        uint256 amount;
    }
}",656
RealWorld_TA_29_BentoBoxV1Flat_RealWorld_20240803213700.log,29,BentoBoxV1Flat,994405,872,995277,171.0,4.989465,"// SPDX-License-Identifier: UNLICENSED
// The BentoBox

//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄
//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪
//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·
//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌
//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀

// This contract stores funds, handles their transfers, supports flash loans and strategies.

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to Keno for all his hard work and support

// Version 22-Mar-2021

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable not-rely-on-time
// solhint-disable no-inline-assembly

// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0
// License-Identifier: MIT

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    function decimals() external view returns (uint256);
}

// File contracts/interfaces/IFlashLoan.sol
// License-Identifier: MIT

interface IFlashBorrower {
    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param token The address of the token that is loaned.
    /// @param amount of the `token` that is loaned.
    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.
    /// @param data Additional data that was passed to the flashloan function.
    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external;
}

interface IBatchFlashBorrower {
    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.
    /// @param sender The address of the invoker of this flashloan.
    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.
    /// @param amounts A one-to-one map to `tokens` that is loaned.
    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.
    /// @param data Additional data that was passed to the flashloan function.
    function onBatchFlashLoan(
        address sender,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        uint256[] calldata fees,
        bytes calldata data
    ) external;
}

// File contracts/interfaces/IWETH.sol
// License-Identifier: MIT

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}

// File contracts/interfaces/IStrategy.sol
// License-Identifier: MIT

interface IStrategy {
    /// @notice Send the assets to the Strategy and call skim to invest them.
    /// @param amount The amount of tokens to invest.
    function skim(uint256 amount) external;

    /// @notice Harvest any profits made converted to the asset and pass them to the caller.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);

    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.
    /// @dev The `actualAmount` should be very close to the amount.
    /// The difference should NOT be used to report a loss. That's what harvest is for.
    /// @param amount The requested amount the caller wants to withdraw.
    /// @return actualAmount The real amount that is withdrawn.
    function withdraw(uint256 amount) external returns (uint256 actualAmount);

    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function exit(uint256 balance) external returns (int256 amountAdded);
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0
// License-Identifier: MIT

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0
// License-Identifier: MIT

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0
// License-Identifier: MIT

struct Rebase {
    uint128 elastic;
    uint128 base;
}

/// @notice A rebasing library using overflow-/underflow-safe math.
library RebaseLibrary {
    using BoringMath for uint256;
    using BoringMath128 for uint128;

    /// @notice Calculates the base value in relationship to `elastic` and `total`.
    function toBase(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (uint256 base) {
        if (total.elastic == 0) {
            base = elastic;
        } else {
            base = elastic.mul(total.base) / total.elastic;
            if (roundUp && base.mul(total.elastic) / total.base < elastic) {
                base = base.add(1);
            }
        }
    }

    /// @notice Calculates the elastic value in relationship to `base` and `total`.
    function toElastic(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (uint256 elastic) {
        if (total.base == 0) {
            elastic = base;
        } else {
            elastic = base.mul(total.elastic) / total.base;
            if (roundUp && elastic.mul(total.base) / total.elastic < base) {
                elastic = elastic.add(1);
            }
        }
    }

    /// @notice Add `elastic` to `total` and doubles `total.base`.
    /// @return (Rebase) The new total.
    /// @return base in relationship to `elastic`.
    function add(
        Rebase memory total,
        uint256 elastic,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 base) {
        base = toBase(total, elastic, roundUp);
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return (total, base);
    }

    /// @notice Sub `base` from `total` and update `total.elastic`.
    /// @return (Rebase) The new total.
    /// @return elastic in relationship to `base`.
    function sub(
        Rebase memory total,
        uint256 base,
        bool roundUp
    ) internal pure returns (Rebase memory, uint256 elastic) {
        elastic = toElastic(total, base, roundUp);
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return (total, elastic);
    }

    /// @notice Add `elastic` and `base` to `total`.
    function add(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.add(elastic.to128());
        total.base = total.base.add(base.to128());
        return total;
    }

    /// @notice Subtract `elastic` and `base` to `total`.
    function sub(
        Rebase memory total,
        uint256 elastic,
        uint256 base
    ) internal pure returns (Rebase memory) {
        total.elastic = total.elastic.sub(elastic.to128());
        total.base = total.base.sub(base.to128());
        return total;
    }

    /// @notice Add `elastic` to `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.add(elastic.to128());
    }

    /// @notice Subtract `elastic` from `total` and update storage.
    /// @return newElastic Returns updated `elastic`.
    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {
        newElastic = total.elastic = total.elastic.sub(elastic.to128());
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0
// License-Identifier: MIT

// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}

// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0
// License-Identifier: MIT

interface IMasterContract {
    /// @notice Init function that gets called from `BoringFactory.deploy`.
    /// Also kown as the constructor for cloned contracts.
    /// Any ETH send to `BoringFactory.deploy` ends up here.
    /// @param data Can be abi encoded arguments or anything else.
    function init(bytes calldata data) external payable;
}

// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0
// License-Identifier: MIT

contract BoringFactory {
    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);

    /// @notice Mapping from clone contracts to their masterContract.
    mapping(address => address) public masterContractOf;

    /// @notice Deploys a given master Contract as a clone.
    /// Any ETH transferred with this call is forwarded to the new clone.
    /// Emits `LogDeploy`.
    /// @param masterContract The address of the contract to clone.
    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.
    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.
    /// @return cloneAddress Address of the created clone contract.
    function deploy(
        address masterContract,
        bytes calldata data,
        bool useCreate2
    ) public payable returns (address cloneAddress) {
        require(masterContract != address(0), ""BoringFactory: No masterContract"");
        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address

        if (useCreate2) {
            // each masterContract has different code already. So clones are distinguished by their data only.
            bytes32 salt = keccak256(data);

            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create2(0, clone, 0x37, salt)
            }
        } else {
            assembly {
                let clone := mload(0x40)
                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
                mstore(add(clone, 0x14), targetBytes)
                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
                cloneAddress := create(0, clone, 0x37)
            }
        }
        masterContractOf[cloneAddress] = masterContract;

        IMasterContract(cloneAddress).init{value: msg.value}(data);

        emit LogDeploy(masterContract, data, cloneAddress);
    }
}

// File contracts/MasterContractManager.sol
// License-Identifier: UNLICENSED

contract MasterContractManager is BoringOwnable, BoringFactory {
    event LogWhiteListMasterContract(address indexed masterContract, bool approved);
    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);
    event LogRegisterProtocol(address indexed protocol);

    /// @notice masterContract to user to approval state
    mapping(address => mapping(address => bool)) public masterContractApproved;
    /// @notice masterContract to whitelisted state for approval without signed message
    mapping(address => bool) public whitelistedMasterContracts;
    /// @notice user nonces for masterContract approvals
    mapping(address => uint256) public nonces;

    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");
    // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";
    bytes32 private constant APPROVAL_SIGNATURE_HASH =
        keccak256(""SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)"");

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DOMAIN_SEPARATOR;
    // solhint-disable-next-line var-name-mixedcase
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    constructor() public {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
    }

    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(""BentoBox V1""), chainId, address(this)));
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.
    function registerProtocol() public {
        masterContractOf[msg.sender] = msg.sender;
        emit LogRegisterProtocol(msg.sender);
    }

    /// @notice Enables or disables a contract for approval without signed message.
    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: Cannot approve 0"");

        // Effects
        whitelistedMasterContracts[masterContract] = approved;
        emit LogWhiteListMasterContract(masterContract, approved);
    }

    /// @notice Approves or revokes a `masterContract` access to `user` funds.
    /// @param user The address of the user that approves or revokes access.
    /// @param masterContract The address who gains or loses access.
    /// @param approved If True approves access. If False revokes access.
    /// @param v Part of the signature. (See EIP-191)
    /// @param r Part of the signature. (See EIP-191)
    /// @param s Part of the signature. (See EIP-191)
    // F4 - Check behaviour for all function arguments when wrong or extreme
    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.
    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails
    function setMasterContractApproval(
        address user,
        address masterContract,
        bool approved,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        // Checks
        require(masterContract != address(0), ""MasterCMgr: masterC not set""); // Important for security

        // If no signature is provided, the fallback is executed
        if (r == 0 && s == 0 && v == 0) {
            require(user == msg.sender, ""MasterCMgr: user not sender"");
            require(masterContractOf[user] == address(0), ""MasterCMgr: user is clone"");
            require(whitelistedMasterContracts[masterContract], ""MasterCMgr: not whitelisted"");
        } else {
            // Important for security - any address without masterContract has address(0) as masterContract
            // So approving address(0) would approve every address, leading to full loss of funds
            // Also, ecrecover returns address(0) on failure. So we check this:
            require(user != address(0), ""MasterCMgr: User cannot be 0"");

            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)
            // C10: nonce + chainId are used to prevent replays
            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)
            // C11: signature is EIP-712 compliant
            // C12 - abi.encodePacked can't contain variable length user input (SWC-133)
            // C12: abi.encodePacked has fixed length parameters
            bytes32 digest = keccak256(
                abi.encodePacked(
                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                    DOMAIN_SEPARATOR(),
                    keccak256(
                        abi.encode(
                            APPROVAL_SIGNATURE_HASH,
                            approved ? keccak256(""Give FULL access to funds in (and approved to) BentoBox?"") : keccak256(""Revoke access to BentoBox?""),
                            user,
                            masterContract,
                            approved,
                            nonces[user]++
                        )
                    )
                )
            );
            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress == user, ""MasterCMgr: Invalid Signature"");
        }

        // Effects
        masterContractApproved[masterContract][user] = approved;
        emit LogSetMasterContractApproval(masterContract, user, approved);
    }
}

// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0
// License-Identifier: MIT

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}

// File contracts/BentoBox.sol
// License-Identifier: UNLICENSED

/// @title BentoBox
/// @author BoringCrypto, Keno
/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.
/// Yield from this will go to the token depositors.
/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.
/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.
contract BentoBoxV1 is MasterContractManager, BoringBatchable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;
    using RebaseLibrary for Rebase;

    // ************** //
    // *** EVENTS *** //
    // ************** //

    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);
    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);

    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);

    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);
    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);
    event LogStrategyInvest(IERC20 indexed token, uint256 amount);
    event LogStrategyDivest(IERC20 indexed token, uint256 amount);
    event LogStrategyProfit(IERC20 indexed token, uint256 amount);
    event LogStrategyLoss(IERC20 indexed token, uint256 amount);

    // *************** //
    // *** STRUCTS *** //
    // *************** //

    struct StrategyData {
        uint64 strategyStartDate;
        uint64 targetPercentage;
        uint128 balance; // the balance of the strategy that BentoBox thinks is in there
    }

    // ******************************** //
    // *** CONSTANTS AND IMMUTABLES *** //
    // ******************************** //

    // V2 - Can they be private?
    // V2: Private to save gas, to verify it's correct, check the constructor arguments
    IERC20 private immutable wethToken;

    IERC20 private constant USE_ETHEREUM = IERC20(0);
    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%
    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;
    uint256 private constant STRATEGY_DELAY = 0 weeks;
    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%
    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off

    // ***************** //
    // *** VARIABLES *** //
    // ***************** //

    // Balance per token per address/contract in shares
    mapping(IERC20 => mapping(address => uint256)) public balanceOf;

    // Rebase from amount to share
    mapping(IERC20 => Rebase) public totals;

    mapping(IERC20 => IStrategy) public strategy;
    mapping(IERC20 => IStrategy) public pendingStrategy;
    mapping(IERC20 => StrategyData) public strategyData;

    // ******************* //
    // *** CONSTRUCTOR *** //
    // ******************* //

    constructor(IERC20 wethToken_) public {
        wethToken = wethToken_;
    }

    // ***************** //
    // *** MODIFIERS *** //
    // ***************** //

    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.
    /// If 'from' is msg.sender, it's allowed.
    /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances
    /// can be taken by anyone.
    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.
    /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.
    modifier allowed(address from) {
        if (from != msg.sender && from != address(this)) {
            // From is sender or you are skimming
            address masterContract = masterContractOf[msg.sender];
            require(masterContract != address(0), ""BentoBox: no masterContract"");
            require(masterContractApproved[masterContract][from], ""BentoBox: Transfer not approved"");
        }
        _;
    }

    // ************************** //
    // *** INTERNAL FUNCTIONS *** //
    // ************************** //

    /// @dev Returns the total balance of `token` this contracts holds,
    /// plus the total amount this contract thinks the strategy holds.
    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {
        amount = token.balanceOf(address(this)).add(strategyData[token].balance);
    }

    // ************************ //
    // *** PUBLIC FUNCTIONS *** //
    // ************************ //

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        IERC20 token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share) {
        share = totals[token].toBase(amount, roundUp);
    }

    /// @dev Helper function represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        IERC20 token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount) {
        amount = totals[token].toElastic(share, roundUp);
    }

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];

        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.
        require(total.elastic != 0 || token.totalSupply() > 0, ""BentoBox: No tokens"");
        if (share == 0) {
            // value of the share may be lower than the amount due to rounding, that's ok
            share = total.toBase(amount, false);
            // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)
            if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {
                return (0, 0);
            }
        } else {
            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)
            amount = total.toElastic(share, true);
        }

        // In case of skimming, check that only the skimmable amount is taken.
        // For ETH, the full balance is available, so no need to check.
        // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.
        require(from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic), ""BentoBox: Skim too much"");

        balanceOf[token][to] = balanceOf[token][to].add(share);
        total.base = total.base.add(share.to128());
        total.elastic = total.elastic.add(amount.to128());
        totals[token] = total;

        // Interactions
        // During the first deposit, we check that this token is 'real'
        if (token_ == USE_ETHEREUM) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)
            IWETH(address(wethToken)).deposit{value: amount}();
        } else if (from != address(this)) {
            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)
            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.
            token.safeTransferFrom(from, address(this), amount);
        }
        emit LogDeposit(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        IERC20 token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;
        Rebase memory total = totals[token];
        if (share == 0) {
            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)
            share = total.toBase(amount, true);
        } else {
            // amount may be lower than the value of share due to rounding, that's ok
            amount = total.toElastic(share, false);
        }

        balanceOf[token][from] = balanceOf[token][from].sub(share);
        total.elastic = total.elastic.sub(amount.to128());
        total.base = total.base.sub(share.to128());
        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)
        require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, ""BentoBox: cannot empty"");
        totals[token] = total;

        // Interactions
        if (token_ == USE_ETHEREUM) {
            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.
            IWETH(address(wethToken)).withdraw(amount);
            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.
            (bool success, ) = to.call{value: amount}("""");
            require(success, ""BentoBox: ETH transfer failed"");
        } else {
            // X2, X3: A malicious token could block withdrawal of just THAT token.
            //         masterContracts may want to take care not to rely on withdraw always succeeding.
            token.safeTransfer(to, amount);
        }
        emit LogWithdraw(token, from, to, amount, share);
        amountOut = amount;
        shareOut = share;
    }

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    // Clones of master contracts can transfer from any account that has approved them
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transferMultiple for gas optimization
    function transfer(
        IERC20 token,
        address from,
        address to,
        uint256 share
    ) public allowed(from) {
        // Checks
        require(to != address(0), ""BentoBox: to not set""); // To avoid a bad UI from burning funds

        // Effects
        balanceOf[token][from] = balanceOf[token][from].sub(share);
        balanceOf[token][to] = balanceOf[token][to].add(share);

        emit LogTransfer(token, from, to, share);
    }

    /// @notice Transfer shares from a user account to multiple other ones.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param tos The receivers of the tokens.
    /// @param shares The amount of `token` in shares for each receiver in `tos`.
    // F3 - Can it be combined with another similar function?
    // F3: This isn't combined with transfer for gas optimization
    function transferMultiple(
        IERC20 token,
        address from,
        address[] calldata tos,
        uint256[] calldata shares
    ) public allowed(from) {
        // Checks
        require(tos[0] != address(0), ""BentoBox: to[0] not set""); // To avoid a bad UI from burning funds

        // Effects
        uint256 totalAmount;
        uint256 len = tos.length;
        for (uint256 i = 0; i < len; i++) {
            address to = tos[i];
            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);
            totalAmount = totalAmount.add(shares[i]);
            emit LogTransfer(token, from, to, shares[i]);
        }
        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);
    }

    /// @notice Flashloan ability.
    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.
    /// @param receiver Address of the token receiver.
    /// @param token The address of the token to receive.
    /// @param amount of the tokens to receive.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function flashLoan(
        IFlashBorrower borrower,
        address receiver,
        IERC20 token,
        uint256 amount,
        bytes calldata data
    ) public {
        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;
        token.safeTransfer(receiver, amount);

        borrower.onFlashLoan(msg.sender, token, amount, fee, data);

        require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), ""BentoBox: Wrong amount"");
        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);
    }

    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.
    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.
    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.
    /// @param tokens The addresses of the tokens.
    /// @param amounts of the tokens for each receiver.
    /// @param data The calldata to pass to the `borrower` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Not possible to follow this here, reentrancy has been reviewed
    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)
    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.
    function batchFlashLoan(
        IBatchFlashBorrower borrower,
        address[] calldata receivers,
        IERC20[] calldata tokens,
        uint256[] calldata amounts,
        bytes calldata data
    ) public {
        uint256[] memory fees = new uint256[](tokens.length);

        uint256 len = tokens.length;
        for (uint256 i = 0; i < len; i++) {
            uint256 amount = amounts[i];
            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;

            tokens[i].safeTransfer(receivers[i], amounts[i]);
        }

        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);

        for (uint256 i = 0; i < len; i++) {
            IERC20 token = tokens[i];
            require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), ""BentoBox: Wrong amount"");
            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);
        }
    }

    /// @notice Sets the target percentage of the strategy for `token`.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.
    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {
        // Checks
        require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, ""StrategyManager: Target too high"");

        // Effects
        strategyData[token].targetPercentage = targetPercentage_;
        emit LogStrategyTargetPercentage(token, targetPercentage_);
    }

    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.
    /// Must be called twice with the same arguments.
    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.
    /// @dev Only the owner of this contract is allowed to change this.
    /// @param token The address of the token that maps to a strategy to change.
    /// @param newStrategy The address of the contract that conforms to `IStrategy`.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // C4 - Use block.timestamp only for long intervals (SWC-116)
    // C4: block.timestamp is used for a period of 2 weeks, which is long enough
    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {
        StrategyData memory data = strategyData[token];
        IStrategy pending = pendingStrategy[token];
        if (data.strategyStartDate == 0 || pending != newStrategy) {
            pendingStrategy[token] = newStrategy;
            // C1 - All math done through BoringMath (SWC-101)
            // C1: Our sun will swallow the earth well before this overflows
            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();
            emit LogStrategyQueued(token, newStrategy);
        } else {
            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, ""StrategyManager: Too early"");
            if (address(strategy[token]) != address(0)) {
                int256 balanceChange = strategy[token].exit(data.balance);
                // Effects
                if (balanceChange > 0) {
                    uint256 add = uint256(balanceChange);
                    totals[token].addElastic(add);
                    emit LogStrategyProfit(token, add);
                } else if (balanceChange < 0) {
                    uint256 sub = uint256(-balanceChange);
                    totals[token].subElastic(sub);
                    emit LogStrategyLoss(token, sub);
                }

                emit LogStrategyDivest(token, data.balance);
            }
            strategy[token] = pending;
            data.strategyStartDate = 0;
            data.balance = 0;
            pendingStrategy[token] = IStrategy(0);
            emit LogStrategySet(token, newStrategy);
        }
        strategyData[token] = data;
    }

    /// @notice The actual process of yield farming. Executes the strategy of `token`.
    /// Optionally does housekeeping if `balance` is true.
    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.
    /// @param token The address of the token for which a strategy is deployed.
    /// @param balance True if housekeeping should be done.
    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.
    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)
    // F5: Total amount is updated AFTER interaction. But strategy is under our control.
    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?
    function harvest(
        IERC20 token,
        bool balance,
        uint256 maxChangeAmount
    ) public {
        StrategyData memory data = strategyData[token];
        IStrategy _strategy = strategy[token];
        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);
        if (balanceChange == 0 && !balance) {
            return;
        }

        uint256 totalElastic = totals[token].elastic;

        if (balanceChange > 0) {
            uint256 add = uint256(balanceChange);
            totalElastic = totalElastic.add(add);
            totals[token].elastic = totalElastic.to128();
            emit LogStrategyProfit(token, add);
        } else if (balanceChange < 0) {
            // C1 - All math done through BoringMath (SWC-101)
            // C1: balanceChange could overflow if it's max negative int128.
            // But tokens with balances that large are not supported by the BentoBox.
            uint256 sub = uint256(-balanceChange);
            totalElastic = totalElastic.sub(sub);
            totals[token].elastic = totalElastic.to128();
            data.balance = data.balance.sub(sub.to128());
            emit LogStrategyLoss(token, sub);
        }

        if (balance) {
            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;
            // if data.balance == targetBalance there is nothing to update
            if (data.balance < targetBalance) {
                uint256 amountOut = targetBalance.sub(data.balance);
                if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {
                    amountOut = maxChangeAmount;
                }
                token.safeTransfer(address(_strategy), amountOut);
                data.balance = data.balance.add(amountOut.to128());
                _strategy.skim(amountOut);
                emit LogStrategyInvest(token, amountOut);
            } else if (data.balance > targetBalance) {
                uint256 amountIn = data.balance.sub(targetBalance.to128());
                if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {
                    amountIn = maxChangeAmount;
                }

                uint256 actualAmountIn = _strategy.withdraw(amountIn);

                data.balance = data.balance.sub(actualAmountIn.to128());
                emit LogStrategyDivest(token, actualAmountIn);
            }
        }

        strategyData[token] = data;
    }

    // Contract should be able to receive ETH deposits to support deposit & skim
    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}
}",11876
RealWorld_TA_29_ConstantProductPoolFactory_RealWorld_20240803215930.log,29,ConstantProductPoolFactory,43159,2381,45540,98.0,0.263415,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""./ConstantProductPool.sol"";
import ""./PoolDeployer.sol"";

/// @notice Contract for deploying Trident exchange Constant Product Pool with configurations.
/// @author Mudit Gupta.
contract ConstantProductPoolFactory is PoolDeployer {
    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}

    function deployPool(bytes memory _deployData) external returns (address pool) {
        (address tokenA, address tokenB, uint256 swapFee, bool twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));
        if (tokenA > tokenB) {
            (tokenA, tokenB) = (tokenB, tokenA);
            _deployData = abi.encode(tokenA, tokenB, swapFee, twapSupport);
        }
        address[] memory tokens = new address[](2);
        tokens[0] = tokenA;
        tokens[1] = tokenB;

        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.
        bytes32 salt = keccak256(_deployData);
        pool = address(new ConstantProductPool{salt: salt}(_deployData, masterDeployer));
        _registerPool(pool, tokens, salt);
    }
}",287
RealWorld_TA_29_TridentOwnable_RealWorld_20240803214754.log,29,TridentOwnable,47673,1646,49319,84.0,0.271285,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident access control contract.
/// @author Adapted from https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringOwnable.sol, License-Identifier: MIT.
contract TridentOwnable {
    address public owner;
    address public pendingOwner;

    event TransferOwner(address indexed sender, address indexed recipient);
    event TransferOwnerClaim(address indexed sender, address indexed recipient);

    /// @notice Initialize and grant deployer account (`msg.sender`) `owner` access role.
    constructor() {
        owner = msg.sender;
        emit TransferOwner(address(0), msg.sender);
    }

    /// @notice Access control modifier that requires modified function to be called by `owner` account.
    modifier onlyOwner() {
        require(msg.sender == owner, ""NOT_OWNER"");
        _;
    }

    /// @notice `pendingOwner` can claim `owner` account.
    function claimOwner() external {
        require(msg.sender == pendingOwner, ""NOT_PENDING_OWNER"");
        emit TransferOwner(owner, msg.sender);
        owner = msg.sender;
        pendingOwner = address(0);
    }

    /// @notice Transfer `owner` account.
    /// @param recipient Account granted `owner` access control.
    /// @param direct If 'true', ownership is directly transferred.
    function transferOwner(address recipient, bool direct) external onlyOwner {
        if (direct) {
            owner = recipient;
            emit TransferOwner(msg.sender, recipient);
        } else {
            pendingOwner = recipient;
            emit TransferOwnerClaim(msg.sender, recipient);
        }
    }
}",345
RealWorld_TA_29_ConstantProductPool_RealWorld_20240803220111.log,29,ConstantProductPool,382842,6092,388934,192.0,2.03605,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

import ""../interfaces/IMasterDeployer.sol"";
import ""../workInProgress/IMigrator.sol"";
import ""../interfaces/IPool.sol"";
import ""../interfaces/ITridentCallee.sol"";
import ""../libraries/TridentMath.sol"";
import ""./TridentERC20.sol"";

/// @notice Trident exchange pool template with constant product formula for swapping between an ERC-20 token pair.
/// @dev The reserves are stored as bento shares.
///      The curve is applied to shares as well. This pool does not care about the underlying amounts.
contract ConstantProductPool is IPool, TridentERC20 {
    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);
    event Sync(uint256 reserve0, uint256 reserve1);

    uint256 internal constant MINIMUM_LIQUIDITY = 1000;

    uint8 internal constant PRECISION = 112;
    uint256 internal constant MAX_FEE = 10000; // @dev 100%.
    uint256 internal constant MAX_FEE_SQUARE = 100000000;
    uint256 internal constant E18 = uint256(10)**18;
    uint256 public immutable swapFee;
    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;

    address public immutable barFeeTo;
    address public immutable bento;
    address public immutable masterDeployer;
    address public immutable token0;
    address public immutable token1;

    uint256 public barFee;
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast;

    uint112 internal reserve0;
    uint112 internal reserve1;
    uint32 internal blockTimestampLast;

    bytes32 public constant override poolIdentifier = ""Trident:ConstantProduct"";

    uint256 internal unlocked;
    modifier lock() {
        require(unlocked == 1, ""LOCKED"");
        unlocked = 2;
        _;
        unlocked = 1;
    }

    constructor(bytes memory _deployData, address _masterDeployer) {
        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));

        // NB Factory ensures that the tokens are sorted
        require(_token0 != address(0), ""ZERO_ADDRESS"");
        require(_token0 != _token1, ""IDENTICAL_ADDRESSES"");
        require(_token0 != address(this), ""INVALID_TOKEN"");
        require(_token1 != address(this), ""INVALID_TOKEN"");
        require(_swapFee <= MAX_FEE, ""INVALID_SWAP_FEE"");

        (, bytes memory _barFee) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        (, bytes memory _barFeeTo) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFeeTo.selector));
        (, bytes memory _bento) = _masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.bento.selector));

        token0 = _token0;
        token1 = _token1;
        swapFee = _swapFee;
        // @dev This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.
        unchecked {
            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;
        }
        barFee = abi.decode(_barFee, (uint256));
        barFeeTo = abi.decode(_barFeeTo, (address));
        bento = abi.decode(_bento, (address));
        masterDeployer = _masterDeployer;
        unlocked = 1;
        if (_twapSupport) blockTimestampLast = 1;
    }

    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.
    /// The router must ensure that sufficient LP tokens are minted by using the return value.
    function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        address recipient = abi.decode(data, (address));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
        uint256 computed = TridentMath.sqrt((balance0 - fee0) * (balance1 - fee1));

        if (_totalSupply == 0) {
            require(amount0 > 0 && amount1 > 0, ""INVALID_AMOUNTS"");
            _mint(address(0), MINIMUM_LIQUIDITY);
            address migrator = IMasterDeployer(masterDeployer).migrator();
            if (msg.sender == migrator) {
                liquidity = IMigrator(migrator).desiredLiquidity();
                require(liquidity != 0 && liquidity != type(uint256).max, ""BAD_DESIRED_LIQUIDITY"");
            } else {
                require(migrator == address(0), ""ONLY_MIGRATOR"");
                liquidity = computed - MINIMUM_LIQUIDITY;
            }
        } else {
            uint256 k = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            liquidity = ((computed - k) * _totalSupply) / k;
        }
        require(liquidity != 0, ""INSUFFICIENT_LIQUIDITY_MINTED"");
        _mint(recipient, liquidity);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);
        emit Mint(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.
    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {
        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        _transfer(token0, amount0, recipient, unwrapBento);
        _transfer(token1, amount1, recipient, unwrapBento);
        // @dev This is safe from underflow - amounts are lesser figures derived from balances.
        unchecked {
            balance0 -= amount0;
            balance1 -= amount1;
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);

        withdrawnAmounts = new TokenAmount[](2);
        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});
        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another
    /// - i.e., the user gets a single token out by burning LP tokens.
    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 _totalSupply = totalSupply;
        uint256 liquidity = balanceOf[address(this)];

        unchecked {
            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
        }

        uint256 amount0 = (liquidity * balance0) / _totalSupply;
        uint256 amount1 = (liquidity * balance1) / _totalSupply;

        _burn(address(this), liquidity);
        unchecked {
            if (tokenOut == token1) {
                // @dev Swap `token0` for `token1`
                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.
                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);
                _transfer(token1, amount1, recipient, unwrapBento);
                balance1 -= amount1;
                amountOut = amount1;
                amount0 = 0;
            } else {
                // @dev Swap `token1` for `token0`.
                require(tokenOut == token0, ""INVALID_OUTPUT_TOKEN"");
                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);
                _transfer(token0, amount0, recipient, unwrapBento);
                balance0 -= amount0;
                amountOut = amount0;
                amount1 = 0;
            }
        }
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        kLast = TridentMath.sqrt(balance0 * balance1);
        emit Burn(msg.sender, amount0, amount1, recipient);
    }

    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.
    function swap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        require(_reserve0 > 0, ""POOL_UNINITIALIZED"");
        (uint256 balance0, uint256 balance1) = _balance();
        uint256 amountIn;
        address tokenOut;
        unchecked {
            if (tokenIn == token0) {
                tokenOut = token1;
                amountIn = balance0 - _reserve0;
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                balance1 -= amountOut;
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                tokenOut = token0;
                amountIn = balance1 - reserve1;
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                balance0 -= amountOut;
            }
        }
        _transfer(tokenOut, amountOut, recipient, unwrapBento);
        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);
    }

    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.
    function flashSwap(bytes calldata data) public override lock returns (uint256 amountOut) {
        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(
            data,
            (address, address, bool, uint256, bytes)
        );
        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();
        require(_reserve0 > 0, ""POOL_UNINITIALIZED"");
        unchecked {
            if (tokenIn == token0) {
                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
                _transfer(token1, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance0 - _reserve0 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);
            } else {
                require(tokenIn == token1, ""INVALID_INPUT_TOKEN"");
                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
                _transfer(token0, amountOut, recipient, unwrapBento);
                ITridentCallee(msg.sender).tridentSwapCallback(context);
                (uint256 balance0, uint256 balance1) = _balance();
                require(balance1 - _reserve1 >= amountIn, ""INSUFFICIENT_AMOUNT_IN"");
                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);
                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);
            }
        }
    }

    /// @dev Updates `barFee` for Trident protocol.
    function updateBarFee() public {
        (, bytes memory _barFee) = masterDeployer.staticcall(abi.encodeWithSelector(IMasterDeployer.barFee.selector));
        barFee = abi.decode(_barFee, (uint256));
    }

    function _getReserves()
        internal
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _balance() internal view returns (uint256 balance0, uint256 balance1) {
        // @dev balanceOf(address,address).
        (, bytes memory _balance0) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token0, address(this)));
        balance0 = abi.decode(_balance0, (uint256));
        // @dev balanceOf(address,address).
        (, bytes memory _balance1) = bento.staticcall(abi.encodeWithSelector(0xf7888aec, token1, address(this)));
        balance1 = abi.decode(_balance1, (uint256));
    }

    function _update(
        uint256 balance0,
        uint256 balance1,
        uint112 _reserve0,
        uint112 _reserve1,
        uint32 _blockTimestampLast
    ) internal {
        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, ""OVERFLOW"");
        if (blockTimestampLast == 0) {
            // @dev TWAP support is disabled for gas efficiency.
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
        } else {
            uint32 blockTimestamp = uint32(block.timestamp % 2**32);
            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {
                unchecked {
                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;
                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;
                    price0CumulativeLast += price0 * timeElapsed;
                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;
                    price1CumulativeLast += price1 * timeElapsed;
                }
            }
            reserve0 = uint112(balance0);
            reserve1 = uint112(balance1);
            blockTimestampLast = blockTimestamp;
        }
        emit Sync(balance0, balance1);
    }

    function _mintFee(
        uint112 _reserve0,
        uint112 _reserve1,
        uint256 _totalSupply
    ) internal returns (uint256 liquidity) {
        uint256 _kLast = kLast;
        if (_kLast != 0) {
            uint256 computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            if (computed > _kLast) {
                // @dev `barFee` % of increase in liquidity.
                // It's going to be slightly less than `barFee` % in reality due to the math.
                liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;
                if (liquidity != 0) {
                    _mint(barFeeTo, liquidity);
                }
            }
        }
    }

    function _getAmountOut(
        uint256 amountIn,
        uint256 reserveAmountIn,
        uint256 reserveAmountOut
    ) internal view returns (uint256 amountOut) {
        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;
        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);
    }

    function _transfer(
        address token,
        uint256 shares,
        address to,
        bool unwrapBento
    ) internal {
        if (unwrapBento) {
            // @dev withdraw(address,address,address,uint256,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(0x97da6d30, token, address(this), to, 0, shares));
            require(success, ""WITHDRAW_FAILED"");
        } else {
            // @dev transfer(address,address,address,uint256).
            (bool success, ) = bento.call(abi.encodeWithSelector(0xf18d03cc, token, address(this), to, shares));
            require(success, ""TRANSFER_FAILED"");
        }
    }

    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.
    function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }

    function getAssets() public view override returns (address[] memory assets) {
        assets = new address[](2);
        assets[0] = token0;
        assets[1] = token1;
    }

    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {
        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();
        if (tokenIn == token0) {
            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);
        } else {
            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);
        }
    }

    function getReserves()
        public
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        return _getReserves();
    }
}",4326
RealWorld_TA_29_IMigrator_RealWorld_20240803214329.log,29,IMigrator,22963,1159,24122,84.0,0.137995,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

interface IMigrator {
    // Return the desired amount of liquidity token that the migrator wants.
    function desiredLiquidity() external view returns (uint256);
}",58
RealWorld_TA_29_ITridentRouter_RealWorld_20240803223329.log,29,ITridentRouter,41171,1485,42656,94.0,0.235555,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool router interface.
interface ITridentRouter {
    struct Path {
        address pool;
        bytes data;
    }

    struct ExactInputSingleParams {
        uint256 amountIn;
        uint256 amountOutMinimum;
        address pool;
        address tokenIn;
        bytes data;
    }

    struct ExactInputParams {
        address tokenIn;
        uint256 amountIn;
        uint256 amountOutMinimum;
        Path[] path;
    }

    struct TokenInput {
        address token;
        bool native;
        uint256 amount;
    }

    struct InitialPath {
        address tokenIn;
        address pool;
        bool native;
        uint256 amount;
        bytes data;
    }

    struct PercentagePath {
        address tokenIn;
        address pool;
        uint64 balancePercentage; // @dev Multiplied by 10^6. 100% = 100_000_000
        bytes data;
    }

    struct Output {
        address token;
        address to;
        bool unwrapBento;
        uint256 minAmount;
    }

    struct ComplexPathParams {
        InitialPath[] initialPath;
        PercentagePath[] percentagePath;
        Output[] output;
    }
}",268
RealWorld_TA_29_IPoolFactory_RealWorld_20240803223506.log,29,IPoolFactory,22835,1486,24321,83.0,0.143895,"// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.8.0;

/// @notice Trident pool deployment interface.
interface IPoolFactory {
    function deployPool(bytes calldata _deployData) external returns (address pool);
}",54
RealWorld_TA_30_IStablesOracle_RealWorld_20240804002047.log,30,IStablesOracle,24108,1525,25633,96.0,0.15104,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IStablesOracle {
    function getEthereumPrice() external view returns (uint256);
    function getPrices() external view returns (uint256, uint256);
    function getSafeAnswer(address) external view returns (uint256);
}",67
RealWorld_TA_30_MockUniswapPair_RealWorld_20240803234154.log,30,MockUniswapPair,44236,3250,47486,121.0,0.28618,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockUniswapPair is ERC20 {
    using SafeERC20 for IERC20;

    address public immutable token0;
    address public immutable token1;

    constructor(
        address _token0,
        address _token1
    )
        public
        ERC20(""Uniswap Pair"", ""UNI-V2"")
    {
        token0 = _token0;
        token1 = _token1;
    }

    function addLiquidity(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _amountOut
    )
        external
    {
        IERC20(token0).safeTransferFrom(msg.sender, address(this), _amount0);
        IERC20(token1).safeTransferFrom(msg.sender, address(this), _amount1);
        _mint(msg.sender, _amountOut);
    }

    function getReserves()
        external
        view
        returns (uint112, uint112, uint32)
    {
        return (
            uint112(IERC20(token0).balanceOf(address(this))),
            uint112(IERC20(token1).balanceOf(address(this))),
            uint32(block.timestamp)
        );
    }
}",310
RealWorld_TA_30_IVoteProxy_RealWorld_20240804004025.log,30,IVoteProxy,23362,1154,24516,86.0,0.13989,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IVoteProxy {
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address _voter) external view returns (uint256);
}",61
RealWorld_TA_30_MockzpaToken_RealWorld_20240803231140.log,30,MockzpaToken,78442,5012,83454,123.0,0.49245,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/Stabilize.sol"";

contract MockzpaToken is ERC20, IZPAToken {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address constant DEAD = 0x000000000000000000000000000000000000dEaD;
    uint256 constant divisionFactor = 100000;

    address public override underlyingAsset;
    uint256 public override initialFee = 1000; // 1000 = 1%, 100000 = 100%, max fee restricted in contract is 10%
    uint256 public override endFee = 100; // 100 = 0.1%
    uint256 public override feeDuration = 604800; // The amount of seconds it takes from the initial to end fee

    // Info of each user.
    struct UserInfo {
        uint256 depositTime; // The time the user made a deposit, every deposit resets the time
    }

    mapping(address => UserInfo) private userInfo;

    constructor(
        string memory _name,
        string memory _symbol,
        address _underlyingAsset
    )
        public
        ERC20(_name, _symbol)
    {
        underlyingAsset = _underlyingAsset;
    }

    function deposit(uint256 _amount) external override {
        uint256 _toMint = _amount.mul(1e18).div(pricePerToken());
        IERC20(underlyingAsset).safeTransferFrom(msg.sender, address(this), _amount);
        _mint(msg.sender, _toMint);
        userInfo[_msgSender()].depositTime = block.timestamp; // Update the deposit time
    }

    function redeem(uint256 _amount) external override {
        uint256 _underlyingAmount = _amount.mul(pricePerToken()).div(1e18);
        _burn(msg.sender, _amount);

        // Pay fee upon withdrawing
        if (userInfo[_msgSender()].depositTime == 0) {
            // The user has never deposited here
            userInfo[_msgSender()].depositTime = block.timestamp; // Give them the max fee
        }

        uint256 feeSubtraction = initialFee.sub(endFee).mul(block.timestamp.sub(userInfo[_msgSender()].depositTime)).div(feeDuration);
        if (feeSubtraction > initialFee.sub(endFee)) {
            // Cannot reduce fee more than this
            feeSubtraction = initialFee.sub(endFee);
        }
        uint256 fee = initialFee.sub(feeSubtraction);
        fee = _underlyingAmount.mul(fee).div(divisionFactor);
        _underlyingAmount = _underlyingAmount.sub(fee);

        // Now withdraw this amount to the user and send fee to treasury
        IERC20(underlyingAsset).safeTransfer(msg.sender, _underlyingAmount);
        IERC20(underlyingAsset).safeTransfer(DEAD, fee);
    }

    function pricePerToken() public view override returns (uint256) {
        return 2e18;
    }
}",699
RealWorld_TA_30_YearnV2_RealWorld_20240804010947.log,30,YearnV2,25535,1243,26778,82.0,0.152535,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface IYearnV2Vault {
    function deposit(uint256 amount) external returns (uint256);
    function deposit() external returns (uint256);
    function withdraw(uint256 shares) external;
    function withdraw() external;
    function pricePerShare() external view returns (uint256);
    function token() external view returns (address);
}",86
RealWorld_TA_30_PickleJar_RealWorld_20240804010522.log,30,PickleJar,27002,2271,29273,92.0,0.18043,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface PickleJar {
    function balanceOf(address account) external view returns (uint);
    function balance() external view returns (uint);
    function available() external view returns (uint);
    function depositAll() external;
    function deposit(uint _amount) external;
    function withdrawAll() external;
    function withdraw(uint _shares) external;
    function getRatio() external view returns (uint);
}",98
RealWorld_TA_30_LinkERC20_RealWorld_20240804004910.log,30,LinkERC20,44754,2047,46801,87.0,0.26471,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

abstract contract LinkERC20 is ERC20 {
  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {IERC20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseApproval(address spender, uint256 addedValue) public virtual returns (bool) {
    return super.increaseAllowance(spender, addedValue);
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {IERC20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseApproval(address spender, uint256 subtractedValue) public virtual returns (bool) {
    return super.decreaseAllowance(spender, subtractedValue);
  }
}",317
RealWorld_TA_30_MockdYdXSoloMargin_RealWorld_20240803231946.log,30,MockdYdXSoloMargin,101436,4000,105436,112.0,0.58718,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/dYdXSoloMargin.sol"";

contract MockdYdXSoloMargin is ISoloMargin {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;
    using SafeMath for uint128;

    // Store balances as (Account => (MarketID => balance))
    mapping(address => mapping(uint256 => uint128)) balances;

    // Mapping of tokens as (MarketID => token)
    mapping(uint256 => address) tokens;

    constructor (uint256[] memory _marketIds, address[] memory _addresses) public {
        require(_marketIds.length == _addresses.length, ""marketIds.length != addresses.length"");
        for (uint256 i = 0; i < _marketIds.length; i++) {
            tokens[_marketIds[i]] = _addresses[i];
        }
    }

    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) public override {
        _verifyInputs(accounts, actions);

        _runActions(
            accounts,
            actions
        );
    }

    function _verifyInputs(
        Account.Info[] memory accounts,
        Actions.ActionArgs[] memory actions
    ) private pure {
        require(actions.length != 0, ""Cannot have zero actions"");
        require(accounts.length != 0, ""Cannot have zero accounts"");

        for (uint256 a = 0; a < accounts.length; a++) {
            for (uint256 b = a + 1; b < accounts.length; b++) {
                require(!Account.equals(accounts[a], accounts[b]), ""Cannot duplicate accounts"");
            }
        }
    }

    function _runActions(
        Account.Info[] memory accounts,
        Actions.ActionArgs[] memory actions
    ) private {
        for (uint256 i = 0; i < actions.length; i++) {
            Actions.ActionArgs memory action = actions[i];
            Actions.ActionType actionType = action.actionType;

            if (actionType == Actions.ActionType.Deposit) {
                _deposit(Actions.parseDepositArgs(accounts, action));
            } else if (actionType == Actions.ActionType.Withdraw) {
                _withdraw(Actions.parseWithdrawArgs(accounts, action));
            }
        }
    }

    function _deposit(
        Actions.DepositArgs memory args
    )
        private
    {
        require(
            args.from == msg.sender || args.from == args.account.owner,
            ""Invalid deposit source""
        );

        // We'll not implement all cases in this mock, for simplicity
        require(args.amount.denomination == Types.AssetDenomination.Wei, ""!Types.AssetDenomination.Wei"");
        IERC20(tokens[args.market]).safeTransferFrom(args.from, address(this), args.amount.value);

        uint128 newBalance = to128(SafeMath.add(balances[args.account.owner][args.market], args.amount.value));
        balances[args.account.owner][args.market] = newBalance;
    }

    function _withdraw(
        Actions.WithdrawArgs memory args
    )
        private
    {
        require(
            msg.sender == args.account.owner,
            ""Not valid operator""
        );
        require(args.amount.value <= balances[args.account.owner][args.market], ""!balance"");
        require(!args.amount.sign, ""should receive negative amount"");
        IERC20(tokens[args.market]).safeTransfer(args.to, args.amount.value);

        uint128 newBalance = to128(SafeMath.sub(balances[args.account.owner][args.market], args.amount.value));
        balances[args.account.owner][args.market] = newBalance;
    }

    function getMarketTokenAddress(uint256 marketId) external override view returns (address) {
        return tokens[marketId];
    }

    function getAccountWei(Account.Info memory account, uint256 marketId)
        external
        override
        view
        returns (Types.Wei memory)
    {
        Types.Wei memory balance = Types.Wei({
            sign: true,
            value: balances[account.owner][marketId]
        });
        return balance;
    }

    function to128(
        uint256 number
    )
        internal
        pure
        returns (uint128)
    {
        uint128 result = uint128(number);
        require(result == number, ""Unsafe cast to uint128"");
        return result;
    }
}",978
RealWorld_TA_30_Stabilize_RealWorld_20240804011111.log,30,Stabilize,34694,1334,36028,82.0,0.20015,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface IZPAToken {
    function deposit(uint256) external;
    function redeem(uint256) external;
    function underlyingAsset() external view returns (address);
    function pricePerToken() external view returns (uint256);

    function initialFee() external view returns (uint256);
    function endFee() external view returns (uint256);
    function feeDuration() external view returns (uint256);
}

interface IZPAPool {
    function deposit(uint256, uint256) external;
    function withdraw(uint256, uint256) external;
    function exit(uint256, uint256) external;
    function getReward(uint256) external;
    function rewardEarned(uint256, address) external view returns (uint256);
    function poolTokenAddress(uint256) external view returns (address);
    function poolBalance(uint256, address) external view returns (uint256);
}",196
RealWorld_TA_30_Yfii_RealWorld_20240804005755.log,30,Yfii,23429,1303,24732,79.0,0.143205,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Yfii {
    function withdraw(uint) external;
    function getReward() external;
    function stake(uint) external;
    function balanceOf(address) external view returns (uint);
    function exit() external;
}",61
RealWorld_TA_30_MockDErc20_RealWorld_20240803232140.log,30,MockDErc20,47517,4346,51863,132.0,0.324505,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockDErc20 is ERC20 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public underlying;

    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {
        underlying = _underlying;
    }

    function getExchangeRate() public pure returns (uint256) {
        return 2e18; // 1 dDAI = 2 DAI
    }

    function getTokenBalance(address _account) external view returns (uint256) {
        return balanceOf(_account).mul(getExchangeRate()).div(1e18);
    }

    function mint(address _account, uint256 _amount) external {
        uint256 _toMint = _amount.mul(1e18).div(getExchangeRate());
        underlying.safeTransferFrom(msg.sender, address(this), _amount);
        _mint(_account, _toMint);
    }

    function redeem(address _account, uint256 _amount) external {
        uint256 _underlyingAmount = _amount.mul(getExchangeRate()).div(1e18);
        _burn(_account, _amount);
        underlying.safeTransfer(msg.sender, _underlyingAmount);
    }
}",339
RealWorld_TA_30_MockERC20_RealWorld_20240803225829.log,30,MockERC20,100750,4056,104806,111.0,0.58487,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

contract MockERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    address private _owner;

    uint internal _totalSupply;

    mapping(address => uint)                   private _balance;
    mapping(address => mapping(address => uint)) private _allowance;

    modifier _onlyOwner_() {
        require(msg.sender == _owner, ""ERR_NOT_OWNER"");
        _;
    }

    event Approval(address indexed src, address indexed dst, uint amt);
    event Transfer(address indexed src, address indexed dst, uint amt);

    // Math
    function add(uint a, uint b) internal pure returns (uint c) {
        require((c = a + b) >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require((c = a - b) <= a);
    }

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals
    ) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _owner = msg.sender;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function _move(address src, address dst, uint amt) internal {
        require(_balance[src] >= amt, ""!bal"");
        _balance[src] = sub(_balance[src], amt);
        _balance[dst] = add(_balance[dst], amt);
        emit Transfer(src, dst, amt);
    }

    function _push(address to, uint amt) internal {
        _move(address(this), to, amt);
    }

    function _pull(address from, uint amt) internal {
        _move(from, address(this), amt);
    }

    function _mint(address dst, uint amt) internal {
        _balance[dst] = add(_balance[dst], amt);
        _totalSupply = add(_totalSupply, amt);
        emit Transfer(address(0), dst, amt);
    }

    function _burn(address dst, uint amt) internal {
        _balance[dst] = sub(_balance[dst], amt);
        _totalSupply = sub(_totalSupply, amt);
        emit Transfer(dst, address(0), amt);
    }

    function allowance(address src, address dst) external view returns (uint) {
        return _allowance[src][dst];
    }

    function balanceOf(address whom) public view returns (uint) {
        return _balance[whom];
    }

    function faucet(uint256 amt) public returns (bool) {
        _mint(msg.sender, amt);
        return true;
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    function approve(address dst, uint amt) external returns (bool) {
        _allowance[msg.sender][dst] = amt;
        emit Approval(msg.sender, dst, amt);
        return true;
    }

    function mint(address dst, uint256 amt) public _onlyOwner_ returns (bool) {
        _mint(dst, amt);
        return true;
    }

    function burn(uint amt) public returns (bool) {
        require(_balance[msg.sender] >= amt, ""!bal"");
        _burn(msg.sender, amt);
        return true;
    }

    function burnFrom(address src, uint amt) public _onlyOwner_ returns (bool) {
        require(_balance[src] >= amt, ""!bal"");
        _burn(src, amt);
        return true;
    }

    function transfer(address dst, uint amt) external returns (bool) {
        _move(msg.sender, dst, amt);
        return true;
    }

    function transferFrom(address src, address dst, uint amt) external returns (bool) {
        require(msg.sender == src || amt <= _allowance[src][msg.sender], ""!spender"");
        _move(src, dst, amt);
        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {
            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);
            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);
        }
        return true;
    }

    function transferOwnership(address newOwner) external _onlyOwner_ {
        _owner = newOwner;
    }
}",955
RealWorld_TA_30_IYaxisBar_RealWorld_20240804004607.log,30,IYaxisBar,22682,1384,24066,85.0,0.14109,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYaxisBar is IERC20 {
    function availableBalance() external view returns (uint256);
}",56
RealWorld_TA_30_VaultToken_RealWorld_20240803234547.log,30,VaultToken,60087,1637,61724,95.0,0.333175,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""../vendor/LinkToken/token/LinkERC20.sol"";
import ""../vendor/LinkToken/ERC677Token.sol"";

/**
 * @notice Vault Token
 * @dev Contract has been copied from:
 * https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/LinkToken.sol
 * with modification made to specify name and symbol, deploys with 0 total supply
 */
contract VaultToken is LinkERC20, ERC677Token {

    constructor(
        string memory _name,
        string memory _symbol
    )
        public
        ERC20(_name, _symbol)
    // solhint-disable-next-line no-empty-blocks
    {}

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount)
        internal
        override
        virtual
        validAddress(recipient)
    {
        super._transfer(sender, recipient, amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount)
        internal
        override
        virtual
        validAddress(spender)
    {
        super._approve(owner, spender, amount);
    }


    // MODIFIERS

    modifier validAddress(address _recipient) {
        require(_recipient != address(this), ""!validAddress"");
        _;
    }
}",496
RealWorld_TA_30_Rewards_RealWorld_20240803224106.log,30,Rewards,158750,3698,162448,127.0,0.86771,"// SPDX-License-Identifier: MIT
// solhint-disable reason-string
// solhint-disable not-rely-on-time
/**
 * This contract has been modified with:
 * - generalized for any reward token, staking token, and duration
 * - upgraded to Solidity 6
 * - support ERC677 transferAndCall
 * <3 Synthetix
 */


/*
   ____            __   __        __   _
  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __
 _\ \ / // // _ \/ __// _ \/ -_)/ __// / \ \ /
/___/ \_, //_//_/\__//_//_/\__/ \__//_/ /_\_\
     /___/

* Synthetix: CurveRewards.sol
*
* Docs: https://docs.synthetix.io/
*
*
* MIT License
* ===========
*
* Copyright (c) 2020 Synthetix
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the ""Software""), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*/

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/Math.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../vendor/LinkToken/token/ERC677Receiver.sol"";

abstract contract IRewardDistributionRecipient is Ownable {
    address public rewardDistribution;

    function notifyRewardAmount(uint256 reward) external virtual;

    modifier onlyRewardDistribution() {
        require(_msgSender() == rewardDistribution, ""Caller is not reward distribution"");
        _;
    }

    function setRewardDistribution(address _rewardDistribution)
        external
        onlyOwner
    {
        rewardDistribution = _rewardDistribution;
    }
}

contract LPTokenWrapper {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable stakingToken;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    constructor(
        address _stakingToken
    )
        public
    {
        stakingToken = IERC20(_stakingToken);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function stake(uint256 amount) public virtual {
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
    }

    function stakeFor(address account, uint256 amount) internal {
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        // we don't transferFrom here because this is only triggered
        // when tokens have already been received
    }

    function withdraw(uint256 amount) public virtual {
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        stakingToken.safeTransfer(msg.sender, amount);
    }
}

contract Rewards is LPTokenWrapper, IRewardDistributionRecipient, ERC677Receiver {
    IERC20 public immutable rewardToken;
    uint256 public immutable duration;

    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);

    constructor(
        address _rewardToken,
        address _stakingToken,
        uint256 _duration
    )
        public
        LPTokenWrapper(_stakingToken)
    {
        rewardToken = IERC20(_rewardToken);
        duration = _duration;
    }

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    function onTokenTransfer(address sender, uint256 amount, bytes memory)
        public override updateReward(sender)
    {
        require(msg.sender == address(stakingToken), ""!stakingToken"");
        super.stakeFor(sender, amount);
        emit Staked(sender, amount);
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return Math.min(block.timestamp, periodFinish);
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalSupply() == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable()
                    .sub(lastUpdateTime)
                    .mul(rewardRate)
                    .mul(1e18)
                    .div(totalSupply())
            );
    }

    function earned(address account) public view returns (uint256) {
        return
            balanceOf(account)
                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))
                .div(1e18)
                .add(rewards[account]);
    }

    // stake visibility is public as overriding LPTokenWrapper's stake() function
    function stake(uint256 amount) public override updateReward(msg.sender) {
        require(amount > 0, ""Cannot stake 0"");
        super.stake(amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount) public override updateReward(msg.sender) {
        require(amount > 0, ""Cannot withdraw 0"");
        super.withdraw(amount);
        emit Withdrawn(msg.sender, amount);
    }

    function exit() external {
        withdraw(balanceOf(msg.sender));
        getReward();
    }

    function getReward() public updateReward(msg.sender) {
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function notifyRewardAmount(uint256 reward)
        external
        override
        onlyRewardDistribution
        updateReward(address(0))
    {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward.div(duration);
        } else {
            uint256 remaining = periodFinish.sub(block.timestamp);
            uint256 leftover = remaining.mul(rewardRate);
            rewardRate = reward.add(leftover).div(duration);
        }
        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(duration);
        emit RewardAdded(reward);
    }
}",1696
RealWorld_TA_30_IsYAX_RealWorld_20240803225006.log,30,IsYAX,20824,1382,22206,82.0,0.13176,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IsYAX {
    function exit() external;
}",28
RealWorld_TA_30_Aave_RealWorld_20240804010359.log,30,Aave,46755,1357,48112,81.0,0.260915,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Aave {
    function borrow(address _reserve, uint _amount, uint _interestRateModel, uint16 _referralCode) external;
    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;
    function repay(address _reserve, uint _amount, address payable _onBehalfOf) external payable;
    function getUserAccountData(address _user)
        external
        view
        returns (
            uint totalLiquidityETH,
            uint totalCollateralETH,
            uint totalBorrowsETH,
            uint totalFeesETH,
            uint availableBorrowsETH,
            uint currentLiquidationThreshold,
            uint ltv,
            uint healthFactor
        );
    function getUserReserveData(address _reserve, address _user)
        external
        view
        returns (
            uint currentATokenBalance,
            uint currentBorrowBalance,
            uint principalBorrowBalance,
            uint borrowRateMode,
            uint borrowRate,
            uint liquidityRate,
            uint originationFee,
            uint variableBorrowIndex,
            uint lastUpdateTimestamp,
            bool usageAsCollateralEnabled
        );
}

interface LendingPoolAddressesProvider {
    function getLendingPool() external view returns (address);
    function getLendingPoolCore() external view returns (address);
    function getPriceOracle() external view returns (address);
}

interface AaveToken {
    function underlyingAssetAddress() external view returns (address);
}

interface Oracle {
    function getAssetPrice(address reserve) external view returns (uint);
    function latestAnswer() external view returns (uint);
}",348
RealWorld_TA_30_MockV3Aggregatgor_RealWorld_20240803230416.log,30,MockV3Aggregatgor,71412,3490,74902,103.0,0.42686,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""../interfaces/Chainlink.sol"";

/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */
contract MockV3Aggregator is AggregatorV2V3Interface {
  uint256 constant public override version = 0;

  uint8 public override decimals;
  int256 public override latestAnswer;
  uint256 public override latestTimestamp;
  uint256 public override latestRound;

  mapping(uint256 => int256) public override getAnswer;
  mapping(uint256 => uint256) public override getTimestamp;
  mapping(uint256 => uint256) private getStartedAt;

  constructor(
    uint8 _decimals,
    int256 _initialAnswer
  ) public {
    decimals = _decimals;
    updateAnswer(_initialAnswer);
  }

  function updateAnswer(
    int256 _answer
  ) public {
    latestAnswer = _answer;
    latestTimestamp = block.timestamp;
    latestRound++;
    getAnswer[latestRound] = _answer;
    getTimestamp[latestRound] = block.timestamp;
    getStartedAt[latestRound] = block.timestamp;
  }

  function updateRoundData(
    uint80 _roundId,
    int256 _answer,
    uint256 _timestamp,
    uint256 _startedAt
  ) public {
    latestRound = _roundId;
    latestAnswer = _answer;
    latestTimestamp = _timestamp;
    getAnswer[latestRound] = _answer;
    getTimestamp[latestRound] = _timestamp;
    getStartedAt[latestRound] = _startedAt;
  }

  function getRoundData(uint80 _roundId)
    external
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    return (
      _roundId,
      getAnswer[_roundId],
      getStartedAt[_roundId],
      getTimestamp[_roundId],
      _roundId
    );
  }

  function latestRoundData()
    external
    view
    override
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    return (
      uint80(latestRound),
      getAnswer[latestRound],
      getStartedAt[latestRound],
      getTimestamp[latestRound],
      uint80(latestRound)
    );
  }

  function description()
    external
    view
    override
    returns (string memory)
  {
    return ""v0.6/tests/MockV3Aggregator.sol"";
  }
}",612
RealWorld_TA_30_Manager_RealWorld_20240803235012.log,30,Manager,309491,5058,314549,155.0,1.648615,"// SPDX-License-Identifier: MIT
// solhint-disable max-states-count
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title Manager
 * @notice This contract serves as the central point for governance-voted
 * variables. Fees and permissioned addresses are stored and referenced in
 * this contract only.
 */
contract Manager is IManager {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;
    uint256 public constant MAX_TOKENS = 256;

    address public immutable override yaxis;

    bool public override halted;

    address public override governance;
    address public override harvester;
    address public override insurancePool;
    address public override stakingPool;
    address public override strategist;
    address public override pendingStrategist;
    address public override treasury;

    // The following fees are all mutable.
    // They are updated by governance (community vote).
    uint256 public override insuranceFee;
    uint256 public override insurancePoolFee;
    uint256 public override stakingPoolShareFee;
    uint256 public override treasuryFee;
    uint256 public override withdrawalProtectionFee;


    uint256 private setPendingStrategistTime;

    // Governance must first allow the following properties before
    // the strategist can make use of them
    mapping(address => bool) public override allowedControllers;
    mapping(address => bool) public override allowedConverters;
    mapping(address => bool) public override allowedStrategies;
    mapping(address => bool) public override allowedTokens;
    mapping(address => bool) public override allowedVaults;

    // vault => controller
    mapping(address => address) public override controllers;
    // vault => tokens[]
    mapping(address => address[]) public override tokens;
    // token => vault
    mapping(address => address) public override vaults;

    event AllowedController(
        address indexed _controller,
        bool _allowed
    );
    event AllowedConverter(
        address indexed _converter,
        bool _allowed
    );
    event AllowedStrategy(
        address indexed _strategy,
        bool _allowed
    );
    event AllowedToken(
        address indexed _token,
        bool _allowed
    );
    event AllowedVault(
        address indexed _vault,
        bool _allowed
    );
    event Halted();
    event SetController(
        address indexed _vault,
        address indexed _controller
    );
    event SetGovernance(
        address indexed _governance
    );
    event SetPendingStrategist(
        address indexed _strategist
    );
    event SetStrategist(
        address indexed _strategist
    );
    event TokenAdded(
        address indexed _vault,
        address indexed _token
    );
    event TokenRemoved(
        address indexed _vault,
        address indexed _token
    );

    /**
     * @param _yaxis The address of the YAX token
     */
    constructor(
        address _yaxis
    )
        public
    {
        require(_yaxis != address(0), ""!_yaxis"");
        yaxis = _yaxis;
        governance = msg.sender;
        strategist = msg.sender;
        harvester = msg.sender;
        treasury = msg.sender;
        stakingPoolShareFee = 2000;
        treasuryFee = 500;
        withdrawalProtectionFee = 10;
    }

    /**
     * GOVERNANCE-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the permission for the given controller
     * @param _controller The address of the controller
     * @param _allowed The status of if it is allowed
     */
    function setAllowedController(
        address _controller,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IController(_controller).manager()) == address(this), ""!manager"");
        allowedControllers[_controller] = _allowed;
        emit AllowedController(_controller, _allowed);
    }

    /**
     * @notice Sets the permission for the given converter
     * @param _converter The address of the converter
     * @param _allowed The status of if it is allowed
     */
    function setAllowedConverter(
        address _converter,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IConverter(_converter).manager()) == address(this), ""!manager"");
        allowedConverters[_converter] = _allowed;
        emit AllowedConverter(_converter, _allowed);
    }

    /**
     * @notice Sets the permission for the given strategy
     * @param _strategy The address of the strategy
     * @param _allowed The status of if it is allowed
     */
    function setAllowedStrategy(
        address _strategy,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IStrategy(_strategy).manager()) == address(this), ""!manager"");
        allowedStrategies[_strategy] = _allowed;
        emit AllowedStrategy(_strategy, _allowed);
    }

    /**
     * @notice Sets the permission for the given token
     * @param _token The address of the token
     * @param _allowed The status of if it is allowed
     */
    function setAllowedToken(
        address _token,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        allowedTokens[_token] = _allowed;
        emit AllowedToken(_token, _allowed);
    }

    /**
     * @notice Sets the permission for the given vault
     * @param _vault The address of the vault
     * @param _allowed The status of if it is allowed
     */
    function setAllowedVault(
        address _vault,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IVault(_vault).manager()) == address(this), ""!manager"");
        allowedVaults[_vault] = _allowed;
        emit AllowedVault(_vault, _allowed);
    }

    /**
     * @notice Sets the governance address
     * @param _governance The address of the governance
     */
    function setGovernance(
        address _governance
    )
        external
        notHalted
        onlyGovernance
    {
        governance = _governance;
        emit SetGovernance(_governance);
    }

    /**
     * @notice Sets the harvester address
     * @param _harvester The address of the harvester
     */
    function setHarvester(
        address _harvester
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IHarvester(_harvester).manager()) == address(this), ""!manager"");
        harvester = _harvester;
    }

    /**
     * @notice Sets the insurance fee
     * @dev Throws if setting fee over 1%
     * @param _insuranceFee The value for the insurance fee
     */
    function setInsuranceFee(
        uint256 _insuranceFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insuranceFee <= 100, ""_insuranceFee over 1%"");
        insuranceFee = _insuranceFee;
    }

    /**
     * @notice Sets the insurance pool address
     * @param _insurancePool The address of the insurance pool
     */
    function setInsurancePool(
        address _insurancePool
    )
        external
        notHalted
        onlyGovernance
    {
        insurancePool = _insurancePool;
    }

    /**
     * @notice Sets the insurance pool fee
     * @dev Throws if setting fee over 20%
     * @param _insurancePoolFee The value for the insurance pool fee
     */
    function setInsurancePoolFee(
        uint256 _insurancePoolFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insurancePoolFee <= 2000, ""_insurancePoolFee over 20%"");
        insurancePoolFee = _insurancePoolFee;
    }

    /**
     * @notice Sets the staking pool address
     * @param _stakingPool The address of the staking pool
     */
    function setStakingPool(
        address _stakingPool
    )
        external
        notHalted
        onlyGovernance
    {
        stakingPool = _stakingPool;
    }

    /**
     * @notice Sets the staking pool share fee
     * @dev Throws if setting fee over 50%
     * @param _stakingPoolShareFee The value for the staking pool fee
     */
    function setStakingPoolShareFee(
        uint256 _stakingPoolShareFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_stakingPoolShareFee <= 5000, ""_stakingPoolShareFee over 50%"");
        stakingPoolShareFee = _stakingPoolShareFee;
    }

    /**
     * @notice Sets the pending strategist and the timestamp
     * @param _strategist The address of the strategist
     */
    function setStrategist(
        address _strategist
    )
        external
        notHalted
        onlyGovernance
    {
        require(_strategist != address(0), ""!_strategist"");
        pendingStrategist = _strategist;
        // solhint-disable-next-line not-rely-on-time
        setPendingStrategistTime = block.timestamp;
        emit SetPendingStrategist(_strategist);
    }

    /**
     * @notice Sets the treasury address
     * @param _treasury The address of the treasury
     */
    function setTreasury(
        address _treasury
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasury != address(0), ""!_treasury"");
        treasury = _treasury;
    }

    /**
     * @notice Sets the treasury fee
     * @dev Throws if setting fee over 20%
     * @param _treasuryFee The value for the treasury fee
     */
    function setTreasuryFee(
        uint256 _treasuryFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasuryFee <= 2000, ""_treasuryFee over 20%"");
        treasuryFee = _treasuryFee;
    }

    /**
     * @notice Sets the withdrawal protection fee
     * @dev Throws if setting fee over 1%
     * @param _withdrawalProtectionFee The value for the withdrawal protection fee
     */
    function setWithdrawalProtectionFee(
        uint256 _withdrawalProtectionFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_withdrawalProtectionFee <= 100, ""_withdrawalProtectionFee over 1%"");
        withdrawalProtectionFee = _withdrawalProtectionFee;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Updates the strategist to the pending strategist
     * @dev This can only be called after the pending strategist timelock (7 days)
     */
    function acceptStrategist()
        external
        notHalted
    {
        require(msg.sender == pendingStrategist, ""!pendingStrategist"");
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), ""PENDING_STRATEGIST_TIMELOCK"");
        delete pendingStrategist;
        delete setPendingStrategistTime;
        strategist = msg.sender;
        emit SetStrategist(msg.sender);
    }

    /**
     * @notice Adds a token to be able to be deposited for a given vault
     * @param _vault The address of the vault
     * @param _token The address of the token
     */
    function addToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedTokens[_token], ""!allowedTokens"");
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault].length < MAX_TOKENS, "">tokens"");
        require(vaults[_token] == address(0), ""!_token"");
        vaults[_token] = _vault;
        tokens[_vault].push(_token);
        emit TokenAdded(_vault, _token);
    }

    /**
     * @notice Allows the strategist to pull tokens out of this contract
     * @dev This contract should never hold tokens
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to send to
     */
    function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * @notice Removes a token from being able to be deposited for a given vault
     * @param _vault The address of the vault
     * @param _token The address of the token
     */
    function removeToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        uint256 k = tokens[_vault].length;
        uint256 index;
        bool found;

        for (uint i = 0; i < k; i++) {
            if (tokens[_vault][i] == _token) {
                index = i;
                found = true;
                break;
            }
        }

        // TODO: Verify added check
        if (found) {
            tokens[_vault][index] = tokens[_vault][k-1];
            tokens[_vault].pop();
            delete vaults[_token];
            emit TokenRemoved(_vault, _token);
        }
    }

    /**
     * @notice Sets the vault address for a controller
     * @param _vault The address of the vault
     * @param _controller The address of the controller
     */
    function setController(
        address _vault,
        address _controller
    )
        external
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!_vault"");
        require(allowedControllers[_controller], ""!_controller"");
        controllers[_vault] = _controller;
        emit SetController(_vault, _controller);
    }

    /**
     * @notice Sets the protocol as halted, disallowing all deposits forever
     * @dev Withdraws will still work, allowing users to exit the protocol
     */
    function setHalted()
        external
        notHalted
        onlyStrategist
    {
        halted = true;
        emit Halted();
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns an array of token addresses for a given vault
     * @param _vault The address of the vault
     */
    function getTokens(
        address _vault
    )
        external
        view
        override
        returns (address[] memory)
    {
        return tokens[_vault];
    }

    /**
     * @notice Returns a tuple of:
     *     YAXIS token address,
     *     Treasury address,
     *     Treasury fee
     */
    function getHarvestFeeInfo()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (
            yaxis,
            treasury,
            treasuryFee
        );
    }

    modifier notHalted() {
        require(!halted, ""halted"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""!governance"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == strategist, ""!strategist"");
        _;
    }
}",3492
RealWorld_TA_30_IUniswapV2Pair_RealWorld_20240804004443.log,30,IUniswapV2Pair,25768,1275,27043,82.0,0.15434,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IUniswapV2Pair is IERC20 {
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
}",95
RealWorld_TA_30_YaxisVoteProxy_RealWorld_20240804003829.log,30,YaxisVoteProxy,50249,3660,53909,114.0,0.324445,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IVoteProxy.sol"";

contract YaxisVoteProxy {
    IVoteProxy public voteProxy;
    address public governance;
    constructor() public {
        governance = msg.sender;
    }

    function name() external pure returns (string memory) {
        return ""YAXIS Vote Power"";
    }

    function symbol() external pure returns (string memory) {
        return ""YAX VP"";
    }

    function decimals() external view returns (uint8) {
        return voteProxy.decimals();
    }

    function totalSupply() external view returns (uint256) {
        return voteProxy.totalSupply();
    }

    function balanceOf(address _voter) external view returns (uint256) {
        return voteProxy.balanceOf(_voter);
    }

    function setVoteProxy(IVoteProxy _voteProxy) external {
        require(msg.sender == governance, ""!governance"");
        voteProxy = _voteProxy;
    }

    function setGovernance(address _governance) external {
        require(msg.sender == governance, ""!governance"");
        governance = _governance;
    }



/**
 * This function allows governance to take unsupported tokens out of the contract.
 * This is in an effort to make someone whole, should they seriously mess up.
 * There is no guarantee governance will vote to return these.
 * It also allows for removal of airdropped tokens.
 */
    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {
        require(msg.sender == governance, ""!governance"");
        _token.transfer(to, amount);
    }
}",363
RealWorld_TA_30_MetaVaultNonConverter_RealWorld_20240803232754.log,30,MetaVaultNonConverter,94654,2593,97247,106.0,0.52513,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./IConverter.sol"";
import ""./IVaultManager.sol"";

/**
 * @title MetaVaultNonConverter (StableSwap3PoolConverter)
 * @notice The StableSwap3PoolConverter is used to convert funds on Curve's 3Pool.
 * This is a safe version that does not allow the vault to be used for arbitrage.
 */
contract MetaVaultNonConverter is IConverter {
    using SafeERC20 for IERC20;

    IVaultManager public immutable vaultManager;
    IERC20 public immutable token3CRV; // 3Crv

    /**
     * @param _token3CRV The address of the 3CRV token
     * @param _vaultManager The address of the Vault Manager
     */
    constructor(
        IERC20 _token3CRV,
        IVaultManager _vaultManager
    ) public {
        token3CRV = _token3CRV;
        vaultManager = _vaultManager;
    }

    /**
     * @notice Called by Governance to enable or disable a strategy to use the converter
     */
    function setStrategy(address, bool) external override onlyGovernance {
        return;
    }

    /**
     * @notice Called by Governance to approve a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    ) external onlyGovernance {
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Returns the address of the 3CRV token
     */
    function token() external view override returns (address) {
        return address(token3CRV);
    }

    /**
     * @notice Converts the amount of input tokens to output tokens
     */
    function convert(
        address,
        address,
        uint256
    ) external override returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Checks the amount of input tokens to output tokens
     */
    function convert_rate(
        address,
        address,
        uint256
    ) external override view returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Converts stables of the 3Pool to 3CRV
     */
    function convert_stables(
        uint256[3] calldata
    ) external override returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Checks the amount of 3CRV given for the amounts
     */
    function calc_token_amount(
        uint256[3] calldata,
        bool
    ) external override view returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Checks the amount of an output token given for 3CRV
     */
    function calc_token_amount_withdraw(
        uint256,
        address
    ) external override view returns (uint256) {
        revert(""Only 3CRV allowed"");
    }

    /**
     * @notice Allows Governance to withdraw tokens from the converter
     * @dev This contract should never have any tokens in it at the end of a transaction
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to receive the tokens
     */
    function governanceRecoverUnsupported(
        IERC20 _token,
        uint256 _amount,
        address _to
    ) external onlyGovernance {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * @dev Throws if not called by a controller or governance
     */
    modifier onlyGovernance() {
        require(vaultManager.controllers(msg.sender)
            || msg.sender == vaultManager.governance(), ""!governance"");
        _;
    }
}",920
RealWorld_TA_30_IStableSwap3Pool_RealWorld_20240804001722.log,30,IStableSwap3Pool,36949,1674,38623,92.0,0.218225,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IStableSwap3Pool {
    function get_virtual_price() external view returns (uint);
    function balances(uint) external view returns (uint);
    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);
    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;
    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;
    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;
    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;
    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);
    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);
}",219
RealWorld_TA_30_IMasterChef_RealWorld_20240804004318.log,30,IMasterChef,23589,1398,24987,83.0,0.145905,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IMasterChef {
    function userInfo(uint256, address) external view returns (uint256, uint256, uint256);
    function pendingYaxis(uint256, address) external view returns (uint256);
}",60
RealWorld_TA_30_MockCurveMinter_RealWorld_20240803230945.log,30,MockCurveMinter,33027,3025,36052,113.0,0.225635,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/Gauge.sol"";

contract MockCurveMinter is Mintr {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 crv;

    constructor(IERC20 _crv) public {
        crv = _crv;
    }

    function mint(address) external override {
        uint _bal = crv.balanceOf(address(this));
        crv.safeTransfer(msg.sender, _bal.div(10)); // always mint 10% amount of balance
    }
}",172
RealWorld_TA_30_Gauge_RealWorld_20240804011830.log,30,Gauge,24481,1802,26283,86.0,0.158445,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Gauge {
    function deposit(uint) external;
    function balanceOf(address) external view returns (uint);
    function withdraw(uint) external;
    function claimable_tokens(address) external view returns (uint);
}

interface Mintr {
    function mint(address) external;
}",71
RealWorld_TA_30_Idle_RealWorld_20240804010233.log,30,Idle,26535,1384,27919,84.0,0.160355,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface IIdleTokenV3_1 {
    function tokenPrice() external view returns (uint256 price);
    function token() external view returns (address);
    function mintIdleToken(uint256 _amount, bool _skipRebalance, address _referral) external returns (uint256 mintedTokens);
    function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);
}",97
RealWorld_TA_30_MockDRewards_RealWorld_20240803230601.log,30,MockDRewards,56281,3324,59605,106.0,0.347885,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockDRewards {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public lpToken;
    IERC20 public rewardToken;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    uint256 rewardRate; // over 1000

    constructor(
        address _lpToken,
        address _rewardToken,
        uint256 _rewardRate
    ) public {
        lpToken = IERC20(_lpToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function earned(address account) public view returns (uint256) {
        return balanceOf(account).mul(rewardRate).div(1000);
    }

    function stake(uint256 amount) public {
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        lpToken.safeTransferFrom(msg.sender, address(this), amount);
    }

    function withdraw(uint256 amount) public {
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        lpToken.safeTransfer(msg.sender, amount);
    }

    function exit() external {
        withdraw(balanceOf(msg.sender));
        getReward();
    }

    function getReward() public {
        uint256 reward = earned(msg.sender);
        if (reward > 0) {
            if (reward > rewardToken.balanceOf(address(this))) {
                reward = rewardToken.balanceOf(address(this));
            }
            rewardToken.safeTransfer(msg.sender, reward);
        }
    }
}",451
RealWorld_TA_30_IStrategy_RealWorld_20240804002541.log,30,IStrategy,32900,2118,35018,98.0,0.20686,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";
import ""./ISwap.sol"";

interface IStrategy {
    function balanceOf() external view returns (uint256);
    function balanceOfPool() external view returns (uint256);
    function balanceOfWant() external view returns (uint256);
    function deposit() external;
    function harvest(uint256, uint256) external;
    function manager() external view returns (IManager);
    function name() external view returns (string memory);
    function router() external view returns (ISwap);
    function skim() external;
    function want() external view returns (address);
    function weth() external view returns (address);
    function withdraw(address) external;
    function withdraw(uint256) external;
    function withdrawAll() external;
}",170
RealWorld_TA_30_IController_RealWorld_20240804003507.log,30,IController,31835,1681,33516,85.0,0.192795,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IController {
    function balanceOf() external view returns (uint256);
    function converter(address _vault) external view returns (address);
    function earn(address _strategy, address _token, uint256 _amount) external;
    function investEnabled() external view returns (bool);
    function harvestStrategy(address _strategy, uint256 _estimatedWETH, uint256 _estimatedYAXIS) external;
    function manager() external view returns (IManager);
    function strategies() external view returns (uint256);
    function withdraw(address _token, uint256 _amount) external;
    function withdrawAll(address _strategy, address _convert) external;
}",156
RealWorld_TA_30_MockYaxisChef_RealWorld_20240803234357.log,30,MockYaxisChef,35905,2682,38587,108.0,0.233165,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

contract MockYaxisChef {
    mapping(address => uint256) private _userInfo;
    mapping(address => uint256) private _pending;

    function addBalance(
        address _user,
        uint256 _amount,
        uint256 _pendingAmount
    )
        external
    {
        _userInfo[_user] += _amount;
        _pending[_user] += _pendingAmount;
    }

    function userInfo(
        uint256,
        address _user
    )
        external
        view
        returns (uint256, uint256, uint256)
    {
        return (_userInfo[_user], 0, 0);
    }

    function pendingYaxis(
        uint256,
        address _user
    )
        external
        view
        returns (uint256)
    {
        return _pending[_user];
    }
}",188
RealWorld_TA_30_Converter_RealWorld_20240804011355.log,30,Converter,21301,1692,22993,87.0,0.140345,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Converter {
    function convert(address) external returns (uint);
}",30
RealWorld_TA_30_IConverter_RealWorld_20240803233524.log,30,IConverter,37921,2206,40127,100.0,0.233725,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IConverter {
    function token() external view returns (address _share);
    function convert(
        address _input,
        address _output,
        uint _inputAmount
    ) external returns (uint _outputAmount);
    function convert_rate(
        address _input,
        address _output,
        uint _inputAmount
    ) external view returns (uint _outputAmount);
    function convert_stables(
        uint[3] calldata amounts
    ) external returns (uint _shareAmount); // 0: DAI, 1: USDC, 2: USDT
    function calc_token_amount(
        uint[3] calldata amounts,
        bool deposit
    ) external view returns (uint _shareAmount);
    function calc_token_amount_withdraw(
        uint _shares,
        address _output
    ) external view returns (uint _outputAmount);
    function setStrategy(address _strategy, bool _status) external;
}",232
RealWorld_TA_30_ISwap_RealWorld_20240804002225.log,30,ISwap,23903,1505,25408,91.0,0.149615,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface ISwap {
    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external;
    function getAmountsOut(uint256, address[] calldata) external view returns (uint256[] memory);
}",69
RealWorld_TA_30_Harvester_RealWorld_20240803235249.log,30,Harvester,196342,5249,201591,144.0,1.08669,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""./interfaces/IVault.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/ILegacyController.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/ISwap.sol"";

/**
 * @title Harvester
 * @notice This contract is to be used as a central point to call
 * harvest on all strategies for any given vault. It has its own
 * permissions for harvesters (set by the strategist or governance).
 */
contract Harvester is IHarvester {
    using SafeMath for uint256;

    uint256 public constant ONE_HUNDRED_PERCENT = 10000;

    IManager public immutable override manager;
    IController public immutable controller;
    ILegacyController public immutable legacyController;

    uint256 public slippage;

    struct Strategy {
        uint256 timeout;
        uint256 lastCalled;
        address[] addresses;
    }

    mapping(address => Strategy) public strategies;
    mapping(address => bool) public isHarvester;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(
        address indexed controller,
        address indexed strategy
    );

    /**
     * @notice Logged when a harvester is set
     */
    event HarvesterSet(address indexed harvester, bool status);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 timeout);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy, uint256 timeout);

    /**
     * @param _manager The address of the yAxisMetaVaultManager contract
     * @param _controller The address of the controller
     */
    constructor(
        address _manager,
        address _controller,
        address _legacyController
    )
        public
    {
        manager = IManager(_manager);
        controller = IController(_controller);
        legacyController = ILegacyController(_legacyController);
    }

    /**
     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy to the rotation for a given vault and sets a timeout
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        override
        onlyController
    {
        strategies[_vault].addresses.push(_strategy);
        strategies[_vault].timeout = _timeout;
        emit StrategyAdded(_vault, _strategy, _timeout);
    }

    /**
     * @notice Removes a strategy from the rotation for a given vault and sets a timeout
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        override
        onlyController
    {
        uint256 tail = strategies[_vault].addresses.length;
        uint256 index;
        bool found;
        for (uint i; i < tail; i++) {
            if (strategies[_vault].addresses[i] == _strategy) {
                index = i;
                found = true;
                break;
            }
        }

        if (found) {
            strategies[_vault].addresses[index] = strategies[_vault].addresses[tail.sub(1)];
            strategies[_vault].addresses.pop();
            strategies[_vault].timeout = _timeout;
            emit StrategyRemoved(_vault, _strategy, _timeout);
        }
    }

    /**
     * @notice Sets the status of a harvester address to be able to call harvest functions
     * @param _harvester The address of the harvester
     * @param _status The status to allow the harvester to harvest
     */
    function setHarvester(
        address _harvester,
        bool _status
    )
        external
        onlyStrategist
    {
        isHarvester[_harvester] = _status;
        emit HarvesterSet(_harvester, _status);
    }

    function setSlippage(
        uint256 _slippage
    )
        external
        onlyStrategist
    {
        require(_slippage < ONE_HUNDRED_PERCENT, ""!_slippage"");
        slippage = _slippage;
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    function earn(
        address _strategy,
        IVault _vault,
        address _token
    )
        external
        onlyHarvester
    {
        _vault.earn(_token, _strategy);
    }

    /**
     * @notice Harvests a given strategy on the provided controller
     * @dev This function ignores the timeout
     * @param _controller The address of the controller
     * @param _strategy The address of the strategy
     */
    function harvest(
        IController _controller,
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        public
        onlyHarvester
    {
        _controller.harvestStrategy(_strategy, _estimatedWETH, _estimatedYAXIS);
        emit Harvest(address(_controller), _strategy);
    }

    /**
     * @notice Harvests the next available strategy for a given vault and
     * rotates the strategies
     * @param _vault The address of the vault
     */
    function harvestNextStrategy(
        address _vault,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
    {
        require(canHarvest(_vault), ""!canHarvest"");
        address strategy = strategies[_vault].addresses[0];
        harvest(controller, strategy, _estimatedWETH, _estimatedYAXIS);
        uint256 k = strategies[_vault].addresses.length;
        if (k > 1) {
            address[] memory _strategies = new address[](k);
            for (uint i; i < k-1; i++) {
                _strategies[i] = strategies[_vault].addresses[i+1];
            }
            _strategies[k-1] = strategy;
            strategies[_vault].addresses = _strategies;
        }
        // solhint-disable-next-line not-rely-on-time
        strategies[_vault].lastCalled = block.timestamp;
    }

    /**
     * @notice Earns tokens in the LegacyController to the v3 vault
     * @param _token The address of the token
     * @param _expected The expected amount to deposit after conversion
     */
    function legacyEarn(
        address _token,
        uint256 _expected
    )
        external
        onlyHarvester
    {
        legacyController.legacyDeposit(_token, _expected);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the addresses of the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategyAddresses(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return strategies[_vault].addresses;
    }

    /**
     * PUBLIC VIEW FUNCTIONS
     */

    /**
     * @notice Returns the availability of a vault's strategy to be harvested
     * @param _vault The address of the vault
     */
    function canHarvest(
        address _vault
    )
        public
        view
        returns (bool)
    {
        Strategy storage strategy = strategies[_vault];
        // only can harvest if there are strategies, and when sufficient time has elapsed
        return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout));
    }

    /**
     * @notice Returns the estimated amount of WETH and YAXIS for the given strategy
     * @param _strategy The address of the strategy
     */
    function getEstimates(
        address _strategy
    )
        public
        view
        returns (uint256 _estimatedWETH, uint256 _estimatedYAXIS)
    {
        ISwap _router = IStrategy(_strategy).router();
        address[] memory _path;
        _path[0] = IStrategy(_strategy).want();
        _path[1] = IStrategy(_strategy).weth();
        uint256[] memory _amounts = _router.getAmountsOut(
            IStrategy(_strategy).balanceOfPool(),
            _path
        );
        _estimatedWETH = _amounts[1];
        uint256 _slippage = slippage;
        if (_slippage > 0) {
            _estimatedWETH = _estimatedWETH.mul(_slippage).div(ONE_HUNDRED_PERCENT);
        }
        _path[0] = manager.yaxis();
        uint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);
        _amounts = _router.getAmountsOut(_fee, _path);
        _estimatedYAXIS = _amounts[1];
        if (_slippage > 0) {
            _estimatedYAXIS = _estimatedYAXIS.mul(_slippage).div(ONE_HUNDRED_PERCENT);
        }
    }

    /**
     * MODIFIERS
     */

    modifier onlyController() {
        require(manager.allowedControllers(msg.sender), ""!controller"");
        _;
    }

    modifier onlyHarvester() {
        require(isHarvester[msg.sender], ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2110
RealWorld_TA_30_Balancer_RealWorld_20240804005337.log,30,Balancer,37303,1567,38870,85.0,0.217855,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Balancer {
    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;
    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;
    function swapExactAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        address tokenOut,
        uint minAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountOut, uint spotPriceAfter);
    function swapExactAmountOut(
        address tokenIn,
        uint maxAmountIn,
        address tokenOut,
        uint tokenAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountIn, uint spotPriceAfter);
    function joinswapExternAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        uint minPoolAmountOut
    ) external returns (uint poolAmountOut);
    function exitswapPoolAmountIn(
        address tokenOut,
        uint poolAmountIn,
        uint minAmountOut
    ) external returns (uint tokenAmountOut);
}",230
RealWorld_TA_30_dYdXSoloMargin_RealWorld_20240804005916.log,30,dYdXSoloMargin,71872,2332,74204,95.0,0.406,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;
pragma experimental ABIEncoderV2;

library Account {
    enum Status {
        Normal,
        Liquid,
        Vapor
    }

    struct Info {
        address owner;  // The address that owns the account
        uint256 number; // A nonce that allows a single address to control many accounts
    }

    function equals(
        Info memory a,
        Info memory b
    )
        internal
        pure
        returns (bool)
    {
        return a.owner == b.owner && a.number == b.number;
    }
}

library Types {
    enum AssetDenomination {
        Wei // the amount is denominated in wei
    }

    struct Wei {
        bool sign; // true if positive
        uint256 value;
    }

    enum AssetReference {
        Delta // the amount is given as a delta from the current value
    }

    struct AssetAmount {
        bool sign; // true if positive
        AssetDenomination denomination;
        AssetReference ref;
        uint256 value;
    }
}

library Actions {
    enum ActionType {
        Deposit, // supply tokens
        Withdraw // borrow tokens
    }

    enum AccountLayout {
        OnePrimary,
        TwoPrimary,
        PrimaryAndSecondary
    }

    enum MarketLayout {
        ZeroMarkets,
        OneMarket,
        TwoMarkets
    }

    struct ActionArgs {
        ActionType actionType;
        uint256 accountId;
        Types.AssetAmount amount;
        uint256 primaryMarketId;
        uint256 secondaryMarketId;
        address otherAddress;
        uint256 otherAccountId;
        bytes data;
    }

    struct DepositArgs {
        Types.AssetAmount amount;
        Account.Info account;
        uint256 market;
        address from;
    }

    struct WithdrawArgs {
        Types.AssetAmount amount;
        Account.Info account;
        uint256 market;
        address to;
    }

    function parseDepositArgs(
        Account.Info[] memory accounts,
        ActionArgs memory args
    )
        internal
        pure
        returns (DepositArgs memory)
    {
        assert(args.actionType == ActionType.Deposit);
        return DepositArgs({
            amount: args.amount,
            account: accounts[args.accountId],
            market: args.primaryMarketId,
            from: args.otherAddress
        });
    }

    function parseWithdrawArgs(
        Account.Info[] memory accounts,
        ActionArgs memory args
    )
        internal
        pure
        returns (WithdrawArgs memory)
    {
        assert(args.actionType == ActionType.Withdraw);
        return WithdrawArgs({
            amount: args.amount,
            account: accounts[args.accountId],
            market: args.primaryMarketId,
            to: args.otherAddress
        });
    }
}

interface ISoloMargin {
    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;
    function getMarketTokenAddress(uint256 marketId) external view returns (address);
    function getAccountWei(Account.Info memory account, uint256 marketId) external view returns (Types.Wei memory);
}",625
RealWorld_TA_30_MockERC20NonStandard_RealWorld_20240803232556.log,30,MockERC20NonStandard,96038,3731,99769,116.0,0.55481,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

contract MockERC20NonStandard {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    address private _owner;

    uint internal _totalSupply;

    mapping(address => uint)                   private _balance;
    mapping(address => mapping(address => uint)) private _allowance;

    modifier _onlyOwner_() {
        require(msg.sender == _owner, ""ERR_NOT_OWNER"");
        _;
    }

    event Approval(address indexed src, address indexed dst, uint amt);
    event Transfer(address indexed src, address indexed dst, uint amt);

    // Math
    function add(uint a, uint b) internal pure returns (uint c) {
        require((c = a + b) >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require((c = a - b) <= a);
    }

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals
    ) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
        _owner = msg.sender;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function _move(address src, address dst, uint amt) internal {
        require(_balance[src] >= amt, ""!bal"");
        _balance[src] = sub(_balance[src], amt);
        _balance[dst] = add(_balance[dst], amt);
        emit Transfer(src, dst, amt);
    }

    function _push(address to, uint amt) internal {
        _move(address(this), to, amt);
    }

    function _pull(address from, uint amt) internal {
        _move(from, address(this), amt);
    }

    function _mint(address dst, uint amt) internal {
        _balance[dst] = add(_balance[dst], amt);
        _totalSupply = add(_totalSupply, amt);
        emit Transfer(address(0), dst, amt);
    }

    function _burn(address dst, uint amt) internal {
        _balance[dst] = sub(_balance[dst], amt);
        _totalSupply = sub(_totalSupply, amt);
        emit Transfer(dst, address(0), amt);
    }

    function allowance(address src, address dst) external view returns (uint) {
        return _allowance[src][dst];
    }

    function balanceOf(address whom) public view returns (uint) {
        return _balance[whom];
    }

    function faucet(uint256 amt) public {
        _mint(msg.sender, amt);
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    function approve(address dst, uint amt) external {
        _allowance[msg.sender][dst] = amt;
        emit Approval(msg.sender, dst, amt);
    }

    function mint(address dst, uint256 amt) public _onlyOwner_ {
        _mint(dst, amt);
    }

    function burn(uint amt) public {
        require(_balance[msg.sender] >= amt, ""!bal"");
        _burn(msg.sender, amt);
    }

    function burnFrom(address src, uint amt) public _onlyOwner_ {
        require(_balance[src] >= amt, ""!bal"");
        _burn(src, amt);
    }

    function transfer(address dst, uint amt) external {
        _move(msg.sender, dst, amt);
    }

    function transferFrom(address src, address dst, uint amt) external {
        require(msg.sender == src || amt <= _allowance[src][msg.sender], ""!spender"");
        _move(src, dst, amt);
        if (msg.sender != src && _allowance[src][msg.sender] != uint256(- 1)) {
            _allowance[src][msg.sender] = sub(_allowance[src][msg.sender], amt);
            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);
        }
    }

    function transferOwnership(address newOwner) external _onlyOwner_ {
        _owner = newOwner;
    }
}",901
RealWorld_TA_30_ExtendedIERC20_RealWorld_20240804001556.log,30,ExtendedIERC20,23262,1621,24883,84.0,0.14873,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface ExtendedIERC20 {
    function decimals() external view returns (uint8);
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
}",56
RealWorld_TA_30_ILegacyVault_RealWorld_20240804002721.log,30,ILegacyVault,21384,1586,22970,89.0,0.13864,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface ILegacyVault {
    function want() external returns (address);
}",32
RealWorld_TA_30_StablesConverter_RealWorld_20240804000601.log,30,StablesConverter,168246,5693,173939,146.0,0.95509,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IConverter.sol"";
import ""../interfaces/IManager.sol"";
import ""../interfaces/ICurve3Pool.sol"";

/**
 * @title StablesConverter
 */
contract StablesConverter is IConverter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IManager public immutable override manager;
    ICurve3Pool public immutable stableSwap3Pool;
    IERC20 public immutable token3CRV; // 3Crv

    IERC20[3] public tokens; // DAI, USDC, USDT

    mapping(address => int128) internal indices;

    /**
     * @param _tokenDAI The address of the DAI token
     * @param _tokenUSDC The address of the USDC token
     * @param _tokenUSDT The address of the USDT token
     * @param _token3CRV The address of the 3CRV token
     * @param _stableSwap3Pool The address of 3Pool
     * @param _manager The address of the Vault Manager
     */
    constructor(
        IERC20 _tokenDAI,
        IERC20 _tokenUSDC,
        IERC20 _tokenUSDT,
        IERC20 _token3CRV,
        ICurve3Pool _stableSwap3Pool,
        IManager _manager
    ) public {
        tokens[0] = _tokenDAI;
        tokens[1] = _tokenUSDC;
        tokens[2] = _tokenUSDT;
        indices[address(_tokenDAI)] = 0;
        indices[address(_tokenUSDC)] = 1;
        indices[address(_tokenUSDT)] = 2;
        token3CRV = _token3CRV;
        stableSwap3Pool = _stableSwap3Pool;
        tokens[0].safeApprove(address(_stableSwap3Pool), type(uint256).max);
        tokens[1].safeApprove(address(_stableSwap3Pool), type(uint256).max);
        tokens[2].safeApprove(address(_stableSwap3Pool), type(uint256).max);
        _token3CRV.safeApprove(address(_stableSwap3Pool), type(uint256).max);
        manager = _manager;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Called by the strategist to approve a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        _token.safeApprove(_spender, 0);
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Allows the strategist to withdraw tokens from the converter
     * @dev This contract should never have any tokens in it at the end of a transaction
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to receive the tokens
     */
    function recoverUnsupported(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * AUTHORIZED-ONLY FUNCTIONS
     */

    /**
     * @notice Converts the amount of input tokens to output tokens
     * @param _input The address of the token being converted
     * @param _output The address of the token to be converted to
     * @param _inputAmount The input amount of tokens that are being converted
     * @param _estimatedOutput The estimated output tokens after converting
     */
    function convert(
        address _input,
        address _output,
        uint256 _inputAmount,
        uint256 _estimatedOutput
    )
        external
        override
        onlyAuthorized
        returns (uint256 _outputAmount)
    {
        if (_output == address(token3CRV)) { // convert to 3CRV
            uint256[3] memory amounts;
            for (uint8 i = 0; i < 3; i++) {
                if (_input == address(tokens[i])) {
                    amounts[i] = _inputAmount;
                    uint256 _before = token3CRV.balanceOf(address(this));
                    stableSwap3Pool.add_liquidity(amounts, _estimatedOutput);
                    uint256 _after = token3CRV.balanceOf(address(this));
                    _outputAmount = _after.sub(_before);
                    token3CRV.safeTransfer(msg.sender, _outputAmount);
                    return _outputAmount;
                }
            }
        } else if (_input == address(token3CRV)) { // convert from 3CRV
            // A temporary cache, used to save gas.
            IERC20 _token;
            for (uint8 i = 0; i < 3; i++) {
                _token = tokens[i];
                if (_output == address(_token) {
                    uint256 _before = _token.balanceOf(address(this));
                    stableSwap3Pool.remove_liquidity_one_coin(
                        _inputAmount,
                        i,
                        _estimatedOutput
                    );
                    uint256 _after = _token.balanceOf(address(this));
                    _outputAmount = _after.sub(_before);
                    _token.safeTransfer(msg.sender, _outputAmount);
                    return _outputAmount;
                }
            }
        } else {
            stableSwap3Pool.exchange(
                indices[_input],
                indices[_output],
                _inputAmount,
                _estimatedOutput
            );
            _outputAmount = IERC20(_output).balanceOf(address(this));
            IERC20(_output).safeTransfer(msg.sender, _outputAmount);
            return _outputAmount;
        }
        return 0;
    }

    /**
     * @notice Checks the amount of input tokens to output tokens
     * @param _input The address of the token being converted
     * @param _output The address of the token to be converted to
     * @param _inputAmount The input amount of tokens that are being converted
     */
    function expected(
        address _input,
        address _output,
        uint256 _inputAmount
    )
        external
        override
        view
        returns (uint256)
    {
        if (_output == address(token3CRV)) { // convert to 3CRV
            uint256[3] memory amounts;
            for (uint8 i = 0; i < 3; i++) {
                if (_input == address(tokens[i])) {
                    amounts[i] = _inputAmount;
                    return stableSwap3Pool.calc_token_amount(amounts, true);
                }
            }
        } else if (_input == address(token3CRV)) { // convert from 3CRV
            for (uint8 i = 0; i < 3; i++) {
                if (_output == address(tokens[i])) {
                    // @dev this is for UI reference only, the actual share price
                    // (stable/CRV) will be re-calculated on-chain when we do convert()
                    return stableSwap3Pool.calc_withdraw_one_coin(_inputAmount, i);
                }
            }
        } else {
            return stableSwap3Pool.get_dy(indices[_input], indices[_output], _inputAmount);
        }
        return 0;
    }

    /**
     * MODIFIERS
     */

    /**
     * @dev Throws if not called by an allowed vault, controller, or strategy
     */
    modifier onlyAuthorized() {
        require(manager.allowedVaults(msg.sender)
            || manager.allowedControllers(msg.sender)
            || manager.allowedStrategies(msg.sender),
            ""!authorized""
        );
        _;
    }

    /**
     * @dev Throws if not called by the strategist
     */
    modifier onlyStrategist {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",1792
RealWorld_TA_30_DForce_RealWorld_20240804010053.log,30,DForce,27909,2006,29915,97.0,0.179665,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface dRewards {
    function withdraw(uint) external;
    function getReward() external;
    function stake(uint) external;
    function balanceOf(address) external view returns (uint);
    function exit() external;
}

interface dERC20 {
  function mint(address, uint256) external;
  function redeem(address, uint) external;
  function getTokenBalance(address) external view returns (uint);
  function getExchangeRate() external view returns (uint);
}",110
RealWorld_TA_30_OneSplitAudit_RealWorld_20240804011655.log,30,OneSplitAudit,30050,1848,31898,93.0,0.18721,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface OneSplitAudit {
    function swap(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata distribution,
        uint256 flags
    )
        external
        payable
        returns(uint256 returnAmount);

    function getExpectedReturn(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 parts,
        uint256 flags // See constants in IOneSplit.sol
    )
        external
        view
        returns(
            uint256 returnAmount,
            uint256[] memory distribution
        );
}",140
RealWorld_TA_30_IVault_RealWorld_20240804001856.log,30,IVault,38080,3123,41203,109.0,0.25286,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IVault {
    function available(address _token) external view returns (uint256);
    function balance() external view returns (uint256);
    function deposit(address _token, uint256 _amount) external returns (uint256);
    function depositMultiple(address[] calldata _tokens, uint256[] calldata _amount) external returns (uint256);
    function earn(address _token, address _strategy) external;
    function gauge() external returns (address);
    function getPricePerFullShare() external view returns (uint256);
    function getTokens() external view returns (address[] memory);
    function manager() external view returns (IManager);
    function swap(address _token0, address _token1, uint256 _expectedAmount) external returns (uint256);
    function withdraw(uint256 _amount, address _output) external;
    function withdrawAll(address _output) external;
    function withdrawFee(uint256 _amount) external view returns (uint256);
}",220
RealWorld_TA_30_MockPickleMasterChef_RealWorld_20240803225626.log,30,MockPickleMasterChef,51726,5156,56882,120.0,0.36175,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract MockPickleMasterChef {
    IERC20 public pickleToken;
    IERC20 public lpToken;

    struct UserInfo {
        uint amount; // How many LP tokens the user has provided.
        uint rewardDebt; // Reward debt. See explanation below.
    }

    mapping(uint => mapping(address => UserInfo)) public userInfo;

    constructor(IERC20 _pickleToken, IERC20 _lpToken) public {
        pickleToken = _pickleToken;
        lpToken = _lpToken;
    }

    function deposit(uint _pid, uint _amount) external {
        lpToken.transferFrom(msg.sender, address(this), _amount);
        UserInfo storage user = userInfo[_pid][msg.sender];
        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount
        user.amount = user.amount + _amount;
    }

    function withdraw(uint _pid, uint _amount) external {
        lpToken.transfer(msg.sender, _amount);
        UserInfo storage user = userInfo[_pid][msg.sender];
        pickleToken.transfer(msg.sender, user.amount / 10); // always get 10% of deposited amount
        user.amount = user.amount - _amount;
    }

    function pendingPickle(uint, address) external view returns (uint) {
        return pickleToken.balanceOf(address(this)) / 10;
    }

    function emergencyWithdraw(uint _pid) external {
        UserInfo storage user = userInfo[_pid][msg.sender];
        lpToken.transfer(msg.sender, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;
    }
}",364
RealWorld_TA_30_VaultHelper_RealWorld_20240803235516.log,30,VaultHelper,100581,3923,104504,124.0,0.581365,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/ILiquidityGaugeV2.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title VaultHelper
 * @notice The VaultHelper acts as a single contract that users may set
 * token approvals on for any token of any vault.
 * @dev This contract has no state and could be deployed by anyone if
 * they didn't trust the original deployer.
 */
contract VaultHelper {
    using SafeERC20 for IERC20;

    /**
     * @notice Deposits the given token into the specified vault
     * @dev Users must approve the vault helper to spend their token
     * @param _vault The address of the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
    function depositVault(
        address _vault,
        address _token,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_token, _amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the specified vault
     * @dev Users must approve the vault helper to spend their tokens
     * @param _vault The address of the vault
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultipleVault(
        address _vault,
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0, ""!_amounts"");
            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
            IERC20(_tokens[i]).safeApprove(_vault, 0);
            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);
        }
        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    function withdrawVault(
        address _vault,
        address _toToken,
        uint256 _amount
    )
        external
    {
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);
            ILiquidityGaugeV2(_gauge).withdraw(_amount);
            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        } else {
            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);
            IVault(_vault).withdraw(_amount, _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        }
    }
}",997
RealWorld_TA_30_Vault_RealWorld_20240803234724.log,30,Vault,232009,5128,237137,166.0,1.262605,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./VaultToken.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/ExtendedIERC20.sol"";

/**
 * @title Vault
 * @notice The vault is where users deposit and withdraw
 * like-kind assets that have been added by governance.
 */
contract Vault is VaultToken, IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;

    // Strategist-updated variables
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    /**
     * @param _name The name of the vault token for depositors
     * @param _symbol The symbol of the vault token for depositors
     * @param _manager The address of the vault manager contract
     */
    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        VaultToken(_name, _symbol)
    {
        manager = IManager(_manager);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the value of this vault's gauge
     * @dev Allow to be unset with the zero address
     * @param _gauge The address of the gauge
     */
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    /**
     * @notice Sets the value for min
     * @dev min is the minimum percent of funds to keep small withdrawals cheap
     * @param _min The new min value
     */
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    /**
     * @notice Sets the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    /**
     * @notice Swaps tokens held within the vault
     * @param _token0 The token address to swap out
     * @param _token1 The token address to to
     * @param _expectedAmount The expected amount of _token1 to receive
     */
    function swap(
        address _token0,
        address _token1,
        uint256 _expectedAmount
    )
        external
        override
        notHalted
        onlyStrategist
        returns (uint256 _balance)
    {
        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));
        _balance = IERC20(_token0).balanceOf(address(this));
        IERC20(_token0).safeTransfer(address(_converter), _balance);
        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn(
        address _token,
        address _strategy
    )
        external
        override
        checkToken(_token)
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available(_token);
            IERC20(_token).safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, _token, _balance);
            emit Earn(_token, _balance);
        }
    }

    /**
     * USER-FACING FUNCTIONS
     */

    /**
     * @notice Deposits the given token into the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
     function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the vault
     * @dev Users must approve the vault to spend their stablecoin
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultiple(
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
        override
        returns (uint256 _shares)
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i; i < _amounts.length; i++) {
            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));
        }
    }

    /**
     * @notice Withdraws an amount of shares to a given output token
     * @param _shares The amount of shares to withdraw
     * @param _output The address of the token to receive
     */
    function withdraw(
        uint256 _shares,
        address _output
    )
        public
        override
        checkToken(_output)
    {
        uint256 _amount = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = IERC20(_output).balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(_output, _toWithdraw);
            }
            uint256 _after = IERC20(_output).balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        IERC20(_output).safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraw the entire balance for an account
     * @param _output The address of the desired token to receive
     */
    function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }

    /**
     * VIEWS
     */

    /**
     * @notice Returns the amount of tokens available to be sent to strategies
     * @dev Custom logic in here for how much the vault allows to be borrowed
     * @dev Sets minimum required on-hand to keep small withdrawals cheap
     * @param _token The address of the token
     */
    function available(
        address _token
    )
        public
        view
        override
        returns (uint256)
    {
        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);
    }

    /**
     * @notice Returns the total balance of the vault, including strategies
     */
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    /**
     * @notice Returns the balance of allowed tokens present on the vault only
     */
    function balanceOfThis()
        public
        view
        returns (uint256 _balance)
    {
        address[] memory _tokens = manager.getTokens(address(this));
        for (uint8 i; i < _tokens.length; i++) {
            address _token = _tokens[i];
            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
        }
    }

    /**
     * @notice Returns the rate of vault shares
     */
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() > 0) {
            return balance().mul(1e18).div(totalSupply());
        } else {
            return balance();
        }
    }

    /**
     * @notice Returns an array of the tokens for this vault
     */
    function getTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return manager.getTokens(address(this));
    }

    /**
     * @notice Returns the fee for withdrawing the given amount
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier checkToken(address _token) {
        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), ""!_token"");
        _;
    }

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2561
RealWorld_TA_30_PickleMasterChef_RealWorld_20240804005630.log,30,PickleMasterChef,27028,1717,28745,83.0,0.16948,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface PickleMasterChef {
    function deposit(uint _poolId, uint _amount) external;
    function withdraw(uint _poolId, uint _amount) external;
    function pendingPickle(uint _pid, address _user) external view returns (uint);
    function userInfo(uint _pid, address _user) external view returns (uint amount, uint rewardDebt);
    function emergencyWithdraw(uint _pid) external;
}",103
RealWorld_TA_30_IRewards_RealWorld_20240804004153.log,30,IRewards,23130,1167,24297,83.0,0.13899,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface IRewards {
    function balanceOf(address) external view returns (uint256);
    function earned(address) external view returns (uint256);
    function totalSupply() external view returns (uint256);
}",59
RealWorld_TA_30_Controller_RealWorld_20240804000829.log,30,Controller,423733,6601,430334,198.0,2.250685,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";

/**
 * @title Controller
 * @notice This controller allows multiple strategies to be used
 * for a single vault supporting multiple tokens.
 */
contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    // vault => Vault
    mapping(address => VaultDetail) internal _vaultDetails;
    // strategy => vault
    mapping(address => address) internal _vaultStrategies;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(address indexed strategy);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy);

    /**
     * @notice Logged when strategies are reordered for a vault
     */
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    /**
     * @param _manager The address of the manager
     */
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The cap of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        // checking if strategy is already added
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        // get the index of the newly added strategy
        uint256 index = _vaultDetails[_vault].strategies.length;
        // ensure we haven't added too many strategies already
        require(index < maxStrategies, ""!maxStrategies"");
        // push the strategy to the array of strategies
        _vaultDetails[_vault].strategies.push(_strategy);
        // set the cap
        _vaultDetails[_vault].caps[_strategy] = _cap;
        // set the index
        _vaultDetails[_vault].index[_strategy] = index;
        // store the mapping of strategy to the vault
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            // add it to the harvester
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    /**
     * @notice Withdraws token from a strategy to the treasury address as returned by the manager
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     */
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    /**
     * @notice Withdraws token from the controller to the treasury
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    /**
     * @notice Removes a strategy for a given token
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the index of the strategy to remove
        uint256 index = vaultDetail.index[_strategy];
        // get the index of the last strategy
        uint256 tail = vaultDetail.strategies.length.sub(1);
        // get the address of the last strategy
        address replace = vaultDetail.strategies[tail];
        // replace the removed strategy with the tail
        vaultDetail.strategies[index] = replace;
        // set the new index for the replaced strategy
        vaultDetail.index[replace] = index;
        // remove the duplicate replaced strategy
        vaultDetail.strategies.pop();
        // remove the strategy's index
        delete vaultDetail.index[_strategy];
        // remove the strategy's cap
        delete vaultDetail.caps[_strategy];
        // remove the strategy's balance
        delete vaultDetail.balances[_strategy];
        // remove the mapping of strategy to the vault
        delete _vaultStrategies[_strategy];
        // pull funds from the removed strategy to the vault
        IStrategy(_strategy).withdrawAll();
        // remove the strategy from the harvester
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    /**
     * @notice Reorders two strategies for a given vault
     * @param _vault The address of the vault
     * @param _strategy1 The address of the first strategy
     * @param _strategy2 The address of the second strategy
     */
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the indexes of the strategies
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        // set the new addresses at their indexes
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        // update indexes
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    /**
     * @notice Sets/updates the cap of a strategy for a vault
     * @dev If the balance of the strategy is greater than the new cap (except if
     * the cap is 0), then withdraw the difference from the strategy to the vault.
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The new cap of the strategy
     */
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        // send excess funds (over cap) back to the vault
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    /**
     * @notice Sets/updates the converter for a given vault
     * @param _vault The address of the vault
     * @param _converter The address of the converter
     */
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    /**
     * @notice Sets/updates the global invest enabled flag
     * @param _investEnabled The new bool of the invest enabled flag
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    /**
     * @notice Sets/updates the maximum number of strategies for a vault
     * @param _maxStrategies The new value of the maximum strategies
     */
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    /**
     * @notice Withdraws all funds from a strategy
     * @param _strategy The address of the strategy
     * @param _convert The token address to convert to
     */
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Harvests the specified strategy
     * @param _strategy The address of the strategy
     */
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    /**
     * VAULT-ONLY FUNCTIONS
     */

    /**
     * @notice Invests funds into a strategy
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     * @param _amount The amount that will be invested
     */
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault(_token)
    {
        // get the want token of the strategy
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            // TODO: do estimation for received
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        // call the strategy deposit function
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    /**
     * @notice Withdraws funds from a strategy
     * @dev If the withdraw amount is greater than the first strategy given
     * by getBestStrategyWithdraw, this function will loop over strategies
     * until the requested amount is met.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault(_token)
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(_token, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            // getBestStrategyWithdraw will return arrays larger than needed
            // if this happens, simply exit the loop
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                // TODO: do estimation for received
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the rough balance of the sum of all strategies for a given vault
     * @dev This function is optimized to prevent looping over all strategy balances,
     * and instead the controller tracks the earn, withdraw, and harvest amounts.
     */
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    /**
     * @notice Returns the converter assigned for the given vault
     * @param _vault Address of the vault
     */
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    /**
     * @notice Returns the cap of a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    /**
     * @notice Returns whether investing is enabled for the calling vault
     * @dev Should be called by the vault
     */
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    /**
     * @notice Returns all the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    /**
     * @notice Returns the length of the strategies of the calling vault
     * @dev This function is expected to be called by a vault
     */
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    /**
     * INTERNAL FUNCTIONS
     */

    /**
     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from
     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays
     * from this function will always be the same length as the amount of strategies for
     * a token. Check that _strategies[i] != address(0) when consuming to know when to
     * break out of the loop.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function getBestStrategyWithdraw(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        // get the length of strategies for a single token
        address _vault = manager.vaults(_token);
        uint256 k = _vaultDetails[_vault].strategies.length;
        // initialize fixed-length memory arrays
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        // scan forward from the the beginning of strategies
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            // get the balance of the strategy
            _balance = _vaultDetails[_vault].balances[_strategy];
            // if the strategy doesn't have the balance to cover the withdraw
            if (_balance < _amount) {
                // withdraw what we can and add to the _amounts
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                // stop scanning if the balance is more than the withdraw amount
                _amounts[i] = _amount;
                break;
            }
        }
    }

    /**
     * @notice Updates the stored balance of a given strategy for a vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    /**
     * MODIFIERS
     */

    /**
     * @notice Reverts if the protocol is halted
     */
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    /**
     * @notice Reverts if the caller is not governance
     */
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    /**
     * @notice Reverts if the strategy is not allowed in the manager
     */
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the vault for the given token
     */
    modifier onlyVault(address _token) {
        require(msg.sender == manager.vaults(_token), ""!vault"");
        _;
    }
}",4847
RealWorld_TA_30_IMerkleDistributor_RealWorld_20240803225130.log,30,IMerkleDistributor,35374,1730,37104,85.0,0.21147,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.6.0;

// Allows anyone to claim a token if they exist in a merkle root.
interface IMerkleDistributor {
    // Returns the address of the token distributed by this contract.
    function token() external view returns (address);
    // Returns the merkle root of the merkle tree containing account balances available to claim.
    function merkleRoot() external view returns (bytes32);
    // Returns true if the index has been marked claimed.
    function isClaimed(uint256 index) external view returns (bool);
    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.
    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external;

    // This event is triggered whenever a call to #claim succeeds.
    event Claimed(uint256 index, address account, uint256 amount);
}",200
RealWorld_TA_30_ERC677Receiver_RealWorld_20240804005039.log,30,ERC677Receiver,22128,1348,23476,84.0,0.1376,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

abstract contract ERC677Receiver {
  function onTokenTransfer(address _sender, uint _value, bytes memory _data) public virtual;
}",44
RealWorld_TA_30_IManager_RealWorld_20240804002852.log,30,IManager,46919,1768,48687,88.0,0.269955,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IManager {
    function addToken(address, address) external;
    function allowedControllers(address) external view returns (bool);
    function allowedConverters(address) external view returns (bool);
    function allowedStrategies(address) external view returns (bool);
    function allowedTokens(address) external view returns (bool);
    function allowedVaults(address) external view returns (bool);
    function controllers(address) external view returns (address);
    function getHarvestFeeInfo() external view returns (address, address, uint256);
    function getTokens(address) external view returns (address[] memory);
    function governance() external view returns (address);
    function halted() external view returns (bool);
    function harvester() external view returns (address);
    function insuranceFee() external view returns (uint256);
    function insurancePool() external view returns (address);
    function insurancePoolFee() external view returns (uint256);
    function pendingStrategist() external view returns (address);
    function removeToken(address, address) external;
    function stakingPool() external view returns (address);
    function stakingPoolShareFee() external view returns (uint256);
    function strategist() external view returns (address);
    function tokens(address, uint256) external view returns (address);
    function treasury() external view returns (address);
    function treasuryFee() external view returns (uint256);
    function vaults(address) external view returns (address);
    function withdrawalProtectionFee() external view returns (uint256);
    function yaxis() external view returns (address);
}",337
RealWorld_TA_30_MockYearnV2_RealWorld_20240803231549.log,30,MockYearnV2,54628,4115,58743,118.0,0.35544,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockYearnV2 is ERC20 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public underlying;

    constructor(string memory name, string memory symbol, IERC20 _underlying) public ERC20(name, symbol) {
        underlying = _underlying;
    }

    function balance() public view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    function pricePerShare() public view returns (uint256) {
        return balance().mul(1e18).div(totalSupply());
    }

    function deposit() external returns (uint256) {
        uint256 _balance = underlying.balanceOf(msg.sender);
        return deposit(_balance);
    }

    function deposit(uint256 _amount) public returns (uint256) {
        uint256 underlyingTotal = balance();
        uint256 _before = balance();
        underlying.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = balance();
        _amount = _after.sub(_before);
        uint256 shares;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(underlyingTotal);
        }
        _mint(msg.sender, shares);
        return shares;
    }

    function withdraw() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint256 _amount) public {
        uint256 ret = (balance().mul(_amount)).div(totalSupply());
        _burn(msg.sender, _amount);
        underlying.safeTransfer(msg.sender, ret);
    }

    function token() external view returns (address) {
        return address(underlying);
    }
}",433
RealWorld_TA_30_Curve_RealWorld_20240804011525.log,30,Curve,30996,2135,33131,88.0,0.19768,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface ICurveFi {
  function get_virtual_price() external view returns (uint);
  function add_liquidity(
    uint256[4] calldata amounts,
    uint256 min_mint_amount
  ) external;
  function remove_liquidity_imbalance(
    uint256[4] calldata amounts,
    uint256 max_burn_amount
  ) external;
  function remove_liquidity(
    uint256 _amount,
    uint256[4] calldata amounts
  ) external;
  function exchange(
    int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount
  ) external;
}",151
RealWorld_TA_30_LegacyController_RealWorld_20240804001149.log,30,LegacyController,161555,6057,167612,151.0,0.928915,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/ILegacyController.sol"";
import ""../interfaces/ILegacyVault.sol"";
import ""../interfaces/IManager.sol"";
import ""../interfaces/IVault.sol"";

contract LegacyController is ILegacyController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    uint256 public constant MAX = 10000;

    IManager public immutable manager;
    IERC20 public immutable token;
    address public immutable metavault;

    bool public investEnabled;
    IVault public vault;
    IConverter public converter;

    event Earn(uint256 amount);
    event Withdraw(uint256 amount);

    /**
     * @param _manager The vault manager contract
     * @param _metavault The legacy MetaVault contract
     */
    constructor(
        address _manager,
        address _metavault
    )
        public
    {
        manager = IManager(_manager);
        metavault = _metavault;
        address _token = ILegacyVault(_metavault).want();
        token = IERC20(_token);
    }

    /**
     * @notice Sets the vault address
     * @param _vault The v3 vault address
     */
    function setVault(
        address _vault
    )
        external
        onlyStrategist
    {
        IVault cachedVault = vault;
        if (address(cachedVault) != address(0)) {
            cachedVault.withdrawAll(address(token));
            token.safeTransfer(metavault, token.balanceOf(address(this)));
        }
        vault = IVault(_vault);
    }

    /**
     * @notice Sets the converter address
     * @param _converter The address of the converter
     */
    function setConverter(
        address _converter
    )
        external
        onlyStrategist
    {
        converter = IConverter(_converter);
    }

    /**
     * @notice Sets the investEnabled status flag
     * @param _investEnabled Bool for enabling investment
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        onlyStrategist
    {
        investEnabled = _investEnabled;
    }

    /**
     * @notice Recovers stuck tokens sent directly to this contract
     * @dev This only allows the strategist to recover unsupported tokens
     * @param _token The address of the token
     * @param _receiver The address to receive the tokens
     */
    function recoverUnsupportedToken(
        address _token,
        address _receiver
    )
        external
        onlyStrategist
    {
        require(_token != address(token), ""!_token"");
        IERC20(_token).safeTransfer(_receiver, IERC20(_token).balanceOf(address(this)));
    }

    /**
     * @notice Returns the balance of the given token on the vault
     * @param _token The address of the token
     */
    function balanceOf(
        address _token
    )
        external
        view
        onlyToken(_token)
        returns (uint256)
    {
        return token.balanceOf(address(this))
                    .add(IERC20(address(vault)).balanceOf(address(this)));
    }

    /**
     * @notice Returns the withdraw fee for withdrawing the given token and amount
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        address _token,
        uint256 _amount
    )
        external
        view
        onlyToken(_token)
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    /**
     * @notice Withdraws the amount from the v3 vault
     * @param _amount The amount to withdraw
     */
    function withdraw(
        address,
        uint256 _amount
    )
        external
        onlyEnabledVault
        onlyMetaVault
    {
        uint256 _balance = token.balanceOf(address(this));
        // happy path exits without calling back to the vault
        if (_balance >= _amount) {
            token.safeTransfer(metavault, _amount);
            emit Withdraw(_amount);
        } else {
            uint256 _toWithdraw = _amount.sub(_balance);
            IVault cachedVault = vault;
            // convert to vault shares
            address[] memory _tokens = cachedVault.getTokens();
            require(_tokens.length > 0, ""!_tokens"");
            // get the amount of the token that we would be withdrawing
            uint256 _expected = converter.expected(address(token), _tokens[0], _toWithdraw);
            uint256 _shares = _expected.mul(1e18).div(cachedVault.getPricePerFullShare());
            cachedVault.withdraw(_shares, _tokens[0]);
            _balance = IERC20(_tokens[0]).balanceOf(address(this));
            IERC20(_tokens[0]).safeTransfer(address(converter), _balance);
            // TODO: calculate expected
            converter.convert(_tokens[0], address(token), _balance, 1);
            emit Withdraw(token.balanceOf(address(this)));
            token.safeTransfer(metavault, token.balanceOf(address(this)));
        }
    }

    /**
     * @notice Only emits the Earn event
     * @dev This is a dummy function to allow the MetaVault to call
     * @param _amount The amount to earn
     */
    function earn(
        address,
        uint256 _amount
    )
        external
        onlyMetaVault
    {
        emit Earn(_amount);
    }

    /**
     * @notice Deposits the given token to the v3 vault
     * @param _toToken The address to convert to
     * @param _expected The expected amount to deposit after conversion
     */
    function legacyDeposit(
        address _toToken,
        uint256 _expected
    )
        external
        override
        onlyEnabledConverter
        onlyHarvester
    {
        if (_toToken != address(token)) {
            uint256 _amount = token.balanceOf(address(this));
            token.safeTransfer(address(converter), _amount);
            converter.convert(address(token), _toToken, _amount, _expected);
        }
        IERC20(_toToken).safeApprove(address(vault), 0);
        IERC20(_toToken).safeApprove(address(vault), type(uint256).max);
        vault.deposit(_toToken, IERC20(_toToken).balanceOf(address(this)));
    }

    /**
     * @notice Reverts if the converter is not set
     */
    modifier onlyEnabledConverter() {
        require(address(converter) != address(0), ""!converter"");
        _;
    }

    /**
     * @notice Reverts if the vault is not set
     */
    modifier onlyEnabledVault() {
        require(address(vault) != address(0), ""!vault"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the MetaVault
     */
    modifier onlyMetaVault() {
        require(msg.sender == metavault, ""!metavault"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    /**
     * @notice Reverts if the given token is not the stored token
     */
    modifier onlyToken(address _token) {
        require(_token == address(token), ""!_token"");
        _;
    }
}",1696
RealWorld_TA_30_MockStabilizePool_RealWorld_20240803232354.log,30,MockStabilizePool,61032,4064,65096,120.0,0.38644,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/Stabilize.sol"";

contract MockStabilizePool is IZPAPool {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 public lpToken;
    IERC20 public rewardToken;
    uint256 public rewardRate;

    struct UserInfo {
        uint256 amount;
        uint256 rewardDebt;
        uint256 unclaimedReward;
    }

    mapping(uint256 => mapping(address => UserInfo)) private userInfo;
    mapping(uint256 => address) public override poolTokenAddress;

    constructor(
        address _lpToken,
        address _rewardToken,
        uint256 _rewardRate
    ) public {
        lpToken = IERC20(_lpToken);
        rewardToken = IERC20(_rewardToken);
        rewardRate = _rewardRate;
    }

    function deposit(uint256 _pid, uint256 _amount) external override {
        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.add(_amount);
        lpToken.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function withdraw(uint256 _pid, uint256 _amount) public override {
        userInfo[_pid][msg.sender].amount = userInfo[_pid][msg.sender].amount.sub(_amount);
        lpToken.safeTransfer(msg.sender, _amount);
    }

    function exit(uint256 _pid, uint256 _amount) external override {
        withdraw(_pid, _amount);
        getReward(_pid);
    }

    function getReward(uint256 _pid) public override {
        uint256 _amount = rewardEarned(_pid, msg.sender);
        rewardToken.safeTransfer(msg.sender, _amount);
    }

    function rewardEarned(uint256 _pid, address _user) public view override returns (uint256) {
        return poolBalance(_pid, _user).mul(rewardRate).div(1000);
    }

    function poolBalance(uint256 _pid, address _user) public view override returns (uint256) {
        return userInfo[_pid][_user].amount;
    }
}",492
RealWorld_TA_30_IMetaVault_RealWorld_20240803233835.log,30,IMetaVault,39234,2294,41528,93.0,0.24205,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface IMetaVault {
    function balance() external view returns (uint);
    function setController(address _controller) external;
    function claimInsurance() external;
    function token() external view returns (address);
    function available() external view returns (uint);
    function withdrawFee(uint _amount) external view returns (uint);
    function earn() external;
    function calc_token_amount_deposit(uint[3] calldata amounts) external view returns (uint);
    function calc_token_amount_withdraw(uint _shares, address _output) external view returns (uint);
    function convert_rate(address _input, uint _amount) external view returns (uint);
    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external;
    function harvest(address reserve, uint amount) external;
    function withdraw(uint _shares, address _output) external;
    function want() external view returns (address);
    function getPricePerFullShare() external view returns (uint);
}",241
RealWorld_TA_30_Uniswap_RealWorld_20240804010656.log,30,Uniswap,21631,1429,23060,79.0,0.136735,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface Uni {
    function swapExactTokensForTokens(uint, uint, address[] calldata, address, uint) external;
}",42
RealWorld_TA_30_MockERC677_RealWorld_20240803224819.log,30,MockERC677,60229,2932,63161,105.0,0.359785,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""../../vendor/LinkToken/token/LinkERC20.sol"";
import ""../../vendor/LinkToken/ERC677Token.sol"";

contract MockERC677 is LinkERC20, ERC677Token {

    constructor(
        string memory _name,
        string memory _symbol
    )
        public
        ERC20(_name, _symbol)
    {}

    function mint(
        address _to,
        uint256 _amount
    )
        external
    {
        _mint(_to, _amount);
    }

    function faucet(
        uint256 _amount
    )
        external
    {
        _mint(msg.sender, _amount);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount)
        internal
        override
        virtual
        validAddress(recipient)
    {
        super._transfer(sender, recipient, amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount)
        internal
        override
        virtual
        validAddress(spender)
    {
        super._approve(owner, spender, amount);
    }


    // MODIFIERS

    modifier validAddress(address _recipient) {
        require(_recipient != address(this), ""!validAddress"");
        _;
    }
}",486
RealWorld_TA_30_Chainlink_RealWorld_20240804011958.log,30,Chainlink,43735,1629,45364,86.0,0.251255,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface AggregatorInterface {
      function latestAnswer() external view returns (int256);
      function latestTimestamp() external view returns (uint256);
      function latestRound() external view returns (uint256);
      function getAnswer(uint256 roundId) external view returns (int256);
      function getTimestamp(uint256 roundId) external view returns (uint256);
}

interface AggregatorV3Interface {

      function decimals() external view returns (uint8);
      function description() external view returns (string memory);
      function version() external view returns (uint256);

      // getRoundData and latestRoundData should both raise ""No data present""
      // if they do not have data to report, instead of returning unset values
      // which could be misinterpreted as actual reported values.
      function getRoundData(uint80 _roundId)
            external
            view
            returns (
                  uint80 roundId,
                  int256 answer,
                  uint256 startedAt,
                  uint256 updatedAt,
                  uint80 answeredInRound
            );
      function latestRoundData()
            external
            view
            returns (
                  uint80 roundId,
                  int256 answer,
                  uint256 startedAt,
                  uint256 updatedAt,
                  uint80 answeredInRound
            );
}

interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface
{
}",295
RealWorld_TA_30_MinterWrapper_RealWorld_20240803235722.log,30,MinterWrapper,65683,3161,68844,122.0,0.391635,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract MinterWrapper is Ownable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 public immutable token;
    address public minter;
    uint256 public rate;

    event Write();

    constructor(
        address _token
    )
        public
        Ownable()
    {
        token = IERC20(_token);
        rate = 1e12;
    }

    /**
     * @notice Sets the address of the minter contract
     * @dev can only be set once
     * @param _minter The address of the minter
     */
    function setMinter(
        address _minter
    )
        external
        onlyOwner
    {
        require(minter == address(0), ""minter"");
        require(_minter != address(0), ""!_minter"");
        minter = _minter;
    }

    /**
     * @notice Sets the emission rate
     * @param _rate The rate of reward token emissions
     */
    function setRate(
        uint256 _rate
    )
        external
        onlyOwner
    {
        rate = _rate;
    }

    /**
     * @notice Mints the given amount to the given account
     * @dev Requires this contract to be funded with the reward token
     * @param _account The address to receive the reward tokens
     * @param _amount The amount of tokens to send the receiver
     */
    function mint(
        address _account,
        uint256 _amount
    )
        external
        returns (bool)
    {
        require(msg.sender == minter, ""!minter"");
        token.safeTransfer(_account, _amount);
        return true;
    }

    /**
     * @notice Returns the current block timestamp
     * @dev Emits Write event to prevent from being a view function
     */
    function future_epoch_time_write()
        external
        returns (uint256)
    {
        emit Write();
        // solhint-disable-next-line not-rely-on-time
        return block.timestamp;
    }

    /**
     * @notice Returns the amount of reward tokens on this contract
     */
    function available_supply()
        public
        view
        returns (uint256)
    {
        return token.balanceOf(address(this));
    }
}",569
RealWorld_TA_30_ICurve3Pool_RealWorld_20240804003155.log,30,ICurve3Pool,36853,2082,38935,94.0,0.225905,"// SPDX-License-Identifier: MIT
// solhint-disable func-name-mixedcase
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

interface ICurve3Pool {
    function get_virtual_price() external view returns (uint);
    function balances(uint) external view returns (uint);
    function get_dy(int128 i, int128 j, uint dx) external view returns (uint dy);
    function exchange(int128 i, int128 j, uint dx, uint min_dy) external;
    function add_liquidity(uint[3] calldata amounts, uint min_mint_amount) external;
    function remove_liquidity(uint _amount, uint[3] calldata amounts) external;
    function remove_liquidity_one_coin(uint _token_amount, int128 i, uint min_amount) external;
    function calc_token_amount(uint[3] calldata amounts, bool deposit) external view returns (uint);
    function calc_withdraw_one_coin(uint _token_amount, int128 i) external view returns (uint);
}",217
RealWorld_TA_30_IERC677_RealWorld_20240803225258.log,30,IERC677,23181,1387,24568,81.0,0.143645,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IERC677 is IERC20 {
    function transferAndCall(address, address, uint256, bytes calldata) external returns (bool);
}",64
RealWorld_TA_30_FlamIncome_RealWorld_20240804005504.log,30,FlamIncome,24495,1430,25925,84.0,0.151075,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IVault {
    function token() external view returns (address);
    function priceE18() external view returns (uint);
    function deposit(uint) external;
    function withdraw(uint) external;
    function depositAll() external;
    function withdrawAll() external;
}",71
RealWorld_TA_30_MockIdleToken_RealWorld_20240803231749.log,30,MockIdleToken,53794,4040,57834,115.0,0.34977,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/Idle.sol"";

contract MockIdleToken is ERC20, IIdleTokenV3_1 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address public override token;
    IERC20 public rewardToken;
    IERC20 public govToken;

    constructor(
        string memory _name,
        string memory _symbol,
        address _underlyingAsset,
        address _rewardToken,
        address _govToken
    )
        public
        ERC20(_name, _symbol)
    {
        token = _underlyingAsset;
        rewardToken = ERC20(_rewardToken);
        govToken = ERC20(_govToken);
    }

    function mintIdleToken(uint256 _amount, bool, address) external override returns (uint256 mintedTokens) {
        mintedTokens = _amount.mul(1e18).div(tokenPrice());
        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);
        _mint(msg.sender, mintedTokens);
    }

    function redeemIdleToken(uint256 _amount) external override returns (uint256 redeemedTokens) {
        uint256 price = tokenPrice();
        redeemedTokens = _amount.mul(price).div(1e18);
        _burn(msg.sender, _amount);
        rewardToken.safeTransfer(msg.sender, 10e18);
        govToken.safeTransfer(msg.sender, 5e18);
        IERC20(token).safeTransfer(msg.sender, redeemedTokens);
    }

    function tokenPrice() public view override returns (uint256) {
        return 2e18; // 1 idleDAI = 2 DAI
    }
}",424
RealWorld_TA_30_IController_RealWorld_20240803233706.log,30,IController,28985,1566,30551,87.0,0.176245,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IController {
    function balanceOf(address) external view returns (uint256);
    function earn(address, uint256) external;
    function investEnabled() external view returns (bool);
    function harvestStrategy(address) external;
    function strategyTokens(address) external returns (address);
    function vaults(address) external view returns (address);
    function want(address) external view returns (address);
    function withdraw(address, uint256) external;
    function withdrawFee(address, uint256) external view returns (uint256);
}",123
RealWorld_TA_30_MerkleDistributor_RealWorld_20240803224641.log,30,MerkleDistributor,54820,2115,56935,96.0,0.3164,"// SPDX-License-Identifier: UNLICENSED
// solhint-disable
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/cryptography/MerkleProof.sol"";
import ""./interfaces/IMerkleDistributor.sol"";

contract MerkleDistributor is IMerkleDistributor {
    address public immutable override token;
    bytes32 public immutable override merkleRoot;

    // This is a packed array of booleans.
    mapping(uint256 => uint256) private claimedBitMap;

    constructor(address token_, bytes32 merkleRoot_) public {
        token = token_;
        merkleRoot = merkleRoot_;
    }

    function isClaimed(uint256 index) public view override returns (bool) {
        uint256 claimedWordIndex = index / 256;
        uint256 claimedBitIndex = index % 256;
        uint256 claimedWord = claimedBitMap[claimedWordIndex];
        uint256 mask = (1 << claimedBitIndex);
        return claimedWord & mask == mask;
    }

    function _setClaimed(uint256 index) private {
        uint256 claimedWordIndex = index / 256;
        uint256 claimedBitIndex = index % 256;
        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);
    }

    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {
        require(!isClaimed(index), 'MerkleDistributor: Drop already claimed.');

        // Verify the merkle proof.
        bytes32 node = keccak256(abi.encodePacked(index, account, amount));
        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');

        // Mark it claimed and send the token.
        _setClaimed(index);
        require(IERC20(token).transfer(account, amount), 'MerkleDistributor: Transfer failed.');

        emit Claimed(index, account, amount);
    }
}",442
RealWorld_TA_30_BaseStrategy_RealWorld_20240804000330.log,30,BaseStrategy,189038,3837,192875,149.0,1.02193,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/IStableSwap3Pool.sol"";
import ""../interfaces/ISwap.sol"";
import ""../interfaces/IManager.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IController.sol"";

/**
 * @title BaseStrategy
 * @notice The BaseStrategy is an abstract contract which all
 * yAxis strategies should inherit functionality from. It gives
 * specific security properties which make it hard to write an
 * insecure strategy.
 * @notice All state-changing functions implemented in the strategy
 * should be internal, since any public or externally-facing functions
 * are already handled in the BaseStrategy.
 * @notice The following functions must be implemented by a strategy:
 * - function _deposit() internal virtual;
 * - function _harvest() internal virtual;
 * - function _withdraw(uint256 _amount) internal virtual;
 * - function _withdrawAll() internal virtual;
 * - function balanceOfPool() public view override virtual returns (uint256);
 */
abstract contract BaseStrategy is IStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    uint256 public constant ONE_HUNDRED_PERCENT = 10000;

    address public immutable override want;
    address public immutable override weth;
    address public immutable controller;
    IManager public immutable override manager;
    string public override name;
    ISwap public override router;

    /**
     * @param _controller The address of the controller
     * @param _manager The address of the manager
     * @param _want The desired token of the strategy
     * @param _weth The address of WETH
     * @param _router The address of the router for swapping tokens
     */
    constructor(
        string memory _name,
        address _controller,
        address _manager,
        address _want,
        address _weth,
        address _router
    ) public {
        name = _name;
        want = _want;
        controller = _controller;
        manager = IManager(_manager);
        weth = _weth;
        router = ISwap(_router);
        IERC20(_weth).safeApprove(address(_router), type(uint256).max);
    }

    /**
     * GOVERNANCE-ONLY FUNCTIONS
     */

    /**
     * @notice Approves a token address to be spent by an address
     * @param _token The address of the token
     * @param _spender The address of the spender
     * @param _amount The amount to spend
     */
    function approveForSpender(
        IERC20 _token,
        address _spender,
        uint256 _amount
    )
        external
    {
        require(msg.sender == manager.governance(), ""!governance"");
        _token.safeApprove(_spender, 0);
        _token.safeApprove(_spender, _amount);
    }

    /**
     * @notice Sets the address of the ISwap-compatible router
     * @param _router The address of the router
     */
    function setRouter(
        address _router
    )
        external
    {
        require(msg.sender == manager.governance(), ""!governance"");
        router = ISwap(_router);
        IERC20(weth).safeApprove(address(_router), 0);
        IERC20(weth).safeApprove(address(_router), type(uint256).max);
    }

    /**
     * CONTROLLER-ONLY FUNCTIONS
     */

    /**
     * @notice Deposits funds to the strategy's pool
     */
    function deposit()
        external
        override
        onlyController
    {
        _deposit();
    }

    /**
     * @notice Harvest funds in the strategy's pool
     */
    function harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        onlyController
    {
        _harvest(_estimatedWETH, _estimatedYAXIS);
    }

    /**
     * @notice Sends stuck want tokens in the strategy to the controller
     */
    function skim()
        external
        override
        onlyController
    {
        IERC20(want).safeTransfer(controller, balanceOfWant());
    }

    /**
     * @notice Sends stuck tokens in the strategy to the controller
     * @param _asset The address of the token to withdraw
     */
    function withdraw(
        address _asset
    )
        external
        override
        onlyController
    {
        require(want != _asset, ""want"");

        IERC20 _assetToken = IERC20(_asset);
        uint256 _balance = _assetToken.balanceOf(address(this));
        _assetToken.safeTransfer(controller, _balance);
    }

    /**
     * @notice Initiated from a vault, withdraws funds from the pool
     * @param _amount The amount of the want token to withdraw
     */
    function withdraw(
        uint256 _amount
    )
        external
        override
        onlyController
    {
        uint256 _balance = balanceOfWant();
        if (_balance < _amount) {
            _amount = _withdrawSome(_amount.sub(_balance));
            _amount = _amount.add(_balance);
        }

        IERC20(want).safeTransfer(controller, _amount);
    }

    /**
     * @notice Withdraws all funds from the strategy
     */
    function withdrawAll()
        external
        override
        onlyController
    {
        _withdrawAll();

        uint256 _balance = IERC20(want).balanceOf(address(this));

        IERC20(want).safeTransfer(controller, _balance);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the strategy's balance of the want token plus the balance of pool
     */
    function balanceOf()
        external
        view
        override
        returns (uint256)
    {
        return balanceOfWant().add(balanceOfPool());
    }

    /**
     * PUBLIC VIEW FUNCTIONS
     */

    /**
     * @notice Returns the balance of the pool
     * @dev Must be implemented by the strategy
     */
    function balanceOfPool()
        public
        view
        virtual
        override
        returns (uint256);

    /**
     * @notice Returns the balance of the want token on the strategy
     */
    function balanceOfWant()
        public
        view
        override
        returns (uint256)
    {
        return IERC20(want).balanceOf(address(this));
    }

    /**
     * INTERNAL FUNCTIONS
     */

    function _deposit()
        internal
        virtual;

    function _harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        virtual;

    function _payHarvestFees(
        address _poolToken,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        returns (uint256 _wethBal)
    {
        uint256 _amount = IERC20(_poolToken).balanceOf(address(this));
        _swapTokens(_poolToken, weth, _amount, _estimatedWETH);
        _wethBal = IERC20(weth).balanceOf(address(this));

        if (_wethBal > 0) {
            // get all the necessary variables in a single call
            (
                address yaxis,
                address treasury,
                uint256 treasuryFee
            ) = manager.getHarvestFeeInfo();

            uint256 _fee;

            // pay the treasury with YAX
            if (treasuryFee > 0 && treasury != address(0)) {
                _fee = _wethBal.mul(treasuryFee).div(ONE_HUNDRED_PERCENT);
                _swapTokens(weth, yaxis, _fee, _estimatedYAXIS);
                IERC20(yaxis).safeTransfer(treasury, IERC20(yaxis).balanceOf(address(this)));
            }

            // return the remaining WETH balance
            _wethBal = IERC20(weth).balanceOf(address(this));
        }
    }

    function _swapTokens(
        address _input,
        address _output,
        uint256 _amount,
        uint256 _expected
    )
        internal
    {
        address[] memory path = new address[](2);
        path[0] = _input;
        path[1] = _output;
        router.swapExactTokensForTokens(
            _amount,
            _expected,
            path,
            address(this),
            // The deadline is a hardcoded value that is far in the future.
            1e10
        );
    }

    function _withdraw(
        uint256 _amount
    )
        internal
        virtual;

    function _withdrawAll()
        internal
        virtual;

    function _withdrawSome(
        uint256 _amount
    )
        internal
        returns (uint256)
    {
        uint256 _before = IERC20(want).balanceOf(address(this));
        _withdraw(_amount);
        uint256 _after = IERC20(want).balanceOf(address(this));
        _amount = _after.sub(_before);

        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    modifier onlyController() {
        require(msg.sender == controller, ""!controller"");
        _;
    }
}",2055
RealWorld_TA_30_MockGenericVault_RealWorld_20240803231345.log,30,MockGenericVault,61148,4387,65535,122.0,0.39348,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./MockERC20.sol"";
import ""../interfaces/GenericVault.sol"";

contract MockGenericVault is MockERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    IERC20 public token;

    uint public min = 9500;
    uint public constant max = 10000;

    constructor (address _token) public MockERC20(
        string(abi.encodePacked(""Generic Vault "", ERC20(_token).name())),
        string(abi.encodePacked(""v"", ERC20(_token).symbol())),
        ERC20(_token).decimals()
    ) {
        token = IERC20(_token);
    }

    function balance() public view returns (uint) {
        return token.balanceOf(address(this));
    }

    function available() public view returns (uint) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    function deposit(uint _amount) public {
        uint _pool = balance();
        uint _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint _after = token.balanceOf(address(this));
        _amount = _after.sub(_before);
        uint shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint _shares) public {
        uint r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);
        token.safeTransfer(msg.sender, r);
    }

    function getPricePerFullShare() public view returns (uint) {
        return balance().mul(1e18).div(totalSupply());
    }
}",506
RealWorld_TA_30_MockFlamIncome_RealWorld_20240803230222.log,30,MockFlamIncome,60640,4273,64913,112.0,0.38866,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./MockERC20.sol"";

contract MockFlamIncomeVault is MockERC20 {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    IERC20 public token;

    uint public min = 9500;
    uint public constant max = 10000;

    constructor (address _token) public MockERC20(
        string(abi.encodePacked(""flamincomed "", ERC20(_token).name())),
        string(abi.encodePacked(""f"", ERC20(_token).symbol())),
        ERC20(_token).decimals()
    ) {
        token = IERC20(_token);
    }

    function balance() public view returns (uint) {
        return token.balanceOf(address(this));
    }

    function available() public view returns (uint) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    function deposit(uint _amount) public {
        uint _pool = balance();
        uint _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint _after = token.balanceOf(address(this));
        _amount = _after.sub(_before);
        uint shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint _shares) public {
        uint r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);
        token.safeTransfer(msg.sender, r);
    }

    function priceE18() public view returns (uint) {
        return balance().mul(1e18).div(totalSupply());
    }
}",500
RealWorld_TA_30_YaxisToken_RealWorld_20240803224315.log,30,YaxisToken,69029,1852,70881,94.0,0.382185,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""../vendor/LinkToken/token/LinkERC20.sol"";
import ""../vendor/LinkToken/ERC677Token.sol"";

/**
 * @notice yAxis Token
 * @dev Contract has been copied from:
 * https://github.com/smartcontractkit/LinkToken/blob/master/contracts/v0.6/LinkToken.sol
 * with modifications only made to TOTAL_SUPPLY, NAME, SYMBOL, and the validAddress
 * modifier's revert message.
 */
contract YaxisToken is LinkERC20, ERC677Token {
    uint256 private constant TOTAL_SUPPLY = 11*10**24;
    string private constant NAME = ""yAxis V2"";
    string private constant SYMBOL = ""YAXIS"";

    constructor()
        public
        ERC20(NAME, SYMBOL)
    {
        _onCreate();
    }

    /**
     * @dev Hook that is called when this contract is created.
     * Useful to override constructor behaviour in child contracts (e.g., LINK bridge tokens).
     * @notice Default implementation mints 10**27 tokens to msg.sender
     */
    function _onCreate()
        internal
        virtual
    {
        _mint(msg.sender, TOTAL_SUPPLY);
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount)
        internal
        override
        virtual
        validAddress(recipient)
    {
        super._transfer(sender, recipient, amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
     *
     * This is internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(address owner, address spender, uint256 amount)
        internal
        override
        virtual
        validAddress(spender)
    {
        super._approve(owner, spender, amount);
    }


    // MODIFIERS

    modifier validAddress(address _recipient) {
        require(_recipient != address(this), ""!validAddress"");
        _;
    }
}",598
RealWorld_TA_30_IConverter_RealWorld_20240804003331.log,30,IConverter,27636,1811,29447,94.0,0.1744,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IConverter {
    function manager() external view returns (IManager);
    function convert(
        address _input,
        address _output,
        uint256 _inputAmount,
        uint256 _estimatedOutput
    ) external returns (uint256 _outputAmount);
    function expected(
        address _input,
        address _output,
        uint256 _inputAmount
    ) external view returns (uint256 _outputAmount);
}",110
RealWorld_TA_30_IVaultManager_RealWorld_20240803233320.log,30,IVaultManager,37373,1633,39006,122.0,0.219525,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface IVaultManager {
    function controllers(address) external view returns (bool);
    function getHarvestFeeInfo() external view returns (address, address, uint256, address, uint256, address, uint256);
    function governance() external view returns (address);
    function harvester() external view returns (address);
    function insuranceFee() external view returns (uint256);
    function insurancePool() external view returns (address);
    function insurancePoolFee() external view returns (uint256);
    function stakingPool() external view returns (address);
    function stakingPoolShareFee() external view returns (uint256);
    function strategist() external view returns (address);
    function treasury() external view returns (address);
    function treasuryBalance() external view returns (uint256);
    function treasuryFee() external view returns (uint256);
    function vaults(address) external view returns (bool);
    function withdrawalProtectionFee() external view returns (uint256);
    function yax() external view returns (address);
}",226
RealWorld_TA_30_YaxisVotePower_RealWorld_20240804003634.log,30,YaxisVotePower,70874,3439,74313,113.0,0.42315,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";

import ""./interfaces/IRewards.sol"";
import ""./interfaces/IUniswapV2Pair.sol"";
import ""./interfaces/IVoteProxy.sol"";

contract YaxisVotePower is IVoteProxy {
    using SafeMath for uint256;

    // solhint-disable-next-line const-name-snakecase
    uint8 public constant override decimals = uint8(18);

    IUniswapV2Pair public immutable yaxisEthUniswapV2Pair;
    IERC20 public immutable yaxis;
    IRewards public immutable rewardsYaxis;
    IRewards public immutable rewardsYaxisEth;

    constructor(
        address _yaxis,
        address _rewardsYaxis,
        address _rewardsYaxisEth,
        address _yaxisEthUniswapV2Pair
    )
        public
    {
        yaxis = IERC20(_yaxis);
        rewardsYaxis = IRewards(_rewardsYaxis);
        rewardsYaxisEth = IRewards(_rewardsYaxisEth);
        yaxisEthUniswapV2Pair = IUniswapV2Pair(_yaxisEthUniswapV2Pair);
    }

    function totalSupply()
        external
        view
        override
        returns (uint256)
    {
        return sqrt(yaxis.totalSupply());
    }

    function balanceOf(
        address _voter
    )
        external
        view
        override
        returns (uint256 _balance)
    {
        uint256 _stakeAmount = rewardsYaxisEth.balanceOf(_voter);
        (uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();
        uint256 _supply = yaxisEthUniswapV2Pair.totalSupply();
        _supply = _supply == 0
            ? 1e18
            : _supply;
        uint256 _lpStakingYax = _yaxReserves
            .mul(_stakeAmount)
            .div(_supply)
            .add(rewardsYaxisEth.earned(_voter));
        uint256 _rewardsYaxisAmount = rewardsYaxis.balanceOf(_voter)
            .add(rewardsYaxis.earned(_voter));
        _balance = sqrt(
            yaxis.balanceOf(_voter)
                .add(_lpStakingYax)
                .add(_rewardsYaxisAmount)
        );
    }

    function sqrt(
        uint256 x
    )
        private
        pure
        returns (uint256 y)
    {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        y = y * (10 ** 9);
    }
}",622
RealWorld_TA_30_AlwaysAccess_RealWorld_20240803235927.log,30,AlwaysAccess,31158,1838,32996,98.0,0.19255,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

contract AlwaysAccess {
    mapping(address => bool) private authorized;

    constructor(bool _authorized)
    public
    {
        authorized[msg.sender] = _authorized;
    }

    function setAuthorized(address _address, bool _authorized) external {
        authorized[_address] = _authorized;
    }

    function allowedVaults(address _address) external view returns (bool) {
        return authorized[_address];
    }

    function allowedControllers(address _address) external view returns (bool) {
        return authorized[_address];
    }

    function allowedStrategies(address _address) external view returns (bool) {
        return authorized[_address];
    }
}",148
RealWorld_TA_30_ERC677Token_RealWorld_20240804004735.log,30,ERC677Token,45365,2404,47769,93.0,0.274905,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./token/ERC677.sol"";
import ""./token/ERC677Receiver.sol"";

abstract contract ERC677Token is ERC20, ERC677 {
  /**
   * @dev transfer token to a contract address with additional data if the recipient is a contact.
   * @param _to The address to transfer to.
   * @param _value The amount to be transferred.
   * @param _data The extra data to be passed to the receiving contract.
   */
  function transferAndCall(address _to, uint _value, bytes memory _data)
    public
    override
    virtual
    returns (bool success)
  {
    super.transfer(_to, _value);
    emit Transfer(msg.sender, _to, _value, _data);
    if (isContract(_to)) {
      contractFallback(_to, _value, _data);
    }
    return true;
  }


  // PRIVATE

  function contractFallback(address _to, uint _value, bytes memory _data)
    private
  {
    ERC677Receiver receiver = ERC677Receiver(_to);
    receiver.onTokenTransfer(msg.sender, _value, _data);
  }

  function isContract(address _addr)
    private
    view
    returns (bool hasCode)
  {
    uint length;
    assembly { length := extcodesize(_addr) }
    return length > 0;
  }
}",317
RealWorld_TA_30_MockUniswapRouter_RealWorld_20240803230022.log,30,MockUniswapRouter,82267,4093,86360,117.0,0.493195,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

interface IUniswapRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}

contract MockUniswapRouter is IUniswapRouter {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 univ2LpToken;

    constructor(IERC20 _univ2LpToken) public {
        univ2LpToken = _univ2LpToken;
    }

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) public override returns (uint256[] memory amounts) {
        return _swap(amountIn, amountOutMin, path, to, deadline);
    }

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external override returns (uint256[] memory amounts) {
        return _swap(amountIn, amountOutMin, path, to, deadline);
    }

    function _swap(
        uint256 amountIn,
        uint256,
        address[] calldata path,
        address to,
        uint256
    ) internal returns (uint256[] memory amounts) {
        uint256 amountOut = amountIn.mul(1); // assume 1 INPUT -> 1 OUTPUT
        IERC20 inputToken = IERC20(path[0]);
        IERC20 outputToken = IERC20(path[path.length - 1]);
        inputToken.safeTransferFrom(msg.sender, address(this), amountIn);
        outputToken.safeTransfer(to, amountOut);
        amounts = new uint256[](2);
        amounts[0] = amountIn;
        amounts[1] = amountOut;
    }

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint,
        uint,
        address to,
        uint
    ) external override returns (uint amountA, uint amountB, uint liquidity) {
        amountA = (amountADesired < amountBDesired) ? amountADesired : amountBDesired;
        amountB = amountA;
        liquidity = amountA;
        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amountA);
        IERC20(tokenB).safeTransferFrom(msg.sender, address(this), amountB);
        univ2LpToken.safeTransfer(to, liquidity); // 1A + 1B -> 1LP
    }
}",776
RealWorld_TA_30_ILiquidityGaugeV2_RealWorld_20240804002358.log,30,ILiquidityGaugeV2,23144,1961,25105,101.0,0.15494,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

interface ILiquidityGaugeV2 {
    function set_approve_deposit(address, bool) external;
    function deposit(uint256) external;
    function withdraw(uint256) external;
}",54
RealWorld_TA_30_NativeStrategyCurve3Crv_RealWorld_20240804000107.log,30,NativeStrategyCurve3Crv,112377,4947,117324,141.0,0.660825,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""../../interfaces/Gauge.sol"";
import ""../../interfaces/Balancer.sol"";

import ""../interfaces/ExtendedIERC20.sol"";

import ""./BaseStrategy.sol"";

contract NativeStrategyCurve3Crv is BaseStrategy {
    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route
    address public immutable crv;

    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)
    address public immutable dai;
    address public immutable usdc;
    address public immutable usdt;

    Mintr public immutable crvMintr;
    IStableSwap3Pool public immutable stableSwap3Pool;
    Gauge public immutable gauge; // 3Crv Gauge

    constructor(
        string memory _name,
        address _want,
        address _crv,
        address _weth,
        address _dai,
        address _usdc,
        address _usdt,
        Gauge _gauge,
        Mintr _crvMintr,
        IStableSwap3Pool _stableSwap3Pool,
        address _controller,
        address _manager,
        address _router
    )
        public
        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)
    {
        crv = _crv;
        dai = _dai;
        usdc = _usdc;
        usdt = _usdt;
        stableSwap3Pool = _stableSwap3Pool;
        gauge = _gauge;
        crvMintr = _crvMintr;
        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);
        IERC20(_crv).safeApprove(address(_router), type(uint256).max);
        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);
        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);
    }

    function _deposit()
        internal
        override
    {
        uint256 _wantBal = balanceOfWant();
        if (_wantBal > 0) {
            // deposit [want] to Gauge
            gauge.deposit(_wantBal);
        }
    }

    function _claimReward()
        internal
    {
        crvMintr.mint(address(gauge));
    }

    function _addLiquidity()
        internal
    {
        uint256[3] memory amounts;
        amounts[0] = IERC20(dai).balanceOf(address(this));
        amounts[1] = IERC20(usdc).balanceOf(address(this));
        amounts[2] = IERC20(usdt).balanceOf(address(this));
        stableSwap3Pool.add_liquidity(amounts, 1);
    }

    function getMostPremium()
        public
        view
        returns (address, uint256)
    {
        uint daiBalance = stableSwap3Pool.balances(0);
        // USDC - Supports a change up to the 18 decimal standard
        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));
        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);

        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {
            return (dai, 0);
        }

        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {
            return (usdc, 1);
        }

        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {
            return (usdt, 2);
        }

        return (dai, 0); // If they're somehow equal, we just want DAI
    }

    function _harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        override
    {
        _claimReward();
        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);

        if (_remainingWeth > 0) {
            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to
            _swapTokens(weth, _stableCoin, _remainingWeth, 1);
            _addLiquidity();

            _deposit();
        }
    }

    function _withdrawAll()
        internal
        override
    {
        uint256 _bal = gauge.balanceOf(address(this));
        _withdraw(_bal);
    }

    function _withdraw(
        uint256 _amount
    )
        internal
        override
    {
        gauge.withdraw(_amount);
    }

    function balanceOfPool()
        public
        view
        override
        returns (uint256)
    {
        return gauge.balanceOf(address(this));
    }
}",1121
RealWorld_TA_30_MetaVault_RealWorld_20240803232942.log,30,MetaVault,587034,7432,594466,216.0,3.08381,"// SPDX-License-Identifier: MIT
// solhint-disable

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./IVaultManager.sol"";
import ""./IController.sol"";
import ""./IConverter.sol"";
import ""./IMetaVault.sol"";

/**
 * @title MetaVault (yAxisMetaVault)
 * @notice The metavault is where users deposit and withdraw stablecoins
 * @dev This metavault will pay YAX incentive for depositors and stakers
 * It does not need minter key of YAX. Governance multisig will mint total
 * of 34000 YAX and send into the vault in the beginning
 */
contract MetaVault is ERC20, IMetaVault {
    using Address for address;
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    IERC20[4] public inputTokens; // DAI, USDC, USDT, 3Crv

    IERC20 public token3CRV;
    IERC20 public tokenYAX;

    uint public min = 9500;
    uint public constant max = 10000;

    uint public earnLowerlimit = 5 ether; // minimum to invest is 5 3CRV
    uint public totalDepositCap = 10000000 ether; // initial cap set at 10 million dollar

    address public governance;
    address public controller;
    uint public insurance;
    IVaultManager public vaultManager;
    IConverter public converter;

    bool public acceptContractDepositor = false; // dont accept contract at beginning

    struct UserInfo {
        uint amount;
        uint yaxRewardDebt;
        uint accEarned;
    }

    uint public lastRewardBlock;
    uint public accYaxPerShare;

    uint public yaxPerBlock;

    mapping(address => UserInfo) public userInfo;

    address public treasuryWallet = 0x362Db1c17db4C79B51Fe6aD2d73165b1fe9BaB4a;

    uint public constant BLOCKS_PER_WEEK = 46500;

    // Block number when each epoch ends.
    uint[5] public epochEndBlocks;

    // Reward multipler for each of 5 epoches (epochIndex: reward multipler)
    uint[6] public epochRewardMultiplers = [86000, 64000, 43000, 21000, 10000, 1];

    /**
     * @notice Emitted when a user deposits funds
     */
    event Deposit(address indexed user, uint amount);

    /**
     * @notice Emitted when a user withdraws funds
     */
    event Withdraw(address indexed user, uint amount);

    /**
     * @notice Emitted when YAX is paid to a user
     */
    event RewardPaid(address indexed user, uint reward);

    /**
     * @param _tokenDAI The address of the DAI token
     * @param _tokenUSDC The address of the USDC token
     * @param _tokenUSDT The address of the USDT token
     * @param _token3CRV The address of the 3CRV token
     * @param _tokenYAX The address of the YAX token
     * @param _yaxPerBlock The amount of YAX rewarded per block
     * @param _startBlock The starting block for rewards
     */
    constructor (IERC20 _tokenDAI, IERC20 _tokenUSDC, IERC20 _tokenUSDT, IERC20 _token3CRV, IERC20 _tokenYAX,
        uint _yaxPerBlock, uint _startBlock) public ERC20(""yAxis.io:MetaVault:3CRV"", ""MVLT"") {
        inputTokens[0] = _tokenDAI;
        inputTokens[1] = _tokenUSDC;
        inputTokens[2] = _tokenUSDT;
        inputTokens[3] = _token3CRV;
        token3CRV = _token3CRV;
        tokenYAX = _tokenYAX;
        yaxPerBlock = _yaxPerBlock; // supposed to be 0.000001 YAX (1000000000000 = 1e12 wei)
        lastRewardBlock = (_startBlock > block.number) ? _startBlock : block.number; // supposed to be 11,163,000 (Sat Oct 31 2020 06:30:00 GMT+0)
        epochEndBlocks[0] = lastRewardBlock + BLOCKS_PER_WEEK * 2; // weeks 1-2
        epochEndBlocks[1] = epochEndBlocks[0] + BLOCKS_PER_WEEK * 2; // weeks 3-4
        epochEndBlocks[2] = epochEndBlocks[1] + BLOCKS_PER_WEEK * 4; // month 2
        epochEndBlocks[3] = epochEndBlocks[2] + BLOCKS_PER_WEEK * 8; // month 3-4
        epochEndBlocks[4] = epochEndBlocks[3] + BLOCKS_PER_WEEK * 8; // month 5-6
        governance = msg.sender;
    }

    /**
     * @dev Throws if called by a contract and we are not allowing.
     */
    modifier checkContract() {
        if (!acceptContractDepositor) {
            require(!address(msg.sender).isContract() && msg.sender == tx.origin, ""Sorry we do not accept contract!"");
        }
        _;
    }

    /**
     * @notice Returns the current token3CRV balance of the vault and controller, minus insurance
     * @dev Ignore insurance fund for balance calculations
     */
    function balance() public override view returns (uint) {
        uint bal = token3CRV.balanceOf(address(this));
        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(token3CRV)));
        return bal.sub(insurance);
    }

    /**
     * @notice Called by Governance to set the value for min
     * @param _min The new min value
     */
    function setMin(uint _min) external {
        require(msg.sender == governance, ""!governance"");
        min = _min;
    }

    /**
     * @notice Called by Governance to set the value for the governance address
     * @param _governance The new governance value
     */
    function setGovernance(address _governance) public {
        require(msg.sender == governance, ""!governance"");
        governance = _governance;
    }

    /**
     * @notice Called by Governance to set the value for the controller address
     * @param _controller The new controller value
     */
    function setController(address _controller) public override {
        require(msg.sender == governance, ""!governance"");
        controller = _controller;
    }

    /**
     * @notice Called by Governance to set the value for the converter address
     * @param _converter The new converter value
     * @dev Requires that the return address of token() from the converter is the
     * same as token3CRV
     */
    function setConverter(IConverter _converter) public {
        require(msg.sender == governance, ""!governance"");
        require(_converter.token() == address(token3CRV), ""!token3CRV"");
        converter = _converter;
    }

    /**
     * @notice Called by Governance to set the value for the vaultManager address
     * @param _vaultManager The new vaultManager value
     */
    function setVaultManager(IVaultManager _vaultManager) public {
        require(msg.sender == governance, ""!governance"");
        vaultManager = _vaultManager;
    }

    /**
     * @notice Called by Governance to set the value for the earnLowerlimit
     * @dev earnLowerlimit determines the minimum balance of this contract for earn
     * to be called
     * @param _earnLowerlimit The new earnLowerlimit value
     */
    function setEarnLowerlimit(uint _earnLowerlimit) public {
        require(msg.sender == governance, ""!governance"");
        earnLowerlimit = _earnLowerlimit;
    }

    /**
     * @notice Called by Governance to set the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(uint _totalDepositCap) public {
        require(msg.sender == governance, ""!governance"");
        totalDepositCap = _totalDepositCap;
    }

    /**
     * @notice Called by Governance to set the value for acceptContractDepositor
     * @dev acceptContractDepositor allows the metavault to accept deposits from
     * smart contract addresses
     * @param _acceptContractDepositor The new acceptContractDepositor value
     */
    function setAcceptContractDepositor(bool _acceptContractDepositor) public {
        require(msg.sender == governance, ""!governance"");
        acceptContractDepositor = _acceptContractDepositor;
    }

    /**
     * @notice Called by Governance to set the value for yaxPerBlock
     * @dev Makes a call to updateReward()
     * @param _yaxPerBlock The new yaxPerBlock value
     */
    function setYaxPerBlock(uint _yaxPerBlock) public {
        require(msg.sender == governance, ""!governance"");
        updateReward();
        yaxPerBlock = _yaxPerBlock;
    }

    /**
     * @notice Called by Governance to set the value for epochEndBlocks at the given index
     * @dev Throws if _index >= 5
     * @dev Throws if _epochEndBlock > the current block.number
     * @dev Throws if the stored block.number at the given index is > the current block.number
     * @param _index The index to set of epochEndBlocks
     * @param _epochEndBlock The new epochEndBlocks value at the index
     */
    function setEpochEndBlock(uint8 _index, uint256 _epochEndBlock) public {
        require(msg.sender == governance, ""!governance"");
        require(_index < 5, ""_index out of range"");
        require(_epochEndBlock > block.number, ""Too late to update"");
        require(epochEndBlocks[_index] > block.number, ""Too late to update"");
        epochEndBlocks[_index] = _epochEndBlock;
    }

    /**
     * @notice Called by Governance to set the value for epochRewardMultiplers at the given index
     * @dev Throws if _index < 1 or > 5
     * @dev Throws if the stored block.number at the previous index is > the current block.number
     * @param _index The index to set of epochRewardMultiplers
     * @param _epochRewardMultipler The new epochRewardMultiplers value at the index
     */
    function setEpochRewardMultipler(uint8 _index, uint256 _epochRewardMultipler) public {
        require(msg.sender == governance, ""!governance"");
        require(_index > 0 && _index < 6, ""Index out of range"");
        require(epochEndBlocks[_index - 1] > block.number, ""Too late to update"");
        epochRewardMultiplers[_index] = _epochRewardMultipler;
    }

    /**
     * @notice Return reward multiplier over the given _from to _to block.
     * @param _from The from block
     * @param _to The to block
     */
    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {
        // start at the end of the epochs
        for (uint8 epochId = 5; epochId >= 1; --epochId) {
            // if _to (the current block number if called within this contract) is after the previous epoch ends
            if (_to >= epochEndBlocks[epochId - 1]) {
                // if the last reward block is after the previous epoch: return the number of blocks multiplied by this epochs multiplier
                if (_from >= epochEndBlocks[epochId - 1]) return _to.sub(_from).mul(epochRewardMultiplers[epochId]);
                // get the multiplier amount for the remaining reward of the current epoch
                uint256 multiplier = _to.sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]);
                // if epoch is 1: return the remaining current epoch reward with the first epoch reward
                if (epochId == 1) return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));
                // for all epochs in between the first and current epoch
                for (epochId = epochId - 1; epochId >= 1; --epochId) {
                    // if the last reward block is after the previous epoch: return the current remaining reward with the previous epoch
                    if (_from >= epochEndBlocks[epochId - 1]) return multiplier.add(epochEndBlocks[epochId].sub(_from).mul(epochRewardMultiplers[epochId]));
                    // accumulate the multipler with the reward from the epoch
                    multiplier = multiplier.add(epochEndBlocks[epochId].sub(epochEndBlocks[epochId - 1]).mul(epochRewardMultiplers[epochId]));
                }
                // return the accumulated multiplier with the reward from the first epoch
                return multiplier.add(epochEndBlocks[0].sub(_from).mul(epochRewardMultiplers[0]));
            }
        }
        // return the reward amount between _from and _to in the first epoch
        return _to.sub(_from).mul(epochRewardMultiplers[0]);
    }

    /**
     * @notice Called by Governance to set the value for the treasuryWallet
     * @param _treasuryWallet The new treasuryWallet value
     */
    function setTreasuryWallet(address _treasuryWallet) public {
        require(msg.sender == governance, ""!governance"");
        treasuryWallet = _treasuryWallet;
    }

    /**
     * @notice Called by Governance or the controller to claim the amount stored in the insurance fund
     * @dev If called by the controller, insurance will auto compound the vault, increasing getPricePerFullShare
     */
    function claimInsurance() external override {
        // if claim by controller for auto-compounding (current insurance will stay to increase sharePrice)
        // otherwise send the fund to treasuryWallet
        if (msg.sender != controller) {
            // claim by governance for insurance
            require(msg.sender == governance, ""!governance"");
            token3CRV.safeTransfer(treasuryWallet, insurance);
        }
        insurance = 0;
    }

    /**
     * @notice Get the address of the 3CRV token
     */
    function token() public override view returns (address) {
        return address(token3CRV);
    }

    /**
     * @notice Get the amount that the metavault allows to be borrowed
     * @dev min and max are used to keep small withdrawals cheap
     */
    function available() public override view returns (uint) {
        return token3CRV.balanceOf(address(this)).mul(min).div(max);
    }

    /**
     * @notice If the controller is set, returns the withdrawFee of the 3CRV token for the given _amount
     * @param _amount The amount being queried to withdraw
     */
    function withdrawFee(uint _amount) public override view returns (uint) {
        return (controller == address(0)) ? 0 : IController(controller).withdrawFee(address(token3CRV), _amount);
    }

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn() public override {
        if (controller != address(0)) {
            IController _contrl = IController(controller);
            if (_contrl.investEnabled()) {
                uint _bal = available();
                token3CRV.safeTransfer(controller, _bal);
                _contrl.earn(address(token3CRV), _bal);
            }
        }
    }

    /**
     * @notice Returns the amount of 3CRV given for the amounts deposited
     * @param amounts The stablecoin amounts being deposited
     */
    function calc_token_amount_deposit(uint[3] calldata amounts) external override view returns (uint) {
        return converter.calc_token_amount(amounts, true);
    }

    /**
     * @notice Returns the amount given in the desired token for the given shares
     * @param _shares The amount of shares to withdraw
     * @param _output The desired token to withdraw
     */
    function calc_token_amount_withdraw(uint _shares, address _output) external override view returns (uint) {
        uint _withdrawFee = withdrawFee(_shares);
        if (_withdrawFee > 0) {
            _shares = _shares.mul(10000 - _withdrawFee).div(10000);
        }
        uint r = (balance().mul(_shares)).div(totalSupply());
        if (_output == address(token3CRV)) {
            return r;
        }
        return converter.calc_token_amount_withdraw(r, _output);
    }

    /**
     * @notice Returns the amount of 3CRV that would be given for the amount of input tokens
     * @param _input The stablecoin to convert to 3CRV
     * @param _amount The amount of stablecoin to convert
     */
    function convert_rate(address _input, uint _amount) external override view returns (uint) {
        return converter.convert_rate(_input, address(token3CRV), _amount);
    }

    /**
     * @notice Deposit a single stablecoin to the metavault
     * @dev Users must approve the metavault to spend their stablecoin
     * @param _amount The amount of the stablecoin to deposit
     * @param _input The address of the stablecoin being deposited
     * @param _min_mint_amount The expected amount of shares to receive
     * @param _isStake Stakes shares or not
     */
    function deposit(uint _amount, address _input, uint _min_mint_amount, bool _isStake) external override checkContract {
        require(_amount > 0, ""!_amount"");
        uint _pool = balance();
        uint _before = token3CRV.balanceOf(address(this));
        if (_input == address(token3CRV)) {
            token3CRV.safeTransferFrom(msg.sender, address(this), _amount);
        } else if (converter.convert_rate(_input, address(token3CRV), _amount) > 0) {
            IERC20(_input).safeTransferFrom(msg.sender, address(converter), _amount);
            converter.convert(_input, address(token3CRV), _amount);
        }
        uint _after = token3CRV.balanceOf(address(this));
        require(totalDepositCap == 0 || _after <= totalDepositCap, "">totalDepositCap"");
        _amount = _after.sub(_before); // Additional check for deflationary tokens
        require(_amount >= _min_mint_amount, ""slippage"");
        if (_amount > 0) {
            if (!_isStake) {
                _deposit(msg.sender, _pool, _amount);
            } else {
                uint _shares = _deposit(address(this), _pool, _amount);
                _stakeShares(_shares);
            }
        }
    }

    /**
     * @notice Deposits multiple stablecoins simultaneously to the metavault
     * @dev 0: DAI, 1: USDC, 2: USDT, 3: 3CRV
     * @dev Users must approve the metavault to spend their stablecoin
     * @param _amounts The amounts of each stablecoin being deposited
     * @param _min_mint_amount The expected amount of shares to receive
     * @param _isStake Stakes shares or not
     */
    function depositAll(uint[4] calldata _amounts, uint _min_mint_amount, bool _isStake) external checkContract {
        uint _pool = balance();
        uint _before = token3CRV.balanceOf(address(this));
        bool hasStables = false;
        for (uint8 i = 0; i < 4; i++) {
            uint _inputAmount = _amounts[i];
            if (_inputAmount > 0) {
                if (i == 3) {
                    inputTokens[i].safeTransferFrom(msg.sender, address(this), _inputAmount);
                } else if (converter.convert_rate(address(inputTokens[i]), address(token3CRV), _inputAmount) > 0) {
                    inputTokens[i].safeTransferFrom(msg.sender, address(converter), _inputAmount);
                    hasStables = true;
                }
            }
        }
        if (hasStables) {
            uint[3] memory _stablesAmounts;
            _stablesAmounts[0] = _amounts[0];
            _stablesAmounts[1] = _amounts[1];
            _stablesAmounts[2] = _amounts[2];
            converter.convert_stables(_stablesAmounts);
        }
        uint _after = token3CRV.balanceOf(address(this));
        require(totalDepositCap == 0 || _after <= totalDepositCap, "">totalDepositCap"");
        uint _totalDepositAmount = _after.sub(_before); // Additional check for deflationary tokens
        require(_totalDepositAmount >= _min_mint_amount, ""slippage"");
        if (_totalDepositAmount > 0) {
            if (!_isStake) {
                _deposit(msg.sender, _pool, _totalDepositAmount);
            } else {
                uint _shares = _deposit(address(this), _pool, _totalDepositAmount);
                _stakeShares(_shares);
            }
        }
    }

    /**
     * @notice Stakes metavault shares
     * @param _shares The amount of shares to stake
     */
    function stakeShares(uint _shares) external {
        uint _before = balanceOf(address(this));
        IERC20(address(this)).transferFrom(msg.sender, address(this), _shares);
        uint _after = balanceOf(address(this));
        _shares = _after.sub(_before);
        // Additional check for deflationary tokens
        _stakeShares(_shares);
    }

    function _deposit(address _mintTo, uint _pool, uint _amount) internal returns (uint _shares) {
        if (address(vaultManager) != address(0)) {
            // expected 0.1% of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals
            // it is updated by governance (community vote)
            uint _insuranceFee = vaultManager.insuranceFee();
            if (_insuranceFee > 0) {
                uint _insurance = _amount.mul(_insuranceFee).div(10000);
                _amount = _amount.sub(_insurance);
                insurance = insurance.add(_insurance);
            }
        }

        if (totalSupply() == 0) {
            _shares = _amount;
        } else {
            _shares = (_amount.mul(totalSupply())).div(_pool);
        }
        if (_shares > 0) {
            if (token3CRV.balanceOf(address(this)) > earnLowerlimit) {
                earn();
            }
            _mint(_mintTo, _shares);
        }
    }

    function _stakeShares(uint _shares) internal {
        UserInfo storage user = userInfo[msg.sender];
        updateReward();
        _getReward();
        user.amount = user.amount.add(_shares);
        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);
        emit Deposit(msg.sender, _shares);
    }

    /**
     * @notice Returns the pending YAXs for a given account
     * @param _account The address to query
     */
    function pendingYax(address _account) public view returns (uint _pending) {
        UserInfo storage user = userInfo[_account];
        uint _accYaxPerShare = accYaxPerShare;
        uint lpSupply = balanceOf(address(this));
        if (block.number > lastRewardBlock && lpSupply != 0) {
            uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);
            _accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));
        }
        _pending = user.amount.mul(_accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);
    }

    /**
     * @notice Sets the lastRewardBlock and accYaxPerShare
     */
    function updateReward() public {
        if (block.number <= lastRewardBlock) {
            return;
        }
        uint lpSupply = balanceOf(address(this));
        if (lpSupply == 0) {
            lastRewardBlock = block.number;
            return;
        }
        uint256 _multiplier = getMultiplier(lastRewardBlock, block.number);
        accYaxPerShare = accYaxPerShare.add(_multiplier.mul(yaxPerBlock).mul(1e12).div(lpSupply));
        lastRewardBlock = block.number;
    }

    function _getReward() internal {
        UserInfo storage user = userInfo[msg.sender];
        uint _pendingYax = user.amount.mul(accYaxPerShare).div(1e12).sub(user.yaxRewardDebt);
        if (_pendingYax > 0) {
            user.accEarned = user.accEarned.add(_pendingYax);
            safeYaxTransfer(msg.sender, _pendingYax);
            emit RewardPaid(msg.sender, _pendingYax);
        }
    }

    /**
     * @notice Withdraw the entire balance for an account
     * @param _output The address of the desired stablecoin to receive
     */
    function withdrawAll(address _output) external {
        unstake(userInfo[msg.sender].amount);
        withdraw(balanceOf(msg.sender), _output);
    }

    /**
     * @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'
     * @param reserve The address of the token to swap to 3CRV
     * @param amount The amount to swap
     */
    function harvest(address reserve, uint amount) external override {
        require(msg.sender == controller, ""!controller"");
        require(reserve != address(token3CRV), ""token3CRV"");
        IERC20(reserve).safeTransfer(controller, amount);
    }

    /**
     * @notice Unstakes the given shares from the metavault
     * @dev call unstake(0) to only receive the reward
     * @param _amount The amount to unstake
     */
    function unstake(uint _amount) public {
        updateReward();
        _getReward();
        UserInfo storage user = userInfo[msg.sender];
        if (_amount > 0) {
            require(user.amount >= _amount, ""stakedBal < _amount"");
            user.amount = user.amount.sub(_amount);
            IERC20(address(this)).transfer(msg.sender, _amount);
        }
        user.yaxRewardDebt = user.amount.mul(accYaxPerShare).div(1e12);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraws an amount of shares to a given output stablecoin
     * @dev No rebalance implementation for lower fees and faster swaps
     * @param _shares The amount of shares to withdraw
     * @param _output The address of the stablecoin to receive
     */
    function withdraw(uint _shares, address _output) public override {
        uint _userBal = balanceOf(msg.sender);
        if (_shares > _userBal) {
            uint _need = _shares.sub(_userBal);
            require(_need <= userInfo[msg.sender].amount, ""_userBal+staked < _shares"");
            unstake(_need);
        }
        uint r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        if (address(vaultManager) != address(0)) {
            // expected 0.1% of withdrawal go back to vault (for auto-compounding) to protect withdrawals
            // it is updated by governance (community vote)
            uint _withdrawalProtectionFee = vaultManager.withdrawalProtectionFee();
            if (_withdrawalProtectionFee > 0) {
                uint _withdrawalProtection = r.mul(_withdrawalProtectionFee).div(10000);
                r = r.sub(_withdrawalProtection);
            }
        }

        // Check balance
        uint b = token3CRV.balanceOf(address(this));
        if (b < r) {
            uint _toWithdraw = r.sub(b);
            if (controller != address(0)) {
                IController(controller).withdraw(address(token3CRV), _toWithdraw);
            }
            uint _after = token3CRV.balanceOf(address(this));
            uint _diff = _after.sub(b);
            if (_diff < _toWithdraw) {
                r = b.add(_diff);
            }
        }

        if (_output == address(token3CRV)) {
            token3CRV.safeTransfer(msg.sender, r);
        } else {
            require(converter.convert_rate(address(token3CRV), _output, r) > 0, ""rate=0"");
            token3CRV.safeTransfer(address(converter), r);
            uint _outputAmount = converter.convert(address(token3CRV), _output, r);
            IERC20(_output).safeTransfer(msg.sender, _outputAmount);
        }
    }

    /**
     * @notice Returns the address of the 3CRV token
     */
    function want() external override view returns (address) {
        return address(token3CRV);
    }

    /**
     * @notice Returns the rate of earnings of a single share
     */
    function getPricePerFullShare() external override view returns (uint) {
        return balance().mul(1e18).div(totalSupply());
    }

    /**
     * @notice Transfers YAX from the metavault to a given address
     * @dev Ensures the metavault has enough balance to transfer
     * @param _to The address to transfer to
     * @param _amount The amount to transfer
     */
    function safeYaxTransfer(address _to, uint _amount) internal {
        uint _tokenBal = tokenYAX.balanceOf(address(this));
        tokenYAX.safeTransfer(_to, (_tokenBal < _amount) ? _tokenBal : _amount);
    }

    /**
     * @notice Converts non-3CRV stablecoins held in the metavault to 3CRV
     * @param _token The address to convert
     */
    function earnExtra(address _token) public {
        require(msg.sender == governance, ""!governance"");
        require(address(_token) != address(token3CRV), ""3crv"");
        require(address(_token) != address(this), ""mlvt"");
        uint _amount = IERC20(_token).balanceOf(address(this));
        require(converter.convert_rate(_token, address(token3CRV), _amount) > 0, ""rate=0"");
        IERC20(_token).safeTransfer(address(converter), _amount);
        converter.convert(_token, address(token3CRV), _amount);
    }
}",6761
RealWorld_TA_30_MockCurveGauge_RealWorld_20240803225421.log,30,MockCurveGauge,41878,3895,45773,123.0,0.28729,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""../interfaces/Gauge.sol"";

contract MockCurveGauge is Gauge {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 want;

    mapping(address => uint) public amounts;

    constructor(IERC20 _want) public {
        want = _want;
    }

    function deposit(uint _amount) external override {
        want.safeTransferFrom(msg.sender, address(this), _amount);
        amounts[msg.sender] = amounts[msg.sender].add(_amount);
    }

    function balanceOf(address _account) external override view returns (uint) {
        return amounts[_account];
    }

    function claimable_tokens(address _account) external override view returns (uint) {
        return amounts[_account].div(10); // always return 10% of staked
    }

    function withdraw(uint _amount) external override {
        want.safeTransfer(msg.sender, _amount);
        amounts[msg.sender] = amounts[msg.sender].sub(_amount);
    }
}",269
RealWorld_TA_30_MockYaxisBar_RealWorld_20240803234010.log,30,MockYaxisBar,51398,3146,54544,102.0,0.31991,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

contract MockYaxisBar is ERC20 {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable YAX;

    constructor(
        address _yax
    )
        public
        ERC20(""Staked yAxis"", ""sYAX"")
    {
        YAX = IERC20(_yax);
    }

    function availableBalance()
        external
        view
        returns (uint256)
    {
        return YAX.balanceOf(address(this));
    }

    function enter(
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        _mint(msg.sender, _amount.mul(1e18).div(getPricePerFullShare()));
        YAX.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function leave(
        uint256 _amount
    )
        public
    {
        require(_amount > 0, ""!_amount"");
        _burn(msg.sender, _amount);
        YAX.safeTransfer(msg.sender, _amount.mul(getPricePerFullShare()).div(1e18));
    }

    function exit()
        external
    {
        leave(balanceOf(msg.sender));
    }

    function getPricePerFullShare()
        public
        view
        returns (uint256)
    {
        return totalSupply() == 0
            ? 1e18
            : YAX.balanceOf(address(this)).mul(1e18).div(totalSupply());
    }
}",394
RealWorld_TA_30_ERC677_RealWorld_20240804005205.log,30,ERC677,24920,1663,26583,90.0,0.15786,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

abstract contract ERC677 is IERC20 {
  function transferAndCall(address to, uint value, bytes memory data) public virtual returns (bool success);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}",82
RealWorld_TA_30_IHarvester_RealWorld_20240804003022.log,30,IHarvester,24264,1935,26199,91.0,0.16002,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./IManager.sol"";

interface IHarvester {
    function addStrategy(address, address, uint256) external;
    function manager() external view returns (IManager);
    function removeStrategy(address, address, uint256) external;
}",65
RealWorld_TA_30_Swap_RealWorld_20240803224451.log,30,Swap,61773,2657,64430,108.0,0.362005,"// SPDX-License-Identifier: MIT
// solhint-disable var-name-mixedcase
pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IsYAX.sol"";

/**
 * @title Swap
 * @notice This contract swaps a user's YAX and sYAX to the YAXIS token
 * If the user does not have YAX or sYAX, it will not attempt to swap
 * those assets in order to save gas.
 */
contract Swap {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IERC20 public immutable YAXIS;
    IERC20 public immutable YAX;
    IERC20 public immutable SYAX;

    /**
     * @param _yaxis The YAXIS token address
     * @param _yax The YAX token address
     * @param _syax The sYAX token address
     */
    constructor(
        address _yaxis,
        address _yax,
        address _syax
    )
        public
    {
        YAXIS = IERC20(_yaxis);
        YAX = IERC20(_yax);
        SYAX = IERC20(_syax);
    }

    /**
     * @notice Swaps the user's YAX and sYAX for YAXIS
     * @dev Assumes this contract should never hold YAX directly
     * because it will send its entire balance to the caller.
     * @dev This contract must be funded with YAXIS before
     * users can call swap().
     */
    function swap()
        external
    {
        uint256 _balance = YAX.balanceOf(address(this));
        uint256 _amount = SYAX.balanceOf(msg.sender);
        if (_amount > 0) {
            SYAX.safeTransferFrom(msg.sender, address(this), _amount);
            IsYAX(address(SYAX)).exit();
        }
        _amount = YAX.balanceOf(msg.sender);
        if (_amount > 0) {
            YAX.safeTransferFrom(msg.sender, address(this), _amount);
        }
        _amount = YAX.balanceOf(address(this)).sub(_balance);
        if (_amount > 0) {
            YAXIS.safeTransfer(msg.sender, _amount);
        }
    }
}",522
RealWorld_TA_30_MockPickleJar_RealWorld_20240803230749.log,30,MockPickleJar,49531,3840,53371,114.0,0.324455,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/PickleJar.sol"";
import ""./MockERC20.sol"";

contract MockPickleJar is MockERC20 {
    IERC20 public t3crv;
    IERC20 public lpToken;

    constructor(IERC20 _t3crv) public MockERC20(""pickling Curve.fi DAI/USDC/USDT"", ""p3Crv"", 18) {
        t3crv = _t3crv;
    }

    function balance() public view returns (uint) {
        return t3crv.balanceOf(address(this));
    }

    function available() external view returns (uint) {
        return balance() * 9500 / 10000;
    }

    function depositAll() external {
        deposit(t3crv.balanceOf(msg.sender));
    }

    function deposit(uint _amount) public {
        t3crv.transferFrom(msg.sender, address(this), _amount);
        uint256 shares = _amount * 1000000000000000000 / getRatio();
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdraw(uint _shares) public {
        uint256 r = _shares * getRatio() / 1000000000000000000;
        _burn(msg.sender, _shares);
        t3crv.transfer(msg.sender, r);
    }

    function getRatio() public pure returns (uint) {
        return 1010000000000000000; // +1%
    }
}",352
RealWorld_TA_30_ILegacyController_RealWorld_20240804001423.log,30,ILegacyController,21925,1873,23798,91.0,0.147085,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

interface ILegacyController {
    function legacyDeposit(address _token, uint256 _expected) external;
}",38
RealWorld_TA_30_GenericVault_RealWorld_20240804011235.log,30,GenericVault,24828,1273,26101,78.0,0.1496,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

interface IGenericVault {
    function token() external view returns (address);
    function getPricePerFullShare() external view returns (uint256);
    function deposit(uint256) external;
    function withdraw(uint256) external;
    function depositAll() external;
    function withdrawAll() external;
}",76
RealWorld_TA_30_MStable_RealWorld_20240804010817.log,30,MStable,25466,1783,27249,87.0,0.16299,"// SPDX-License-Identifier: MIT
pragma solidity ^0.6.2;

interface MStable {
    function mint(address, uint) external;
    function redeem(address, uint) external;
}

interface mSavings {
    function depositSavings(uint) external;
    function creditBalances(address) external view returns (uint);
    function redeem(uint) external;
    function exchangeRate() external view returns (uint);
}",86
RealWorld_TA_31_Address_RealWorld_20240804040926.log,31,Address,45784,1250,47034,80.0,0.25392,"pragma solidity ^0.5.0;

/**
 * Utility library of inline functions on addresses
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.
 */
library OpenZeppelinUpgradesAddress {
    /**
     * Returns whether the target address is a contract
     * @dev This function will return false if invoked during the constructor of a contract,
     * as the code is not actually created until after the constructor finishes.
     * @param account address of the account to check
     * @return whether the target address is a contract
     */
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        // XXX Currently there is no better way to check if there is a contract in an address
        // than to check the size of the code at that address.
        // See https://ethereum.stackexchange.com/a/14016/36603
        // for more details about how this works.
        // TODO Check this again before the Serenity release, because all addresses will be
        // contracts then.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}",331
RealWorld_TA_31_BaseStrategy_RealWorld_20240804021445.log,31,BaseStrategy,275558,5138,280696,154.0,1.48055,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""./@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""./@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol"";
import ""./@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""./@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol"";
import ""./@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""./@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../interfaces/uniswap/IUniswapRouterV2.sol"";
import ""../interfaces/badger/IController.sol"";
import ""../interfaces/badger/IStrategy.sol"";

import ""./SettAccessControl.sol"";

/*
    ===== Badger Base Strategy =====
    Common base class for all Sett strategies

    Changelog
    V1.1
    - Verify amount unrolled from strategy positions on withdraw() is within a threshold relative to the requested amount as a sanity check
    - Add version number which is displayed with baseStrategyVersion(). If a strategy does not implement this function, it can be assumed to be 1.0

    V1.2
    - Remove idle want handling from base withdraw() function. This should be handled as the strategy sees fit in _withdrawSome()
*/
abstract contract BaseStrategy is PausableUpgradeable, SettAccessControl {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    event Withdraw(uint256 amount);
    event WithdrawAll(uint256 balance);
    event WithdrawOther(address token, uint256 amount);
    event SetStrategist(address strategist);
    event SetGovernance(address governance);
    event SetController(address controller);
    event SetWithdrawalFee(uint256 withdrawalFee);
    event SetPerformanceFeeStrategist(uint256 performanceFeeStrategist);
    event SetPerformanceFeeGovernance(uint256 performanceFeeGovernance);
    event Harvest(uint256 harvested, uint256 indexed blockNumber);
    event Tend(uint256 tended);

    address public want; // Want: Curve.fi renBTC/wBTC (crvRenWBTC) LP token

    uint256 public performanceFeeGovernance;
    uint256 public performanceFeeStrategist;
    uint256 public withdrawalFee;

    uint256 public constant MAX_FEE = 10000;
    address public constant uniswap =
        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap Dex

    address public controller;
    address public guardian;

    uint256 public withdrawalMaxDeviationThreshold;

    function __BaseStrategy_init(
        address _governance,
        address _strategist,
        address _controller,
        address _keeper,
        address _guardian
    ) public initializer whenNotPaused {
        __Pausable_init();
        governance = _governance;
        strategist = _strategist;
        keeper = _keeper;
        controller = _controller;
        guardian = _guardian;
        withdrawalMaxDeviationThreshold = 50;
    }

    // ===== Modifiers =====

    function _onlyController() internal view {
        require(msg.sender == controller, ""onlyController"");
    }

    function _onlyAuthorizedActorsOrController() internal view {
        require(
            msg.sender == keeper ||
                msg.sender == governance ||
                msg.sender == controller,
            ""onlyAuthorizedActorsOrController""
        );
    }

    function _onlyAuthorizedPausers() internal view {
        require(
            msg.sender == guardian || msg.sender == governance,
            ""onlyPausers""
        );
    }

    /// ===== View Functions =====
    function baseStrategyVersion() public view returns (string memory) {
        return ""1.2"";
    }

    /// @notice Get the balance of want held idle in the Strategy
    function balanceOfWant() public view returns (uint256) {
        return IERC20Upgradeable(want).balanceOf(address(this));
    }

    /// @notice Get the total balance of want realized in the strategy, whether idle or active in Strategy positions.
    function balanceOf() public view virtual returns (uint256) {
        return balanceOfWant().add(balanceOfPool());
    }

    function isTendable() public view virtual returns (bool) {
        return false;
    }

    /// ===== Permissioned Actions: Governance =====

    function setGuardian(address _guardian) external {
        _onlyGovernance();
        guardian = _guardian;
    }

    function setWithdrawalFee(uint256 _withdrawalFee) external {
        _onlyGovernance();
        require(
            _withdrawalFee <= MAX_FEE,
            ""base-strategy/excessive-withdrawal-fee""
        );
        withdrawalFee = _withdrawalFee;
    }

    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist)
        external
    {
        _onlyGovernance();
        require(
            _performanceFeeStrategist <= MAX_FEE,
            ""base-strategy/excessive-strategist-performance-fee""
        );
        performanceFeeStrategist = _performanceFeeStrategist;
    }

    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance)
        external
    {
        _onlyGovernance();
        require(
            _performanceFeeGovernance <= MAX_FEE,
            ""base-strategy/excessive-governance-performance-fee""
        );
        performanceFeeGovernance = _performanceFeeGovernance;
    }

    function setController(address _controller) external {
        _onlyGovernance();
        controller = _controller;
    }

    function setWithdrawalMaxDeviationThreshold(uint256 _threshold) external {
        _onlyGovernance();
        require(
            _threshold <= MAX_FEE,
            ""base-strategy/excessive-max-deviation-threshold""
        );
        withdrawalMaxDeviationThreshold = _threshold;
    }

    function deposit() public virtual whenNotPaused {
        _onlyAuthorizedActorsOrController();
        uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));
        if (_want > 0) {
            _deposit(_want);
        }
        _postDeposit();
    }

    // ===== Permissioned Actions: Controller =====

    /// @notice Controller-only function to Withdraw partial funds, normally used with a vault withdrawal
    function withdrawAll()
        external
        virtual
        whenNotPaused
        returns (uint256 balance)
    {
        _onlyController();

        _withdrawAll();

        _transferToVault(IERC20Upgradeable(want).balanceOf(address(this)));
    }

    /// @notice Withdraw partial funds from the strategy, unrolling from strategy positions as necessary
    /// @notice Processes withdrawal fee if present
    /// @dev If it fails to recover sufficient funds (defined by withdrawalMaxDeviationThreshold), the withdrawal should fail so that this unexpected behavior can be investigated
    function withdraw(uint256 _amount) external virtual whenNotPaused {
        _onlyController();

        // Withdraw from strategy positions, typically taking from any idle want first.
        _withdrawSome(_amount);
        uint256 _postWithdraw =
            IERC20Upgradeable(want).balanceOf(address(this));

        // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions
        // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold
        if (_postWithdraw < _amount) {
            uint256 diff = _diff(_amount, _postWithdraw);

            // Require that difference between expected and actual values is less than the deviation threshold percentage
            require(
                diff <=
                    _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE),
                ""base-strategy/withdraw-exceed-max-deviation-threshold""
            );
        }

        // Return the amount actually withdrawn if less than amount requested
        uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);

        // Process withdrawal fee
        uint256 _fee = _processWithdrawalFee(_toWithdraw);

        // Transfer remaining to Vault to handle withdrawal
        _transferToVault(_toWithdraw.sub(_fee));
    }

    // NOTE: must exclude any tokens used in the yield
    // Controller role - withdraw should return to Controller
    function withdrawOther(address _asset)
        external
        virtual
        whenNotPaused
        returns (uint256 balance)
    {
        _onlyController();
        _onlyNotProtectedTokens(_asset);

        balance = IERC20Upgradeable(_asset).balanceOf(address(this));
        IERC20Upgradeable(_asset).safeTransfer(controller, balance);
    }

    /// ===== Permissioned Actions: Authoized Contract Pausers =====

    function pause() external {
        _onlyAuthorizedPausers();
        _pause();
    }

    function unpause() external {
        _onlyGovernance();
        _unpause();
    }

    /// ===== Internal Helper Functions =====

    /// @notice If withdrawal fee is active, take the appropriate amount from the given value and transfer to rewards recipient
    /// @return The withdrawal fee that was taken
    function _processWithdrawalFee(uint256 _amount) internal returns (uint256) {
        if (withdrawalFee == 0) {
            return 0;
        }

        uint256 fee = _amount.mul(withdrawalFee).div(MAX_FEE);
        IERC20Upgradeable(want).safeTransfer(
            IController(controller).rewards(),
            fee
        );
        return fee;
    }

    /// @dev Helper function to process an arbitrary fee
    /// @dev If the fee is active, transfers a given portion in basis points of the specified value to the recipient
    /// @return The fee that was taken
    function _processFee(
        address token,
        uint256 amount,
        uint256 feeBps,
        address recipient
    ) internal returns (uint256) {
        if (feeBps == 0) {
            return 0;
        }
        uint256 fee = amount.mul(feeBps).div(MAX_FEE);
        IERC20Upgradeable(token).safeTransfer(recipient, fee);
        return fee;
    }

    /// @dev Reset approval and approve exact amount
    function _safeApproveHelper(
        address token,
        address recipient,
        uint256 amount
    ) internal {
        IERC20Upgradeable(token).safeApprove(recipient, 0);
        IERC20Upgradeable(token).safeApprove(recipient, amount);
    }

    function _transferToVault(uint256 _amount) internal {
        address _vault = IController(controller).vaults(address(want));
        require(_vault != address(0), ""!vault""); // additional protection so we don't burn the funds
        IERC20Upgradeable(want).safeTransfer(_vault, _amount);
    }

    /// @notice Swap specified balance of given token on Uniswap with given path
    function _swap(
        address startToken,
        uint256 balance,
        address[] memory path
    ) internal {
        _safeApproveHelper(startToken, uniswap, balance);
        IUniswapRouterV2(uniswap).swapExactTokensForTokens(
            balance,
            0,
            path,
            address(this),
            now
        );
    }

    function _swapEthIn(uint256 balance, address[] memory path) internal {
        IUniswapRouterV2(uniswap).swapExactETHForTokens{value: balance}(
            0,
            path,
            address(this),
            now
        );
    }

    function _swapEthOut(
        address startToken,
        uint256 balance,
        address[] memory path
    ) internal {
        _safeApproveHelper(startToken, uniswap, balance);
        IUniswapRouterV2(uniswap).swapExactTokensForETH(
            balance,
            0,
            path,
            address(this),
            now
        );
    }

    /// @notice Add liquidity to uniswap for specified token pair, utilizing the maximum balance possible
    function _add_max_liquidity_uniswap(address token0, address token1)
        internal
        virtual
    {
        uint256 _token0Balance =
            IERC20Upgradeable(token0).balanceOf(address(this));
        uint256 _token1Balance =
            IERC20Upgradeable(token1).balanceOf(address(this));

        _safeApproveHelper(token0, uniswap, _token0Balance);
        _safeApproveHelper(token1, uniswap, _token1Balance);

        IUniswapRouterV2(uniswap).addLiquidity(
            token0,
            token1,
            _token0Balance,
            _token1Balance,
            0,
            0,
            address(this),
            block.timestamp
        );
    }

    /// @notice Utility function to diff two numbers, expects higher value in first position
    function _diff(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""diff/expected-higher-number-in-first-position"");
        return a.sub(b);
    }

    // ===== Abstract Functions: To be implemented by specific Strategies =====

    /// @dev Internal deposit logic to be implemented by Stratgies
    function _deposit(uint256 _amount) internal virtual;

    function _postDeposit() internal virtual {
        //no-op by default
    }

    /// @notice Specify tokens used in yield process, should not be available to withdraw via withdrawOther()
    function _onlyNotProtectedTokens(address _asset) internal virtual;

    function getProtectedTokens()
        external
        view
        virtual
        returns (address[] memory);

    /// @dev Internal logic for strategy migration. Should exit positions as efficiently as possible
    function _withdrawAll() internal virtual;

    /// @dev Internal logic for partial withdrawals. Should exit positions as efficiently as possible.
    /// @dev The withdraw() function shell automatically uses idle want in the strategy before attempting to withdraw more using this
    function _withdrawSome(uint256 _amount) internal virtual returns (uint256);

    /// @dev Realize returns from positions
    /// @dev Returns can be reinvested into positions, or distributed in another fashion
    /// @dev Performance fees should also be implemented in this function
    /// @dev Override function stub is removed as each strategy can have it's own return signature for STATICCALL
    // function harvest() external virtual;

    /// @dev User-friendly name for this strategy for purposes of convenient reading
    function getName() external pure virtual returns (string memory);

    /// @dev Balance of want currently held in strategy positions
    function balanceOfPool() public view virtual returns (uint256);

    uint256[49] private __gap;
}",3152
RealWorld_TA_31_ECDSA_RealWorld_20240804040800.log,31,ECDSA,92721,1466,94187,84.0,0.492925,"pragma solidity ^0.5.2;

/**
 * @title Elliptic curve signature operations
 * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
 * TODO Remove this library once solidity supports passing a signature to ecrecover.
 * See https://github.com/ethereum/solidity/issues/864
 *
 * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/79dd498b16b957399f84b9aa7e720f98f9eb83e3/contracts/cryptography/ECDSA.sol
 * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts
 * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the
 * build/artifacts folder) as well as the vanilla implementation from an openzeppelin version.
 */

library OpenZeppelinUpgradesECDSA {
    /**
     * @dev Recover signer address from a message by using their signature
     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
     * @param signature bytes signature, the signature is generated using web3.eth.sign()
     */
    function recover(bytes32 hash, bytes memory signature)
        internal
        pure
        returns (address)
    {
        // Check the signature length
        if (signature.length != 65) {
            return (address(0));
        }

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (
            uint256(s) >
            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
        ) {
            return address(0);
        }

        if (v != 27 && v != 28) {
            return address(0);
        }

        // If the signature is valid (and not malleable), return the signer address
        return ecrecover(hash, v, r, s);
    }

    /**
     * toEthSignedMessageHash
     * @dev prefix a bytes32 value with ""\x19Ethereum Signed Message:""
     * and hash the result
     */
    function toEthSignedMessageHash(bytes32 hash)
        internal
        pure
        returns (bytes32)
    {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return
            keccak256(
                abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)
            );
    }
}",888
RealWorld_TA_31_Counters_RealWorld_20240804033757.log,31,Counters,47698,1189,48887,77.0,0.26227,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../math/SafeMath.sol"";

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}
 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never
 * directly accessed.
 */
library Counters {
    using SafeMath for uint256;

    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        // The {SafeMath} overflow check can be skipped here, see the comment at the top
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}",350
RealWorld_TA_31_AccessControlUpgradeable_RealWorld_20240804051803.log,31,AccessControlUpgradeable,177323,2345,179668,106.0,0.933515,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../utils/EnumerableSetUpgradeable.sol"";
import ""../utils/AddressUpgradeable.sol"";
import ""../GSN/ContextUpgradeable.sol"";
import ""../proxy/Initializable.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControlUpgradeable is
    Initializable,
    ContextUpgradeable
{
    function __AccessControl_init() internal initializer {
        __Context_init_unchained();
        __AccessControl_init_unchained();
    }

    function __AccessControl_init_unchained() internal initializer {}

    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    using AddressUpgradeable for address;

    struct RoleData {
        EnumerableSetUpgradeable.AddressSet members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index)
        public
        view
        returns (address)
    {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(
            hasRole(_roles[role].adminRole, _msgSender()),
            ""AccessControl: sender must be an admin to grant""
        );

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(
            hasRole(_roles[role].adminRole, _msgSender()),
            ""AccessControl: sender must be an admin to revoke""
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(
            account == _msgSender(),
            ""AccessControl: can only renounce roles for self""
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }

    uint256[49] private __gap;
}",1894
RealWorld_TA_31_BadgerWrapperApi_RealWorld_20240804061425.log,31,BadgerWrapperApi,30785,1582,32367,91.0,0.185565,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import ""deps/@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface BadgerWrapperAPI is IERC20 {
    function name() external view returns (string calldata);

    function symbol() external view returns (string calldata);

    function decimals() external view returns (uint256);

    function token() external view returns (address);

    function pricePerShare() external view returns (uint256);

    function totalWrapperBalance(address account)
        external
        view
        returns (uint256);

    function totalVaultBalance(address account) external view returns (uint256);
}",153
RealWorld_TA_31_AccessControl_RealWorld_20240804031218.log,31,AccessControl,170402,1780,172182,97.0,0.88761,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../utils/EnumerableSet.sol"";
import ""../utils/Address.sol"";
import ""../GSN/Context.sol"";

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;
    using Address for address;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping(bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     *
     * _Available since v3.1._
     */
    event RoleAdminChanged(
        bytes32 indexed role,
        bytes32 indexed previousAdminRole,
        bytes32 indexed newAdminRole
    );

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {_setupRole}.
     */
    event RoleGranted(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(
        bytes32 indexed role,
        address indexed account,
        address indexed sender
    );

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    /**
     * @dev Returns the number of accounts that have `role`. Can be used
     * together with {getRoleMember} to enumerate all bearers of a role.
     */
    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }

    /**
     * @dev Returns one of the accounts that have `role`. `index` must be a
     * value between 0 and {getRoleMemberCount}, non-inclusive.
     *
     * Role bearers are not sorted in any particular way, and their ordering may
     * change at any point.
     *
     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
     * you perform all queries on the same block. See the following
     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
     * for more information.
     */
    function getRoleMember(bytes32 role, uint256 index)
        public
        view
        returns (address)
    {
        return _roles[role].members.at(index);
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) public virtual {
        require(
            hasRole(_roles[role].adminRole, _msgSender()),
            ""AccessControl: sender must be an admin to grant""
        );

        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) public virtual {
        require(
            hasRole(_roles[role].adminRole, _msgSender()),
            ""AccessControl: sender must be an admin to revoke""
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `account`.
     */
    function renounceRole(bytes32 role, address account) public virtual {
        require(
            account == _msgSender(),
            ""AccessControl: can only renounce roles for self""
        );

        _revokeRole(role, account);
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event. Note that unlike {grantRole}, this function doesn't perform any
     * checks on the calling account.
     *
     * [WARNING]
     * ====
     * This function should only be called from the constructor when setting
     * up the initial roles for the system.
     *
     * Using this function in any other way is effectively circumventing the admin
     * system imposed by {AccessControl}.
     * ====
     */
    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}",1809
RealWorld_TA_31_CvxLocker_RealWorld_20240804015747.log,31,CvxLocker,655090,7355,662445,227.0,3.42255,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import ""../../interfaces/cvx/MathUtil.sol"";
import ""../../interfaces/cvx/IStakingProxy.sol"";
import ""../../interfaces/cvx/IRewardStaking.sol"";
import ""../../interfaces/cvx/BoringMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/ReentrancyGuard.sol"";

// CVX Locking contract for https://www.convexfinance.com/
// CVX locked in this contract will be entitled to voting rights for the Convex Finance platform
// Based on EPS Staking contract for http://ellipsis.finance/
// Based on SNX MultiRewards by iamdefinitelyahuman - https://github.com/iamdefinitelyahuman/multi-rewards
contract CvxLocker is ReentrancyGuard, Ownable {
    using BoringMath for uint256;
    using BoringMath224 for uint224;
    using BoringMath112 for uint112;
    using BoringMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ========== STATE VARIABLES ========== */

    struct Reward {
        bool useBoost;
        uint40 periodFinish;
        uint208 rewardRate;
        uint40 lastUpdateTime;
        uint208 rewardPerTokenStored;
    }
    struct Balances {
        uint112 locked;
        uint112 boosted;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint112 boosted;
        uint32 unlockTime;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Epoch {
        uint224 supply; //epoch boosted supply
        uint32 date; //epoch start date
    }

    //token constants
    IERC20 public constant stakingToken =
        IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B); //cvx
    address public constant cvxCrv =
        address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //rewards
    address[] public rewardTokens;
    mapping(address => Reward) public rewardData;

    // Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;

    // Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;

    // user -> reward token -> amount
    mapping(address => mapping(address => uint256))
        public userRewardPerTokenPaid;
    mapping(address => mapping(address => uint256)) public rewards;

    //supplies and epochs
    uint256 public lockedSupply;
    uint256 public boostedSupply;
    Epoch[] public epochs;

    //mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    //boost
    address public boostPayment =
        address(0x1389388d01708118b497f59521f6943Be2541bb7);
    uint256 public maximumBoostPayment = 0;
    uint256 public boostRate = 10000;
    uint256 public nextMaximumBoostPayment = 0;
    uint256 public nextBoostRate = 10000;
    uint256 public constant denominator = 10000;

    //staking
    uint256 public minimumStake = 10000;
    uint256 public maximumStake = 10000;
    address public stakingProxy;
    address public constant cvxcrvStaking =
        address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);
    uint256 public constant stakeOffsetOnLock = 500; //allow broader range for staking when depositing

    //management
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 4;

    //shutdown
    bool public isShutdown = false;

    //erc20-like interface
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== CONSTRUCTOR ========== */

    constructor() public Ownable() {
        _name = ""Vote Locked Convex Token"";
        _symbol = ""vlCVX"";
        _decimals = 18;

        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({supply: 0, date: uint32(currentEpoch)}));
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /* ========== ADMIN CONFIGURATION ========== */

    // Add a new reward token to be distributed to stakers
    function addReward(
        address _rewardsToken,
        address _distributor,
        bool _useBoost
    ) public onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0);
        require(_rewardsToken != address(stakingToken));
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint40(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint40(block.timestamp);
        rewardData[_rewardsToken].useBoost = _useBoost;
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0);
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //Set the staking contract for the underlying cvx. immutable to avoid foul play
    function setStakingContract(address _staking) external onlyOwner {
        require(stakingProxy == address(0), ""staking contract immutable"");

        stakingProxy = _staking;
    }

    //set staking limits. will stake the mean of the two once either ratio is crossed
    function setStakeLimits(uint256 _minimum, uint256 _maximum)
        external
        onlyOwner
    {
        require(_minimum <= denominator, ""min range"");
        require(_maximum <= denominator, ""max range"");
        minimumStake = _minimum;
        maximumStake = _maximum;
        updateStakeRatio(0);
    }

    //set boost parameters
    function setBoost(
        uint256 _max,
        uint256 _rate,
        address _receivingAddress
    ) external onlyOwner {
        require(maximumBoostPayment < 1500, ""over max payment""); //max 15%
        require(boostRate < 30000, ""over max rate""); //max 3x
        require(_receivingAddress != address(0), ""invalid address""); //must point somewhere valid
        nextMaximumBoostPayment = _max;
        nextBoostRate = _rate;
        boostPayment = _receivingAddress;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay)
        external
        onlyOwner
    {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        if (stakingProxy != address(0)) {
            uint256 stakeBalance = IStakingProxy(stakingProxy).getBalance();
            IStakingProxy(stakingProxy).withdraw(stakeBalance);
        }
        isShutdown = true;
    }

    //set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, uint256(-1));

        IERC20(stakingToken).safeApprove(stakingProxy, 0);
        IERC20(stakingToken).safeApprove(stakingProxy, uint256(-1));
    }

    /* ========== VIEWS ========== */

    function _rewardPerToken(address _rewardsToken)
        internal
        view
        returns (uint256)
    {
        if (boostedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(
                    rewardData[_rewardsToken]
                        .periodFinish
                )
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(
                    rewardData[_rewardsToken].useBoost
                        ? boostedSupply
                        : lockedSupply
                )
            );
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        return
            _balance
                .mul(
                _rewardPerToken(_rewardsToken).sub(
                    userRewardPerTokenPaid[_user][_rewardsToken]
                )
            )
                .div(1e18)
                .add(rewards[_user][_rewardsToken]);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime)
        internal
        view
        returns (uint256)
    {
        return Math.min(block.timestamp, _finishTime);
    }

    function lastTimeRewardApplicable(address _rewardsToken)
        public
        view
        returns (uint256)
    {
        return
            _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return _rewardPerToken(_rewardsToken);
    }

    function getRewardForDuration(address _rewardsToken)
        external
        view
        returns (uint256)
    {
        return
            uint256(rewardData[_rewardsToken].rewardRate).mul(rewardsDuration);
    }

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account)
        external
        view
        returns (EarnedData[] memory userRewards)
    {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 boostedBal = userBalance.boosted;
        for (uint256 i = 0; i < userRewards.length; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(
                _account,
                token,
                rewardData[token].useBoost ? boostedBal : userBalance.locked
            );
        }
        return userRewards;
    }

    // Total BOOSTED balance of an account, including unlocked but not withdrawn tokens
    function rewardWeightOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].boosted;
    }

    // total token balance of an account, including unlocked but not withdrawn tokens
    function lockedBalanceOf(address _user)
        external
        view
        returns (uint256 amount)
    {
        return balances[_user].locked;
    }

    //BOOSTED balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;

        //start with current boosted amount
        amount = balances[_user].boosted;

        uint256 locksLength = locks.length;
        //remove old records only (will be better gas-wise than adding up)
        for (uint256 i = nextUnlockIndex; i < locksLength; i++) {
            if (locks[i].unlockTime <= block.timestamp) {
                amount = amount.sub(locks[i].boosted);
            } else {
                //stop now as no futher checks are needed
                break;
            }
        }

        //also remove amount in the current epoch
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        if (
            locksLength > 0 &&
            uint256(locks[locksLength - 1].unlockTime).sub(lockDuration) ==
            currentEpoch
        ) {
            amount = amount.sub(locks[locksLength - 1].boosted);
        }

        return amount;
    }

    //BOOSTED balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user)
        external
        view
        returns (uint256 amount)
    {
        LockedBalance[] storage locks = userLocks[_user];

        //get timestamp of given epoch index
        uint256 epochTime = epochs[_epoch].date;
        //get timestamp of first non-inclusive epoch
        uint256 cutoffEpoch = epochTime.sub(lockDuration);

        //current epoch is not counted
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = locks.length - 1; i + 1 != 0; i--) {
            uint256 lockEpoch = uint256(locks[i].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch <= epochTime && lockEpoch < currentEpoch) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i].boosted);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    //supply of all properly locked BOOSTED balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 cutoffEpoch = currentEpoch.sub(lockDuration);
        uint256 epochindex = epochs.length;

        //do not include current epoch's supply
        if (uint256(epochs[epochindex - 1].date) == currentEpoch) {
            epochindex--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = epochindex - 1; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(e.supply);
        }

        return supply;
    }

    //supply of all properly locked BOOSTED balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch)
        external
        view
        returns (uint256 supply)
    {
        uint256 epochStart =
            uint256(epochs[_epoch].date).div(rewardsDuration).mul(
                rewardsDuration
            );
        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);

        //do not include current epoch's supply
        if (uint256(epochs[_epoch].date) == currentEpoch) {
            _epoch--;
        }

        //traverse inversely to make more current queries more gas efficient
        for (uint256 i = _epoch; i + 1 != 0; i--) {
            Epoch storage e = epochs[i];
            if (uint256(e.date) <= cutoffEpoch) {
                break;
            }
            supply = supply.add(epochs[i].supply);
        }

        return supply;
    }

    //find an epoch index based on timestamp
    function findEpochId(uint256 _time) external view returns (uint256 epoch) {
        uint256 max = epochs.length - 1;
        uint256 min = 0;

        //convert to start point
        _time = _time.div(rewardsDuration).mul(rewardsDuration);

        for (uint256 i = 0; i < 128; i++) {
            if (min >= max) break;

            uint256 mid = (min + max + 1) / 2;
            uint256 midEpochBlock = epochs[mid].date;
            if (midEpochBlock == _time) {
                //found
                return mid;
            } else if (midEpochBlock < _time) {
                min = mid;
            } else {
                max = mid - 1;
            }
        }
        return min;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    //number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length

        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate =
                    uint256(epochs[epochs.length - 1].date).add(
                        rewardsDuration
                    );
                epochs.push(Epoch({supply: 0, date: uint32(nextEpochDate)}));
            }

            //update boost parameters on a new epoch
            if (boostRate != nextBoostRate) {
                boostRate = nextBoostRate;
            }
            if (maximumBoostPayment != nextMaximumBoostPayment) {
                maximumBoostPayment = nextMaximumBoostPayment;
            }
        }
    }

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount, _spendRatio);
    }

    //lock tokens
    function _lock(
        address _account,
        uint256 _amount,
        uint256 _spendRatio
    ) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(_spendRatio <= maximumBoostPayment, ""over max spend"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //calc lock and boosted amount
        uint256 spendAmount = _amount.mul(_spendRatio).div(denominator);
        uint256 boostRatio =
            boostRate.mul(_spendRatio).div(
                maximumBoostPayment == 0 ? 1 : maximumBoostPayment
            );
        uint112 lockAmount = _amount.sub(spendAmount).to112();
        uint112 boostedAmount =
            _amount.add(_amount.mul(boostRatio).div(denominator)).to112();

        //add user balances
        bal.locked = bal.locked.add(lockAmount);
        bal.boosted = bal.boosted.add(boostedAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(lockAmount);
        boostedSupply = boostedSupply.add(boostedAmount);

        //add user lock records or add to current
        uint256 currentEpoch =
            block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(
                LockedBalance({
                    amount: lockAmount,
                    boosted: boostedAmount,
                    unlockTime: uint32(unlockTime)
                })
            );
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
            userL.boosted = userL.boosted.add(boostedAmount);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(uint224(boostedAmount));

        //send boost payment
        if (spendAmount > 0) {
            stakingToken.safeTransfer(boostPayment, spendAmount);
        }

        //update staking, allow a bit of leeway for smaller deposits to reduce gas
        updateStakeRatio(stakeOffsetOnLock);

        emit Staked(_account, _amount, lockAmount, boostedAmount);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint112 boostedAmount;
        uint256 length = locks.length;
        uint256 reward = 0;

        if (
            isShutdown ||
            locks[length - 1].unlockTime <= block.timestamp.sub(_checkDelay)
        ) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;
            boostedAmount = userBalance.boosted;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch =
                    block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(
                        rewardsDuration
                    );
                uint256 epochsover =
                    currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(
                        rewardsDuration
                    );
                uint256 rRate =
                    MathUtil.min(
                        kickRewardPerEpoch.mul(epochsover + 1),
                        denominator
                    );
                reward = uint256(locks[length - 1].amount).mul(rRate).div(
                    denominator
                );
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > block.timestamp.sub(_checkDelay))
                    break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);
                boostedAmount = boostedAmount.add(locks[i].boosted);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch =
                        block
                            .timestamp
                            .sub(_checkDelay)
                            .div(rewardsDuration)
                            .mul(rewardsDuration);
                    uint256 epochsover =
                        currentEpoch.sub(uint256(locks[i].unlockTime)).div(
                            rewardsDuration
                        );
                    uint256 rRate =
                        MathUtil.min(
                            kickRewardPerEpoch.mul(epochsover + 1),
                            denominator
                        );
                    reward = reward.add(
                        uint256(locks[i].amount).mul(rRate).div(denominator)
                    );
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        userBalance.boosted = userBalance.boosted.sub(boostedAmount);
        lockedSupply = lockedSupply.sub(locked);
        boostedSupply = boostedSupply.sub(boostedAmount);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //if theres a reward(kicked), it will always be a withdraw only
            //preallocate enough cvx from stake contract to pay for both reward and withdraw
            allocateCVXForTransfer(uint256(locked));

            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            transferCVX(_rewardAddress, reward, false);

            emit KickReward(_rewardAddress, _account, reward);
        } else if (_spendRatio > 0) {
            //preallocate enough cvx to transfer the boost cost
            allocateCVXForTransfer(
                uint256(locked).mul(_spendRatio).div(denominator)
            );
        }

        //relock or return to user
        if (_relock) {
            _lock(_withdrawTo, locked, _spendRatio);
        } else {
            transferCVX(_withdrawTo, locked, true);
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(
        bool _relock,
        uint256 _spendRatio,
        address _withdrawTo
    ) external nonReentrant {
        _processExpiredLocks(
            msg.sender,
            _relock,
            _spendRatio,
            _withdrawTo,
            msg.sender,
            0
        );
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, 0, msg.sender, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(
            _account,
            false,
            0,
            _account,
            msg.sender,
            rewardsDuration.mul(kickRewardEpochDelay)
        );
    }

    //pull required amount of cvx from staking for an upcoming transfer
    function allocateCVXForTransfer(uint256 _amount) internal {
        uint256 balance = stakingToken.balanceOf(address(this));
        if (_amount > balance) {
            IStakingProxy(stakingProxy).withdraw(_amount.sub(balance));
        }
    }

    //transfer helper: pull enough from staking, transfer, updating staking ratio
    function transferCVX(
        address _account,
        uint256 _amount,
        bool _updateStake
    ) internal {
        //allocate enough cvx from staking for the transfer
        allocateCVXForTransfer(_amount);
        //transfer
        stakingToken.safeTransfer(_account, _amount);

        //update staking
        if (_updateStake) {
            updateStakeRatio(0);
        }
    }

    //calculate how much cvx should be staked. update if needed
    function updateStakeRatio(uint256 _offset) internal {
        if (isShutdown) return;

        //get balances
        uint256 local = stakingToken.balanceOf(address(this));
        uint256 staked = IStakingProxy(stakingProxy).getBalance();
        uint256 total = local.add(staked);

        if (total == 0) return;

        //current staked ratio
        uint256 ratio = staked.mul(denominator).div(total);
        //mean will be where we reset to if unbalanced
        uint256 mean = maximumStake.add(minimumStake).div(2);
        uint256 max = maximumStake.add(_offset);
        uint256 min = Math.min(minimumStake, minimumStake - _offset);
        if (ratio > max) {
            //remove
            uint256 remove = staked.sub(total.mul(mean).div(denominator));
            IStakingProxy(stakingProxy).withdraw(remove);
        } else if (ratio < min) {
            //add
            uint256 increase = total.mul(mean).div(denominator).sub(staked);
            stakingToken.safeTransfer(stakingProxy, increase);
            IStakingProxy(stakingProxy).stake();
        }
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake)
        public
        nonReentrant
        updateReward(_account)
    {
        for (uint256 i; i < rewardTokens.length; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = rewards[_account][_rewardsToken];
            if (reward > 0) {
                rewards[_account][_rewardsToken] = 0;
                if (_rewardsToken == cvxCrv && _stake) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function _notifyReward(address _rewardsToken, uint256 _reward) internal {
        Reward storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to208();
        } else {
            uint256 remaining =
                uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward
                .add(leftover)
                .div(rewardsDuration)
                .to208();
        }

        rdata.lastUpdateTime = block.timestamp.to40();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to40();
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward)
        external
        updateReward(address(0))
    {
        require(rewardDistributors[_rewardsToken][msg.sender]);
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(
            msg.sender,
            address(this),
            _reward
        );

        emit RewardAdded(_rewardsToken, _reward);

        if (_rewardsToken == cvxCrv) {
            //update staking ratio if main reward
            updateStakeRatio(0);
        }
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount)
        external
        onlyOwner
    {
        require(
            _tokenAddress != address(stakingToken),
            ""Cannot withdraw staking token""
        );
        require(
            rewardData[_tokenAddress].lastUpdateTime == 0,
            ""Cannot withdraw reward token""
        );
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address _account) {
        {
            //stack too deep
            Balances storage userBalance = balances[_account];
            uint256 boostedBal = userBalance.boosted;
            for (uint256 i = 0; i < rewardTokens.length; i++) {
                address token = rewardTokens[i];
                rewardData[token].rewardPerTokenStored = _rewardPerToken(token)
                    .to208();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(
                    rewardData[token]
                        .periodFinish
                )
                    .to40();
                if (_account != address(0)) {
                    //check if reward is boostable or not. use boosted or locked balance accordingly
                    rewards[_account][token] = _earned(
                        _account,
                        token,
                        rewardData[token].useBoost
                            ? boostedBal
                            : userBalance.locked
                    );
                    userRewardPerTokenPaid[_account][token] = rewardData[token]
                        .rewardPerTokenStored;
                }
            }
        }
        _;
    }

    /* ========== EVENTS ========== */
    event RewardAdded(address indexed _token, uint256 _reward);
    event Staked(
        address indexed _user,
        uint256 _paidAmount,
        uint256 _lockedAmount,
        uint256 _boostedAmount
    );
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(
        address indexed _user,
        address indexed _kicked,
        uint256 _reward
    );
    event RewardPaid(
        address indexed _user,
        address indexed _rewardsToken,
        uint256 _reward
    );
    event Recovered(address _token, uint256 _amount);
}",7607
RealWorld_TA_31_BaseStrategy_RealWorld_20240804072409.log,31,BaseStrategy,233173,4052,237225,131.0,1.246905,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""interfaces/uniswap/IUniswapRouterV2.sol"";
import ""interfaces/badger/IController.sol"";
import ""interfaces/badger/IStrategy.sol"";

import ""../SettAccessControl.sol"";

/*
    ===== Badger Base Strategy =====
    Common base class for all Sett strategies

    Changelog
    V1.1
    - Verify amount unrolled from strategy positions on withdraw() is within a threshold relative to the requested amount as a sanity check
    - Add version number which is displayed with baseStrategyVersion(). If a strategy does not implement this function, it can be assumed to be 1.0

    V1.2
    - Remove idle want handling from base withdraw() function. This should be handled as the strategy sees fit in _withdrawSome()
*/
abstract contract BaseStrategy is PausableUpgradeable, SettAccessControl {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    event Withdraw(uint256 amount);
    event WithdrawAll(uint256 balance);
    event WithdrawOther(address token, uint256 amount);
    event SetStrategist(address strategist);
    event SetGovernance(address governance);
    event SetController(address controller);
    event SetWithdrawalFee(uint256 withdrawalFee);
    event SetPerformanceFeeStrategist(uint256 performanceFeeStrategist);
    event SetPerformanceFeeGovernance(uint256 performanceFeeGovernance);
    event Harvest(uint256 harvested, uint256 indexed blockNumber);
    event Tend(uint256 tended);

    address public want; // Want: Curve.fi renBTC/wBTC (crvRenWBTC) LP token

    uint256 public performanceFeeGovernance;
    uint256 public performanceFeeStrategist;
    uint256 public withdrawalFee;

    uint256 public constant MAX_FEE = 10000;

    address public controller;
    address public guardian;

    uint256 public withdrawalMaxDeviationThreshold;

    function __BaseStrategy_init(
        address _governance,
        address _strategist,
        address _controller,
        address _keeper,
        address _guardian
    ) public initializer whenNotPaused {
        __Pausable_init();
        governance = _governance;
        strategist = _strategist;
        keeper = _keeper;
        controller = _controller;
        guardian = _guardian;
        withdrawalMaxDeviationThreshold = 50;
    }

    // ===== Modifiers =====

    function _onlyController() internal view {
        require(msg.sender == controller, ""onlyController"");
    }

    function _onlyAuthorizedActorsOrController() internal view {
        require(msg.sender == keeper || msg.sender == governance || msg.sender == controller, ""onlyAuthorizedActorsOrController"");
    }

    function _onlyAuthorizedPausers() internal view {
        require(msg.sender == guardian || msg.sender == governance, ""onlyPausers"");
    }

    /// ===== View Functions =====
    function baseStrategyVersion() public view returns (string memory) {
        return ""1.2"";
    }

    /// @notice Get the balance of want held idle in the Strategy
    function balanceOfWant() public view returns (uint256) {
        return IERC20Upgradeable(want).balanceOf(address(this));
    }

    /// @notice Get the total balance of want realized in the strategy, whether idle or active in Strategy positions.
    function balanceOf() public virtual view returns (uint256) {
        return balanceOfWant().add(balanceOfPool());
    }

    function isTendable() public virtual view returns (bool) {
        return false;
    }

    function isProtectedToken(address token) public view returns (bool) {
        address[] memory protectedTokens = getProtectedTokens();
        for (uint256 i = 0; i < protectedTokens.length; i++) {
            if (token == protectedTokens[i]) {
                return true;
            }
        }
        return false;
    }

    /// ===== Permissioned Actions: Governance =====

    function setGuardian(address _guardian) external {
        _onlyGovernance();
        guardian = _guardian;
    }

    function setWithdrawalFee(uint256 _withdrawalFee) external {
        _onlyGovernance();
        require(_withdrawalFee <= MAX_FEE, ""base-strategy/excessive-withdrawal-fee"");
        withdrawalFee = _withdrawalFee;
    }

    function setPerformanceFeeStrategist(uint256 _performanceFeeStrategist) external {
        _onlyGovernance();
        require(_performanceFeeStrategist <= MAX_FEE, ""base-strategy/excessive-strategist-performance-fee"");
        performanceFeeStrategist = _performanceFeeStrategist;
    }

    function setPerformanceFeeGovernance(uint256 _performanceFeeGovernance) external {
        _onlyGovernance();
        require(_performanceFeeGovernance <= MAX_FEE, ""base-strategy/excessive-governance-performance-fee"");
        performanceFeeGovernance = _performanceFeeGovernance;
    }

    function setController(address _controller) external {
        _onlyGovernance();
        controller = _controller;
    }

    function setWithdrawalMaxDeviationThreshold(uint256 _threshold) external {
        _onlyGovernance();
        require(_threshold <= MAX_FEE, ""base-strategy/excessive-max-deviation-threshold"");
        withdrawalMaxDeviationThreshold = _threshold;
    }

    function deposit() public virtual whenNotPaused {
        _onlyAuthorizedActorsOrController();
        uint256 _want = IERC20Upgradeable(want).balanceOf(address(this));
        if (_want > 0) {
            _deposit(_want);
        }
        _postDeposit();
    }

    // ===== Permissioned Actions: Controller =====

    /// @notice Controller-only function to Withdraw partial funds, normally used with a vault withdrawal
    function withdrawAll() external virtual whenNotPaused returns (uint256 balance) {
        _onlyController();

        _withdrawAll();

        _transferToVault(IERC20Upgradeable(want).balanceOf(address(this)));
    }

    /// @notice Withdraw partial funds from the strategy, unrolling from strategy positions as necessary
    /// @notice Processes withdrawal fee if present
    /// @dev If it fails to recover sufficient funds (defined by withdrawalMaxDeviationThreshold), the withdrawal should fail so that this unexpected behavior can be investigated
    function withdraw(uint256 _amount) external virtual whenNotPaused {
        _onlyController();

        // Withdraw from strategy positions, typically taking from any idle want first.
        _withdrawSome(_amount);
        uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));

        // Sanity check: Ensure we were able to retrieve sufficent want from strategy positions
        // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold
        if (_postWithdraw < _amount) {
            uint256 diff = _diff(_amount, _postWithdraw);

            // Require that difference between expected and actual values is less than the deviation threshold percentage
            require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_FEE), ""base-strategy/withdraw-exceed-max-deviation-threshold"");
        }

        // Return the amount actually withdrawn if less than amount requested
        uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);

        // Process withdrawal fee
        uint256 _fee = _processWithdrawalFee(_toWithdraw);

        // Transfer remaining to Vault to handle withdrawal
        _transferToVault(_toWithdraw.sub(_fee));
    }

    // NOTE: must exclude any tokens used in the yield
    // Controller role - withdraw should return to Controller
    function withdrawOther(address _asset) external virtual whenNotPaused returns (uint256 balance) {
        _onlyController();
        _onlyNotProtectedTokens(_asset);

        balance = IERC20Upgradeable(_asset).balanceOf(address(this));
        IERC20Upgradeable(_asset).safeTransfer(controller, balance);
    }

    /// ===== Permissioned Actions: Authoized Contract Pausers =====

    function pause() external {
        _onlyAuthorizedPausers();
        _pause();
    }

    function unpause() external {
        _onlyGovernance();
        _unpause();
    }

    /// ===== Internal Helper Functions =====

    /// @notice If withdrawal fee is active, take the appropriate amount from the given value and transfer to rewards recipient
    /// @return The withdrawal fee that was taken
    function _processWithdrawalFee(uint256 _amount) internal returns (uint256) {
        if (withdrawalFee == 0) {
            return 0;
        }

        uint256 fee = _amount.mul(withdrawalFee).div(MAX_FEE);
        IERC20Upgradeable(want).safeTransfer(IController(controller).rewards(), fee);
        return fee;
    }

    /// @dev Helper function to process an arbitrary fee
    /// @dev If the fee is active, transfers a given portion in basis points of the specified value to the recipient
    /// @return The fee that was taken
    function _processFee(
        address token,
        uint256 amount,
        uint256 feeBps,
        address recipient
    ) internal returns (uint256) {
        if (feeBps == 0) {
            return 0;
        }
        uint256 fee = amount.mul(feeBps).div(MAX_FEE);
        IERC20Upgradeable(token).safeTransfer(recipient, fee);
        return fee;
    }

    function _transferToVault(uint256 _amount) internal {
        address _vault = IController(controller).vaults(address(want));
        require(_vault != address(0), ""!vault""); // additional protection so we don't burn the funds
        IERC20Upgradeable(want).safeTransfer(_vault, _amount);
    }

    /// @notice Utility function to diff two numbers, expects higher value in first position
    function _diff(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, ""diff/expected-higher-number-in-first-position"");
        return a.sub(b);
    }

    // ===== Abstract Functions: To be implemented by specific Strategies =====

    /// @dev Internal deposit logic to be implemented by Stratgies
    function _deposit(uint256 _want) internal virtual;

    function _postDeposit() internal virtual {
        //no-op by default
    }

    /// @notice Specify tokens used in yield process, should not be available to withdraw via withdrawOther()
    function _onlyNotProtectedTokens(address _asset) internal virtual;

    function getProtectedTokens() public virtual view returns (address[] memory) {
        return new address[](0);
    }

    /// @dev Internal logic for strategy migration. Should exit positions as efficiently as possible
    function _withdrawAll() internal virtual;

    /// @dev Internal logic for partial withdrawals. Should exit positions as efficiently as possible.
    /// @dev The withdraw() function shell automatically uses idle want in the strategy before attempting to withdraw more using this
    function _withdrawSome(uint256 _amount) internal virtual returns (uint256);

    /// @dev Realize returns from positions
    /// @dev Returns can be reinvested into positions, or distributed in another fashion
    /// @dev Performance fees should also be implemented in this function
    /// @dev Override function stub is removed as each strategy can have it's own return signature for STATICCALL
    // function harvest() external virtual;

    /// @dev User-friendly name for this strategy for purposes of convenient reading
    function getName() external virtual pure returns (string memory);

    /// @dev Balance of want currently held in strategy positions
    function balanceOfPool() public virtual view returns (uint256);

    uint256[49] private __gap;
}",2626
RealWorld_TA_31_EnumerableSet_RealWorld_20240804034339.log,31,EnumerableSet,179885,1260,181145,92.0,0.924625,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`
 * (`UintSet`) are supported.
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            bytes32 lastvalue = set._values[lastIndex];

            // Move the last value to the index where the value to delete is
            set._values[toDeleteIndex] = lastvalue;
            // Update the index for the moved value
            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value)
        private
        view
        returns (bool)
    {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index)
        private
        view
        returns (bytes32)
    {
        require(
            set._values.length > index,
            ""EnumerableSet: index out of bounds""
        );
        return set._values[index];
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value)
        internal
        returns (bool)
    {
        return _add(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value)
        internal
        returns (bool)
    {
        return _remove(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value)
        internal
        view
        returns (bool)
    {
        return _contains(set._inner, bytes32(uint256(value)));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index)
        internal
        view
        returns (address)
    {
        return address(uint256(_at(set._inner, index)));
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value)
        internal
        returns (bool)
    {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value)
        internal
        view
        returns (bool)
    {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index)
        internal
        view
        returns (uint256)
    {
        return uint256(_at(set._inner, index));
    }
}",1920
RealWorld_TA_31_BadgerGuestlistApi_RealWorld_20240804061850.log,31,BadgerGuestlistApi,25496,1863,27359,84.0,0.16474,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.7.0;

interface BadgerGuestListAPI {
    function authorized(
        address guest,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external view returns (bool);

    function setGuests(address[] calldata _guests, bool[] calldata _invited)
        external;
}",85
RealWorld_TA_31_ContextUpgradeable_RealWorld_20240804052622.log,31,ContextUpgradeable,39233,1296,40529,80.0,0.222085,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;
import ""../proxy/Initializable.sol"";

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract ContextUpgradeable is Initializable {
    function __Context_init() internal initializer {
        __Context_init_unchained();
    }

    function __Context_init_unchained() internal initializer {}

    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }

    uint256[50] private __gap;
}",248
RealWorld_TA_31_ConditionalEscrowUpgradeable_RealWorld_20240804053719.log,31,ConditionalEscrowUpgradeable,42384,2785,45169,92.0,0.26762,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./EscrowUpgradeable.sol"";
import ""../../proxy/Initializable.sol"";

/**
 * @title ConditionalEscrow
 * @dev Base abstract escrow to only allow withdrawal if a condition is met.
 * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.
 */
abstract contract ConditionalEscrowUpgradeable is
    Initializable,
    EscrowUpgradeable
{
    function __ConditionalEscrow_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
        __Escrow_init_unchained();
        __ConditionalEscrow_init_unchained();
    }

    function __ConditionalEscrow_init_unchained() internal initializer {}

    /**
     * @dev Returns whether an address is allowed to withdraw their funds. To be
     * implemented by derived contracts.
     * @param payee The destination address of the funds.
     */
    function withdrawalAllowed(address payee)
        public
        view
        virtual
        returns (bool);

    function withdraw(address payable payee) public virtual override {
        require(
            withdrawalAllowed(payee),
            ""ConditionalEscrow: payee is not allowed to withdraw""
        );
        super.withdraw(payee);
    }

    uint256[50] private __gap;
}",282
RealWorld_TA_31_ECDSA_RealWorld_20240804032359.log,31,ECDSA,97841,1606,99447,86.0,0.521325,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature)
        internal
        pure
        returns (address)
    {
        // Check the signature length
        if (signature.length != 65) {
            revert(""ECDSA: invalid signature length"");
        }

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (
            uint256(s) >
            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
        ) {
            revert(""ECDSA: invalid signature 's' value"");
        }

        if (v != 27 && v != 28) {
            revert(""ECDSA: invalid signature 'v' value"");
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        require(signer != address(0), ""ECDSA: invalid signature"");

        return signer;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash)
        internal
        pure
        returns (bytes32)
    {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return
            keccak256(
                abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)
            );
    }
}",941
RealWorld_TA_31_ConditionalEscrow_RealWorld_20240804033343.log,31,ConditionalEscrow,34476,2078,36554,86.0,0.21394,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""./Escrow.sol"";

/**
 * @title ConditionalEscrow
 * @dev Base abstract escrow to only allow withdrawal if a condition is met.
 * @dev Intended usage: See {Escrow}. Same usage guidelines apply here.
 */
abstract contract ConditionalEscrow is Escrow {
    /**
     * @dev Returns whether an address is allowed to withdraw their funds. To be
     * implemented by derived contracts.
     * @param payee The destination address of the funds.
     */
    function withdrawalAllowed(address payee)
        public
        view
        virtual
        returns (bool);

    function withdraw(address payable payee) public virtual override {
        require(
            withdrawalAllowed(payee),
            ""ConditionalEscrow: payee is not allowed to withdraw""
        );
        super.withdraw(payee);
    }
}",188
RealWorld_TA_31_BaseUpgradeabilityProxy_RealWorld_20240804041959.log,31,BaseUpgradeabilityProxy,53905,1971,55876,87.0,0.308945,"pragma solidity ^0.5.0;

import ""./Proxy.sol"";
import ""../utils/Address.sol"";

/**
 * @title BaseUpgradeabilityProxy
 * @dev This contract implements a proxy that allows to change the
 * implementation address to which it will delegate.
 * Such a change is called an implementation upgrade.
 */
contract BaseUpgradeabilityProxy is Proxy {
    /**
     * @dev Emitted when the implementation is upgraded.
     * @param implementation Address of the new implementation.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Returns the current implementation.
     * @return Address of the current implementation
     */
    function _implementation() internal view returns (address impl) {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }

    /**
     * @dev Upgrades the proxy to a new implementation.
     * @param newImplementation Address of the new implementation.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Sets the implementation address of the proxy.
     * @param newImplementation Address of the new implementation.
     */
    function _setImplementation(address newImplementation) internal {
        require(
            OpenZeppelinUpgradesAddress.isContract(newImplementation),
            ""Cannot set a proxy implementation to a non-contract address""
        );

        bytes32 slot = IMPLEMENTATION_SLOT;

        assembly {
            sstore(slot, newImplementation)
        }
    }
}",418
RealWorld_TA_31_Context_RealWorld_20240804032238.log,31,Context,34968,1491,36459,79.0,0.20466,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}",194
RealWorld_TA_31_CurveSwapper_RealWorld_20240804072938.log,31,CurveSwapper,74001,2947,76948,99.0,0.428945,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol"";
import ""deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""interfaces/curve/ICurveFi.sol"";
import ""./BaseSwapper.sol"";

/*
    Expands swapping functionality over base strategy
    - ETH in and ETH out Variants
    - Sushiswap support in addition to Uniswap
*/
contract CurveSwapper is BaseSwapper {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    function _add_liquidity_single_coin(
        address swap,
        address pool,
        address inputToken,
        uint256 inputAmount,
        uint256 inputPosition,
        uint256 numPoolElements,
        uint256 min_mint_amount
    ) internal {
        _safeApproveHelper(inputToken, swap, inputAmount);
        if (numPoolElements == 2) {
            uint256[2] memory convertedAmounts;
            convertedAmounts[inputPosition] = inputAmount;
            ICurveFi(swap).add_liquidity(convertedAmounts, min_mint_amount);
        } else if (numPoolElements == 3) {
            uint256[3] memory convertedAmounts;
            convertedAmounts[inputPosition] = inputAmount;
            ICurveFi(swap).add_liquidity(convertedAmounts, min_mint_amount);
        } else if (numPoolElements == 4) {
            uint256[4] memory convertedAmounts;
            convertedAmounts[inputPosition] = inputAmount;
            ICurveFi(swap).add_liquidity(convertedAmounts, min_mint_amount);
        } else {
            revert(""Invalid number of amount elements"");
        }
    }

    function _add_liquidity(
        address pool,
        uint256[2] memory amounts,
        uint256 min_mint_amount
    ) internal {
        ICurveFi(pool).add_liquidity(amounts, min_mint_amount);
    }

    function _add_liquidity(
        address pool,
        uint256[3] memory amounts,
        uint256 min_mint_amount
    ) internal {
        ICurveFi(pool).add_liquidity(amounts, min_mint_amount);
    }

    function _add_liquidity(
        address pool,
        uint256[4] memory amounts,
        uint256 min_mint_amount
    ) internal {
        ICurveFi(pool).add_liquidity(amounts, min_mint_amount);
    }

    function _remove_liquidity_one_coin(
        address swap,
        uint256 _token_amount,
        int128 i,
        uint256 _min_amount
    ) internal {
        ICurveFi(swap).remove_liquidity_one_coin(_token_amount, i, _min_amount);
    }
}",690
RealWorld_TA_31_Create2Upgradeable_RealWorld_20240804054831.log,31,Create2Upgradeable,69456,1665,71121,82.0,0.38058,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.
 * `CREATE2` can be used to compute in advance the address where a smart
 * contract will be deployed, which allows for interesting new mechanisms known
 * as 'counterfactual interactions'.
 *
 * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more
 * information.
 */
library Create2Upgradeable {
    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address) {
        address addr;
        require(
            address(this).balance >= amount,
            ""Create2: insufficient balance""
        );
        require(bytecode.length != 0, ""Create2: bytecode length is zero"");
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), ""Create2: Failed on deploy"");
        return addr;
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the
     * `bytecodeHash` or `salt` will result in a new destination address.
     */
    function computeAddress(bytes32 salt, bytes32 bytecodeHash)
        internal
        view
        returns (address)
    {
        return computeAddress(salt, bytecodeHash, address(this));
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at
     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.
     */
    function computeAddress(
        bytes32 salt,
        bytes32 bytecodeHash,
        address deployer
    ) internal pure returns (address) {
        bytes32 _data =
            keccak256(
                abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)
            );
        return address(uint256(_data));
    }
}",604
RealWorld_TA_31_CountersUpgradeable_RealWorld_20240804054955.log,31,CountersUpgradeable,48388,1389,49777,83.0,0.26972,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../math/SafeMathUpgradeable.sol"";

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}
 * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never
 * directly accessed.
 */
library CountersUpgradeable {
    using SafeMathUpgradeable for uint256;

    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        // The {SafeMath} overflow check can be skipped here, see the comment at the top
        counter._value += 1;
    }

    function decrement(Counter storage counter) internal {
        counter._value = counter._value.sub(1);
    }
}",356
RealWorld_TA_31_BoringMath_RealWorld_20240804063312.log,31,BoringMath,136743,1274,138017,81.0,0.709195,"// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }

    function to40(uint256 a) internal pure returns (uint40 c) {
        require(a <= uint40(-1), ""BoringMath: uint40 Overflow"");
        c = uint40(a);
    }

    function to112(uint256 a) internal pure returns (uint112 c) {
        require(a <= uint112(-1), ""BoringMath: uint112 Overflow"");
        c = uint112(a);
    }

    function to224(uint256 a) internal pure returns (uint224 c) {
        require(a <= uint224(-1), ""BoringMath: uint224 Overflow"");
        c = uint224(a);
    }

    function to208(uint256 a) internal pure returns (uint208 c) {
        require(a <= uint208(-1), ""BoringMath: uint208 Overflow"");
        c = uint208(a);
    }

    function to216(uint256 a) internal pure returns (uint216 c) {
        require(a <= uint216(-1), ""BoringMath: uint216 Overflow"");
        c = uint216(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint32 a, uint32 b) internal pure returns (uint32) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint112.
library BoringMath112 {
    function add(uint112 a, uint112 b) internal pure returns (uint112 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint112 a, uint112 b) internal pure returns (uint112 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint112 a, uint112 b) internal pure returns (uint112 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint112 a, uint112 b) internal pure returns (uint112) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint224.
library BoringMath224 {
    function add(uint224 a, uint224 b) internal pure returns (uint224 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint224 a, uint224 b) internal pure returns (uint224 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint224 a, uint224 b) internal pure returns (uint224 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function div(uint224 a, uint224 b) internal pure returns (uint224) {
        require(b > 0, ""BoringMath: division by zero"");
        return a / b;
    }
}",1415
RealWorld_TA_31_Address_RealWorld_20240804034211.log,31,Address,135937,1790,137727,86.0,0.715485,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            ""Address: insufficient balance""
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{value: amount}("""");
        require(
            success,
            ""Address: unable to send value, recipient may have reverted""
        );
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                ""Address: low-level call with value failed""
            );
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            ""Address: insufficient balance for call""
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) =
            target.call{value: weiValue}(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1396
RealWorld_TA_31_Create2_RealWorld_20240804034513.log,31,Create2,69290,1283,70573,77.0,0.37211,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.
 * `CREATE2` can be used to compute in advance the address where a smart
 * contract will be deployed, which allows for interesting new mechanisms known
 * as 'counterfactual interactions'.
 *
 * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more
 * information.
 */
library Create2 {
    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address) {
        address addr;
        require(
            address(this).balance >= amount,
            ""Create2: insufficient balance""
        );
        require(bytecode.length != 0, ""Create2: bytecode length is zero"");
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), ""Create2: Failed on deploy"");
        return addr;
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the
     * `bytecodeHash` or `salt` will result in a new destination address.
     */
    function computeAddress(bytes32 salt, bytes32 bytecodeHash)
        internal
        view
        returns (address)
    {
        return computeAddress(salt, bytecodeHash, address(this));
    }

    /**
     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at
     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.
     */
    function computeAddress(
        bytes32 salt,
        bytes32 bytecodeHash,
        address deployer
    ) internal pure returns (address) {
        bytes32 _data =
            keccak256(
                abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)
            );
        return address(uint256(_data));
    }
}",602
RealWorld_TA_31_Arrays_RealWorld_20240804034047.log,31,Arrays,48047,1459,49506,82.0,0.269415,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../math/Math.sol"";

/**
 * @dev Collection of functions related to array types.
 */
library Arrays {
    /**
     * @dev Searches a sorted `array` and returns the first index that contains
     * a value greater or equal to `element`. If no such index exists (i.e. all
     * values in the array are strictly less than `element`), the array length is
     * returned. Time complexity O(log n).
     *
     * `array` is expected to be sorted in ascending order, and to contain no
     * repeated elements.
     */
    function findUpperBound(uint256[] storage array, uint256 element)
        internal
        view
        returns (uint256)
    {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid] > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1] == element) {
            return low - 1;
        } else {
            return low;
        }
    }
}",350
RealWorld_TA_31_EnumerableMapUpgradeable_RealWorld_20240804054245.log,31,EnumerableMapUpgradeable,193709,1251,194960,92.0,0.993565,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Library for managing an enumerable variant of Solidity's
 * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
 * type.
 *
 * Maps have the following properties:
 *
 * - Entries are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Entries are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableMap for EnumerableMap.UintToAddressMap;
 *
 *     // Declare a set state variable
 *     EnumerableMap.UintToAddressMap private myMap;
 * }
 * ```
 *
 * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are
 * supported.
 */
library EnumerableMapUpgradeable {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct MapEntry {
        bytes32 _key;
        bytes32 _value;
    }

    struct Map {
        // Storage of map keys and values
        MapEntry[] _entries;
        // Position of the entry defined by a key in the `entries` array, plus 1
        // because index 0 means a key is not in the map.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(
        Map storage map,
        bytes32 key,
        bytes32 value
    ) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex == 0) {
            // Equivalent to !contains(map, key)
            map._entries.push(MapEntry({_key: key, _value: value}));
            // The entry is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            map._indexes[key] = map._entries.length;
            return true;
        } else {
            map._entries[keyIndex - 1]._value = value;
            return false;
        }
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex != 0) {
            // Equivalent to contains(map, key)
            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one
            // in the array, and then remove the last entry (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = keyIndex - 1;
            uint256 lastIndex = map._entries.length - 1;

            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            MapEntry storage lastEntry = map._entries[lastIndex];

            // Move the last entry to the index where the entry to delete is
            map._entries[toDeleteIndex] = lastEntry;
            // Update the index for the moved entry
            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved entry was stored
            map._entries.pop();

            // Delete the index for the deleted slot
            delete map._indexes[key];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key)
        private
        view
        returns (bool)
    {
        return map._indexes[key] != 0;
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._entries.length;
    }

    /**
     * @dev Returns the key-value pair stored at position `index` in the map. O(1).
     *
     * Note that there are no guarantees on the ordering of entries inside the
     * array, and it may change when more entries are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Map storage map, uint256 index)
        private
        view
        returns (bytes32, bytes32)
    {
        require(
            map._entries.length > index,
            ""EnumerableMap: index out of bounds""
        );

        MapEntry storage entry = map._entries[index];
        return (entry._key, entry._value);
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        return _get(map, key, ""EnumerableMap: nonexistent key"");
    }

    /**
     * @dev Same as {_get}, with a custom error message when `key` is not in the map.
     */
    function _get(
        Map storage map,
        bytes32 key,
        string memory errorMessage
    ) private view returns (bytes32) {
        uint256 keyIndex = map._indexes[key];
        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)
        return map._entries[keyIndex - 1]._value; // All indexes are 1-based
    }

    // UintToAddressMap

    struct UintToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        UintToAddressMap storage map,
        uint256 key,
        address value
    ) internal returns (bool) {
        return _set(map._inner, bytes32(key), bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(UintToAddressMap storage map, uint256 key)
        internal
        returns (bool)
    {
        return _remove(map._inner, bytes32(key));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(UintToAddressMap storage map, uint256 key)
        internal
        view
        returns (bool)
    {
        return _contains(map._inner, bytes32(key));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(UintToAddressMap storage map)
        internal
        view
        returns (uint256)
    {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintToAddressMap storage map, uint256 index)
        internal
        view
        returns (uint256, address)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (uint256(key), address(uint256(value)));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(UintToAddressMap storage map, uint256 key)
        internal
        view
        returns (address)
    {
        return address(uint256(_get(map._inner, bytes32(key))));
    }

    /**
     * @dev Same as {get}, with a custom error message when `key` is not in the map.
     */
    function get(
        UintToAddressMap storage map,
        uint256 key,
        string memory errorMessage
    ) internal view returns (address) {
        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));
    }
}",2083
RealWorld_TA_31_AddressUpgradeable_RealWorld_20240804055540.log,31,AddressUpgradeable,136221,2146,138367,100.0,0.724025,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library AddressUpgradeable {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies in extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(
            address(this).balance >= amount,
            ""Address: insufficient balance""
        );

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{value: amount}("""");
        require(
            success,
            ""Address: unable to send value, recipient may have reverted""
        );
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data)
        internal
        returns (bytes memory)
    {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return _functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return
            functionCallWithValue(
                target,
                data,
                value,
                ""Address: low-level call with value failed""
            );
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(
            address(this).balance >= value,
            ""Address: insufficient balance for call""
        );
        return _functionCallWithValue(target, data, value, errorMessage);
    }

    function _functionCallWithValue(
        address target,
        bytes memory data,
        uint256 weiValue,
        string memory errorMessage
    ) private returns (bytes memory) {
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) =
            target.call{value: weiValue}(data);
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1398
RealWorld_TA_31_App_RealWorld_20240804041215.log,31,App,118012,2473,120485,100.0,0.63952,"pragma solidity ^0.5.0;

import ""./ImplementationProvider.sol"";
import ""./Package.sol"";
import ""../upgradeability/AdminUpgradeabilityProxy.sol"";
import ""../ownership/Ownable.sol"";

/**
 * @title App
 * @dev Contract for upgradeable applications.
 * It handles the creation of proxies.
 */
contract App is OpenZeppelinUpgradesOwnable {
    /**
     * @dev Emitted when a new proxy is created.
     * @param proxy Address of the created proxy.
     */
    event ProxyCreated(address proxy);

    /**
     * @dev Emitted when a package dependency is changed in the application.
     * @param providerName Name of the package that changed.
     * @param package Address of the package associated to the name.
     * @param version Version of the package in use.
     */
    event PackageChanged(
        string providerName,
        address package,
        uint64[3] version
    );

    /**
     * @dev Tracks a package in a particular version, used for retrieving implementations
     */
    struct ProviderInfo {
        Package package;
        uint64[3] version;
    }

    /**
     * @dev Maps from dependency name to a tuple of package and version
     */
    mapping(string => ProviderInfo) internal providers;

    /**
     * @dev Constructor function.
     */
    constructor() public {}

    /**
     * @dev Returns the provider for a given package name, or zero if not set.
     * @param packageName Name of the package to be retrieved.
     * @return The provider.
     */
    function getProvider(string memory packageName)
        public
        view
        returns (ImplementationProvider provider)
    {
        ProviderInfo storage info = providers[packageName];
        if (address(info.package) == address(0))
            return ImplementationProvider(0);
        return ImplementationProvider(info.package.getContract(info.version));
    }

    /**
     * @dev Returns information on a package given its name.
     * @param packageName Name of the package to be queried.
     * @return A tuple with the package address and pinned version given a package name, or zero if not set
     */
    function getPackage(string memory packageName)
        public
        view
        returns (Package, uint64[3] memory)
    {
        ProviderInfo storage info = providers[packageName];
        return (info.package, info.version);
    }

    /**
     * @dev Sets a package in a specific version as a dependency for this application.
     * Requires the version to be present in the package.
     * @param packageName Name of the package to set or overwrite.
     * @param package Address of the package to register.
     * @param version Version of the package to use in this application.
     */
    function setPackage(
        string memory packageName,
        Package package,
        uint64[3] memory version
    ) public onlyOwner {
        require(
            package.hasVersion(version),
            ""The requested version must be registered in the given package""
        );
        providers[packageName] = ProviderInfo(package, version);
        emit PackageChanged(packageName, address(package), version);
    }

    /**
     * @dev Unsets a package given its name.
     * Reverts if the package is not set in the application.
     * @param packageName Name of the package to remove.
     */
    function unsetPackage(string memory packageName) public onlyOwner {
        require(
            address(providers[packageName].package) != address(0),
            ""Package to unset not found""
        );
        delete providers[packageName];
        emit PackageChanged(
            packageName,
            address(0),
            [uint64(0), uint64(0), uint64(0)]
        );
    }

    /**
     * @dev Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.
     * @param packageName Name of the package where the contract is contained.
     * @param contractName Name of the contract.
     * @return Address where the contract is implemented.
     */
    function getImplementation(
        string memory packageName,
        string memory contractName
    ) public view returns (address) {
        ImplementationProvider provider = getProvider(packageName);
        if (address(provider) == address(0)) return address(0);
        return provider.getImplementation(contractName);
    }

    /**
     * @dev Creates a new proxy for the given contract and forwards a function call to it.
     * This is useful to initialize the proxied contract.
     * @param packageName Name of the package where the contract is contained.
     * @param contractName Name of the contract.
     * @param admin Address of the proxy administrator.
     * @param data Data to send as msg.data to the corresponding implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     * @return Address of the new proxy.
     */
    function create(
        string memory packageName,
        string memory contractName,
        address admin,
        bytes memory data
    ) public payable returns (AdminUpgradeabilityProxy) {
        address implementation = getImplementation(packageName, contractName);
        AdminUpgradeabilityProxy proxy =
            (new AdminUpgradeabilityProxy).value(msg.value)(
                implementation,
                admin,
                data
            );
        emit ProxyCreated(address(proxy));
        return proxy;
    }
}",1157
RealWorld_TA_31_BaseAdminUpgradeabilityProxy_RealWorld_20240804042305.log,31,BaseAdminUpgradeabilityProxy,94401,2200,96601,93.0,0.516005,"pragma solidity ^0.5.0;

import ""./UpgradeabilityProxy.sol"";

/**
 * @title BaseAdminUpgradeabilityProxy
 * @dev This contract combines an upgradeability proxy with an authorization
 * mechanism for administrative tasks.
 * All external functions in this contract must be guarded by the
 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity
 * feature proposal that would enable this to be done automatically.
 */
contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
    /**
     * @dev Emitted when the administration has been transferred.
     * @param previousAdmin Address of the previous admin.
     * @param newAdmin Address of the new admin.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is
     * validated in the constructor.
     */

    bytes32 internal constant ADMIN_SLOT =
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Modifier to check whether the `msg.sender` is the admin.
     * If it is, it will run the function. Otherwise, it will delegate the call
     * to the implementation.
     */
    modifier ifAdmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @return The address of the proxy admin.
     */
    function admin() external ifAdmin returns (address) {
        return _admin();
    }

    /**
     * @return The address of the implementation.
     */
    function implementation() external ifAdmin returns (address) {
        return _implementation();
    }

    /**
     * @dev Changes the admin of the proxy.
     * Only the current admin can call this function.
     * @param newAdmin Address to transfer proxy administration to.
     */
    function changeAdmin(address newAdmin) external ifAdmin {
        require(
            newAdmin != address(0),
            ""Cannot change the admin of a proxy to the zero address""
        );
        emit AdminChanged(_admin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev Upgrade the backing implementation of the proxy.
     * Only the admin can call this function.
     * @param newImplementation Address of the new implementation.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    /**
     * @dev Upgrade the backing implementation of the proxy and call a function
     * on the new implementation.
     * This is useful to initialize the proxied contract.
     * @param newImplementation Address of the new implementation.
     * @param data Data to send as msg.data in the low level call.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     */
    function upgradeToAndCall(address newImplementation, bytes calldata data)
        external
        payable
        ifAdmin
    {
        _upgradeTo(newImplementation);
        (bool success, ) = newImplementation.delegatecall(data);
        require(success);
    }

    /**
     * @return The admin slot.
     */
    function _admin() internal view returns (address adm) {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Sets the address of the proxy admin.
     * @param newAdmin Address of the new proxy admin.
     */
    function _setAdmin(address newAdmin) internal {
        bytes32 slot = ADMIN_SLOT;

        assembly {
            sstore(slot, newAdmin)
        }
    }

    /**
     * @dev Only fall back when the sender is not the admin.
     */
    function _willFallback() internal {
        require(
            msg.sender != _admin(),
            ""Cannot call fallback function from the proxy admin""
        );
        super._willFallback();
    }
}",902
RealWorld_TA_31_Controller_RealWorld_20240804020636.log,31,Controller,173996,6296,180292,147.0,0.9959,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

import ""../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""../../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";

import ""interfaces/badger/IConverter.sol"";
import ""interfaces/badger/IOneSplitAudit.sol"";
import ""interfaces/badger/IStrategy.sol"";
import ""../../deps/SettAccessControl.sol"";

contract Controller is SettAccessControl {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using SafeMathUpgradeable for uint256;

    address public onesplit;
    address public rewards;
    mapping(address => address) public vaults;
    mapping(address => address) public strategies;
    mapping(address => mapping(address => address)) public converters;
    mapping(address => mapping(address => bool)) public approvedStrategies;

    uint256 public split = 500;
    uint256 public constant max = 10000;

    /// @param _governance Can take any permissioned action within the Controller, with the exception of Vault helper functions
    /// @param _strategist Can configure new Vaults, choose strategies among those approved by governance, and call operations involving non-core tokens
    /// @param _keeper An extra address that can call earn() to deposit tokens from a Sett into the associated active Strategy. Designed for use by a trusted bot in leiu of having this function publically callable.
    /// @param _rewards The recipient of standard fees (such as performance and withdrawal fees) from Strategies
    function initialize(
        address _governance,
        address _strategist,
        address _keeper,
        address _rewards
    ) public initializer {
        governance = _governance;
        strategist = _strategist;
        keeper = _keeper;

        rewards = _rewards;
        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);
    }

    // ===== Modifiers =====

    /// @notice The Sett for a given token or any of the permissioned roles can call earn() to deposit accumulated deposit funds from the Sett to the active Strategy
    function _onlyApprovedForWant(address want) internal view {
        require(
            msg.sender == vaults[want] ||
                msg.sender == keeper ||
                msg.sender == strategist ||
                msg.sender == governance,
            ""!authorized""
        );
    }

    // ===== View Functions =====

    /// @notice Get the balance of the given tokens' current strategy of that token.
    function balanceOf(address _token) external view returns (uint256) {
        return IStrategy(strategies[_token]).balanceOf();
    }

    function getExpectedReturn(
        address _strategy,
        address _token,
        uint256 parts
    ) public view returns (uint256 expected) {
        uint256 _balance = IERC20Upgradeable(_token).balanceOf(_strategy);
        address _want = IStrategy(_strategy).want();
        (expected, ) = IOneSplitAudit(onesplit).getExpectedReturn(
            _token,
            _want,
            _balance,
            parts,
            0
        );
    }

    // ===== Permissioned Actions: Governance Only =====

    /// @notice Approve the given address as a Strategy for a want. The Strategist can freely switch between approved stratgies for a token.
    function approveStrategy(address _token, address _strategy) public {
        _onlyGovernance();
        approvedStrategies[_token][_strategy] = true;
    }

    /// @notice Revoke approval for the given address as a Strategy for a want.
    function revokeStrategy(address _token, address _strategy) public {
        _onlyGovernance();
        approvedStrategies[_token][_strategy] = false;
    }

    /// @notice Change the recipient of rewards for standard fees from Strategies
    function setRewards(address _rewards) public {
        _onlyGovernance();
        rewards = _rewards;
    }

    function setSplit(uint256 _split) public {
        _onlyGovernance();
        split = _split;
    }

    /// @notice Change the oneSplit contract, which is used in conversion of non-core strategy rewards
    function setOneSplit(address _onesplit) public {
        _onlyGovernance();
        onesplit = _onesplit;
    }

    // ===== Permissioned Actions: Governance or Strategist =====

    /// @notice Set the Vault (aka Sett) for a given want
    /// @notice The vault can only be set once
    function setVault(address _token, address _vault) public {
        _onlyGovernanceOrStrategist();

        require(vaults[_token] == address(0), ""vault"");
        vaults[_token] = _vault;
    }

    /// @notice Migrate assets from existing strategy to a new strategy.
    /// @notice The new strategy must have been previously approved by governance.
    /// @notice Strategist or governance can freely switch between approved strategies
    function setStrategy(address _token, address _strategy) public {
        _onlyGovernanceOrStrategist();

        require(approvedStrategies[_token][_strategy] == true, ""!approved"");

        address _current = strategies[_token];
        if (_current != address(0)) {
            IStrategy(_current).withdrawAll();
        }
        strategies[_token] = _strategy;
    }

    /// @notice Set the contract used to convert between two given assets
    function setConverter(
        address _input,
        address _output,
        address _converter
    ) public {
        _onlyGovernanceOrStrategist();
        converters[_input][_output] = _converter;
    }

    /// @notice Withdraw the entire balance of a token from that tokens' current strategy.
    /// @notice Does not trigger a withdrawal fee.
    /// @notice Entire balance will be sent to corresponding Sett.
    function withdrawAll(address _token) public {
        _onlyGovernanceOrStrategist();
        IStrategy(strategies[_token]).withdrawAll();
    }

    /// @dev Transfer an amount of the specified token from the controller to the sender.
    /// @dev Token balance are never meant to exist in the controller, this is purely a safeguard.
    function inCaseTokensGetStuck(address _token, uint256 _amount) public {
        _onlyGovernanceOrStrategist();
        IERC20Upgradeable(_token).safeTransfer(msg.sender, _amount);
    }

    /// @dev Transfer an amount of the specified token from the controller to the sender.
    /// @dev Token balance are never meant to exist in the controller, this is purely a safeguard.
    function inCaseStrategyTokenGetStuck(address _strategy, address _token)
        public
    {
        _onlyGovernanceOrStrategist();
        IStrategy(_strategy).withdrawOther(_token);
    }

    // ==== Permissioned Actions: Only Approved Actors =====

    /// @notice Deposit given token to strategy, converting it to the strategies' want first (if required).
    /// @dev Only the associated vault, or permissioned actors can call this function (keeper, strategist, governance)
    /// @param _token Token to deposit (will be converted to want by converter). If no converter is registered, the transaction will revert.
    /// @param _amount Amount of token to deposit
    function earn(address _token, uint256 _amount) public {
        address _strategy = strategies[_token];
        address _want = IStrategy(_strategy).want();

        _onlyApprovedForWant(_want);

        if (_want != _token) {
            address converter = converters[_token][_want];
            IERC20Upgradeable(_token).safeTransfer(converter, _amount);
            _amount = IConverter(converter).convert(_strategy);
            IERC20Upgradeable(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20Upgradeable(_token).safeTransfer(_strategy, _amount);
        }
        IStrategy(_strategy).deposit();
    }

    // ===== Permissioned Actions: Only Associated Vault =====

    /// @notice Wtihdraw a given token from it's corresponding strategy
    /// @notice Only the associated vault can call, in response to a user withdrawal request
    function withdraw(address _token, uint256 _amount) public {
        require(msg.sender == vaults[_token], ""!vault"");
        IStrategy(strategies[_token]).withdraw(_amount);
    }
}",1865
RealWorld_TA_31_AdminUpgradeabilityProxy_RealWorld_20240804015326.log,31,AdminUpgradeabilityProxy,226887,2261,229148,113.0,1.179655,"/**
 *Submitted for verification at Etherscan.io on 2020-10-09
 */

// SPDX-License-Identifier: MIT

pragma solidity ^0.6.2;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}

/**
 * @title Proxy
 * @dev Implements delegation of calls to other contracts, with proper
 * forwarding of return values and bubbling of failures.
 * It defines a fallback function that delegates all calls to the address
 * returned by the abstract _implementation() internal function.
 */
abstract contract Proxy {
    /**
     * @dev Fallback function.
     * Implemented entirely in `_fallback`.
     */
    fallback() external payable {
        _fallback();
    }

    /**
     * @dev Receive function.
     * Implemented entirely in `_fallback`.
     */
    receive() external payable {
        _fallback();
    }

    /**
     * @return The Address of the implementation.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates execution to an implementation contract.
     * This is a low level function that doesn't return to its internal call site.
     * It will return to the external caller whatever the implementation returns.
     * @param implementation Address to delegate.
     */
    function _delegate(address implementation) internal {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(
                gas(),
                implementation,
                0,
                calldatasize(),
                0,
                0
            )

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    /**
     * @dev Function that is run as the first thing in the fallback function.
     * Can be redefined in derived contracts to add functionality.
     * Redefinitions must call super._willFallback().
     */
    function _willFallback() internal virtual {}

    /**
     * @dev fallback implementation.
     * Extracted to enable manual triggering.
     */
    function _fallback() internal {
        _willFallback();
        _delegate(_implementation());
    }
}

/**
 * @title UpgradeabilityProxy
 * @dev This contract implements a proxy that allows to change the
 * implementation address to which it will delegate.
 * Such a change is called an implementation upgrade.
 */
contract UpgradeabilityProxy is Proxy {
    /**
     * @dev Contract constructor.
     * @param _logic Address of the initial implementation.
     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     */
    constructor(address _logic, bytes memory _data) public payable {
        assert(
            IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256(""eip1967.proxy.implementation"")) - 1)
        );
        _setImplementation(_logic);
        if (_data.length > 0) {
            (bool success, ) = _logic.delegatecall(_data);
            require(success);
        }
    }

    /**
     * @dev Emitted when the implementation is upgraded.
     * @param implementation Address of the new implementation.
     */
    event Upgraded(address indexed implementation);

    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of ""eip1967.proxy.implementation"" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    /**
     * @dev Returns the current implementation.
     * @return impl Address of the current implementation
     */
    function _implementation() internal view override returns (address impl) {
        bytes32 slot = IMPLEMENTATION_SLOT;
        assembly {
            impl := sload(slot)
        }
    }

    /**
     * @dev Upgrades the proxy to a new implementation.
     * @param newImplementation Address of the new implementation.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }

    /**
     * @dev Sets the implementation address of the proxy.
     * @param newImplementation Address of the new implementation.
     */
    function _setImplementation(address newImplementation) internal {
        require(
            Address.isContract(newImplementation),
            ""Cannot set a proxy implementation to a non-contract address""
        );

        bytes32 slot = IMPLEMENTATION_SLOT;

        assembly {
            sstore(slot, newImplementation)
        }
    }
}

/**
 * @title AdminUpgradeabilityProxy
 * @dev This contract combines an upgradeability proxy with an authorization
 * mechanism for administrative tasks.
 * All external functions in this contract must be guarded by the
 * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity
 * feature proposal that would enable this to be done automatically.
 */
contract AdminUpgradeabilityProxy is UpgradeabilityProxy {
    /**
     * Contract constructor.
     * @param _logic address of the initial implementation.
     * @param _admin Address of the proxy administrator.
     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     */
    constructor(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable UpgradeabilityProxy(_logic, _data) {
        assert(
            ADMIN_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.admin"")) - 1)
        );
        _setAdmin(_admin);
    }

    /**
     * @dev Emitted when the administration has been transferred.
     * @param previousAdmin Address of the previous admin.
     * @param newAdmin Address of the new admin.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of ""eip1967.proxy.admin"" subtracted by 1, and is
     * validated in the constructor.
     */

    bytes32 internal constant ADMIN_SLOT =
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Modifier to check whether the `msg.sender` is the admin.
     * If it is, it will run the function. Otherwise, it will delegate the call
     * to the implementation.
     */
    modifier ifAdmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @return The address of the proxy admin.
     */
    function admin() external ifAdmin returns (address) {
        return _admin();
    }

    /**
     * @return The address of the implementation.
     */
    function implementation() external ifAdmin returns (address) {
        return _implementation();
    }

    /**
     * @dev Changes the admin of the proxy.
     * Only the current admin can call this function.
     * @param newAdmin Address to transfer proxy administration to.
     */
    function changeAdmin(address newAdmin) external ifAdmin {
        require(
            newAdmin != address(0),
            ""Cannot change the admin of a proxy to the zero address""
        );
        emit AdminChanged(_admin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @dev Upgrade the backing implementation of the proxy.
     * Only the admin can call this function.
     * @param newImplementation Address of the new implementation.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    /**
     * @dev Upgrade the backing implementation of the proxy and call a function
     * on the new implementation.
     * This is useful to initialize the proxied contract.
     * @param newImplementation Address of the new implementation.
     * @param data Data to send as msg.data in the low level call.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     */
    function upgradeToAndCall(address newImplementation, bytes calldata data)
        external
        payable
        ifAdmin
    {
        _upgradeTo(newImplementation);
        (bool success, ) = newImplementation.delegatecall(data);
        require(success);
    }

    /**
     * @return adm The admin slot.
     */
    function _admin() internal view returns (address adm) {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Sets the address of the proxy admin.
     * @param newAdmin Address of the new proxy admin.
     */
    function _setAdmin(address newAdmin) internal {
        bytes32 slot = ADMIN_SLOT;

        assembly {
            sstore(slot, newAdmin)
        }
    }

    /**
     * @dev Only fall back when the sender is not the admin.
     */
    function _willFallback() internal virtual override {
        require(
            msg.sender != _admin(),
            ""Cannot call fallback function from the proxy admin""
        );
        super._willFallback();
    }
}",2476
RealWorld_TA_31_BadgerRegistry_RealWorld_20240804021108.log,31,BadgerRegistry,169074,5033,174107,129.0,0.94603,"// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.7.0;
pragma experimental ABIEncoderV2;

import ""deps/@openzeppelin/contracts/utils/EnumerableSet.sol"";

contract BadgerRegistry {
    using EnumerableSet for EnumerableSet.AddressSet;

    //@dev is the vault at the experimental, guarded or open stage? Only for Prod Vaults
    enum VaultStatus {experimental, guarded, open}

    struct VaultData {
        string version;
        VaultStatus status;
        address[] list;
    }

    //@dev Multisig. Vaults from here are considered Production ready
    address public governance;
    address public devGovernance; //@notice an address with some powers to make things easier in development

    //@dev Given an Author Address, and Token, Return the Vault
    mapping(address => mapping(string => EnumerableSet.AddressSet))
        private vaults;
    mapping(string => address) public addresses;

    //@dev Given Version and VaultStatus, returns the list of Vaults in production
    mapping(string => mapping(VaultStatus => EnumerableSet.AddressSet))
        private productionVaults;

    // Known constants you can use
    string[] public keys; //@notice, you don't have a guarantee of the key being there, it's just a utility
    string[] public versions; //@notice, you don't have a guarantee of the key being there, it's just a utility

    event NewVault(address author, string version, address vault);
    event RemoveVault(address author, string version, address vault);
    event PromoteVault(
        address author,
        string version,
        address vault,
        VaultStatus status
    );
    event DemoteVault(
        address author,
        string version,
        address vault,
        VaultStatus status
    );

    event Set(string key, address at);
    event AddKey(string key);
    event AddVersion(string version);

    function initialize(address newGovernance) public {
        require(governance == address(0));
        governance = newGovernance;
        devGovernance = address(0);

        versions.push(""v1""); //For v1
        versions.push(""v2""); //For v2
    }

    function setGovernance(address _newGov) public {
        require(msg.sender == governance, ""!gov"");
        governance = _newGov;
    }

    function setDev(address newDev) public {
        require(
            msg.sender == governance || msg.sender == devGovernance,
            ""!gov""
        );
        devGovernance = newDev;
    }

    //@dev Utility function to add Versions for Vaults,
    //@notice No guarantee that it will be properly used
    function addVersions(string memory version) public {
        require(msg.sender == governance, ""!gov"");
        versions.push(version);

        emit AddVersion(version);
    }

    //@dev Anyone can add a vault to here, it will be indexed by their address
    function add(string memory version, address vault) public {
        bool added = vaults[msg.sender][version].add(vault);
        if (added) {
            emit NewVault(msg.sender, version, vault);
        }
    }

    //@dev Remove the vault from your index
    function remove(string memory version, address vault) public {
        bool removed = vaults[msg.sender][version].remove(vault);
        if (removed) {
            emit RemoveVault(msg.sender, version, vault);
        }
    }

    //@dev Promote a vault to Production
    //@dev Promote just means indexed by the Governance Address
    function promote(
        string memory version,
        address vault,
        VaultStatus status
    ) public {
        require(
            msg.sender == governance || msg.sender == devGovernance,
            ""!gov""
        );

        VaultStatus actualStatus = status;
        if (msg.sender == devGovernance) {
            actualStatus = VaultStatus.experimental;
        }

        bool added = productionVaults[version][actualStatus].add(vault);

        // If added remove from old and emit event
        if (added) {
            // also remove from old prod
            if (uint256(actualStatus) == 2) {
                // Remove from prev2
                productionVaults[version][VaultStatus(0)].remove(vault);
                productionVaults[version][VaultStatus(1)].remove(vault);
            }
            if (uint256(actualStatus) == 1) {
                // Remove from prev1
                productionVaults[version][VaultStatus(0)].remove(vault);
            }

            emit PromoteVault(msg.sender, version, vault, actualStatus);
        }
    }

    function demote(
        string memory version,
        address vault,
        VaultStatus status
    ) public {
        require(
            msg.sender == governance || msg.sender == devGovernance,
            ""!gov""
        );

        VaultStatus actualStatus = status;
        if (msg.sender == devGovernance) {
            actualStatus = VaultStatus.experimental;
        }

        bool removed = productionVaults[version][actualStatus].remove(vault);

        if (removed) {
            emit DemoteVault(msg.sender, version, vault, status);
        }
    }

    /** KEY Management */

    //@dev Set the value of a key to a specific address
    //@notice e.g. controller = 0x123123
    function set(string memory key, address at) public {
        require(msg.sender == governance, ""!gov"");
        _addKey(key);
        addresses[key] = at;
        emit Set(key, at);
    }

    //@dev Retrieve the value of a key
    function get(string memory key) public view returns (address) {
        return addresses[key];
    }

    //@dev Add a key to the list of keys
    //@notice This is used to make it easier to discover keys,
    //@notice however you have no guarantee that all keys will be in the list
    function _addKey(string memory key) internal {
        //If we find the key, skip
        bool found = false;
        for (uint256 x = 0; x < keys.length; x++) {
            // Compare strings via their hash because solidity
            if (keccak256(bytes(key)) == keccak256(bytes(keys[x]))) {
                found = true;
            }
        }

        if (found) {
            return;
        }

        // Else let's add it and emit the event
        keys.push(key);

        emit AddKey(key);
    }

    //@dev Retrieve a list of all Vault Addresses from the given author
    function getVaults(string memory version, address author)
        public
        view
        returns (address[] memory)
    {
        uint256 length = vaults[author][version].length();

        address[] memory list = new address[](length);
        for (uint256 i = 0; i < length; i++) {
            list[i] = vaults[author][version].at(i);
        }
        return list;
    }

    //@dev Retrieve a list of all Vaults that are in production, based on Version and Status
    function getFilteredProductionVaults(
        string memory version,
        VaultStatus status
    ) public view returns (address[] memory) {
        uint256 length = productionVaults[version][status].length();

        address[] memory list = new address[](length);
        for (uint256 i = 0; i < length; i++) {
            list[i] = productionVaults[version][status].at(i);
        }
        return list;
    }

    function getProductionVaults() public view returns (VaultData[] memory) {
        uint256 versionsCount = versions.length;

        VaultData[] memory data = new VaultData[](versionsCount * 3);

        for (uint256 x = 0; x < versionsCount; x++) {
            for (uint256 y = 0; y < 3; y++) {
                uint256 length =
                    productionVaults[versions[x]][VaultStatus(y)].length();
                address[] memory list = new address[](length);
                for (uint256 z = 0; z < length; z++) {
                    list[z] = productionVaults[versions[x]][VaultStatus(y)].at(
                        z
                    );
                }
                data[x * (versionsCount - 1) + y * 2] = VaultData({
                    version: versions[x],
                    status: VaultStatus(y),
                    list: list
                });
            }
        }

        return data;
    }
}",1771
RealWorld_TA_31_AdminUpgradeabilityProxy_RealWorld_20240804041831.log,31,AdminUpgradeabilityProxy,42042,1955,43997,86.0,0.24931,"pragma solidity ^0.5.0;

import ""./BaseAdminUpgradeabilityProxy.sol"";

/**
 * @title AdminUpgradeabilityProxy
 * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for
 * initializing the implementation, admin, and init data.
 */
contract AdminUpgradeabilityProxy is
    BaseAdminUpgradeabilityProxy,
    UpgradeabilityProxy
{
    /**
     * Contract constructor.
     * @param _logic address of the initial implementation.
     * @param _admin Address of the proxy administrator.
     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
     * It should include the signature and the parameters of the function to be called, as described in
     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
     */
    constructor(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable UpgradeabilityProxy(_logic, _data) {
        assert(
            ADMIN_SLOT == bytes32(uint256(keccak256(""eip1967.proxy.admin"")) - 1)
        );
        _setAdmin(_admin);
    }
}",276
RealWorld_TA_31_EnumerableMap_RealWorld_20240804033916.log,31,EnumerableMap,193731,1319,195050,89.0,0.995035,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Library for managing an enumerable variant of Solidity's
 * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]
 * type.
 *
 * Maps have the following properties:
 *
 * - Entries are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Entries are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableMap for EnumerableMap.UintToAddressMap;
 *
 *     // Declare a set state variable
 *     EnumerableMap.UintToAddressMap private myMap;
 * }
 * ```
 *
 * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are
 * supported.
 */
library EnumerableMap {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Map type with
    // bytes32 keys and values.
    // The Map implementation uses private functions, and user-facing
    // implementations (such as Uint256ToAddressMap) are just wrappers around
    // the underlying Map.
    // This means that we can only create new EnumerableMaps for types that fit
    // in bytes32.

    struct MapEntry {
        bytes32 _key;
        bytes32 _value;
    }

    struct Map {
        // Storage of map keys and values
        MapEntry[] _entries;
        // Position of the entry defined by a key in the `entries` array, plus 1
        // because index 0 means a key is not in the map.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function _set(
        Map storage map,
        bytes32 key,
        bytes32 value
    ) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex == 0) {
            // Equivalent to !contains(map, key)
            map._entries.push(MapEntry({_key: key, _value: value}));
            // The entry is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            map._indexes[key] = map._entries.length;
            return true;
        } else {
            map._entries[keyIndex - 1]._value = value;
            return false;
        }
    }

    /**
     * @dev Removes a key-value pair from a map. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function _remove(Map storage map, bytes32 key) private returns (bool) {
        // We read and store the key's index to prevent multiple reads from the same storage slot
        uint256 keyIndex = map._indexes[key];

        if (keyIndex != 0) {
            // Equivalent to contains(map, key)
            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one
            // in the array, and then remove the last entry (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = keyIndex - 1;
            uint256 lastIndex = map._entries.length - 1;

            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs
            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

            MapEntry storage lastEntry = map._entries[lastIndex];

            // Move the last entry to the index where the entry to delete is
            map._entries[toDeleteIndex] = lastEntry;
            // Update the index for the moved entry
            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based

            // Delete the slot where the moved entry was stored
            map._entries.pop();

            // Delete the index for the deleted slot
            delete map._indexes[key];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function _contains(Map storage map, bytes32 key)
        private
        view
        returns (bool)
    {
        return map._indexes[key] != 0;
    }

    /**
     * @dev Returns the number of key-value pairs in the map. O(1).
     */
    function _length(Map storage map) private view returns (uint256) {
        return map._entries.length;
    }

    /**
     * @dev Returns the key-value pair stored at position `index` in the map. O(1).
     *
     * Note that there are no guarantees on the ordering of entries inside the
     * array, and it may change when more entries are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Map storage map, uint256 index)
        private
        view
        returns (bytes32, bytes32)
    {
        require(
            map._entries.length > index,
            ""EnumerableMap: index out of bounds""
        );

        MapEntry storage entry = map._entries[index];
        return (entry._key, entry._value);
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function _get(Map storage map, bytes32 key) private view returns (bytes32) {
        return _get(map, key, ""EnumerableMap: nonexistent key"");
    }

    /**
     * @dev Same as {_get}, with a custom error message when `key` is not in the map.
     */
    function _get(
        Map storage map,
        bytes32 key,
        string memory errorMessage
    ) private view returns (bytes32) {
        uint256 keyIndex = map._indexes[key];
        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)
        return map._entries[keyIndex - 1]._value; // All indexes are 1-based
    }

    // UintToAddressMap

    struct UintToAddressMap {
        Map _inner;
    }

    /**
     * @dev Adds a key-value pair to a map, or updates the value for an existing
     * key. O(1).
     *
     * Returns true if the key was added to the map, that is if it was not
     * already present.
     */
    function set(
        UintToAddressMap storage map,
        uint256 key,
        address value
    ) internal returns (bool) {
        return _set(map._inner, bytes32(key), bytes32(uint256(value)));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the key was removed from the map, that is if it was present.
     */
    function remove(UintToAddressMap storage map, uint256 key)
        internal
        returns (bool)
    {
        return _remove(map._inner, bytes32(key));
    }

    /**
     * @dev Returns true if the key is in the map. O(1).
     */
    function contains(UintToAddressMap storage map, uint256 key)
        internal
        view
        returns (bool)
    {
        return _contains(map._inner, bytes32(key));
    }

    /**
     * @dev Returns the number of elements in the map. O(1).
     */
    function length(UintToAddressMap storage map)
        internal
        view
        returns (uint256)
    {
        return _length(map._inner);
    }

    /**
     * @dev Returns the element stored at position `index` in the set. O(1).
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintToAddressMap storage map, uint256 index)
        internal
        view
        returns (uint256, address)
    {
        (bytes32 key, bytes32 value) = _at(map._inner, index);
        return (uint256(key), address(uint256(value)));
    }

    /**
     * @dev Returns the value associated with `key`.  O(1).
     *
     * Requirements:
     *
     * - `key` must be in the map.
     */
    function get(UintToAddressMap storage map, uint256 key)
        internal
        view
        returns (address)
    {
        return address(uint256(_get(map._inner, bytes32(key))));
    }

    /**
     * @dev Same as {get}, with a custom error message when `key` is not in the map.
     */
    function get(
        UintToAddressMap storage map,
        uint256 key,
        string memory errorMessage
    ) internal view returns (address) {
        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));
    }
}",2081
RealWorld_TA_31_ECDSAUpgradeable_RealWorld_20240804053238.log,31,ECDSAUpgradeable,97850,1571,99421,83.0,0.52067,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSAUpgradeable {
    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature)
        internal
        pure
        returns (address)
    {
        // Check the signature length
        if (signature.length != 65) {
            revert(""ECDSA: invalid signature length"");
        }

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (
            uint256(s) >
            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
        ) {
            revert(""ECDSA: invalid signature 's' value"");
        }

        if (v != 27 && v != 28) {
            revert(""ECDSA: invalid signature 'v' value"");
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        require(signer != address(0), ""ECDSA: invalid signature"");

        return signer;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * replicates the behavior of the
     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
     * JSON-RPC method.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash)
        internal
        pure
        returns (bytes32)
    {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return
            keccak256(
                abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash)
            );
    }
}",943
RealWorld_TA_31_ArraysUpgradeable_RealWorld_20240804055120.log,31,ArraysUpgradeable,48255,1398,49653,79.0,0.269235,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import ""../math/MathUpgradeable.sol"";

/**
 * @dev Collection of functions related to array types.
 */
library ArraysUpgradeable {
    /**
     * @dev Searches a sorted `array` and returns the first index that contains
     * a value greater or equal to `element`. If no such index exists (i.e. all
     * values in the array are strictly less than `element`), the array length is
     * returned. Time complexity O(log n).
     *
     * `array` is expected to be sorted in ascending order, and to contain no
     * repeated elements.
     */
    function findUpperBound(uint256[] storage array, uint256 element)
        internal
        view
        returns (uint256)
    {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = MathUpgradeable.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid] > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1] == element) {
            return low - 1;
        } else {
            return low;
        }
    }
}",356
RealWorld_TA_31_CvxStakingProxy_RealWorld_20240804015521.log,31,CvxStakingProxy,135498,5913,141411,144.0,0.79575,"// SPDX-License-Identifier: MIT
pragma solidity 0.6 .12;

import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';


interface ICrvDepositor {
    function deposit(uint256, bool) external;
}

interface IConvexRewards {
    function withdraw(uint256 _amount, bool _claim) external;

    function balanceOf(address _account) external view returns(uint256);

    function getReward(bool _stake) external;

    function stakeAll() external;
}

interface ICvxLocker {
    function notifyRewardAmount(address _rewardsToken, uint256 reward) external;
}


// receive tokens to stake
// get current staked balance
// withdraw staked tokens
// send rewards back to owner(cvx locker)
// register token types that can be distributed

contract CvxStakingProxy {
    using SafeERC20
    for IERC20;
    using Address
    for address;
    using SafeMath
    for uint256;

    //tokens
    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public constant cvxCrv = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);

    //convex addresses
    address public constant cvxStaking = address(0xCF50b810E57Ac33B91dCF525C6ddd9881B139332);
    address public constant crvDeposit = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae);
    uint256 public constant denominator = 10000;

    address public immutable rewards;

    address public owner;
    address public pendingOwner;
    uint256 public callIncentive = 25;

    event RewardsDistributed(address indexed token, uint256 amount);

    constructor(address _rewards) public {
        rewards = _rewards;
        owner = msg.sender;
    }

    function setPendingOwner(address _po) external {
        require(msg.sender == owner, ""!auth"");
        pendingOwner = _po;
    }

    function applyPendingOwner() external {
        require(msg.sender == owner, ""!auth"");
        require(pendingOwner != address(0), ""invalid owner"");

        owner = pendingOwner;
        pendingOwner = address(0);
    }

    function setCallIncentive(uint256 _incentive) external {
        require(msg.sender == owner, ""!auth"");
        require(_incentive <= 100, ""too high"");
        callIncentive = _incentive;
    }

    function setApprovals() external {
        IERC20(cvx).safeApprove(cvxStaking, 0);
        IERC20(cvx).safeApprove(cvxStaking, uint256(-1));

        IERC20(crv).safeApprove(crvDeposit, 0);
        IERC20(crv).safeApprove(crvDeposit, uint256(-1));

        IERC20(cvxCrv).safeApprove(rewards, 0);
        IERC20(cvxCrv).safeApprove(rewards, uint256(-1));
    }

    function rescueToken(address _token, address _to) external {
        require(msg.sender == owner, ""!auth"");
        require(_token != crv && _token != cvx && _token != cvxCrv, ""not allowed"");

        uint256 bal = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransfer(_to, bal);
    }

    function getBalance() external view returns(uint256) {
        return IConvexRewards(cvxStaking).balanceOf(address(this));
    }

    function withdraw(uint256 _amount) external {
        require(msg.sender == rewards, ""!auth"");

        //unstake
        IConvexRewards(cvxStaking).withdraw(_amount, false);

        //withdraw cvx
        IERC20(cvx).safeTransfer(msg.sender, _amount);
    }


    function stake() external {
        require(msg.sender == rewards, ""!auth"");

        IConvexRewards(cvxStaking).stakeAll();
    }

    function distribute() external {
        //claim rewards
        IConvexRewards(cvxStaking).getReward(false);

        //convert any crv that was directly added
        uint256 crvBal = IERC20(crv).balanceOf(address(this));
        if (crvBal > 0) {
            ICrvDepositor(crvDeposit).deposit(crvBal, true);
        }

        //distribute cvxcrv
        uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));

        if (cvxCrvBal > 0) {
            uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);
            cvxCrvBal = cvxCrvBal.sub(incentiveAmount);
            
            //send incentives
            IERC20(cvxCrv).safeTransfer(msg.sender,incentiveAmount);

            //update rewards
            ICvxLocker(rewards).notifyRewardAmount(cvxCrv, cvxCrvBal);

            emit RewardsDistributed(cvxCrv, cvxCrvBal);
        }
    }

    //in case a new reward is ever added, allow generic distribution
    function distributeOther(IERC20 _token) external {
        require( address(_token) != crv && address(_token) != cvxCrv, ""not allowed"");

        uint256 bal = _token.balanceOf(address(this));

        if (bal > 0) {
            uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);
            bal = bal.sub(incentiveAmount);
            
            //send incentives
            _token.safeTransfer(msg.sender,incentiveAmount);

            //approve
            _token.safeApprove(rewards, 0);
            _token.safeApprove(rewards, uint256(-1));

            //update rewards
            ICvxLocker(rewards).notifyRewardAmount(address(_token), bal);

            emit RewardsDistributed(address(_token), bal);
        }
    }
}",1390
