filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_TA_58_UniV3Trader_RealWorld_20240807214600.log,58,UniV3Trader,140932,4427,145359,202.0,0.7932,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/external/univ3/ISwapRouter.sol"";
import ""./libraries/TraderExceptionsLibrary.sol"";
import ""./Trader.sol"";

/// @notice Contract that can execute ERC20 swaps on Uniswap V3
contract UniV3Trader is Trader, ITrader {
    using SafeERC20 for IERC20;

    struct Options {
        uint24 fee;
        uint160 sqrtPriceLimitX96;
        uint256 deadline;
        uint256 limitAmount;
    }

    struct PathItemOptions {
        uint24 fee;
    }

    ISwapRouter public swapRouter;

    constructor(address _swapRouter) {
        swapRouter = ISwapRouter(_swapRouter);
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 1) {
            return _swapExactInputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactInputMultihop(amount, recipient, path, options_);
        }
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 0) {
            return _swapExactOutputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactOutputMultihop(amount, recipient, path, options_);
        }
    }

    function _validatePathLinked(PathItem[] memory path) internal pure returns (bool result) {
        if (path.length == 0) return false;
        for (uint256 i = 0; i < path.length - 1; ++i) if (path[0].token1 != path[i + 1].token0) return false;
        return true;
    }

    function _swapExactInputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountOut) {
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInputSingle(params);
    }

    function _swapExactOutputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountIn) {
        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutputSingle(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _swapExactInputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountOut) {
        address input = path[0].token0;
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: _makeMultihopPath(path),
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInput(params);
    }

    function _swapExactOutputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountIn) {
        address input = path[0].token0;
        ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams({
            path: _reverseBytes(_makeMultihopPath(path)),
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutput(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {
        for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];
    }

    function _makeMultihopPath(PathItem[] memory path) internal pure returns (bytes memory) {
        bytes memory result;
        for (uint256 i = 0; i < path.length; ++i) {
            PathItemOptions memory pathItemOptions = abi.decode(path[i].options, (PathItemOptions));
            result = bytes.concat(result, abi.encodePacked(path[i].token0, abi.encodePacked(pathItemOptions.fee)));
        }
        result = bytes.concat(result, abi.encodePacked(path[path.length - 1].token1));
        return result;
    }
}",1457
RealWorld_TA_58_WERC20Test_RealWorld_20240807173109.log,58,WERC20Test,29277,3084,32361,125.0,0.208065,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

interface IWrapped {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract WERC20Test is IWrapped, ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, (10**18) * (10**18));
    }

    function deposit() external payable {}

    function withdraw(uint256 wad) external {}
}",125
RealWorld_TA_58_UniV3VaultTest_RealWorld_20240807213730.log,58,UniV3VaultTest,30694,3083,33777,138.0,0.21513,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../UniV3Vault.sol"";

contract UniV3VaultTest is UniV3Vault {
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) UniV3Vault(vaultGovernance_, vaultTokens_, fee) {}

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }
}",133
RealWorld_TA_58_GatewayVaultGovernance_RealWorld_20240807204332.log,58,GatewayVaultGovernance,124387,4292,128679,173.0,0.707775,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IGatewayVaultGovernance.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Gateway Vaults params and can deploy a new Gateway Vault.
contract GatewayVaultGovernance is VaultGovernance, IGatewayVaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    /// @inheritdoc IGatewayVaultGovernance
    function delayedStrategyParams(uint256 nft) public view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({limits: new uint256[](0)});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        IGatewayVault vault = IGatewayVault(_internalParams.registry.vaultForNft(nft));
        require(
            (params.redirects.length == 0) || (params.redirects.length == vault.subvaultNfts().length),
            ExceptionsLibrary.REDIRECTS_AND_VAULT_TOKENS_LENGTH
        );
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @notice Deploy a new vault
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256[] - an array of Nfts of subvaults. It is required that each nft subvault is approved by the caller to this address.
    /// @param strategy Strategy that will be approved to manage subvaults
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address strategy
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        for (uint256 i = 0; i < vaultTokens.length; ++i) {
            require(_internalParams.protocolGovernance.isAllowedToken(vaultTokens[i]), ""TNA"");
        }
        (vault, nft) = super.deployVault(vaultTokens, """", msg.sender);
        uint256[] memory subvaultNfts = abi.decode(options, (uint256[]));
        IVaultRegistry registry = _internalParams.registry;
        IGatewayVault(address(vault)).addSubvaults(subvaultNfts);
        for (uint256 i = 0; i < subvaultNfts.length; i++) {
            registry.safeTransferFrom(msg.sender, address(vault), subvaultNfts[i]);
        }
        IGatewayVault gw = IGatewayVault(address(vault));
        gw.setApprovalsForStrategy(strategy, subvaultNfts);
    }

    /// @inheritdoc IGatewayVaultGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc IGatewayVaultGovernance
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);
}",1262
RealWorld_TA_58_TraderExceptionsLibrary_RealWorld_20240807214925.log,58,TraderExceptionsLibrary,31094,1492,32586,98.0,0.18531,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

library TraderExceptionsLibrary {
    string constant PROTOCOL_ADMIN_REQUIRED_EXCEPTION = ""PA"";
    string constant TRADER_ALREADY_REGISTERED_EXCEPTION = ""TE"";
    string constant TRADER_NOT_FOUND_EXCEPTION = ""UT"";
    string constant TRADE_FAILED_EXCEPTION = ""TF"";
    string constant VAULT_NOT_FOUND_EXCEPTION = ""VF"";
    string constant VAULT_TOKEN_REQUIRED_EXCEPTION = ""VT"";
    string constant AT_LEAST_STRATEGY_REQUIRED_EXCEPTION = ""SR"";
    string constant INVALID_TRADE_PATH_EXCEPTION = ""TP"";
    string constant RECURRENCE_EXCEPTION = ""RE"";
    string constant TOKEN_NOT_ALLOWED_EXCEPTION = ""TA"";
}",147
RealWorld_TA_58_UniV3VaultGovernanceTest_RealWorld_20240807212641.log,58,UniV3VaultGovernanceTest,28876,3185,32061,120.0,0.20808,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IUniV3VaultGovernance.sol"";
import ""../UniV3VaultGovernance.sol"";
import ""../VaultGovernance.sol"";

contract UniV3VaultGovernanceTest is UniV3VaultGovernance {
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        UniV3VaultGovernance(internalParams_, delayedProtocolParams_)
    {
        delete _delayedProtocolParams;
    }
}",111
RealWorld_TA_58_GatewayVaultGovernance_RealWorld_20240807171259.log,58,GatewayVaultGovernance,124053,3812,127865,133.0,0.696505,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IGatewayVaultGovernance.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Gateway Vaults params and can deploy a new Gateway Vault.
contract GatewayVaultGovernance is VaultGovernance, IGatewayVaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    /// @inheritdoc IGatewayVaultGovernance
    function delayedStrategyParams(uint256 nft) public view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return DelayedStrategyParams({redirects: new uint256[](0)});
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({limits: new uint256[](0)});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc IGatewayVaultGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        IGatewayVault vault = IGatewayVault(_internalParams.registry.vaultForNft(nft));
        require(
            (params.redirects.length == 0) || (params.redirects.length == vault.subvaultNfts().length),
            ExceptionsLibrary.REDIRECTS_AND_VAULT_TOKENS_LENGTH
        );
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @notice Deploy a new vault
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256[] - an array of Nfts of subvaults. It is required that each nft subvault is approved by the caller to this address.
    /// @param strategy Strategy that will be approved to manage subvaults
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address strategy
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        for (uint256 i = 0; i < vaultTokens.length; ++i) {
            require(_internalParams.protocolGovernance.isAllowedToken(vaultTokens[i]), ""TNA"");
        }
        (vault, nft) = super.deployVault(vaultTokens, """", msg.sender);
        uint256[] memory subvaultNfts = abi.decode(options, (uint256[]));
        IVaultRegistry registry = _internalParams.registry;
        IGatewayVault(address(vault)).addSubvaults(subvaultNfts);
        for (uint256 i = 0; i < subvaultNfts.length; i++) {
            registry.safeTransferFrom(msg.sender, address(vault), subvaultNfts[i]);
        }
        IGatewayVault gw = IGatewayVault(address(vault));
        gw.setApprovalsForStrategy(strategy, subvaultNfts);
    }

    /// @inheritdoc IGatewayVaultGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc IGatewayVaultGovernance
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);
}",1262
RealWorld_TA_58_IUniswapV3PoolState_RealWorld_20240807190844.log,58,IUniswapV3PoolState,138017,1413,139430,102.0,0.718345,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolPerformanceFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1445
RealWorld_TA_58_IVaultFactory_RealWorld_20240807221924.log,58,IVaultFactory,26622,1752,28374,108.0,0.16815,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";
import ""./IVault.sol"";

interface IVaultFactory {
    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault vault);
}",96
RealWorld_TA_58_TraderExceptionsLibrary_RealWorld_20240807180938.log,58,TraderExceptionsLibrary,30895,1274,32169,94.0,0.179955,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

library TraderExceptionsLibrary {
    string constant PROTOCOL_ADMIN_REQUIRED_EXCEPTION = ""PA"";
    string constant TRADER_ALREADY_REGISTERED_EXCEPTION = ""TE"";
    string constant TRADER_NOT_FOUND_EXCEPTION = ""UT"";
    string constant TRADE_FAILED_EXCEPTION = ""TF"";
    string constant VAULT_NOT_FOUND_EXCEPTION = ""VF"";
    string constant VAULT_TOKEN_REQUIRED_EXCEPTION = ""VT"";
    string constant AT_LEAST_STRATEGY_REQUIRED_EXCEPTION = ""SR"";
    string constant INVALID_TRADE_PATH_EXCEPTION = ""TP"";
    string constant RECURRENCE_EXCEPTION = ""RE"";
    string constant TOKEN_NOT_ALLOWED_EXCEPTION = ""TA"";
}",147
RealWorld_TA_58_YearnVaultFactory_RealWorld_20240807203456.log,58,YearnVaultFactory,37140,1888,39028,143.0,0.22346,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./YearnVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for YearnVaultGovernance that can create new Yearn Vaults.
contract YearnVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        YearnVault vault = new YearnVault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_TA_58_IAaveVaultGovernance_RealWorld_20240807193146.log,58,IAaveVaultGovernance,40863,1321,42184,108.0,0.230735,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./external/aave/ILendingPool.sol"";
import ""./IVaultGovernance.sol"";

interface IAaveVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param lendingPool Reference to Aave LendingPool
    struct DelayedProtocolParams {
        ILendingPool lendingPool;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",270
RealWorld_TA_58_TestFunctionEncoding_RealWorld_20240807173744.log,58,TestFunctionEncoding,27615,2336,29951,113.0,0.184795,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract TestFunctionEncoding {
    Vault public vault;

    constructor(Vault _vault) {
        vault = _vault;
    }

    function encodeWithSignatureTest(address from) external {
        bytes memory data = abi.encodeWithSignature(""tvl()"");
        vault.claimRewards(from, data);
    }
}",107
RealWorld_TA_58_VaultGovernance_RealWorld_20240807204627.log,58,VaultGovernance,204917,4353,209270,195.0,1.111645,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Internal contract for managing different params.
/// @dev The contract should be overriden by the concrete VaultGovernance,
/// define different params structs and use abi.decode / abi.encode to serialize
/// to bytes in this contract. It also should emit events on params change.
abstract contract VaultGovernance is IVaultGovernance {
    InternalParams internal _internalParams;
    InternalParams private _stagedInternalParams;
    uint256 internal _internalParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedStrategyParams;
    mapping(uint256 => bytes) internal _stagedDelayedStrategyParams;
    mapping(uint256 => uint256) internal _delayedStrategyParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedProtocolPerVaultParams;
    mapping(uint256 => bytes) internal _stagedDelayedProtocolPerVaultParams;
    mapping(uint256 => uint256) internal _delayedProtocolPerVaultParamsTimestamp;

    bytes internal _delayedProtocolParams;
    bytes internal _stagedDelayedProtocolParams;
    uint256 internal _delayedProtocolParamsTimestamp;

    mapping(uint256 => bytes) internal _strategyParams;
    bytes internal _protocolParams;

    IVaultFactory public factory;
    bool public initialized;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) {
        _internalParams = internalParams_;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVaultGovernance
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolParamsTimestamp() external view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParamsTimestamp() external view returns (uint256) {
        return _internalParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParams() external view returns (InternalParams memory) {
        return _internalParams;
    }

    /// @inheritdoc IVaultGovernance
    function stagedInternalParams() external view returns (InternalParams memory) {
        return _stagedInternalParams;
    }

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @inheritdoc IVaultGovernance
    function initialize(IVaultFactory factory_) external {
        require(!initialized, ExceptionsLibrary.INITIALIZATION);
        factory = factory_;
        initialized = true;
    }

    /// @inheritdoc IVaultGovernance
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) public virtual returns (IVault vault, uint256 nft) {
        require(initialized, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance protocolGovernance = IProtocolGovernance(_internalParams.protocolGovernance);
        require(protocolGovernance.permissionless() || protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.PERMISSIONLESS_OR_ADMIN);
        vault = factory.deployVault(vaultTokens, options);
        address nftOwner = owner;
        nft = _internalParams.registry.registerVault(address(vault), nftOwner);
        vault.initialize(nft);
        emit DeployedVault(tx.origin, msg.sender, vaultTokens, options, nftOwner, address(vault), nft);
    }

    /// @inheritdoc IVaultGovernance
    function stageInternalParams(InternalParams memory newParams) external {
        _requireProtocolAdmin();
        _stagedInternalParams = newParams;
        _internalParamsTimestamp = block.timestamp + _internalParams.protocolGovernance.governanceDelay();
        emit StagedInternalParams(tx.origin, msg.sender, newParams, _internalParamsTimestamp);
    }

    /// @inheritdoc IVaultGovernance
    function commitInternalParams() external {
        _requireProtocolAdmin();
        require(_internalParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _internalParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _internalParams = _stagedInternalParams;
        delete _internalParamsTimestamp;
        emit CommitedInternalParams(tx.origin, msg.sender, _internalParams);
    }

    // -------------------  INTERNAL  -------------------

    /// @notice Set Delayed Strategy Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _stagedDelayedStrategyParams[nft] = params;
        uint256 delayFactor = _delayedStrategyParams[nft].length == 0 ? 0 : 1;
        _delayedStrategyParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Strategy Params
    function _commitDelayedStrategyParams(uint256 nft) internal {
        _requireAtLeastStrategy(nft);
        require(_delayedStrategyParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedStrategyParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedStrategyParams[nft] = _stagedDelayedStrategyParams[nft];
        delete _stagedDelayedStrategyParams[nft];
        delete _delayedStrategyParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Per Vault Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedProtocolPerVaultParams(uint256 nft, bytes memory params) internal {
        _requireProtocolAdmin();
        _stagedDelayedProtocolPerVaultParams[nft] = params;
        uint256 delayFactor = _delayedProtocolPerVaultParams[nft].length == 0 ? 0 : 1;
        _delayedProtocolPerVaultParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Per Vault Params
    function _commitDelayedProtocolPerVaultParams(uint256 nft) internal {
        _requireProtocolAdmin();
        require(_delayedProtocolPerVaultParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolPerVaultParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolPerVaultParams[nft] = _stagedDelayedProtocolPerVaultParams[nft];
        delete _stagedDelayedProtocolPerVaultParams[nft];
        delete _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Params
    /// @param params New params
    function _stageDelayedProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        uint256 delayFactor = _delayedProtocolParams.length == 0 ? 0 : 1;
        _stagedDelayedProtocolParams = params;
        _delayedProtocolParamsTimestamp =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Params
    function _commitDelayedProtocolParams() internal {
        _requireProtocolAdmin();
        require(_delayedProtocolParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolParams = _stagedDelayedProtocolParams;
        delete _stagedDelayedProtocolParams;
        delete _delayedProtocolParamsTimestamp;
    }

    /// @notice Set immediate strategy params
    /// @dev Should require nft > 0
    /// @param nft Nft of the vault
    /// @param params New params
    function _setStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _strategyParams[nft] = params;
    }

    /// @notice Set immediate protocol params
    /// @param params New params
    function _setProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        _protocolParams = params;
    }

    function _requireAtLeastStrategy(uint256 nft) internal view {
        require(
            (_internalParams.protocolGovernance.isAdmin(msg.sender) ||
                _internalParams.registry.getApproved(nft) == msg.sender ||
                (_internalParams.registry.ownerOf(nft) == msg.sender)),
            ExceptionsLibrary.REQUIRE_AT_LEAST_ADMIN
        );
    }

    function _requireProtocolAdmin() internal view {
        require(_internalParams.protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
    }

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StagedInternalParams(address indexed origin, address indexed sender, InternalParams params, uint256 when);

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    event CommitedInternalParams(address indexed origin, address indexed sender, InternalParams params);

    /// @notice Emitted when New Vault is deployed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param vaultTokens Vault tokens for this vault
    /// @param options Options for deploy. The details of the options structure are specified in subcontracts
    /// @param owner Owner of the VaultRegistry NFT for this vault
    /// @param vaultAddress Address of the new Vault
    /// @param vaultNft VaultRegistry NFT for the new Vault
    event DeployedVault(
        address indexed origin,
        address indexed sender,
        address[] vaultTokens,
        bytes options,
        address owner,
        address vaultAddress,
        uint256 vaultNft
    );
}",2217
RealWorld_TA_58_IVault_RealWorld_20240807192114.log,58,IVault,121454,3110,124564,128.0,0.66947,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IVault {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Address of the Vault Governance for this contract.
    function vaultGovernance() external view returns (IVaultGovernance);

    /// @notice ERC20 tokens under Vault management.
    function vaultTokens() external view returns (address[] memory);

    /// @notice Total value locked for this contract.
    /// @dev Generally it is the underlying token value of this contract in some
    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.
    /// @return tokenAmounts Total available balances for multiple tokens (nth tokenAmount corresponds to nth token in vaultTokens)
    function tvl() external view returns (uint256[] memory tokenAmounts);

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Pushes tokens on the vault balance to the underlying protocol. For example, for Yearn this operation will take USDC from
    /// the contract balance and convert it to yUSDC.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice The same as `push` method above but transfers tokens to vault balance prior to calling push.
    /// After the `push` it returns all the leftover tokens back (`push` method doesn't guarantee that tokenAmounts will be invested in full).
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice Pulls tokens from the underlying protocol to the `to` address.
    /// For example, for Yearn this operation will take yUSDC from
    /// the Yearn protocol, convert it to USDC and send to `to` address.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT. There's a subtle difference however - while vault owner
    /// can pull the tokens to any address, Strategy can only pull to other vault in the Vault System (a set of vaults united by the Gateway Vault)
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param to Address to receive the tokens
    /// @param tokens Tokens to pull
    /// @param tokenAmounts Amounts of tokens to pull
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually withdrawn. It could be less than tokenAmounts (but not higher)
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice This method is for claiming accidentally accumulated tokens on the contact's balance.
    /// @dev Can only be called by Protocol Governance.
    /// @param to Address that will receive the tokens
    /// @param tokens Tokens to claim. Each token must be other than those in vaultTokens
    function reclaimTokens(address to, address[] memory tokens) external;

    /// @notice Claim liquidity mining rewards.
    /// @dev Can only be called by Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Since this method allows sending arbitrary transactions, the destinations of the calls
    /// are whitelisted by Protocol Governance.
    /// @param from Address of the reward pool
    /// @param data Abi encoded call to the `from` address
    function claimRewards(address from, bytes memory data) external;

    function isVaultToken(address token) external view returns (bool);
}",1252
RealWorld_TA_58_UniV3Vault_RealWorld_20240807163020.log,58,UniV3Vault,208364,4904,213268,166.0,1.1399,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/external/univ3/INonfungiblePositionManager.sol"";
import ""./interfaces/external/univ3/IUniswapV3Pool.sol"";
import ""./interfaces/external/univ3/IUniswapV3Factory.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./libraries/external/TickMath.sol"";
import ""./libraries/external/LiquidityAmounts.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.
contract UniV3Vault is IERC721Receiver, Vault {
    struct Options {
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct Pair {
        uint256 a0;
        uint256 a1;
    }

    IUniswapV3Pool public immutable pool;

    uint256 public uniV3Nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param fee Fee of the underlying UniV3 pool
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) Vault(vaultGovernance_, vaultTokens_) {
        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);
        pool = IUniswapV3Pool(
            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)
        );
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {
        require(msg.sender == address(_positionManager()), ""SNFT"");
        require(_isStrategy(operator), ""STR"");
        (
            , ,
            address token0,
            address token1,
            , , , , , , ,
        ) = _positionManager().positions(tokenId);
        // new position should have vault tokens
        require(
            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],
            ""VT""
        );

        if (uniV3Nft != 0) {
            (
                , , , , , , ,
                uint128 liquidity,
                , ,
                uint128 tokensOwed0,
                uint128 tokensOwed1
            ) = _positionManager().positions(uniV3Nft);
            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, ""TVL"");
            // return previous uni v3 position nft
            _positionManager().transferFrom(address(this), from, uniV3Nft);
        }

        uniV3Nft = tokenId;
        return this.onERC721Received.selector;
    }

    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        collectedEarnings = new uint256[](2);
        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );
        collectedEarnings[0] = collectedEarnings0;
        collectedEarnings[1] = collectedEarnings1;
        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](_vaultTokens.length);
        if (uniV3Nft == 0)
            return tokenAmounts;
        (
            , , , , , 
            int24 tickLower, 
            int24 tickUpper, 
            uint128 liquidity,
            , , ,
        ) = _positionManager().positions(uniV3Nft);
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtPriceX96,
            sqrtPriceAX96,
            sqrtPriceBX96,
            liquidity
        );
        tokenAmounts[0] = amount0;
        tokenAmounts[1] = amount1;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < tokens.length; i++)
            _allowTokenIfNecessary(tokens[i]);

        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = Pair({
            a0: tokenAmounts[0],
            a1: tokenAmounts[1]
        });
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: uniV3Nft,
                amount0Desired: amounts.a0,
                amount1Desired: amounts.a1,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        actualTokenAmounts[0] = amount0;
        actualTokenAmounts[1] = amount1;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);
        actualTokenAmounts[0] = amounts.a0;
        actualTokenAmounts[1] = amounts.a1;
    }

    function _pullUniV3Nft(
        uint256[] memory tokenAmounts,
        address to,
        Options memory opts
    ) internal returns (Pair memory) {
        uint128 liquidityToPull;
        // scope the code below to avoid stack-too-deep exception
        {
            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);
            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(
                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]
            );
            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;
            if (liquidityToPull == 0) {
                return Pair({a0: 0, a1: 0});
            }
        }
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: uniV3Nft,
                liquidity: liquidityToPull,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: uint128(amount0),
                amount1Max: uint128(amount1)
            })
        );
        return Pair({a0: amount0Collected, a1: amount1Collected});
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {}

    /// TODO: make a virtual function here? Or other better approach
    function _positionManager() internal view returns (INonfungiblePositionManager) {
        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)
            IERC20(token).approve(address(_positionManager()), type(uint256).max);
    }

    function _parseOptions(bytes memory options) internal view returns (Options memory) {
        if (options.length == 0)
            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});

        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);
        return abi.decode(options, (Options));
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);
}",2299
RealWorld_TA_58_ILpIssuerGovernance_RealWorld_20240807182609.log,58,ILpIssuerGovernance,107314,1602,108916,104.0,0.56861,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface ILpIssuerGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param strategyTreasury Reference to address that will collect strategy management fees
    /// @param strategyPerformanceTreasury Reference to address that will collect strategy performance fees
    /// @param managementFee Management fee for Strategist denominated in 10 ** 9
    /// @param performanceFee Performance fee for Strategist denominated in 10 ** 9
    struct DelayedStrategyParams {
        address strategyTreasury;
        address strategyPerformanceTreasury;
        uint256 managementFee;
        uint256 performanceFee;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param managementFeeChargeDelay The minimal interval between management fee charges
    struct DelayedProtocolParams {
        uint256 managementFeeChargeDelay;
    }

    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param tokenLimitPerAddress Reference to address that will collect strategy fees
    struct StrategyParams {
        uint256 tokenLimitPerAddress;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param protocolFee Management fee for Protocol denominated in 10 ** 9
    struct DelayedProtocolPerVaultParams {
        uint256 protocolFee;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory);

    /// @notice Delayed Protocol Per Vault Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Delayed Strategy Params
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;

    /// @notice Stage Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external;

    /// @notice Commit Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolPerVaultParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedProtocolPerVaultParams(uint256 nft) external;

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",1089
RealWorld_TA_58_IUniswapV3PoolImmutables_RealWorld_20240807195853.log,58,IUniswapV3PoolImmutables,54776,1310,56086,93.0,0.30008,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_TA_58_IUniswapV3PoolState_RealWorld_20240807195709.log,58,IUniswapV3PoolState,138007,1381,139388,102.0,0.717655,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolPerformanceFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1445
RealWorld_TA_58_IYearnVault_RealWorld_20240807185044.log,58,IYearnVault,29074,1798,30872,99.0,0.18133,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYearnVault is IERC20 {
    function decimals() external view returns (uint256);

    function pricePerShare() external view returns (uint256);

    function deposit(uint256 amount, address recipient) external returns (uint256);

    // Default maxLoss = 1, i.e. 0.01% [BPS]
    function withdraw(
        uint256 maxShares,
        address recipient,
        uint256 maxLoss
    ) external returns (uint256);
}",133
RealWorld_TA_58_UniV3VaultGovernance_RealWorld_20240807205245.log,58,UniV3VaultGovernance,71488,2716,74204,141.0,0.41176,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all UniV3 Vaults params and can deploy a new UniV3 Vault.
contract UniV3VaultGovernance is IUniV3VaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );
    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",615
RealWorld_TA_58_IDefaultAccessControl_RealWorld_20240807220927.log,58,IDefaultAccessControl,26133,1385,27518,101.0,0.158365,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/IAccessControlEnumerable.sol"";

interface IDefaultAccessControl is IAccessControlEnumerable {
    /// @notice Checks that the address is contract admin.
    /// @param who Address to check
    /// @return `true` if who is admin, `false` otherwise
    function isAdmin(address who) external view returns (bool);
}",93
RealWorld_TA_58_LpIssuerFactory_RealWorld_20240807200538.log,58,LpIssuerFactory,39010,1948,40958,100.0,0.23401,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./LpIssuer.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for LpIssuerGovernance that can create new LpIssuers.
contract LpIssuerFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        (string memory name, string memory symbol) = abi.decode(options, (string, string));
        LpIssuer vault = new LpIssuer(vaultGovernance, vaultTokens, name, symbol);
        return IVault(address(vault));
    }
}",244
RealWorld_TA_58_TickMath_RealWorld_20240807220106.log,58,TickMath,264164,1406,265570,122.0,1.34894,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        // diff: original require(absTick <= uint256(MAX_TICK), ""T"");
        require(absTick <= uint256(int256(MAX_TICK)), ""T"");

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, ""R"");
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}",2878
RealWorld_TA_58_VaultTest_RealWorld_20240807175723.log,58,VaultTest,44095,2846,46941,119.0,0.277395,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract VaultTest is Vault {
    uint256[] res;

    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        res = new uint256[](1);
        res[0] = 0;
    }

    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        return res;
    }

    function _push(uint256[] memory, bytes memory) internal view override returns (uint256[] memory) {
        // no-op, tokens are already on balance
        return res;
    }

    function _pull(
        address,
        uint256[] memory,
        bytes memory
    ) internal view override returns (uint256[] memory) {
        return res;
    }

    function postReclaimTokens(address to, address[] memory tokens) external {
        _postReclaimTokens(to, tokens);
    }

    function isValidPullDestination(address to) external view returns (bool) {
        return _isValidPullDestination(to);
    }

    function isApprovedOrOwner(address to) external view returns (bool) {
        return _isApprovedOrOwner(to);
    }
}",288
RealWorld_TA_58_GatewayVaultFactory_RealWorld_20240807170712.log,58,GatewayVaultFactory,36563,1648,38211,87.0,0.215775,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./GatewayVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for GatewayVaultGovernance that can create new Gateway Vaults.
contract GatewayVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        GatewayVault gatewayVault = new GatewayVault(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",213
RealWorld_TA_58_IAaveVaultGovernance_RealWorld_20240807184358.log,58,IAaveVaultGovernance,41330,1555,42885,95.0,0.23775,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./external/aave/ILendingPool.sol"";
import ""./IVaultGovernance.sol"";

interface IAaveVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param lendingPool Reference to Aave LendingPool
    struct DelayedProtocolParams {
        ILendingPool lendingPool;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",270
RealWorld_TA_58_IUniswapV3PoolImmutables_RealWorld_20240807191029.log,58,IUniswapV3PoolImmutables,54766,1300,56066,89.0,0.29983,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_TA_58_TestVaultGovernance_RealWorld_20240807175059.log,58,TestVaultGovernance,57740,2226,59966,105.0,0.33322,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../VaultGovernance.sol"";

contract TestVaultGovernance is VaultGovernance {
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    function stageDelayedStrategyParams(uint256 nft, bytes memory params) public {
        _stageDelayedStrategyParams(nft, params);
    }

    function stageDelayedProtocolParams(bytes memory params) public {
        _stageDelayedProtocolParams(params);
    }

    function getStagedDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _stagedDelayedStrategyParams[nft];
    }

    function getStagedDelayedProtocolParams() public view returns (bytes memory) {
        return _stagedDelayedProtocolParams;
    }

    function getDelayedStrategyParamsTimestamp(uint256 nft) public view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    function getDelayedProtocolParamsTimestamp() public view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    function getDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _delayedStrategyParams[nft];
    }

    function getDelayedProtocolParams() public view returns (bytes memory) {
        return _delayedProtocolParams;
    }

    function commitDelayedStrategyParams(uint256 nft) public {
        _commitDelayedStrategyParams(nft);
    }

    function commitDelayedProtocolParams() public {
        _commitDelayedProtocolParams();
    }

    function setStrategyParams(uint256 nft, bytes memory params) public {
        _setStrategyParams(nft, params);
    }

    function setProtocolParams(bytes memory params) public {
        _setProtocolParams(params);
    }

    function getStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _strategyParams[nft];
    }

    function getProtocolParams() public view returns (bytes memory) {
        return _protocolParams;
    }

    function requireProtocolAdmin() public view {
        _requireProtocolAdmin();
    }

    function requireAtLeastStrategy(uint256 nft) public view {
        _requireAtLeastStrategy(nft);
    }
}",467
RealWorld_TA_58_IAaveVaultGovernance_RealWorld_20240807222914.log,58,IAaveVaultGovernance,41115,1493,42608,107.0,0.235435,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

import ""./external/aave/ILendingPool.sol"";
import ""./IVaultGovernance.sol"";

interface IAaveVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param lendingPool Reference to Aave LendingPool
    struct DelayedProtocolParams {
        ILendingPool lendingPool;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",270
RealWorld_TA_58_IUniswapV3PoolState_RealWorld_20240807225529.log,58,IUniswapV3PoolState,138102,1498,139600,117.0,0.72047,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Pool state that can change
/// @notice These methods compose the pool's state, and can change with any frequency including multiple times
/// per transaction
interface IUniswapV3PoolState {
    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
    /// when accessed externally.
    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
    /// boundary.
    /// observationIndex The index of the last oracle observation that was written,
    /// observationCardinality The current maximum number of observations stored in the pool,
    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
    /// feeProtocol The protocol fee for both tokens of the pool.
    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
    /// unlocked Whether the pool is currently locked to reentrancy
    function slot0()
        external
        view
        returns (
            uint160 sqrtPriceX96,
            int24 tick,
            uint16 observationIndex,
            uint16 observationCardinality,
            uint16 observationCardinalityNext,
            uint8 feeProtocol,
            bool unlocked
        );

    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal0X128() external view returns (uint256);

    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
    /// @dev This value can overflow the uint256
    function feeGrowthGlobal1X128() external view returns (uint256);

    /// @notice The amounts of token0 and token1 that are owed to the protocol
    /// @dev Protocol fees will never exceed uint128 max in either token
    function protocolPerformanceFees() external view returns (uint128 token0, uint128 token1);

    /// @notice The currently in range liquidity available to the pool
    /// @dev This value has no relationship to the total liquidity across all ticks
    function liquidity() external view returns (uint128);

    /// @notice Look up information about a specific tick in the pool
    /// @param tick The tick to look up
    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
    /// tick upper,
    /// liquidityNet how much liquidity changes when the pool price crosses the tick,
    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
    /// secondsOutside the seconds spent on the other side of the tick from the current tick,
    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
    /// a specific position.
    function ticks(int24 tick)
        external
        view
        returns (
            uint128 liquidityGross,
            int128 liquidityNet,
            uint256 feeGrowthOutside0X128,
            uint256 feeGrowthOutside1X128,
            int56 tickCumulativeOutside,
            uint160 secondsPerLiquidityOutsideX128,
            uint32 secondsOutside,
            bool initialized
        );

    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
    function tickBitmap(int16 wordPosition) external view returns (uint256);

    /// @notice Returns the information about a position by the position's key
    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
    /// @return _liquidity The amount of liquidity in the position,
    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
    function positions(bytes32 key)
        external
        view
        returns (
            uint128 _liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    /// @notice Returns data about a specific observation index
    /// @param index The element of the observations array to fetch
    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
    /// ago, rather than at a specific index in the array.
    /// @return blockTimestamp The timestamp of the observation,
    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
    /// Returns initialized whether the observation has been initialized and the values are safe to use
    function observations(uint256 index)
        external
        view
        returns (
            uint32 blockTimestamp,
            int56 tickCumulative,
            uint160 secondsPerLiquidityCumulativeX128,
            bool initialized
        );
}",1445
RealWorld_TA_58_YearnVaultGovernance_RealWorld_20240807200324.log,58,YearnVaultGovernance,92019,3199,95218,132.0,0.524075,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Aave Vaults params and can deploy a new Aave Vault.
contract YearnVaultGovernance is IYearnVaultGovernance, VaultGovernance {
    mapping(address => address) private _yTokens;

    /// @notice Creates a new contract
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IYearnVaultGovernance
    function yTokenForToken(address token) external view returns (address) {
        address yToken = _yTokens[token];
        if (yToken != address(0)) {
            return yToken;
        }
        IYearnVaultRegistry yearnRegistry = delayedProtocolParams().yearnVaultRegistry;
        try yearnRegistry.latestVault(token) returns (address _vault) {
            return _vault;
        } catch (bytes memory) {
            return address(0);
        }
    }

    /// @inheritdoc IYearnVaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({yearnVaultRegistry: IYearnVaultRegistry(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IYearnVaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @inheritdoc IYearnVaultGovernance
    function setYTokenForToken(address token, address yToken) external {
        _requireProtocolAdmin();
        _yTokens[token] = yToken;
        emit SetYToken(tx.origin, msg.sender, token, yToken);
    }

    /// @notice Emitted when new yToken is set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param token ERC-20 token for the yToken
    /// @param yToken yToken for ERC-20 token
    event SetYToken(address indexed origin, address indexed sender, address indexed token, address yToken);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",862
RealWorld_TA_58_IPeripheryImmutableState_RealWorld_20240807224811.log,58,IPeripheryImmutableState,26356,1120,27476,103.0,0.15418,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_TA_58_GatewayVaultTestFactory_RealWorld_20240807210042.log,58,GatewayVaultTestFactory,35310,3258,38568,138.0,0.24171,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./GatewayVaultTest.sol"";

contract GatewayVaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        GatewayVaultTest gatewayVault = new GatewayVaultTest(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",184
RealWorld_TA_58_IGatewayVaultGovernance_RealWorld_20240807222718.log,58,IGatewayVaultGovernance,58413,1500,59913,113.0,0.322065,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IGatewayVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param redirects Redirects[i] is the nft of subvault that will receive deposit to i-th subvault. If the array is empty there is no redirects
    struct DelayedStrategyParams {
        uint256[] redirects;
    }
    /// @notice Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param limits Token limits for the vault
    struct StrategyParams {
        uint256[] limits;
    }

    /// @notice Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;
}",494
RealWorld_TA_58_TestCallStatic_RealWorld_20240807174521.log,58,TestCallStatic,25395,1662,27057,115.0,0.160215,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

contract TestCallStatic {
    uint256 private _a;

    function incA() external returns (uint256) {
        _a += 1;
        return _a;
    }

    function a() external view returns (uint256) {
        return _a;
    }
}",79
RealWorld_TA_58_UniV3VaultGovernanceTest_RealWorld_20240807174906.log,58,UniV3VaultGovernanceTest,28456,2771,31227,111.0,0.1977,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IUniV3VaultGovernance.sol"";
import ""../UniV3VaultGovernance.sol"";
import ""../VaultGovernance.sol"";

contract UniV3VaultGovernanceTest is UniV3VaultGovernance {
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        UniV3VaultGovernance(internalParams_, delayedProtocolParams_)
    {
        delete _delayedProtocolParams;
    }
}",111
RealWorld_TA_58_IYearnVaultGovernance_RealWorld_20240807183114.log,58,IYearnVaultGovernance,52478,1938,54416,111.0,0.30115,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./external/yearn/IYearnVaultRegistry.sol"";
import ""./IVaultGovernance.sol"";

interface IYearnVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param yearnVaultRegistry Reference to Yearn Vault Registry
    struct DelayedProtocolParams {
        IYearnVaultRegistry yearnVaultRegistry;
    }

    /// @notice Determines a corresponding Yearn vault for token
    /// @param token ERC-20 token for the yToken
    /// @return If there's a yToken returns its address, otherwise returns 0
    function yTokenForToken(address token) external view returns (address);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;

    /// @notice Sets the manual override for yToken vaults map
    /// @dev Can only be called by Protocol Admin
    /// @param token ERC-20 token for yToken
    /// @param yToken for ERC-20 token
    function setYTokenForToken(address token, address yToken) external;
}",401
RealWorld_TA_58_ILpIssuerGovernance_RealWorld_20240807191201.log,58,ILpIssuerGovernance,107186,1458,108644,98.0,0.56509,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface ILpIssuerGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param strategyTreasury Reference to address that will collect strategy management fees
    /// @param strategyPerformanceTreasury Reference to address that will collect strategy performance fees
    /// @param managementFee Management fee for Strategist denominated in 10 ** 9
    /// @param performanceFee Performance fee for Strategist denominated in 10 ** 9
    struct DelayedStrategyParams {
        address strategyTreasury;
        address strategyPerformanceTreasury;
        uint256 managementFee;
        uint256 performanceFee;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param managementFeeChargeDelay The minimal interval between management fee charges
    struct DelayedProtocolParams {
        uint256 managementFeeChargeDelay;
    }

    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param tokenLimitPerAddress Reference to address that will collect strategy fees
    struct StrategyParams {
        uint256 tokenLimitPerAddress;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param protocolFee Management fee for Protocol denominated in 10 ** 9
    struct DelayedProtocolPerVaultParams {
        uint256 protocolFee;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory);

    /// @notice Delayed Protocol Per Vault Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Delayed Strategy Params
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;

    /// @notice Stage Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external;

    /// @notice Commit Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolPerVaultParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedProtocolPerVaultParams(uint256 nft) external;

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",1089
RealWorld_TA_58_IVaultRegistry_RealWorld_20240807184013.log,58,IVaultRegistry,68962,2935,71897,118.0,0.40351,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultFactory.sol"";
import ""./IVaultGovernance.sol"";

interface IVaultRegistry is IERC721 {
    /// @notice Get Vault for the giver NFT ID.
    /// @param nftId NFT ID
    /// @return vault Address of the Vault contract
    function vaultForNft(uint256 nftId) external view returns (address vault);

    /// @notice Get NFT ID for given Vault contract address.
    /// @param vault Address of the Vault contract
    /// @return nftId NFT ID
    function nftForVault(address vault) external view returns (uint256 nftId);

    /// @notice Checks if the nft is locked for all transfers
    /// @param nft NFT to check for lock
    /// @return `true` if locked, false otherwise
    function isLocked(uint256 nft) external view returns (bool);

    /// @notice Register new Vault and mint NFT.
    /// @param vault address of the vault
    /// @param owner owner of the NFT
    /// @return nft Nft minted for the given Vault
    function registerVault(address vault, address owner) external returns (uint256 nft);

    /// @notice Number of Vaults registered.
    function vaultsCount() external view returns (uint256);

    /// @notice All Vaults registered.
    function vaults() external view returns (address[] memory);

    /// @notice Address of the ProtocolGovernance.
    function protocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Address of the staged ProtocolGovernance.
    function stagedProtocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.
    function stagedProtocolGovernanceTimestamp() external view returns (uint256);

    /// @notice Stage new ProtocolGovernance.
    /// @param newProtocolGovernance new ProtocolGovernance
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;

    /// @notice Commit new ProtocolGovernance.
    function commitStagedProtocolGovernance() external;

    /// @notice Approve nft to new address
    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault
    /// @param newAddress address that will be approved
    /// @param nft for re-approval
    function adminApprove(address newAddress, uint256 nft) external;

    /// @notice Lock NFT for transfers
    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.
    /// @param nft - NFT to lock
    function lockNft(uint256 nft) external;
}",619
RealWorld_TA_58_ITrader_RealWorld_20240807215256.log,58,ITrader,52652,2217,54869,108.0,0.3076,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

// When trading from a smart contract, the most important thing to keep in mind is that
// access to an external price source is required. Without this, trades can be frontrun for considerable loss.

interface ITrader {
    /// @notice Trade path element
    /// @param token0 The token to be sold
    /// @param token1 The token to be bought
    /// @param options Protocol-specific options
    struct PathItem {
        address token0;
        address token1;
        bytes options;
    }

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the input tokens to spend
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountOut Amount of the output tokens received
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountOut);

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the output tokens to receive
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountIn of the input tokens spent
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountIn);
}",399
RealWorld_TA_58_ISwapRouter_RealWorld_20240807195529.log,58,ISwapRouter,65891,1421,67312,97.0,0.357875,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_TA_58_UniV3VaultFactory_RealWorld_20240807170120.log,58,UniV3VaultFactory,41399,1711,43110,95.0,0.241215,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./UniV3Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for UniV3VaultGovernance that can create new UniV3 Vaults.
contract UniV3VaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Should equal UniV3 pool fee
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        uint256 fee = abi.decode(options, (uint256));
        UniV3Vault vault = new UniV3Vault(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",271
RealWorld_TA_58_IUniV3VaultGovernance_RealWorld_20240807223507.log,58,IUniV3VaultGovernance,41020,1341,42361,106.0,0.23192,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./external/univ3/INonfungiblePositionManager.sol"";
import ""./IVaultGovernance.sol"";

interface IUniV3VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param positionManager Reference to UniV3 INonfungiblePositionManager
    struct DelayedProtocolParams {
        INonfungiblePositionManager positionManager;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",271
RealWorld_TA_58_GatewayVaultFactory_RealWorld_20240807203721.log,58,GatewayVaultFactory,36562,1675,38237,96.0,0.21631,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./GatewayVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for GatewayVaultGovernance that can create new Gateway Vaults.
contract GatewayVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        GatewayVault gatewayVault = new GatewayVault(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",213
RealWorld_TA_58_IVaultGovernance_RealWorld_20240807193521.log,58,IVaultGovernance,74095,2295,76390,117.0,0.416375,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultRegistry.sol"";
import ""./IVaultFactory.sol"";
import ""./IVault.sol"";

interface IVaultGovernance {
    /// @notice Internal references of the contract.
    /// @param protocolGovernance Reference to Protocol Governance
    /// @param registry Reference to Vault Registry
    struct InternalParams {
        IProtocolGovernance protocolGovernance;
        IVaultRegistry registry;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Checks if contract is initialized.
    /// @dev Uninitialized contracts cannot deploy vaults
    function initialized() external view returns (bool);

    /// @notice Vault factory for this Vault Governance.
    function factory() external view returns (IVaultFactory);

    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.
    /// @param nft Nft of the vault
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.
    function delayedProtocolParamsTimestamp() external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.
    /// @param nft Nft of the vault
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.
    function internalParamsTimestamp() external view returns (uint256);

    /// @notice Internal Params of the contract.
    function internalParams() external view returns (InternalParams memory);

    /// @notice Staged new Internal Params.
    /// @dev The Internal Params could be committed after internalParamsTimestamp
    function stagedInternalParams() external view returns (InternalParams memory);

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @notice Instantly initialize governance with factory.
    /// @dev Can only be called by initial deployer and only once.
    /// Required to be called before any function starts working.
    /// @param factory new factory
    function initialize(IVaultFactory factory) external;

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0.
    /// @param owner Owner of the registry vault nft. If it is address(0) then vault will own his own nft
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) external returns (IVault vault, uint256 nft);

    /// @notice Stage new Internal Params.
    /// @param newParams New Internal Params
    function stageInternalParams(InternalParams memory newParams) external;

    /// @notice Commit staged Internal Params.
    function commitInternalParams() external;
}",669
RealWorld_TA_58_IVault_RealWorld_20240807221714.log,58,IVault,120668,2771,123439,128.0,0.65876,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IVault {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Address of the Vault Governance for this contract.
    function vaultGovernance() external view returns (IVaultGovernance);

    /// @notice ERC20 tokens under Vault management.
    function vaultTokens() external view returns (address[] memory);

    /// @notice Total value locked for this contract.
    /// @dev Generally it is the underlying token value of this contract in some
    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.
    /// @return tokenAmounts Total available balances for multiple tokens (nth tokenAmount corresponds to nth token in vaultTokens)
    function tvl() external view returns (uint256[] memory tokenAmounts);

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Pushes tokens on the vault balance to the underlying protocol. For example, for Yearn this operation will take USDC from
    /// the contract balance and convert it to yUSDC.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice The same as `push` method above but transfers tokens to vault balance prior to calling push.
    /// After the `push` it returns all the leftover tokens back (`push` method doesn't guarantee that tokenAmounts will be invested in full).
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice Pulls tokens from the underlying protocol to the `to` address.
    /// For example, for Yearn this operation will take yUSDC from
    /// the Yearn protocol, convert it to USDC and send to `to` address.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT. There's a subtle difference however - while vault owner
    /// can pull the tokens to any address, Strategy can only pull to other vault in the Vault System (a set of vaults united by the Gateway Vault)
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param to Address to receive the tokens
    /// @param tokens Tokens to pull
    /// @param tokenAmounts Amounts of tokens to pull
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually withdrawn. It could be less than tokenAmounts (but not higher)
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice This method is for claiming accidentally accumulated tokens on the contact's balance.
    /// @dev Can only be called by Protocol Governance.
    /// @param to Address that will receive the tokens
    /// @param tokens Tokens to claim. Each token must be other than those in vaultTokens
    function reclaimTokens(address to, address[] memory tokens) external;

    /// @notice Claim liquidity mining rewards.
    /// @dev Can only be called by Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Since this method allows sending arbitrary transactions, the destinations of the calls
    /// are whitelisted by Protocol Governance.
    /// @param from Address of the reward pool
    /// @param data Abi encoded call to the `from` address
    function claimRewards(address from, bytes memory data) external;

    function isVaultToken(address token) external view returns (bool);
}",1252
RealWorld_TA_58_UniV3VaultTestFactory_RealWorld_20240807172914.log,58,UniV3VaultTestFactory,36325,2200,38525,113.0,0.225625,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./UniV3VaultTest.sol"";

contract UniV3VaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        uint256 fee = abi.decode(options, (uint256));
        UniV3VaultTest vault = new UniV3VaultTest(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",209
RealWorld_TA_58_IYearnVaultRegistry_RealWorld_20240807223845.log,58,IYearnVaultRegistry,21628,1420,23048,99.0,0.13654,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

interface IYearnVaultRegistry {
    function latestVault(address vault) external view returns (address);
}",37
RealWorld_TA_58_INonfungiblePositionManager_RealWorld_20240807190454.log,58,INonfungiblePositionManager,169699,1997,171696,118.0,0.888435,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;
pragma abicoder v2;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IPeripheryImmutableState.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is IPeripheryImmutableState, IERC721 {
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1833
RealWorld_TA_58_TestCallStatic_RealWorld_20240807211855.log,58,TestCallStatic,25161,1412,26573,93.0,0.154045,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

contract TestCallStatic {
    uint256 private _a;

    function incA() external returns (uint256) {
        _a += 1;
        return _a;
    }

    function a() external view returns (uint256) {
        return _a;
    }
}",79
RealWorld_TA_58_LiquidityAmounts_RealWorld_20240807215832.log,58,LiquidityAmounts,159154,3103,162257,152.0,0.85783,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""./FullMath.sol"";
import ""./FixedPoint96.sol"";

/// @title Liquidity amount functions
/// @notice Provides functions for computing liquidity amounts from token amounts and prices
library LiquidityAmounts {
    /// @notice Downcasts uint256 to uint128
    /// @param x The uint258 to be downcasted
    /// @return y The passed value, downcasted to uint128
    function toUint128(uint256 x) private pure returns (uint128 y) {
        require((y = uint128(x)) == x);
    }

    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount0 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount0(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount1 The amount1 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount1(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount of token0 being sent in
    /// @param amount1 The amount of token1 being sent in
    /// @return liquidity The maximum amount of liquidity received
    function getLiquidityForAmounts(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);

            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
        } else {
            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
        }
    }

    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    function getAmount0ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return
            FullMath.mulDiv(
                uint256(liquidity) << FixedPoint96.RESOLUTION,
                sqrtRatioBX96 - sqrtRatioAX96,
                sqrtRatioBX96
            ) / sqrtRatioAX96;
    }

    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount1 The amount of token1
    function getAmount1ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
    }

    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function getAmountsForLiquidity(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
        } else {
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        }
    }
}",1688
RealWorld_TA_58_UniV3Trader_RealWorld_20240807180655.log,58,UniV3Trader,141048,4844,145892,161.0,0.80212,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""../interfaces/external/univ3/ISwapRouter.sol"";
import ""./libraries/TraderExceptionsLibrary.sol"";
import ""./Trader.sol"";

/// @notice Contract that can execute ERC20 swaps on Uniswap V3
contract UniV3Trader is Trader, ITrader {
    using SafeERC20 for IERC20;

    struct Options {
        uint24 fee;
        uint160 sqrtPriceLimitX96;
        uint256 deadline;
        uint256 limitAmount;
    }

    struct PathItemOptions {
        uint24 fee;
    }

    ISwapRouter public swapRouter;

    constructor(address _swapRouter) {
        swapRouter = ISwapRouter(_swapRouter);
    }

    /// @inheritdoc ITrader
    function swapExactInput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 1) {
            return _swapExactInputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactInputMultihop(amount, recipient, path, options_);
        }
    }

    /// @inheritdoc ITrader
    function swapExactOutput(
        uint256,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256) {
        Options memory options_ = abi.decode(options, (Options));
        if (path.length == 0) {
            return _swapExactOutputSingle(path[0].token0, path[0].token1, amount, recipient, options_);
        } else {
            require(_validatePathLinked(path), TraderExceptionsLibrary.INVALID_TRADE_PATH_EXCEPTION);
            return _swapExactOutputMultihop(amount, recipient, path, options_);
        }
    }

    function _validatePathLinked(PathItem[] memory path) internal pure returns (bool result) {
        if (path.length == 0) return false;
        for (uint256 i = 0; i < path.length - 1; ++i) if (path[0].token1 != path[i + 1].token0) return false;
        return true;
    }

    function _swapExactInputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountOut) {
        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInputSingle(params);
    }

    function _swapExactOutputSingle(
        address input,
        address output,
        uint256 amount,
        address recipient,
        Options memory options
    ) internal returns (uint256 amountIn) {
        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({
            tokenIn: input,
            tokenOut: output,
            fee: options.fee,
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount,
            sqrtPriceLimitX96: options.sqrtPriceLimitX96
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutputSingle(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _swapExactInputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountOut) {
        address input = path[0].token0;
        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({
            path: _makeMultihopPath(path),
            recipient: recipient,
            deadline: options.deadline,
            amountIn: amount,
            amountOutMinimum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), amount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountOut = swapRouter.exactInput(params);
    }

    function _swapExactOutputMultihop(
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        Options memory options
    ) internal returns (uint256 amountIn) {
        address input = path[0].token0;
        ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams({
            path: _reverseBytes(_makeMultihopPath(path)),
            recipient: recipient,
            deadline: options.deadline,
            amountOut: amount,
            amountInMaximum: options.limitAmount
        });
        IERC20(input).safeTransferFrom(msg.sender, address(this), options.limitAmount);
        _approveERC20TokenIfNecessary(input, address(swapRouter));
        amountIn = swapRouter.exactOutput(params);
        if (amountIn < options.limitAmount)
            IERC20(input).safeTransferFrom(address(this), recipient, options.limitAmount - amountIn);
    }

    function _reverseBytes(bytes memory input) internal pure returns (bytes memory output) {
        for (uint256 i = 0; i < input.length; ++i) output[i] = input[input.length - 1 - i];
    }

    function _makeMultihopPath(PathItem[] memory path) internal pure returns (bytes memory) {
        bytes memory result;
        for (uint256 i = 0; i < path.length; ++i) {
            PathItemOptions memory pathItemOptions = abi.decode(path[i].options, (PathItemOptions));
            result = bytes.concat(result, abi.encodePacked(path[i].token0, abi.encodePacked(pathItemOptions.fee)));
        }
        result = bytes.concat(result, abi.encodePacked(path[path.length - 1].token1));
        return result;
    }
}",1457
RealWorld_TA_58_GatewayVaultTest_RealWorld_20240807213048.log,58,GatewayVaultTest,38222,3314,41536,143.0,0.25739,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../GatewayVault.sol"";

contract GatewayVaultTest is GatewayVault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        GatewayVault(vaultGovernance_, vaultTokens_)
    {}

    function isValidPullDestination(address to) public view returns (bool) {
        return _isValidPullDestination(to);
    }

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function setSubvaultNfts(uint256[] memory nfts) public {
        _subvaultNfts = nfts;
    }

    function isApprovedOrOwner(address sender) public view returns (bool) {
        return _isApprovedOrOwner(sender);
    }

    function setVaultTokens(address[] memory tokens) public {
        _vaultTokens = tokens;
    }
}",217
RealWorld_TA_58_LpIssuerGovernance_RealWorld_20240807171739.log,58,LpIssuerGovernance,223669,3914,227583,155.0,1.196625,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuerGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Lp Issuers params and can deploy a new LpIssuer Vault.
contract LpIssuerGovernance is IERC721Receiver, ILpIssuerGovernance, VaultGovernance {
    uint256 public immutable MAX_PROTOCOL_FEE;
    uint256 public immutable MAX_MANAGEMENT_FEE;
    uint256 public immutable MAX_PERFORMANCE_FEE;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
        MAX_PROTOCOL_FEE = 5 * CommonLibrary.DENOMINATOR;
        MAX_MANAGEMENT_FEE = 10 * CommonLibrary.DENOMINATOR;
        MAX_PERFORMANCE_FEE = 50 * CommonLibrary.DENOMINATOR;
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory) {
        if (_delayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory)
    {
        if (_stagedDelayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_stagedDelayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({tokenLimitPerAddress: 0});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        require(params.managementFee <= MAX_MANAGEMENT_FEE, ExceptionsLibrary.MAX_MANAGEMENT_FEE);
        require(params.performanceFee <= MAX_PERFORMANCE_FEE, ExceptionsLibrary.MAX_PERFORMANCE_FEE);
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external {
        require(params.protocolFee <= MAX_PROTOCOL_FEE, ExceptionsLibrary.MAX_PROTOCOL_FEE);
        _stageDelayedProtocolPerVaultParams(nft, abi.encode(params));
        emit StageDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            params,
            _delayedStrategyParamsTimestamp[nft]
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolPerVaultParams(uint256 nft) external {
        _commitDelayedProtocolPerVaultParams(nft);
        emit CommitDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams))
        );
    }

    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Required for intermediate vault token transfer in deploy
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external view returns (bytes4) {
        IVaultRegistry registry = _internalParams.registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        return this.onERC721Received.selector;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256 - an nfts of the gateway subvault. It is required that nft subvault is approved by the caller to this address and that it is a gateway vault
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        (uint256 subvaultNft, string memory name, string memory symbol) = abi.decode(
            options,
            (uint256, string, string)
        );
        (vault, nft) = super.deployVault(vaultTokens, abi.encode(name, symbol), msg.sender);
        IVaultRegistry registry = _internalParams.registry;
        ILpIssuer(address(vault)).addSubvault(subvaultNft);
        registry.safeTransferFrom(msg.sender, address(vault), subvaultNft);
    }

    /// @notice Emitted when new DelayedProtocolPerVaultParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolPerVaultParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params
    );

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set.
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",2468
RealWorld_TA_58_WERC20Test_RealWorld_20240807210503.log,58,WERC20Test,29280,3386,32666,131.0,0.21412,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

interface IWrapped {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

contract WERC20Test is IWrapped, ERC20 {
    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {
        _mint(msg.sender, (10**18) * (10**18));
    }

    function deposit() external payable {}

    function withdraw(uint256 wad) external {}
}",125
RealWorld_TA_58_ITrader_RealWorld_20240807181301.log,58,ITrader,52709,2310,55019,109.0,0.309745,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

// When trading from a smart contract, the most important thing to keep in mind is that
// access to an external price source is required. Without this, trades can be frontrun for considerable loss.

interface ITrader {
    /// @notice Trade path element
    /// @param token0 The token to be sold
    /// @param token1 The token to be bought
    /// @param options Protocol-specific options
    struct PathItem {
        address token0;
        address token1;
        bytes options;
    }

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the input tokens to spend
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountOut Amount of the output tokens received
    function swapExactInput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountOut);

    /// @notice Swap exact amount of input tokens for output tokens
    /// @param traderId Trader ID (used only by Chief trader)
    /// @param amount Amount of the output tokens to receive
    /// @param recipient Address of the recipient (not used by Chief trader)
    /// @param path Trade path PathItem[]
    /// @param options Protocol-speceific options
    /// @return amountIn of the input tokens spent
    function swapExactOutput(
        uint256 traderId,
        uint256 amount,
        address recipient,
        PathItem[] memory path,
        bytes memory options
    ) external returns (uint256 amountIn);
}",399
RealWorld_TA_58_IPeripheryImmutableState_RealWorld_20240807195020.log,58,IPeripheryImmutableState,26477,1236,27713,92.0,0.157105,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_TA_58_ILendingPoolAddressesProvider_RealWorld_20240807185618.log,58,ILendingPoolAddressesProvider,56911,1684,58595,114.0,0.318235,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_TA_58_VaultTest_RealWorld_20240807213524.log,58,VaultTest,44030,2887,46917,124.0,0.27789,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract VaultTest is Vault {
    uint256[] res;

    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        res = new uint256[](1);
        res[0] = 0;
    }

    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        return res;
    }

    function _push(uint256[] memory, bytes memory) internal view override returns (uint256[] memory) {
        // no-op, tokens are already on balance
        return res;
    }

    function _pull(
        address,
        uint256[] memory,
        bytes memory
    ) internal view override returns (uint256[] memory) {
        return res;
    }

    function postReclaimTokens(address to, address[] memory tokens) external {
        _postReclaimTokens(to, tokens);
    }

    function isValidPullDestination(address to) external view returns (bool) {
        return _isValidPullDestination(to);
    }

    function isApprovedOrOwner(address to) external view returns (bool) {
        return _isApprovedOrOwner(to);
    }
}",288
RealWorld_TA_58_IChiefTrader_RealWorld_20240807181114.log,58,IChiefTrader,33895,2128,36023,105.0,0.212035,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""../../interfaces/IProtocolGovernance.sol"";

interface IChiefTrader {
    /// @notice ProtocolGovernance
    /// @return the address of the protocol governance contract
    function protocolGovernance() external view returns (address);

    /// @notice Count of traders
    function tradersCount() external view returns (uint256);

    /// @notice Get the address of the trader at index
    /// @param _index The index of the trader
    function getTrader(uint256 _index) external view returns (address);

    /// @notice Get all registered traders
    function traders() external view returns (address[] memory);

    /// @notice Add new trader
    /// @param traderAddress the address of the trader
    function addTrader(address traderAddress) external;
}",179
RealWorld_TA_58_IUniswapV3Pool_RealWorld_20240807224956.log,58,IUniswapV3Pool,29742,1314,31056,94.0,0.17499,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState
{

}",142
RealWorld_TA_58_IGatewayVaultGovernance_RealWorld_20240807184213.log,58,IGatewayVaultGovernance,58368,1458,59826,103.0,0.321,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IGatewayVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param redirects Redirects[i] is the nft of subvault that will receive deposit to i-th subvault. If the array is empty there is no redirects
    struct DelayedStrategyParams {
        uint256[] redirects;
    }
    /// @notice Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param limits Token limits for the vault
    struct StrategyParams {
        uint256[] limits;
    }

    /// @notice Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;
}",494
RealWorld_TA_58_UniV3Vault_RealWorld_20240807200028.log,58,UniV3Vault,208799,5135,213934,174.0,1.146695,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/external/univ3/INonfungiblePositionManager.sol"";
import ""./interfaces/external/univ3/IUniswapV3Pool.sol"";
import ""./interfaces/external/univ3/IUniswapV3Factory.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./libraries/external/TickMath.sol"";
import ""./libraries/external/LiquidityAmounts.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces UniswapV3 protocol in the integration layer.
contract UniV3Vault is IERC721Receiver, Vault {
    struct Options {
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    struct Pair {
        uint256 a0;
        uint256 a1;
    }

    IUniswapV3Pool public immutable pool;

    uint256 public uniV3Nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param fee Fee of the underlying UniV3 pool
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) Vault(vaultGovernance_, vaultTokens_) {
        require(_vaultTokens.length == 2, ExceptionsLibrary.TOKEN_LENGTH);
        pool = IUniswapV3Pool(
            IUniswapV3Factory(_positionManager().factory()).getPool(_vaultTokens[0], _vaultTokens[1], fee)
        );
    }

    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory) external returns (bytes4) {
        require(msg.sender == address(_positionManager()), ""SNFT"");
        require(_isStrategy(operator), ""STR"");
        (
            , ,
            address token0,
            address token1,
            , , , , , , ,
        ) = _positionManager().positions(tokenId);
        // new position should have vault tokens
        require(
            token0 == _vaultTokens[0] && token1 == _vaultTokens[1],
            ""VT""
        );

        if (uniV3Nft != 0) {
            (
                , , , , , , ,
                uint128 liquidity,
                , ,
                uint128 tokensOwed0,
                uint128 tokensOwed1
            ) = _positionManager().positions(uniV3Nft);
            require(liquidity == 0 && tokensOwed0 == 0 && tokensOwed1 == 0, ""TVL"");
            // return previous uni v3 position nft
            _positionManager().transferFrom(address(this), from, uniV3Nft);
        }

        uniV3Nft = tokenId;
        return this.onERC721Received.selector;
    }

    function collectEarnings(address to) external nonReentrant returns (uint256[] memory collectedEarnings) {
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        collectedEarnings = new uint256[](2);
        (uint256 collectedEarnings0, uint256 collectedEarnings1) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: type(uint128).max,
                amount1Max: type(uint128).max
            })
        );
        collectedEarnings[0] = collectedEarnings0;
        collectedEarnings[1] = collectedEarnings1;
        emit CollectedEarnings(tx.origin, to, collectedEarnings0, collectedEarnings1);
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        tokenAmounts = new uint256[](_vaultTokens.length);
        if (uniV3Nft == 0)
            return tokenAmounts;
        (
            , , , , , 
            int24 tickLower, 
            int24 tickUpper, 
            uint128 liquidity,
            , , ,
        ) = _positionManager().positions(uniV3Nft);
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtPriceX96,
            sqrtPriceAX96,
            sqrtPriceBX96,
            liquidity
        );
        tokenAmounts[0] = amount0;
        tokenAmounts[1] = amount1;
    }

    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < tokens.length; i++)
            _allowTokenIfNecessary(tokens[i]);

        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = Pair({
            a0: tokenAmounts[0],
            a1: tokenAmounts[1]
        });
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (, uint256 amount0, uint256 amount1) = _positionManager().increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: uniV3Nft,
                amount0Desired: amounts.a0,
                amount1Desired: amounts.a1,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        actualTokenAmounts[0] = amount0;
        actualTokenAmounts[1] = amount1;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        actualTokenAmounts = new uint256[](2);
        if (uniV3Nft == 0)
            return actualTokenAmounts;

        Options memory opts = _parseOptions(options);
        Pair memory amounts = _pullUniV3Nft(tokenAmounts, to, opts);
        actualTokenAmounts[0] = amounts.a0;
        actualTokenAmounts[1] = amounts.a1;
    }

    function _pullUniV3Nft(
        uint256[] memory tokenAmounts,
        address to,
        Options memory opts
    ) internal returns (Pair memory) {
        uint128 liquidityToPull;
        // scope the code below to avoid stack-too-deep exception
        {
            (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = _positionManager().positions(uniV3Nft);
            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
            uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);
            uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
            liquidityToPull = LiquidityAmounts.getLiquidityForAmounts(
                sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, tokenAmounts[0], tokenAmounts[1]
            );
            liquidityToPull = liquidity < liquidityToPull ? liquidity : liquidityToPull;
            if (liquidityToPull == 0) {
                return Pair({a0: 0, a1: 0});
            }
        }
        Pair memory minAmounts = Pair({
            a0: opts.amount0Min,
            a1: opts.amount1Min
        });
        (uint256 amount0, uint256 amount1) = _positionManager().decreaseLiquidity(
            INonfungiblePositionManager.DecreaseLiquidityParams({
                tokenId: uniV3Nft,
                liquidity: liquidityToPull,
                amount0Min: minAmounts.a0,
                amount1Min: minAmounts.a1,
                deadline: opts.deadline
            })
        );
        (uint256 amount0Collected, uint256 amount1Collected) = _positionManager().collect(
            INonfungiblePositionManager.CollectParams({
                tokenId: uniV3Nft,
                recipient: to,
                amount0Max: uint128(amount0),
                amount1Max: uint128(amount1)
            })
        );
        return Pair({a0: amount0Collected, a1: amount1Collected});
    }

    function _postReclaimTokens(address, address[] memory tokens) internal view override {}

    /// TODO: make a virtual function here? Or other better approach
    function _positionManager() internal view returns (INonfungiblePositionManager) {
        return IUniV3VaultGovernance(address(_vaultGovernance)).delayedProtocolParams().positionManager;
    }

    function _allowTokenIfNecessary(address token) internal {
        if (IERC20(token).allowance(address(_positionManager()), address(this)) < type(uint256).max / 2)
            IERC20(token).approve(address(_positionManager()), type(uint256).max);
    }

    function _parseOptions(bytes memory options) internal view returns (Options memory) {
        if (options.length == 0)
            return Options({amount0Min: 0, amount1Min: 0, deadline: block.timestamp + 600});

        require(options.length == 32 * 3, ExceptionsLibrary.IO_LENGTH);
        return abi.decode(options, (Options));
    }

    function _isStrategy(address addr) internal view returns (bool) {
        return _vaultGovernance.internalParams().registry.getApproved(_nft) == addr;
    }

    event CollectedEarnings(address indexed origin, address indexed to, uint256 amount0, uint256 amount1);
}",2299
RealWorld_TA_58_ISwapRouter_RealWorld_20240807190654.log,58,ISwapRouter,65671,1586,67257,107.0,0.360075,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_TA_58_YearnVault_RealWorld_20240807204042.log,58,YearnVault,103326,5207,108533,168.0,0.62077,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/external/aave/ILendingPool.sol"";
import ""./interfaces/external/yearn/IYearnVault.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces Yearn protocol in the integration layer.
/// @dev Notes:
/// ### TVL
///
/// The TVL of the vault is cached and updated after each deposit withdraw.
/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the
/// last `deposit` / `withdraw`
///
/// ### yTokens
/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there
/// - in YearnVaultRegistry.
/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,
/// the YearnVault cannot be created.
///
/// ### Push / Pull
/// There are some deposit limits imposed by Yearn vaults.
/// The contract's vaultTokens are fully allowed to corresponding yTokens.

contract YearnVault is Vault {
    address[] private _yTokens;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        _yTokens = new address[](vaultTokens_.length);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);
            require(_yTokens[i] != address(0), ""YV"");
        }
    }

    /// @notice Yearn protocol vaults used by this contract
    function yTokens() external view returns (address[] memory) {
        return _yTokens;
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        address[] memory tokens = _vaultTokens;
        tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < _yTokens.length; i++) {
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());
        }
    }

    function _push(uint256[] memory tokenAmounts, bytes memory)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            address token = tokens[i];
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            _allowTokenIfNecessary(token, address(yToken));
            yToken.deposit(tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        uint256 maxLoss = abi.decode(options, (uint256));
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            IYearnVault yToken = IYearnVault(_yTokens[i]);
            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());
            uint256 balance = yToken.balanceOf(address(this));
            if (yTokenAmount > balance) {
                yTokenAmount = balance;
            }
            if (yTokenAmount == 0) {
                continue;
            }
            yToken.withdraw(yTokenAmount, to, maxLoss);
            (tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _allowTokenIfNecessary(address token, address yToken) internal {
        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {
            IERC20(token).approve(yToken, type(uint256).max);
        }
    }
}",1006
RealWorld_TA_58_VaultGovernance_RealWorld_20240807171515.log,58,VaultGovernance,204070,3375,207445,142.0,1.08785,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Internal contract for managing different params.
/// @dev The contract should be overriden by the concrete VaultGovernance,
/// define different params structs and use abi.decode / abi.encode to serialize
/// to bytes in this contract. It also should emit events on params change.
abstract contract VaultGovernance is IVaultGovernance {
    InternalParams internal _internalParams;
    InternalParams private _stagedInternalParams;
    uint256 internal _internalParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedStrategyParams;
    mapping(uint256 => bytes) internal _stagedDelayedStrategyParams;
    mapping(uint256 => uint256) internal _delayedStrategyParamsTimestamp;

    mapping(uint256 => bytes) internal _delayedProtocolPerVaultParams;
    mapping(uint256 => bytes) internal _stagedDelayedProtocolPerVaultParams;
    mapping(uint256 => uint256) internal _delayedProtocolPerVaultParamsTimestamp;

    bytes internal _delayedProtocolParams;
    bytes internal _stagedDelayedProtocolParams;
    uint256 internal _delayedProtocolParamsTimestamp;

    mapping(uint256 => bytes) internal _strategyParams;
    bytes internal _protocolParams;

    IVaultFactory public factory;
    bool public initialized;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    constructor(InternalParams memory internalParams_) {
        _internalParams = internalParams_;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVaultGovernance
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256) {
        return _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @inheritdoc IVaultGovernance
    function delayedProtocolParamsTimestamp() external view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParamsTimestamp() external view returns (uint256) {
        return _internalParamsTimestamp;
    }

    /// @inheritdoc IVaultGovernance
    function internalParams() external view returns (InternalParams memory) {
        return _internalParams;
    }

    /// @inheritdoc IVaultGovernance
    function stagedInternalParams() external view returns (InternalParams memory) {
        return _stagedInternalParams;
    }

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @inheritdoc IVaultGovernance
    function initialize(IVaultFactory factory_) external {
        require(!initialized, ExceptionsLibrary.INITIALIZATION);
        factory = factory_;
        initialized = true;
    }

    /// @inheritdoc IVaultGovernance
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) public virtual returns (IVault vault, uint256 nft) {
        require(initialized, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance protocolGovernance = IProtocolGovernance(_internalParams.protocolGovernance);
        require(protocolGovernance.permissionless() || protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.PERMISSIONLESS_OR_ADMIN);
        vault = factory.deployVault(vaultTokens, options);
        address nftOwner = owner;
        nft = _internalParams.registry.registerVault(address(vault), nftOwner);
        vault.initialize(nft);
        emit DeployedVault(tx.origin, msg.sender, vaultTokens, options, nftOwner, address(vault), nft);
    }

    /// @inheritdoc IVaultGovernance
    function stageInternalParams(InternalParams memory newParams) external {
        _requireProtocolAdmin();
        _stagedInternalParams = newParams;
        _internalParamsTimestamp = block.timestamp + _internalParams.protocolGovernance.governanceDelay();
        emit StagedInternalParams(tx.origin, msg.sender, newParams, _internalParamsTimestamp);
    }

    /// @inheritdoc IVaultGovernance
    function commitInternalParams() external {
        _requireProtocolAdmin();
        require(_internalParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _internalParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _internalParams = _stagedInternalParams;
        delete _internalParamsTimestamp;
        emit CommitedInternalParams(tx.origin, msg.sender, _internalParams);
    }

    // -------------------  INTERNAL  -------------------

    /// @notice Set Delayed Strategy Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _stagedDelayedStrategyParams[nft] = params;
        uint256 delayFactor = _delayedStrategyParams[nft].length == 0 ? 0 : 1;
        _delayedStrategyParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Strategy Params
    function _commitDelayedStrategyParams(uint256 nft) internal {
        _requireAtLeastStrategy(nft);
        require(_delayedStrategyParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedStrategyParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedStrategyParams[nft] = _stagedDelayedStrategyParams[nft];
        delete _stagedDelayedStrategyParams[nft];
        delete _delayedStrategyParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Per Vault Params
    /// @param nft Nft of the vault
    /// @param params New params
    function _stageDelayedProtocolPerVaultParams(uint256 nft, bytes memory params) internal {
        _requireProtocolAdmin();
        _stagedDelayedProtocolPerVaultParams[nft] = params;
        uint256 delayFactor = _delayedProtocolPerVaultParams[nft].length == 0 ? 0 : 1;
        _delayedProtocolPerVaultParamsTimestamp[nft] =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Per Vault Params
    function _commitDelayedProtocolPerVaultParams(uint256 nft) internal {
        _requireProtocolAdmin();
        require(_delayedProtocolPerVaultParamsTimestamp[nft] > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolPerVaultParamsTimestamp[nft], ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolPerVaultParams[nft] = _stagedDelayedProtocolPerVaultParams[nft];
        delete _stagedDelayedProtocolPerVaultParams[nft];
        delete _delayedProtocolPerVaultParamsTimestamp[nft];
    }

    /// @notice Set Delayed Protocol Params
    /// @param params New params
    function _stageDelayedProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        uint256 delayFactor = _delayedProtocolParams.length == 0 ? 0 : 1;
        _stagedDelayedProtocolParams = params;
        _delayedProtocolParamsTimestamp =
            block.timestamp +
            _internalParams.protocolGovernance.governanceDelay() *
            delayFactor;
    }

    /// @notice Commit Delayed Protocol Params
    function _commitDelayedProtocolParams() internal {
        _requireProtocolAdmin();
        require(_delayedProtocolParamsTimestamp > 0, ExceptionsLibrary.NULL);
        require(block.timestamp >= _delayedProtocolParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        _delayedProtocolParams = _stagedDelayedProtocolParams;
        delete _stagedDelayedProtocolParams;
        delete _delayedProtocolParamsTimestamp;
    }

    /// @notice Set immediate strategy params
    /// @dev Should require nft > 0
    /// @param nft Nft of the vault
    /// @param params New params
    function _setStrategyParams(uint256 nft, bytes memory params) internal {
        _requireAtLeastStrategy(nft);
        _strategyParams[nft] = params;
    }

    /// @notice Set immediate protocol params
    /// @param params New params
    function _setProtocolParams(bytes memory params) internal {
        _requireProtocolAdmin();
        _protocolParams = params;
    }

    function _requireAtLeastStrategy(uint256 nft) internal view {
        require(
            (_internalParams.protocolGovernance.isAdmin(msg.sender) ||
                _internalParams.registry.getApproved(nft) == msg.sender ||
                (_internalParams.registry.ownerOf(nft) == msg.sender)),
            ExceptionsLibrary.REQUIRE_AT_LEAST_ADMIN
        );
    }

    function _requireProtocolAdmin() internal view {
        require(_internalParams.protocolGovernance.isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
    }

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StagedInternalParams(address indexed origin, address indexed sender, InternalParams params, uint256 when);

    /// @notice Emitted when InternalParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    event CommitedInternalParams(address indexed origin, address indexed sender, InternalParams params);

    /// @notice Emitted when New Vault is deployed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param vaultTokens Vault tokens for this vault
    /// @param options Options for deploy. The details of the options structure are specified in subcontracts
    /// @param owner Owner of the VaultRegistry NFT for this vault
    /// @param vaultAddress Address of the new Vault
    /// @param vaultNft VaultRegistry NFT for the new Vault
    event DeployedVault(
        address indexed origin,
        address indexed sender,
        address[] vaultTokens,
        bytes options,
        address owner,
        address vaultAddress,
        uint256 vaultNft
    );
}",2217
RealWorld_TA_58_ILendingPoolAddressesProvider_RealWorld_20240807194513.log,58,ILendingPoolAddressesProvider,57072,1867,58939,98.0,0.3227,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_TA_58_IVaultGovernance_RealWorld_20240807223303.log,58,IVaultGovernance,74121,2409,76530,122.0,0.418785,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultRegistry.sol"";
import ""./IVaultFactory.sol"";
import ""./IVault.sol"";

interface IVaultGovernance {
    /// @notice Internal references of the contract.
    /// @param protocolGovernance Reference to Protocol Governance
    /// @param registry Reference to Vault Registry
    struct InternalParams {
        IProtocolGovernance protocolGovernance;
        IVaultRegistry registry;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Checks if contract is initialized.
    /// @dev Uninitialized contracts cannot deploy vaults
    function initialized() external view returns (bool);

    /// @notice Vault factory for this Vault Governance.
    function factory() external view returns (IVaultFactory);

    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.
    /// @param nft Nft of the vault
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.
    function delayedProtocolParamsTimestamp() external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.
    /// @param nft Nft of the vault
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.
    function internalParamsTimestamp() external view returns (uint256);

    /// @notice Internal Params of the contract.
    function internalParams() external view returns (InternalParams memory);

    /// @notice Staged new Internal Params.
    /// @dev The Internal Params could be committed after internalParamsTimestamp
    function stagedInternalParams() external view returns (InternalParams memory);

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @notice Instantly initialize governance with factory.
    /// @dev Can only be called by initial deployer and only once.
    /// Required to be called before any function starts working.
    /// @param factory new factory
    function initialize(IVaultFactory factory) external;

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0.
    /// @param owner Owner of the registry vault nft. If it is address(0) then vault will own his own nft
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) external returns (IVault vault, uint256 nft);

    /// @notice Stage new Internal Params.
    /// @param newParams New Internal Params
    function stageInternalParams(InternalParams memory newParams) external;

    /// @notice Commit staged Internal Params.
    function commitInternalParams() external;
}",669
RealWorld_TA_58_UniV3VaultGovernance_RealWorld_20240807172017.log,58,UniV3VaultGovernance,70876,2180,73056,106.0,0.39798,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IUniV3VaultGovernance.sol"";
import ""./VaultGovernance.sol"";

/// @notice Governance that manages all UniV3 Vaults params and can deploy a new UniV3 Vault.
contract UniV3VaultGovernance is IUniV3VaultGovernance, VaultGovernance {
    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({positionManager: INonfungiblePositionManager(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IUniV3VaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IUniV3VaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );
    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",615
RealWorld_TA_58_TestEncoding_RealWorld_20240807210928.log,58,TestEncoding,35321,2300,37621,112.0,0.222605,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IProtocolGovernance.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultRegistry.sol"";

contract TestEncoding {
    IProtocolGovernance.Params private data;
    address addr;

    function setDataCalldata(bytes calldata tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function setDataMemory(bytes memory tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function getData() public view returns (IProtocolGovernance.Params memory) {
        return data;
    }

    function setAddress(bytes calldata _addr) public {
        addr = abi.decode(_addr, (address));
    }

    function getAddress() public view returns (address) {
        return addr;
    }
}",188
RealWorld_TA_58_IUniswapV3Factory_RealWorld_20240807194831.log,58,IUniswapV3Factory,97570,2017,99587,107.0,0.52819,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_TA_58_IUniswapV3Factory_RealWorld_20240807224623.log,58,IUniswapV3Factory,97139,1578,98717,106.0,0.517255,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_TA_58_ILendingPoolAddressesProvider_RealWorld_20240807224255.log,58,ILendingPoolAddressesProvider,57080,1833,58913,104.0,0.32206,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",462
RealWorld_TA_58_TestFunctionEncoding_RealWorld_20240807211122.log,58,TestFunctionEncoding,27819,2561,30380,117.0,0.190315,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../Vault.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVault.sol"";

contract TestFunctionEncoding {
    Vault public vault;

    constructor(Vault _vault) {
        vault = _vault;
    }

    function encodeWithSignatureTest(address from) external {
        bytes memory data = abi.encodeWithSignature(""tvl()"");
        vault.claimRewards(from, data);
    }
}",107
RealWorld_TA_58_IGatewayVault_RealWorld_20240807183308.log,58,IGatewayVault,52931,2432,55363,114.0,0.313295,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface IGatewayVault is IVault {
    /// @notice List of subvaults nfts
    function subvaultNfts() external view returns (uint256[] memory);

    /// @notice Checks that vault is subvault of the IGatewayVault.
    /// @param vault The vault to check
    /// @return `true` if vault is a subvault of the IGatewayVault
    function hasSubvault(address vault) external view returns (bool);

    /// @notice Breakdown of tvls by subvault.
    /// @return tokenAmounts Token amounts with subvault breakdown. If there are `k` subvaults then token `j`, `tokenAmounts[j]` would be a vector 1 x k - breakdown of token amount by subvaults
    function subvaultsTvl() external view returns (uint256[][] memory tokenAmounts);

    /// @notice A tvl of a specific subvault.
    /// @param vaultNum The number of the subvault in the subvaults array
    /// @return An array of token amounts (tvl) in the same order as vaultTokens
    function subvaultTvl(uint256 vaultNum) external view returns (uint256[] memory);

    /// @notice Adds subvaults NFTs to vault.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param nfts Subvault NFTs to add
    function addSubvaults(uint256[] memory nfts) external;

    /// @notice Approves all NFTs to given address.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param strategy The address to which all NFTs will be approved (strategy)
    /// @param nfts Subvault NFTs to add
    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external;
}",416
RealWorld_TA_58_IYearnVaultRegistry_RealWorld_20240807185225.log,58,IYearnVaultRegistry,20434,1262,21696,87.0,0.12741,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

interface IYearnVaultRegistry {
    function latestVault(address vault) external view returns (address);
}",37
RealWorld_TA_58_LpIssuer_RealWorld_20240807164845.log,58,LpIssuer,317800,5096,322896,394.0,1.69092,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./DefaultAccessControl.sol"";
import ""./LpIssuerGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.
contract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;
    uint256 private _subvaultNft;
    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 private _nft;
    uint256[] private _lpPriceHighWaterMarks;
    uint256[] private _existentials;

    uint256 public lastFeeCharge;

    /// @notice Creates a new contract.
    /// @dev All subvault nfts must be owned by this vault before.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param name_ Name of the ERC-721 token
    /// @param symbol_ Symbol of the ERC-721 token
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        string memory name_,
        string memory symbol_
    ) ERC20(name_, symbol_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            address token = vaultTokens_[i];
            _vaultTokensIndex[token] = true;
            _lpPriceHighWaterMarks.push(0);
            _existentials.push(10**(ERC20(token).decimals() / 2));
        }
        lastFeeCharge = block.timestamp;
    }

    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    function existentials() external view returns (uint256[] memory) {
        return _existentials;
    }

    /// @inheritdoc ILpIssuer
    function subvaultNft() external view returns (uint256) {
        return _subvaultNft;
    }

    function nft() external view returns (uint256) {
        return _nft;
    }

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    /// @inheritdoc ILpIssuer
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 thisNft = _nft;
        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);
        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);
        IVault subvault = _subvault();
        uint256[] memory existentials_ = _existentials;
        uint256[] memory tvl = subvault.tvl(); //pre-money
        uint256 supply = totalSupply();
        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;
        if (supply > 0) {
            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR
            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);
        }

        // If with that big supply we don't reveive any lps then it doesn't make sense to continue
        require(balanceFactor > 0, ""BF"");
        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);

        // Making sure the proportion between tokenAmounts and tvl are the same
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);
            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));
            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);
        }

        uint256[] memory actualTokenAmounts = subvault.transferAndPush(
            address(this),
            _vaultTokens,
            balancedAmounts,
            options
        );
        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);

        require(amountToMint > 0, ""ZLP"");

        require(
            amountToMint + balanceOf(msg.sender) <=
                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,
            ExceptionsLibrary.LIMIT_PER_ADDRESS
        );

        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);
        _mint(msg.sender, amountToMint);

        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (balancedAmounts[i] > actualTokenAmounts[i]) {
                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);
            }
        }

        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);
    }

    /// @inheritdoc ILpIssuer
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external nonReentrant {
        uint256 supply = totalSupply();
        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);
        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);
        uint256[] memory tvl = _subvault().tvl();
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;
        }
        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (actualTokenAmounts[i] == 0) {
                continue;
            }
            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);
        }
        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);
        _burn(msg.sender, lpTokenAmount);
        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);
    }

    /// @inheritdoc ILpIssuer
    function addSubvault(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        _subvaultNft = nft_;
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external nonReentrant returns (bytes4) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        registry.lockNft(tokenId);
        return this.onERC721Received.selector;
    }

    function _allowTokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {
            IERC20(token).approve(address(to), type(uint256).max);
        }
    }

    function _subvault() internal view returns (IVault) {
        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));
    }

    /// @dev We don't charge on any deposit / withdraw to save gas.
    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)
    /// So the error results in slightly lower management fees than in exact case
    function _chargeFees(
        uint256 thisNft,
        uint256[] memory tvls,
        uint256 supply,
        uint256[] memory deltaTvls,
        uint256 deltaSupply,
        bool isWithdraw
    ) internal {
        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));
        uint256 elapsed = block.timestamp - lastFeeCharge;
        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {
            return;
        }
        lastFeeCharge = block.timestamp;
        uint256 baseSupply = supply;
        if (isWithdraw) {
            baseSupply = 0;
            if (supply > deltaSupply) {
                baseSupply = supply - deltaSupply;
            }
        }

        if (baseSupply == 0) {
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;
            }
            return;
        }

        uint256[] memory baseTvls = new uint256[](tvls.length);
        for (uint256 i = 0; i < baseTvls.length; i++) {
            if (isWithdraw) {
                baseTvls[i] = tvls[i] - deltaTvls[i];
            } else {
                baseTvls[i] = tvls[i];
            }
        }

        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);
        if (strategyParams.managementFee > 0) {
            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /
                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(strategyParams.strategyTreasury, toMint);
            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);
        }
        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;
        if (protocolFee > 0) {
            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();
            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(treasury, toMint);
            emit ProtocolFeesCharged(treasury, protocolFee, toMint);
        }
        uint256 performanceFee = strategyParams.performanceFee;
        uint256[] memory hwms = _lpPriceHighWaterMarks;
        if (performanceFee > 0) {
            uint256 minLpPriceFactor = type(uint256).max;
            for (uint256 i = 0; i < baseTvls.length; i++) {
                uint256 hwm = hwms[i];
                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;
                if (lpPrice > hwm) {
                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;
                    if (delta < minLpPriceFactor) {
                        minLpPriceFactor = delta;
                    }
                } else {
                    // not eligible for performance fees
                    return;
                }
            }
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            }
            address treasury = strategyParams.strategyPerformanceTreasury;
            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            _mint(treasury, toMint);
            emit PerformanceFeesCharged(treasury, performanceFee, toMint);
        }
    }

    function _getLpAmount(
        uint256[] memory tvl,
        uint256[] memory amounts,
        uint256[] memory existentials_,
        uint256 supply
    ) internal pure returns (uint256 lpAmount) {
        lpAmount = 0;
        if (supply == 0) {
            // On init lpToken = max(tokenAmounts)
            for (uint256 i = 0; i < tvl.length; i++) {
                if (amounts[i] > lpAmount) {
                    lpAmount = amounts[i];
                }
            }
            return lpAmount;
        }
        for (uint256 i = 0; i < tvl.length; i++) {
            if (amounts[i] <= existentials_[i]) {
                // skip existential deposits for lp share calculation
                continue;
            }
            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];
            // take min of meaningful tokenLp amounts
            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {
                lpAmount = tokenLpAmount;
            }
        }
    }

    function _getBalancedAmount(
        uint256 tvl,
        uint256 amount,
        uint256 existential,
        uint256 balanceFactor,
        uint256 supply
    ) internal pure returns (uint256) {
        if (supply == 0) {
            // skip normalization on init
            return amount;
        }
        if (amount < existential) {
            // avoid putting small amounts as it can introduce unnecessary harsh errors
            // one should provide amount > existential deposit each time tvl is not 0
            require(tvl == 0, ""PN"");
            return 0;
        }
        // normalize amount
        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;
        if (res > amount) {
            res = amount;
        }
        return res;
    }

    /// @notice Emitted when management fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when protocol fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when performance fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when liquidity is deposited
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens deposited
    /// @param actualTokenAmounts Token amounts deposited
    /// @param lpTokenMinted LP tokens received by the liquidity provider
    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);

    /// @notice Emitted when liquidity is withdrawn
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens withdrawn
    /// @param actualTokenAmounts Token amounts withdrawn
    /// @param lpTokenBurned LP tokens burned from the liquidity provider
    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);
}",3633
RealWorld_TA_58_ILpIssuer_RealWorld_20240807184535.log,58,ILpIssuer,44474,2042,46516,109.0,0.26321,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface ILpIssuer {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Nft of the underlying vault.
    function subvaultNft() external view returns (uint256);

    /// @notice Adds subvault nft to the vault.
    /// @dev Can be called only once.
    /// @param nft Subvault nft to add
    function addSubvault(uint256 nft) external;

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Deposit tokens into LpIssuer
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external;

    /// @notice Withdraw tokens from LpIssuer
    /// @param to Address to withdraw to
    /// @param lpTokenAmount Amount of token to withdraw
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external;
}",323
RealWorld_TA_58_IUniV3VaultGovernance_RealWorld_20240807193720.log,58,IUniV3VaultGovernance,41035,1344,42379,98.0,0.232055,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./external/univ3/INonfungiblePositionManager.sol"";
import ""./IVaultGovernance.sol"";

interface IUniV3VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param positionManager Reference to UniV3 INonfungiblePositionManager
    struct DelayedProtocolParams {
        INonfungiblePositionManager positionManager;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",271
RealWorld_TA_58_ProtocolGovernance_RealWorld_20240807172418.log,58,ProtocolGovernance,189249,4909,194158,169.0,1.044425,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./DefaultAccessControl.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all params common for Mellow Permissionless Vaults protocol.
contract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {
    using EnumerableSet for EnumerableSet.AddressSet;
    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;

    EnumerableSet.AddressSet private _claimAllowlist;
    address[] private _pendingClaimAllowlistAdd;
    uint256 public pendingClaimAllowlistAddTimestamp;

    address[] private _tokenWhitelist;
    address[] private _pendingTokenWhitelistAdd;
    uint256 private _numberOfValidTokens;
    mapping(address => bool) _tokensAllowed;
    mapping(address => bool) _tokenEverAdded;
    uint256 public pendingTokenWhitelistAddTimestamp;

    EnumerableSet.AddressSet private _vaultGovernances;
    address[] private _pendingVaultGovernancesAdd;
    uint256 public pendingVaultGovernancesAddTimestamp;

    IProtocolGovernance.Params public params;
    Params public pendingParams;

    uint256 public pendingParamsTimestamp;

    /// @notice Creates a new contract.
    /// @param admin Initial admin of the contract
    constructor(address admin) DefaultAccessControl(admin) {
        _tokenWhitelist = new address[](0);
        _numberOfValidTokens = 0;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IProtocolGovernance
    function claimAllowlist() external view returns (address[] memory) {
        uint256 l = _claimAllowlist.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _claimAllowlist.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function tokenWhitelist() external view returns (address[] memory) {
        uint256 l = _tokenWhitelist.length;
        address[] memory res = new address[](_numberOfValidTokens);
        uint256 j = 0;
        for (uint256 i = 0; i < l; i++) {
            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {
                continue;
            }
            res[j] = _tokenWhitelist[i];
            j += 1;
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function vaultGovernances() external view returns (address[] memory) {
        uint256 l = _vaultGovernances.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _vaultGovernances.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingClaimAllowlistAdd() external view returns (address[] memory) {
        return _pendingClaimAllowlistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingTokenWhitelistAdd() external view returns (address[] memory) {
        return _pendingTokenWhitelistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingVaultGovernancesAdd() external view returns (address[] memory) {
        return _pendingVaultGovernancesAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToClaim(address addr) external view returns (bool) {
        return _claimAllowlist.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToken(address addr) external view returns (bool) {
        return _tokenEverAdded[addr] && _tokensAllowed[addr];
    }

    /// @inheritdoc IProtocolGovernance
    function isVaultGovernance(address addr) external view returns (bool) {
        return _vaultGovernances.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function permissionless() external view returns (bool) {
        return params.permissionless;
    }

    /// @inheritdoc IProtocolGovernance
    function maxTokensPerVault() external view returns (uint256) {
        return params.maxTokensPerVault;
    }

    /// @inheritdoc IProtocolGovernance
    function governanceDelay() external view returns (uint256) {
        return params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function protocolTreasury() external view returns (address) {
        return params.protocolTreasury;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @inheritdoc IProtocolGovernance
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingClaimAllowlistAdd = addresses;
        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromClaimAllowlist(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_claimAllowlist.contains(addr)) {
            return;
        }
        _claimAllowlist.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ""ADM"");
        _pendingTokenWhitelistAdd = addresses;
        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromTokenWhitelist(address addr) external {
        require(isAdmin(msg.sender), ""ADM"");
        _tokensAllowed[addr] = false;
        if (_tokenEverAdded[addr]) {
            --_numberOfValidTokens;
        }
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingVaultGovernancesAdd = addresses;
        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromVaultGovernances(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_vaultGovernances.contains(addr)) {
            return;
        }
        _vaultGovernances.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingParams(IProtocolGovernance.Params memory newParams) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);
        pendingParams = newParams;
        pendingParamsTimestamp = block.timestamp + params.governanceDelay;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @inheritdoc IProtocolGovernance
    function commitClaimAllowlistAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {
            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);
        }
        delete _pendingClaimAllowlistAdd;
        delete pendingClaimAllowlistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitTokenWhitelistAdd() external {
        require(isAdmin(msg.sender), ""ADM"");
        require(
            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),
            ""TS""
        );
        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {
            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {
                _numberOfValidTokens += 1;
                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);
                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;
            } else {
                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {
                    _numberOfValidTokens += 1;
                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                }
            }
        }
        delete _pendingTokenWhitelistAdd;
        delete pendingTokenWhitelistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitVaultGovernancesAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {
            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);
        }
        delete _pendingVaultGovernancesAdd;
        delete pendingVaultGovernancesAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitParams() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params
        params = pendingParams;
        delete pendingParams;
        delete pendingParamsTimestamp;
    }
}",2027
RealWorld_TA_58_IDefaultAccessControl_RealWorld_20240807182755.log,58,IDefaultAccessControl,24827,1315,26142,86.0,0.150435,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/IAccessControlEnumerable.sol"";

interface IDefaultAccessControl is IAccessControlEnumerable {
    /// @notice Checks that the address is contract admin.
    /// @param who Address to check
    /// @return `true` if who is admin, `false` otherwise
    function isAdmin(address who) external view returns (bool);
}",93
RealWorld_TA_58_IERC20VaultGovernance_RealWorld_20240807192629.log,58,IERC20VaultGovernance,40535,1539,42074,102.0,0.233455,"// SPDX-License-Identifier: BSL-1.1
pragma solidity 0.8.9;

import ""../trader/interfaces/ITrader.sol"";
import ""./IVaultGovernance.sol"";

interface IERC20VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param trader Reference to internal Trader contract
    struct DelayedProtocolParams {
        ITrader trader;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",266
RealWorld_TA_58_INonfungiblePositionManager_RealWorld_20240807225132.log,58,INonfungiblePositionManager,170116,2792,172908,134.0,0.90642,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;
pragma abicoder v2;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IPeripheryImmutableState.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is IPeripheryImmutableState, IERC721 {
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1833
RealWorld_TA_58_IYearnVault_RealWorld_20240807193900.log,58,IYearnVault,29067,1760,30827,101.0,0.180535,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYearnVault is IERC20 {
    function decimals() external view returns (uint256);

    function pricePerShare() external view returns (uint256);

    function deposit(uint256 amount, address recipient) external returns (uint256);

    // Default maxLoss = 1, i.e. 0.01% [BPS]
    function withdraw(
        uint256 maxShares,
        address recipient,
        uint256 maxLoss
    ) external returns (uint256);
}",133
RealWorld_TA_58_IUniV3VaultGovernance_RealWorld_20240807184913.log,58,IUniV3VaultGovernance,41049,1340,42389,88.0,0.232045,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./external/univ3/INonfungiblePositionManager.sol"";
import ""./IVaultGovernance.sol"";

interface IUniV3VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param positionManager Reference to UniV3 INonfungiblePositionManager
    struct DelayedProtocolParams {
        INonfungiblePositionManager positionManager;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",271
RealWorld_TA_58_INonfungiblePositionManager_RealWorld_20240807195334.log,58,INonfungiblePositionManager,169787,2090,171877,112.0,0.890735,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;
pragma abicoder v2;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IPeripheryImmutableState.sol"";

/// @title Non-fungible token for positions
/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred
/// and authorized.
interface INonfungiblePositionManager is IPeripheryImmutableState, IERC721 {
    /// @notice Emitted when liquidity is increased for a position NFT
    /// @dev Also emitted when a token is minted
    /// @param tokenId The ID of the token for which liquidity was increased
    /// @param liquidity The amount by which liquidity for the NFT position was increased
    /// @param amount0 The amount of token0 that was paid for the increase in liquidity
    /// @param amount1 The amount of token1 that was paid for the increase in liquidity
    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when liquidity is decreased for a position NFT
    /// @param tokenId The ID of the token for which liquidity was decreased
    /// @param liquidity The amount by which liquidity for the NFT position was decreased
    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity
    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity
    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);
    /// @notice Emitted when tokens are collected for a position NFT
    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior
    /// @param tokenId The ID of the token for which underlying tokens were collected
    /// @param recipient The address of the account that received the collected tokens
    /// @param amount0 The amount of token0 owed to the position that was collected
    /// @param amount1 The amount of token1 owed to the position that was collected
    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);

    /// @notice Returns the position information associated with a given token ID.
    /// @dev Throws if the token ID is not valid.
    /// @param tokenId The ID of the token that represents the position
    /// @return nonce The nonce for permits
    /// @return operator The address that is approved for spending
    /// @return token0 The address of the token0 for a specific pool
    /// @return token1 The address of the token1 for a specific pool
    /// @return fee The fee associated with the pool
    /// @return tickLower The lower end of the tick range for the position
    /// @return tickUpper The higher end of the tick range for the position
    /// @return liquidity The liquidity of the position
    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position
    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position
    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation
    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation
    function positions(uint256 tokenId)
        external
        view
        returns (
            uint96 nonce,
            address operator,
            address token0,
            address token1,
            uint24 fee,
            int24 tickLower,
            int24 tickUpper,
            uint128 liquidity,
            uint256 feeGrowthInside0LastX128,
            uint256 feeGrowthInside1LastX128,
            uint128 tokensOwed0,
            uint128 tokensOwed1
        );

    struct MintParams {
        address token0;
        address token1;
        uint24 fee;
        int24 tickLower;
        int24 tickUpper;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        address recipient;
        uint256 deadline;
    }

    /// @notice Creates a new position wrapped in a NFT
    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized
    /// a method does not exist, i.e. the pool is assumed to be initialized.
    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata
    /// @return tokenId The ID of the token that represents the minted position
    /// @return liquidity The amount of liquidity for this position
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function mint(MintParams calldata params)
        external
        payable
        returns (
            uint256 tokenId,
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct IncreaseLiquidityParams {
        uint256 tokenId;
        uint256 amount0Desired;
        uint256 amount1Desired;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`
    /// @param params tokenId The ID of the token for which liquidity is being increased,
    /// amount0Desired The desired amount of token0 to be spent,
    /// amount1Desired The desired amount of token1 to be spent,
    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,
    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return liquidity The new liquidity amount as a result of the increase
    /// @return amount0 The amount of token0 to acheive resulting liquidity
    /// @return amount1 The amount of token1 to acheive resulting liquidity
    function increaseLiquidity(IncreaseLiquidityParams calldata params)
        external
        payable
        returns (
            uint128 liquidity,
            uint256 amount0,
            uint256 amount1
        );

    struct DecreaseLiquidityParams {
        uint256 tokenId;
        uint128 liquidity;
        uint256 amount0Min;
        uint256 amount1Min;
        uint256 deadline;
    }

    /// @notice Decreases the amount of liquidity in a position and accounts it to the position
    /// @param params tokenId The ID of the token for which liquidity is being decreased,
    /// amount The amount by which liquidity will be decreased,
    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,
    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,
    /// deadline The time by which the transaction must be included to effect the change
    /// @return amount0 The amount of token0 accounted to the position's tokens owed
    /// @return amount1 The amount of token1 accounted to the position's tokens owed
    function decreaseLiquidity(DecreaseLiquidityParams calldata params)
        external
        payable
        returns (uint256 amount0, uint256 amount1);

    struct CollectParams {
        uint256 tokenId;
        address recipient;
        uint128 amount0Max;
        uint128 amount1Max;
    }

    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient
    /// @param params tokenId The ID of the NFT for which tokens are being collected,
    /// recipient The account that should receive the tokens,
    /// amount0Max The maximum amount of token0 to collect,
    /// amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of fees collected in token0
    /// @return amount1 The amount of fees collected in token1
    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);

    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens
    /// must be collected first.
    /// @param tokenId The ID of the token that is being burned
    function burn(uint256 tokenId) external payable;
}",1833
RealWorld_TA_58_TestEncoding_RealWorld_20240807173550.log,58,TestEncoding,34915,2161,37076,112.0,0.217795,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IProtocolGovernance.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultRegistry.sol"";

contract TestEncoding {
    IProtocolGovernance.Params private data;
    address addr;

    function setDataCalldata(bytes calldata tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function setDataMemory(bytes memory tempData) public {
        data = abi.decode(tempData, (IProtocolGovernance.Params));
    }

    function getData() public view returns (IProtocolGovernance.Params memory) {
        return data;
    }

    function setAddress(bytes calldata _addr) public {
        addr = abi.decode(_addr, (address));
    }

    function getAddress() public view returns (address) {
        return addr;
    }
}",188
RealWorld_TA_58_YearnVaultFactory_RealWorld_20240807170537.log,58,YearnVaultFactory,36803,1609,38412,93.0,0.216195,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./YearnVault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for YearnVaultGovernance that can create new Yearn Vaults.
contract YearnVaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        YearnVault vault = new YearnVault(vaultGovernance, vaultTokens);
        return IVault(vault);
    }
}",217
RealWorld_TA_58_ILpIssuer_RealWorld_20240807223104.log,58,ILpIssuer,44489,1996,46485,117.0,0.262365,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface ILpIssuer {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Nft of the underlying vault.
    function subvaultNft() external view returns (uint256);

    /// @notice Adds subvault nft to the vault.
    /// @dev Can be called only once.
    /// @param nft Subvault nft to add
    function addSubvault(uint256 nft) external;

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Deposit tokens into LpIssuer
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external;

    /// @notice Withdraw tokens from LpIssuer
    /// @param to Address to withdraw to
    /// @param lpTokenAmount Amount of token to withdraw
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external;
}",323
RealWorld_TA_58_IYearnVaultGovernance_RealWorld_20240807191732.log,58,IYearnVaultGovernance,52622,2088,54710,105.0,0.30487,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./external/yearn/IYearnVaultRegistry.sol"";
import ""./IVaultGovernance.sol"";

interface IYearnVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param yearnVaultRegistry Reference to Yearn Vault Registry
    struct DelayedProtocolParams {
        IYearnVaultRegistry yearnVaultRegistry;
    }

    /// @notice Determines a corresponding Yearn vault for token
    /// @param token ERC-20 token for the yToken
    /// @return If there's a yToken returns its address, otherwise returns 0
    function yTokenForToken(address token) external view returns (address);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;

    /// @notice Sets the manual override for yToken vaults map
    /// @dev Can only be called by Protocol Admin
    /// @param token ERC-20 token for yToken
    /// @param yToken for ERC-20 token
    function setYTokenForToken(address token, address yToken) external;
}",401
RealWorld_TA_58_IProtocolGovernance_RealWorld_20240807182923.log,58,IProtocolGovernance,91179,2340,93519,109.0,0.502695,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IDefaultAccessControl.sol"";
import ""./IVaultRegistry.sol"";

interface IProtocolGovernance is IDefaultAccessControl {
    /// @notice CommonLibrary protocol params.
    /// @param permissionless If `true` anyone can spawn vaults, o/w only Protocol Governance Admin
    /// @param maxTokensPerVault Max different token addresses that could be managed by the protocol
    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them
    /// @param protocolTreasury Protocol treasury address for collecting management fees
    struct Params {
        bool permissionless;
        uint256 maxTokensPerVault;
        uint256 governanceDelay;
        address protocolTreasury;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function claimAllowlist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to claimAllowlist.
    function pendingClaimAllowlistAdd() external view returns (address[] memory);

    /// @notice Addresses of tokens allowed for vaults.
    function tokenWhitelist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to tokenWhitelist.
    function pendingTokenWhitelistAdd() external view returns (address[] memory);

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function vaultGovernances() external view returns (address[] memory);

    /// @notice Pending addresses to be added to vaultGovernances.
    function pendingVaultGovernancesAdd() external view returns (address[] memory);

    /// @notice Check if address is allowed to claim.
    function isAllowedToClaim(address addr) external view returns (bool);

    /// @notice Check if address is an approved token.
    function isAllowedToken(address addr) external view returns (bool);

    /// @notice Check if address is a registered vault governance.
    function isVaultGovernance(address addr) external view returns (bool);

    /// @notice If `false` only admins can deploy new vaults, o/w anyone can deploy a new vault.
    function permissionless() external view returns (bool);

    /// @notice Max different ERC20 token addresses that could be managed by the protocol.
    function maxTokensPerVault() external view returns (uint256);

    /// @notice The delay for committing any governance params.
    function governanceDelay() external view returns (uint256);

    /// @notice The address of the protocol treasury.
    function protocolTreasury() external view returns (address);

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @notice Set new pending params.
    /// @param newParams newParams to set
    function setPendingParams(Params memory newParams) external;

    /// @notice Stage addresses for claim allow list.
    /// @param addresses Addresses to add
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for token whitelist.
    /// @param addresses Addresses to add
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for vault governances.
    /// @param addresses Addresses to add
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external;

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @notice Commit pending params.
    function commitParams() external;

    /// @notice Commit pending ClaimAllowlistAdd params.
    function commitClaimAllowlistAdd() external;

    /// @notice Commit pending tokenWhitelistAdd params.
    function commitTokenWhitelistAdd() external;

    /// @notice Commit pending VaultGovernancesAdd params.
    function commitVaultGovernancesAdd() external;

    /// @notice Remove from claim allow list immediately.
    function removeFromClaimAllowlist(address addr) external;

    /// @notice Remove from token whitelist immediately.
    function removeFromTokenWhitelist(address addr) external;

    /// @notice Remove from vault governances immediately.
    function removeFromVaultGovernances(address addr) external;
}",867
RealWorld_TA_58_LpIssuerFactory_RealWorld_20240807163513.log,58,LpIssuerFactory,39006,1892,40898,232.0,0.23287,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./LpIssuer.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for LpIssuerGovernance that can create new LpIssuers.
contract LpIssuerFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @inheritdoc IVaultFactory
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        (string memory name, string memory symbol) = abi.decode(options, (string, string));
        LpIssuer vault = new LpIssuer(vaultGovernance, vaultTokens, name, symbol);
        return IVault(address(vault));
    }
}",244
RealWorld_TA_58_ILpIssuerGovernance_RealWorld_20240807220731.log,58,ILpIssuerGovernance,107238,1910,109148,114.0,0.57439,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface ILpIssuerGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param strategyTreasury Reference to address that will collect strategy management fees
    /// @param strategyPerformanceTreasury Reference to address that will collect strategy performance fees
    /// @param managementFee Management fee for Strategist denominated in 10 ** 9
    /// @param performanceFee Performance fee for Strategist denominated in 10 ** 9
    struct DelayedStrategyParams {
        address strategyTreasury;
        address strategyPerformanceTreasury;
        uint256 managementFee;
        uint256 performanceFee;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param managementFeeChargeDelay The minimal interval between management fee charges
    struct DelayedProtocolParams {
        uint256 managementFeeChargeDelay;
    }

    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param tokenLimitPerAddress Reference to address that will collect strategy fees
    struct StrategyParams {
        uint256 tokenLimitPerAddress;
    }

    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param protocolFee Management fee for Protocol denominated in 10 ** 9
    struct DelayedProtocolPerVaultParams {
        uint256 protocolFee;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory);

    /// @notice Delayed Protocol Per Vault Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Delayed Strategy Params
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;

    /// @notice Stage Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external;

    /// @notice Commit Delayed Protocol Per Vault Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolPerVaultParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedProtocolPerVaultParams(uint256 nft) external;

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",1089
RealWorld_TA_58_IGatewayVaultGovernance_RealWorld_20240807193003.log,58,IGatewayVaultGovernance,58544,1637,60181,101.0,0.32546,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IGatewayVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param redirects Redirects[i] is the nft of subvault that will receive deposit to i-th subvault. If the array is empty there is no redirects
    struct DelayedStrategyParams {
        uint256[] redirects;
    }
    /// @notice Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param limits Token limits for the vault
    struct StrategyParams {
        uint256[] limits;
    }

    /// @notice Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Delayed Strategy Params staged for commit after delay.
    /// @param nft VaultRegistry NFT of the vault
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory);

    /// @notice Strategy Params.
    /// @param nft VaultRegistry NFT of the vault
    function strategyParams(uint256 nft) external view returns (StrategyParams memory);

    /// @notice Stage Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external;

    /// @notice Commit Delayed Strategy Params, i.e. Params that could be changed by Strategy or Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedStrategyParamsTimestamp
    /// @param nft VaultRegistry NFT of the vault
    function commitDelayedStrategyParams(uint256 nft) external;

    /// @notice Set Strategy params, i.e. Params that could be changed by Strategy or Protocol Governance immediately.
    /// @param nft Nft of the vault
    /// @param params New params
    function setStrategyParams(uint256 nft, StrategyParams calldata params) external;
}",494
RealWorld_TA_58_IVaultGovernance_RealWorld_20240807184726.log,58,IVaultGovernance,73976,2193,76169,105.0,0.41374,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultRegistry.sol"";
import ""./IVaultFactory.sol"";
import ""./IVault.sol"";

interface IVaultGovernance {
    /// @notice Internal references of the contract.
    /// @param protocolGovernance Reference to Protocol Governance
    /// @param registry Reference to Vault Registry
    struct InternalParams {
        IProtocolGovernance protocolGovernance;
        IVaultRegistry registry;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Checks if contract is initialized.
    /// @dev Uninitialized contracts cannot deploy vaults
    function initialized() external view returns (bool);

    /// @notice Vault factory for this Vault Governance.
    function factory() external view returns (IVaultFactory);

    /// @notice Timestamp in unix time seconds after which staged Delayed Strategy Params could be committed.
    /// @param nft Nft of the vault
    function delayedStrategyParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params could be committed.
    function delayedProtocolParamsTimestamp() external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Delayed Protocol Params Per Vault could be committed.
    /// @param nft Nft of the vault
    function delayedProtocolPerVaultParamsTimestamp(uint256 nft) external view returns (uint256);

    /// @notice Timestamp in unix time seconds after which staged Internal Params could be committed.
    function internalParamsTimestamp() external view returns (uint256);

    /// @notice Internal Params of the contract.
    function internalParams() external view returns (InternalParams memory);

    /// @notice Staged new Internal Params.
    /// @dev The Internal Params could be committed after internalParamsTimestamp
    function stagedInternalParams() external view returns (InternalParams memory);

    // -------------------  PUBLIC, MUTATING  -------------------

    /// @notice Instantly initialize governance with factory.
    /// @dev Can only be called by initial deployer and only once.
    /// Required to be called before any function starts working.
    /// @param factory new factory
    function initialize(IVaultFactory factory) external;

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0.
    /// @param owner Owner of the registry vault nft. If it is address(0) then vault will own his own nft
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address owner
    ) external returns (IVault vault, uint256 nft);

    /// @notice Stage new Internal Params.
    /// @param newParams New Internal Params
    function stageInternalParams(InternalParams memory newParams) external;

    /// @notice Commit staged Internal Params.
    function commitInternalParams() external;
}",669
RealWorld_TA_58_IPeripheryImmutableState_RealWorld_20240807190144.log,58,IPeripheryImmutableState,26370,1142,27512,85.0,0.15469,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Immutable state
/// @notice Functions that return immutable state of the router
interface IPeripheryImmutableState {
    /// @return Returns the address of the Uniswap V3 factory
    function factory() external view returns (address);

    /// @return Returns the address of WETH9
    function WETH9() external view returns (address);
}",99
RealWorld_TA_58_VaultRegistry_RealWorld_20240807172205.log,58,VaultRegistry,135880,3363,139243,130.0,0.74666,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IVaultFactory.sol"";
import ""./interfaces/IVaultRegistry.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice This contract is used to manage ERC721 NFT for all Vaults.
contract VaultRegistry is IVaultRegistry, ERC721 {
    uint256 private _stagedProtocolGovernanceTimestamp;
    IProtocolGovernance private _protocolGovernance;
    IProtocolGovernance private _stagedProtocolGovernance;

    address[] private _vaults;
    mapping(address => uint256) private _nftIndex;
    mapping(uint256 => address) private _vaultIndex;
    mapping(uint256 => bool) private _locks;
    uint256 private _topNft = 1;

    /// @notice Creates a new contract.
    /// @param name ERC721 token name
    /// @param symbol ERC721 token symbol
    /// @param protocolGovernance_ Reference to ProtocolGovernance
    constructor(
        string memory name,
        string memory symbol,
        IProtocolGovernance protocolGovernance_
    ) ERC721(name, symbol) {
        _protocolGovernance = protocolGovernance_;
    }

    function vaults() external view returns (address[] memory) {
        return _vaults;
    }

    /// @inheritdoc IVaultRegistry
    function vaultForNft(uint256 nft) external view returns (address) {
        return _vaultIndex[nft];
    }

    /// @inheritdoc IVaultRegistry
    function nftForVault(address vault) external view returns (uint256) {
        return _nftIndex[vault];
    }

    /// @inheritdoc IVaultRegistry
    function isLocked(uint256 nft) external view returns (bool) {
        return _locks[nft];
    }

    /// @inheritdoc IVaultRegistry
    function registerVault(address vault, address owner) external returns (uint256 nft) {
        require(_protocolGovernance.isVaultGovernance(msg.sender), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        nft = _topNft;
        _safeMint(owner, nft);
        _vaultIndex[nft] = vault;
        _nftIndex[vault] = nft;
        _vaults.push(vault);
        _topNft += 1;
        emit VaultRegistered(tx.origin, msg.sender, nft, vault, owner);
    }

    /// @inheritdoc IVaultRegistry
    function protocolGovernance() external view returns (IProtocolGovernance) {
        return _protocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernance() external view returns (IProtocolGovernance) {
        return _stagedProtocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernanceTimestamp() external view returns (uint256) {
        return _stagedProtocolGovernanceTimestamp;
    }

    /// @inheritdoc IVaultRegistry
    function vaultsCount() external view returns (uint256) {
        return _vaults.length;
    }

    /// @inheritdoc IVaultRegistry
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        _stagedProtocolGovernance = newProtocolGovernance;
        _stagedProtocolGovernanceTimestamp = (block.timestamp + _protocolGovernance.governanceDelay());
        emit StagedProtocolGovernance(tx.origin, msg.sender, newProtocolGovernance, _stagedProtocolGovernanceTimestamp);
    }

    /// @inheritdoc IVaultRegistry
    function commitStagedProtocolGovernance() external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        require(_stagedProtocolGovernanceTimestamp > 0, ExceptionsLibrary.NULL_OR_NOT_INITIALIZED);
        require(block.timestamp >= _stagedProtocolGovernanceTimestamp, ExceptionsLibrary.TIMESTAMP);
        _protocolGovernance = _stagedProtocolGovernance;
        delete _stagedProtocolGovernanceTimestamp;
        emit CommitedProtocolGovernance(tx.origin, msg.sender, _protocolGovernance);
    }

    /// @inheritdoc IVaultRegistry
    function adminApprove(address newAddress, uint256 nft) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        IERC721(address(this)).approve(newAddress, nft);
    }

    function lockNft(uint256 nft) external {
        require(ownerOf(nft) == msg.sender, ExceptionsLibrary.TOKEN_OWNER);
        _locks[nft] = true;
        emit TokenLocked(tx.origin, msg.sender, nft);
    }

    function _isProtocolAdmin(address sender) internal view returns (bool) {
        return _protocolGovernance.isAdmin(sender);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256 tokenId
    ) internal view override {
        require(!_locks[tokenId], ExceptionsLibrary.LOCKED_NFT);
    }

    /// @notice Emitted when token is locked for transfers
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft NFT to be locked
    event TokenLocked(address indexed origin, address indexed sender, uint256 indexed nft);

    /// @notice Emitted when new Vault is registered in VaultRegistry
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param vault Address of the Vault contract
    /// @param owner Owner of the VaultRegistry NFT
    event VaultRegistered(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        address vault,
        address owner
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance
    /// @param start Timestamp of the start of the new ProtocolGovernance
    event StagedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance,
        uint256 start
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance that has been committed
    event CommitedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance
    );
}",1400
RealWorld_TA_58_IYearnVault_RealWorld_20240807223655.log,58,IYearnVault,29011,1576,30587,107.0,0.176575,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IYearnVault is IERC20 {
    function decimals() external view returns (uint256);

    function pricePerShare() external view returns (uint256);

    function deposit(uint256 amount, address recipient) external returns (uint256);

    // Default maxLoss = 1, i.e. 0.01% [BPS]
    function withdraw(
        uint256 maxShares,
        address recipient,
        uint256 maxLoss
    ) external returns (uint256);
}",133
RealWorld_TA_58_TickMath_RealWorld_20240807182028.log,58,TickMath,264156,1188,265344,128.0,1.34454,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128
library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
    int24 internal constant MAX_TICK = -MIN_TICK;

    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    /// @notice Calculates sqrt(1.0001^tick) * 2^96
    /// @dev Throws if |tick| > max tick
    /// @param tick The input tick for the above formula
    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        // diff: original require(absTick <= uint256(MAX_TICK), ""T"");
        require(absTick <= uint256(int256(MAX_TICK)), ""T"");

        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

        if (tick > 0) ratio = type(uint256).max / ratio;

        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // second inequality must be < because the price can never reach the price at the max tick
        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, ""R"");
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb = 0;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }

        if (msb >= 128) r = ratio >> (msb - 127);
        else r = ratio << (127 - msb);

        int256 log_2 = (int256(msb) - 128) << 64;

        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(63, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(62, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(61, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(60, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(59, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(58, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(57, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(56, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(55, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(54, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(53, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(52, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(51, f))
            r := shr(f, r)
        }
        assembly {
            r := shr(127, mul(r, r))
            let f := shr(128, r)
            log_2 := or(log_2, shl(50, f))
        }

        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number

        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
    }
}",2878
RealWorld_TA_58_IUniswapV3Pool_RealWorld_20240807190311.log,58,IUniswapV3Pool,29831,1410,31241,101.0,0.177355,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState
{

}",142
RealWorld_TA_58_Trader_RealWorld_20240807180508.log,58,Trader,33158,2072,35230,105.0,0.20723,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./interfaces/ITrader.sol"";

/// @notice Base contract for every trader contract (a contract that can execute ERC20 swaps)
abstract contract Trader is ERC165 {
    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return (interfaceId == this.supportsInterface.selector || interfaceId == type(ITrader).interfaceId);
    }

    function _approveERC20TokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)
            IERC20(token).approve(to, type(uint256).max);
    }
}",192
RealWorld_TA_58_UniV3VaultFactory_RealWorld_20240807202909.log,58,UniV3VaultFactory,41843,1779,43622,110.0,0.244795,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.9;

import ""./interfaces/IVaultFactory.sol"";
import ""./UniV3Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Helper contract for UniV3VaultGovernance that can create new UniV3 Vaults.
contract UniV3VaultFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this VaultKind
    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Should equal UniV3 pool fee
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        uint256 fee = abi.decode(options, (uint256));
        UniV3Vault vault = new UniV3Vault(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",271
RealWorld_TA_58_IGatewayVault_RealWorld_20240807221509.log,58,IGatewayVault,52752,2226,54978,122.0,0.30828,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface IGatewayVault is IVault {
    /// @notice List of subvaults nfts
    function subvaultNfts() external view returns (uint256[] memory);

    /// @notice Checks that vault is subvault of the IGatewayVault.
    /// @param vault The vault to check
    /// @return `true` if vault is a subvault of the IGatewayVault
    function hasSubvault(address vault) external view returns (bool);

    /// @notice Breakdown of tvls by subvault.
    /// @return tokenAmounts Token amounts with subvault breakdown. If there are `k` subvaults then token `j`, `tokenAmounts[j]` would be a vector 1 x k - breakdown of token amount by subvaults
    function subvaultsTvl() external view returns (uint256[][] memory tokenAmounts);

    /// @notice A tvl of a specific subvault.
    /// @param vaultNum The number of the subvault in the subvaults array
    /// @return An array of token amounts (tvl) in the same order as vaultTokens
    function subvaultTvl(uint256 vaultNum) external view returns (uint256[] memory);

    /// @notice Adds subvaults NFTs to vault.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param nfts Subvault NFTs to add
    function addSubvaults(uint256[] memory nfts) external;

    /// @notice Approves all NFTs to given address.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param strategy The address to which all NFTs will be approved (strategy)
    /// @param nfts Subvault NFTs to add
    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external;
}",416
RealWorld_TA_58_IGatewayVault_RealWorld_20240807191919.log,58,IGatewayVault,52964,2422,55386,112.0,0.31326,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface IGatewayVault is IVault {
    /// @notice List of subvaults nfts
    function subvaultNfts() external view returns (uint256[] memory);

    /// @notice Checks that vault is subvault of the IGatewayVault.
    /// @param vault The vault to check
    /// @return `true` if vault is a subvault of the IGatewayVault
    function hasSubvault(address vault) external view returns (bool);

    /// @notice Breakdown of tvls by subvault.
    /// @return tokenAmounts Token amounts with subvault breakdown. If there are `k` subvaults then token `j`, `tokenAmounts[j]` would be a vector 1 x k - breakdown of token amount by subvaults
    function subvaultsTvl() external view returns (uint256[][] memory tokenAmounts);

    /// @notice A tvl of a specific subvault.
    /// @param vaultNum The number of the subvault in the subvaults array
    /// @return An array of token amounts (tvl) in the same order as vaultTokens
    function subvaultTvl(uint256 vaultNum) external view returns (uint256[] memory);

    /// @notice Adds subvaults NFTs to vault.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param nfts Subvault NFTs to add
    function addSubvaults(uint256[] memory nfts) external;

    /// @notice Approves all NFTs to given address.
    /// @dev Can be called only once by GatewayVaultGovernance
    /// @param strategy The address to which all NFTs will be approved (strategy)
    /// @param nfts Subvault NFTs to add
    function setApprovalsForStrategy(address strategy, uint256[] memory nfts) external;
}",416
RealWorld_TA_58_IVaultRegistry_RealWorld_20240807222504.log,58,IVaultRegistry,68733,2615,71348,132.0,0.395965,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultFactory.sol"";
import ""./IVaultGovernance.sol"";

interface IVaultRegistry is IERC721 {
    /// @notice Get Vault for the giver NFT ID.
    /// @param nftId NFT ID
    /// @return vault Address of the Vault contract
    function vaultForNft(uint256 nftId) external view returns (address vault);

    /// @notice Get NFT ID for given Vault contract address.
    /// @param vault Address of the Vault contract
    /// @return nftId NFT ID
    function nftForVault(address vault) external view returns (uint256 nftId);

    /// @notice Checks if the nft is locked for all transfers
    /// @param nft NFT to check for lock
    /// @return `true` if locked, false otherwise
    function isLocked(uint256 nft) external view returns (bool);

    /// @notice Register new Vault and mint NFT.
    /// @param vault address of the vault
    /// @param owner owner of the NFT
    /// @return nft Nft minted for the given Vault
    function registerVault(address vault, address owner) external returns (uint256 nft);

    /// @notice Number of Vaults registered.
    function vaultsCount() external view returns (uint256);

    /// @notice All Vaults registered.
    function vaults() external view returns (address[] memory);

    /// @notice Address of the ProtocolGovernance.
    function protocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Address of the staged ProtocolGovernance.
    function stagedProtocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.
    function stagedProtocolGovernanceTimestamp() external view returns (uint256);

    /// @notice Stage new ProtocolGovernance.
    /// @param newProtocolGovernance new ProtocolGovernance
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;

    /// @notice Commit new ProtocolGovernance.
    function commitStagedProtocolGovernance() external;

    /// @notice Approve nft to new address
    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault
    /// @param newAddress address that will be approved
    /// @param nft for re-approval
    function adminApprove(address newAddress, uint256 nft) external;

    /// @notice Lock NFT for transfers
    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.
    /// @param nft - NFT to lock
    function lockNft(uint256 nft) external;
}",619
RealWorld_TA_58_LiquidityAmounts_RealWorld_20240807181822.log,58,LiquidityAmounts,158910,2399,161309,124.0,0.84253,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

import ""./FullMath.sol"";
import ""./FixedPoint96.sol"";

/// @title Liquidity amount functions
/// @notice Provides functions for computing liquidity amounts from token amounts and prices
library LiquidityAmounts {
    /// @notice Downcasts uint256 to uint128
    /// @param x The uint258 to be downcasted
    /// @return y The passed value, downcasted to uint128
    function toUint128(uint256 x) private pure returns (uint128 y) {
        require((y = uint128(x)) == x);
    }

    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount0 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount0(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount1 The amount1 being sent in
    /// @return liquidity The amount of returned liquidity
    function getLiquidityForAmount1(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
    }

    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param amount0 The amount of token0 being sent in
    /// @param amount1 The amount of token1 being sent in
    /// @return liquidity The maximum amount of liquidity received
    function getLiquidityForAmounts(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint256 amount0,
        uint256 amount1
    ) internal pure returns (uint128 liquidity) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);

            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
        } else {
            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
        }
    }

    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    function getAmount0ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return
            FullMath.mulDiv(
                uint256(liquidity) << FixedPoint96.RESOLUTION,
                sqrtRatioBX96 - sqrtRatioAX96,
                sqrtRatioBX96
            ) / sqrtRatioAX96;
    }

    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount1 The amount of token1
    function getAmount1ForLiquidity(
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
    }

    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
    /// pool prices and the prices at the tick boundaries
    /// @param sqrtRatioX96 A sqrt price representing the current pool prices
    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
    /// @param liquidity The liquidity being valued
    /// @return amount0 The amount of token0
    /// @return amount1 The amount of token1
    function getAmountsForLiquidity(
        uint160 sqrtRatioX96,
        uint160 sqrtRatioAX96,
        uint160 sqrtRatioBX96,
        uint128 liquidity
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);

        if (sqrtRatioX96 <= sqrtRatioAX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        } else if (sqrtRatioX96 < sqrtRatioBX96) {
            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
        } else {
            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
        }
    }
}",1688
RealWorld_TA_58_UniV3VaultTest_RealWorld_20240807175924.log,58,UniV3VaultTest,30731,3219,33950,119.0,0.218035,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../UniV3Vault.sol"";

contract UniV3VaultTest is UniV3Vault {
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        uint24 fee
    ) UniV3Vault(vaultGovernance_, vaultTokens_, fee) {}

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }
}",133
RealWorld_TA_58_IERC20VaultGovernance_RealWorld_20240807183840.log,58,IERC20VaultGovernance,40395,1389,41784,91.0,0.229755,"// SPDX-License-Identifier: BSL-1.1
pragma solidity 0.8.9;

import ""../trader/interfaces/ITrader.sol"";
import ""./IVaultGovernance.sol"";

interface IERC20VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param trader Reference to internal Trader contract
    struct DelayedProtocolParams {
        ITrader trader;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",266
RealWorld_TA_58_IChiefTrader_RealWorld_20240807215105.log,58,IChiefTrader,33965,1830,35795,108.0,0.206425,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""../../interfaces/IProtocolGovernance.sol"";

interface IChiefTrader {
    /// @notice ProtocolGovernance
    /// @return the address of the protocol governance contract
    function protocolGovernance() external view returns (address);

    /// @notice Count of traders
    function tradersCount() external view returns (uint256);

    /// @notice Get the address of the trader at index
    /// @param _index The index of the trader
    function getTrader(uint256 _index) external view returns (address);

    /// @notice Get all registered traders
    function traders() external view returns (address[] memory);

    /// @notice Add new trader
    /// @param traderAddress the address of the trader
    function addTrader(address traderAddress) external;
}",179
RealWorld_TA_58_ProtocolGovernance_RealWorld_20240807205742.log,58,ProtocolGovernance,189240,4657,193897,177.0,1.03934,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./DefaultAccessControl.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all params common for Mellow Permissionless Vaults protocol.
contract ProtocolGovernance is IProtocolGovernance, DefaultAccessControl {
    using EnumerableSet for EnumerableSet.AddressSet;
    uint256 public constant MAX_GOVERNANCE_DELAY = 7 days;

    EnumerableSet.AddressSet private _claimAllowlist;
    address[] private _pendingClaimAllowlistAdd;
    uint256 public pendingClaimAllowlistAddTimestamp;

    address[] private _tokenWhitelist;
    address[] private _pendingTokenWhitelistAdd;
    uint256 private _numberOfValidTokens;
    mapping(address => bool) _tokensAllowed;
    mapping(address => bool) _tokenEverAdded;
    uint256 public pendingTokenWhitelistAddTimestamp;

    EnumerableSet.AddressSet private _vaultGovernances;
    address[] private _pendingVaultGovernancesAdd;
    uint256 public pendingVaultGovernancesAddTimestamp;

    IProtocolGovernance.Params public params;
    Params public pendingParams;

    uint256 public pendingParamsTimestamp;

    /// @notice Creates a new contract.
    /// @param admin Initial admin of the contract
    constructor(address admin) DefaultAccessControl(admin) {
        _tokenWhitelist = new address[](0);
        _numberOfValidTokens = 0;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IProtocolGovernance
    function claimAllowlist() external view returns (address[] memory) {
        uint256 l = _claimAllowlist.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _claimAllowlist.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function tokenWhitelist() external view returns (address[] memory) {
        uint256 l = _tokenWhitelist.length;
        address[] memory res = new address[](_numberOfValidTokens);
        uint256 j = 0;
        for (uint256 i = 0; i < l; i++) {
            if (!_tokensAllowed[_tokenWhitelist[i]] && _tokenEverAdded[_tokenWhitelist[i]]) {
                continue;
            }
            res[j] = _tokenWhitelist[i];
            j += 1;
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function vaultGovernances() external view returns (address[] memory) {
        uint256 l = _vaultGovernances.length();
        address[] memory res = new address[](l);
        for (uint256 i = 0; i < l; i++) {
            res[i] = _vaultGovernances.at(i);
        }
        return res;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingClaimAllowlistAdd() external view returns (address[] memory) {
        return _pendingClaimAllowlistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingTokenWhitelistAdd() external view returns (address[] memory) {
        return _pendingTokenWhitelistAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function pendingVaultGovernancesAdd() external view returns (address[] memory) {
        return _pendingVaultGovernancesAdd;
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToClaim(address addr) external view returns (bool) {
        return _claimAllowlist.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function isAllowedToken(address addr) external view returns (bool) {
        return _tokenEverAdded[addr] && _tokensAllowed[addr];
    }

    /// @inheritdoc IProtocolGovernance
    function isVaultGovernance(address addr) external view returns (bool) {
        return _vaultGovernances.contains(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function permissionless() external view returns (bool) {
        return params.permissionless;
    }

    /// @inheritdoc IProtocolGovernance
    function maxTokensPerVault() external view returns (uint256) {
        return params.maxTokensPerVault;
    }

    /// @inheritdoc IProtocolGovernance
    function governanceDelay() external view returns (uint256) {
        return params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function protocolTreasury() external view returns (address) {
        return params.protocolTreasury;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @inheritdoc IProtocolGovernance
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingClaimAllowlistAdd = addresses;
        pendingClaimAllowlistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromClaimAllowlist(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_claimAllowlist.contains(addr)) {
            return;
        }
        _claimAllowlist.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ""ADM"");
        _pendingTokenWhitelistAdd = addresses;
        pendingTokenWhitelistAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromTokenWhitelist(address addr) external {
        require(isAdmin(msg.sender), ""ADM"");
        _tokensAllowed[addr] = false;
        if (_tokenEverAdded[addr]) {
            --_numberOfValidTokens;
        }
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        _pendingVaultGovernancesAdd = addresses;
        pendingVaultGovernancesAddTimestamp = block.timestamp + params.governanceDelay;
    }

    /// @inheritdoc IProtocolGovernance
    function removeFromVaultGovernances(address addr) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        if (!_vaultGovernances.contains(addr)) {
            return;
        }
        _vaultGovernances.remove(addr);
    }

    /// @inheritdoc IProtocolGovernance
    function setPendingParams(IProtocolGovernance.Params memory newParams) external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(params.governanceDelay <= MAX_GOVERNANCE_DELAY, ExceptionsLibrary.MAX_GOVERNANCE_DELAY);
        pendingParams = newParams;
        pendingParamsTimestamp = block.timestamp + params.governanceDelay;
    }

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @inheritdoc IProtocolGovernance
    function commitClaimAllowlistAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingClaimAllowlistAddTimestamp) && (pendingClaimAllowlistAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingClaimAllowlistAdd.length; i++) {
            _claimAllowlist.add(_pendingClaimAllowlistAdd[i]);
        }
        delete _pendingClaimAllowlistAdd;
        delete pendingClaimAllowlistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitTokenWhitelistAdd() external {
        require(isAdmin(msg.sender), ""ADM"");
        require(
            (block.timestamp >= pendingTokenWhitelistAddTimestamp) && (pendingTokenWhitelistAddTimestamp > 0),
            ""TS""
        );
        for (uint256 i = 0; i < _pendingTokenWhitelistAdd.length; i++) {
            if (!_tokenEverAdded[_pendingTokenWhitelistAdd[i]]) {
                _numberOfValidTokens += 1;
                _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                _tokenWhitelist.push(_pendingTokenWhitelistAdd[i]);
                _tokenEverAdded[_pendingTokenWhitelistAdd[i]] = true;
            } else {
                if (!_tokensAllowed[_pendingTokenWhitelistAdd[i]]) {
                    _numberOfValidTokens += 1;
                    _tokensAllowed[_pendingTokenWhitelistAdd[i]] = true;
                }
            }
        }
        delete _pendingTokenWhitelistAdd;
        delete pendingTokenWhitelistAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitVaultGovernancesAdd() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(
            (block.timestamp >= pendingVaultGovernancesAddTimestamp) && (pendingVaultGovernancesAddTimestamp > 0),
            ExceptionsLibrary.TIMESTAMP
        );
        for (uint256 i = 0; i < _pendingVaultGovernancesAdd.length; i++) {
            _vaultGovernances.add(_pendingVaultGovernancesAdd[i]);
        }
        delete _pendingVaultGovernancesAdd;
        delete pendingVaultGovernancesAddTimestamp;
    }

    /// @inheritdoc IProtocolGovernance
    function commitParams() external {
        require(isAdmin(msg.sender), ExceptionsLibrary.ADMIN);
        require(block.timestamp >= pendingParamsTimestamp, ExceptionsLibrary.TIMESTAMP);
        require(pendingParams.maxTokensPerVault > 0 || pendingParams.governanceDelay > 0, ExceptionsLibrary.EMPTY_PARAMS); // sanity check for empty params
        params = pendingParams;
        delete pendingParams;
        delete pendingParamsTimestamp;
    }
}",2027
RealWorld_TA_58_Vault_RealWorld_20240807170257.log,58,Vault,233500,5024,238524,158.0,1.26798,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Abstract contract that has logic common for every Vault.
/// @dev Notes:
/// ### ERC-721
///
/// Each Vault should be registered in VaultRegistry and get corresponding VaultRegistry NFT.
///
/// ### Access control
///
/// `push` and `pull` methods are only allowed for owner / approved person of the NFT. However,
/// `pull` for approved person also checks that pull destination is another vault of the Vault System.
///
/// The semantics is: NFT owner owns all Vault liquidity, Approved person is liquidity manager.
/// ApprovedForAll person cannot do anything except ERC-721 token transfers.
///
/// Both NFT owner and approved person can call claimRewards method which claims liquidity mining rewards (if any)
///
/// `reclaimTokens` for mistakenly transfered tokens (not included into vaultTokens) additionally can be withdrawn by
/// the protocol admin
abstract contract Vault is IVault, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 internal _nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this Vault
    /// @param vaultTokens_ ERC20 tokens that will be managed by this Vault
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            _vaultTokensIndex[vaultTokens_[i]] = true;
        }
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVault
    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    /// @inheritdoc IVault
    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    /// @inheritdoc IVault
    function tvl() public view virtual returns (uint256[] memory tokenAmounts);

    /// @inheritdoc IVault
    function nft() external view returns (uint256) {
        return _nft;
    }

    // -------------------  PUBLIC, MUTATING, VaultGovernance  -------------------

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED  -------------------

    /// @inheritdoc IVault
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) public nonReentrant returns (uint256[] memory actualTokenAmounts) {
        uint256 nft_ = _nft;
        require(nft_ > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER); // Also checks that the token exists
        IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry;
        IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_));
        uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault));
        require(ownerNft > 0, ExceptionsLibrary.OWNER_VAULT_NFT); // require deposits only through Vault
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _push(pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Push(pActualTokenAmounts);
    }

    /// @inheritdoc IVault
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts) {
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokenAmounts[i] > 0) {
                IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmounts[i]);
            }
        }
        actualTokenAmounts = push(tokens, tokenAmounts, options);
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 leftover = actualTokenAmounts[i] < tokenAmounts[i] ? tokenAmounts[i] - actualTokenAmounts[i] : 0;
            if (leftover > 0) {
                IERC20(tokens[i]).safeTransfer(from, leftover);
            }
        }
    }

    /// @inheritdoc IVault
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external nonReentrant returns (uint256[] memory actualTokenAmounts) {
        require(_isApprovedOrOwner(msg.sender), ""IO""); // Also checks that the token exists
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION); // approved can only pull to whitelisted contracts
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _pull(to, pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Pull(to, actualTokenAmounts);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED OR PROTOCOL ADMIN -------------------
    /// @inheritdoc IVault
    function reclaimTokens(address to, address[] memory tokens) external nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance governance = _vaultGovernance.internalParams().protocolGovernance;
        bool isProtocolAdmin = governance.isAdmin(msg.sender);
        require(isProtocolAdmin || _isApprovedOrOwner(msg.sender), ExceptionsLibrary.ADMIN);
        if (!isProtocolAdmin) {
            require(_isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        }
        uint256[] memory tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = IERC20(tokens[i]);
            tokenAmounts[i] = token.balanceOf(address(this));
            if (tokenAmounts[i] == 0) {
                continue;
            }
            token.safeTransfer(to, tokenAmounts[i]);
        }
        _postReclaimTokens(to, tokens);
        emit ReclaimTokens(to, tokens, tokenAmounts);
    }

    /// @inheritdoc IVault
    function claimRewards(address from, bytes memory data) external override nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IProtocolGovernance protocolGovernance = _vaultGovernance.internalParams().protocolGovernance;
        require(protocolGovernance.isAllowedToClaim(from), ExceptionsLibrary.ALLOWED_TO_CLAIM);
        (bool res, bytes memory returndata) = from.call(data);
        if (!res) {
            assembly {
                let returndata_size := mload(returndata)
                // Bubble up revert reason
                revert(add(32, returndata), returndata_size)
            }
        }
    }

    // -------------------  PUBLIC, VIEW   -------------------\

    function isVaultToken(address token) public view returns (bool) {
        return _vaultTokensIndex[token];
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _validateAndProjectTokens(address[] memory tokens, uint256[] memory tokenAmounts)
        internal
        view
        returns (uint256[] memory pTokenAmounts)
    {
        require(CommonLibrary.isSortedAndUnique(tokens), ExceptionsLibrary.SORTED_AND_UNIQUE);
        require(tokens.length == tokenAmounts.length, ExceptionsLibrary.INCONSISTENT_LENGTH);
        pTokenAmounts = CommonLibrary.projectTokenAmounts(_vaultTokens, tokens, tokenAmounts);
    }

    /// The idea is to check that `this` Vault and `to` Vault
    /// nfts are owned by the same address. Then check that nft for this address
    /// exists in registry as Vault => it's one of the vaults with trusted interface.
    /// Then check that both `this` and `to` are registered in the nft owner using hasSubvault function.
    /// Since only gateway vault has hasSubvault function this will prove correctly that
    /// the vaults belong to the same vault system.
    function _isValidPullDestination(address to) internal view returns (bool) {
        if (!CommonLibrary.isContract(to)) {
            return false;
        }
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        // make sure that this vault is a registered vault
        if (_nft == 0) {
            return false;
        }
        address thisOwner = registry.ownerOf(_nft);
        // make sure that vault has a registered owner
        uint256 thisOwnerNft = registry.nftForVault(thisOwner);
        if (thisOwnerNft == 0) {
            return false;
        }
        IGatewayVault gw = IGatewayVault(thisOwner);
        if (!gw.hasSubvault(address(this)) || !gw.hasSubvault(to)) {
            return false;
        }
        return true;
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _isApprovedOrOwner(address sender) internal view returns (bool) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 nft_ = _nft;
        if (nft_ == 0) {
            return false;
        }
        return registry.getApproved(nft_) == sender || registry.ownerOf(nft_) == sender;
    }

    // -------------------  PRIVATE, MUTATING  -------------------

    /// Guaranteed to have exact signature matchinn vault tokens
    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        virtual
        returns (uint256[] memory actualTokenAmounts);

    /// Guaranteed to have exact signature matchinn vault tokens
    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal virtual returns (uint256[] memory actualTokenAmounts);

    function _postReclaimTokens(address to, address[] memory tokens) internal virtual {}

    /// @notice Emitted on successful push
    /// @param tokenAmounts The amounts of tokens to pushed
    event Push(uint256[] tokenAmounts);

    /// @notice Emitted on successful pull
    /// @param to The target address for pulled tokens
    /// @param tokenAmounts The amounts of tokens to pull
    event Pull(address to, uint256[] tokenAmounts);

    /// @notice Emitted when tokens are reclaimed
    /// @param to The target address for pulled tokens
    /// @param tokens ERC20 tokens to be reclaimed
    /// @param tokenAmounts The amounts of reclaims
    event ReclaimTokens(address to, address[] tokens, uint256[] tokenAmounts);
}",2627
RealWorld_TA_58_IYearnVaultRegistry_RealWorld_20240807194043.log,58,IYearnVaultRegistry,21778,1592,23370,102.0,0.14073,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

interface IYearnVaultRegistry {
    function latestVault(address vault) external view returns (address);
}",37
RealWorld_TA_58_ILpIssuer_RealWorld_20240807193336.log,58,ILpIssuer,44648,2319,46967,103.0,0.26962,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVault.sol"";

interface ILpIssuer {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Nft of the underlying vault.
    function subvaultNft() external view returns (uint256);

    /// @notice Adds subvault nft to the vault.
    /// @dev Can be called only once.
    /// @param nft Subvault nft to add
    function addSubvault(uint256 nft) external;

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Deposit tokens into LpIssuer
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external;

    /// @notice Withdraw tokens from LpIssuer
    /// @param to Address to withdraw to
    /// @param lpTokenAmount Amount of token to withdraw
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param.
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external;
}",323
RealWorld_TA_58_IVault_RealWorld_20240807183504.log,58,IVault,120958,3003,123961,119.0,0.66485,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";

interface IVault {
    /// @notice VaultRegistry NFT for this vault
    function nft() external view returns (uint256);

    /// @notice Address of the Vault Governance for this contract.
    function vaultGovernance() external view returns (IVaultGovernance);

    /// @notice ERC20 tokens under Vault management.
    function vaultTokens() external view returns (address[] memory);

    /// @notice Total value locked for this contract.
    /// @dev Generally it is the underlying token value of this contract in some
    /// other DeFi protocol. For example, for USDC Yearn Vault this would be total USDC balance that could be withdrawn for Yearn to this contract.
    /// @return tokenAmounts Total available balances for multiple tokens (nth tokenAmount corresponds to nth token in vaultTokens)
    function tvl() external view returns (uint256[] memory tokenAmounts);

    /// @notice Initialize contract with vault nft
    /// @param nft VaultRegistry NFT for this vault
    function initialize(uint256 nft) external;

    /// @notice Pushes tokens on the vault balance to the underlying protocol. For example, for Yearn this operation will take USDC from
    /// the contract balance and convert it to yUSDC.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice The same as `push` method above but transfers tokens to vault balance prior to calling push.
    /// After the `push` it returns all the leftover tokens back (`push` method doesn't guarantee that tokenAmounts will be invested in full).
    /// @param tokens Tokens to push
    /// @param tokenAmounts Amounts of tokens to push
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually invested. It could be less than tokenAmounts (but not higher)
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice Pulls tokens from the underlying protocol to the `to` address.
    /// For example, for Yearn this operation will take yUSDC from
    /// the Yearn protocol, convert it to USDC and send to `to` address.
    /// @dev Can only be called but Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT. There's a subtle difference however - while vault owner
    /// can pull the tokens to any address, Strategy can only pull to other vault in the Vault System (a set of vaults united by the Gateway Vault)
    ///
    /// Tokens **must** be a subset of Vault Tokens. However, the convention is that if tokenAmount == 0 it is the same as token is missing.
    ///
    /// Also notice that this operation doesn't guarantee that tokenAmounts will be invested in full.
    /// @param to Address to receive the tokens
    /// @param tokens Tokens to pull
    /// @param tokenAmounts Amounts of tokens to pull
    /// @param options Additional options that could be needed for some vaults. E.g. for Uniswap this could be `deadline` param. For the exact bytes structure see concrete vault descriptions
    /// @return actualTokenAmounts The amounts actually withdrawn. It could be less than tokenAmounts (but not higher)
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts);

    /// @notice This method is for claiming accidentally accumulated tokens on the contact's balance.
    /// @dev Can only be called by Protocol Governance.
    /// @param to Address that will receive the tokens
    /// @param tokens Tokens to claim. Each token must be other than those in vaultTokens
    function reclaimTokens(address to, address[] memory tokens) external;

    /// @notice Claim liquidity mining rewards.
    /// @dev Can only be called by Vault Owner or Strategy. Vault owner is the owner of NFT for this vault in VaultManager.
    /// Strategy is approved address for the vault NFT.
    ///
    /// Since this method allows sending arbitrary transactions, the destinations of the calls
    /// are whitelisted by Protocol Governance.
    /// @param from Address of the reward pool
    /// @param data Abi encoded call to the `from` address
    function claimRewards(address from, bytes memory data) external;

    function isVaultToken(address token) external view returns (bool);
}",1252
RealWorld_TA_58_ILendingPool_RealWorld_20240807185355.log,58,ILendingPool,349833,2571,352404,141.0,1.800585,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3997
RealWorld_TA_58_IVaultFactory_RealWorld_20240807192324.log,58,IVaultFactory,26557,1604,28161,182.0,0.164865,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";
import ""./IVault.sol"";

interface IVaultFactory {
    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault vault);
}",96
RealWorld_TA_58_YearnVaultGovernance_RealWorld_20240807163309.log,58,YearnVaultGovernance,91974,3356,95330,121.0,0.52699,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Aave Vaults params and can deploy a new Aave Vault.
contract YearnVaultGovernance is IYearnVaultGovernance, VaultGovernance {
    mapping(address => address) private _yTokens;

    /// @notice Creates a new contract
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
    }

    /// @inheritdoc IYearnVaultGovernance
    function yTokenForToken(address token) external view returns (address) {
        address yToken = _yTokens[token];
        if (yToken != address(0)) {
            return yToken;
        }
        IYearnVaultRegistry yearnRegistry = delayedProtocolParams().yearnVaultRegistry;
        try yearnRegistry.latestVault(token) returns (address _vault) {
            return _vault;
        } catch (bytes memory) {
            return address(0);
        }
    }

    /// @inheritdoc IYearnVaultGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({yearnVaultRegistry: IYearnVaultRegistry(address(0))});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc IYearnVaultGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc IYearnVaultGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @inheritdoc IYearnVaultGovernance
    function setYTokenForToken(address token, address yToken) external {
        _requireProtocolAdmin();
        _yTokens[token] = yToken;
        emit SetYToken(tx.origin, msg.sender, token, yToken);
    }

    /// @notice Emitted when new yToken is set
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param token ERC-20 token for the yToken
    /// @param yToken yToken for ERC-20 token
    event SetYToken(address indexed origin, address indexed sender, address indexed token, address yToken);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",862
RealWorld_TA_58_UniV3VaultTestFactory_RealWorld_20240807210302.log,58,UniV3VaultTestFactory,36608,2372,38980,119.0,0.23048,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./UniV3VaultTest.sol"";

contract UniV3VaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        uint256 fee = abi.decode(options, (uint256));
        UniV3VaultTest vault = new UniV3VaultTest(vaultGovernance, vaultTokens, uint24(fee));
        return IVault(vault);
    }
}",209
RealWorld_TA_58_IYearnVaultGovernance_RealWorld_20240807221312.log,58,IYearnVaultGovernance,52912,2350,55262,115.0,0.31156,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./external/yearn/IYearnVaultRegistry.sol"";
import ""./IVaultGovernance.sol"";

interface IYearnVaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param yearnVaultRegistry Reference to Yearn Vault Registry
    struct DelayedProtocolParams {
        IYearnVaultRegistry yearnVaultRegistry;
    }

    /// @notice Determines a corresponding Yearn vault for token
    /// @param token ERC-20 token for the yToken
    /// @return If there's a yToken returns its address, otherwise returns 0
    function yTokenForToken(address token) external view returns (address);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;

    /// @notice Sets the manual override for yToken vaults map
    /// @dev Can only be called by Protocol Admin
    /// @param token ERC-20 token for yToken
    /// @param yToken for ERC-20 token
    function setYTokenForToken(address token, address yToken) external;
}",401
RealWorld_TA_58_IERC20VaultGovernance_RealWorld_20240807222114.log,58,IERC20VaultGovernance,40797,1526,42323,228.0,0.234505,"// SPDX-License-Identifier: BSL-1.1
pragma solidity 0.8.9;

import ""../trader/interfaces/ITrader.sol"";
import ""./IVaultGovernance.sol"";

interface IERC20VaultGovernance is IVaultGovernance {
    /// @notice Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @param trader Reference to internal Trader contract
    struct DelayedProtocolParams {
        ITrader trader;
    }

    /// @notice Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function delayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Delayed Protocol Params staged for commit after delay.
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory);

    /// @notice Stage Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    /// @dev Can only be called after delayedProtocolParamsTimestamp.
    /// @param params New params
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external;

    /// @notice Commit Delayed Protocol Params, i.e. Params that could be changed by Protocol Governance with Protocol Governance delay.
    function commitDelayedProtocolParams() external;
}",266
RealWorld_TA_58_TestVaultGovernance_RealWorld_20240807212843.log,58,TestVaultGovernance,57848,2407,60255,122.0,0.33738,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../VaultGovernance.sol"";

contract TestVaultGovernance is VaultGovernance {
    constructor(InternalParams memory internalParams_) VaultGovernance(internalParams_) {}

    function stageDelayedStrategyParams(uint256 nft, bytes memory params) public {
        _stageDelayedStrategyParams(nft, params);
    }

    function stageDelayedProtocolParams(bytes memory params) public {
        _stageDelayedProtocolParams(params);
    }

    function getStagedDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _stagedDelayedStrategyParams[nft];
    }

    function getStagedDelayedProtocolParams() public view returns (bytes memory) {
        return _stagedDelayedProtocolParams;
    }

    function getDelayedStrategyParamsTimestamp(uint256 nft) public view returns (uint256) {
        return _delayedStrategyParamsTimestamp[nft];
    }

    function getDelayedProtocolParamsTimestamp() public view returns (uint256) {
        return _delayedProtocolParamsTimestamp;
    }

    function getDelayedStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _delayedStrategyParams[nft];
    }

    function getDelayedProtocolParams() public view returns (bytes memory) {
        return _delayedProtocolParams;
    }

    function commitDelayedStrategyParams(uint256 nft) public {
        _commitDelayedStrategyParams(nft);
    }

    function commitDelayedProtocolParams() public {
        _commitDelayedProtocolParams();
    }

    function setStrategyParams(uint256 nft, bytes memory params) public {
        _setStrategyParams(nft, params);
    }

    function setProtocolParams(bytes memory params) public {
        _setProtocolParams(params);
    }

    function getStrategyParams(uint256 nft) public view returns (bytes memory) {
        return _strategyParams[nft];
    }

    function getProtocolParams() public view returns (bytes memory) {
        return _protocolParams;
    }

    function requireProtocolAdmin() public view {
        _requireProtocolAdmin();
    }

    function requireAtLeastStrategy(uint256 nft) public view {
        _requireAtLeastStrategy(nft);
    }
}",467
RealWorld_TA_58_IUniswapV3Factory_RealWorld_20240807185951.log,58,IUniswapV3Factory,97841,2035,99876,110.0,0.529905,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity =0.8.9;

/// @title The interface for the Uniswap V3 Factory
/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(
        address indexed token0,
        address indexed token1,
        uint24 indexed fee,
        int24 tickSpacing,
        address pool
    );

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",939
RealWorld_TA_58_IDefaultAccessControl_RealWorld_20240807191342.log,58,IDefaultAccessControl,26451,1679,28130,110.0,0.165835,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/access/IAccessControlEnumerable.sol"";

interface IDefaultAccessControl is IAccessControlEnumerable {
    /// @notice Checks that the address is contract admin.
    /// @param who Address to check
    /// @return `true` if who is admin, `false` otherwise
    function isAdmin(address who) external view returns (bool);
}",93
RealWorld_TA_58_LpIssuer_RealWorld_20240807201748.log,58,LpIssuer,318665,5765,324430,197.0,1.708625,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./DefaultAccessControl.sol"";
import ""./LpIssuerGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Contract that mints and burns LP tokens in exchange for ERC20 liquidity.
contract LpIssuer is IERC721Receiver, ILpIssuer, ERC20, ReentrancyGuard {
    using SafeERC20 for IERC20;
    uint256 private _subvaultNft;
    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 private _nft;
    uint256[] private _lpPriceHighWaterMarks;
    uint256[] private _existentials;

    uint256 public lastFeeCharge;

    /// @notice Creates a new contract.
    /// @dev All subvault nfts must be owned by this vault before.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    /// @param name_ Name of the ERC-721 token
    /// @param symbol_ Symbol of the ERC-721 token
    constructor(
        IVaultGovernance vaultGovernance_,
        address[] memory vaultTokens_,
        string memory name_,
        string memory symbol_
    ) ERC20(name_, symbol_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            address token = vaultTokens_[i];
            _vaultTokensIndex[token] = true;
            _lpPriceHighWaterMarks.push(0);
            _existentials.push(10**(ERC20(token).decimals() / 2));
        }
        lastFeeCharge = block.timestamp;
    }

    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    function existentials() external view returns (uint256[] memory) {
        return _existentials;
    }

    /// @inheritdoc ILpIssuer
    function subvaultNft() external view returns (uint256) {
        return _subvaultNft;
    }

    function nft() external view returns (uint256) {
        return _nft;
    }

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_> 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    /// @inheritdoc ILpIssuer
    function deposit(uint256[] calldata tokenAmounts, bytes memory options) external nonReentrant {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 thisNft = _nft;
        require(thisNft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_subvaultNft > 0, ExceptionsLibrary.INITIALIZE_SUB_VAULT);
        require(registry.ownerOf(thisNft) == address(this), ExceptionsLibrary.INITIALIZE_OWNER);
        IVault subvault = _subvault();
        uint256[] memory existentials_ = _existentials;
        uint256[] memory tvl = subvault.tvl(); //pre-money
        uint256 supply = totalSupply();
        uint256 balanceFactor = CommonLibrary.PRICE_DENOMINATOR;
        if (supply > 0) {
            // This is lpTokens if total supply == CommonLibrary.PRICE_DENOMINATOR
            balanceFactor = _getLpAmount(tvl, tokenAmounts, existentials_, CommonLibrary.PRICE_DENOMINATOR);
        }

        // If with that big supply we don't reveive any lps then it doesn't make sense to continue
        require(balanceFactor > 0, ""BF"");
        uint256[] memory balancedAmounts = new uint256[](tokenAmounts.length);

        // Making sure the proportion between tokenAmounts and tvl are the same
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            balancedAmounts[i] = _getBalancedAmount(tvl[i], tokenAmounts[i], existentials_[i], balanceFactor, supply);
            _allowTokenIfNecessary(_vaultTokens[i], address(subvault));
            IERC20(_vaultTokens[i]).safeTransferFrom(msg.sender, address(this), balancedAmounts[i]);
        }

        uint256[] memory actualTokenAmounts = subvault.transferAndPush(
            address(this),
            _vaultTokens,
            balancedAmounts,
            options
        );
        uint256 amountToMint = _getLpAmount(tvl, actualTokenAmounts, existentials_, supply);

        require(amountToMint > 0, ""ZLP"");

        require(
            amountToMint + balanceOf(msg.sender) <=
                ILpIssuerGovernance(address(_vaultGovernance)).strategyParams(thisNft).tokenLimitPerAddress,
            ExceptionsLibrary.LIMIT_PER_ADDRESS
        );

        _chargeFees(thisNft, tvl, supply, actualTokenAmounts, amountToMint, false);
        _mint(msg.sender, amountToMint);

        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (balancedAmounts[i] > actualTokenAmounts[i]) {
                IERC20(_vaultTokens[i]).safeTransfer(msg.sender, balancedAmounts[i] - actualTokenAmounts[i]);
            }
        }

        emit Deposit(msg.sender, _vaultTokens, actualTokenAmounts, amountToMint);
    }

    /// @inheritdoc ILpIssuer
    function withdraw(
        address to,
        uint256 lpTokenAmount,
        bytes memory options
    ) external nonReentrant {
        uint256 supply = totalSupply();
        require(supply > 0, ExceptionsLibrary.TOTAL_SUPPLY_IS_ZERO);
        uint256[] memory tokenAmounts = new uint256[](_vaultTokens.length);
        uint256[] memory tvl = _subvault().tvl();
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            tokenAmounts[i] = (lpTokenAmount * tvl[i]) / supply;
        }
        uint256[] memory actualTokenAmounts = _subvault().pull(address(this), _vaultTokens, tokenAmounts, options);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            if (actualTokenAmounts[i] == 0) {
                continue;
            }
            IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);
        }
        _chargeFees(_nft, tvl, supply, actualTokenAmounts, lpTokenAmount, true);
        _burn(msg.sender, lpTokenAmount);
        emit Withdraw(msg.sender, _vaultTokens, actualTokenAmounts, lpTokenAmount);
    }

    /// @inheritdoc ILpIssuer
    function addSubvault(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(_subvaultNft == 0, ExceptionsLibrary.SUB_VAULT_INITIALIZED);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        _subvaultNft = nft_;
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external nonReentrant returns (bytes4) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        registry.lockNft(tokenId);
        return this.onERC721Received.selector;
    }

    function _allowTokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(address(to), address(this)) < type(uint256).max / 2) {
            IERC20(token).approve(address(to), type(uint256).max);
        }
    }

    function _subvault() internal view returns (IVault) {
        return IVault(_vaultGovernance.internalParams().registry.vaultForNft(_subvaultNft));
    }

    /// @dev We don't charge on any deposit / withdraw to save gas.
    /// While this introduce some error, the charge always goes for lower lp token supply (pre-deposit / post-withdraw)
    /// So the error results in slightly lower management fees than in exact case
    function _chargeFees(
        uint256 thisNft,
        uint256[] memory tvls,
        uint256 supply,
        uint256[] memory deltaTvls,
        uint256 deltaSupply,
        bool isWithdraw
    ) internal {
        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));
        uint256 elapsed = block.timestamp - lastFeeCharge;
        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {
            return;
        }
        lastFeeCharge = block.timestamp;
        uint256 baseSupply = supply;
        if (isWithdraw) {
            baseSupply = 0;
            if (supply > deltaSupply) {
                baseSupply = supply - deltaSupply;
            }
        }

        if (baseSupply == 0) {
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;
            }
            return;
        }

        uint256[] memory baseTvls = new uint256[](tvls.length);
        for (uint256 i = 0; i < baseTvls.length; i++) {
            if (isWithdraw) {
                baseTvls[i] = tvls[i] - deltaTvls[i];
            } else {
                baseTvls[i] = tvls[i];
            }
        }

        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);
        if (strategyParams.managementFee > 0) {
            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /
                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(strategyParams.strategyTreasury, toMint);
            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);
        }
        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;
        if (protocolFee > 0) {
            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();
            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);
            _mint(treasury, toMint);
            emit ProtocolFeesCharged(treasury, protocolFee, toMint);
        }
        uint256 performanceFee = strategyParams.performanceFee;
        uint256[] memory hwms = _lpPriceHighWaterMarks;
        if (performanceFee > 0) {
            uint256 minLpPriceFactor = type(uint256).max;
            for (uint256 i = 0; i < baseTvls.length; i++) {
                uint256 hwm = hwms[i];
                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;
                if (lpPrice > hwm) {
                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;
                    if (delta < minLpPriceFactor) {
                        minLpPriceFactor = delta;
                    }
                } else {
                    // not eligible for performance fees
                    return;
                }
            }
            for (uint256 i = 0; i < tvls.length; i++) {
                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            }
            address treasury = strategyParams.strategyPerformanceTreasury;
            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;
            _mint(treasury, toMint);
            emit PerformanceFeesCharged(treasury, performanceFee, toMint);
        }
    }

    function _getLpAmount(
        uint256[] memory tvl,
        uint256[] memory amounts,
        uint256[] memory existentials_,
        uint256 supply
    ) internal pure returns (uint256 lpAmount) {
        lpAmount = 0;
        if (supply == 0) {
            // On init lpToken = max(tokenAmounts)
            for (uint256 i = 0; i < tvl.length; i++) {
                if (amounts[i] > lpAmount) {
                    lpAmount = amounts[i];
                }
            }
            return lpAmount;
        }
        for (uint256 i = 0; i < tvl.length; i++) {
            if (amounts[i] <= existentials_[i]) {
                // skip existential deposits for lp share calculation
                continue;
            }
            uint256 tokenLpAmount = (amounts[i] * supply) / tvl[i];
            // take min of meaningful tokenLp amounts
            if ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {
                lpAmount = tokenLpAmount;
            }
        }
    }

    function _getBalancedAmount(
        uint256 tvl,
        uint256 amount,
        uint256 existential,
        uint256 balanceFactor,
        uint256 supply
    ) internal pure returns (uint256) {
        if (supply == 0) {
            // skip normalization on init
            return amount;
        }
        if (amount < existential) {
            // avoid putting small amounts as it can introduce unnecessary harsh errors
            // one should provide amount > existential deposit each time tvl is not 0
            require(tvl == 0, ""PN"");
            return 0;
        }
        // normalize amount
        uint256 res = (tvl * balanceFactor) / CommonLibrary.PRICE_DENOMINATOR;
        if (res > amount) {
            res = amount;
        }
        return res;
    }

    /// @notice Emitted when management fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ManagementFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when protocol fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event ProtocolFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when performance fees are charged
    /// @param treasury Treasury receiver of the fee
    /// @param feeRate Fee percent applied denominated in 10 ** 9
    /// @param amount Amount of lp token minted
    event PerformanceFeesCharged(address indexed treasury, uint256 feeRate, uint256 amount);

    /// @notice Emitted when liquidity is deposited
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens deposited
    /// @param actualTokenAmounts Token amounts deposited
    /// @param lpTokenMinted LP tokens received by the liquidity provider
    event Deposit(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenMinted);

    /// @notice Emitted when liquidity is withdrawn
    /// @param from The source address for the liquidity
    /// @param tokens ERC20 tokens withdrawn
    /// @param actualTokenAmounts Token amounts withdrawn
    /// @param lpTokenBurned LP tokens burned from the liquidity provider
    event Withdraw(address indexed from, address[] tokens, uint256[] actualTokenAmounts, uint256 lpTokenBurned);
}",3633
RealWorld_TA_58_ILendingPool_RealWorld_20240807194228.log,58,ILendingPool,349830,3027,352857,162.0,1.80969,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3997
RealWorld_TA_58_GatewayVaultTestFactory_RealWorld_20240807172710.log,58,GatewayVaultTestFactory,34807,3242,38049,122.0,0.238875,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""../interfaces/IVaultFactory.sol"";
import ""../interfaces/IVaultGovernance.sol"";
import ""./GatewayVaultTest.sol"";

contract GatewayVaultTestFactory is IVaultFactory {
    IVaultGovernance public vaultGovernance;

    constructor(IVaultGovernance vaultGovernance_) {
        vaultGovernance = vaultGovernance_;
    }

    function setVaultGovernance(address newVaultGovernance) public {
        vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function deployVault(address[] memory vaultTokens, bytes memory) external returns (IVault) {
        require(msg.sender == address(vaultGovernance), ""VG"");
        GatewayVaultTest gatewayVault = new GatewayVaultTest(vaultGovernance, vaultTokens);
        return IVault(gatewayVault);
    }
}",184
RealWorld_TA_58_IUniswapV3Pool_RealWorld_20240807195154.log,58,IUniswapV3Pool,29864,1452,31316,97.0,0.17836,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

import './pool/IUniswapV3PoolImmutables.sol';
import './pool/IUniswapV3PoolState.sol';

/// @title The interface for a Uniswap V3 Pool
/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
/// to the ERC20 specification
/// @dev The pool interface is broken up into many smaller pieces
interface IUniswapV3Pool is
    IUniswapV3PoolImmutables,
    IUniswapV3PoolState
{

}",142
RealWorld_TA_58_IUniswapV3PoolImmutables_RealWorld_20240807225728.log,58,IUniswapV3PoolImmutables,54671,1205,55876,99.0,0.297455,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.5.0;

/// @title Pool state that never changes
/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
interface IUniswapV3PoolImmutables {
    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
    /// @return The contract address
    function factory() external view returns (address);

    /// @notice The first of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token0() external view returns (address);

    /// @notice The second of the two tokens of the pool, sorted by address
    /// @return The token contract address
    function token1() external view returns (address);

    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
    /// @return The fee
    function fee() external view returns (uint24);

    /// @notice The pool tick spacing
    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
    /// This value is an int24 to avoid casting even though it is always positive.
    /// @return The tick spacing
    function tickSpacing() external view returns (int24);

    /// @notice The maximum amount of position liquidity that can use any tick in the range
    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
    /// @return The max amount of liquidity per tick
    function maxLiquidityPerTick() external view returns (uint128);
}",435
RealWorld_TA_58_Trader_RealWorld_20240807214407.log,58,Trader,33374,1743,35117,111.0,0.20173,"// SPDX-License-Identifier: BSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./interfaces/ITrader.sol"";

/// @notice Base contract for every trader contract (a contract that can execute ERC20 swaps)
abstract contract Trader is ERC165 {
    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return (interfaceId == this.supportsInterface.selector || interfaceId == type(ITrader).interfaceId);
    }

    function _approveERC20TokenIfNecessary(address token, address to) internal {
        if (IERC20(token).allowance(to, address(this)) < type(uint256).max / 2)
            IERC20(token).approve(to, type(uint256).max);
    }
}",192
RealWorld_TA_58_Vault_RealWorld_20240807203101.log,58,Vault,235077,6319,241396,233.0,1.301765,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/IGatewayVault.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./interfaces/IVault.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Abstract contract that has logic common for every Vault.
/// @dev Notes:
/// ### ERC-721
///
/// Each Vault should be registered in VaultRegistry and get corresponding VaultRegistry NFT.
///
/// ### Access control
///
/// `push` and `pull` methods are only allowed for owner / approved person of the NFT. However,
/// `pull` for approved person also checks that pull destination is another vault of the Vault System.
///
/// The semantics is: NFT owner owns all Vault liquidity, Approved person is liquidity manager.
/// ApprovedForAll person cannot do anything except ERC-721 token transfers.
///
/// Both NFT owner and approved person can call claimRewards method which claims liquidity mining rewards (if any)
///
/// `reclaimTokens` for mistakenly transfered tokens (not included into vaultTokens) additionally can be withdrawn by
/// the protocol admin
abstract contract Vault is IVault, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IVaultGovernance internal _vaultGovernance;
    address[] internal _vaultTokens;
    mapping(address => bool) internal _vaultTokensIndex;
    uint256 internal _nft;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance of this Vault
    /// @param vaultTokens_ ERC20 tokens that will be managed by this Vault
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_) {
        require(CommonLibrary.isSortedAndUnique(vaultTokens_), ExceptionsLibrary.SORTED_AND_UNIQUE);
        _vaultGovernance = vaultGovernance_;
        _vaultTokens = vaultTokens_;
        for (uint256 i = 0; i < vaultTokens_.length; i++) {
            _vaultTokensIndex[vaultTokens_[i]] = true;
        }
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @inheritdoc IVault
    function vaultGovernance() external view returns (IVaultGovernance) {
        return _vaultGovernance;
    }

    /// @inheritdoc IVault
    function vaultTokens() external view returns (address[] memory) {
        return _vaultTokens;
    }

    /// @inheritdoc IVault
    function tvl() public view virtual returns (uint256[] memory tokenAmounts);

    /// @inheritdoc IVault
    function nft() external view returns (uint256) {
        return _nft;
    }

    // -------------------  PUBLIC, MUTATING, VaultGovernance  -------------------

    function initialize(uint256 nft_) external {
        require(msg.sender == address(_vaultGovernance), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        require(nft_ > 0, ExceptionsLibrary.NFT_ZERO);
        require(_nft == 0, ExceptionsLibrary.INITIALIZATION);
        _nft = nft_;
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        registry.setApprovalForAll(address(registry), true);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED  -------------------

    /// @inheritdoc IVault
    function push(
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) public nonReentrant returns (uint256[] memory actualTokenAmounts) {
        uint256 nft_ = _nft;
        require(nft_ > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER); // Also checks that the token exists
        IVaultRegistry vaultRegistry = _vaultGovernance.internalParams().registry;
        IVault ownerVault = IVault(vaultRegistry.ownerOf(nft_));
        uint256 ownerNft = vaultRegistry.nftForVault(address(ownerVault));
        require(ownerNft > 0, ExceptionsLibrary.OWNER_VAULT_NFT); // require deposits only through Vault
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _push(pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Push(pActualTokenAmounts);
    }

    /// @inheritdoc IVault
    function transferAndPush(
        address from,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external returns (uint256[] memory actualTokenAmounts) {
        for (uint256 i = 0; i < tokens.length; i++) {
            if (tokenAmounts[i] > 0) {
                IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmounts[i]);
            }
        }
        actualTokenAmounts = push(tokens, tokenAmounts, options);
        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 leftover = actualTokenAmounts[i] < tokenAmounts[i] ? tokenAmounts[i] - actualTokenAmounts[i] : 0;
            if (leftover > 0) {
                IERC20(tokens[i]).safeTransfer(from, leftover);
            }
        }
    }

    /// @inheritdoc IVault
    function pull(
        address to,
        address[] memory tokens,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) external nonReentrant returns (uint256[] memory actualTokenAmounts) {
        require(_isApprovedOrOwner(msg.sender), ""IO""); // Also checks that the token exists
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        address owner = registry.ownerOf(_nft);
        require(owner == msg.sender || _isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION); // approved can only pull to whitelisted contracts
        uint256[] memory pTokenAmounts = _validateAndProjectTokens(tokens, tokenAmounts);
        uint256[] memory pActualTokenAmounts = _pull(to, pTokenAmounts, options);
        actualTokenAmounts = CommonLibrary.projectTokenAmounts(tokens, _vaultTokens, pActualTokenAmounts);
        emit Pull(to, actualTokenAmounts);
    }

    // -------------------  PUBLIC, MUTATING, NFT OWNER OR APPROVED OR PROTOCOL ADMIN -------------------
    /// @inheritdoc IVault
    function reclaimTokens(address to, address[] memory tokens) external nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        IProtocolGovernance governance = _vaultGovernance.internalParams().protocolGovernance;
        bool isProtocolAdmin = governance.isAdmin(msg.sender);
        require(isProtocolAdmin || _isApprovedOrOwner(msg.sender), ExceptionsLibrary.ADMIN);
        if (!isProtocolAdmin) {
            require(_isValidPullDestination(to), ExceptionsLibrary.VALID_PULL_DESTINATION);
        }
        uint256[] memory tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = IERC20(tokens[i]);
            tokenAmounts[i] = token.balanceOf(address(this));
            if (tokenAmounts[i] == 0) {
                continue;
            }
            token.safeTransfer(to, tokenAmounts[i]);
        }
        _postReclaimTokens(to, tokens);
        emit ReclaimTokens(to, tokens, tokenAmounts);
    }

    /// @inheritdoc IVault
    function claimRewards(address from, bytes memory data) external override nonReentrant {
        require(_nft > 0, ExceptionsLibrary.INITIALIZATION);
        require(_isApprovedOrOwner(msg.sender), ExceptionsLibrary.APPROVED_OR_OWNER);
        IProtocolGovernance protocolGovernance = _vaultGovernance.internalParams().protocolGovernance;
        require(protocolGovernance.isAllowedToClaim(from), ExceptionsLibrary.ALLOWED_TO_CLAIM);
        (bool res, bytes memory returndata) = from.call(data);
        if (!res) {
            assembly {
                let returndata_size := mload(returndata)
                // Bubble up revert reason
                revert(add(32, returndata), returndata_size)
            }
        }
    }

    // -------------------  PUBLIC, VIEW   -------------------\

    function isVaultToken(address token) public view returns (bool) {
        return _vaultTokensIndex[token];
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _validateAndProjectTokens(address[] memory tokens, uint256[] memory tokenAmounts)
        internal
        view
        returns (uint256[] memory pTokenAmounts)
    {
        require(CommonLibrary.isSortedAndUnique(tokens), ExceptionsLibrary.SORTED_AND_UNIQUE);
        require(tokens.length == tokenAmounts.length, ExceptionsLibrary.INCONSISTENT_LENGTH);
        pTokenAmounts = CommonLibrary.projectTokenAmounts(_vaultTokens, tokens, tokenAmounts);
    }

    /// The idea is to check that `this` Vault and `to` Vault
    /// nfts are owned by the same address. Then check that nft for this address
    /// exists in registry as Vault => it's one of the vaults with trusted interface.
    /// Then check that both `this` and `to` are registered in the nft owner using hasSubvault function.
    /// Since only gateway vault has hasSubvault function this will prove correctly that
    /// the vaults belong to the same vault system.
    function _isValidPullDestination(address to) internal view returns (bool) {
        if (!CommonLibrary.isContract(to)) {
            return false;
        }
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        // make sure that this vault is a registered vault
        if (_nft == 0) {
            return false;
        }
        address thisOwner = registry.ownerOf(_nft);
        // make sure that vault has a registered owner
        uint256 thisOwnerNft = registry.nftForVault(thisOwner);
        if (thisOwnerNft == 0) {
            return false;
        }
        IGatewayVault gw = IGatewayVault(thisOwner);
        if (!gw.hasSubvault(address(this)) || !gw.hasSubvault(to)) {
            return false;
        }
        return true;
    }

    // -------------------  PRIVATE, VIEW  -------------------

    function _isApprovedOrOwner(address sender) internal view returns (bool) {
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256 nft_ = _nft;
        if (nft_ == 0) {
            return false;
        }
        return registry.getApproved(nft_) == sender || registry.ownerOf(nft_) == sender;
    }

    // -------------------  PRIVATE, MUTATING  -------------------

    /// Guaranteed to have exact signature matchinn vault tokens
    function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        virtual
        returns (uint256[] memory actualTokenAmounts);

    /// Guaranteed to have exact signature matchinn vault tokens
    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal virtual returns (uint256[] memory actualTokenAmounts);

    function _postReclaimTokens(address to, address[] memory tokens) internal virtual {}

    /// @notice Emitted on successful push
    /// @param tokenAmounts The amounts of tokens to pushed
    event Push(uint256[] tokenAmounts);

    /// @notice Emitted on successful pull
    /// @param to The target address for pulled tokens
    /// @param tokenAmounts The amounts of tokens to pull
    event Pull(address to, uint256[] tokenAmounts);

    /// @notice Emitted when tokens are reclaimed
    /// @param to The target address for pulled tokens
    /// @param tokens ERC20 tokens to be reclaimed
    /// @param tokenAmounts The amounts of reclaims
    event ReclaimTokens(address to, address[] tokens, uint256[] tokenAmounts);
}",2627
RealWorld_TA_58_IVaultRegistry_RealWorld_20240807192813.log,58,IVaultRegistry,68627,2527,71154,108.0,0.393675,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""./IProtocolGovernance.sol"";
import ""./IVaultFactory.sol"";
import ""./IVaultGovernance.sol"";

interface IVaultRegistry is IERC721 {
    /// @notice Get Vault for the giver NFT ID.
    /// @param nftId NFT ID
    /// @return vault Address of the Vault contract
    function vaultForNft(uint256 nftId) external view returns (address vault);

    /// @notice Get NFT ID for given Vault contract address.
    /// @param vault Address of the Vault contract
    /// @return nftId NFT ID
    function nftForVault(address vault) external view returns (uint256 nftId);

    /// @notice Checks if the nft is locked for all transfers
    /// @param nft NFT to check for lock
    /// @return `true` if locked, false otherwise
    function isLocked(uint256 nft) external view returns (bool);

    /// @notice Register new Vault and mint NFT.
    /// @param vault address of the vault
    /// @param owner owner of the NFT
    /// @return nft Nft minted for the given Vault
    function registerVault(address vault, address owner) external returns (uint256 nft);

    /// @notice Number of Vaults registered.
    function vaultsCount() external view returns (uint256);

    /// @notice All Vaults registered.
    function vaults() external view returns (address[] memory);

    /// @notice Address of the ProtocolGovernance.
    function protocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Address of the staged ProtocolGovernance.
    function stagedProtocolGovernance() external view returns (IProtocolGovernance);

    /// @notice Minimal timestamp when staged ProtocolGovernance can be applied.
    function stagedProtocolGovernanceTimestamp() external view returns (uint256);

    /// @notice Stage new ProtocolGovernance.
    /// @param newProtocolGovernance new ProtocolGovernance
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external;

    /// @notice Commit new ProtocolGovernance.
    function commitStagedProtocolGovernance() external;

    /// @notice Approve nft to new address
    /// @dev This can be called only by the Protocol Governance. It is used to disable the strategy for a vault
    /// @param newAddress address that will be approved
    /// @param nft for re-approval
    function adminApprove(address newAddress, uint256 nft) external;

    /// @notice Lock NFT for transfers
    /// @dev Use this method when vault structure is set up and should become immutable. Can be called by owner.
    /// @param nft - NFT to lock
    function lockNft(uint256 nft) external;
}",619
RealWorld_TA_58_ILendingPool_RealWorld_20240807224026.log,58,ILendingPool,349656,2405,352061,147.0,1.79638,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.8.9;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from ""./ILendingPoolAddressesProvider.sol"";
import {DataTypes} from ""./DataTypes.sol"";

interface ILendingPool {
    /**
     * @dev Emitted on deposit()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address initiating the deposit
     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens
     * @param amount The amount deposited
     * @param referral The referral code used
     **/
    event Deposit(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on withdraw()
     * @param reserve The address of the underlyng asset being withdrawn
     * @param user The address initiating the withdrawal, owner of aTokens
     * @param to Address that will receive the underlying
     * @param amount The amount to be withdrawn
     **/
    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);

    /**
     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
     * @param reserve The address of the underlying asset being borrowed
     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
     * initiator of the transaction on flashLoan()
     * @param onBehalfOf The address that will be getting the debt
     * @param amount The amount borrowed out
     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable
     * @param borrowRate The numeric rate at which the user has borrowed
     * @param referral The referral code used
     **/
    event Borrow(
        address indexed reserve,
        address user,
        address indexed onBehalfOf,
        uint256 amount,
        uint256 borrowRateMode,
        uint256 borrowRate,
        uint16 indexed referral
    );

    /**
     * @dev Emitted on repay()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The beneficiary of the repayment, getting his debt reduced
     * @param repayer The address of the user initiating the repay(), providing the funds
     * @param amount The amount repaid
     **/
    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);

    /**
     * @dev Emitted on swapBorrowRateMode()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user swapping his rate mode
     * @param rateMode The rate mode that the user wants to swap to
     **/
    event Swap(address indexed reserve, address indexed user, uint256 rateMode);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on setUserUseReserveAsCollateral()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user enabling the usage as collateral
     **/
    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on rebalanceStableBorrowRate()
     * @param reserve The address of the underlying asset of the reserve
     * @param user The address of the user for which the rebalance has been executed
     **/
    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);

    /**
     * @dev Emitted on flashLoan()
     * @param target The address of the flash loan receiver contract
     * @param initiator The address initiating the flash loan
     * @param asset The address of the asset being flash borrowed
     * @param amount The amount flash borrowed
     * @param premium The fee flash borrowed
     * @param referralCode The referral code used
     **/
    event FlashLoan(
        address indexed target,
        address indexed initiator,
        address indexed asset,
        uint256 amount,
        uint256 premium,
        uint16 referralCode
    );

    /**
     * @dev Emitted when the pause is triggered.
     */
    event Paused();

    /**
     * @dev Emitted when the pause is lifted.
     */
    event Unpaused();

    /**
     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via
     * LendingPoolCollateral manager using a DELEGATECALL
     * This allows to have the events in the generated ABI for LendingPool.
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator
     * @param liquidator The address of the liquidator
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    event LiquidationCall(
        address indexed collateralAsset,
        address indexed debtAsset,
        address indexed user,
        uint256 debtToCover,
        uint256 liquidatedCollateralAmount,
        address liquidator,
        bool receiveAToken
    );

    /**
     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared
     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,
     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it
     * gets added to the LendingPool ABI
     * @param reserve The address of the underlying asset of the reserve
     * @param liquidityRate The new liquidity rate
     * @param stableBorrowRate The new stable borrow rate
     * @param variableBorrowRate The new variable borrow rate
     * @param liquidityIndex The new liquidity index
     * @param variableBorrowIndex The new variable borrow index
     **/
    event ReserveDataUpdated(
        address indexed reserve,
        uint256 liquidityRate,
        uint256 stableBorrowRate,
        uint256 variableBorrowRate,
        uint256 liquidityIndex,
        uint256 variableBorrowIndex
    );

    /**
     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.
     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC
     * @param asset The address of the underlying asset to deposit
     * @param amount The amount to be deposited
     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
     *   is a different wallet
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    /**
     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned
     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
     * @param asset The address of the underlying asset to withdraw
     * @param amount The underlying amount to be withdrawn
     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
     * @param to Address that will receive the underlying, same as msg.sender if the user
     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
     *   different wallet
     * @return The final amount withdrawn
     **/
    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower
     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the
     * corresponding debt token (StableDebtToken or VariableDebtToken)
     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet
     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`
     * @param asset The address of the underlying asset to borrow
     * @param amount The amount to be borrowed
     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself
     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
     * if he has been given credit delegation allowance
     **/
    function borrow(
        address asset,
        uint256 amount,
        uint256 interestRateMode,
        uint16 referralCode,
        address onBehalfOf
    ) external;

    /**
     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned
     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address
     * @param asset The address of the borrowed underlying asset previously borrowed
     * @param amount The amount to repay
     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`
     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
     * other borrower whose debt should be removed
     * @return The final amount repaid
     **/
    function repay(
        address asset,
        uint256 amount,
        uint256 rateMode,
        address onBehalfOf
    ) external returns (uint256);

    /**
     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa
     * @param asset The address of the underlying asset borrowed
     * @param rateMode The rate mode that the user wants to swap to
     **/
    function swapBorrowRateMode(address asset, uint256 rateMode) external;

    /**
     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
     * - Users can be rebalanced if the following conditions are satisfied:
     *     1. Usage ratio is above 95%
     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been
     *        borrowed at a stable rate and depositors are not earning enough
     * @param asset The address of the underlying asset borrowed
     * @param user The address of the user to be rebalanced
     **/
    function rebalanceStableBorrowRate(address asset, address user) external;

    /**
     * @dev Allows depositors to enable/disable a specific deposited asset as collateral
     * @param asset The address of the underlying asset deposited
     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise
     **/
    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;

    /**
     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives
     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk
     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
     * @param user The address of the borrower getting liquidated
     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover
     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants
     * to receive the underlying collateral asset directly
     **/
    function liquidationCall(
        address collateralAsset,
        address debtAsset,
        address user,
        uint256 debtToCover,
        bool receiveAToken
    ) external;

    /**
     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,
     * as long as the amount taken plus a fee is returned.
     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.
     * For further details please visit https://developers.aave.com
     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface
     * @param assets The addresses of the assets being flash-borrowed
     * @param amounts The amounts amounts being flash-borrowed
     * @param modes Types of the debt to open if the flash loan is not returned:
     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address
     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2
     * @param params Variadic packed params to pass to the receiver as extra information
     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
     *   0 if the action is executed directly by the user, without any middle-man
     **/
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;

    /**
     * @dev Returns the user account data across all the reserves
     * @param user The address of the user
     * @return totalCollateralETH the total collateral in ETH of the user
     * @return totalDebtETH the total debt in ETH of the user
     * @return availableBorrowsETH the borrowing power left of the user
     * @return currentLiquidationThreshold the liquidation threshold of the user
     * @return ltv the loan to value of the user
     * @return healthFactor the current health factor of the user
     **/
    function getUserAccountData(address user)
        external
        view
        returns (
            uint256 totalCollateralETH,
            uint256 totalDebtETH,
            uint256 availableBorrowsETH,
            uint256 currentLiquidationThreshold,
            uint256 ltv,
            uint256 healthFactor
        );

    function initReserve(
        address reserve,
        address aTokenAddress,
        address stableDebtAddress,
        address variableDebtAddress,
        address interestRateStrategyAddress
    ) external;

    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;

    function setConfiguration(address reserve, uint256 configuration) external;

    /**
     * @dev Returns the configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The configuration of the reserve
     **/
    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);

    /**
     * @dev Returns the configuration of the user across all the reserves
     * @param user The user address
     * @return The configuration of the user
     **/
    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);

    /**
     * @dev Returns the normalized income normalized income of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve's normalized income
     */
    function getReserveNormalizedIncome(address asset) external view returns (uint256);

    /**
     * @dev Returns the normalized variable debt per unit of asset
     * @param asset The address of the underlying asset of the reserve
     * @return The reserve normalized variable debt
     */
    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function finalizeTransfer(
        address asset,
        address from,
        address to,
        uint256 amount,
        uint256 balanceFromAfter,
        uint256 balanceToBefore
    ) external;

    function getReservesList() external view returns (address[] memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);

    function setPause(bool val) external;

    function paused() external view returns (bool);
}",3997
RealWorld_TA_58_GatewayVaultTest_RealWorld_20240807175246.log,58,GatewayVaultTest,38206,3702,41908,133.0,0.26507,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""../interfaces/IVaultGovernance.sol"";
import ""../interfaces/IVaultFactory.sol"";
import ""../GatewayVault.sol"";

contract GatewayVaultTest is GatewayVault {
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        GatewayVault(vaultGovernance_, vaultTokens_)
    {}

    function isValidPullDestination(address to) public view returns (bool) {
        return _isValidPullDestination(to);
    }

    function setVaultGovernance(address newVaultGovernance) public {
        _vaultGovernance = IVaultGovernance(newVaultGovernance);
    }

    function setSubvaultNfts(uint256[] memory nfts) public {
        _subvaultNfts = nfts;
    }

    function isApprovedOrOwner(address sender) public view returns (bool) {
        return _isApprovedOrOwner(sender);
    }

    function setVaultTokens(address[] memory tokens) public {
        _vaultTokens = tokens;
    }
}",217
RealWorld_TA_58_LpIssuerGovernance_RealWorld_20240807204944.log,58,LpIssuerGovernance,223525,3504,227029,179.0,1.187705,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/ILpIssuerGovernance.sol"";
import ""./interfaces/ILpIssuer.sol"";
import ""./libraries/CommonLibrary.sol"";
import ""./VaultGovernance.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Governance that manages all Lp Issuers params and can deploy a new LpIssuer Vault.
contract LpIssuerGovernance is IERC721Receiver, ILpIssuerGovernance, VaultGovernance {
    uint256 public immutable MAX_PROTOCOL_FEE;
    uint256 public immutable MAX_MANAGEMENT_FEE;
    uint256 public immutable MAX_PERFORMANCE_FEE;

    /// @notice Creates a new contract.
    /// @param internalParams_ Initial Internal Params
    /// @param delayedProtocolParams_ Initial Protocol Params
    constructor(InternalParams memory internalParams_, DelayedProtocolParams memory delayedProtocolParams_)
        VaultGovernance(internalParams_)
    {
        _delayedProtocolParams = abi.encode(delayedProtocolParams_);
        MAX_PROTOCOL_FEE = 5 * CommonLibrary.DENOMINATOR;
        MAX_MANAGEMENT_FEE = 10 * CommonLibrary.DENOMINATOR;
        MAX_PERFORMANCE_FEE = 50 * CommonLibrary.DENOMINATOR;
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolParams() public view returns (DelayedProtocolParams memory) {
        if (_delayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_delayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolParams() external view returns (DelayedProtocolParams memory) {
        if (_stagedDelayedProtocolParams.length == 0) {
            return DelayedProtocolParams({managementFeeChargeDelay: 0});
        }
        return abi.decode(_stagedDelayedProtocolParams, (DelayedProtocolParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedProtocolPerVaultParams(uint256 nft) external view returns (DelayedProtocolPerVaultParams memory) {
        if (_delayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedProtocolPerVaultParams(uint256 nft)
        external
        view
        returns (DelayedProtocolPerVaultParams memory)
    {
        if (_stagedDelayedProtocolPerVaultParams[nft].length == 0) {
            return DelayedProtocolPerVaultParams({protocolFee: 0});
        }
        return abi.decode(_stagedDelayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stagedDelayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_stagedDelayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_stagedDelayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function delayedStrategyParams(uint256 nft) external view returns (DelayedStrategyParams memory) {
        if (_delayedStrategyParams[nft].length == 0) {
            return
                DelayedStrategyParams({
                    strategyTreasury: address(0),
                    strategyPerformanceTreasury: address(0),
                    managementFee: 0,
                    performanceFee: 0
                });
        }
        return abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function strategyParams(uint256 nft) external view returns (StrategyParams memory) {
        if (_strategyParams[nft].length == 0) {
            return StrategyParams({tokenLimitPerAddress: 0});
        }
        return abi.decode(_strategyParams[nft], (StrategyParams));
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedStrategyParams(uint256 nft, DelayedStrategyParams calldata params) external {
        require(params.managementFee <= MAX_MANAGEMENT_FEE, ExceptionsLibrary.MAX_MANAGEMENT_FEE);
        require(params.performanceFee <= MAX_PERFORMANCE_FEE, ExceptionsLibrary.MAX_PERFORMANCE_FEE);
        _stageDelayedStrategyParams(nft, abi.encode(params));
        emit StageDelayedStrategyParams(tx.origin, msg.sender, nft, params, _delayedStrategyParamsTimestamp[nft]);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedStrategyParams(uint256 nft) external {
        _commitDelayedStrategyParams(nft);
        emit CommitDelayedStrategyParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedStrategyParams[nft], (DelayedStrategyParams))
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolPerVaultParams(uint256 nft, DelayedProtocolPerVaultParams calldata params) external {
        require(params.protocolFee <= MAX_PROTOCOL_FEE, ExceptionsLibrary.MAX_PROTOCOL_FEE);
        _stageDelayedProtocolPerVaultParams(nft, abi.encode(params));
        emit StageDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            params,
            _delayedStrategyParamsTimestamp[nft]
        );
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolPerVaultParams(uint256 nft) external {
        _commitDelayedProtocolPerVaultParams(nft);
        emit CommitDelayedProtocolPerVaultParams(
            tx.origin,
            msg.sender,
            nft,
            abi.decode(_delayedProtocolPerVaultParams[nft], (DelayedProtocolPerVaultParams))
        );
    }

    function setStrategyParams(uint256 nft, StrategyParams calldata params) external {
        _setStrategyParams(nft, abi.encode(params));
        emit SetStrategyParams(tx.origin, msg.sender, nft, params);
    }

    /// @inheritdoc ILpIssuerGovernance
    function stageDelayedProtocolParams(DelayedProtocolParams calldata params) external {
        _stageDelayedProtocolParams(abi.encode(params));
        emit StageDelayedProtocolParams(tx.origin, msg.sender, params, _delayedProtocolParamsTimestamp);
    }

    /// @inheritdoc ILpIssuerGovernance
    function commitDelayedProtocolParams() external {
        _commitDelayedProtocolParams();
        emit CommitDelayedProtocolParams(
            tx.origin,
            msg.sender,
            abi.decode(_delayedProtocolParams, (DelayedProtocolParams))
        );
    }

    /// @notice Required for intermediate vault token transfer in deploy
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external view returns (bytes4) {
        IVaultRegistry registry = _internalParams.registry;
        require(msg.sender == address(registry), ExceptionsLibrary.NFT_VAULT_REGISTRY);
        return this.onERC721Received.selector;
    }

    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Abi encoded uint256 - an nfts of the gateway subvault. It is required that nft subvault is approved by the caller to this address and that it is a gateway vault
    /// @return vault Address of the new vault
    /// @return nft Nft of the vault in the vault registry
    function deployVault(
        address[] memory vaultTokens,
        bytes memory options,
        address
    ) public override(VaultGovernance, IVaultGovernance) returns (IVault vault, uint256 nft) {
        (uint256 subvaultNft, string memory name, string memory symbol) = abi.decode(
            options,
            (uint256, string, string)
        );
        (vault, nft) = super.deployVault(vaultTokens, abi.encode(name, symbol), msg.sender);
        IVaultRegistry registry = _internalParams.registry;
        ILpIssuer(address(vault)).addSubvault(subvaultNft);
        registry.safeTransferFrom(msg.sender, address(vault), subvaultNft);
    }

    /// @notice Emitted when new DelayedProtocolPerVaultParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolPerVaultParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedProtocolPerVaultParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedProtocolPerVaultParams params
    );

    /// @notice Emitted when new DelayedStrategyParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedStrategyParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are committed
    event CommitDelayedStrategyParams(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        DelayedStrategyParams params
    );

    /// @notice Emitted when new StrategyParams are set.
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param params New params that are set
    event SetStrategyParams(address indexed origin, address indexed sender, uint256 indexed nft, StrategyParams params);

    /// @notice Emitted when new DelayedProtocolParams are staged for commit
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that were staged for commit
    /// @param when When the params could be committed
    event StageDelayedProtocolParams(
        address indexed origin,
        address indexed sender,
        DelayedProtocolParams params,
        uint256 when
    );

    /// @notice Emitted when new DelayedProtocolParams are committed
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param params New params that are committed
    event CommitDelayedProtocolParams(address indexed origin, address indexed sender, DelayedProtocolParams params);
}",2468
RealWorld_TA_58_IProtocolGovernance_RealWorld_20240807221110.log,58,IProtocolGovernance,90960,2149,93109,120.0,0.49778,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IDefaultAccessControl.sol"";
import ""./IVaultRegistry.sol"";

interface IProtocolGovernance is IDefaultAccessControl {
    /// @notice CommonLibrary protocol params.
    /// @param permissionless If `true` anyone can spawn vaults, o/w only Protocol Governance Admin
    /// @param maxTokensPerVault Max different token addresses that could be managed by the protocol
    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them
    /// @param protocolTreasury Protocol treasury address for collecting management fees
    struct Params {
        bool permissionless;
        uint256 maxTokensPerVault;
        uint256 governanceDelay;
        address protocolTreasury;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function claimAllowlist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to claimAllowlist.
    function pendingClaimAllowlistAdd() external view returns (address[] memory);

    /// @notice Addresses of tokens allowed for vaults.
    function tokenWhitelist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to tokenWhitelist.
    function pendingTokenWhitelistAdd() external view returns (address[] memory);

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function vaultGovernances() external view returns (address[] memory);

    /// @notice Pending addresses to be added to vaultGovernances.
    function pendingVaultGovernancesAdd() external view returns (address[] memory);

    /// @notice Check if address is allowed to claim.
    function isAllowedToClaim(address addr) external view returns (bool);

    /// @notice Check if address is an approved token.
    function isAllowedToken(address addr) external view returns (bool);

    /// @notice Check if address is a registered vault governance.
    function isVaultGovernance(address addr) external view returns (bool);

    /// @notice If `false` only admins can deploy new vaults, o/w anyone can deploy a new vault.
    function permissionless() external view returns (bool);

    /// @notice Max different ERC20 token addresses that could be managed by the protocol.
    function maxTokensPerVault() external view returns (uint256);

    /// @notice The delay for committing any governance params.
    function governanceDelay() external view returns (uint256);

    /// @notice The address of the protocol treasury.
    function protocolTreasury() external view returns (address);

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @notice Set new pending params.
    /// @param newParams newParams to set
    function setPendingParams(Params memory newParams) external;

    /// @notice Stage addresses for claim allow list.
    /// @param addresses Addresses to add
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for token whitelist.
    /// @param addresses Addresses to add
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for vault governances.
    /// @param addresses Addresses to add
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external;

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @notice Commit pending params.
    function commitParams() external;

    /// @notice Commit pending ClaimAllowlistAdd params.
    function commitClaimAllowlistAdd() external;

    /// @notice Commit pending tokenWhitelistAdd params.
    function commitTokenWhitelistAdd() external;

    /// @notice Commit pending VaultGovernancesAdd params.
    function commitVaultGovernancesAdd() external;

    /// @notice Remove from claim allow list immediately.
    function removeFromClaimAllowlist(address addr) external;

    /// @notice Remove from token whitelist immediately.
    function removeFromTokenWhitelist(address addr) external;

    /// @notice Remove from vault governances immediately.
    function removeFromVaultGovernances(address addr) external;
}",867
RealWorld_TA_58_VaultRegistry_RealWorld_20240807205508.log,58,VaultRegistry,135781,3565,139346,152.0,0.750205,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity =0.8.9;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import ""./interfaces/IProtocolGovernance.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/IVaultFactory.sol"";
import ""./interfaces/IVaultRegistry.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice This contract is used to manage ERC721 NFT for all Vaults.
contract VaultRegistry is IVaultRegistry, ERC721 {
    uint256 private _stagedProtocolGovernanceTimestamp;
    IProtocolGovernance private _protocolGovernance;
    IProtocolGovernance private _stagedProtocolGovernance;

    address[] private _vaults;
    mapping(address => uint256) private _nftIndex;
    mapping(uint256 => address) private _vaultIndex;
    mapping(uint256 => bool) private _locks;
    uint256 private _topNft = 1;

    /// @notice Creates a new contract.
    /// @param name ERC721 token name
    /// @param symbol ERC721 token symbol
    /// @param protocolGovernance_ Reference to ProtocolGovernance
    constructor(
        string memory name,
        string memory symbol,
        IProtocolGovernance protocolGovernance_
    ) ERC721(name, symbol) {
        _protocolGovernance = protocolGovernance_;
    }

    function vaults() external view returns (address[] memory) {
        return _vaults;
    }

    /// @inheritdoc IVaultRegistry
    function vaultForNft(uint256 nft) external view returns (address) {
        return _vaultIndex[nft];
    }

    /// @inheritdoc IVaultRegistry
    function nftForVault(address vault) external view returns (uint256) {
        return _nftIndex[vault];
    }

    /// @inheritdoc IVaultRegistry
    function isLocked(uint256 nft) external view returns (bool) {
        return _locks[nft];
    }

    /// @inheritdoc IVaultRegistry
    function registerVault(address vault, address owner) external returns (uint256 nft) {
        require(_protocolGovernance.isVaultGovernance(msg.sender), ExceptionsLibrary.SHOULD_BE_CALLED_BY_VAULT_GOVERNANCE);
        nft = _topNft;
        _safeMint(owner, nft);
        _vaultIndex[nft] = vault;
        _nftIndex[vault] = nft;
        _vaults.push(vault);
        _topNft += 1;
        emit VaultRegistered(tx.origin, msg.sender, nft, vault, owner);
    }

    /// @inheritdoc IVaultRegistry
    function protocolGovernance() external view returns (IProtocolGovernance) {
        return _protocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernance() external view returns (IProtocolGovernance) {
        return _stagedProtocolGovernance;
    }

    /// @inheritdoc IVaultRegistry
    function stagedProtocolGovernanceTimestamp() external view returns (uint256) {
        return _stagedProtocolGovernanceTimestamp;
    }

    /// @inheritdoc IVaultRegistry
    function vaultsCount() external view returns (uint256) {
        return _vaults.length;
    }

    /// @inheritdoc IVaultRegistry
    function stageProtocolGovernance(IProtocolGovernance newProtocolGovernance) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        _stagedProtocolGovernance = newProtocolGovernance;
        _stagedProtocolGovernanceTimestamp = (block.timestamp + _protocolGovernance.governanceDelay());
        emit StagedProtocolGovernance(tx.origin, msg.sender, newProtocolGovernance, _stagedProtocolGovernanceTimestamp);
    }

    /// @inheritdoc IVaultRegistry
    function commitStagedProtocolGovernance() external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        require(_stagedProtocolGovernanceTimestamp > 0, ExceptionsLibrary.NULL_OR_NOT_INITIALIZED);
        require(block.timestamp >= _stagedProtocolGovernanceTimestamp, ExceptionsLibrary.TIMESTAMP);
        _protocolGovernance = _stagedProtocolGovernance;
        delete _stagedProtocolGovernanceTimestamp;
        emit CommitedProtocolGovernance(tx.origin, msg.sender, _protocolGovernance);
    }

    /// @inheritdoc IVaultRegistry
    function adminApprove(address newAddress, uint256 nft) external {
        require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);
        IERC721(address(this)).approve(newAddress, nft);
    }

    function lockNft(uint256 nft) external {
        require(ownerOf(nft) == msg.sender, ExceptionsLibrary.TOKEN_OWNER);
        _locks[nft] = true;
        emit TokenLocked(tx.origin, msg.sender, nft);
    }

    function _isProtocolAdmin(address sender) internal view returns (bool) {
        return _protocolGovernance.isAdmin(sender);
    }

    function _beforeTokenTransfer(
        address,
        address,
        uint256 tokenId
    ) internal view override {
        require(!_locks[tokenId], ExceptionsLibrary.LOCKED_NFT);
    }

    /// @notice Emitted when token is locked for transfers
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft NFT to be locked
    event TokenLocked(address indexed origin, address indexed sender, uint256 indexed nft);

    /// @notice Emitted when new Vault is registered in VaultRegistry
    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param nft VaultRegistry NFT of the vault
    /// @param vault Address of the Vault contract
    /// @param owner Owner of the VaultRegistry NFT
    event VaultRegistered(
        address indexed origin,
        address indexed sender,
        uint256 indexed nft,
        address vault,
        address owner
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance
    /// @param start Timestamp of the start of the new ProtocolGovernance
    event StagedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance,
        uint256 start
    );

    /// @param origin Origin of the transaction
    /// @param sender Sender of the transaction
    /// @param newProtocolGovernance Address of the new ProtocolGovernance that has been committed
    event CommitedProtocolGovernance(
        address indexed origin,
        address indexed sender,
        IProtocolGovernance newProtocolGovernance
    );
}",1400
RealWorld_TA_58_YearnVault_RealWorld_20240807171021.log,58,YearnVault,103688,5867,109555,156.0,0.63578,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.9;

import ""./interfaces/external/aave/ILendingPool.sol"";
import ""./interfaces/external/yearn/IYearnVault.sol"";
import ""./interfaces/IYearnVaultGovernance.sol"";
import ""./Vault.sol"";
import ""./libraries/ExceptionsLibrary.sol"";

/// @notice Vault that interfaces Yearn protocol in the integration layer.
/// @dev Notes:
/// ### TVL
///
/// The TVL of the vault is cached and updated after each deposit withdraw.
/// So essentially `tvl` call doesn't take into account accrued interest / donations to Yearn since the
/// last `deposit` / `withdraw`
///
/// ### yTokens
/// yTokens are fixed at the token creation and addresses are taken from YearnVault governance and if missing there
/// - in YearnVaultRegistry.
/// So essentially each yToken is fixed for life of the YearnVault. If the yToken is missing for some vaultToken,
/// the YearnVault cannot be created.
///
/// ### Push / Pull
/// There are some deposit limits imposed by Yearn vaults.
/// The contract's vaultTokens are fully allowed to corresponding yTokens.

contract YearnVault is Vault {
    address[] private _yTokens;

    /// @notice Creates a new contract.
    /// @param vaultGovernance_ Reference to VaultGovernance for this vault
    /// @param vaultTokens_ ERC20 tokens under Vault management
    constructor(IVaultGovernance vaultGovernance_, address[] memory vaultTokens_)
        Vault(vaultGovernance_, vaultTokens_)
    {
        _yTokens = new address[](vaultTokens_.length);
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            _yTokens[i] = IYearnVaultGovernance(address(vaultGovernance_)).yTokenForToken(_vaultTokens[i]);
            require(_yTokens[i] != address(0), ""YV"");
        }
    }

    /// @notice Yearn protocol vaults used by this contract
    function yTokens() external view returns (address[] memory) {
        return _yTokens;
    }

    /// @inheritdoc Vault
    function tvl() public view override returns (uint256[] memory tokenAmounts) {
        address[] memory tokens = _vaultTokens;
        tokenAmounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < _yTokens.length; i++) {
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            tokenAmounts[i] = (yToken.balanceOf(address(this)) * yToken.pricePerShare()) / (10**yToken.decimals());
        }
    }

    function _push(uint256[] memory tokenAmounts, bytes memory)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        address[] memory tokens = _vaultTokens;
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            address token = tokens[i];
            IYearnVault yToken = IYearnVault(_yTokens[i]);
            _allowTokenIfNecessary(token, address(yToken));
            yToken.deposit(tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        uint256 maxLoss = abi.decode(options, (uint256));
        for (uint256 i = 0; i < _yTokens.length; i++) {
            if (tokenAmounts[i] == 0) {
                continue;
            }

            IYearnVault yToken = IYearnVault(_yTokens[i]);
            uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());
            uint256 balance = yToken.balanceOf(address(this));
            if (yTokenAmount > balance) {
                yTokenAmount = balance;
            }
            if (yTokenAmount == 0) {
                continue;
            }
            yToken.withdraw(yTokenAmount, to, maxLoss);
            (tokenAmounts[i], address(this));
        }
        actualTokenAmounts = tokenAmounts;
    }

    function _allowTokenIfNecessary(address token, address yToken) internal {
        if (IERC20(token).allowance(address(this), yToken) < type(uint256).max / 2) {
            IERC20(token).approve(yToken, type(uint256).max);
        }
    }
}",1006
RealWorld_TA_58_IProtocolGovernance_RealWorld_20240807191534.log,58,IProtocolGovernance,91049,2253,93302,116.0,0.500305,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IDefaultAccessControl.sol"";
import ""./IVaultRegistry.sol"";

interface IProtocolGovernance is IDefaultAccessControl {
    /// @notice CommonLibrary protocol params.
    /// @param permissionless If `true` anyone can spawn vaults, o/w only Protocol Governance Admin
    /// @param maxTokensPerVault Max different token addresses that could be managed by the protocol
    /// @param governanceDelay The delay (in secs) that must pass before setting new pending params to commiting them
    /// @param protocolTreasury Protocol treasury address for collecting management fees
    struct Params {
        bool permissionless;
        uint256 maxTokensPerVault;
        uint256 governanceDelay;
        address protocolTreasury;
    }

    // -------------------  PUBLIC, VIEW  -------------------

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function claimAllowlist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to claimAllowlist.
    function pendingClaimAllowlistAdd() external view returns (address[] memory);

    /// @notice Addresses of tokens allowed for vaults.
    function tokenWhitelist() external view returns (address[] memory);

    /// @notice Pending addresses to be added to tokenWhitelist.
    function pendingTokenWhitelistAdd() external view returns (address[] memory);

    /// @notice Addresses allowed to claim liquidity mining rewards from.
    function vaultGovernances() external view returns (address[] memory);

    /// @notice Pending addresses to be added to vaultGovernances.
    function pendingVaultGovernancesAdd() external view returns (address[] memory);

    /// @notice Check if address is allowed to claim.
    function isAllowedToClaim(address addr) external view returns (bool);

    /// @notice Check if address is an approved token.
    function isAllowedToken(address addr) external view returns (bool);

    /// @notice Check if address is a registered vault governance.
    function isVaultGovernance(address addr) external view returns (bool);

    /// @notice If `false` only admins can deploy new vaults, o/w anyone can deploy a new vault.
    function permissionless() external view returns (bool);

    /// @notice Max different ERC20 token addresses that could be managed by the protocol.
    function maxTokensPerVault() external view returns (uint256);

    /// @notice The delay for committing any governance params.
    function governanceDelay() external view returns (uint256);

    /// @notice The address of the protocol treasury.
    function protocolTreasury() external view returns (address);

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, DELAY  -------------------

    /// @notice Set new pending params.
    /// @param newParams newParams to set
    function setPendingParams(Params memory newParams) external;

    /// @notice Stage addresses for claim allow list.
    /// @param addresses Addresses to add
    function setPendingClaimAllowlistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for token whitelist.
    /// @param addresses Addresses to add
    function setPendingTokenWhitelistAdd(address[] calldata addresses) external;

    /// @notice Stage addresses for vault governances.
    /// @param addresses Addresses to add
    function setPendingVaultGovernancesAdd(address[] calldata addresses) external;

    // -------------------  PUBLIC, MUTATING, GOVERNANCE, IMMEDIATE  -------------------

    /// @notice Commit pending params.
    function commitParams() external;

    /// @notice Commit pending ClaimAllowlistAdd params.
    function commitClaimAllowlistAdd() external;

    /// @notice Commit pending tokenWhitelistAdd params.
    function commitTokenWhitelistAdd() external;

    /// @notice Commit pending VaultGovernancesAdd params.
    function commitVaultGovernancesAdd() external;

    /// @notice Remove from claim allow list immediately.
    function removeFromClaimAllowlist(address addr) external;

    /// @notice Remove from token whitelist immediately.
    function removeFromTokenWhitelist(address addr) external;

    /// @notice Remove from vault governances immediately.
    function removeFromVaultGovernances(address addr) external;
}",867
RealWorld_TA_58_IVaultFactory_RealWorld_20240807183706.log,58,IVaultFactory,26372,1446,27818,92.0,0.16078,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.9;

import ""./IVaultGovernance.sol"";
import ""./IVault.sol"";

interface IVaultFactory {
    /// @notice Deploy a new vault.
    /// @param vaultTokens ERC20 tokens under vault management
    /// @param options Reserved additional deploy options. Should be 0x0
    function deployVault(address[] memory vaultTokens, bytes memory options) external returns (IVault vault);
}",96
RealWorld_TA_58_ISwapRouter_RealWorld_20240807225349.log,58,ISwapRouter,66049,1579,67628,98.0,0.361825,"// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity >=0.7.5;
pragma abicoder v2;

/// @title Router token swapping functionality
/// @notice Functions for swapping tokens via Uniswap V3
interface ISwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);

    struct ExactInputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
    }

    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
    /// @return amountOut The amount of the received token
    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another token
    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);

    struct ExactOutputParams {
        bytes path;
        address recipient;
        uint256 deadline;
        uint256 amountOut;
        uint256 amountInMaximum;
    }

    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
    /// @return amountIn The amount of the input token
    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
}",571
RealWorld_TA_59_AbstractTransferVerification_RealWorld_20240808095126.log,59,AbstractTransferVerification,25999,1390,27389,102.0,0.157795,"pragma solidity >=0.6.6;

import ""./Permissions.sol"";

/// @title AbstractTransferVerification
/// @author 0xScotch <scotch@malt.money>
/// @notice Implements a single method that can block a particular transfer
abstract contract AbstractTransferVerification is Permissions {
  function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {
    return (true, """");
  }
}",92
RealWorld_TA_59_IERC20Permit_RealWorld_20240808104321.log,59,IERC20Permit,62398,1436,63834,98.0,0.34071,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.6;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.;
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}",532
RealWorld_TA_59_IMaltDataLab_RealWorld_20240808105717.log,59,IMaltDataLab,32026,1352,33378,473.0,0.18717,"pragma solidity >=0.6.6;

interface IMaltDataLab {
  function priceTarget() external view returns (uint256);
  function smoothedReserveRatio() external view returns (uint256);
  function smoothedMaltPrice() external view returns (uint256);
  function smoothedMaltInPool() external view returns (uint256);
  function reserveRatioAverage(uint256 _lookback) external view returns (uint256);
  function maltPriceAverage(uint256 _lookback) external view returns (uint256);
  function maltInPoolAverage(uint256 _lookback) external view returns (uint256);
  function realValueOfLPToken(uint256 amount) external view returns (uint256);
  function trackReserveRatio() external;
  function trackPool() external;
}",161
RealWorld_TA_59_IOverflow_RealWorld_20240808111150.log,59,IOverflow,24584,1937,26521,116.0,0.16166,"pragma solidity >=0.6.6;

interface IOverflow {
  function requestCapital(uint256 amount) external returns (uint256 fulfilledAmount);
  function purchaseArbitrageTokens(uint256 maxAmount)
    external returns (uint256 remaining);
  function claim() external;
  function outstandingArbTokens() external view returns (uint256 outstanding);
}",71
RealWorld_TA_59_ERC20VestedMine_RealWorld_20240808091829.log,59,ERC20VestedMine,109146,4417,113563,178.0,0.63407,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./AbstractRewardMine.sol"";
import ""./interfaces/IDistributor.sol"";
import ""./interfaces/IBonding.sol"";


/// @title ERC20 Vested Mine
/// @author 0xScotch <scotch@malt.money>
/// @notice An implementation of AbstractRewardMine to handle rewards being vested by the RewardDistributor
contract ERC20VestedMine is Initializable, AbstractRewardMine {
  IDistributor public distributor;
  IBonding public bonding;

  function initialize(
    address _timelock,
    address initialAdmin,
    address _miningService,
    address _distributor,
    address _bonding,
    address _rewardToken
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    distributor = IDistributor(_distributor);
    bonding = IBonding(_bonding);

    _initialSetup(_rewardToken, _miningService);
  }

  function onUnbond(address account, uint256 amount)
    override
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    // Withdraw all current rewards
    // Done now before we change stake padding below
    uint256 rewardEarned = earned(account);
    _handleWithdrawForAccount(account, rewardEarned, account);

    uint256 bondedBalance = balanceOfBonded(account);

    if (bondedBalance == 0) {
      return;
    }

    _checkForForfeit(account, amount, bondedBalance);

    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);

    _reconcileWithdrawn(account, amount, bondedBalance);
    _removeFromStakePadding(account, lessStakePadding, ""< stake padding"");
  }

  function totalBonded() override public view returns (uint256) {
    return bonding.totalBonded();
  }

  function balanceOfBonded(address account) override public view returns (uint256) {
    return bonding.balanceOfBonded(account);
  }

  /*
   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case
   * of vesting rewards they are different. In that case totalDeclaredReward is total
   * reward, including unvested. totalReleasedReward is just the rewards that have completed
   * the vesting schedule.
   */
  function totalDeclaredReward() override public view returns (uint256) {
    return distributor.totalDeclaredReward();
  }

  function totalReleasedReward() override public view returns (uint256) {
    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _checkForForfeit(address account, uint256 amount, uint256 bondedBalance) internal {
    // This is the user's share of total rewards
    uint256 userReward = balanceOfRewards(account);
    uint256 globalRewarded = totalDeclaredReward();

    uint256 earnedReward = 0;
    
    // This is done inline instead of using earned() to save gas
    if (globalRewarded > 0 && userReward > 0) {
      // Note this doesn't factor in withdrawn as it is working
      // on absolute reward terms
      earnedReward = totalReleasedReward().mul(userReward) / globalRewarded;
    }

    // The user is unbonding so we should reduce declaredReward
    // proportional to the unbonded amount
    // At any given point in time, every user has rewards allocated
    // to them. balanceOfRewards(account) will tell you this value.
    // If a user unbonds x% of their LP then declaredReward should
    // reduce by exactly x% of that user's allocated rewards

    // However, this has to be done in 2 parts. First forfeit x%
    // Of unvested rewards. This decrements declaredReward automatically.
    // Then we call decrementRewards using x% of rewards that have 
    // already been released. The net effect is declaredReward decreases
    // by x% of the users allocated reward

    uint256 forfeitReward = userReward.sub(earnedReward).mul(amount) / bondedBalance;
    uint256 declaredRewardDecrease = earnedReward.mul(amount) / bondedBalance;

    if (forfeitReward > 0) {
      distributor.forfeit(forfeitReward);
    }

    if (declaredRewardDecrease > 0) {
      distributor.decrementRewards(declaredRewardDecrease);
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setDistributor(address _distributor)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    distributor = IDistributor(_distributor);
  }

  function setBonding(address _bonding)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    bonding = IBonding(_bonding);
  }
}",1080
RealWorld_TA_59_Bonding_RealWorld_20240808095931.log,59,Bonding,235902,5667,241569,201.0,1.29285,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./interfaces/IDAO.sol"";
import ""./interfaces/IMiningService.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IMaltDataLab.sol"";

import ""./Permissions.sol"";


struct UserState {
  uint256 bonded;

  // TODO calculate average bonded period for log calc Tue 03 Aug 2021 11:22:39 BST
  uint256 bondedEpoch;
}

struct EpochState {
  uint256 lastTotalBonded;
  uint256 lastUpdateTime;
  uint256 cumulativeTotalBonded;
}


/// @title LP Bonding
/// @author 0xScotch <scotch@malt.money>
/// @notice The contract which LP tokens are bonded to to make a user eligible for protocol rewards
contract Bonding is Initializable, Permissions {
  ERC20 public malt;
  ERC20 public rewardToken;
  ERC20 public stakeToken;
  IDAO public dao;
  IMiningService public miningService;
  IDexHandler public dexHandler;
  IMaltDataLab public maltDataLab;

  uint256 internal _globalBonded;
  uint256 internal _currentEpoch;
  address internal offering;
  mapping(address => UserState) internal userState;
  mapping(uint256 => EpochState) internal epochState;

  event Bond(address indexed account, uint256 value);
  event Unbond(address indexed account, uint256 value);
  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _malt,
    address _rewardToken,
    address _stakeToken,
    address _dao,
    address _miningService,
    address _offering,
    address _dexHandler,
    address _maltDataLab
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    dao = IDAO(_dao);
    offering = _offering;
    stakeToken = ERC20(_stakeToken);
    miningService = IMiningService(_miningService);
    dexHandler = IDexHandler(_dexHandler);
    malt = ERC20(_malt);
    rewardToken = ERC20(_rewardToken);
    maltDataLab = IMaltDataLab(_maltDataLab);
  }

  function bond(uint256 amount) external {
    bondToAccount(msg.sender, amount);
  }

  function bondToAccount(address account, uint256 amount)
    public
  {
    if (msg.sender != offering) {
      _notSameBlock();
    }
    require(amount > 0, ""Cannot bond 0"");

    miningService.onBond(account, amount);

    _bond(account, amount);
  }

  function unbond(uint256 amount)
    external
  {
    require(amount > 0, ""Cannot unbond 0"");

    uint256 bondedBalance = balanceOfBonded(msg.sender);

    require(bondedBalance > 0, ""< bonded balance"");
    require(amount <= bondedBalance, ""< bonded balance"");

    // Avoid leaving dust behind
    if (amount.add(1e16) > bondedBalance) {
      amount = bondedBalance;
    }

    miningService.onUnbond(msg.sender, amount);

    _unbond(amount);
  }

  function unbondAndBreak(uint256 amount)
    external
  {
    require(amount > 0, ""Cannot unbond 0"");

    uint256 bondedBalance = balanceOfBonded(msg.sender);

    require(bondedBalance > 0, ""< bonded balance"");
    require(amount <= bondedBalance, ""< bonded balance"");

    // Avoid leaving dust behind
    if (amount.add(1e16) > bondedBalance) {
      amount = bondedBalance;
    }

    miningService.onUnbond(msg.sender, amount);

    _unbondAndBreak(amount);
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function averageBondedValue(uint256 epoch) public view returns (uint256) {
    EpochState storage state = epochState[epoch];
    uint256 epochLength = dao.epochLength();
    uint256 timeElapsed = epochLength;
    uint256 epochStartTime = dao.getEpochStartTime(epoch);
    uint256 diff;
    uint256 lastUpdateTime = state.lastUpdateTime;
    uint256 lastTotalBonded = state.lastTotalBonded;

    if (lastUpdateTime == 0) {
      lastUpdateTime = epochStartTime;
    }

    if (lastTotalBonded == 0) {
      lastTotalBonded = _globalBonded;
    }

    if (block.timestamp < epochStartTime) {
      return 0;
    }

    if (epochStartTime + epochLength <= lastUpdateTime) {
      return maltDataLab.realValueOfLPToken((state.cumulativeTotalBonded) / epochLength);
    }

    if (epochStartTime + epochLength < block.timestamp) {
      // The desired epoch is in the past
      diff = (epochStartTime + epochLength) - lastUpdateTime;
    } else {
      diff = block.timestamp - lastUpdateTime;
      timeElapsed = block.timestamp - epochStartTime;
    }

    if (timeElapsed == 0) {
      // Only way timeElapsed should == 0 is when block.timestamp == epochStartTime
      // Therefore just return the lastTotalBonded value
      return maltDataLab.realValueOfLPToken(lastTotalBonded);
    }

    uint256 endValue = state.cumulativeTotalBonded + (lastTotalBonded.mul(diff));
    return maltDataLab.realValueOfLPToken((endValue) / timeElapsed);
  }

  function totalBonded() public view returns (uint256) {
    return _globalBonded;
  }

  function balanceOfBonded(address account) public view returns (uint256) {
    return userState[account].bonded;
  }

  function bondedEpoch(address account) public view returns (uint256) {
    return userState[account].bondedEpoch;
  }

  function epochData(uint256 epoch) public view returns(uint256, uint256, uint256) {
    return (epochState[epoch].lastTotalBonded, epochState[epoch].lastUpdateTime, epochState[epoch].cumulativeTotalBonded);
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _balanceCheck() internal view {
    require(stakeToken.balanceOf(address(this)) >= totalBonded(), ""Balance inconsistency"");
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _bond(address account, uint256 amount) internal {
    stakeToken.safeTransferFrom(msg.sender, address(this), amount);

    _addToBonded(account, amount);

    _balanceCheck();

    emit Bond(account, amount);
  }

  function _unbond(uint256 amountLPToken) internal notSameBlock {
    _removeFromBonded(msg.sender, amountLPToken, ""LP: Insufficient bonded balance"");

    stakeToken.safeTransfer(msg.sender, amountLPToken);

    _balanceCheck();

    emit Unbond(msg.sender, amountLPToken);
  }

  function _unbondAndBreak(uint256 amountLPToken) internal notSameBlock {
    _removeFromBonded(msg.sender, amountLPToken, ""LP: Insufficient bonded balance"");

    stakeToken.safeTransfer(address(dexHandler), amountLPToken);

    (uint256 amountMalt, uint256 amountReward) = dexHandler.removeLiquidity();

    malt.safeTransfer(msg.sender, amountMalt);
    rewardToken.safeTransfer(msg.sender, amountReward);

    _balanceCheck();

    emit UnbondAndBreak(msg.sender, amountLPToken, amountMalt, amountReward);
  }

  function _addToBonded(address account, uint256 amount) internal {
    userState[account].bonded = userState[account].bonded.add(amount);

    _updateEpochState(_globalBonded.add(amount));

    if (userState[account].bondedEpoch == 0) {
      userState[account].bondedEpoch = dao.epoch();
    }
  }

  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {
    userState[account].bonded = userState[account].bonded.sub(amount, reason);

    _updateEpochState(_globalBonded.sub(amount, reason));
  }

  function _updateEpochState(uint256 newTotalBonded) internal {
    EpochState storage state = epochState[_currentEpoch];
    uint256 epoch = dao.epoch();
    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);
    uint256 lastUpdateTime = state.lastUpdateTime;
    uint256 lengthOfEpoch = dao.epochLength();
    uint256 epochEndTime = epochStartTime + lengthOfEpoch;

    if (lastUpdateTime == 0) {
      lastUpdateTime = epochStartTime;
    }

    if (lastUpdateTime > epochEndTime) {
      lastUpdateTime = epochEndTime;
    }

    if (epoch == _currentEpoch) {
      // We are still in the same epoch. Just update
      uint256 finalTime = block.timestamp;
      if (block.timestamp > epochEndTime) {
        // We are past the end of the epoch so cap to end of epoch
        finalTime = epochEndTime;
      } 

      uint256 diff = finalTime - lastUpdateTime;

      if (diff > 0) {
        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));

        state.lastUpdateTime = finalTime;
        state.lastTotalBonded = newTotalBonded;
      }
    } else {
      // We have crossed at least 1 epoch boundary

      // Won't underflow due to check on lastUpdateTime above
      uint256 diff = epochEndTime - lastUpdateTime;

      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));
      state.lastUpdateTime = epochEndTime;
      state.lastTotalBonded = _globalBonded;

      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {
        state = epochState[i];
        epochStartTime = dao.getEpochStartTime(i);
        epochEndTime = epochStartTime + lengthOfEpoch;
        state.lastTotalBonded = _globalBonded;

        if (epochEndTime < block.timestamp) {
          // The desired epoch is in the past
          diff = lengthOfEpoch;
          state.lastUpdateTime = epochEndTime;
        } else {
          diff = block.timestamp - epochStartTime;
          state.lastUpdateTime = block.timestamp;
        }

        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);
      }

      state.lastTotalBonded = newTotalBonded;
      _currentEpoch = epoch;
    } 

    _globalBonded = newTotalBonded;
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setMiningService(address _miningService)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_miningService != address(0), ""Cannot set 0 address"");
    miningService = IMiningService(_miningService);
  }

  function setDAO(address _dao)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_dao != address(0), ""Cannot set 0 address"");
    dao = IDAO(_dao);
  }

  function setDexHandler(address _dexHandler)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_dexHandler != address(0), ""Cannot set 0 address"");
    dexHandler = IDexHandler(_dexHandler);
  }

  function setCurrentEpoch(uint256 _epoch)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    _currentEpoch = _epoch;
  }
}",2523
RealWorld_TA_59_RewardReinvestor_RealWorld_20240808093122.log,59,RewardReinvestor,114311,3950,118261,153.0,0.650555,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IBonding.sol"";
import ""./interfaces/IMiningService.sol"";
import ""./libraries/UniswapV2Library.sol"";
import ""./Permissions.sol"";


/// @title Reward Reinvestor
/// @author 0xScotch <scotch@malt.money>
/// @notice Provide a way to programmatically reinvest Malt rewards
contract RewardReinvestor is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  ERC20 public malt;
  ERC20 public rewardToken;
  ERC20 public stakeToken;

  IDexHandler public dexHandler;
  IBonding public bonding;
  IMiningService public miningService;
  address public treasury;

  event ProvideReinvest(address account, uint256 reward);
  event SplitReinvest(address account, uint256 amountReward);
  event SetDexHandler(address dexHandler);
  event SetBonding(address bonding);
  event SetMiningService(address miningService);
  event SetTreasury(address _treasury);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _maltToken,
    address _rewardToken,
    address _dexHandler,
    address _bonding,
    address _miningService,
    address _uniswapV2Factory,
    address _treasury
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    malt = ERC20(_maltToken);
    rewardToken = ERC20(_rewardToken);
    dexHandler = IDexHandler(_dexHandler);
    bonding = IBonding(_bonding);
    miningService = IMiningService(_miningService);
    treasury = _treasury;

    stakeToken = ERC20(UniswapV2Library.pairFor(_uniswapV2Factory, _maltToken, _rewardToken));
  }

  function provideReinvest(uint256 rewardLiquidity) external {
    _retrieveReward(rewardLiquidity);

    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    // This is how much malt is required
    uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);

    // Transfer the remaining Malt required
    malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);

    _bondAccount(msg.sender);

    emit ProvideReinvest(msg.sender, rewardLiquidity);
  }

  function splitReinvest(uint256 rewardLiquidity) external {
    _retrieveReward(rewardLiquidity);

    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    rewardToken.safeTransfer(address(dexHandler), rewardBalance.div(2));

    dexHandler.buyMalt();

    _bondAccount(msg.sender);

    emit SplitReinvest(msg.sender, rewardLiquidity);
  }

  function _retrieveReward(uint256 rewardLiquidity) internal {
    require(rewardLiquidity > 0, ""Cannot reinvest 0"");

    miningService.withdrawRewardsForAccount(
      msg.sender,
      rewardLiquidity
    );
  }

  function _bondAccount(address account) internal {
    malt.safeTransfer(address(dexHandler), malt.balanceOf(address(this)));
    rewardToken.safeTransfer(address(dexHandler), rewardToken.balanceOf(address(this)));

    (,,uint256 liquidityCreated) = dexHandler.addLiquidity();

    stakeToken.approve(address(bonding), liquidityCreated);

    bonding.bondToAccount(account, liquidityCreated);

    // If there is any carry / left overs then send to treasury
    uint256 maltBalance = malt.balanceOf(address(this));
    uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));

    if (maltBalance > 0) {
      malt.safeTransfer(treasury, maltBalance);
    }

    if (rewardTokenBalance > 0) {
      rewardToken.safeTransfer(treasury, rewardTokenBalance);
    }
  }

  function setDexHandler(address _dexHandler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dexHandler != address(0), ""Not address 0"");
    dexHandler = IDexHandler(_dexHandler);
    emit SetDexHandler(_dexHandler);
  }

  function setBonding(address _bonding)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_bonding != address(0), ""Not address 0"");
    bonding = IBonding(_bonding);
    emit SetBonding(_bonding);
  }

  function setMiningService(address _miningService)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_miningService != address(0), ""Not address 0"");
    miningService = IMiningService(_miningService);
    emit SetMiningService(_miningService);
  }

  function setTreasury(address _treasury)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_treasury != address(0), ""Not address 0"");
    treasury = _treasury;
    emit SetTreasury(_treasury);
  }
}",1172
RealWorld_TA_59_IDexHandler_RealWorld_20240808103807.log,59,IDexHandler,34454,1450,35904,98.0,0.20127,"pragma solidity >=0.6.6;

interface IDexHandler {
  function buyMalt() external returns (uint256 purchased);
  function sellMalt() external returns (uint256 rewards);
  function addLiquidity() external returns (
    uint256 maltUsed,
    uint256 rewardUsed,
    uint256 liquidityCreated
  );
  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward);
  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256);
  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256);
  function reserves() external view returns (uint256 maltSupply, uint256 rewardSupply);
  function maltMarketPrice() external view returns (uint256 price, uint256 decimals);
  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)
    external view returns (uint256 liquidityA);
}",198
RealWorld_TA_59_PoolTransferVerification_RealWorld_20240808101003.log,59,PoolTransferVerification,85331,3576,88907,136.0,0.498175,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./interfaces/IMaltDataLab.sol"";
import ""./Permissions.sol"";
import ""./AbstractTransferVerification.sol"";


/// @title Pool Transfer Verification
/// @author 0xScotch <scotch@malt.money>
/// @notice Implements ability to block Malt transfers
contract PoolTransferVerification is AbstractTransferVerification, Initializable {
  uint256 public thresholdBps;
  IMaltDataLab public maltDataLab;
  uint256 public priceLookback;
  address public pool;

  mapping(address => bool) public whitelist;

  event AddToWhitelist(address indexed _address);
  event RemoveFromWhitelist(address indexed _address);
  event SetPool(address indexed pool);
  event SetPriceLookback(uint256 lookback);
  event SetThreshold(uint256 newThreshold);

  function initialize(
    address _timelock,
    address initialAdmin,
    uint256 _thresholdBps,
    address _maltDataLab,
    uint256 _lookback,
    address _pool
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    thresholdBps = _thresholdBps;
    maltDataLab = IMaltDataLab(_maltDataLab);
    priceLookback = _lookback;
    pool = _pool;
  }

  function verifyTransfer(address from, address to, uint256 amount) 
    public view override returns (bool, string memory) 
  {
    // This contract only cares about transfers out of the pool
    if (from != pool) {
      return (true, """");
    }

    if (isWhitelisted(to)) {
      return (true, """");
    }

    uint256 priceTarget = maltDataLab.priceTarget();

    return (
      maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,
      ""The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens.""
    );
  }

  function isWhitelisted(address _address) public view returns(bool) {
    return whitelist[_address];
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setThreshold(uint256 newThreshold)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(newThreshold > 0 && newThreshold < 10000, ""Threshold must be between 0-100%"");
    thresholdBps = newThreshold;
    emit SetThreshold(newThreshold);
  }

  function setPriceLookback(uint256 lookback)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(lookback > 0, ""Cannot have 0 lookback"");
    priceLookback = lookback;
    emit SetPriceLookback(lookback);
  }

  function setPool(address _pool)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_pool != address(0), ""Cannot have 0 lookback"");
    pool = _pool;
    emit SetPool(_pool);
  }

  function addToWhitelist(address _address) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"") 
  {
    whitelist[_address] = true;
    emit AddToWhitelist(_address);
  }

  function removeFromWhitelist(address _address) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")  
  {
    if (!whitelist[_address]) {
      return;
    }
    whitelist[_address] = false;
    emit RemoveFromWhitelist(_address);
  }
}",790
RealWorld_TA_59_Create2Deployer_RealWorld_20240808090300.log,59,Create2Deployer,27137,1736,28873,117.0,0.170405,"pragma solidity >=0.6.6;

contract Create2Deployer {
  event Deployed(address addr, uint256 salt);

  function deploy(bytes memory code, uint256 salt) public {
    address addr;
    assembly {
      addr := create2(0, add(code, 0x20), mload(code), salt)
      if iszero(extcodesize(addr)) {
        revert(0, 0)
      }
    }

    emit Deployed(addr, salt);
  }
}",101
RealWorld_TA_59_DAO_RealWorld_20240808090459.log,59,DAO,87076,3761,90837,170.0,0.5106,"pragma solidity >=0.6.6;
pragma experimental ABIEncoderV2;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./interfaces/IBurnMintableERC20.sol"";
import ""./Permissions.sol"";


/// @title Malt DAO
/// @author 0xScotch <scotch@malt.money>
/// @notice In essence a contract that is the oracle for the current epoch
contract MaltDAO is Initializable, Permissions {
  using SafeMath for uint256;

  IBurnMintableERC20 public malt;
  uint256 public epoch = 0;
  uint256 public epochLength;
  uint256 public genesisTime;
  uint256 public advanceIncentive = 100; // 100 Malt

  event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);
  event Mint(address recipient, uint256 amount);
  event SetMaltToken(address maltToken);
  event SetEpochLength(uint256 length);
  event SetAdvanceIncentive(uint256 incentive);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _malt,
    uint256 _epochLength,
    uint256 _genesisTime,
    address offering,
    uint256 offeringMint
  ) external initializer {
    _setMaltToken(_malt);
    _setEpochLength(_epochLength);

    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    genesisTime = _genesisTime;

    if (offeringMint > 0) {
      // Tokens minted to Community Whitelist contract
      malt.mint(offering, offeringMint);
    }
  }

  receive() external payable {}

  function advance() external {
    require(block.timestamp >= getEpochStartTime(epoch + 1), ""Cannot advance epoch until start of new epoch"");

    incrementEpoch();

    malt.mint(msg.sender, advanceIncentive * 1e18);

    emit Advance(epoch, block.number, block.timestamp);
  }

  function getEpochStartTime(uint256 _epoch) public view returns (uint256) {
    return genesisTime.add(epochLength.mul(_epoch));
  }

  function epochsPerYear() public view returns (uint256) {
    // 31557600 = seconds in a year
    return 31557600 / epochLength;
  }

  function mint(address to, uint256 amount)
    public
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    require(amount > 0, ""Cannot have zero amount"");
    malt.mint(to, amount);
    emit Mint(to, amount);
  }

  function setMaltToken(address _malt)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    _setMaltToken(_malt);
  }

  function setEpochLength(uint256 _length)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_length > 0, ""Cannot have zero length epochs"");
    _setEpochLength(_length);
  }

  function setAdvanceIncentive(uint256 incentive)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    advanceIncentive = incentive;
    emit SetAdvanceIncentive(incentive);
  }

  /* Internal methods */
  function incrementEpoch() internal {
    epoch = epoch.add(1);
  }
  
  function _setEpochLength(uint256 length) internal {
    epochLength = length;
    emit SetEpochLength(length);
  }

  function _setMaltToken(address _malt) internal {
    malt = IBurnMintableERC20(_malt);
    emit SetMaltToken(_malt);
  }
}",813
RealWorld_TA_59_ForfeitHandler_RealWorld_20240808093913.log,59,ForfeitHandler,69322,2903,72225,128.0,0.40467,"pragma solidity >=0.6.6;

import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./Permissions.sol"";


/// @title Forfeit Handler
/// @author 0xScotch <scotch@malt.money>
/// @notice When a user unbonds, their unvested rewards are forfeited. This contract decides what to do with those funds
contract ForfeitHandler is Initializable, Permissions {
  ERC20 public rewardToken;
  address public treasuryMultisig;
  address public swingTrader;

  uint256 public swingTraderRewardCut = 500;
  uint256 public treasuryRewardCut = 500;

  event Forfeit(address sender, uint256 amount);
  event SetRewardCut(uint256 treasuryCut, uint256 swingTraderCut);
  event SetTreasury(address treasury);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _treasuryMultisig,
    address _swingTrader
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    rewardToken = ERC20(_rewardToken);
    treasuryMultisig = _treasuryMultisig;
    swingTrader = _swingTrader;
  }

  function handleForfeit() public {
    uint256 balance = rewardToken.balanceOf(address(this));

    if (balance == 0) {
      return;
    }

    uint256 swingTraderCut = balance.mul(swingTraderRewardCut).div(1000);
    uint256 treasuryCut = balance - swingTraderCut;

    if (swingTraderCut > 0) {
      rewardToken.safeTransfer(swingTrader, swingTraderCut);
    }

    if (treasuryCut > 0) {
      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);
    }

    emit Forfeit(msg.sender, balance);
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setRewardCut(
    uint256 _treasuryCut,
    uint256 _swingTraderCut
  )
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_treasuryCut.add(_swingTraderCut) == 1000, ""Reward cut must add to 100%"");

    treasuryRewardCut = _treasuryCut;
    swingTraderRewardCut = _swingTraderCut;

    emit SetRewardCut(_treasuryCut, _swingTraderCut);
  }

  function setTreasury(address _treasury)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_treasury != address(0), ""Cannot set 0 address"");

    treasuryMultisig = _treasury;

    emit SetTreasury(_treasury);
  }
}",594
RealWorld_TA_59_IRewardMine_RealWorld_20240808110512.log,59,IRewardMine,37500,1300,38800,89.0,0.2135,"pragma solidity >=0.6.6;

interface IRewardMine {
  function rewardToken() external view returns (address);
  function onBond(address account, uint256 amount) external;
  function onUnbond(address account, uint256 amount) external;
  function withdrawAll() external;
  function withdraw(uint256 rewardAmount) external;
  function totalBonded() external view returns (uint256);
  function balanceOfBonded(address account) external view returns (uint256);
  function totalDeclaredReward() external view returns (uint256);
  function totalReleasedReward() external view returns (uint256);
  function totalStakePadding() external view returns(uint256);
  function balanceOfStakePadding(address account) external view returns (uint256);
  function getRewardOwnershipFraction(address account) external view returns(uint256 numerator, uint256 denominator);
  function balanceOfRewards(address account) external view returns (uint256);
  function earned(address account) external view returns (uint256 earnedReward);
  function withdrawForAccount(address account, uint256 amount, address to) external returns (uint256);
}",227
RealWorld_TA_59_AuctionBurnReserveSkew_RealWorld_20240808100723.log,59,AuctionBurnReserveSkew,146493,4161,150654,158.0,0.815685,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""./interfaces/IStabilizerNode.sol"";
import ""./Auction.sol"";
import ""./Permissions.sol"";


/// @title Auction Burn Reserve Skew
/// @author 0xScotch <scotch@malt.money>
/// @notice This contract makes decisions about what do to with excess Liquidity Extension balance at the end of an auction. Burn additional Malt or retain capital in LE
contract AuctionBurnReserveSkew is Initializable, Permissions {
  using SafeMath for uint256;

  // An array of 0s or 1s that track if active stabilization was 
  // needed above or below peg.
  // 0 = below peg
  // 1 = above peg
  //
  // By doing this we can average the array to get a value that
  // indicates if we are more frequently over or under peg.
  uint256[] public pegObservations;
  uint256 public auctionAverageLookback = 10;

  IStabilizerNode public stabilizerNode;
  IAuction public auction;

  // This is the total number of stabilization observation we have seen
  uint256 public count;

  event SetAuctionAverageLookback(uint256 lookback);
  event SetStabilizerNode(address stabilizerNode);
  event SetAuction(address auction);
  event AbovePegObservation(uint256 amount);
  event BelowPegObservation(uint256 amount);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _stabilizerNode,
    address _auction,
    uint256 _period
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);
    _setupRole(ADMIN_ROLE, initialAdmin);

    stabilizerNode = IStabilizerNode(_stabilizerNode);
    auction = IAuction(_auction);
    auctionAverageLookback = _period;

    for (uint i = 0; i < _period; i++) {
      pegObservations.push(0);
    }
  }

  function consult(uint256 excess) public view returns (uint256) {
    uint256 frequency = getPegDeltaFrequency();
    uint256 participation = getAverageParticipation();

    // Weight participation higher than frequency
    uint256 skew = (frequency + (participation * 2)) / 3;

    return excess.mul(skew).div(10000);
  }

  function getRealBurnBudget(
    uint256 maxBurnSpend,
    uint256 premiumExcess
  ) public view returns(uint256) {
    // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement
    // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn

    if (premiumExcess > maxBurnSpend) {
      return premiumExcess;
    }

    uint256 usableExcess = maxBurnSpend.sub(premiumExcess);

    if (usableExcess == 0) {
      return premiumExcess;
    }

    uint256 burnable = consult(usableExcess);

    return premiumExcess + burnable;
  }

  function getAverageParticipation() public view returns (uint256) {
    uint256 initialAuction = 0;
    uint256 currentAuctionId = auction.currentAuctionId();

    if (currentAuctionId > auctionAverageLookback) {
      initialAuction = currentAuctionId - auctionAverageLookback;
    }

    // Use the existing struct to avoid filling the stack with temp vars
    AuctionData memory aggregate;

    for (uint256 i = initialAuction; i < currentAuctionId; ++i) {
      (uint256 commitments, uint256 maxCommitments) = auction.getAuctionCommitments(i);
      aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;
      aggregate.commitments = aggregate.commitments + commitments;
    }

    uint256 participation = 0;
    if (aggregate.maxCommitments > 0) {
      participation = aggregate.commitments.mul(10000).div(aggregate.maxCommitments);
    }

    return participation;
  }

  function getPegDeltaFrequency() public view returns (uint256) {
    uint256 initialIndex = 0;
    uint256 index;

    if (count > auctionAverageLookback) {
      initialIndex = count - auctionAverageLookback;
    }

    uint256 total = 0;

    for (uint256 i = initialIndex; i < count; ++i) {
      index = _getIndexOfObservation(i);
      total = total + pegObservations[index];
    }

    return total * 10000 / auctionAverageLookback;
  }

  function _getIndexOfObservation(uint _index) internal view returns (uint index) {
    return _index % auctionAverageLookback;
  }

  /*
   * The arguments passed into these observation functions are not currently used but they are added
   * incase future versions to this contract want to use them. In that case the stabilizernode
   * won't have to be changed as it is already passing in this argument.
   */
  function addAbovePegObservation(uint256 amount)
    public
    onlyRole(STABILIZER_NODE_ROLE, ""Must be a stabilizer node to call this method"")
  {
    uint256 index = _getIndexOfObservation(count);
    // above peg
    pegObservations[index] = 1;

    count = count + 1;
    emit AbovePegObservation(amount);
  }

  function addBelowPegObservation(uint256 amount)
    public
    onlyRole(STABILIZER_NODE_ROLE, ""Must be a stabilizer node to call this method"")
  {
    uint256 index = _getIndexOfObservation(count);
    // below peg
    pegObservations[index] = 0;

    count = count + 1;
    emit BelowPegObservation(amount);
  }

  function setNewStabilizerNode(address _node)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_node != address(0), ""Cannot set 0 address"");
    _swapRole(_node, address(stabilizerNode), STABILIZER_NODE_ROLE);
    stabilizerNode = IStabilizerNode(_node);
    emit SetStabilizerNode(_node);
  }

  function setNewAuction(address _auction)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auction != address(0), ""Cannot set 0 address"");
    auction = IAuction(_auction);
    emit SetAuction(_auction);
  }

  function setAuctionAverageLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have zero lookback period"");

    if (_lookback > auctionAverageLookback) {
      for (uint i = auctionAverageLookback; i < _lookback; i++) {
        pegObservations.push(0);
      }
    }

    auctionAverageLookback = _lookback;
    emit SetAuctionAverageLookback(_lookback);
  }
}",1554
RealWorld_TA_59_RewardDistributor_RealWorld_20240808102607.log,59,RewardDistributor,232282,5581,237863,198.0,1.27303,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../Permissions.sol"";
import ""../interfaces/IBonding.sol"";
import ""../interfaces/IForfeit.sol"";
import ""../interfaces/IRewardMine.sol"";

import ""hardhat/console.sol"";

struct State {
  uint256 declaredBalance;
}

struct FocalPoint {
  uint256 id;
  uint256 focalLength;
  uint256 endTime;

  uint256 rewarded;
  uint256 vested;

  uint256 lastVestingTime;
}

/// @title Reward Vesting Distributor
/// @author 0xScotch <scotch@malt.money>
/// @notice The contract in charge of implementing the focal vesting scheme for rewards
contract RewardDistributor is Initializable, Permissions {
  uint256 public focalID = 1; // Avoid issues with defaulting to 0
  uint256 public focalLength = 2 days;

  bytes32 public constant THROTTLER_ROLE = keccak256(""THROTTLER_ROLE"");
  bytes32 public constant REWARD_MINE_ROLE = keccak256(""REWARD_MINE_ROLE"");
  bytes32 public constant FOCAL_LENGTH_UPDATER_ROLE = keccak256(""FOCAL_LENGTH_UPDATER_ROLE"");

  address public throttler;
  IRewardMine public rewardMine;
  IForfeit public forfeitor;
  ERC20 public rewardToken;
  IBonding public bonding;

  State internal _globals;
  FocalPoint[] internal focalPoints;

  event DeclareReward(
    uint256 amount,
    address rewardToken
  );
  event Forfeit(address account, address rewardToken, uint256 forfeited);
  event RewardFocal(
    uint256 id,
    uint256 focalLength,
    uint256 endTime,
    uint256 rewarded
  );

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardMine,
    address _bonding,
    address _throttler,
    address _forfeitor,
    address _rewardToken
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(FOCAL_LENGTH_UPDATER_ROLE, _timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    _roleSetup(THROTTLER_ROLE, _throttler);
    _roleSetup(FOCAL_LENGTH_UPDATER_ROLE, initialAdmin);
    _roleSetup(REWARD_MINE_ROLE, _rewardMine);

    rewardToken = ERC20(_rewardToken);

    throttler = _throttler;
    rewardMine = IRewardMine(_rewardMine);
    forfeitor = IForfeit(_forfeitor);
    bonding = IBonding(_bonding);

    focalPoints.push();
    focalPoints.push();
  }

  function vest() public {
    if (_globals.declaredBalance == 0) {
      return;
    }
    uint256 vestedReward = 0;

    FocalPoint storage vestingFocal = _getVestingFocal();
    FocalPoint storage activeFocal = _getActiveFocal();

    vestedReward = _getVestableQuantity(vestingFocal);
    uint256 activeReward = _getVestableQuantity(activeFocal);

    vestedReward = vestedReward.add(activeReward);

    // Send vested amount to liquidity mine
    rewardToken.safeTransfer(address(rewardMine), vestedReward);

    // increment focalID if time is past the halfway mark
    // through a focal period
    if (block.timestamp >= _getNextFocalStart(activeFocal)) {
      _incrementFocalPoint();
    }
  }

  /* PUBLIC VIEW FUNCTIONS */
  function totalDeclaredReward() public view returns (uint256) {
    return _globals.declaredBalance;
  }

  /* INTERNAL VIEW FUNCTIONS */
  function _getFocalIndex(uint256 id) internal pure returns (uint8 index) {
    return uint8(id % 2);
  }

  function _getVestingFocal() internal view returns (FocalPoint storage) {
    // Can add 1 as the modulo ensures we wrap correctly
    uint8 index = _getFocalIndex(focalID + 1);
    return focalPoints[index];
  }

  /* INTERNAL FUNCTIONS */
  function _getActiveFocal() internal returns (FocalPoint storage) {
    uint8 index = _getFocalIndex(focalID);
    FocalPoint storage focal = focalPoints[index];

    if (focal.id != focalID) {
      // If id is not focalID then reinitialize the struct
      _resetFocalPoint(focalID, block.timestamp + focalLength);
    }

    return focal;
  }

  function _rewardCheck(uint256 reward) internal {
    require(reward > 0, ""Cannot declare 0 reward"");

    _globals.declaredBalance = _globals.declaredBalance.add(reward);

    uint256 totalReward = rewardToken.balanceOf(address(this)) + rewardMine.totalReleasedReward();

    require(_globals.declaredBalance <= totalReward, ""Insufficient balance"");
  }

  function _forfeit(uint256 forfeited) internal {
    require(forfeited <= _globals.declaredBalance, ""Cannot forfeit more than declared"");

    _globals.declaredBalance = _globals.declaredBalance.sub(forfeited);

    rewardToken.safeTransfer(address(forfeitor), forfeited);
    forfeitor.handleForfeit();

    uint256 totalReward = rewardToken.balanceOf(address(this)) + rewardMine.totalReleasedReward();

    require(_globals.declaredBalance <= totalReward, ""Insufficient balance"");

    emit Forfeit(msg.sender, address(rewardToken), forfeited);
  }

  function _resetFocalPoint(uint256 id, uint256 endTime) internal {
    uint8 index = _getFocalIndex(id);
    FocalPoint storage newFocal = focalPoints[index];
    
    newFocal.id = id;
    newFocal.focalLength = focalLength;
    newFocal.endTime = endTime;
    newFocal.rewarded = 0;
    newFocal.vested = 0;
    newFocal.lastVestingTime = endTime - focalLength;
  }

  function _incrementFocalPoint() internal {
    FocalPoint storage oldFocal = _getActiveFocal();

    // This will increment every 24 hours so overflow on uint256
    // isn't an issue.
    focalID = focalID + 1;

    // Emit event that documents the focalPoint that has just ended
    emit RewardFocal(
      oldFocal.id,
      oldFocal.focalLength,
      oldFocal.endTime,
      oldFocal.rewarded
    );

    uint256 newEndTime = oldFocal.endTime + focalLength / 2;

    _resetFocalPoint(focalID, newEndTime);
  }

  function _getNextFocalStart(FocalPoint storage focal) internal view returns (uint256) {
    return focal.endTime - (focal.focalLength / 2);
  }

  function _getVestableQuantity(FocalPoint storage focal) internal returns (
    uint256 vestedReward
  ) {
    uint256 currentTime = block.timestamp;

    if (focal.lastVestingTime >= currentTime) {
      return 0;
    }

    if (currentTime > focal.endTime) {
      currentTime = focal.endTime;
    }

    // Time in between last vesting call and end of focal period
    uint256 timeRemaining = focal.endTime - focal.lastVestingTime;

    if (timeRemaining == 0) {
      return 0;
    }

    // Time since last vesting call
    uint256 vestedTime = currentTime - focal.lastVestingTime;

    uint256 remainingReward = focal.rewarded - focal.vested;

    vestedReward = remainingReward.mul(vestedTime).div(timeRemaining);

    focal.vested = focal.vested.add(vestedReward);
    focal.lastVestingTime = currentTime;

    return vestedReward;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function declareReward(uint256 amount)
    external
    onlyRole(THROTTLER_ROLE, ""Only throttler role"")
  {
    _rewardCheck(amount);

    if (bonding.totalBonded() == 0) {
      // There is no accounts to distribute the rewards to so forfeit it
      _forfeit(amount);
      return;
    } 

    // Vest current reward before adding new reward to ensure
    // Everything is up to date before we add new reward
    vest();

    FocalPoint storage activeFocal = _getActiveFocal();
    activeFocal.rewarded = activeFocal.rewarded.add(amount);

    emit DeclareReward(amount, address(rewardToken));
  }

  function forfeit(uint256 amount)
    public
    onlyRole(REWARD_MINE_ROLE, ""Only reward mine"")
  {
    if (amount > 0) {
      _forfeit(amount);
    }
  }

  function decrementRewards(uint256 amount)
    public
    onlyRole(REWARD_MINE_ROLE, ""Only reward mine"")
  {
    require(amount <= _globals.declaredBalance, ""Can't decrement more than total reward balance"");

    if (amount > 0) {
      _globals.declaredBalance = _globals.declaredBalance.sub(amount);
    }
  }

  function setFocalLength(uint256 _focalLength)
    public 
    onlyRole(FOCAL_LENGTH_UPDATER_ROLE, ""Only focal length updater"")
  {
    // Cannot have focal length under 1 hour
    require(_focalLength >= 3600, ""Focal length too small"");
    focalLength = _focalLength;
  }

  function setThrottler(address _throttler)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_throttler != address(0), ""Cannot set 0 address as throttler"");
    _swapRole(_throttler, address(throttler), THROTTLER_ROLE);
    throttler = _throttler;
  }

  function setRewardMine(address _rewardMine)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_rewardMine != address(0), ""Cannot set 0 address as rewardMine"");
    _swapRole(_rewardMine, address(rewardMine), REWARD_MINE_ROLE);
    rewardMine = IRewardMine(_rewardMine);
  }

  function setForfeitor(address _forfeitor)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_forfeitor != address(0), ""Cannot set 0 address as forfeitor"");
    forfeitor = IForfeit(_forfeitor);
  }

  function setRewardToken(address _rewardToken)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_rewardToken != address(0), ""Cannot set 0 address as reward Token"");
    rewardToken = ERC20(_rewardToken);
  }

  function setBonding(address _bonding)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_bonding != address(0), ""Cannot set 0 address as bonding"");
    bonding = IBonding(_bonding);
  }

  function addFocalLengthUpdater(address _updater)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_updater != address(0), ""Cannot set 0 address as focal length updater"");
    _roleSetup(FOCAL_LENGTH_UPDATER_ROLE, _updater);
  }

  function removeFocalLengthUpdater(address _updater)
    public 
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    revokeRole(FOCAL_LENGTH_UPDATER_ROLE, _updater);
  }
}",2511
RealWorld_TA_59_ISwingTrader_RealWorld_20240808104502.log,59,ISwingTrader,24534,1869,26403,103.0,0.16005,"pragma solidity >=0.6.6;

interface ISwingTrader {
  function buyMalt(uint256 maxCapital) external returns (uint256 capitalUsed);
  function sellMalt(uint256 maxAmount) external returns (uint256 amountSold);
  function costBasis() external view returns (uint256 cost, uint256 decimals);
}",69
RealWorld_TA_59_IStabilizerNode_RealWorld_20240808104831.log,59,IStabilizerNode,21990,1494,23484,99.0,0.13983,"pragma solidity >=0.6.6;

import ""./IAuction.sol"";

interface IStabilizerNode {
  function stabilize() external;
  function auction() external view returns (IAuction);
}",40
RealWorld_TA_59_IAuctionBurnReserveSkew_RealWorld_20240808112507.log,59,IAuctionBurnReserveSkew,29712,2038,31750,105.0,0.18932,"pragma solidity >=0.6.6;

interface IAuctionBurnReserveSkew {
  function consult(uint256 excess) external view returns (uint256);
  function getAverageParticipation() external view;
  function getPegDeltaFrequency() external view;
  function addAbovePegObservation(uint256 amount) external;
  function addBelowPegObservation(uint256 amount) external;
  function setNewStabilizerNode() external;
  function removeStabilizerNode() external;
  function getRealBurnBudget(
    uint256 maxBurnSpend,
    uint256 premiumExcess
  ) external view returns(uint256);
}",132
RealWorld_TA_59_Malt_RealWorld_20240808091036.log,59,Malt,60921,2608,63529,150.0,0.356765,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""./ERC20Permit.sol"";
import ""./Permissions.sol"";
import ""./interfaces/ITransferService.sol"";


/// @title Malt V2 Token
/// @author 0xScotch <scotch@malt.money>
/// @notice The ERC20 token contract for Malt V2
contract Malt is ERC20Permit, Initializable, Permissions {
  using SafeMath for uint256;

  ITransferService public transferService;

  constructor(string memory name, string memory ticker) public ERC20Permit(name, ticker) {}

  event SetTransferService(address service);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _transferService,
    address[] calldata minters,
    address[] calldata burners
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    transferService = ITransferService(_transferService);

    for (uint256 i = 0; i < minters.length; i = i + 1) {
      _setupRole(MONETARY_MINTER_ROLE, minters[i]);
    }
    for (uint256 i = 0; i < burners.length; i = i + 1) {
      _setupRole(MONETARY_BURNER_ROLE, burners[i]);
    }
  }

  function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {
    (bool success, string memory reason) = transferService.verifyTransfer(from, to, amount);
    require(success, reason);
  }

  function mint(address to, uint256 amount)
    public
    onlyRole(MONETARY_MINTER_ROLE, ""Must have monetary minter role"")
  {
    _mint(to, amount);
  }

  function burn(address from, uint256 amount)
    public
    onlyRole(MONETARY_BURNER_ROLE, ""Must have monetary burner role"")
  {
    _burn(from, amount);
  }

  function setTransferService(address _service)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_service != address(0), ""Cannot use address 0 as transfer service"");
    transferService = ITransferService(_service);
    emit SetTransferService(_service);
  }
}",516
RealWorld_TA_59_MiningService_RealWorld_20240808094821.log,59,MiningService,122029,5770,127799,183.0,0.725545,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IRewardMine.sol"";


/// @title Malt Mining Service
/// @author 0xScotch <scotch@malt.money>
/// @notice A contract that abstracts one or more implementations of AbstractRewardMine
contract MiningService is Initializable, Permissions {
  address[] public mines;
  mapping(address => bool) internal mineActive;
  address public reinvestor;
  address public bonding;

  bytes32 public constant REINVESTOR_ROLE = keccak256(""REINVESTOR_ROLE"");
  bytes32 public constant BONDING_ROLE = keccak256(""BONDING_ROLE"");

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _reinvestor,
    address _bonding
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _roleSetup(REINVESTOR_ROLE, _reinvestor);
    _roleSetup(BONDING_ROLE, _bonding);

    bonding = _bonding;
    reinvestor = _reinvestor;
  }

  function withdrawAccountRewards(uint256 amount)
    public
  {
    _withdrawMultiple(msg.sender, amount);
  }

  function balanceOfRewards(address account) public view returns (uint256) {
    uint256 total;
    for (uint i = 0; i < mines.length; i = i + 1) {
      if (!mineActive[mines[i]]) {
        continue;
      }
      total += IRewardMine(mines[i]).balanceOfRewards(account);
    }

    return total;
  }

  function numberOfMines() public view returns(uint256) {
    return mines.length;
  }

  function isMineActive(address mine) public view returns(bool) {
    return mineActive[mine];
  }

  function earned(address account) public view returns (uint256) {
    uint256 total;

    for (uint i = 0; i < mines.length; i = i + 1) {
      if (!mineActive[mines[i]]) {
        continue;
      }
      total += IRewardMine(mines[i]).earned(account);
    }

    return total;
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function onBond(address account, uint256 amount)
    public
    onlyRole(BONDING_ROLE, ""Must have bonding privs"")
  {
    for (uint i = 0; i < mines.length; i = i + 1) {
      IRewardMine mine = IRewardMine(mines[i]);
      mine.onBond(account, amount);
    }
  }

  function onUnbond(address account, uint256 amount)
    public
    onlyRole(BONDING_ROLE, ""Must have bonding privs"")
  {
    for (uint i = 0; i < mines.length; i = i + 1) {
      IRewardMine mine = IRewardMine(mines[i]);
      mine.onUnbond(account, amount);
    }
  }

  function setReinvestor(address _reinvestor)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_reinvestor != address(0), ""Cannot use address 0"");
    _swapRole(_reinvestor, reinvestor, REINVESTOR_ROLE);
    reinvestor = _reinvestor;
  }

  function setBonding(address _bonding)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_bonding != address(0), ""Cannot use address 0"");
    _swapRole(_bonding, bonding, REINVESTOR_ROLE);
    bonding = _bonding;
  }

  function addRewardMine(address mine)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    if (mineActive[mine]) {
      return;
    }
    mineActive[mine] = true;

    mines.push(mine);
  }

  function removeRewardMine(address mine)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    if (!mineActive[mine]) {
      return;
    }
    mineActive[mine] = false;

    // Loop until the second last element
    for (uint i = 0; i < mines.length - 1; i = i + 1) {
      if (mines[i] == mine) {
        // Replace the current item with the last and pop the last away.
        mines[i] = mines[mines.length - 1];
        mines.pop();
        return;
      }
    }

    // If we made it here then the mine being removed is the last item
    mines.pop();
  }

  function withdrawRewardsForAccount(address account, uint256 amount)
    public
    onlyRole(REINVESTOR_ROLE, ""Must have reinvestor privs"")
  {
    _withdrawMultiple(account, amount);
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _withdrawMultiple(address account, uint256 amount) internal {
    for (uint i = 0; i < mines.length; i = i + 1) {
      if (!mineActive[mines[i]]) {
        continue;
      }

      uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);

      amount = amount.sub(withdrawnAmount);

      if (amount == 0) {
        break;
      }
    }
  }
}",1213
RealWorld_TA_59_IBurnMintableERC20_RealWorld_20240808105012.log,59,IBurnMintableERC20,72800,1334,74134,92.0,0.39068,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IBurnMintableERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    function decimals() external view returns (uint256);

    function burn(address account, uint256 amount) external;
    function mint(address account, uint256 amount) external;

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",656
RealWorld_TA_59_Auction_RealWorld_20240808100254.log,59,Auction,641208,7189,648397,266.0,3.34982,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/IMaltDataLab.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/ILiquidityExtension.sol"";
import ""./interfaces/IImpliedCollateralService.sol"";
import ""./interfaces/IAuctionBurnReserveSkew.sol"";
import ""./interfaces/IAuctionStartController.sol"";


struct AccountCommitment {
  uint256 commitment;
  uint256 redeemed;
  uint256 maltPurchased;
}

struct AuctionData {
  // The full amount of commitments required to return to peg
  uint256 fullRequirement;
  // total maximum desired commitments to this auction
  uint256 maxCommitments;
  // Quantity of sale currency committed to this auction
  uint256 commitments;
  // Malt purchased and burned using current commitments
  uint256 maltPurchased;
  // Desired starting price for the auction
  uint256 startingPrice;
  // Desired lowest price for the arbitrage token
  uint256 endingPrice;
  // Price of arbitrage tokens at conclusion of auction. This is either
  // when the duration elapses or the maxCommitments is reached
  uint256 finalPrice;
  // The peg price for the liquidity pool
  uint256 pegPrice;
  // Time when auction started
  uint256 startingTime;
  uint256 endingTime;
  // Is the auction currently accepting commitments?
  bool active;
  // The reserve ratio at the start of the auction
  uint256 preAuctionReserveRatio;
  // Has this auction been finalized? Meaning any additional stabilizing
  // has been done
  bool finalized;
  // The amount of arb tokens that have been executed and are now claimable
  uint256 claimableTokens;
  // The finally calculated realBurnBudget
  uint256 finalBurnBudget;
  // The amount of Malt purchased with realBurnBudget
  uint256 finalPurchased;
  // A map of all commitments to this auction by specific accounts
  mapping(address => AccountCommitment) accountCommitments;
}


/// @title Malt Arbitrage Auction
/// @author 0xScotch <scotch@malt.money>
/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here
contract Auction is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(""AUCTION_AMENDER_ROLE"");

  address public stabilizerNode;
  address public amender;
  IMaltDataLab public maltDataLab;
  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  IDexHandler public dexHandler;
  ILiquidityExtension public liquidityExtension;
  IImpliedCollateralService public impliedCollateralService;
  IAuctionBurnReserveSkew public auctionBurnReserveSkew;

  uint256 public unclaimedArbTokens;
  uint256 public replenishingAuctionId;
  uint256 public currentAuctionId;
  uint256 public claimableArbitrageRewards;
  uint256 public nextCommitmentId;
  uint256 public auctionLength = 600; // 10 minutes
  uint256 public arbTokenReplenishSplit = 7000; // 70%
  uint256 public maxAuctionEnd = 900; // 90% of target price
  uint256 public auctionEndReserveBps = 900; // 90% of collateral
  uint256 public priceLookback = 2 minutes;
  uint256 public reserveRatioLookback = 30; // 30 seconds
  uint256 public dustThreshold = 1e4;

  address public auctionStartController;

  mapping (uint256 => AuctionData) internal idToAuction;
  mapping(address => uint256[]) internal accountCommitmentEpochs;

  event AuctionCommitment(
    uint256 commitmentId,
    uint256 auctionId,
    address account,
    uint256 commitment,
    uint256 purchased
  );

  event ClaimArbTokens(
    uint256 auctionId,
    address account,
    uint256 amountTokens
  );

  event AuctionEnded(
    uint256 id,
    uint256 commitments,
    uint256 startingPrice,
    uint256 finalPrice,
    uint256 maltPurchased
  );

  event AuctionStarted(
    uint256 id,
    uint256 maxCommitments,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 startingTime,
    uint256 endingTime
  );

  event ArbTokenAllocation(
    uint256 replenishingAuctionId,
    uint256 maxArbAllocation
  );

  event SetAuctionLength(uint256 length);
  event SetStabilizerNode(address stabilizerNode);
  event SetMaltDataLab(address dataLab);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    uint256 _auctionLength,
    address _stabilizerNode,
    address _maltDataLab,
    address _dexHandler,
    address _liquidityExtension,
    address _impliedCollateralService,
    address _auctionBurnReserveSkew,
    address _amender
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);
    _roleSetup(AUCTION_AMENDER_ROLE, _amender);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auctionLength = _auctionLength;
    stabilizerNode = _stabilizerNode;
    maltDataLab = IMaltDataLab(_maltDataLab);
    dexHandler = IDexHandler(_dexHandler);
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);
    amender = _amender;
  }

  /*
   * PUBLIC METHODS
   */
  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {
    require(auctionActive(currentAuctionId), ""No auction running"");

    uint256 realCommitment = _capCommitment(currentAuctionId, amount);

    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);

    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);
    
    AuctionData storage auction = idToAuction[currentAuctionId];

    require(auction.startingTime <= now, ""Auction hasn't started yet"");
    require(auction.endingTime >= now, ""Auction is already over"");
    require(auction.active == true, ""Auction is not active"");

    auction.commitments = auction.commitments.add(realCommitment);

    if (auction.accountCommitments[msg.sender].commitment == 0) {
      accountCommitmentEpochs[msg.sender].push(currentAuctionId);
    }
    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);
    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);
    auction.maltPurchased = auction.maltPurchased.add(purchased);

    emit AuctionCommitment(
      nextCommitmentId,
      currentAuctionId,
      msg.sender,
      realCommitment,
      purchased
    );

    nextCommitmentId = nextCommitmentId + 1;

    if (auction.commitments >= auction.maxCommitments) {
      _endAuction(currentAuctionId) ;
    }
  }

  function claimArbitrage(uint256 _auctionId) external notSameBlock {
    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);

    require(amountTokens > 0, ""No claimable Arb tokens"");

    AuctionData storage auction = idToAuction[_auctionId];

    require(!auction.active, ""Cannot claim tokens on an active auction"");

    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];

    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);
    uint256 remaining = commitment.commitment.sub(commitment.redeemed);

    require(redemption <= remaining.add(1), ""Cannot claim more tokens than available"");

    commitment.redeemed = commitment.redeemed.add(redemption);

    // Unclaimed represents total outstanding, but not necessarily
    // claimable yet.
    // claimableArbitrageRewards represents total amount that is now
    // available to be claimed
    if (amountTokens > unclaimedArbTokens) {
      unclaimedArbTokens = 0;
    } else {
      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);
    }

    if (amountTokens > claimableArbitrageRewards) {
      claimableArbitrageRewards = 0;
    } else {
      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);
    }

    collateralToken.safeTransfer(msg.sender, amountTokens);

    emit ClaimArbTokens(
      _auctionId,
      msg.sender,
      amountTokens
    );
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function isAuctionFinished(uint256 _id) public view returns(bool) {
    AuctionData storage auction = idToAuction[_id];

    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);
  }

  function auctionActive(uint256 _id) public view returns (bool) {
    AuctionData storage auction = idToAuction[_id];
    
    return auction.active && now >= auction.startingTime;
  }

  function isAuctionFinalized(uint256 _id) public view returns (bool) {
    AuctionData storage auction = idToAuction[_id];
    return auction.finalized;
  }

  function userClaimableArbTokens(
    address account,
    uint256 auctionId
  ) public view returns (uint256) {
    AuctionData storage auction = idToAuction[auctionId];

    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {
      return 0;
    }

    AccountCommitment storage commitment = auction.accountCommitments[account];

    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);


    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);

    uint256 price = auction.finalPrice;

    if (auction.finalPrice == 0) {
      price = currentPrice(auctionId);
    }

    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);
    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);

    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);

    // Avoid leaving dust behind
    if (amountOut < dustThreshold) {
      return 0;
    }

    return amountOut;
  }

  function balanceOfArbTokens(
    uint256 _auctionId,
    address account
  ) public view returns (uint256) {
    AuctionData storage auction = idToAuction[_auctionId];

    AccountCommitment storage commitment = auction.accountCommitments[account];

    uint256 remaining = commitment.commitment.sub(commitment.redeemed);

    uint256 price = auction.finalPrice;

    if (auction.finalPrice == 0) {
      price = currentPrice(_auctionId);
    }

    return remaining.mul(auction.pegPrice).div(price);
  }

  function averageMaltPrice(uint256 _id) external view returns (uint256) {
    AuctionData storage auction = idToAuction[_id];

    if (auction.maltPurchased == 0) {
      return 0;
    }

    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);
  }

  function currentPrice(uint256 _id) public view returns (uint256) {
    AuctionData storage auction = idToAuction[_id];

    if (auction.startingTime == 0) {
      return maltDataLab.priceTarget();
    }

    uint256 secondsSinceStart = 0;

    if (now > auction.startingTime) {
      secondsSinceStart = now - auction.startingTime;
    }

    uint256 auctionDuration = auction.endingTime - auction.startingTime;

    if (secondsSinceStart >= auctionDuration) {
      return auction.endingPrice;
    }

    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);

    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);

    return auction.startingPrice.sub(currentPriceDelta);
  }

  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {
    AuctionData storage auction = idToAuction[_id];

    return (auction.commitments, auction.maxCommitments);
  }

  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {
    AuctionData storage auction = idToAuction[_id];

    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);
  }

  function auctionExists(uint256 _id) public view returns (bool) {
    AuctionData storage auction = idToAuction[_id];

    return auction.startingTime > 0;
  }

  function getAccountCommitments(address account) external view returns (
    uint256[] memory auctions,
    uint256[] memory commitments,
    uint256[] memory awardedTokens,
    uint256[] memory redeemedTokens,
    uint256[] memory finalPrice,
    uint256[] memory claimable,
    bool[] memory finished
  ) {
    uint256[] memory epochCommitments = accountCommitmentEpochs[account];

    auctions = new uint256[](epochCommitments.length);
    commitments = new uint256[](epochCommitments.length);
    awardedTokens = new uint256[](epochCommitments.length);
    redeemedTokens = new uint256[](epochCommitments.length);
    finalPrice = new uint256[](epochCommitments.length);
    claimable = new uint256[](epochCommitments.length);
    finished = new bool[](epochCommitments.length);

    for (uint i = 0; i < epochCommitments.length; ++i) {
      AuctionData storage auction = idToAuction[epochCommitments[i]];

      AccountCommitment storage commitment = auction.accountCommitments[account];

      uint256 price = auction.finalPrice;

      if (auction.finalPrice == 0) {
        price = currentPrice(epochCommitments[i]);
      }

      auctions[i] = epochCommitments[i];
      commitments[i] = commitment.commitment;
      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);
      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);
      finalPrice[i] = price;
      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);
      finished[i] = isAuctionFinished(epochCommitments[i]);
    }
  }

  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {
    return accountCommitmentEpochs[account];
  }

  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (
    uint256 commitment,
    uint256 redeemed,
    uint256 maltPurchased
  ) {
    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];

    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);
  }

  function getActiveAuction() external view returns (
    uint256 auctionId,
    uint256 maxCommitments,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  ) {
    AuctionData storage auction = idToAuction[currentAuctionId];

    return (
      currentAuctionId,
      auction.maxCommitments,
      auction.commitments,
      auction.maltPurchased,
      auction.startingPrice,
      auction.endingPrice,
      auction.finalPrice,
      auction.pegPrice,
      auction.startingTime,
      auction.endingTime,
      auction.finalBurnBudget,
      auction.finalPurchased
    );
  }

  function getAuction(uint256 _id) public view returns (
    uint256 fullRequirement,
    uint256 maxCommitments,
    uint256 commitments,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  ) {
    AuctionData storage auction = idToAuction[_id];

    return (
      auction.fullRequirement,
      auction.maxCommitments,
      auction.commitments,
      auction.startingPrice,
      auction.endingPrice,
      auction.finalPrice,
      auction.pegPrice,
      auction.startingTime,
      auction.endingTime,
      auction.finalBurnBudget,
      auction.finalPurchased
    );
  }

  function getAuctionCore(uint256 _id) public view returns (
    uint256 auctionId,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 preAuctionReserveRatio,
    bool active
  ) {
    AuctionData storage auction = idToAuction[_id];

    return (
      _id,
      auction.commitments,
      auction.maltPurchased,
      auction.startingPrice,
      auction.finalPrice,
      auction.pegPrice,
      auction.startingTime,
      auction.endingTime,
      auction.preAuctionReserveRatio,
      auction.active
    );
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _triggerAuction(
    uint256 pegPrice,
    uint256 rRatio,
    uint256 purchaseAmount
  ) internal {
    if (auctionStartController != address(0)) {
      bool success = IAuctionStartController(auctionStartController).checkForStart();
      if (!success) {
        return;
      }
    }
    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);

    AuctionData memory auction = AuctionData(
      purchaseAmount, // fullRequirement
      purchaseAmount, // maxCommitments
      0, // commitments
      0, // maltPurchased
      startingPrice,
      endingPrice,
      0, // finalPrice
      pegPrice,
      now, // startingTime
      now.add(auctionLength), // endingTime
      true, // active
      rRatio, // preAuctionReserveRatio
      false, // finalized
      0, // claimableTokens
      0, // finalBurnBudget
      0 // finalPurchased
    );

    _createAuction(
      currentAuctionId,
      auction
    );
  }

  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {
    AuctionData storage auction = idToAuction[_id];

    realCommitment = _commitment;

    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {
      realCommitment = auction.maxCommitments.sub(auction.commitments);
    }
  }

  function _endAuction(uint256 _id) internal {
    AuctionData storage auction = idToAuction[_id];

    require(auction.active == true, ""Auction is already over"");

    auction.active = false;
    auction.finalPrice = currentPrice(_id);

    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);
    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);

    emit AuctionEnded(
      _id,
      auction.commitments,
      auction.startingPrice,
      auction.finalPrice,
      auction.maltPurchased
    );
  }

  function _finalizeAuction(uint256 auctionId) internal {
    (
      uint256 avgMaltPrice,
      uint256 commitments,
      uint256 fullRequirement,
      uint256 maltPurchased,
      uint256 finalPrice,
      uint256 preAuctionReserveRatio
    ) = _setupAuctionFinalization(auctionId);

    if (commitments >= fullRequirement) {
      return;
    }

    uint256 priceTarget = maltDataLab.priceTarget();

    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token
    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal
    // (commitments * 1/maxDeficit) - commitments
    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);

    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);

    uint256 premiumExcess = 0;

    // The assumption here is that each token will be worth 1 Malt when redeemed.
    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth
    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.
    if (totalTokens >= maltPurchased) {
      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.
      // So the premium excess will actually ensure slight net negative supply growth.
      premiumExcess = totalTokens - maltPurchased;
    }

    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);

    if (realBurnBudget > 0) {
      AuctionData storage auction = idToAuction[auctionId];

      auction.finalBurnBudget = realBurnBudget;
      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);
    }
  }

  function _setupAuctionFinalization(uint256 auctionId)
    internal
    returns (
      uint256 avgMaltPrice,
      uint256 commitments,
      uint256 fullRequirement,
      uint256 maltPurchased,
      uint256 finalPrice,
      uint256 preAuctionReserveRatio
    )
  {
    AuctionData storage auction = idToAuction[auctionId];
    require(auction.startingTime > 0, ""No auction available for the given id"");

    auction.finalized = true;

    if (auction.maltPurchased > 0) {
      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);
    }
    
    return (
      avgMaltPrice,
      auction.commitments,
      auction.fullRequirement,
      auction.maltPurchased,
      auction.finalPrice,
      auction.preAuctionReserveRatio
    );
  }

  function _createAuction(
    uint256 _id,
    AuctionData memory auction
  ) internal {
    require(auction.endingTime == uint256(uint64(auction.endingTime)));

    idToAuction[_id] = auction;

    emit AuctionStarted(
      _id,
      auction.maxCommitments,
      auction.startingPrice,
      auction.endingPrice,
      auction.startingTime,
      auction.endingTime
    );
  }

  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {
    uint256 realBurn = purchaseAmount.mul(
      Math.min(
        rRatio,
        10**decimals
      )
    ).div(10**decimals);

    return purchaseAmount.sub(realBurn);
  }

  function _calculateAuctionPricing(uint256 rRatio) internal view returns (
    uint256 startingPrice,
    uint256 endingPrice
  ) {
    startingPrice = maltDataLab.maltPriceAverage(priceLookback);

    if (startingPrice < rRatio) {
      startingPrice = rRatio;
    }

    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT

    // rRatio should never be large enough for this to overflow
    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0

    // This should always be true
    if (priceTarget > rRatio) {
      idealBottom = priceTarget - rRatio;
    }

    assert(priceTarget >= startingPrice);
    assert(startingPrice > endingPrice);

    if (idealBottom < startingPrice) {
      endingPrice = idealBottom;
    } else {
      endingPrice = absoluteBottom;
    } 

    // priceTarget should never be large enough to overflow here
    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;

    if (endingPrice > maxPrice) {
      endingPrice = maxPrice;
    }
  }

  function _checkAuctionFinalization(bool isInternal) internal {
    if (isInternal && !isAuctionFinished(currentAuctionId)) {
      // Auction is still in progress after internal auction purchasing.
      _resetAuctionMaxCommitments();
    }

    if (isAuctionFinished(currentAuctionId)) {
      if (auctionActive(currentAuctionId)) {
        _endAuction(currentAuctionId);
      }

      if (!isAuctionFinalized(currentAuctionId)) {
        _finalizeAuction(currentAuctionId);
      }
      currentAuctionId = currentAuctionId + 1;
    }
  }

  function _resetAuctionMaxCommitments() internal {
    AuctionData storage auction = idToAuction[currentAuctionId];

    uint256 decimals = collateralToken.decimals();

    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);

    if (auction.commitments <= realMaxRaise) {
      auction.maxCommitments = realMaxRaise;
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function checkAuctionFinalization()
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
  {
    _checkAuctionFinalization(false);
  }

  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)
    external
    onlyRole(AUCTION_AMENDER_ROLE, ""Only auction amender"")
  {
    AuctionData storage auction = idToAuction[auctionId];
    require(auction.accountCommitments[account].commitment >= amount, ""amend: amount underflows"");
    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, ""amend: maltPurchase underflows"");

    auction.commitments = auction.commitments - amount;
    auction.maltPurchased = auction.maltPurchased - maltPurchase;

    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; 
    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;

    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);

    if (amountArbTokens > unclaimedArbTokens) {
      unclaimedArbTokens = 0;
    } else {
      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);
    }
  }

  function allocateArbRewards(uint256 rewarded)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
    returns (uint256)
  {
    AuctionData storage auction = idToAuction[replenishingAuctionId];

    if (auction.finalPrice == 0 || auction.startingTime == 0) {
      return rewarded;
    }

    if (auction.commitments == 0) {
      replenishingAuctionId = replenishingAuctionId + 1;
      return rewarded;
    }

    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);

    if (auction.claimableTokens < totalTokens) {
      uint256 requirement = totalTokens.sub(auction.claimableTokens);
      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);

      if (requirement >= maxArbAllocation) {
        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);
        rewarded = rewarded.sub(maxArbAllocation);
        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);

        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);

        emit ArbTokenAllocation(
          replenishingAuctionId,
          maxArbAllocation
        );
      } else {
        auction.claimableTokens = auction.claimableTokens.add(requirement);
        rewarded = rewarded.sub(requirement);
        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);

        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);

        emit ArbTokenAllocation(
          replenishingAuctionId,
          requirement
        );
      }

      if (auction.claimableTokens == totalTokens) {
        uint256 count = 1;

        while (true) {
          auction = idToAuction[replenishingAuctionId + count];

          if (auction.commitments > 0 || !auction.finalized) {
            replenishingAuctionId = replenishingAuctionId + count;
            break;
          }
          count += 1;
        }
      }
    }

    return rewarded;
  }

  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
  {
    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {
      return;
    }

    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);

    _triggerAuction(pegPrice, rRatio, purchaseAmount);

    impliedCollateralService.handleDeficit(purchaseAmount);

    _checkAuctionFinalization(true);
  }

  function setAuctionLength(uint256 _length)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_length > 0, ""Length must be larger than 0"");
    auctionLength = _length;
    emit SetAuctionLength(_length);
  }

  function setStabilizerNode(address _stabilizerNode)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);
    stabilizerNode = _stabilizerNode;
    emit SetStabilizerNode(_stabilizerNode);
  }

  function setMaltDataLab(address _dataLab)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    maltDataLab = IMaltDataLab(_dataLab);
    emit SetMaltDataLab(_dataLab);
  }

  function setAuctionReplenishId(uint256 _id)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    replenishingAuctionId = _id;
  }

  function setDexHandler(address _handler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    dexHandler = IDexHandler(_handler);
  }

  function setLiquidityExtension(address _liquidityExtension)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
  }

  function setImpliedCollateralService(address _impliedCollateralService)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
  }

  function setAuctionBurnReserveSkew(address _reserveSkew)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);
  }

  function setAuctionAmender(address _amender)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_amender != address(0), ""Cannot set 0 address"");
    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);
    amender = _amender;
  }

  function setAuctionStartController(address _controller)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    // This is allowed to be set to address(0) as its checked before calling methods on it
    auctionStartController = _controller;
  }

  function setTokenReplenishSplit(uint256 _split)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_split > 0 && _split <= 10000, ""Must be between 0-100%"");
    arbTokenReplenishSplit = _split;
  }

  function setMaxAuctionEnd(uint256 _maxEnd)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_maxEnd > 0 && _maxEnd <= 1000, ""Must be between 0-100%"");
    maxAuctionEnd = _maxEnd;
  }

  function setPriceLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_lookback > 0, ""Must be above 0"");
    priceLookback = _lookback;
  }

  function setReserveRatioLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_lookback > 0, ""Must be above 0"");
    reserveRatioLookback = _lookback;
  }

  function setAuctionEndReserveBps(uint256 _bps)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_bps > 0 && _bps < 1000, ""Must be between 0-100%"");
    auctionEndReserveBps = _bps;
  }

  function setDustThreshold(uint256 _threshold)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_threshold > 0, ""Must be between greater than 0"");
    dustThreshold = _threshold;
  }
}",7604
RealWorld_TA_59_AuctionParticipant_RealWorld_20240808095311.log,59,AuctionParticipant,98393,6483,104876,190.0,0.621625,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";


/// @title Auction Participant
/// @author 0xScotch <scotch@malt.money>
/// @notice Will generally be inherited to give another contract the ability to use its capital to buy arbitrage tokens
contract AuctionParticipant is Permissions {
  bytes32 public constant IMPLIED_COLLATERAL_SERVICE_ROLE = keccak256(""IMPLIED_COLLATERAL_SERVICE_ROLE"");

  IAuction public auction;
  ERC20 public auctionRewardToken;

  uint256 public replenishingIndex;
  uint256[] public auctionIds;
  uint256 public claimableRewards;

  bool internal setupCompleted;

  function setupParticipant(
    address _impliedCollateralService,
    address _rewardToken,
    address _auction
  ) public {
    require(!setupCompleted, ""Can only call setup once"");

    _roleSetup(IMPLIED_COLLATERAL_SERVICE_ROLE, _impliedCollateralService);
    auctionRewardToken = ERC20(_rewardToken);
    auction = IAuction(_auction);

    setupCompleted = true;
  }

  function purchaseArbitrageTokens(uint256 maxAmount)
    external
    onlyRole(IMPLIED_COLLATERAL_SERVICE_ROLE, ""Must have implied collateral service privs"")
    returns (uint256 remaining)
  {
    uint256 balance = usableBalance();

    if (maxAmount < balance) {
      balance = maxAmount;
    }

    uint256 currentAuction = auction.currentAuctionId();
    
    if (!auction.auctionActive(currentAuction)) {
      return maxAmount;
    }

    auctionIds.push(currentAuction);

    auctionRewardToken.approve(address(auction), balance);
    auction.purchaseArbitrageTokens(balance);
    
    return maxAmount - balance;
  }

  function claim() external {
    if (auctionIds.length == 0 || replenishingIndex >= auctionIds.length) {
      return;
    }

    uint256 auctionId = auctionIds[replenishingIndex];
    uint256 replenishingId = auction.replenishingAuctionId();

    if (auctionId > replenishingId) {
      // Not yet replenishing this auction
      return;
    }
    uint256 claimableTokens = auction.userClaimableArbTokens(address(this), auctionId);

    if (claimableTokens == 0) {
      // Nothing to claim yet
      return;
    }

    uint256 balance = auctionRewardToken.balanceOf(address(this));

    auction.claimArbitrage(auctionId);

    uint256 finalBalance = auctionRewardToken.balanceOf(address(this));
    uint256 rewardedAmount = finalBalance - balance;

    claimableRewards = claimableRewards.add(rewardedAmount);

    uint256 claimable = auction.userClaimableArbTokens(address(this), auctionId);

    if (replenishingId > auctionId && claimable == 0) {
      // Don't increment replenishingIndex if replenishingAuctionId == auctionId as
      // claimable could be 0 due to the debt not being 100% replenished.
      replenishingIndex = replenishingIndex + 1;
    }

    _handleRewardDistribution(rewardedAmount);
  }

  function outstandingArbTokens() public view returns (uint256 outstanding) {
    outstanding = 0;

    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) {
      uint256 claimable = auction.balanceOfArbTokens(
        auctionIds[i],
        address(this)
      );

      outstanding = outstanding + claimable;
    }

    return outstanding;
  }

  function getAllAuctionIds() public view returns (uint256[] memory) {
    return auctionIds;
  }

  function usableBalance() virtual public view returns(uint256) {
    return auctionRewardToken.balanceOf(address(this));
  }

  function _handleRewardDistribution(uint256 rewarded) virtual internal {
    // Do nothing
    return;
  }

  function setReplenishingIndex(uint256 _index)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_index > replenishingIndex, ""Cannot replenishingIndex to old value"");
    replenishingIndex = _index;
  }
}",925
RealWorld_TA_59_IDAO_RealWorld_20240808105535.log,59,IDAO,26590,1399,27989,100.0,0.16093,"pragma solidity >=0.6.6;

interface IDAO {
  function epoch() external view returns (uint256);
  function epochLength() external view returns (uint256);
  function genesisTime() external view returns (uint256);
  function getEpochStartTime(uint256 _epoch) external view returns (uint256);
  function getLockedMalt(address account) external view returns (uint256);
  function epochsPerYear() external view returns (uint256);
}",95
RealWorld_TA_59_IRewardThrottle_RealWorld_20240808113016.log,59,IRewardThrottle,26700,1734,28434,102.0,0.16818,"pragma solidity >=0.6.6;

interface IRewardThrottle {
  function handleReward() external;
  function epochAPR(uint256 epoch) external view returns (uint256);
  function targetAPR() external view returns (uint256);
  function epochData(uint256 epoch) external view returns (
    uint256 profit,
    uint256 rewarded,
    uint256 bondedValue,
    uint256 throttle
  );
  function checkRewardUnderflow() external;
}",96
RealWorld_TA_59_StabilizerNode_RealWorld_20240808092129.log,59,StabilizerNode,385714,6973,392687,253.0,2.06803,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IMaltDataLab.sol"";
import ""./interfaces/IDAO.sol"";
import ""./interfaces/IRewardThrottle.sol"";
import ""./interfaces/IAuctionBurnReserveSkew.sol"";
import ""./interfaces/ILiquidityExtension.sol"";
import ""./interfaces/IImpliedCollateralService.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/ISwingTrader.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/ISupplyDistributionController.sol"";
import ""./interfaces/IAuctionStartController.sol"";


/// @title Stabilizer Node
/// @author 0xScotch <scotch@malt.money>
/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price
contract StabilizerNode is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  uint256 internal stabilizeWindowEnd;
  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes
  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%
  uint256 public lowerStabilityThreshold = (10**18) / 100;
  uint256 public maxContributionBps = 70;
  uint256 public priceAveragePeriod = 5 minutes;
  uint256 public fastAveragePeriod = 30; // 30 seconds
  uint256 public overrideDistance = 20; // 2%

  uint256 public expansionDampingFactor = 1;

  uint256 public defaultIncentive = 100;

  uint256 public daoRewardCut;
  uint256 public lpRewardCut = 417;
  uint256 public auctionPoolRewardCut = 113;
  uint256 public swingTraderRewardCut = 417;
  uint256 public treasuryRewardCut = 50;
  uint256 public callerRewardCut = 3;

  uint256 public lastStabilize;

  ERC20 public rewardToken;
  IBurnMintableERC20 public malt;
  IAuction public auction;
  IDexHandler public dexHandler;
  IDAO public dao;
  address public uniswapV2Factory;
  ILiquidityExtension public liquidityExtension;
  IMaltDataLab public maltDataLab;
  IAuctionBurnReserveSkew public auctionBurnReserveSkew;
  IRewardThrottle public rewardThrottle;
  ISwingTrader public swingTrader;
  IImpliedCollateralService public impliedCollateralService;

  address payable public treasuryMultisig;
  address public auctionPool;
  address public supplyDistributionController;
  address public auctionStartController;

  event MintMalt(uint256 amount);
  event Stabilize(uint256 timestamp, uint256 exchangeRate);
  event RewardDistribution(uint256 rewarded);
  event SetAnnualYield(uint256 yield);
  event SetStabilizeBackoff(uint256 period);
  event SetAuctionBurnSkew(address auctionBurnReserveSkew);
  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);
  event SetTreasury(address newTreasury);
  event SetDefaultIncentive(uint256 incentive);
  event SetExpansionDamping(uint256 amount);
  event SetNewMaltDataLab(address dataLab);
  event SetAuctionContract(address auction);
  event SetDexHandler(address dexHandler);
  event SetDao(address dao);
  event SetLiquidityExtension(address liquidityExtension);
  event SetRewardThrottle(address rewardThrottle);
  event SetSwingTrader(address swingTrader);
  event SetPriceAveragePeriod(uint256 period);
  event SetOverrideDistance(uint256 distance);
  event SetFastAveragePeriod(uint256 period);
  event SetStabilityThresholds(uint256 upper, uint256 lower);
  event SetAuctionPool(address auctionPool);
  event SetMaxContribution(uint256 maxContribution);
  event SetImpliedCollateralService(address impliedCollateralService);
  event SetSupplyDistributionController(address _controller);
  event SetAuctionStartController(address _controller);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _malt,
    address _auction,
    address _uniswapV2Factory,
    address payable _treasuryMultisig,
    address _auctionPool
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(AUCTION_ROLE, _auction);

    rewardToken = ERC20(_rewardToken);
    malt = IBurnMintableERC20(_malt);
    auction = IAuction(_auction);

    uniswapV2Factory = _uniswapV2Factory;
    treasuryMultisig = _treasuryMultisig;
    auctionPool = _auctionPool;

    lastStabilize = block.timestamp;
  }

  function setupContracts(
    address _dexHandler,
    address _maltDataLab,
    address _auctionBurnReserveSkew,
    address _rewardThrottle,
    address _dao,
    address _swingTrader,
    address _liquidityExtension,
    address _impliedCollateralService
  ) external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    dexHandler = IDexHandler(_dexHandler);
    maltDataLab = IMaltDataLab(_maltDataLab);
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);
    rewardThrottle = IRewardThrottle(_rewardThrottle);
    dao = IDAO(_dao);
    swingTrader = ISwingTrader(_swingTrader);
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
  }

  function stabilize() external notSameBlock {
    auction.checkAuctionFinalization();

    require(
      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),
      ""Can't call stabilize""
    );
    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;

    rewardThrottle.checkRewardUnderflow();

    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);

    if (!_shouldAdjustSupply(exchangeRate)) {
      maltDataLab.trackReserveRatio();

      lastStabilize = block.timestamp;
      return;
    }

    emit Stabilize(block.timestamp, exchangeRate);

    if (exchangeRate > maltDataLab.priceTarget()) {
      _distributeSupply();
    } else {
      _startAuction();
    }

    lastStabilize = block.timestamp;
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _stabilityWindowOverride() internal view returns (bool) {
    if (hasRole(ADMIN_ROLE, _msgSender())) {
      // Admin can always stabilize
      return true;
    }
    // Must have elapsed at least one period of the moving average before we stabilize again
    if (block.timestamp < lastStabilize + fastAveragePeriod) {
      return false;
    }

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);

    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);
    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);

    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;
  }

  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {
    uint256 decimals = rewardToken.decimals();
    uint256 priceTarget = maltDataLab.priceTarget();

    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);
    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);

    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _distributeSupply() internal {
    if (supplyDistributionController != address(0)) {
      bool success = ISupplyDistributionController(supplyDistributionController).check();
      if (!success) {
        return;
      }
    }

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);

    if (tradeSize == 0) {
      return;
    }

    uint256 swingAmount = swingTrader.sellMalt(tradeSize);

    if (swingAmount >= tradeSize) {
      return;
    }

    tradeSize = tradeSize - swingAmount;

    malt.mint(address(dexHandler), tradeSize);
    emit MintMalt(tradeSize);
    uint256 rewards = dexHandler.sellMalt();

    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);

    uint256 remaining = _replenishLiquidityExtension(rewards);

    _distributeRewards(remaining);

    maltDataLab.trackReserveRatio();
    impliedCollateralService.claim();
  }

  function _distributeRewards(uint256 rewarded) internal {
    if (rewarded == 0) {
      return;
    }
    rewardToken.approve(address(auction), rewarded);
    rewarded = auction.allocateArbRewards(rewarded);

    if (rewarded == 0) {
      return;
    }

    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);
    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);
    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);
    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);
    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);

    // Treasury gets paid after everyone else
    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;

    assert(treasuryCut <= rewarded);

    if (callerCut > 0) {
      rewardToken.safeTransfer(msg.sender, callerCut);
    }

    if (auctionPoolCut > 0) {
      rewardToken.safeTransfer(auctionPool, auctionPoolCut);
    }

    if (swingTraderCut > 0) {
      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);
    }

    if (treasuryCut > 0) {
      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);
    }

    if (daoCut > 0) {
      rewardToken.safeTransfer(address(dao), daoCut);
    }

    if (lpCut > 0) {
      rewardToken.safeTransfer(address(rewardThrottle), lpCut);
      rewardThrottle.handleReward();
    }

    emit RewardDistribution(rewarded);
  }

  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {
    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {
      return rewards;
    }

    (uint256 deficit,) = liquidityExtension.collateralDeficit();

    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);

    if (deficit >= maxContrib) {
      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);
      return rewards - maxContrib;
    }

    rewardToken.safeTransfer(address(liquidityExtension), deficit);

    return rewards - deficit;
  }

  function _startAuction() internal {
    if (auctionStartController != address(0)) {
      bool success = IAuctionStartController(auctionStartController).checkForStart();
      if (!success) {
        return;
      }
    }

    uint256 priceTarget = maltDataLab.priceTarget();
    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);

    if (purchaseAmount == 0) {
      return;
    }

    uint256 decimals = rewardToken.decimals();

    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);

    purchaseAmount = purchaseAmount - amountUsed;

    if (purchaseAmount < 10**decimals) {
      return;
    }

    auction.triggerAuction(priceTarget, purchaseAmount);

    malt.mint(msg.sender, defaultIncentive*10**18);
    emit MintMalt(defaultIncentive*10**18);

    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);

    maltDataLab.trackReserveRatio();
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setStabilizeBackoff(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_period > 0, ""Must be greater than 0"");
    stabilizeBackoffPeriod = _period;
    emit SetStabilizeBackoff(_period);
  }

  function setAuctionBurnSkew(address _auctionBurnReserveSkew)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);
    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);
  }

  function setRewardCut(
    uint256 _daoCut,
    uint256 _lpCut,
    uint256 _callerCut,
    uint256 _auctionPoolCut,
    uint256 _swingTraderCut
  )
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);
    require(sum <= 1000, ""Reward cut must be <= 100%"");
    daoRewardCut = _daoCut;
    lpRewardCut = _lpCut;
    callerRewardCut = _callerCut;
    auctionPoolRewardCut = _auctionPoolCut;
    swingTraderRewardCut = _swingTraderCut;
    treasuryRewardCut = 1000 - sum;

    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);
  }

  function setTreasury(address payable _newTreasury)
    external
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    treasuryMultisig = _newTreasury;
    emit SetTreasury(_newTreasury);
  }

  function setDefaultIncentive(uint256 _incentive)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_incentive > 0, ""No negative incentive"");

    defaultIncentive = _incentive;

    emit SetDefaultIncentive(_incentive);
  }

  function setExpansionDamping(uint256 amount)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(amount > 0, ""No negative damping"");

    expansionDampingFactor = amount;
    emit SetExpansionDamping(amount);
  }

  function setNewDataLab(address _dataLab)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    maltDataLab = IMaltDataLab(_dataLab);
    emit SetNewMaltDataLab(_dataLab);
  }

  function setAuctionContract(address _auction)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {

    if (address(auction) != address(0)) {
      revokeRole(AUCTION_ROLE, address(auction));
    }

    auction = IAuction(_auction);
    _setupRole(AUCTION_ROLE, _auction);
    emit SetAuctionContract(_auction);
  }

  function setStabilityThresholds(uint256 _upper, uint256 _lower)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_upper > 0 && _lower > 0, ""Must be above 0"");

    upperStabilityThreshold = _upper;
    lowerStabilityThreshold = _lower;
    emit SetStabilityThresholds(_upper, _lower);
  }

  function setAuctionPool(address _auctionPool)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auctionPool != address(0), ""Not address 0"");

    auctionPool = _auctionPool;
    emit SetAuctionPool(_auctionPool);
  }

  function setSupplyDistributionController(address _controller)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    // This is allowed to be set to address(0) as its checked before calling methods on it
    supplyDistributionController = _controller;
    emit SetSupplyDistributionController(_controller);
  }

  function setAuctionStartController(address _controller)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    // This is allowed to be set to address(0) as its checked before calling methods on it
    auctionStartController = _controller;
    emit SetAuctionStartController(_controller);
  }

  function setMaxContribution(uint256 _maxContribution)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_maxContribution > 0 && _maxContribution <= 100, ""Must be between 0 and 100"");

    maxContributionBps = _maxContribution;
    emit SetMaxContribution(_maxContribution);
  }

  function setDexHandler(address _dexHandler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dexHandler != address(0), ""Not address 0"");
    dexHandler = IDexHandler(_dexHandler);
    emit SetDexHandler(_dexHandler);
  }

  function setDao(address _dao)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dao != address(0), ""Not address 0"");
    dao = IDAO(_dao);
    emit SetDao(_dao);
  }

  function setLiquidityExtension(address _liquidityExtension)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_liquidityExtension != address(0), ""Not address 0"");
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    emit SetLiquidityExtension(_liquidityExtension);
  }

  function setRewardThrottle(address _rewardThrottle)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_rewardThrottle != address(0), ""Not address 0"");
    rewardThrottle = IRewardThrottle(_rewardThrottle);
    emit SetRewardThrottle(_rewardThrottle);
  }

  function setSwingTrader(address _swingTrader)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_swingTrader != address(0), ""Not address 0"");
    swingTrader = ISwingTrader(_swingTrader);
    emit SetSwingTrader(_swingTrader);
  }

  function setImpliedCollateralService(address _impliedCollateralService)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_impliedCollateralService != address(0), ""Not address 0"");
    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);
    emit SetImpliedCollateralService(_impliedCollateralService);
  }

  function setPriceAveragePeriod(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_period > 0, ""Cannot have 0 period"");
    priceAveragePeriod = _period;
    emit SetPriceAveragePeriod(_period);
  }

  function setOverrideDistance(uint256 _distance)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_distance > 0 && _distance < 1000, ""Override must be between 0-100%"");
    overrideDistance = _distance;
    emit SetOverrideDistance(_distance);
  }

  function setFastAveragePeriod(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_period > 0, ""Cannot have 0 period"");
    fastAveragePeriod = _period;
    emit SetFastAveragePeriod(_period);
  }
}",4441
RealWorld_TA_59_Timelock_RealWorld_20240808093357.log,59,Timelock,126296,4189,130485,165.0,0.71526,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""./Permissions.sol"";


/// @title Timelock
/// @author 0xScotch <scotch@malt.money>
/// @notice Fairly basic timelock contract
contract Timelock is Initializable, Permissions {
  using SafeMath for uint256;

  // The amount of delay after which a delay can a queued can be executed.
  uint256 public delay = 2 days;
  // The the period within which an queued proposal can be executed.
  uint256 public gracePeriod = 7 days;

  mapping(bytes32 => bool) public queuedTransactions;

  event NewDelay(uint256 indexed newDelay_);
  event NewGracePeriod(uint256 indexed newGracePerios_);
  event NewGovernor(address newGovernor);
  event CancelTransaction(
    bytes32 indexed txHash_,
    address indexed target_,
    uint256 value_,
    string signature_,
    bytes data_,
    uint256 eta_
  );
  event ExecuteTransaction(
    bytes32 indexed txHash_,
    address indexed target_,
    uint256 value_,
    string signature_,
    bytes data_,
    uint256 eta_
  );
  event QueueTransaction(
    bytes32 indexed txHash_,
    address indexed target_,
    uint256 value_,
    string signature_,
    bytes data_,
    uint256 eta_
  );

  address public governor;

  function initialize(address _admin, address _governor) external initializer {
    _adminSetup(_admin);
    _setupRole(GOVERNOR_ROLE, address(this));
    _setupRole(GOVERNOR_ROLE, _governor);
    _setRoleAdmin(GOVERNOR_ROLE, TIMELOCK_ROLE);

    governor = _governor;
  }

  receive() external payable {}

  /**
   * @notice Sets the amount of time after which a proposal that has been queued can be executed.
   */
  function setDelay(uint256 _delay)
    public
    onlyRole(GOVERNOR_ROLE, ""Must have timelock role"")
  {
    require(
      _delay >= 0 && _delay < gracePeriod,
      ""Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod""
    );
    delay = _delay;

    emit NewDelay(delay);
  }

  /**
   * @notice Sets the amount of time within which a queued proposal can be executed.
   */
  function setGracePeriod(uint256 _gracePeriod)
    public
    onlyRole(GOVERNOR_ROLE, ""Must have timelock role"")
  {
    require(
      _gracePeriod > delay,
      ""Timelock::gracePeriod: Grace period must be greater than delay""
    );
    gracePeriod = _gracePeriod;

    emit NewGracePeriod(gracePeriod);
  }

  /**
   * @notice Sets the governor address that is allowed to make proposals
   */
  function setGovernor(address _governor)
    public
    onlyRole(GOVERNOR_ROLE, ""Must have timelock role"")
  {
    _swapRole(_governor, governor, GOVERNOR_ROLE);
    governor = _governor;
    emit NewGovernor(_governor);
  }

  function queueTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  )
    public
    onlyRole(GOVERNOR_ROLE, ""Timelock::queueTransaction: Call must come from governor."")
    returns (bytes32)
  {
    require(
      eta >= block.timestamp.add(delay),
      ""Timelock::queueTransaction: Estimated execution block must satisfy delay.""
    );

    bytes32 txHash = keccak256(
      abi.encode(target, value, signature, data, eta)
    );
    queuedTransactions[txHash] = true;

    emit QueueTransaction(txHash, target, value, signature, data, eta);
    return txHash;
  }

  function cancelTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  )
    public
    onlyRole(GOVERNOR_ROLE, ""Timelock::cancelTransaction: Call must come from governor."")
  {
    bytes32 txHash = keccak256(
      abi.encode(target, value, signature, data, eta)
    );
    queuedTransactions[txHash] = false;

    emit CancelTransaction(txHash, target, value, signature, data, eta);
  }

  function executeTransaction(
    address target,
    uint256 value,
    string memory signature,
    bytes memory data,
    uint256 eta
  )
    public
    payable
    onlyRole(GOVERNOR_ROLE, ""Timelock::executeTransaction: Call must come from governor."")
    returns (bytes memory)
  {
    bytes32 txHash = keccak256(
      abi.encode(target, value, signature, data, eta)
    );
    require(
      queuedTransactions[txHash],
      ""Timelock::executeTransaction: Transaction hasn't been queued.""
    );
    require(
      block.timestamp >= eta,
      ""Timelock::executeTransaction: Transaction hasn't surpassed time lock.""
    );
    require(
      block.timestamp <= eta.add(gracePeriod),
      ""Timelock::executeTransaction: Transaction is stale.""
    );

    queuedTransactions[txHash] = false;

    bytes memory callData;

    if (bytes(signature).length == 0) {
      callData = data;
    } else {
      callData = abi.encodePacked(
        bytes4(keccak256(bytes(signature))),
        data
      );
    }

    (bool success, bytes memory returnData) = target.call{value: value}(
      callData
    );

    require(
      success,
      ""Timelock::executeTransaction: Transaction execution reverted.""
    );

    emit ExecuteTransaction(txHash, target, value, signature, data, eta);

    return returnData;
  }
}",1275
RealWorld_TA_59_UniswapV2Library_RealWorld_20240808102012.log,59,UniswapV2Library,114597,1625,116222,101.0,0.605485,"pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import ""@openzeppelin/contracts/math/SafeMath.sol"";

library UniswapV2Library {
    using SafeMath for uint;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
            ))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}",1160
RealWorld_TA_59_ISupplyDistributionController_RealWorld_20240808103628.log,59,ISupplyDistributionController,20587,1576,22163,97.0,0.134455,"pragma solidity >=0.6.6;

interface ISupplyDistributionController {
  function check() external view returns (bool);
}",26
RealWorld_TA_59_IMalt_RealWorld_20240808105319.log,59,IMalt,31118,1887,33005,134.0,0.19333,"pragma solidity >=0.6.6;

interface IMalt {
  function balanceOf(address account) external view returns (uint256);
  function transfer(address recipient, uint256 amount) external returns (bool);
  function allowance(address owner, address spender) external view returns (uint256);
  function approve(address spender, uint256 amount) external returns (bool);
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
  function mint(address to, uint256 amount) external;
  function burn(address from, uint256 amount) external;

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}",147
RealWorld_TA_59_LiquidityExtension_RealWorld_20240808090751.log,59,LiquidityExtension,128256,4059,132315,163.0,0.72246,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import '@uniswap/lib/contracts/libraries/Babylonian.sol';

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IMaltDataLab.sol"";
import ""./libraries/UniswapV2Library.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";


/// @title Liquidity Extension
/// @author 0xScotch <scotch@malt.money>
/// @notice In charge of facilitating a premium with net supply contraction during auctions
contract LiquidityExtension is Initializable, Permissions {
  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  IAuction public auction;
  IDexHandler public dexHandler;
  IMaltDataLab public maltDataLab;
  address public uniswapV2Factory;

  uint256 public minReserveRatio = 40;

  event SetAuction(address auction);
  event SetDexHandler(address dexHandler);
  event SetMaltDataLab(address dataLab);
  event SetMinReserveRatio(uint256 ratio);
  event BurnMalt(uint256 purchased);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _auction,
    address _collateralToken,
    address _malt,
    address _dexHandler,
    address _maltDataLab,
    address _uniswapV2Factory
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(AUCTION_ROLE, _auction);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auction = IAuction(_auction);
    dexHandler = IDexHandler(_dexHandler);
    maltDataLab = IMaltDataLab(_maltDataLab);
    uniswapV2Factory = _uniswapV2Factory;
  }

  /*
   * PUBLIC VIEW METHODS
   */
  function hasMinimumReserves() public view returns (bool) {
    (uint256 rRatio, uint256 decimals) = reserveRatio();
    return rRatio >= minReserveRatio.mul(10**decimals).div(100);
  }

  function collateralDeficit() public view returns (uint256 deficit, uint256 decimals) {
    // Returns the amount of collateral token required to reach minimum reserves
    // Returns 0 if liquidity extension contains minimum reserves.
    uint256 balance = collateralToken.balanceOf(address(this));
    uint256 collateralDecimals = collateralToken.decimals();

    // TODO use data lab Mon 11 Oct 2021 16:48:08 BST
    (uint256 maltSupply, uint256 collateralSupply) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(collateralToken)
    );

    uint256 k = maltSupply.mul(collateralSupply);
    uint256 priceTarget = maltDataLab.priceTarget();

    uint256 fullCollateral = Babylonian.sqrt(k.mul(10**collateralDecimals).div(priceTarget));

    uint256 minReserves = fullCollateral.mul(minReserveRatio).div(100);

    if (minReserves > balance) {
      return (minReserves - balance, collateralDecimals);
    }

    return (0, collateralDecimals);
  }

  function reserveRatio() public view returns (uint256, uint256) {
    uint256 balance = collateralToken.balanceOf(address(this));
    uint256 collateralDecimals = collateralToken.decimals();

    // TODO use data lab Mon 11 Oct 2021 16:48:08 BST
    (uint256 maltSupply, uint256 collateralSupply) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(collateralToken)
    );

    uint256 k = maltSupply.mul(collateralSupply);
    uint256 priceTarget = maltDataLab.priceTarget();

    uint256 fullCollateral = Babylonian.sqrt(k.mul(10**collateralDecimals).div(priceTarget));

    uint256 rRatio = balance.mul(10**collateralDecimals).div(fullCollateral);
    return (rRatio, collateralDecimals);
  }

  /*
   * PRIVILEDGED METHODS
   */
  function purchaseAndBurn(uint256 amount)
    external
    onlyRole(AUCTION_ROLE, ""Must have auction privs"")
    returns (uint256 purchased)
  {
    require(collateralToken.balanceOf(address(this)) >= amount, ""Insufficient balance"");
    collateralToken.safeTransfer(address(dexHandler), amount);
    purchased = dexHandler.buyMalt();
    malt.burn(address(this), purchased);

    emit BurnMalt(purchased);
  }

  function setAuction(address _auction)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auction != address(0), ""Not address 0"");
    auction = IAuction(_auction);
    emit SetAuction(_auction);
  }

  function setDexHandler(address _dexHandler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dexHandler != address(0), ""Not address 0"");
    dexHandler = IDexHandler(_dexHandler);
    emit SetDexHandler(_dexHandler);
  }

  function setMaltDataLab(address _dataLab)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_dataLab != address(0), ""Not address 0"");
    maltDataLab = IMaltDataLab(_dataLab);
    emit SetMaltDataLab(_dataLab);
  }

  function setMinReserveRatio(uint256 _ratio)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_ratio > 0 && _ratio <= 100, ""Must be between 0 and 100"");
    minReserveRatio = _ratio;
    emit SetMinReserveRatio(_ratio);
  }
}",1341
RealWorld_TA_59_IAuction_RealWorld_20240808105146.log,59,IAuction,75466,1326,76792,91.0,0.40385,"pragma solidity >=0.6.6;

interface IAuction {
  function replenishingAuctionId() external view returns(uint256);
  function currentAuctionId() external view returns(uint256);
  function purchaseArbitrageTokens(uint256 amount) external;
  function claimArbitrage(uint256 _auctionId) external;
  function isAuctionFinished(uint256 _id) external view returns(bool);
  function auctionActive(uint256 _id) external view returns (bool);
  function isAuctionFinalized(uint256 _id) external view returns (bool);
  function userClaimableArbTokens(
    address account,
    uint256 auctionId
  ) external view returns (uint256);
  function balanceOfArbTokens(
    uint256 _auctionId,
    address account
  ) external view returns (uint256);
  function averageMaltPrice(uint256 _id) external view returns (uint256);
  function currentPrice(uint256 _id) external view returns (uint256);
  function getAuctionCommitments(uint256 _id) external view returns (uint256 commitments, uint256 maxCommitments);
  function getAuctionPrices(uint256 _id) external view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice);
  function auctionExists(uint256 _id) external view returns (bool);
  function getAccountCommitments(address account) external view returns (
    uint256[] memory auctions,
    uint256[] memory commitments,
    uint256[] memory awardedTokens,
    uint256[] memory redeemedTokens,
    uint256[] memory finalPrice,
    uint256[] memory claimable,
    bool[] memory finished
  );
  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory);
  function getActiveAuction() external view returns (
    uint256 auctionId,
    uint256 maxCommitments,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  );
  function getAuction(uint256 _id) external view returns (
    uint256 maxCommitments,
    uint256 commitments,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    uint256 finalBurnBudget,
    uint256 finalPurchased
  );
  function getAuctionCore(uint256 _id) external view returns (
    uint256 auctionId,
    uint256 commitments,
    uint256 maltPurchased,
    uint256 startingPrice,
    uint256 finalPrice,
    uint256 pegPrice,
    uint256 startingTime,
    uint256 endingTime,
    bool active
  );
  function checkAuctionFinalization() external;
  function allocateArbRewards(uint256 rewarded) external returns (uint256);
  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount) external;
  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns(uint256, uint256, uint256);
  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltQuantity) external;
}",697
RealWorld_TA_59_IDistributor_RealWorld_20240808110820.log,59,IDistributor,24030,1919,25949,107.0,0.15853,"pragma solidity >=0.6.6;

interface IDistributor {
  function vest() external;
  function totalDeclaredReward() external view returns (uint256);
  function decrementRewards(uint256 amount) external;
  function forfeit(uint256 amount) external;
  function declareReward(uint256 amount) external;
}",64
RealWorld_TA_59_AuctionPool_RealWorld_20240808095624.log,59,AuctionPool,124262,5339,129601,185.0,0.72809,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./AuctionParticipant.sol"";
import ""./AbstractRewardMine.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IBonding.sol"";


/// @title LP Auction Pool
/// @author 0xScotch <scotch@malt.money>
/// @notice A portion of above peg profit is directed here and the capital is deployed into arbitrage auctions when possible.
/// @notice The core functionality is implemented in AuctionParticipant and AbstractRewardMine. But together they make new composite functionality.
contract AuctionPool is Initializable, AuctionParticipant, AbstractRewardMine {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  uint256 public forfeitedRewards;

  IBonding public bonding;
  address public forfeitDestination;

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardToken,
    address _auction,
    address _impliedCollateralService,
    address _bonding,
    address _miningService,
    address _forfeitDestination
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    bonding = IBonding(_bonding);

    _initialSetup(_rewardToken, _miningService);

    setupParticipant(
      _impliedCollateralService,
      _rewardToken,
      _auction
    );
    forfeitDestination = _forfeitDestination;
  }

  function onUnbond(address account, uint256 amount)
    override
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    // Withdraw all current rewards
    // Done now before we change stake padding below
    uint256 rewardEarned = earned(account);
    _handleWithdrawForAccount(account, rewardEarned, account);

    uint256 bondedBalance = balanceOfBonded(account);

    if (bondedBalance == 0) {
      return;
    }

    _checkForForfeit(account, amount, bondedBalance);

    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);

    _reconcileWithdrawn(account, amount, bondedBalance);
    _removeFromStakePadding(account, lessStakePadding, ""< stake padding"");
  }

  function totalBonded() override public view returns (uint256) {
    return bonding.totalBonded();
  }

  function balanceOfBonded(address account) override public view returns (uint256) {
    return bonding.balanceOfBonded(account);
  }

  function totalDeclaredReward() override public view returns (uint256) {
    // Outstanding Arb tokens + the claimable arb tokens that have been redeemed
    // minus rewards that have been forfeited
    return outstandingArbTokens() + claimableRewards - forfeitedRewards;
  }

  function totalReleasedReward() override public view returns (uint256) {
    return claimableRewards + _globalWithdrawn;
  }

  function usableBalance() override public view returns(uint256) {
    uint256 totalBalance = auctionRewardToken.balanceOf(address(this));

    if (totalBalance > claimableRewards) {
      return totalBalance - claimableRewards;
    }

    return 0;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _checkForForfeit(address account, uint256 amount, uint256 bondedBalance) internal {
    // This is the user's share of total rewards
    uint256 userReward = balanceOfRewards(account);
    uint256 globalRewarded = totalDeclaredReward();

    uint256 earnedReward = 0;
    
    // This is done inline instead of using earned() to save gas
    if (globalRewarded > 0 && userReward > 0) {
      earnedReward = totalReleasedReward().mul(userReward).div(globalRewarded);
    }

    uint256 forfeitAmount = userReward.sub(earnedReward).mul(amount) / bondedBalance;
    uint256 declaredRewardDecrease = earnedReward.mul(amount) / bondedBalance;

    if (forfeitAmount > 0) {
      forfeitedRewards = forfeitedRewards + forfeitAmount;
    }

    if (declaredRewardDecrease > 0) {
      claimableRewards = claimableRewards.sub(
        declaredRewardDecrease
      );
    }
  }

  function _afterWithdraw(address account, uint256 amount) override internal {
    claimableRewards = claimableRewards.sub(amount);
  }

  function _handleRewardDistribution(uint256 rewarded) override internal {
    if (forfeitedRewards > 0) {
      uint256 coverage;
      // Need to pay down some of the forfeited amount
      if (rewarded > forfeitedRewards) {
        // Can cover everything
        coverage = forfeitedRewards;
      } else {
        coverage = rewarded;
      }

      forfeitedRewards = forfeitedRewards - coverage;
      claimableRewards = claimableRewards.sub(coverage);

      rewardToken.safeTransfer(forfeitDestination, coverage);
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setBonding(address _bonding)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_bonding != address(0), ""Not zero address"");
    bonding = IBonding(_bonding);
  }

  function setForfeitDestination(address _forfeitDestination)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_forfeitDestination != address(0), ""Not zero address"");
    forfeitDestination = _forfeitDestination;
  }
}",1272
RealWorld_TA_59_ILiquidityExtension_RealWorld_20240808112654.log,59,ILiquidityExtension,26066,1610,27676,93.0,0.16253,"pragma solidity >=0.6.6;

interface ILiquidityExtension {
  function hasMinimumReserves() external view returns (bool);
  function collateralDeficit() external view returns (uint256, uint256);
  function reserveRatio() external view returns (uint256, uint256);
  function purchaseAndBurn(uint256 amount) external returns (uint256 purchased);
  function buyBack(uint256 maltAmount) external;
}",87
RealWorld_TA_59_SwingTrader_RealWorld_20240808091544.log,59,SwingTrader,124982,4056,129038,163.0,0.70603,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IRewardThrottle.sol"";
import ""./interfaces/IDexHandler.sol"";


/// @title Swing Trader
/// @author 0xScotch <scotch@malt.money>
/// @notice The sole aim of this contract is to defend peg and try to profit in the process.
/// @dev It does so from a privileged internal position where it is allowed to purchase on the AMM even in recovery mode
contract SwingTrader is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  ERC20 public collateralToken;
  ERC20 public malt;
  IDexHandler public dexHandler;
  IRewardThrottle public rewardThrottle;

  uint256 internal deployedCapital;
  uint256 public lpProfitCut = 500; // 50%

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    address _dexHandler,
    address _stabilizerNode,
    address _rewardThrottle
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);

    collateralToken = ERC20(_collateralToken);
    malt = ERC20(_malt);
    dexHandler = IDexHandler(_dexHandler);
    rewardThrottle = IRewardThrottle(_rewardThrottle);
  }

  function buyMalt(uint256 maxCapital)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must have stabilizer node privs"")
    returns (uint256 capitalUsed)
  {
    if (maxCapital == 0) {
      return 0;
    }

    uint256 balance = collateralToken.balanceOf(address(this));

    if (balance == 0) {
      return 0;
    }

    if (maxCapital < balance) {
      balance = maxCapital;
    }

    collateralToken.safeTransfer(address(dexHandler), balance);
    dexHandler.buyMalt();

    deployedCapital = deployedCapital + balance;

    return balance;
  }

  function sellMalt(uint256 maxAmount)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must have stabilizer node privs"")
    returns (uint256 amountSold)
  {
    if (maxAmount == 0) {
      return 0;
    }

    uint256 totalMaltBalance = malt.balanceOf(address(this));
    uint256 balance = totalMaltBalance;

    if (balance == 0) {
      return 0;
    }

    (uint256 basis,) = costBasis();

    if (maxAmount < totalMaltBalance) {
      balance = maxAmount;
    }

    malt.safeTransfer(address(dexHandler), balance);
    uint256 rewards = dexHandler.sellMalt();

    if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {
      // If all malt is spent we want to reset deployed capital
      deployedCapital = deployedCapital - rewards;
    } else {
      deployedCapital = 0;
    }

    uint256 maltDecimals = malt.decimals();
    uint256 decimals = collateralToken.decimals();    

    uint256 profit = 0;

    if (maltDecimals == decimals) {
      uint256 soldBasis = basis.mul(balance).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    } else if (maltDecimals > decimals) {
      uint256 diff = maltDecimals - decimals;
      uint256 soldBasis = basis.mul(balance.div(10**diff)).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    } else {
      uint256 diff = decimals - maltDecimals;
      uint256 soldBasis = basis.mul(balance.mul(10**diff)).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    }

    if (profit > 0) {
      uint256 lpCut = profit.mul(lpProfitCut).div(1000);

      collateralToken.safeTransfer(address(rewardThrottle), lpCut);
      rewardThrottle.handleReward();
    }

    return balance;
  }

  function costBasis() public view returns (uint256 cost, uint256 decimals) {
    // Always returns using the decimals of the collateralToken as that is the 
    // currency costBasis is calculated in
    decimals = collateralToken.decimals();    
    uint256 maltBalance = malt.balanceOf(address(this));

    if (deployedCapital == 0 || maltBalance == 0) {
      return (0, decimals);
    }

    uint256 maltDecimals = malt.decimals();    

    if (maltDecimals == decimals) {
      return (deployedCapital.mul(10**decimals).div(maltBalance), decimals);
    } else if (maltDecimals > decimals) {
      uint256 diff = maltDecimals - decimals;
      return (deployedCapital.mul(10**decimals).div(maltBalance.div(10**diff)), decimals);
    } else {
      uint256 diff = decimals - maltDecimals;
      return (deployedCapital.mul(10**decimals).div(maltBalance.mul(10**diff)), decimals);
    }
  }

  function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_profitCut >= 0 && _profitCut <= 1000, ""Must be between 0 and 100%"");
    lpProfitCut = _profitCut;  
  }
}",1297
RealWorld_TA_59_IBonding_RealWorld_20240808111348.log,59,IBonding,26556,2176,28732,116.0,0.1763,"pragma solidity >=0.6.6;

interface IBonding {
  function bond(uint256 amount) external;
  function bondToAccount(address account, uint256 amount) external;
  function unbond(uint256 amount) external;
  function totalBonded() external view returns (uint256);
  function balanceOfBonded(address account) external view returns (uint256);
  function averageBondedValue(uint256 epoch) external view returns (uint256);
}",94
RealWorld_TA_59_UniswapHandler_RealWorld_20240808103252.log,59,UniswapHandler,219332,6943,226275,214.0,1.23552,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';
import '@uniswap/lib/contracts/libraries/Babylonian.sol';
import '@uniswap/lib/contracts/libraries/FullMath.sol';

import ""../Permissions.sol"";
import ""../libraries/UniswapV2Library.sol"";


/// @title Uniswap Interaction Handler
/// @author 0xScotch <scotch@malt.money>
/// @notice A simple contract to make interacting with UniswapV2 pools easier.
/// @notice The buyMalt method is locked down to avoid circumventing recovery mode
/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct
contract UniswapHandler is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  bytes32 public constant BUYER_ROLE = keccak256(""BUYER_ROLE"");

  ERC20 public malt;
  ERC20 public rewardToken;
  ERC20 public lpToken;
  IUniswapV2Router02 public router;
  address public uniswapV2Factory;

  address[] public buyers;
  mapping(address => bool) public buyersActive;

  event AddMaltBuyer(address buyer);
  event RemoveMaltBuyer(address buyer);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _maltToken,
    address _rewardToken,
    address _lpToken,
    address _router,
    address _uniswapV2Factory
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);

    malt = ERC20(_maltToken);
    rewardToken = ERC20(_rewardToken);
    router = IUniswapV2Router02(_router);

    lpToken = ERC20(_lpToken);
    uniswapV2Factory = _uniswapV2Factory;
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {
    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);
  }

  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {
    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);
  }

  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {
    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST
    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(rewardToken)
    );
  }

  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {
    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST
    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      address(malt),
      address(rewardToken)
    );

    if (maltReserves == 0 || rewardReserves == 0) {
      price = 0;
      decimals = 18;
      return (price, decimals);
    }

    uint256 rewardDecimals = rewardToken.decimals();
    uint256 maltDecimals = malt.decimals();

    if (rewardDecimals > maltDecimals) {
      uint256 diff = rewardDecimals - maltDecimals;
      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));
      decimals = rewardDecimals;
    } else if (rewardDecimals < maltDecimals) {
      uint256 diff = maltDecimals - rewardDecimals;
      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);
      decimals = maltDecimals;
    } else {
      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);
      decimals = rewardDecimals;
    }
  }

  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)
    external view returns (uint256 liquidityA)
  {
    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST
    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      tokenA,
      tokenB
    );

    liquidityA = UniswapV2Library.quote(
      liquidityB,
      reservesB,
      reservesA
    );
  }

  /*
   * MUTATION FUNCTIONS
   */
  function buyMalt()
    external
    onlyRole(BUYER_ROLE, ""Must have buyer privs"")
    returns (uint256 purchased)
  {
    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    if (rewardBalance == 0) {
      return 0;
    }

    rewardToken.approve(address(router), rewardBalance);

    address[] memory path = new address[](2);
    path[0] = address(rewardToken);
    path[1] = address(malt);

    router.swapExactTokensForTokens(
      rewardBalance,
      0, // amountOutMin
      path,
      address(this),
      now
    );

    purchased = malt.balanceOf(address(this));
    malt.safeTransfer(msg.sender, purchased);
  }

  function sellMalt() external returns (uint256 rewards) {
    uint256 maltBalance = malt.balanceOf(address(this));

    if (maltBalance == 0) {
      return 0;
    }

    malt.approve(address(router), maltBalance);

    address[] memory path = new address[](2);
    path[0] = address(malt);
    path[1] = address(rewardToken);

    router.swapExactTokensForTokens(
      maltBalance,
      0,
      path,
      address(this),
      now
    );

    rewards = rewardToken.balanceOf(address(this));
    rewardToken.safeTransfer(msg.sender, rewards);
  }

  function addLiquidity() external returns (
    uint256 maltUsed,
    uint256 rewardUsed,
    uint256 liquidityCreated
  ) {
    uint256 maltBalance = malt.balanceOf(address(this));
    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    if (maltBalance == 0 || rewardBalance == 0) {
      return (0, 0, 0);
    }

    rewardToken.approve(address(router), rewardBalance);
    malt.approve(address(router), maltBalance);

    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT
    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(
      address(malt),
      address(rewardToken),
      maltBalance,
      rewardBalance,
      maltBalance.mul(95).div(100),
      rewardBalance.mul(95).div(100),
      msg.sender, // transfer LP tokens to sender
      now
    );

    if (maltUsed < maltBalance) {
      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));
    }

    if (rewardUsed < rewardBalance) {
      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));
    }
  }

  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {
    uint256 liquidityBalance = lpToken.balanceOf(address(this));

    if (liquidityBalance == 0) {
      return (0, 0);
    }

    lpToken.approve(address(router), liquidityBalance);

    (amountMalt, amountReward) = router.removeLiquidity(
      address(malt),
      address(rewardToken),
      liquidityBalance,
      0,
      0,
      msg.sender, // transfer broken LP tokens to sender
      now
    );

    if (amountMalt == 0 || amountReward == 0) {
      liquidityBalance = lpToken.balanceOf(address(this));
      lpToken.safeTransfer(msg.sender, liquidityBalance);
      return (amountMalt, amountReward);
    }
  }

  /*
   * PRIVATE METHODS
   */
  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {
    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST
    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(
      uniswapV2Factory,
      sellToken,
      buyToken
    );

    uint256 invariant = sellReserves.mul(buyReserves);

    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());

    uint256 leftSide = Babylonian.sqrt(
      FullMath.mulDiv(
        invariant.mul(1000),
        priceTarget,
        buyBase.div(priceTarget).mul(buyBase).mul(997)
      )
    );

    uint256 rightSide = sellReserves.mul(1000).div(997);

    if (leftSide < rightSide) return 0;

    return leftSide.sub(rightSide);
  }

  /*
   * PRIVILEDGED METHODS
   */
  function addNewBuyer(address _buyer)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
    notSameBlock
  {
    require(_buyer != address(0), ""Cannot use address 0"");

    if (buyersActive[_buyer]) {
      return;
    }

    buyersActive[_buyer] = true;
    buyers.push(_buyer);

    _setupRole(BUYER_ROLE, _buyer);

    emit AddMaltBuyer(_buyer);
  }

  function removeBuyer(address _buyer)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
    notSameBlock
  {
    if (buyers.length == 0 || !buyersActive[_buyer]) {
      return;
    }

    address buyer;
    buyersActive[_buyer] = false;

    emit RemoveMaltBuyer(_buyer);
    revokeRole(BUYER_ROLE, _buyer);

    // Loop until the second last element
    for (uint i = 0; i < buyers.length - 1; i = i + 1) {
      if (buyers[i] == _buyer) {
        // Replace the current item with the last and pop the last away.
        buyers[i] = buyers[buyers.length - 1];
        buyers.pop();
        return;
      }
    }

    // If we made it here then the buyers being removed is the last item
    buyers.pop();
  }

  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST
}",2420
RealWorld_TA_59_ERC20Permit_RealWorld_20240808091308.log,59,ERC20Permit,111285,4060,115345,154.0,0.637625,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./interfaces/IERC20Permit.sol"";


interface ITransferReceiver {
  function onTokenTransfer(address, uint, bytes calldata) external returns (bool);
}

interface IApprovalReceiver {
  function onTokenApproval(address, uint, bytes calldata) external returns (bool);
}

contract ERC20Permit is ERC20, IERC20Permit {
  bytes32 public constant PERMIT_TYPEHASH = keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
  bytes32 public constant TRANSFER_TYPEHASH = keccak256(""Transfer(address owner,address to,uint256 value,uint256 nonce,uint256 deadline)"");
  bytes32 public override immutable DOMAIN_SEPARATOR;

  /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.
  mapping (address => uint256) public override nonces;

  constructor(string memory name, string memory ticker) public ERC20(name, ticker) {
    uint256 chainId;
    assembly {chainId := chainid()}
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(name)),
        keccak256(bytes(""1"")),
        chainId,
        address(this)
      )
    );
  }

  /// Requirements:
  ///   - `deadline` must be timestamp in future.
  ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.
  ///   - the signature must use `owner` account's current nonce (see {nonces}).
  ///   - the signer cannot be zero address and must be `owner` account.
  function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
    require(block.timestamp <= deadline, ""ERC20Permit: Expired permit"");

    bytes32 hashStruct = keccak256(
      abi.encode(
        PERMIT_TYPEHASH,
        target,
        spender,
        value,
        nonces[target]++,
        deadline
      )
    );

    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));

    _approve(target, spender, value);
    emit Approval(target, spender, value);
  }

  function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool) {
    require(block.timestamp <= deadline, ""ERC20Permit: Expired permit"");

    bytes32 hashStruct = keccak256(
      abi.encode(
        TRANSFER_TYPEHASH,
        target,
        to,
        value,
        nonces[target]++,
        deadline
      )
    );

    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));

    require(to != address(0) || to != address(this));

    uint256 balance = balanceOf(target);
    require(balance >= value, ""ERC20Permit: transfer amount exceeds balance"");

    _transfer(target, to, value);

    return true;
  }

  function verifyEIP712(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {
    bytes32 hash = keccak256(
      abi.encodePacked(
        ""\x19\x01"",
        DOMAIN_SEPARATOR,
        hashStruct
      )
    );

    address signer = ecrecover(hash, v, r, s);
    return (signer != address(0) && signer == target);
  }

  function verifyPersonalSign(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {
    bytes32 hash = prefixed(hashStruct);
    address signer = ecrecover(hash, v, r, s);
    return (signer != address(0) && signer == target);
  }

  // Builds a prefixed hash to mimic the behavior of eth_sign.
  function prefixed(bytes32 hash) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hash));
  }

  function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {
    _approve(msg.sender, spender, value);

    return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);
  }

  function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {
    require(to != address(0) || to != address(this));

    uint256 balance = balanceOf(msg.sender);
    require(balance >= value, ""ERC20Permit: transfer amount exceeds balance"");

    _transfer(msg.sender, to, value);

    return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);
  }
}",1101
RealWorld_TA_59_SafeBurnMintableERC20_RealWorld_20240808102155.log,59,SafeBurnMintableERC20,91641,1762,93403,113.0,0.493445,"// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

import ""../interfaces/IBurnMintableERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeBurnMintableERC20 for IBurnMintableERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeBurnMintableERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IBurnMintableERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IBurnMintableERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IBurnMintableERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IBurnMintableERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(IBurnMintableERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IBurnMintableERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IBurnMintableERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",904
RealWorld_TA_59_MovingAverage_RealWorld_20240808094123.log,59,MovingAverage,308062,5136,313198,415.0,1.64303,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@uniswap/lib/contracts/libraries/FixedPoint.sol"";

import ""./Permissions.sol"";


/// @title Moving Average
/// @author 0xScotch <scotch@malt.money>
/// @notice For tracking the average of a data stream over time
/// @dev Based on the cumulativeValue mechanism for TWAP in uniswapV2
contract MovingAverage is Initializable, Permissions {
  using FixedPoint for *;
  using SafeMath for uint256;

  struct Sample {
    uint64 timestamp;
    uint256 value;
    uint256 cumulativeValue;
    uint256 lastValue;
  }

  bytes32 public constant UPDATER_ROLE = keccak256(""UPDATER_ROLE"");

  uint256 public sampleLength;
  uint256 public cumulativeValue;
  uint256 public sampleMemory;
  uint256 public defaultValue;

  uint64 public blockTimestampLast;

  uint256 private counter;
  uint256 private activeSamples;

  Sample[] private samples;

  event Update(uint256 value, uint256 cumulativeValue);

  function initialize(
    address _timelock,
    address initialAdmin,
    uint256 _sampleLength, // eg 5min represented as seconds
    uint256 _sampleMemory,
    address _updater,
    uint256 _defaultValue
  ) external initializer {
    require(_sampleMemory > 1, 'MA: SampleMemory > 1');

    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);
    _roleSetup(UPDATER_ROLE, _updater);
    _roleSetup(UPDATER_ROLE, initialAdmin);

    sampleLength = _sampleLength;
    sampleMemory = _sampleMemory;
    defaultValue = _defaultValue;

    for (uint i = 0; i < sampleMemory; i++) {
      samples.push();
    }
  }

  /*
   * PUBLIC VIEW METHODS
   */
  function getValue() public view returns (uint256) {
    if (activeSamples < 2) {
      return defaultValue;
    } else if (activeSamples == 2) {
      Sample storage currentSample = _getCurrentSample();
      return currentSample.value;
    } else if (activeSamples < sampleMemory) {
      // Subtract 2 because this is a lookback from the current sample.
      // activeSamples - 1 is the in progress sample. - 2 is the active sample
      // IE if there are 2 samples, we are on one and want to lookback 1.
      // If there are 3 samples, we are on one and want to lookback 2 etc
      uint256 lookback = (activeSamples - 2) * sampleLength;
      return getValueWithLookback(lookback);
    }
    Sample storage currentSample = _getCurrentSample();
    Sample storage firstSample = _getFirstSample();

    uint256 timeElapsed = currentSample.timestamp - firstSample.timestamp;
    uint256 sampleDiff = currentSample.cumulativeValue - firstSample.cumulativeValue;

    if (timeElapsed == 0) {
      return currentSample.value;
    } 

    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);

    return sampleAverage.decode();
  }

  function getValueWithLookback(uint256 _lookbackTime) public view returns (uint256) {
    // _lookbackTime in is seconds
    uint256 lookbackSamples;
    if (_lookbackTime % sampleLength == 0) {
      // If it divides equally just divide down
      lookbackSamples = _lookbackTime / sampleLength;

      if (lookbackSamples == 0) {
        lookbackSamples = 1;
      }
    } else {
      // If it doesn't divide equally, divide and add 1.
      // Creates a Math.ceil() situation
      lookbackSamples = (_lookbackTime / sampleLength) + 1;
    }

    if (activeSamples < 2) {
      return defaultValue;
    } else if (activeSamples == 2) {
      Sample storage currentSample = _getCurrentSample();
      return currentSample.value;
    } else if (lookbackSamples >= activeSamples - 1) {
      // Looking for longer lookback than sampleMemory allows.
      // Just return the full memory average
      return getValue();
    }

    Sample storage currentSample = _getCurrentSample();
    Sample storage nthSample = _getNthSample(lookbackSamples);

    uint256 timeElapsed = currentSample.timestamp - nthSample.timestamp;
    uint256 sampleDiff = currentSample.cumulativeValue - nthSample.cumulativeValue;

    if (timeElapsed == 0) {
      return currentSample.value;
    } 

    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);

    return sampleAverage.decode();
  }

  /*
   * MUTATION METHODS
   */
  function update(uint256 newValue)
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater privs"")
  {
    /* 
     * This function only creates a sample at the end of the sample period.
     * The current sample period just updates the cumulativeValue but doesn't
     * Actually create a sample until the end of the period.
     * This is to protect against flashloan attacks that could try manipulate
     * the samples.
     */
    Sample storage liveSample = samples[_getIndexOfSample(counter)];
    uint64 blockTimestamp = uint64(block.timestamp % 2**64); 

    // Deal with first ever sample
    if (liveSample.timestamp == 0) {
      liveSample.timestamp = uint64(block.timestamp);
      liveSample.value = newValue;
      liveSample.lastValue = newValue;
      liveSample.cumulativeValue = newValue;

      cumulativeValue = newValue;
      blockTimestampLast = blockTimestamp;

      activeSamples = activeSamples + 1;
      return;
    }

    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;

    if (timeElapsed < sampleLength) {
      cumulativeValue += liveSample.lastValue.mul(blockTimestamp - blockTimestampLast);
      liveSample.cumulativeValue = cumulativeValue;
      liveSample.lastValue = newValue;

      blockTimestampLast = blockTimestamp;
      return;
    } else if (timeElapsed >= (sampleLength - 1) * sampleMemory) {
      // More than total sample memory has elapsed. Reset with new values
      uint256 addition = liveSample.lastValue.mul(sampleLength);

      uint256 currentCumulative = cumulativeValue;
      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * sampleMemory);

      uint256 tempCount = counter;
      for (uint256 i = 0; i < sampleMemory; i++ ) {
        tempCount += 1;
        liveSample = samples[_getIndexOfSample(tempCount)];
        liveSample.timestamp = currentTimestamp;
        liveSample.cumulativeValue = currentCumulative;

        currentCumulative += addition;
        currentTimestamp += uint64(sampleLength);
      }

      // Reset the adding of 'addition' in the final loop
      currentCumulative = liveSample.cumulativeValue;

      tempCount += 1;
      liveSample = samples[_getIndexOfSample(tempCount)];
      liveSample.timestamp = blockTimestamp;
      // Only the most recent values really matter here
      liveSample.value = newValue;
      liveSample.lastValue = newValue;
      liveSample.cumulativeValue = currentCumulative;

      counter = tempCount;
      cumulativeValue = currentCumulative;
      blockTimestampLast = blockTimestamp;
      activeSamples = sampleMemory;
      return;
    }

    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);

    // Finish out the current sample
    cumulativeValue += liveSample.lastValue.mul(nextSampleTime - blockTimestampLast);
    liveSample.cumulativeValue = cumulativeValue;

    liveSample = _createNewSample(nextSampleTime, cumulativeValue);
    timeElapsed = timeElapsed - uint64(sampleLength);

    uint256 elapsedSamples = timeElapsed / sampleLength;

    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {
      // update
      cumulativeValue += liveSample.lastValue.mul(sampleLength);
      liveSample.cumulativeValue = cumulativeValue;

      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);

      liveSample = _createNewSample(sampleTime, cumulativeValue);
    }

    cumulativeValue += liveSample.lastValue.mul(timeElapsed % sampleLength);

    // Now set the value of the current sample to the new value
    liveSample.value = newValue;
    liveSample.lastValue = newValue;
    liveSample.cumulativeValue = cumulativeValue;

    blockTimestampLast = blockTimestamp;

    emit Update(newValue, cumulativeValue);
  }

  function updateCumulative(uint256 _cumulative)
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater privs"")
  {
    require(_cumulative >= cumulativeValue, ""Cumulative value can only go up"");

    Sample storage liveSample = samples[_getIndexOfSample(counter)];
    uint64 blockTimestamp = uint64(block.timestamp % 2**64); 

    if (liveSample.timestamp == 0) {
      cumulativeValue = _cumulative;
      blockTimestampLast = blockTimestamp;

      liveSample.timestamp = blockTimestamp;
      liveSample.cumulativeValue = _cumulative;
      liveSample.value = _cumulative;
      liveSample.lastValue = _cumulative;

      activeSamples = activeSamples + 1;
      return;
    }

    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;
    uint64 timeElapsedSinceUpdate = blockTimestamp - blockTimestampLast;
    uint256 newLastValue = (_cumulative - cumulativeValue).div(timeElapsedSinceUpdate);

    if (timeElapsed < sampleLength) {
      // The current sample isn't over. Just update
      liveSample.cumulativeValue = _cumulative;
      liveSample.value = newLastValue;
      liveSample.lastValue = newLastValue;

      blockTimestampLast = blockTimestamp;
      cumulativeValue = _cumulative;
      return;
    } else if (timeElapsed >= sampleLength * (sampleMemory - 1)) {
      // More than total sample memory has elapsed. Reset with new values

      uint256 addition = newLastValue.mul(sampleLength);

      uint256 currentCumulative = _cumulative.sub(addition * (sampleMemory - 1));
      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * (sampleMemory));

      uint256 tempCount = counter;
      for (uint256 i = 0; i < sampleMemory; i++ ) {
        tempCount += 1;
        liveSample = samples[_getIndexOfSample(tempCount)];
        liveSample.timestamp = currentTimestamp;
        liveSample.cumulativeValue = currentCumulative;

        currentCumulative += addition;
        currentTimestamp += uint64(sampleLength);
      }

      tempCount += 1;
      liveSample = samples[_getIndexOfSample(tempCount)];
      liveSample.timestamp = blockTimestamp;
      // Only the most recent values really matter here
      liveSample.value = newLastValue;
      liveSample.lastValue = newLastValue;
      liveSample.cumulativeValue = _cumulative;

      counter = tempCount;
      cumulativeValue = _cumulative;
      blockTimestampLast = blockTimestamp;
      activeSamples = sampleMemory;
      return;
    }

    // One or more sample boundaries have been crossed.
    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);
    // Finish out the current sample
    cumulativeValue += newLastValue.mul(nextSampleTime - blockTimestampLast);
    liveSample.cumulativeValue = cumulativeValue;
    liveSample.lastValue = newLastValue;

    liveSample = _createNewSample(nextSampleTime, cumulativeValue);
    timeElapsed = timeElapsed - uint64(sampleLength);

    uint256 elapsedSamples = timeElapsed / sampleLength;

    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {
      // update
      cumulativeValue += newLastValue.mul(sampleLength);
      liveSample.cumulativeValue = cumulativeValue;

      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);

      liveSample = _createNewSample(sampleTime, cumulativeValue);
    }

    liveSample.value = newLastValue;
    liveSample.lastValue = newLastValue;
    liveSample.cumulativeValue = _cumulative;

    cumulativeValue = _cumulative;
    blockTimestampLast = blockTimestamp;

    emit Update(newLastValue, cumulativeValue);
  }

  /*
   * INTERNAL VIEW METHODS
   */
  function _getIndexOfSample(uint _count) internal view returns (uint32 index) {
    return uint32(_count % sampleMemory);
  }

  function _getCurrentSample() private view returns (Sample storage currentSample) {
    // Active sample is always counter - 1. Counter is the in progress sample
    uint32 currentSampleIndex = _getIndexOfSample(counter - 1);
    currentSample = samples[currentSampleIndex];
  }

  function _getFirstSample() private view returns (Sample storage firstSample) {
    uint32 sampleIndex = _getIndexOfSample(counter);
    // no overflow issue. if sampleIndex + 1 overflows, result is still zero.
    uint32 firstSampleIndex = uint32((sampleIndex + 1) % sampleMemory);
    firstSample = samples[firstSampleIndex];
  }

  function _getNthSample(uint256 n) private view returns (Sample storage sample) {
    require(n < activeSamples - 1, ""Not enough samples"");
    uint32 sampleIndex = _getIndexOfSample(counter - 1 - n);
    sample = samples[sampleIndex];
  }

  /*
   * INTERNAL METHODS
   */
  function _createNewSample(uint64 sampleTime, uint256 cumulativeValue)
    internal
    returns(Sample storage liveSample)
  {
    Sample storage oldSample = samples[_getIndexOfSample(counter - 1)];
    Sample storage previousSample = samples[_getIndexOfSample(counter)];

    if (oldSample.timestamp > 0 && activeSamples > 1) {
      previousSample.value = (previousSample.cumulativeValue - oldSample.cumulativeValue).div(sampleLength);
    }

    counter += 1;
    liveSample = samples[_getIndexOfSample(counter)];
    liveSample.timestamp = sampleTime;
    liveSample.cumulativeValue = cumulativeValue;
    liveSample.value = previousSample.value;
    liveSample.lastValue = previousSample.lastValue;

    if (activeSamples < sampleMemory) {
      // Active samples is how we keep track of how many real samples we have vs default 0 values
      // This is useful for providing data even when full sample set isn't populated yet
      activeSamples = activeSamples + 1;
    }

    blockTimestampLast = sampleTime;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setSampleLength(uint256 _sampleLength)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_sampleLength > 0, ""Cannot have 0 second sample length"");
    sampleLength = _sampleLength;
  }

  function resetLiveSampleTime()
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    Sample storage liveSample = samples[_getIndexOfSample(counter)];
    liveSample.timestamp = uint64(block.timestamp % 2**64); 
  }

  function setSampleMemory(uint256 _sampleMemory)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    require(_sampleMemory > 0, ""Cannot have sample memroy of 0"");

    if (_sampleMemory > sampleMemory) {
      for (uint i = sampleMemory; i < _sampleMemory; i++) {
        samples.push();
      }
      counter = counter % _sampleMemory;
    } else {
      activeSamples = _sampleMemory;

      // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST
    }

    sampleMemory = _sampleMemory;
  }
}",3391
RealWorld_TA_59_TransferService_RealWorld_20240808085645.log,59,TransferService,77221,3619,80840,156.0,0.458485,"pragma solidity >=0.6.6;

import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./interfaces/IMaltDataLab.sol"";
import ""./Permissions.sol"";

import ""./interfaces/ITransferVerification.sol"";


/// @title Transfer Service
/// @author 0xScotch <scotch@malt.money>
/// @notice A contract that acts like a traffic warden to ensure tranfer verification requests get routed correctly
contract TransferService is Initializable, Permissions {
  address[] public verifierList;
  mapping(address => address) public verifiers;

  event AddVerifier(address indexed source, address verifier);
  event RemoveVerifier(address indexed source, address verifier);

  function initialize(
    address _timelock,
    address initialAdmin
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);
  }

  function verifyTransfer(address from, address to, uint256 amount) public view returns (bool, string memory) {
    if (verifiers[from] != address(0)) {
      (bool valid, string memory reason) = ITransferVerification(verifiers[from]).verifyTransfer(from, to, amount);
      if (!valid) {
        return (false, reason);
      }
    } 

    if (verifiers[to] != address(0)) {
      (bool valid, string memory reason) = ITransferVerification(verifiers[to]).verifyTransfer(from, to, amount);
      if (!valid) {
        return (false, reason);
      }
    } 

    return (true, """");
  }

  function numberOfVerifiers() public view returns(uint256) {
    return verifierList.length;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function addVerifier(address _address, address _verifier) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"") 
  {
    require(_verifier != address(0), ""Cannot use address 0"");
    require(_address != address(0), ""Cannot use address 0"");

    if (verifiers[_address] != address(0)) {
      return;
    }

    verifiers[_address] = _verifier;
    verifierList.push(_address);

    emit AddVerifier(_address, _verifier);
  }

  function removeVerifier(address _address) 
    public
    onlyRole(ADMIN_ROLE, ""Must have admin role"")  
  {
    require(_address != address(0), ""Cannot use address 0"");

    if (verifiers[_address] == address(0)) {
      return;
    }

    address verifier = verifiers[_address];
    verifiers[_address] = address(0);

    emit RemoveVerifier(_address, verifier);

    // Loop until the second last element
    for (uint i = 0; i < verifierList.length - 1; i = i + 1) {
      if (verifierList[i] == _address) {
        // Replace the current item with the last and pop the last away.
        verifierList[i] = verifierList[verifierList.length - 1];
        verifierList.pop();
        return;
      }
    }

    // If we made it here then the verifierList being removed is the last item
    verifierList.pop();
  }
}",684
RealWorld_TA_59_ITransferVerification_RealWorld_20240808104647.log,59,ITransferVerification,21786,1691,23477,101.0,0.14275,"pragma solidity >=0.6.6;

interface ITransferVerification {
  function verifyTransfer(address, address, uint256) external view returns (bool, string memory);
}",35
RealWorld_TA_59_MaltDataLab_RealWorld_20240808101435.log,59,MaltDataLab,218677,2856,221533,153.0,1.150505,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"";

import ""./interfaces/IStabilizerNode.sol"";
import ""./interfaces/IMovingAverage.sol"";
import ""./interfaces/IDAO.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/ILiquidityExtension.sol"";

import ""./libraries/UniswapV2Library.sol"";
import ""./libraries/SafeBurnMintableERC20.sol"";

import ""./Permissions.sol"";


/// @title Malt Data Lab
/// @author 0xScotch <scotch@malt.money>
/// @notice The central source of all of Malt protocol's internal data needs
/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles
contract MaltDataLab is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeBurnMintableERC20 for IBurnMintableERC20;

  bytes32 public constant UPDATER_ROLE = keccak256(""UPDATER_ROLE"");

  IBurnMintableERC20 public rewardToken;
  IBurnMintableERC20 public malt;
  ILiquidityExtension public liquidityExtension;
  IUniswapV2Pair public stakeToken;

  IMovingAverage public reserveRatioMA;
  IMovingAverage public maltPriceMA;
  IMovingAverage public poolMaltReserveMA;

  uint256 public priceTarget = 10**18; // $1
  uint256 public reserveRatioLookback = 10 minutes;
  uint256 public maltPriceLookback = 10 minutes;
  uint256 public reserveLookback = 10 minutes;

  event TrackMaltPrice(uint256 price);
  event TrackPoolReserves(uint256 maltReserves, uint256 rewardReserves);
  event TrackReserveRatio(uint256 rRatio, uint256 decimals);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _malt,
    address _rewardToken,
    address _stakeToken,
    uint256 _priceTarget,
    address _liquidityExtension,
    address _reserveRatioMA,
    address _maltPriceMA,
    address _poolMaltReserveMA,
    address _updater
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);
    _roleSetup(UPDATER_ROLE, _updater);
    _roleSetup(UPDATER_ROLE, initialAdmin);

    stakeToken = IUniswapV2Pair(_stakeToken);
    malt = IBurnMintableERC20(_malt);
    rewardToken = IBurnMintableERC20(_rewardToken);
    priceTarget = _priceTarget;
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    reserveRatioMA = IMovingAverage(_reserveRatioMA);
    maltPriceMA = IMovingAverage(_maltPriceMA);
    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);
  }

  function smoothedReserveRatio() public view returns (uint256) {
    return reserveRatioMA.getValueWithLookback(reserveRatioLookback);
  }

  function smoothedMaltPrice() public view returns (uint256) {
    return maltPriceMA.getValueWithLookback(maltPriceLookback);
  }

  function smoothedMaltInPool() public view returns (uint256) {
    return poolMaltReserveMA.getValueWithLookback(reserveLookback);
  }

  function smoothedReserves() public view returns (uint256 maltReserves, uint256 collateralReserves) {
    maltReserves = poolMaltReserveMA.getValueWithLookback(reserveLookback);
    uint256 price = smoothedMaltPrice();
    return (maltReserves, maltReserves.mul(price).div(priceTarget));
  }

  function reserveRatioAverage(uint256 _lookback) public view returns (uint256) {
    return reserveRatioMA.getValueWithLookback(_lookback);
  }

  function maltPriceAverage(uint256 _lookback) public view returns (uint256) {
    return maltPriceMA.getValueWithLookback(_lookback);
  }

  function maltInPoolAverage(uint256 _lookback) public view returns (uint256) {
    return poolMaltReserveMA.getValueWithLookback(_lookback);
  }

  function realValueOfLPToken(uint256 amount) external view returns (uint256) {
    uint256 maltPrice = smoothedMaltPrice();
    (uint256 maltReserves, uint256 rewardReserves) = smoothedReserves();

    if (maltReserves == 0) {
      return 0;
    }

    uint256 totalLPSupply = stakeToken.totalSupply();

    uint256 maltValue = amount.mul(maltReserves).div(totalLPSupply);
    uint256 rewardValue = amount.mul(rewardReserves).div(totalLPSupply);

    return rewardValue.add(maltValue.mul(maltPrice).div(priceTarget));
  }

  /*
   * Public mutation methods
   */
  function trackReserveRatio() public {
    (uint256 reserveRatio, uint256 decimals) = liquidityExtension.reserveRatio();

    reserveRatioMA.update(reserveRatio);

    emit TrackReserveRatio(reserveRatio, decimals);
  }

  function trackMaltPrice()
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater role"")
  {
    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();
    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));
    uint256 rewardDecimals = rewardToken.decimals();

    if (token0 == address(rewardToken)) {
      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);
      maltPriceMA.update(price);
      emit TrackMaltPrice(price);
    } else {
      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);
      maltPriceMA.update(price);

      emit TrackMaltPrice(price);
    }
  }

  function trackPoolReserves()
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater role"")
  {
    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();
    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));
    uint256 rewardDecimals = rewardToken.decimals();

    if (token0 == address(rewardToken)) {
      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve1);
      emit TrackPoolReserves(reserve1, reserve0);
    } else {
      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve0);
      emit TrackPoolReserves(reserve0, reserve1);
    }
  }

  function trackPool()
    external 
    onlyRole(UPDATER_ROLE, ""Must have updater role"")
  {
    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();
    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));
    uint256 rewardDecimals = rewardToken.decimals();

    if (token0 == address(rewardToken)) {
      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);
      maltPriceMA.update(price);

      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve1);
      emit TrackMaltPrice(price);
      emit TrackPoolReserves(reserve1, reserve0);
    } else {
      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);
      maltPriceMA.update(price);

      // Args are (maltReserve)
      poolMaltReserveMA.update(reserve0);
      emit TrackMaltPrice(price);
      emit TrackPoolReserves(reserve0, reserve1);
    }
  }

  /*
   * INTERNAL METHODS
   */
  function _normalizedPrice(
    uint256 numerator,
    uint256 denominator,
    uint256 decimals
  ) internal view returns(uint256 price) {
    // Malt is 18 decimals
    if (decimals > 18) {
      uint256 diff = decimals - 18;
      price = numerator.mul(10**decimals).div(denominator.mul(10**diff));
    } else if (decimals < 18) {
      uint256 diff = 18 - decimals;
      price = (numerator.mul(10**diff)).mul(10**decimals).div(denominator);
    } else {
      price = numerator.mul(10**decimals).div(denominator);
    }
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setLiquidityExtension(address _liquidityExtension) 
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_liquidityExtension != address(0), ""Must be a valid address"");
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
  }

  function setPriceTarget(uint256 _price)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_price > 0, ""Cannot have 0 price"");
    priceTarget = _price;
  }

  function setReserveRatioLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have 0 lookback"");
    reserveRatioLookback = _lookback;
  }

  function setMaltPriceLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have 0 lookback"");
    maltPriceLookback = _lookback;
  }

  function setReserveLookback(uint256 _lookback)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_lookback > 0, ""Cannot have 0 lookback"");
    reserveLookback = _lookback;
  }

  function setReserveAverageContract(address _reserveRatioMA)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_reserveRatioMA != address(0), ""Cannot use 0 address"");
    reserveRatioMA = IMovingAverage(_reserveRatioMA);
  }

  function setMaltPriceAverageContract(address _maltPriceMA)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_maltPriceMA != address(0), ""Cannot use 0 address"");
    maltPriceMA = IMovingAverage(_maltPriceMA);
  }

  function setMaltReservesAverageContract(address _poolMaltReserveMA)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_poolMaltReserveMA != address(0), ""Cannot use 0 address"");
    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);
  }
}",2420
RealWorld_TA_59_RewardThrottle_RealWorld_20240808102927.log,59,RewardThrottle,242019,5914,247933,202.0,1.328375,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""../Permissions.sol"";
import ""../interfaces/IDAO.sol"";
import ""../interfaces/IOverflow.sol"";
import ""../interfaces/IBonding.sol"";
import ""../interfaces/IDistributor.sol"";

import ""hardhat/console.sol"";

struct State {
  uint256 profit;
  uint256 rewarded;
  uint256 bondedValue;
  uint256 throttle;
}

/// @title Reward Throttle
/// @author 0xScotch <scotch@malt.money>
/// @notice The contract in charge of smoothing out rewards and attempting to find a steady APR
/// @dev The use of smoothingPeriod has some flaws. At the very least the length should be longer
contract RewardThrottle is Initializable, Permissions {
  ERC20 public rewardToken;
  IDAO public dao;
  IBonding public bonding;
  IOverflow public overflowPool;
  IDistributor public distributor;

  uint256 public throttle = 200; // 20%
  uint256 public smoothingPeriod = 48; // 48 epochs = 24 hours

  uint256 internal _activeEpoch;
  mapping(uint256 => State) internal _state;

  event RewardOverflow(uint256 epoch, uint256 overflow);
  event HandleReward(uint256 epoch, uint256 amount);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _dao,
    address _overflowPool,
    address _bonding,
    address _distributor,
    address _rewardToken
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);

    dao = IDAO(_dao);
    overflowPool = IOverflow(_overflowPool);
    bonding = IBonding(_bonding);
    distributor = IDistributor(_distributor);
    rewardToken = ERC20(_rewardToken);
  }

  function handleReward() public {
    uint256 balance = rewardToken.balanceOf(address(this));

    uint256 epoch = dao.epoch();

    checkRewardUnderflow();

    if (epoch > _activeEpoch) {
      _activeEpoch = epoch;
      _state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch); 
      _state[_activeEpoch].profit = balance;
      _state[_activeEpoch].rewarded = 0;
      _state[_activeEpoch].throttle = throttle;
    } else {
      _state[_activeEpoch].profit = _state[_activeEpoch].profit.add(balance);
      _state[_activeEpoch].throttle = throttle; 
    }

    // Fetch targetAPR before we update current epoch state
    uint256 aprTarget = targetAPR();

    // Distribute balance to the correct places
    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {
      uint256 remainder = _getRewardOverflow(balance, aprTarget);
      emit RewardOverflow(_activeEpoch, remainder);

      if (remainder > 0) {
        rewardToken.safeTransfer(address(overflowPool), remainder);

        if (balance > remainder) {
          _sendToDistributor(balance - remainder, _activeEpoch);
        }
      }
    } else {
      _sendToDistributor(balance, _activeEpoch);
    }

    emit HandleReward(epoch, balance);
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function epochAPR(uint256 epoch) public view returns (uint256) {
    // This returns an implied APR based on the distributed rewards and bonded LP at the given epoch
    State memory epochState = _state[epoch];

    uint256 bondedValue = epochState.bondedValue;
    if (bondedValue == 0) {
      bondedValue = bonding.averageBondedValue(epoch); 
      if (bondedValue == 0) {
        return 0;
      }
    }

    // 10000 = 100%
    return epochState.rewarded.mul(10000).mul(dao.epochsPerYear()).div(bondedValue);
  }

  function averageAPR(uint256 startEpoch, uint256 endEpoch) public view returns (uint256) {
    require(startEpoch < endEpoch, ""Start cannot be before the end"");

    uint256 totalAPR = 0;
    for (uint256 i = startEpoch; i < endEpoch; i += 1) {
      totalAPR = totalAPR.add(epochAPR(i));
    }

    return totalAPR / (endEpoch - startEpoch);
  }

  function targetAPR() public view returns (uint256) {
    uint256 epoch = dao.epoch();
    (uint256 target,) = getTargets(epoch, smoothingPeriod);
    return target;
  }

  function targetEpochProfit() public view returns (uint256) {
    uint256 epoch = dao.epoch();
    (, uint256 epochProfitTarget) = getTargets(epoch, smoothingPeriod);
    return epochProfitTarget;
  }

  function getTargets(uint256 epoch, uint256 smoothing) public view returns (uint256, uint256) {
    // Average full APR over smoothingPeriod. Throttled by throttle
    uint256 maxPeriod = Math.min(epoch, smoothing);

    uint256 totalProfit = 0;
    uint256 totalBondedValue = 0;

    // Don't use the current epoch as part of the target calculations
    for (uint256 i = 1; i <= maxPeriod; i = i + 1) {
      totalProfit = totalProfit + _state[epoch - i].profit;
      totalBondedValue = totalBondedValue + _state[epoch - i].bondedValue;
    }

    if (totalBondedValue == 0) {
      return (0, 0);
    }

    totalProfit = totalProfit / maxPeriod;
    totalBondedValue = totalBondedValue / maxPeriod;

    // 10k is used here for more granularity on the APR %
    uint256 fullAPR = totalProfit.mul(10000).mul(dao.epochsPerYear()).div(totalBondedValue);
    // throttle is up to 1000. 1000 = 100%
    uint256 aprTarget = fullAPR.mul(throttle).div(1000);

    // (Target APR, Target profit per epoch)
    return (aprTarget, _desiredProfit(aprTarget, _state[epoch].bondedValue));
  }

  function epochData(uint256 epoch) public view returns (
    uint256 profit,
    uint256 rewarded,
    uint256 bondedValue,
    uint256 throttleAmount
  ) {
    return (
      _state[epoch].profit,
      _state[epoch].rewarded,
      _state[epoch].bondedValue,
      _state[epoch].throttle
    );
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _desiredProfit(uint256 apr, uint256 bondedValue) internal view returns (uint256) {
    return apr.mul(bondedValue).div(dao.epochsPerYear()).div(10000);
  }

  function _epochAprGivenReward(uint256 epoch, uint256 reward) internal view returns (uint256) {
    // This returns an implied APR based on the distributed rewards and bonded LP at the given epoch
    State memory epochState = _state[epoch];
    
    if (epochState.bondedValue == 0) {
      return 0;
    }

    // 10000 = 100%
    return (epochState.rewarded.add(reward)).mul(10000).mul(dao.epochsPerYear()).div(epochState.bondedValue);
  }

  function _getRewardOverflow(uint256 declaredReward, uint256 desiredAPR) internal view returns (uint256 remainder) {
    State memory epochState = _state[_activeEpoch];

    if (desiredAPR == 0) {
      // If desired APR is zero then just allow all rewards through
      return 0;
    }

    uint256 targetProfit = desiredAPR.mul(epochState.bondedValue).div(dao.epochsPerYear()).div(10000);

    if (targetProfit <= epochState.rewarded) {
      return declaredReward;
    }

    uint256 undeclaredReward = targetProfit - epochState.rewarded;

    if (undeclaredReward >= declaredReward) {
      // Declared reward doesn't make up for the difference yet
      return 0;
    }

    remainder = declaredReward - undeclaredReward;
  }

  function _getRewardUnderflow(uint256 desiredAPR, uint256 epoch) internal view returns (uint256 amount) {
    State memory epochState = _state[epoch];

    uint256 targetProfit = desiredAPR.mul(epochState.bondedValue).div(dao.epochsPerYear()).div(10000);

    if (targetProfit <= epochState.rewarded) {
      // Rewarded more than target already. 0 underflow
      return 0;
    }

    return targetProfit - epochState.rewarded;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _sendToDistributor(uint256 amount, uint256 epoch) internal {
    if (amount == 0) {
      return;
    }
    rewardToken.safeTransfer(address(distributor), amount);
    distributor.declareReward(amount);

    _state[epoch].rewarded = _state[epoch].rewarded.add(amount);
    _state[epoch].bondedValue = bonding.averageBondedValue(epoch); 
  }

  function checkRewardUnderflow() public {
    uint256 epoch = dao.epoch();

    // Fill in gaps so APR target is correct
    _fillInEpochGaps(epoch);

    if (epoch > _activeEpoch) {
      for (uint256 i = _activeEpoch; i < epoch; i = i + 1) {
        (uint256 desiredAPR,) = getTargets(i, smoothingPeriod);

        if (epochAPR(i) < desiredAPR) {
          uint256 underflow = _getRewardUnderflow(desiredAPR, i);

          if (underflow > 0) {
            uint256 balance = overflowPool.requestCapital(underflow);

            _sendToDistributor(balance, i);
          }
        } 
      }
    }
  }

  function _fillInEpochGaps(uint256 epoch) internal {
    _state[_activeEpoch].bondedValue = bonding.averageBondedValue(_activeEpoch); 
    // Avoid issues if gap between rewards is greater than one epoch
    for (uint256 i = _activeEpoch + 1; i < epoch; i = i + 1) {
      if (_state[i].rewarded == 0 && _state[i].bondedValue == 0) {
        _state[i].bondedValue = bonding.averageBondedValue(i); 
        _state[i].profit = 0;
        _state[i].rewarded = 0;
        _state[i].throttle = throttle;
      }
    }
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setDao(address _dao) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_dao != address(0), ""Not address 0"");
    dao = IDAO(_dao);
  }

  function setBonding(address _bonding) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_bonding != address(0), ""Not address 0"");
    bonding = IBonding(_bonding);
  }

  function setDistributor(address _distributor) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_distributor != address(0), ""Not address 0"");
    distributor = IDistributor(_distributor);
  }

  function setOverflowPool(address _overflowPool) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_overflowPool != address(0), ""Not address 0"");
    overflowPool = IOverflow(_overflowPool);
  }

  function setThrottle(uint256 _throttle) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_throttle <= 1000, ""Cannot have throttle above 100%"");
    throttle = _throttle;
  }

  function setSmoothingPeriod(uint256 _smoothingPeriod) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_smoothingPeriod > 0, ""No zero smoothing period"");
    smoothingPeriod = _smoothingPeriod;
  }
}",2662
RealWorld_TA_59_IAuctionPool_RealWorld_20240808110643.log,59,IAuctionPool,40088,1368,41456,95.0,0.2278,"pragma solidity >=0.6.6;

interface IAuctionPool {
  function onUnbond(address account, uint256 amount) external;
  function totalBonded() external view returns (uint256);
  function balanceOfBonded(address account) external view returns (uint256);
  function totalDeclaredReward() external view returns (uint256);
  function totalReleasedReward() external view returns (uint256);

  function purchaseArbitrageTokens(uint256 maxAmount)
    external returns (uint256 remaining);
  function claim() external;
  function outstandingArbTokens() external view returns (uint256 outstanding);

  function onBond(address account, uint256 amount) external;
  function withdrawAll() external;
  function withdraw(uint256 rewardAmount) external;
  function totalStakePadding() external view returns(uint256);
  function balanceOfStakePadding(address account) external view returns (uint256);
  function getRewardOwnershipFraction(address account) external view returns(uint256 numerator, uint256 denominator);
  function balanceOfRewards(address account) external view returns (uint256);
  function earned(address account) external view returns (uint256 earnedReward);
  function withdrawForAccount(address account, uint256 amount, address to) external returns (uint256);
}",257
RealWorld_TA_59_AbstractRewardMine_RealWorld_20240808101711.log,59,AbstractRewardMine,193355,4921,198276,178.0,1.065195,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

import ""./Permissions.sol"";


/// @title Abstract Reward Mine
/// @author 0xScotch <scotch@malt.money>
/// @notice The base functionality for tracking user reward ownership, withdrawals etc
/// @dev The contract is abstract so needs to be inherited
abstract contract AbstractRewardMine is Permissions {
  using SafeMath for uint256;

  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(""REWARD_MANAGER_ROLE"");
  bytes32 public constant MINING_SERVICE_ROLE = keccak256(""MINING_SERVICE_ROLE"");

  ERC20 public rewardToken;
  address public miningService;

  uint256 internal _globalStakePadding;
  uint256 internal _globalWithdrawn;
  mapping(address => uint256) internal _userStakePadding;
  mapping(address => uint256) internal _userWithdrawn;

  event Withdraw(address indexed account, uint256 rewarded, address indexed to);

  function onBond(address account, uint256 amount)
    virtual
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    _beforeBond(account, amount);
    _handleStakePadding(account, amount);
    _afterBond(account, amount);
  }

  function onUnbond(address account, uint256 amount)
    virtual
    public
    onlyRole(MINING_SERVICE_ROLE, ""Must having mining service privilege"")
  {
    _beforeUnbond(account, amount);
    // Withdraw all current rewards
    // Done now before we change stake padding below
    uint256 rewardEarned = earned(account);
    _handleWithdrawForAccount(account, rewardEarned, account);

    uint256 bondedBalance = balanceOfBonded(account);

    if (bondedBalance == 0) {
      return;
    }

    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);

    _reconcileWithdrawn(account, amount, bondedBalance);
    _removeFromStakePadding(account, lessStakePadding, ""< stake padding"");
    _afterUnbond(account, amount);
  }

  function _initialSetup(address _rewardToken, address _miningService) internal {
    _roleSetup(MINING_SERVICE_ROLE, _miningService);
    _roleSetup(REWARD_MANAGER_ROLE, _miningService);

    rewardToken = ERC20(_rewardToken);
    miningService = _miningService;
  }

  function withdrawAll() public {
    uint256 rewardEarned = earned(msg.sender);

    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);
  }

  function withdraw(uint256 rewardAmount) external {
    uint256 rewardEarned = earned(msg.sender);

    require(rewardAmount <= rewardEarned, ""< earned"");
    
    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);
  }

  /*
   * METHODS TO OVERRIDE
   */
  function totalBonded() virtual public view returns (uint256);
  function balanceOfBonded(address account) virtual public view returns (uint256);

  /*
   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case
   * of vesting rewards they are different. In that case totalDeclaredReward is total
   * reward, including unvested. totalReleasedReward is just the rewards that have completed
   * the vesting schedule.
   */
  function totalDeclaredReward() virtual public view returns (uint256) {
    return rewardToken.balanceOf(address(this));
  }
  function totalReleasedReward() virtual public view returns (uint256) {
    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;
  }

  /*
   * PUBLIC VIEW FUNCTIONS
   */
  function totalStakePadding() public view returns(uint256) {
    return _globalStakePadding;  
  }

  function balanceOfStakePadding(address account) public view returns (uint256) {
    return _userStakePadding[account];
  }

  function totalWithdrawn() public view returns (uint256) {
    return _globalWithdrawn;
  }

  function withdrawnBalance(address account) public view returns (uint256) {
    return _userWithdrawn[account];
  }

  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {
    numerator = balanceOfRewards(account);
    denominator = totalDeclaredReward();
  }

  function balanceOfRewards(address account) public view returns (uint256) {
    /*
     * This represents the rewards allocated to a given account but does not
     * mean all these rewards are unlocked yet. The earned method will
     * fetch the balance that is unlocked for an account
     */
    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);

    uint256 stakePaddingBalance = balanceOfStakePadding(account);

    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {
      return balanceOfRewardedWithStakePadding - stakePaddingBalance;
    }
    return 0;
  }

  function earned(address account) public view returns (uint256 earnedReward) {
    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);

    if (rewardDenominator > 0) {
      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);
    }
  }

  /*
   * INTERNAL VIEW FUNCTIONS
   */
  function _getFullyPaddedReward(address account) internal view returns (uint256) {
    uint256 globalBondedTotal = totalBonded();
    if (globalBondedTotal == 0) {
      return 0;
    }

    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());
    
    return totalRewardedWithStakePadding
      .mul(balanceOfBonded(account))
      .div(globalBondedTotal);
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _withdraw(address account, uint256 amountReward, address to) internal {
    rewardToken.safeTransfer(to, amountReward);
    _userWithdrawn[account] += amountReward;
    _globalWithdrawn += amountReward;

    emit Withdraw(account, amountReward, to);
  }

  function _handleStakePadding(address account, uint256 amount) internal {
    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());

    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;

    uint256 bondedTotal = totalBonded();

    uint256 newStakePadding = bondedTotal == 0 ?
      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :
      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);

    _addToStakePadding(account, newStakePadding);
  }

  function _addToStakePadding(address account, uint256 amount) internal {
    _userStakePadding[account] = _userStakePadding[account].add(amount);

    _globalStakePadding = _globalStakePadding.add(amount);
  }

  function _removeFromStakePadding(
    address account,
    uint256 amount,
    string memory reason
  ) internal {
    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);

    _globalStakePadding = _globalStakePadding.sub(amount, reason);
  }

  function _reconcileWithdrawn(
    address account,
    uint256 amount,
    uint256 bondedBalance
  ) internal {
    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;
    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, ""< withdrawn"");
    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, ""< global withdrawn"");
  }

  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {
    _beforeWithdraw(account, rewardAmount);

    _withdraw(account, rewardAmount, to);

    _afterWithdraw(account, rewardAmount);
  }

  /*
   * HOOKS
   */
  function _beforeWithdraw(address account, uint256 amount) virtual internal {
    // hook
  }

  function _afterWithdraw(address account, uint256 amount) virtual internal {
    // hook
  }

  function _beforeBond(address account, uint256 amount) virtual internal {
    // hook
  }

  function _afterBond(address account, uint256 amount) virtual internal {
    // hook
  }

  function _beforeUnbond(address account, uint256 amount) virtual internal {
    // hook
  }

  function _afterUnbond(address account, uint256 amount) virtual internal {
    // hook
  }

  /*
   * PRIVILEDGED METHODS
   */
  function withdrawForAccount(address account, uint256 amount, address to)
    external
    onlyRole(REWARD_MANAGER_ROLE, ""Must have reward manager privs"")
    returns (uint256)
  {
    uint256 rewardEarned = earned(account);

    if (rewardEarned < amount) {
      amount = rewardEarned;
    }
    
    _handleWithdrawForAccount(account, amount, to);

    return amount;
  }

  function setRewardToken(address _token)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    rewardToken = ERC20(_token);
  }

  function setMiningService(address _miningService)
    public
    onlyRole(ADMIN_ROLE, ""Must have admin privs"")
  {
    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);
    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);
    miningService = _miningService;
  }
}",2095
RealWorld_TA_59_FaucetTwo_RealWorld_20240808092544.log,59,FaucetTwo,39307,5722,45029,197.0,0.310975,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";

interface IFaucet {
  function faucet() external;
}

contract TestFaucetTwo is Initializable {
  using SafeMath for uint256;

  IFaucet public faucetContract;
  IBurnMintableERC20 public token;

  function initialize(address _faucet, address _token) external initializer {
    faucetContract = IFaucet(_faucet);
    token = IBurnMintableERC20(_token);
  }
  
  function faucet(uint256 _amount) external {
    uint256 balance = 0;
    while (true) {
      faucetContract.faucet();
      balance = token.balanceOf(address(this));

      if (balance > _amount) {
        break;
      }
    }

    token.transfer(msg.sender, balance);
  }
}",225
RealWorld_TA_59_ITransferService_RealWorld_20240808104135.log,59,ITransferService,24666,1900,26566,103.0,0.16133,"pragma solidity >=0.6.6;

interface ITransferService {
  function verifyTransfer(address, address, uint256) external view returns (bool, string memory);
  function numberOfVerifiers() external view returns (uint256);
  function addVerifier(address, address) external;
  function removeVerifier(address) external;
}",66
RealWorld_TA_59_IMiningService_RealWorld_20240808111725.log,59,IMiningService,26735,2193,28928,460.0,0.177535,"pragma solidity >=0.6.6;

interface IMiningService {
  function withdrawAccountRewards(uint256 amount) external;
  function balanceOfRewards(address account) external view returns (uint256);
  function earned(address account) external view returns (uint256);
  function onBond(address account, uint256 amount) external;
  function onUnbond(address account, uint256 amount) external;
  function withdrawRewardsForAccount(address account, uint256 amount) external;
}",99
RealWorld_TA_59_RewardOverflowPool_RealWorld_20240808102351.log,59,RewardOverflowPool,69808,3483,73291,134.0,0.4187,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""../AuctionParticipant.sol"";

/// @title Reward Overflow Pool
/// @author 0xScotch <scotch@malt.money>
/// @notice Allows throttler contract to request capital when the current epoch underflows desired reward
contract RewardOverflowPool is Initializable, AuctionParticipant {
  uint256 public maxFulfillment = 500; // 50%
  address public throttler;

  event FulfilledRequest(uint256 amount);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _rewardThrottle,
    address _rewardToken,
    address _auction,
    address _impliedCollateralService
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(REWARD_THROTTLE_ROLE, _rewardThrottle);

    throttler = _rewardThrottle;

    setupParticipant(
      _impliedCollateralService,
      _rewardToken,
      _auction
    );
  }

  function requestCapital(uint256 amount)
    external
    onlyRole(REWARD_THROTTLE_ROLE, ""Must have Reward throttle privs"")
    returns (uint256 fulfilledAmount)
  {
    uint256 balance = auctionRewardToken.balanceOf(address(this));

    if (balance == 0) {
      return 0;
    }

    // This is the max amount allowable
    fulfilledAmount = balance.mul(maxFulfillment).div(1000);

    if (amount <= fulfilledAmount) {
      fulfilledAmount = amount;
    } 

    auctionRewardToken.safeTransfer(throttler, fulfilledAmount);

    emit FulfilledRequest(fulfilledAmount);

    return fulfilledAmount;
  }

  /*
   * INTERNAL FUNCTIONS
   */
  function _handleRewardDistribution(uint256 amount) override internal {
    // reset claimable rewards as all rewards stay here
    claimableRewards = 0;
  }

  /*
   * PRIVILEDGED FUNCTIONS
   */
  function setMaxFulfillment(uint256 _maxFulfillment) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_maxFulfillment > 0, ""Can't have 0 max fulfillment"");
    require(_maxFulfillment <= 1000, ""Can't have above 100% max fulfillment"");

    maxFulfillment = _maxFulfillment;
  }

  function setThrottler(address _throttler) external onlyRole(ADMIN_ROLE, ""Must have admin privs"") {
    require(_throttler != address(0), ""Not address 0"");

    revokeRole(REWARD_THROTTLE_ROLE, throttler);
    _setupRole(REWARD_THROTTLE_ROLE, _throttler);

    throttler = _throttler;
  }
}",616
RealWorld_TA_59_IImpliedCollateralService_RealWorld_20240808103947.log,59,IImpliedCollateralService,22924,2060,24984,105.0,0.15582,"pragma solidity >=0.6.6;

interface IImpliedCollateralService {
  function handleDeficit(uint256 maxAmount) external;
  function claim() external;
  function getCollateralValueInMalt() external view returns(uint256);
}",52
RealWorld_TA_59_IMovingAverage_RealWorld_20240808111546.log,59,IMovingAverage,24616,1547,26163,97.0,0.15402,"pragma solidity >=0.6.6;

interface IMovingAverage {
  function getValue() external view returns (uint256);
  function getValueWithLookback(uint256 _lookbackTime) external view returns (uint256);
  function update(uint256 newValue) external;
  function updateCumulative(uint256 _cumulative) external;
}",68
RealWorld_TA_59_IForfeit_RealWorld_20240808111009.log,59,IForfeit,20671,1593,22264,99.0,0.135215,"pragma solidity >=0.6.6;

interface IForfeit {
  function handleForfeit() external;
}",23
RealWorld_TA_59_AuctionEscapeHatch_RealWorld_20240808085923.log,59,AuctionEscapeHatch,180402,6054,186456,215.0,1.02309,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/math/Math.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IDexHandler.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./Auction.sol"";


struct EarlyExitData {
  uint256 exitedEarly;
  uint256 earlyExitReturn;
  uint256 maltUsed;
}

struct AuctionExits {
  uint256 exitedEarly;
  uint256 earlyExitReturn;
  uint256 maltUsed;
  mapping(address => EarlyExitData) accountExits;
}


/// @title Auction Escape Hatch
/// @author 0xScotch <scotch@malt.money>
/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit
contract AuctionEscapeHatch is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  IAuction public auction;
  IDexHandler public dexHandler;
  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  uint256 public maxEarlyExitBps = 200; // 20%
  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours

  mapping(uint256 => AuctionExits) internal auctionEarlyExits;

  event EarlyExit(address account, uint256 amount, uint256 received);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    address _auction,
    address _handler
  ) external initializer {
    _adminSetup(_timelock);
    _setupRole(ADMIN_ROLE, initialAdmin);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auction = IAuction(_auction);
    dexHandler = IDexHandler(_handler);
  }

  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {
    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);

    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT
    malt.mint(address(dexHandler), maltQuantity);
    uint256 amountOut = dexHandler.sellMalt();

    require(amountOut > minOut, ""EarlyExit: Insufficient output"");

    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];

    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;
    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;
    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;
    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; 
    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; 
    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; 

    auction.amendAccountParticipation(
      msg.sender,
      _auctionId,
      amount,
      maltQuantity
    );

    collateralToken.safeTransfer(msg.sender, amountOut);
    emit EarlyExit(msg.sender, amount, amountOut);
  }

  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {
    // We don't need all the values
    (,,,,,
     uint256 pegPrice,
     ,
     uint256 auctionEndTime,
     bool active
    ) = auction.getAuctionCore(_auctionId);

    if(active || block.timestamp < auctionEndTime) {
      return 0;
    }

    (
      uint256 userCommitment,
      uint256 userRedeemed,
      uint256 userMaltPurchased
    ) = auction.getAuctionParticipationForAccount(account, _auctionId);

    // This should never overflow due to guards in redemption code
    uint256 userOutstanding = userCommitment - userRedeemed;

    if (amount > userOutstanding) {
      amount = userOutstanding;
    }

    if (amount == 0) {
      return 0;
    }

    (uint256 currentPrice,) = dexHandler.maltMarketPrice();

    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);

    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;

    // setCooloffPeriod guards against cooloffPeriod ever being 0
    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;
    if (progressionBps > 10000) {
      progressionBps = 10000;
    }

    if (fullReturn > amount) {
      // Allow a % of profit to be realised
      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;
      return amount + maxProfit;
    } 

    return fullReturn;
  }

  function accountAuctionExits(address account, uint256 auctionId) external view returns (
    uint256 exitedEarly,
    uint256 earlyExitReturn,
    uint256 maltUsed
  ) {
    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];

    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);
  }

  function globalAuctionExits(uint256 auctionId) external view returns (
    uint256 exitedEarly,
    uint256 earlyExitReturn,
    uint256 maltUsed
  ) {
    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];

    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);
  }

  /*
   * INTERNAL METHODS
   */
  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {
    // We don't need all the values
    (,,,,,
     uint256 pegPrice,
     ,
     uint256 auctionEndTime,
     bool active
    ) = auction.getAuctionCore(_auctionId);

    require(!active, ""Cannot exit early on an active auction"");
    require(block.timestamp > auctionEndTime, ""Auction not over"");

    (
      uint256 userCommitment,
      uint256 userRedeemed,
      uint256 userMaltPurchased
    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);

    // This should never overflow due to guards in redemption code
    if (amount > (userCommitment - userRedeemed)) {
      amount = userCommitment - userRedeemed;
    }

    require(amount > 0, ""Nothing to claim"");

    (uint256 currentPrice,) = dexHandler.maltMarketPrice();

    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);

    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;

    // setCooloffPeriod guards against cooloffPeriod ever being 0
    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;
    if (progressionBps > 10000) {
      progressionBps = 10000;
    }

    if (fullReturn > amount) {
      // Allow a % of profit to be realised
      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;
      uint256 desiredReturn = amount + maxProfit;
      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;
    } 

    return maltQuantity;
  }

  /*
   * PRIVILEDGED METHODS
   */
  function setEarlyExitBps(uint256 _earlyExitBps)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, ""Must be between 0-100%"");
    maxEarlyExitBps = _earlyExitBps;
  }

  function setCooloffPeriod(uint256 _period)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    require(_period > 0, ""Cannot have 0 lookback period"");
    cooloffPeriod = _period;
  }

  function setDexHandler(address _handler)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin privilege"")
  {
    dexHandler = IDexHandler(_handler);
  }
}",1930
RealWorld_TA_59_ImpliedCollateralService_RealWorld_20240808093645.log,59,ImpliedCollateralService,110023,3740,113763,146.0,0.624915,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";

import ""./Permissions.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IAuctionPool.sol"";
import ""./interfaces/IOverflow.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";
import ""./interfaces/IRewardThrottle.sol"";
import ""./interfaces/ISwingTrader.sol"";
import ""./interfaces/ILiquidityExtension.sol"";
import ""./interfaces/IMaltDataLab.sol"";


/// @title Implied Collateral Service
/// @author 0xScotch <scotch@malt.money>
/// @notice A contract that provides an abstraction above individual implied collateral sources
contract ImpliedCollateralService is Initializable, Permissions {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  ERC20 public collateralToken;
  IBurnMintableERC20 public malt;
  IAuctionPool public auctionPool;
  IOverflow public rewardOverflow;
  ISwingTrader public swingTrader;
  ILiquidityExtension public liquidityExtension;
  IMaltDataLab public maltDataLab;

  event SetAuctionPool(address auctionPool);
  event SetRewardOverflow(address rewardOverflow);

  function initialize(
    address _timelock,
    address initialAdmin,
    address _collateralToken,
    address _malt,
    address _auction,
    address _auctionPool,
    address _rewardOverflow,
    address _swingTrader,
    address _liquidityExtension,
    address _maltDataLab
  ) external initializer {
    _adminSetup(_timelock);

    _setupRole(ADMIN_ROLE, initialAdmin);
    _setupRole(AUCTION_ROLE, _auction);

    collateralToken = ERC20(_collateralToken);
    malt = IBurnMintableERC20(_malt);
    auctionPool = IAuctionPool(_auctionPool);
    rewardOverflow = IOverflow(_rewardOverflow);
    swingTrader = ISwingTrader(_swingTrader);
    liquidityExtension = ILiquidityExtension(_liquidityExtension);
    maltDataLab = IMaltDataLab(_maltDataLab);
  }

  function handleDeficit(uint256 maxAmount) external onlyRole(AUCTION_ROLE, ""Must have auction role privs"") {
    if (maxAmount > 0) {
      maxAmount = auctionPool.purchaseArbitrageTokens(maxAmount);
    }

    if (maxAmount > 0) {
      maxAmount = rewardOverflow.purchaseArbitrageTokens(maxAmount);

      // if (maxAmount > 0) {
      //   // TODO IDEA: pull reward out of distributor into auction Pool Tue 16 Nov 2021 00:16:03 GMT
      //   maxAmount = distributor.requestCapital(maxAmount);
      //   if (maxAmount > 0) {
      //     maxAmount = rewardOverflow.purchaseArbitrageTokens(maxAmount);
      //   }
      // }
    }
  }

  function claim() external {
    auctionPool.claim();
    rewardOverflow.claim();
  }

  function setAuctionPool(address _auctionPool)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_auctionPool != address(0), ""Not 0 address"");
    auctionPool = IAuctionPool(_auctionPool);
    emit SetAuctionPool(_auctionPool);
  }

  function setRewardOverflow(address _rewardOverflow)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    require(_rewardOverflow != address(0), ""Not 0 address"");
    rewardOverflow = IOverflow(_rewardOverflow);
    emit SetRewardOverflow(_rewardOverflow);
  }

  function getCollateralValueInMalt() public view returns (uint256 collateral) {
    uint256 maltPrice = maltDataLab.smoothedMaltPrice();
    uint256 target = maltDataLab.priceTarget();

    uint256 auctionPoolBalance = collateralToken.balanceOf(address(auctionPool)).mul(target).div(maltPrice);
    uint256 overflowBalance = collateralToken.balanceOf(address(rewardOverflow)).mul(target).div(maltPrice);
    uint256 liquidityExtensionBalance = collateralToken.balanceOf(address(liquidityExtension)).mul(target).div(maltPrice);
    uint256 swingTraderBalance = collateralToken.balanceOf(address(swingTrader)).mul(target).div(maltPrice);
    uint256 swingTraderMaltBalance = malt.balanceOf(address(swingTrader));

    return auctionPoolBalance + overflowBalance + liquidityExtensionBalance + swingTraderBalance + swingTraderMaltBalance;
  }

  function totalUsefulCollateral() public view returns (uint256 collateral) {
    uint256 auctionPoolBalance = collateralToken.balanceOf(address(auctionPool));
    uint256 overflowBalance = collateralToken.balanceOf(address(rewardOverflow));
    uint256 liquidityExtensionBalance = collateralToken.balanceOf(address(liquidityExtension));
    uint256 swingTraderBalance = collateralToken.balanceOf(address(swingTrader));

    return auctionPoolBalance + overflowBalance + liquidityExtensionBalance + swingTraderBalance;
  }
}",1095
RealWorld_TA_59_Permissions_RealWorld_20240808092903.log,59,Permissions,124328,3031,127359,137.0,0.68226,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";


/// @title Permissions
/// @author 0xScotch <scotch@malt.money>
/// @notice Inherited by almost all Malt contracts to provide access control
contract Permissions is AccessControl {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  // Timelock has absolute power across the system
  bytes32 public constant TIMELOCK_ROLE = keccak256(""TIMELOCK_ROLE"");
  bytes32 public constant ADMIN_ROLE = keccak256(""ADMIN_ROLE"");
  bytes32 public constant GOVERNOR_ROLE = keccak256(""GOVERNOR_ROLE"");

  // Can mint/burn Malt
  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(""MONETARY_BURNER_ROLE"");
  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(""MONETARY_MINTER_ROLE"");

  // Contract types
  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(""STABILIZER_NODE_ROLE"");
  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(""LIQUIDITY_MINE_ROLE"");
  bytes32 public constant AUCTION_ROLE = keccak256(""AUCTION_ROLE"");
  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(""REWARD_THROTTLE_ROLE"");

  address internal globalAdmin;

  mapping(address => uint256) public lastBlock; // protect against reentrancy

  function _adminSetup(address _timelock) internal {
    _roleSetup(TIMELOCK_ROLE, _timelock);
    _roleSetup(ADMIN_ROLE, _timelock);
    _roleSetup(GOVERNOR_ROLE, _timelock);
    _roleSetup(MONETARY_BURNER_ROLE, _timelock);
    _roleSetup(MONETARY_MINTER_ROLE, _timelock);
    _roleSetup(STABILIZER_NODE_ROLE, _timelock);
    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);
    _roleSetup(AUCTION_ROLE, _timelock);
    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);

    globalAdmin = _timelock;
  }

  function assignRole(bytes32 role, address _assignee)
    external
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    _setupRole(role, _assignee);
  }

  function removeRole(bytes32 role, address _entity)
    external
    onlyRole(TIMELOCK_ROLE, ""Only timelock can revoke roles"")
  {
    revokeRole(role, _entity);
  }

  function reassignGlobalAdmin(address _admin)
    external
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);
    _swapRole(_admin, globalAdmin, ADMIN_ROLE);
    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);
    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);
    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);
    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);
    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);
    _swapRole(_admin, globalAdmin, AUCTION_ROLE);
    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);

    globalAdmin = _admin;
  }

  function emergencyWithdrawGAS(address payable destination)
    external 
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    // Transfers the entire balance of the Gas token to destination
    destination.call{value: address(this).balance}('');
  }

  function emergencyWithdraw(address _token, address destination)
    external 
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    // Transfers the entire balance of an ERC20 token at _token to destination
    ERC20 token = ERC20(_token);
    token.safeTransfer(destination, token.balanceOf(address(this)));
  }

  function partialWithdrawGAS(address payable destination, uint256 amount)
    external 
    onlyRole(TIMELOCK_ROLE, ""Must have timelock role"")
  {
    destination.call{value: amount}('');
  }

  function partialWithdraw(address _token, address destination, uint256 amount)
    external 
    onlyRole(TIMELOCK_ROLE, ""Only timelock can assign roles"")
  {
    ERC20 token = ERC20(_token);
    token.safeTransfer(destination, amount);
  }

  /*
   * INTERNAL METHODS
   */
  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {
    revokeRole(role, oldAccount);
    _setupRole(role, newAccount);
  }

  function _roleSetup(bytes32 role, address account) internal {
    _setupRole(role, account);
    _setRoleAdmin(role, ADMIN_ROLE);
  }

  function _onlyRole(bytes32 role, string memory reason) internal view {
    require(
      hasRole(
        role,
        _msgSender()
      ),
      reason
    );
  }

  function _notSameBlock() internal {
    require(
      block.number > lastBlock[_msgSender()],
      ""Can't carry out actions in the same block""
    );
    lastBlock[_msgSender()] = block.number;
  }

  // Using internal function calls here reduces compiled bytecode size
  modifier onlyRole(bytes32 role, string memory reason) {
    _onlyRole(role, reason);
    _;
  }

  modifier notSameBlock() {
    _notSameBlock();
    _;
  }
}",1272
RealWorld_TA_59_Faucet_RealWorld_20240808101221.log,59,Faucet,31538,3243,34781,131.0,0.22255,"pragma solidity >=0.6.6;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/upgrades/contracts/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""./interfaces/IBurnMintableERC20.sol"";


contract TestFaucet is Initializable {
  using SafeMath for uint256;

  IBurnMintableERC20 public token;

  function initialize(address _token) external initializer {
    token = IBurnMintableERC20(_token);
  }
  
  function faucet() external {
    uint256 decimals = token.decimals();
    token.mint(msg.sender, 10000*10**decimals);
  }
}",153
RealWorld_TA_59_IAuctionStartController_RealWorld_20240808112829.log,59,IAuctionStartController,20686,1582,22268,105.0,0.13507,"pragma solidity >=0.6.6;

interface IAuctionStartController {
  function checkForStart() external view returns(bool);
}",27
RealWorld_TA_60_IFactory_RealWorld_20240808134729.log,60,IFactory,82978,2364,85342,86.0,0.46217,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""./ICollateral.sol"";
import ""./IIncentivizer.sol"";
import ""./IProduct.sol"";
import ""./IProductProvider.sol"";
import ""../utils/types/UFixed18.sol"";

interface IFactory {
    /// @dev Controller of a one or many products
    struct Controller {
        /// @dev Owner of the product, allowed to update select parameters
        address owner;

        /// @dev Treasury of the product, collects fees
        address treasury;
    }

    event CollateralUpdated(ICollateral newCollateral);
    event IncentivizerUpdated(IIncentivizer newIncentivizer);
    event ProductBaseUpdated(IProduct newProductBase);
    event FeeUpdated(UFixed18 newFee);
    event MinFundingFeeUpdated(UFixed18 newMinFundingFee);
    event MinCollateralUpdated(UFixed18 newMinCollateral);
    event ControllerUpdated(uint256 indexed controllerId, address newOwner, address newTreasury);
    event AllowedUpdated(uint256 indexed controllerId, bool allowed);
    event PauserUpdated(address pauser);
    event IsPausedUpdated(bool isPaused);
    event ControllerCreated(uint256 indexed controllerId, address owner, address treasury);
    event ProductCreated(IProduct indexed product, IProductProvider provider);

    error FactoryAlreadyInitializedError();
    error FactoryNoZeroControllerError();
    error FactoryNotAllowedError();
    error FactoryNotPauserError(address sender);
    error FactoryNotOwnerError(uint256 controllerId);

    function initialized() external view returns (bool);
    function pauser() external view returns (address);
    function isPaused() external view returns (bool);
    function collateral() external view returns (ICollateral);
    function incentivizer() external view returns (IIncentivizer);
    function productBase() external view returns (IProduct);
    function controllers(uint256 collateralId) external view returns (Controller memory);
    function controllerFor(IProduct product) external view returns (uint256);
    function allowed(uint256 collateralId) external view returns (bool);
    function fee() external view returns (UFixed18);
    function minFundingFee() external view returns (UFixed18);
    function minCollateral() external view returns (UFixed18);
    function initialize(ICollateral collateral_, IIncentivizer incentivizer_, IProduct productBase_, address treasury_) external;
    function createController(address controllerTreasury) external returns (uint256);
    function updateController(uint256 controllerId, Controller memory newController) external;
    function createProduct(uint256 controllerId, IProductProvider provider) external returns (IProduct);
    function updateCollateral(ICollateral newCollateral) external;
    function updateIncentivizer(IIncentivizer newIncentivizer) external;
    function updateProductBase(IProduct newProductBase) external;
    function updateFee(UFixed18 newFee) external;
    function updateMinFundingFee(UFixed18 newMinFundingFee) external;
    function updateMinCollateral(UFixed18 newMinCollateral) external;
    function updatePauser(address newPauser) external;
    function updateIsPaused(bool newIsPaused) external;
    function updateAllowed(uint256 controllerId, bool newAllowed) external;
    function isProduct(IProduct product) external view returns (bool);
    function owner() external view returns (address);
    function owner(uint256 controllerId) external view returns (address);
    function owner(IProduct product) external view returns (address);
    function treasury() external view returns (address);
    function treasury(uint256 controllerId) external view returns (address);
    function treasury(IProduct product) external view returns (address);
}",772
RealWorld_TA_60_Product_RealWorld_20240808125627.log,60,Product,274618,4989,279607,228.0,1.47287,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../interfaces/IProduct.sol"";
import ""../interfaces/IProductProvider.sol"";
import ""./types/position/AccountPosition.sol"";
import ""./types/accumulator/AccountAccumulator.sol"";
import ""../utils/unstructured/UReentrancyGuard.sol"";
import ""../factory/UFactoryProvider.sol"";

/**
 * @title Product
 * @notice Manages logic and state for a single product market.
 * @dev Cloned by the Factory contract to launch new product markets.
 */
contract Product is IProduct, UFactoryProvider, UReentrancyGuard {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using AccumulatorLib for Accumulator;
    using PositionLib for Position;
    using PrePositionLib for PrePosition;
    using AccountAccumulatorLib for AccountAccumulator;
    using VersionedAccumulatorLib for VersionedAccumulator;
    using AccountPositionLib for AccountPosition;
    using VersionedPositionLib for VersionedPosition;

    /// @dev The parameter provider of the product market
    IProductProvider public provider;

    /// @dev The individual position state for each account
    mapping(address => AccountPosition) private _positions;

    /// @dev The global position state for the product
    VersionedPosition private _position;

    /// @dev The individual accumulator state for each account
    mapping(address => AccountAccumulator) private _accumulators;

    /// @dev The global accumulator state for the product
    VersionedAccumulator private _accumulator;

    /**
     * @notice Initializes the contract state
     * @param provider_ Product provider contract address
     */
    function initialize(IProductProvider provider_) external {
        UFactoryProvider__initialize(IFactory(msg.sender));
        UReentrancyGuard__initialize();

        provider = provider_;
    }

    /**
     * @notice Surfaces global settlement externally
     */
    function settle() nonReentrant notPaused external {
        settleInternal();
    }

    /**
     * @notice Core global settlement flywheel
     * @dev
     *  a) last settle oracle version
     *  b) latest pre position oracle version
     *  c) current oracle version
     *
     *  Settles from a->b then from b->c if either interval is non-zero to account for a change
     *  in position quantity at (b).
     *
     *  Syncs each to instantaneously after the oracle update.
     */
    function settleInternal() internal {
        provider.sync();
        factory().incentivizer().sync();

        uint256 oracleVersionPreSettle = _position.pre.oracleVersionToSettle(provider);
        uint256 oracleVersionCurrent = provider.currentVersion();
        UFixed18 accumulatedFee;

        // value a->b
        accumulatedFee = accumulatedFee.add(_accumulator.accumulate(_position, factory(), provider, oracleVersionPreSettle));

        // position a->b
        accumulatedFee = accumulatedFee.add(_position.settle(provider, oracleVersionPreSettle));

        // short-circuit if a->c
        if (oracleVersionPreSettle != oracleVersionCurrent) {

            // value b->c
            accumulatedFee = accumulatedFee.add(_accumulator.accumulate(_position, factory(), provider, oracleVersionCurrent));

            // position b->c (stamp c, does not settle pre position)
            _position.settle(provider, oracleVersionCurrent);
        }

        // settle collateral
        factory().collateral().settleProduct(accumulatedFee);

        emit Settle(oracleVersionPreSettle, oracleVersionCurrent);
    }

    /**
     * @notice Surfaces account settlement externally
     * @param account Account to settle
     */
    function settleAccount(address account) notPaused nonReentrant external {
        settleAccountInternal(account);
    }

    /**
     * @notice Core account settlement flywheel
     * @param account Account to settle
     * @dev
     *  a) last settle oracle version
     *  b) latest pre position oracle version
     *  c) current oracle version
     *
     *  Settles from a->b then from b->c if either interval is non-zero to account for a change
     *  in position quantity at (b).
     *
     *  Syncs each to instantaneously after the oracle update.
     */
    function settleAccountInternal(address account) internal {
        (IIncentivizer incentivizer, ICollateral collateral) = (factory().incentivizer(), factory().collateral());
        uint256 oracleVersionPreSettle = _positions[account].pre.oracleVersionToSettle(provider);
        uint256 oracleVersionCurrent = provider.currentVersion();
        Fixed18 accumulated;

        // value a->b
        accumulated = accumulated.add(_accumulators[account].syncTo(_accumulator, _positions[account], oracleVersionPreSettle).sum());

        // sync incentivizer before position update
        incentivizer.syncAccount(account);

        // position a->b
        accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));

        // short-circuit if a->c
        if (oracleVersionPreSettle != oracleVersionCurrent) {

            // value b->c
            accumulated = accumulated.add(_accumulators[account].syncTo(_accumulator, _positions[account], oracleVersionCurrent).sum());

            // position b->c (stamp c, does not settle pre position)
            _positions[account].settle(provider, oracleVersionCurrent);
        }

        // settle collateral
        collateral.settleAccount(account, accumulated);

        emit AccountSettle(account, oracleVersionPreSettle, oracleVersionCurrent);
    }

    /**
     * @notice Opens a taker position for `msg.sender`
     * @param amount Amount of the position to open
     */
    function openTake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    takerInvariant
    positionInvariant
    liquidationInvariant
    maintenanceInvariant
    external {
        _positions[msg.sender].pre.openTake(provider, amount);
        _position.pre.openTake(provider, amount);

        emit TakeOpened(msg.sender, amount);
    }

    /**
     * @notice Closes a taker position for `msg.sender`
     * @param amount Amount of the position to close
     */
    function closeTake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    closeInvariant
    liquidationInvariant
    external {
        closeTakeInternal(msg.sender, amount);
    }

    function closeTakeInternal(address account, UFixed18 amount) internal {
        _positions[account].pre.closeTake(provider, amount);
        _position.pre.closeTake(provider, amount);

        emit TakeClosed(account, amount);
    }

    /**
     * @notice Opens a maker position for `msg.sender`
     * @param amount Amount of the position to open
     */
    function openMake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    makerInvariant
    positionInvariant
    liquidationInvariant
    maintenanceInvariant
    external {
        _positions[msg.sender].pre.openMake(provider, amount);
        _position.pre.openMake(provider, amount);

        emit MakeOpened(msg.sender, amount);
    }

    /**
     * @notice Closes a maker position for `msg.sender`
     * @param amount Amount of the position to close
     */
    function closeMake(UFixed18 amount)
    notPaused
    nonReentrant
    settleForAccount(msg.sender)
    takerInvariant
    closeInvariant
    liquidationInvariant
    external {
        closeMakeInternal(msg.sender, amount);
    }

    function closeMakeInternal(address account, UFixed18 amount) internal {
        _positions[account].pre.closeMake(provider, amount);
        _position.pre.closeMake(provider, amount);

        emit MakeClosed(account, amount);
    }

    /**
     * @notice Closes all open and pending positions, locking for liquidation
     * @dev Only callable by the Collateral contract as part of the liquidation flow
     * @param account Account to close out
     */
    function closeAll(address account) onlyCollateral settleForAccount(account) external {
        Position memory p = _positions[account].position.next(_positions[account].pre);

        // Close all positions
        closeMakeInternal(account, p.maker);
        closeTakeInternal(account, p.taker);

        // Mark liquidation to lock position
        _positions[account].liquidation = true;
    }

    /**
     * @notice Returns the maintenance requirement for `account`
     * @param account Account to return for
     * @return The current maintenance requirement
     */
    function maintenance(address account) public view returns (UFixed18) {
        return _positions[account].maintenance(provider);
    }

    /**
     * @notice Returns the maintenance requirement for `account` after next settlement
     * @dev Assumes no price change and no funding, used to protect user from over-opening
     * @param account Account to return for
     * @return The next maintenance requirement
     */
    function maintenanceNext(address account) public view returns (UFixed18) {
        return _positions[account].maintenanceNext(provider);
    }

    /**
     * @notice Returns whether `account` has a completely zero'd position
     * @param account Account to return for
     * @return The the account is closed
     */
    function isClosed(address account) external view returns (bool) {
        return _positions[account].isClosed();
    }

    /**
     * @notice Returns whether `account` is currently locked for an in-progress liquidation
     * @param account Account to return for
     * @return Whether the account is in liquidation
     */
    function isLiquidating(address account) external view returns (bool) {
        return _positions[account].liquidation;
    }

    /**
     * @notice Returns `account`'s current position
     * @param account Account to return for
     * @return Current position of the account
     */
    function position(address account) external view returns (Position memory) {
        return _positions[account].position;
    }

    /**
     * @notice Returns `account`'s current pending-settlement position
     * @param account Account to return for
     * @return Current pre-position of the account
     */
    function pre(address account) external view returns (PrePosition memory) {
        return _positions[account].pre;
    }

    /**
     * @notice Returns the global latest settled oracle version
     * @return Latest settled oracle version of the product
     */
    function latestVersion() external view returns (uint256) {
        return _position.latestVersion;
    }

    /**
     * @notice Returns the global position at oracleVersion `oracleVersion`
     * @dev Only valid for the version at which a global settlement occurred
     * @param oracleVersion Oracle version to return for
     * @return Global position at oracle version
     */
    function positionAtVersion(uint256 oracleVersion) external view returns (Position memory) {
        return _position.positionAtVersion[oracleVersion];
    }

    /**
     * @notice Returns the current global pending-settlement position
     * @return Global pending-settlement position
     */
    function pre() external view returns (PrePosition memory) {
        return _position.pre;
    }

    /**
     * @notice Returns the global accumulator value at oracleVersion `oracleVersion`
     * @dev Only valid for the version at which a global settlement occurred
     * @param oracleVersion Oracle version to return for
     * @return Global accumulator value at oracle version
     */
    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {
        return _accumulator.valueAtVersion[oracleVersion];
    }

    /**
     * @notice Returns the global accumulator share at oracleVersion `oracleVersion`
     * @dev Only valid for the version at which a global settlement occurred
     * @param oracleVersion Oracle version to return for
     * @return Global accumulator share at oracle version
     */
    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory) {
        return _accumulator.shareAtVersion[oracleVersion];
    }

    /**
     * @notice Returns `account`'s latest settled oracle version
     * @param account Account to return for
     * @return Latest settled oracle version of the account
     */
    function latestVersion(address account) external view returns (uint256) {
        return _accumulators[account].latestVersion;
    }

    /// @dev Limit total maker for guarded rollouts
    modifier makerInvariant {
        _;

        Position memory next = _position.position().next(_position.pre);

        if (next.maker.gt(provider.makerLimit())) revert ProductMakerOverLimitError();
    }

    /// @dev Limit maker short exposure to the range 0.0-1.0x of their position
    modifier takerInvariant {
        _;

        Position memory next = _position.position().next(_position.pre);
        UFixed18 socializationFactor = next.socializationFactor();

        if (socializationFactor.lt(UFixed18Lib.ONE)) revert ProductInsufficientLiquidityError(socializationFactor);
    }

    /// @dev Ensure that the user has only taken a maker or taker position, but not both
    modifier positionInvariant {
        _;

        if (_positions[msg.sender].isDoubleSided()) revert ProductDoubleSidedError();
    }

    /// @dev Ensure that the user hasn't closed more than is open
    modifier closeInvariant {
        _;

        if (_positions[msg.sender].isOverClosed()) revert ProductOverClosedError();
    }

    /// @dev Ensure that the user will have sufficient margin for maintenance after next settlement
    modifier maintenanceInvariant {
        _;

        if (factory().collateral().liquidatableNext(msg.sender, IProduct(this)))
            revert ProductInsufficientCollateralError();
    }

    /// @dev Ensure that the user is not currently being liquidated
    modifier liquidationInvariant {
        if (_positions[msg.sender].liquidation) revert ProductInLiquidationError();

        _;
    }

    /// @dev Helper to fully settle an account's state
    modifier settleForAccount(address account) {
        settleInternal();
        settleAccountInternal(account);

        _;
    }
}",3043
RealWorld_TA_60_VersionedPosition_RealWorld_20240808131426.log,60,VersionedPosition,57603,2527,60130,158.0,0.338555,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./PrePosition.sol"";

//// @dev VersionedPosition type
struct VersionedPosition {
    /// @dev Latest synced oracle version
    uint256 latestVersion;

    /// @dev Mapping of global position at each version
    mapping(uint256 => Position) positionAtVersion;

    /// @dev Current global pending-settlement position delta
    PrePosition pre;
}

/**
 * @title VersionedPositionLib
 * @notice Library that manages global position state.
 * @dev Global position state is used to compute utilization rate and socialization, and to account for and
 *      distribute fees globally.
 *
 *      Positions are stamped for historical lookup anytime there is a global settlement, which services
 *      the delayed-position accounting. It is not guaranteed that every version will have a value stamped, but
 *      only versions when a settlement occurred are needed for this historical computation.
 */
library VersionedPositionLib {
    using PositionLib for Position;
    using PrePositionLib for PrePosition;

    /**
     * @notice Returns the current global position
     * @return Current global position
     */
    function position(VersionedPosition storage self) internal view returns (Position memory) {
        return self.positionAtVersion[self.latestVersion];
    }

    /**
     * @notice Settled the global position to oracle version `toOracleVersion`
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return positionFee The fee accrued from opening or closing a new position
     */
    function settle(VersionedPosition storage self, IProductProvider provider, uint256 toOracleVersion) internal returns (UFixed18 positionFee) {
        if (toOracleVersion <= self.latestVersion) return UFixed18Lib.ZERO;

        bool settled;
        (self.positionAtVersion[toOracleVersion], positionFee, settled) = position(self).settled(self.pre, provider, toOracleVersion);
        if (settled) delete self.pre;

        self.latestVersion = toOracleVersion;
    }
}",455
RealWorld_TA_60_ProductProvider_RealWorld_20240808130251.log,60,ProductProvider,56008,1205,57213,143.0,0.30414,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../interfaces/IProductProvider.sol"";
import ""../../interfaces/IFactory.sol"";
import ""../../utils/types/UFixed18.sol"";

/**
 * @title ProductProviderLib
 * @notice Library that adds a safeguard wrapper to certain product parameters.
 * @dev Product providers are semi-untrusted as they contain custom code from the product owners. Owners
 *      have full control over this parameter-setting code, however there are some ""known ranges"" that
 *      a parameter cannot be outside of (i.e. a fee being over 100%).
 */
library ProductProviderLib {
    using UFixed18Lib for UFixed18;

    /**
     * @notice Returns the minimum funding fee parameter with a capped range for safety
     * @dev Caps factory.minFundingFee() <= self.minFundingFee() <= 1
     * @param self The parameter provider to operate on
     * @param factory The protocol Factory contract
     * @return Safe minimum funding fee parameter
     */
    function safeFundingFee(IProductProvider self, IFactory factory) internal view returns (UFixed18) {
        return self.fundingFee().max(factory.minFundingFee()).min(UFixed18Lib.ONE);
    }

    /**
     * @notice Returns the maker fee parameter with a capped range for safety
     * @dev Caps self.makerFee() <= 1
     * @param self The parameter provider to operate on
     * @return Safe maker fee parameter
     */
    function safeMakerFee(IProductProvider self) internal view returns (UFixed18) {
        return self.makerFee().min(UFixed18Lib.ONE);
    }

    /**
     * @notice Returns the taker fee parameter with a capped range for safety
     * @dev Caps self.takerFee() <= 1
     * @param self The parameter provider to operate on
     * @return Safe taker fee parameter
     */
    function safeTakerFee(IProductProvider self) internal view returns (UFixed18) {
        return self.takerFee().min(UFixed18Lib.ONE);
    }
}",453
RealWorld_TA_60_VersionedAccumulator_RealWorld_20240808131706.log,60,VersionedAccumulator,161700,3554,165254,213.0,0.87958,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./Accumulator.sol"";
import ""../position/VersionedPosition.sol"";
import ""../ProductProvider.sol"";

/// @dev VersionedAccumulator type
struct VersionedAccumulator {
    /// @dev Latest synced oracle version
    uint256 latestVersion;

    /// @dev Mapping of accumulator value at each settled oracle version
    mapping(uint256 => Accumulator) valueAtVersion;

    /// @dev Mapping of accumulator share at each settled oracle version
    mapping(uint256 => Accumulator) shareAtVersion;
}

/**
 * @title VersionedAccumulatorLib
 * @notice Library that manages global versioned accumulator state.
 * @dev Manages two accumulators: value and share. The value accumulator measures the change in position value
 *      over time. The share accumulator measures the change in liquidity ownership over time (for tracking
 *      incentivization rewards).
 *
 *      Both accumulators are stamped for historical lookup anytime there is a global settlement, which services
 *      the delayed-position accounting. It is not guaranteed that every version will have a value stamped, but
 *      only versions when a settlement occurred are needed for this historical computation.
 */
library VersionedAccumulatorLib {
    using Fixed18Lib for Fixed18;
    using UFixed18Lib for UFixed18;
    using PositionLib for Position;
    using VersionedPositionLib for VersionedPosition;
    using AccumulatorLib for Accumulator;
    using ProductProviderLib for IProductProvider;

    /**
     * @notice Globally accumulates all value (position + funding) and share since last oracle update
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param factory The Factory contract of the protocol
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedFee The total fee accrued from accumulation
     */
    function accumulate(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IFactory factory,
        IProductProvider provider,
        uint256 toOracleVersion
    ) internal returns (UFixed18 accumulatedFee) {
        // accumulate funding
        Accumulator memory accumulatedFunding;
        (accumulatedFunding, accumulatedFee) =
            accumulateFunding(self, position, factory, provider, toOracleVersion);

        // accumulate position
        Accumulator memory accumulatedPosition =
            accumulatePosition(self, position, provider, toOracleVersion);

        // accumulate share
        Accumulator memory accumulatedShare =
            accumulateShare(self, position, provider, toOracleVersion);

        // save update
        self.valueAtVersion[toOracleVersion] = self.valueAtVersion[self.latestVersion]
            .add(accumulatedFunding)
            .add(accumulatedPosition);
        self.shareAtVersion[toOracleVersion] = self.shareAtVersion[self.latestVersion].add(accumulatedShare);
        self.latestVersion = toOracleVersion;
    }

    /**
     * @notice Globally accumulates all funding since last oracle update
     * @dev If an oracle version is skipped due to no pre positions, funding will continue to be
     *      pegged to the price of the last snapshotted oracleVersion until a new one is accumulated.
     *      This is an acceptable approximation.
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param factory The Factory contract of the protocol
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedFunding The total amount accumulated from funding
     * @return accumulatedFee The total fee accrued from funding accumulation
     */
    function accumulateFunding(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IFactory factory,
        IProductProvider provider,
        uint256 toOracleVersion
    ) private view returns (Accumulator memory accumulatedFunding, UFixed18 accumulatedFee) {
        Position memory p = position.position();
        if (p.taker.isZero()) return (Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO}), UFixed18Lib.ZERO);
        if (p.maker.isZero()) return (Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO}), UFixed18Lib.ZERO);

        uint256 elapsed = provider.timestampAtVersion(toOracleVersion) - provider.timestampAtVersion(self.latestVersion);

        UFixed18 takerNotional = Fixed18Lib.from(p.taker).mul(provider.priceAtVersion(self.latestVersion)).abs();
        UFixed18 socializedNotional = takerNotional.mul(p.socializationFactor());

        Fixed18 rateAccumulated = provider.rate(p).mul(Fixed18Lib.from(UFixed18Lib.from(elapsed)));
        Fixed18 fundingAccumulated = rateAccumulated.mul(Fixed18Lib.from(socializedNotional));
        accumulatedFee = fundingAccumulated.abs().mul(provider.safeFundingFee(factory));

        Fixed18 fundingIncludingFee = Fixed18Lib.from(
            fundingAccumulated.sign(),
            fundingAccumulated.abs().sub(accumulatedFee)
        );

        accumulatedFunding.maker = fundingIncludingFee.div(Fixed18Lib.from(p.maker));
        accumulatedFunding.taker = fundingIncludingFee.div(Fixed18Lib.from(p.taker)).mul(Fixed18Lib.NEG_ONE);
    }

    /**
     * @notice Globally accumulates position PNL since last oracle update
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedPosition The total amount accumulated from position PNL
     */
    function accumulatePosition(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IProductProvider provider,
        uint256 toOracleVersion
    ) private view returns (Accumulator memory accumulatedPosition) {
        Position memory p = position.position();
        if (p.taker.isZero()) return Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO});
        if (p.maker.isZero()) return Accumulator({maker: Fixed18Lib.ZERO, taker: Fixed18Lib.ZERO});

        Fixed18 oracleDelta = provider.priceAtVersion(toOracleVersion).sub(provider.priceAtVersion(self.latestVersion));
        Fixed18 totalTakerDelta = oracleDelta.mul(Fixed18Lib.from(p.taker));
        Fixed18 socializedTakerDelta = totalTakerDelta.mul(Fixed18Lib.from(p.socializationFactor()));

        accumulatedPosition.maker = socializedTakerDelta.div(Fixed18Lib.from(p.maker)).mul(Fixed18Lib.NEG_ONE);
        accumulatedPosition.taker = socializedTakerDelta.div(Fixed18Lib.from(p.taker));
    }

    /**
     * @notice Globally accumulates position's share of the total market since last oracle update
     * @dev This is used to compute incentivization rewards based on market participation
     * @param self The struct to operate on
     * @param position Pointer to global position
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return accumulatedShare The total share amount accumulated per position
     */
    function accumulateShare(
        VersionedAccumulator storage self,
        VersionedPosition storage position,
        IProductProvider provider,
        uint256 toOracleVersion
    ) private view returns (Accumulator memory accumulatedShare) {
        Position memory p = position.position();
        uint256 elapsed = provider.timestampAtVersion(toOracleVersion) - provider.timestampAtVersion(self.latestVersion);

        accumulatedShare.maker = p.maker.isZero() ? Fixed18Lib.ZERO : Fixed18Lib.from(UFixed18Lib.from(elapsed).div(p.maker));
        accumulatedShare.taker = p.taker.isZero() ? Fixed18Lib.ZERO : Fixed18Lib.from(UFixed18Lib.from(elapsed).div(p.taker));
    }
}",1727
RealWorld_TA_60_Factory_RealWorld_20240808134130.log,60,Factory,193635,3867,197502,119.0,1.045515,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""../interfaces/IFactory.sol"";
import ""../interfaces/ICollateral.sol"";
import ""../interfaces/IIncentivizer.sol"";
import ""../interfaces/IProduct.sol"";

/**
 * @title Factory
 * @notice Manages creating new products and global protocol parameters.
 */
contract Factory is IFactory {

    /// @dev Whether the factory has been initialized
    bool public initialized;

    /// @dev Secondary pauser address (not owner, but has permission to update isPaused)
    address public pauser;

    /// @dev Whether the protocol is currently paused
    bool public isPaused;

    /// @dev Collateral contract address for the protocol
    ICollateral public collateral;

    /// @dev Incentivizer contract address for the protocol
    IIncentivizer public incentivizer;

    /// @dev Base Product implementation contract address for the protocol
    IProduct public productBase;

    /// @dev List of product controllers
    Controller[] private _controllers;

    /// @dev Mapping of the controller for each  product
    mapping(IProduct => uint256) public controllerFor;

    /// @dev Whether a specific controller is allowed to create a new product
    mapping(uint256 => bool) public allowed;

    /// @dev Percent of the fee that goes to the protocol treasury vs the product treasury
    UFixed18 public fee;

    /// @dev Minimum allowable funding fee for a product
    UFixed18 public minFundingFee;

    /// @dev Minimum allowable collateral amount per user account
    UFixed18 public minCollateral;

    /**
     * @notice Initializes the contract state
     * @param collateral_ Collateral contract address
     * @param incentivizer_ Incentivizer contract address
     * @param productBase_ Base Product implementation contract address
     * @param treasury_ Protocol treasury address
     */
    function initialize(
        ICollateral collateral_,
        IIncentivizer incentivizer_,
        IProduct productBase_,
        address treasury_
    ) external {
        if (initialized) revert FactoryAlreadyInitializedError();

        createController(treasury_);

        updatePauser(msg.sender);
        updateCollateral(collateral_);
        updateIncentivizer(incentivizer_);
        updateProductBase(productBase_);
        updateFee(UFixed18Lib.ratio(50, 100));
        updateMinFundingFee(UFixed18Lib.ratio(10, 100));

        initialized = true;
    }

    /**
     * @notice Creates a new controller with `msg.sender` as the owner
     * @param controllerTreasury Treasury address for the controller
     * @return New controller ID
     */
    function createController(address controllerTreasury) public returns (uint256) {
        uint256 controllerId = _controllers.length;

        _controllers.push(Controller({
            owner: msg.sender,
            treasury: controllerTreasury
        }));

        emit ControllerCreated(controllerId, msg.sender, controllerTreasury);

        return controllerId;
    }

    /**
     * @notice Updates the owner and treasury of an existing controller
     * @dev Must be called by the controller's current owner
     * @param controllerId Controller to update
     * @param newController New controller owner and treasury
     */
    function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {
        _controllers[controllerId] = newController;
        emit ControllerUpdated(controllerId, newController.owner, newController.treasury);
    }

    /**
     * @notice Creates a new product market with `provider`
     * @dev Controller caller must be allowed
     * @param controllerId Controller that will own the product
     * @param provider Provider that will service the market
     * @return New product contract address
     */
    function createProduct(uint256 controllerId, IProductProvider provider) onlyOwner(controllerId) external returns (IProduct) {
        if (controllerId == 0) revert FactoryNoZeroControllerError();
        if (!allowed[0] && !allowed[controllerId]) revert FactoryNotAllowedError();

        IProduct newProduct = IProduct(Clones.clone(address(productBase)));
        newProduct.initialize(provider);
        controllerFor[newProduct] = controllerId;
        emit ProductCreated(newProduct, provider);

        return newProduct;
    }

    /**
     * @notice Updates the Collateral contract address
     * @param newCollateral New Collateral contract address
     */
    function updateCollateral(ICollateral newCollateral) onlyOwner(0) public {
        collateral = newCollateral;
        emit CollateralUpdated(newCollateral);
    }

    /**
     * @notice Updates the Incentivizer contract address
     * @param newIncentivizer New Incentivizer contract address
     */
    function updateIncentivizer(IIncentivizer newIncentivizer) onlyOwner(0) public {
        incentivizer = newIncentivizer;
        emit IncentivizerUpdated(newIncentivizer);
    }

    /**
     * @notice Updates the base Product contract address
     * @param newProductBase New base Product contract address
     */
    function updateProductBase(IProduct newProductBase) onlyOwner(0) public {
        productBase = newProductBase;
        emit ProductBaseUpdated(newProductBase);
    }

    /**
     * @notice Updates the protocol-product fee split
     * @param newFee New protocol-product fee split
     */
    function updateFee(UFixed18 newFee) onlyOwner(0) public {
        fee = newFee;
        emit FeeUpdated(newFee);
    }

    /**
     * @notice Updates the minimum allowed funding fee
     * @param newMinFundingFee New minimum allowed funding fee
     */
    function updateMinFundingFee(UFixed18 newMinFundingFee) onlyOwner(0) public {
        minFundingFee = newMinFundingFee;
        emit MinFundingFeeUpdated(newMinFundingFee);
    }

    /**
     * @notice Updates the minimum allowed collateral amount per user account
     * @param newMinCollateral New minimum allowed collateral amount
     */
    function updateMinCollateral(UFixed18 newMinCollateral) onlyOwner(0) public {
        minCollateral = newMinCollateral;
        emit MinCollateralUpdated(newMinCollateral);
    }

    /**
     * @notice Updates the secondary pauser address
     * @param newPauser New secondary pauser address
     */
    function updatePauser(address newPauser) onlyOwner(0) public {
        pauser = newPauser;
        emit PauserUpdated(newPauser);
    }

    /**
     * @notice Updates the protocol pause status
     * @param newIsPaused New protocol pause status
     */
    function updateIsPaused(bool newIsPaused) public {
        if (msg.sender != owner() && msg.sender != pauser) revert FactoryNotPauserError(msg.sender);

        isPaused = newIsPaused;
        emit IsPausedUpdated(newIsPaused);
    }

    /**
     * @notice Updates whether `controllerId` is allowed to create new products
     * @param controllerId Controller to update
     * @param newAllowed New allowed status for `controllerId`
     */
    function updateAllowed(uint256 controllerId, bool newAllowed) onlyOwner(0) external {
        allowed[controllerId] = newAllowed;
        emit AllowedUpdated(controllerId, newAllowed);
    }

    /**
     * @notice Returns whether a contract is a product
     * @param product Contract address to check
     * @return Whether a contract is a product
     */
    function isProduct(IProduct product) public view returns (bool) {
        return controllerFor[product] != 0;
    }

    /**
     * @notice Returns controller state for controller `controllerId`
     * @param controllerId Controller to return for
     * @return Controller state
     */
    function controllers(uint256 controllerId) external view returns (Controller memory) {
        return _controllers[controllerId];
    }

    /**
     * @notice Returns the owner of the protocol
     * @return Owner of the protocol
     */
    function owner() public view returns (address) {
        return owner(0);
    }

    /**
     * @notice Returns the owner of the controller `controllerId`
     * @param controllerId Controller to return for
     * @return Owner of the controller
     */
    function owner(uint256 controllerId) public view returns (address) {
        return _controllers[controllerId].owner;
    }

    /**
     * @notice Returns the owner of the product `product`
     * @param product Product to return for
     * @return Owner of the product
     */
    function owner(IProduct product) public view returns (address) {
        return owner(controllerFor[product]);
    }

    /**
     * @notice Returns the treasury of the protocol
     * @return Treasury of the protocol
     */
    function treasury() public view returns (address) {
        return treasury(0);
    }

    /**
     * @notice Returns the treasury of the controller `controllerId`
     * @param controllerId Controller to return for
     * @return Treasury of the controller
     */
    function treasury(uint256 controllerId) public view returns (address) {
        return _controllers[controllerId].treasury;
    }

    /**
     * @notice Returns the treasury of the product `product`
     * @param product Product to return for
     * @return Treasury of the product
     */
    function treasury(IProduct product) public view returns (address) {
        return treasury(controllerFor[product]);
    }

    // @dev Only allow owner of `controllerId` to call
    modifier onlyOwner(uint256 controllerId) {
        if (msg.sender != owner(controllerId)) revert FactoryNotOwnerError(controllerId);

        _;
    }
}",2094
RealWorld_TA_60_UOwnable_RealWorld_20240808125115.log,60,UOwnable,69799,1272,71071,162.0,0.374435,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 *
 * NOTE: This contract has been extended from the Open Zeppelin library to include an
 *       unstructured storage pattern, so that it can be safely mixed in with upgradeable
 *       contracts without affecting their storage patterns through inheritance.
 */
abstract contract UOwnable {
    /**
     * @dev unstructured storage slot for the owner address
     */
    bytes32 private constant OWNER_SLOT = keccak256(""equilibria.utils.UOwnable.owner"");

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    error UOwnableNotOwnerError(address sender);
    error UOwnableZeroAddressError();

    /**
     * @dev Initializes the contract setting the caller as the initial owner.
     */
    function UOwnable__initialize() internal {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address result) {
        bytes32 slot = OWNER_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        if (owner() != msg.sender) revert UOwnableNotOwnerError(msg.sender);
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) revert UOwnableZeroAddressError();
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner;
        bytes32 slot = OWNER_SLOT;
        assembly {
            oldOwner := sload(slot)
            sstore(slot, newOwner)
        }

        emit OwnershipTransferred(oldOwner, newOwner);
    }
}",617
RealWorld_TA_60_LeveragedEther_RealWorld_20240808132611.log,60,LeveragedEther,51329,3046,54375,166.0,0.317565,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/ProductProviderBase.sol"";

contract LeveragedEther is ProductProviderBase {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    constructor(IOracle oracle) ProductProviderBase(oracle) { }

    // Implementation

    function rate(Position memory position) external pure override returns (Fixed18) {
        if (position.maker.isZero()) return Fixed18Lib.ZERO;

        UFixed18 utilization = position.taker.div(position.maker);
        UFixed18 capped = UFixed18Lib.min(utilization, UFixed18Lib.ONE);
        Fixed18 centered = (Fixed18Lib.from(capped).sub(Fixed18Lib.ratio(1, 2))).mul(Fixed18Lib.from(2));

        return centered.div(Fixed18Lib.from(365 days));
    }

    function payoff(Fixed18 price) public pure override returns (Fixed18) {
        return Fixed18Lib.from(3).mul(price);
    }

    function maintenance() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(100, 100);
    }

    function fundingFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(10, 100);
    }

    function makerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(1, 10000);
    }

    function takerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(1, 10000);
    }

    function makerLimit() external pure override returns (UFixed18) {
        return UFixed18Lib.from(1000);
    }
}",376
RealWorld_TA_60_Program_RealWorld_20240808133947.log,60,Program,139170,3485,142655,101.0,0.76555,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../product/types/position/Position.sol"";
import ""../../utils/types/Token18.sol"";
import ""./ProgramInfo.sol"";

struct Program {
    /// @dev Mapping of latest synced oracle version for each account
    mapping(address => uint256) latestVersion;

    /// @dev Mapping of latest rewards settled for each account
    mapping(address => UFixed18) settled;

    /// @dev Total amount of rewards yet to be claimed
    UFixed18 available;

    /// @dev Oracle version that the program completed, 0 is still ongoing
    uint256 versionComplete;

    /// @dev Whether the program is closed
    bool closed;

    /// @dev Whether the program is owned by the protocol (true) or by the product owner (false)
    bool protocolOwned;
}

library ProgramLib {
    using UFixed18Lib for UFixed18;
    using PositionLib for Position;
    using AccumulatorLib for Accumulator;
    using ProgramInfoLib for ProgramInfo;

    /**
     * @notice Initializes the program state
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param protocolOwned Whether the program is protocol owned
     */
    function initialize(Program storage self, ProgramInfo memory programInfo, bool protocolOwned) internal {
        self.available = programInfo.amount.sum();
        self.protocolOwned = protocolOwned;
    }

    /**
     * @notice Returns whether a program can be closed
     * @dev Programs must wait to be closed until after their grace period has concluded whether
     *      or not it was completed early
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param timestamp The effective timestamp to check
     * @return Whether the program can be closed
     */
    function canClose(Program storage self, ProgramInfo memory programInfo, uint256 timestamp) internal view returns (bool) {
        uint256 end = self.versionComplete == 0 ?
            programInfo.start + programInfo.duration :
            programInfo.product.provider().timestampAtVersion(self.versionComplete);
        return timestamp >= (end + programInfo.grace);
    }

    /**
     * @notice Closes the program
     * @param self Static The Program to operate on
     * @return amountToReturn Amount of remaining unclaimed reward tokens to be returned
     */
    function close(Program storage self) internal returns (UFixed18 amountToReturn) {
        amountToReturn = self.available;
        self.available = UFixed18Lib.ZERO;
        self.closed = true;
    }

    /**
     * @notice Completes the program
     * @dev Completion prevents anymore rewards from accruing, but users may still claim during the
     *      grace period until a program is closed
     * @param self Static The Program to operate on
     * @param oracleVersion The effective oracle version of completion
     */
    function complete(Program storage self, uint256 oracleVersion) internal {
        self.versionComplete = oracleVersion;
    }

    /**
     * @notice Settles unclaimed rewards for account `account`
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param account The account to settle for
     */
    function settle(Program storage self, ProgramInfo memory programInfo, address account) internal {
        (UFixed18 unsettledAmount, uint256 unsettledVersion) = unsettled(self, programInfo, account);

        self.settled[account] = self.settled[account].add(unsettledAmount);
        self.available = self.available.sub(unsettledAmount);
        self.latestVersion[account] = unsettledVersion;
    }

    /**
     * @notice Claims settled rewards for account `account`
     * @param self Static The Program to operate on
     * @param account The account to claim for
     */
    function claim(Program storage self, address account)
    internal returns (UFixed18 claimedAmount) {
        claimedAmount = self.settled[account];
        self.settled[account] = UFixed18Lib.ZERO;
    }

    /**
     * @notice Returns the total amount of unclaimed rewards for account `account`
     * @dev This includes both settled and unsettled unclaimed rewards
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param account The account to claim for
     * @return Total amount of unclaimed rewards for account
     */
    function unclaimed(Program storage self, ProgramInfo memory programInfo, address account)
    internal view returns (UFixed18) {
        (UFixed18 unsettledAmount, ) = unsettled(self, programInfo, account);
        return unsettledAmount.add(self.settled[account]);
    }

    /**
     * @notice Returns the unsettled amount of unclaimed rewards for account `account`
     * @dev Clears when a program is closed
     *      Assumes that position is unchanged since last settlement, must be settled prior to user position update
     * @param self Static The Program to operate on
     * @param programInfo Static program information
     * @param account The account to claim for
     * @return amount Amount of unsettled rewards for account
     * @return latestVersion Effective oracle version for computation
     */
    function unsettled(Program storage self, ProgramInfo memory programInfo, address account)
    private view returns (UFixed18 amount, uint256 latestVersion) {
        IProduct product = programInfo.product;

        uint256 userLatestVersion = self.latestVersion[account];
        Position memory userPosition = product.position(account);
        uint256 userSyncedTo = product.latestVersion(account);

        // compute version to sync to
        latestVersion = self.versionComplete == 0 ? userSyncedTo : Math.min(userSyncedTo, self.versionComplete);
        uint256 latestTimestamp = product.provider().timestampAtVersion(latestVersion);

        // check initialization conditions
        if (!programInfo.isStarted(latestTimestamp)) return (UFixed18Lib.ZERO, 0); // program hasn't started
        if (self.closed) return (UFixed18Lib.ZERO, latestVersion);                 // program has closed
        if (userLatestVersion == 0) return (UFixed18Lib.ZERO, latestVersion);      // user has not been initialized

        // compute unsettled amount
        Accumulator memory userShareDelta =
            userPosition.mul(product.shareAtVersion(latestVersion).sub(product.shareAtVersion(userLatestVersion)));
        amount = UFixed18Lib.from(programInfo.amountPerShare().mul(userShareDelta).sum());
    }
}",1411
RealWorld_TA_60_AccountPosition_RealWorld_20240808131138.log,60,AccountPosition,105321,2434,107755,166.0,0.575285,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./PrePosition.sol"";
import ""../accumulator/Accumulator.sol"";

/// @dev AccountPosition type
struct AccountPosition {
    /// @dev The current settled position of the account
    Position position;

    /// @dev The current position delta pending-settlement
    PrePosition pre;

    /// @dev Whether the account is currently locked for liquidation
    bool liquidation;
}

/**
 * @title AccountPositionLib
 * @notice Library that manages an account-level position.
 */
library AccountPositionLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using PositionLib for Position;
    using PrePositionLib for PrePosition;

    /**
     * @notice Settled the account's position to oracle version `toOracleVersion`
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to accumulate to
     * @return positionFee The fee accrued from opening or closing a new position
     */
    function settle(AccountPosition storage self, IProductProvider provider, uint256 toOracleVersion) internal returns (UFixed18 positionFee) {
        bool settled;
        (self.position, positionFee, settled) = self.position.settled(self.pre, provider, toOracleVersion);
        if (settled) delete self.pre;
    }

    /**
     * @notice Returns the current maintenance requirement for the account
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @return Current maintenance requirement for the account
     */
    function maintenance(AccountPosition storage self, IProductProvider provider) internal view returns (UFixed18) {
        if (self.liquidation) return UFixed18Lib.ZERO;
        return maintenanceInternal(self.position, provider);
    }

    /**
     * @notice Returns the maintenance requirement after the next oracle version settlement
     * @dev Includes the current pending-settlement position delta, assumes no price change
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @return Next maintenance requirement for the account
     */
    function maintenanceNext(AccountPosition storage self, IProductProvider provider) internal view returns (UFixed18) {
        return maintenanceInternal(self.position.next(self.pre), provider);
    }

    /**
      @notice Returns the maintenance requirement for a given `position`
     * @dev Internal helper
     * @param position The position to compete the maintenance requirement for
     * @param provider The parameter provider of the product
     * @return Next maintenance requirement for the account
     */
    function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {
        Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());
        UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();
        return notionalMax.mul(provider.maintenance());
    }

    /**
     * @notice Returns whether an account is completely closed, i.e. no position or pre-position
     * @param self The struct to operate on
     * @return Whether the account is closed
     */
    function isClosed(AccountPosition memory self) internal pure returns (bool) {
        return self.pre.isEmpty() && self.position.isEmpty();
    }

    /**
     * @notice Returns whether an account has opened position on both sides of the market (maker vs taker)
     * @dev Used to verify the invariant that a single account can only have a position on one side of the
     *      market at a time
     * @param self The struct to operate on
     * @return Whether the account is currently doubled sided
     */
    function isDoubleSided(AccountPosition storage self) internal view returns (bool) {
        bool makerEmpty = self.position.maker.isZero() && self.pre.openPosition.maker.isZero() && self.pre.closePosition.maker.isZero();
        bool takerEmpty = self.position.taker.isZero() && self.pre.openPosition.taker.isZero() && self.pre.closePosition.taker.isZero();

        return !makerEmpty && !takerEmpty;
    }

    /**
     * @notice Returns whether the account's pending-settlement delta closes more position than is open
     * @dev Used to verify the invariant that an account cannot settle into having a negative position
     * @param self The struct to operate on
     * @return Whether the account is currently over closed
     */
    function isOverClosed(AccountPosition storage self) internal view returns (bool) {
        Position memory nextOpen = self.position.add(self.pre.openPosition);

        return  self.pre.closePosition.maker.gt(nextOpen.maker) || self.pre.closePosition.taker.gt(nextOpen.taker);
    }
}",1028
RealWorld_TA_60_Accumulator_RealWorld_20240808132336.log,60,Accumulator,64359,1295,65654,153.0,0.347695,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../../utils/types/Fixed18.sol"";

/// @dev Accumulator type
struct Accumulator {
    /// @dev maker accumulator per share
    Fixed18 maker;
    /// @dev taker accumulator per share
    Fixed18 taker;
}

/**
 * @title AccountAccumulatorLib
 * @notice Library that surfaces math operations for the Accumulator type.
 * @dev Accumulators track the cumulative change in position value over time for the maker and taker positions
 *      respectively. Account-level accumulators can then use two of these values `a` and `a'` to compute the
 *      change in position value since last sync. This change in value is then used to compute P&L and fees.
 */
library AccumulatorLib {
    using Fixed18Lib for Fixed18;

    /**
     * @notice Adds two accumulators together
     * @param a The first accumulator to sum
     * @param b The second accumulator to sum
     * @return The resulting summed accumulator
     */
    function add(Accumulator memory a, Accumulator memory b) internal pure returns (Accumulator memory) {
        return Accumulator({maker: a.maker.add(b.maker), taker: a.taker.add(b.taker)});
    }

    /**
     * @notice Subtracts accumulator `b` from `a`
     * @param a The accumulator to subtract from
     * @param b The accumulator to subtract
     * @return The resulting subtracted accumulator
     */
    function sub(Accumulator memory a, Accumulator memory b) internal pure returns (Accumulator memory) {
        return Accumulator({maker: a.maker.sub(b.maker), taker: a.taker.sub(b.taker)});
    }

    /**
     * @notice Multiplies two accumulators together
     * @param a The first accumulator to multiply
     * @param b The second accumulator to multiply
     * @return The resulting multiplied accumulator
     */
    function mul(Accumulator memory a, Accumulator memory b) internal pure returns (Accumulator memory) {
        return Accumulator({maker: a.maker.mul(b.maker), taker: a.taker.mul(b.taker)});
    }

    /**
     * @notice Sums the maker and taker together from a single accumulator
     * @param self The struct to operate on
     * @return The sum of its maker and taker
     */
    function sum(Accumulator memory self) internal pure returns (Fixed18) {
        return self.maker.add(self.taker);
    }
}",560
RealWorld_TA_60_UReentrancyGuard_RealWorld_20240808125359.log,60,UReentrancyGuard,88200,1196,89396,146.0,0.46492,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 *
 * NOTE: This contract has been extended from the Open Zeppelin library to include an
 *       unstructured storage pattern, so that it can be safely mixed in with upgradeable
 *       contracts without affecting their storage patterns through inheritance.
 */
abstract contract UReentrancyGuard {
    error UReentrancyGuardReentrantCallError();

    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    /**
     * @dev unstructured storage slot for the reentrancy status
     */
    bytes32 private constant STATUS_SLOT = keccak256(""equilibria.utils.UReentrancyGuard.status"");

    /**
     * @dev Initializes the contract setting the status to _NOT_ENTERED.
     */
    function UReentrancyGuard__initialize() internal {
        _setStatus(_NOT_ENTERED);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function _status() private view returns (uint256 result) {
        bytes32 slot = STATUS_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    function _setStatus(uint256 newStatus) private {
        bytes32 slot = STATUS_SLOT;
        assembly {
            sstore(slot, newStatus)
        }
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        if (_status() == _ENTERED) revert UReentrancyGuardReentrantCallError();

        // Any calls to nonReentrant after this point will fail
        _setStatus(_ENTERED);

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _setStatus(_NOT_ENTERED);
    }
}",831
RealWorld_TA_60_Squeeth_RealWorld_20240808133147.log,60,Squeeth,49181,2215,51396,75.0,0.290205,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/ProductProviderBase.sol"";

contract Squeeth is ProductProviderBase {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    constructor(IOracle oracle) ProductProviderBase(oracle) { }

    // Implementation

    function rate(Position memory position) external pure override returns (Fixed18) {
        if (position.maker.isZero()) return Fixed18Lib.ZERO;

        UFixed18 utilization = position.taker.div(position.maker);
        UFixed18 capped = UFixed18Lib.min(utilization, UFixed18Lib.ONE);
        Fixed18 centered = (Fixed18Lib.from(capped).sub(Fixed18Lib.ratio(1, 2))).mul(Fixed18Lib.from(2));

        return centered.div(Fixed18Lib.from(365 days));
    }

    function payoff(Fixed18 price) public pure override returns (Fixed18) {
        return price.mul(price);
    }

    function maintenance() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(30, 100);
    }

    function fundingFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(10, 100);
    }

    function makerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function takerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function makerLimit() external pure override returns (UFixed18) {
        return UFixed18Lib.from(1);
    }
}",355
RealWorld_TA_60_MockUOwnable_RealWorld_20240808123623.log,60,MockUOwnable,24227,2366,26593,166.0,0.168455,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../unstructured/UOwnable.sol"";

contract MockUOwnable is UOwnable {
    function __initialize() external {
        super.UOwnable__initialize();
    }
}",57
RealWorld_TA_60_Token18_RealWorld_20240808124154.log,60,Token18,133958,2348,136306,197.0,0.71675,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""./UFixed18.sol"";

/// @dev Token18
type Token18 is address;

/**
 * @title Token18Lib
 * @notice Library to manager Ether and ERC20s that is compliant with the fixed-decimal types.
 * @dev Normalizes token operations with Ether operations (using a magic Ether address).
 */
library Token18Lib {
    using UFixed18Lib for UFixed18;
    using Address for address;
    using SafeERC20 for IERC20;

    error Token18PullEtherError();

    Token18 public constant ETHER = Token18.wrap(address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));

    /**
     * @notice Returns whether a token is the Ether address
     * @param self Token to check for
     * @return Whether the token is Ether
     */
    function isEther(Token18 self) internal pure returns (bool) {
        return Token18.unwrap(self) == Token18.unwrap(ETHER);
    }

    /**
     * @notice Transfers all held tokens from the caller to the `recipient`
     * @param self Token to transfer
     * @param recipient Address to receive the tokens
     */
    function push(Token18 self, address recipient) internal {
        push(self, recipient, balanceOf(self, address(this)));
    }

    /**
     * @notice Transfers `amount` tokens from the caller to the `recipient`
     * @param self Token to transfer
     * @param recipient Address to transfer tokens to
     * @param amount Amount of tokens to transfer
     */
    function push(
        Token18 self,
        address recipient,
        UFixed18 amount
    ) internal {
        isEther(self)
            ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))
            : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount));
    }

    /**
     * @notice Transfers `amount` tokens from the `benefactor` to the caller
     * @dev Reverts if trying to pull Ether
     * @param self Token to transfer
     * @param benefactor Address to transfer tokens from
     * @param amount Amount of tokens to transfer
     */
    function pull(
        Token18 self,
        address benefactor,
        UFixed18 amount
    ) internal {
        if (isEther(self)) revert Token18PullEtherError();
        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), toTokenAmount(self, amount));
    }

    /**
     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`
     * @dev Reverts if trying to pull Ether
     * @param self Token to transfer
     * @param benefactor Address to transfer tokens from
     * @param recipient Address to transfer tokens to
     * @param amount Amount of tokens to transfer
     */
    function pullTo(
        Token18 self,
        address benefactor,
        address recipient,
        UFixed18 amount
    ) internal {
        if (isEther(self)) revert Token18PullEtherError();
        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, toTokenAmount(self, amount));
    }

    /**
     * @notice Returns the name of the token
     * @param self Token to check for
     * @return Token name
     */
    function name(Token18 self) internal view returns (string memory) {
        return isEther(self) ? ""Ether"" : IERC20Metadata(Token18.unwrap(self)).name();
    }

    /**
     * @notice Returns the symbol of the token
     * @param self Token to check for
     * @return Token symbol
     */
    function symbol(Token18 self) internal view returns (string memory) {
        return isEther(self) ? ""ETH"" : IERC20Metadata(Token18.unwrap(self)).symbol();
    }

    /**
     * @notice Returns the decimals of the token
     * @param self Token to check for
     * @return Token decimals
     */
    function decimals(Token18 self) internal view returns (uint8) {
        return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();
    }

    /**
     * @notice Returns the `self` token balance of the caller
     * @param self Token to check for
     * @return Token balance of the caller
     */
    function balanceOf(Token18 self) internal view returns (UFixed18) {
        return balanceOf(self, address(this));
    }

    /**
     * @notice Returns the `self` token balance of `account`
     * @param self Token to check for
     * @param account Account to check
     * @return Token balance of the account
     */
    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {
        uint256 tokenAmount = isEther(self) ?
            account.balance :
            IERC20(Token18.unwrap(self)).balanceOf(account);
        return fromTokenAmount(self, tokenAmount);
    }

    /**
     * @notice Converts the unsigned fixed-decimal amount into the token amount according to
     *         it's defined decimals
     * @param self Token to check for
     * @param amount Amount to convert
     * @return Normalized token amount
     */
    function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {
        UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);
        return UFixed18.unwrap(amount.mul(conversion));
    }

    /**
     * @notice Converts the token amount into the unsigned fixed-decimal amount according to
     *         it's defined decimals
     * @param self Token to check for
     * @param amount Token amount to convert
     * @return Normalized unsigned fixed-decimal amount
     */
    function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {
        UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));
        return UFixed18.wrap(amount).mul(conversion);
    }
}",1405
RealWorld_TA_60_IOracle_RealWorld_20240808134857.log,60,IOracle,27327,1911,29238,78.0,0.174855,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../utils/types/Fixed18.sol"";

interface IOracle {
    event Version(uint256 version, uint256 timestamp, Fixed18 price);

    function sync() external;
    function priceAtVersion(uint256 version) external view returns (Fixed18);
    function timestampAtVersion(uint256 version) external view returns (uint256);
    function currentVersion() external view returns (uint256);
}",99
RealWorld_TA_60_IProductProvider_RealWorld_20240808134443.log,60,IProductProvider,31955,1689,33644,92.0,0.193555,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""./IOracle.sol"";
import ""../product/types/position/Position.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/types/Fixed18.sol"";

interface IProductProvider is IOracle {
    function rate(Position memory position) external view returns (Fixed18);
    function payoff(Fixed18 price) external view returns (Fixed18);
    function maintenance() external view returns (UFixed18);
    function fundingFee() external view returns (UFixed18);
    function makerFee() external view returns (UFixed18);
    function takerFee() external view returns (UFixed18);
    function makerLimit() external view returns (UFixed18);
}",157
RealWorld_TA_60_ChainlinkOracle_RealWorld_20240808121825.log,60,ChainlinkOracle,71450,2695,74145,163.0,0.41115,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""../interfaces/IOracle.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/unstructured/UOwnable.sol"";

/**
 * @title ChainlinkOracle
 * @notice Chainlink implementation of the IOracle interface.
 * @dev One instance per Chainlink price feed should be deployed. Multiple products may use the same
 *      ChainlinkOracle instance if their payoff functions are based on the same underlying oracle.
 */
contract ChainlinkOracle is IOracle, UOwnable {

    event MinDelayUpdated(uint256 newMinDelay);

    /// @dev Chainlink price feed to read from
    IChainlinkFeed public feed;

    /// @dev Mapping of historical price at each oracle version
    Fixed18[] public priceAtVersion;

    /// @dev Mapping of historical timestamp at each oracle version
    uint256[] public timestampAtVersion;

    /// @dev Decimal offset used to normalize chainlink price to 18 decimals
    uint256 private _decimalOffset;

    /// @dev Minimum timestamp delay before committed a new version
    uint256 public minDelay;

    /**
     * @notice Initializes the contract state
     * @param feed_ Chainlink price feed
     */
    constructor(IChainlinkFeed feed_) {
        feed = feed_;
        _decimalOffset = 10 ** feed_.decimals();
        minDelay = 30 minutes;

        sync();
        UOwnable__initialize();
    }

    /**
     * @notice Checks for a new price and updates the oracle version if one is found
     */
    function sync() public {
        (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();
        Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));

        if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {
            priceAtVersion.push(price);
            timestampAtVersion.push(timestamp);

            emit Version(currentVersion(), timestamp, price);
        }
    }

    /**
     * @notice Returns the current oracle version
     * @return Current oracle version
     */
    function currentVersion() public view returns (uint256) {
        return priceAtVersion.length - 1;
    }

    /**
     * @notice Updates the minimum delay before a new version can be committed
     * @param newMinDelay New minimum delay
     */
    function updateMinDelay(uint256 newMinDelay) onlyOwner external {
        minDelay = newMinDelay;
        emit MinDelayUpdated(newMinDelay);
    }
}

interface IChainlinkFeed {
    function decimals() external view returns (uint8);
    function latestRoundData() external view returns (
        uint80 roundID,
        int price,
        uint startedAt,
        uint timeStamp,
        uint80 answeredInRound
    );
}",614
RealWorld_TA_60_Incentivizer_RealWorld_20240808133617.log,60,Incentivizer,267252,4987,272239,128.0,1.436,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""../interfaces/IIncentivizer.sol"";
import ""../interfaces/IFactory.sol"";
import ""./types/Program.sol"";
import ""../utils/unstructured/UReentrancyGuard.sol"";
import ""../product/types/position/Position.sol"";
import ""../product/types/accumulator/Accumulator.sol"";
import ""../factory/UFactoryProvider.sol"";

contract Incentivizer is IIncentivizer, UFactoryProvider, UReentrancyGuard {
    using UFixed18Lib for UFixed18;
    using EnumerableSet for EnumerableSet.UintSet;
    using Token18Lib for Token18;
    using PositionLib for Position;
    using AccumulatorLib for Accumulator;
    using ProgramInfoLib for ProgramInfo;
    using ProgramLib for Program;

    /// @dev Maximum programs per product allowed
    uint256 public programsPerProduct;

    /// @dev Fee taken from total program amount
    UFixed18 public fee;

    /// @dev Static program state
    ProgramInfo[] private _programInfos;

    /// @dev Dynamic program state
    mapping(uint256 => Program) private _programs;

    /// @dev Mapping of all programs for each product
    mapping(IProduct => EnumerableSet.UintSet) private _registry;

    /// @dev Fees that have been collected, but remain unclaimed
    mapping(Token18 => UFixed18) public fees;

    /**
     * @notice Initializes the contract state
     * @param factory_ Factory contract address
     */
    function initialize(IFactory factory_) external {
        UFactoryProvider__initialize(factory_);
        UReentrancyGuard__initialize();

        programsPerProduct = 2;
        fee = UFixed18Lib.ZERO;
    }

    /**
     * @notice Creates a new incentive program
     * @dev Must be called as the product or protocol owner
     * @param info Parameters for the new program
     * @return new program's ID
     */
    function create(ProgramInfo calldata info)
    nonReentrant
    isProduct(info.product)
    notPaused
    external returns (uint256) {
        bool protocolOwned = msg.sender == factory().owner();

        if (_registry[info.product].length() >= programsPerProduct) revert IncentivizerTooManyProgramsError();
        if (!protocolOwned && msg.sender != factory().owner(info.product))
            revert NotProductOwnerError(msg.sender, info.product);

        uint256 programId = _programInfos.length;
        (ProgramInfo memory programInfo, UFixed18 programFee) = ProgramInfoLib.create(fee, info);

        _programInfos.push(programInfo);
        _programs[programId].initialize(programInfo, protocolOwned);
        _registry[info.product].add(programId);
        fees[info.token] = fees[info.token].add(programFee);

        info.token.pull(msg.sender, info.amount.sum());

        emit ProgramCreated(
            programId,
            programInfo.product,
            programInfo.token,
            programInfo.amount.maker,
            programInfo.amount.taker,
            programInfo.start,
            programInfo.duration,
            programInfo.grace,
            programFee
        );

        return programId;
    }

    /**
     * @notice Completes an in-progress program early
     * @dev Must be called as the program owner
     * @param programId Program to end
     */
    function end(uint256 programId)
    notPaused
    validProgram(programId)
    onlyProgramOwner(programId)
    external {
        completeInternal(programId);
    }

    /**
     * @notice Closes a program, returning all unclaimed rewards
     * @param programId Program to end
     */
    function close(uint256 programId)
    notPaused
    validProgram(programId)
    external {
        Program storage program = _programs[programId];
        ProgramInfo storage programInfo = _programInfos[programId];

        if (!program.canClose(programInfo, block.timestamp)) revert IncentivizerProgramNotClosableError();

        // complete if not yet completed
        if (program.versionComplete == 0) {
            completeInternal(programId);
        }

        // close
        UFixed18 amountToReturn = _programs[programId].close();
        programInfo.token.push(treasury(programId), amountToReturn);
        _registry[programInfo.product].remove(programId);

        emit ProgramClosed(programId, amountToReturn);
    }

    /**
     * @notice Completes any in-progress programs that newly completable
     * @dev Called every settle() from each product
     */
    function sync() onlyProduct external {
        IProduct product = IProduct(msg.sender);
        IProductProvider provider = product.provider();

        uint256 currentTimestamp = provider.timestampAtVersion(provider.currentVersion());

        for (uint256 i; i < _registry[product].length(); i++) {
            uint256 programId = _registry[product].at(i);

            if (_programs[programId].versionComplete != 0) continue;
            if (!_programInfos[programId].isComplete(currentTimestamp)) continue;

            completeInternal(programId);
        }
    }

    /**
     * @notice Completes a program
     * @dev Internal helper
     * @param programId Program to complete
     */
    function completeInternal(uint256 programId) private {
        uint256 version = _programInfos[programId].product.latestVersion();
        _programs[programId].complete(version);

        emit ProgramCompleted(programId, version);
    }

    /**
     * @notice Settles unsettled balance for `account`
     * @dev Called immediately proceeding a position update in the corresponding product
     * @param account Account to sync
     */
    function syncAccount(address account) onlyProduct external {
        IProduct product = IProduct(msg.sender);

        for (uint256 i; i < _registry[product].length(); i++) {
            uint256 programId = _registry[product].at(i);
            _programs[programId].settle(_programInfos[programId], account);
        }
    }

    /**
     * @notice Claims all of `msg.sender`'s rewards for `product` programs
     * @param product Product to claim rewards for
     */
    function claim(IProduct product) notPaused nonReentrant isProduct(product) public {
        // settle product markets
        product.settle();
        product.settleAccount(msg.sender);

        // claim
        for (uint256 i; i < _registry[product].length(); i++) {
            claimInternal(msg.sender, _registry[product].at(i));
        }
    }

    /**
     * @notice Claims all of `msg.sender`'s rewards for a specific program
     * @param programId Program to claim rewards for
     */
    function claim(uint256 programId) notPaused nonReentrant validProgram(programId) public {
        IProduct product = _programInfos[programId].product;

        // settle product markets
        product.settle();
        product.settleAccount(msg.sender);

        // claim
        claimInternal(msg.sender, programId);
    }

    /**
     * @notice Claims all of `account`'s rewards for a specific program
     * @dev Internal helper, assumes account has already been product-settled prior to calling
     * @param account Account to claim rewards for
     * @param programId Program to claim rewards for
     */
    function claimInternal(address account, uint256 programId) private {
        Program storage program = _programs[programId];
        ProgramInfo memory programInfo = _programInfos[programId];

        program.settle(programInfo, account);
        UFixed18 claimedAmount = program.claim(account);

        programInfo.token.push(account, claimedAmount);

        emit Claim(account, programId, claimedAmount);
    }

    /**
     * @notice Claims all `tokens` fees to the protocol treasury
     * @param tokens Tokens to claim fees for
     */
    function claimFee(Token18[] calldata tokens) notPaused external {
        for(uint256 i; i < tokens.length; i++) {
            Token18 token = tokens[i];
            UFixed18 amount = fees[token];

            fees[token] = UFixed18Lib.ZERO;
            tokens[i].push(factory().treasury(), amount);

            emit FeeClaim(token, amount);
        }
    }

    /**
     * @notice Returns program info for program `programId`
     * @param programId Program to return for
     * @return Program info
     */
    function programInfos(uint256 programId) external view returns (ProgramInfo memory) {
        return _programInfos[programId];
    }

    /**
     * @notice Returns `account`'s total unclaimed rewards for a specific program
     * @param account Account to return for
     * @param programId Program to return for
     * @return `account`'s total unclaimed rewards for `programId`
     */
    function unclaimed(address account, uint256 programId) external view returns (UFixed18) {
        if (programId >= _programInfos.length) return (UFixed18Lib.ZERO);

        ProgramInfo memory programInfo = _programInfos[programId];
        return _programs[programId].unclaimed(programInfo, account);
    }

    /**
     * @notice Returns `account`'s latest synced version for a specific program
     * @param account Account to return for
     * @param programId Program to return for
     * @return `account`'s latest synced version for `programId`
     */
    function latestVersion(address account, uint256 programId) external view returns (uint256) {
        return _programs[programId].latestVersion[account];
    }

    /**
     * @notice Returns `account`'s settled rewards for a specific program
     * @param account Account to return for
     * @param programId Program to return for
     * @return `account`'s settled rewards for `programId`
     */
    function settled(address account, uint256 programId) external view returns (UFixed18) {
        return _programs[programId].settled[account];
    }

    /**
     * @notice Returns available rewards for a specific program
     * @param programId Program to return for
     * @return Available rewards for `programId`
     */
    function available(uint256 programId) external view returns (UFixed18) {
        return _programs[programId].available;
    }

    /**
     * @notice Returns the version completed for a specific program
     * @param programId Program to return for
     * @return The version completed for `programId`
     */
    function versionComplete(uint256 programId) external view returns (uint256) {
        return _programs[programId].versionComplete;
    }

    /**
     * @notice Returns whether closed for a specific program
     * @param programId Program to return for
     * @return whether closed for `programId`
     */
    function closed(uint256 programId) external view returns (bool) {
        return _programs[programId].closed;
    }

    /**
     * @notice Returns quantity of programs for a specific product
     * @param product Product to return for
     * @return Quantity of programs for `product`
     */
    function programsForLength(IProduct product) external view returns (uint256) {
        return _registry[product].length();
    }

    /**
     * @notice Returns the program at index `index` for a specific product
     * @param product Product to return for
     * @param index Index to return for
     * @return The program at index `index` for `product`
     */
    function programsForAt(IProduct product, uint256 index) external view returns (uint256) {
        return _registry[product].at(index);
    }

    /**
     * @notice Returns the owner of a specific program
     * @param programId Program to return for
     * @return The owner of `programId`
     */
    function owner(uint256 programId) public view returns (address) {
        Program storage program = _programs[programId];
        ProgramInfo storage programInfo = _programInfos[programId];
        return program.protocolOwned ? factory().owner() : factory().owner(programInfo.product);
    }

    /**
     * @notice Returns the treasury of a specific program
     * @param programId Program to return for
     * @return The treasury of `programId`
     */
    function treasury(uint256 programId) public view returns (address) {
        Program storage program = _programs[programId];
        ProgramInfo storage programInfo = _programInfos[programId];
        return program.protocolOwned ? factory().treasury() : factory().treasury(programInfo.product);
    }

    /**
     * @notice Updates the maximum programs per product
     * @param newProgramsPerProduct New maximum programs per product value
     */
    function updateProgramsPerProduct(uint256 newProgramsPerProduct) onlyOwner external {
        programsPerProduct = newProgramsPerProduct;

        emit ProgramsPerProductUpdated(newProgramsPerProduct);
    }

    /**
     * @notice Updates the fee
     * @param newFee New fee value
     */
    function updateFee(UFixed18 newFee) onlyOwner external {
        fee = newFee;

        emit FeeUpdated(newFee);
    }

    /// @dev Only allow the owner of `programId` to call
    modifier onlyProgramOwner(uint256 programId) {
        if (msg.sender != owner(programId)) revert IncentivizerNotProgramOwnerError(msg.sender, programId);

        _;
    }

    /// @dev Only allow a valid `programId`
    modifier validProgram(uint256 programId) {
        if (programId >= _programInfos.length) revert IncentivizerInvalidProgramError(programId);

        _;
    }
}",2948
RealWorld_TA_60_Collateral_RealWorld_20240808133304.log,60,Collateral,190277,3638,193915,102.0,1.024145,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../interfaces/ICollateral.sol"";
import ""./types/OptimisticLedger.sol"";
import ""../utils/unstructured/UReentrancyGuard.sol"";
import ""../factory/UFactoryProvider.sol"";

/**
 * @title Collateral
 * @notice Manages logic and state for all collateral accounts in the protocol.
 */
contract Collateral is ICollateral, UFactoryProvider, UReentrancyGuard {
    using UFixed18Lib for UFixed18;
    using Token18Lib for Token18;
    using OptimisticLedgerLib for OptimisticLedger;

    /// @dev ERC20 stablecoin for collateral
    Token18 public token;

    /// @dev Fee on maintenance for liquidation
    UFixed18 public liquidationFee;

    /// @dev Per product collateral state
    mapping(IProduct => OptimisticLedger) private _products;

    /// @dev Protocol and product fees collected, but not yet claimed
    mapping(address => UFixed18) public fees;

    /**
     * @notice Initializes the contract state
     * @param factory_ Factory contract address
     * @param token_ Collateral ERC20 stablecoin address
     */
    function initialize(IFactory factory_, Token18 token_) external {
        UFactoryProvider__initialize(factory_);
        UReentrancyGuard__initialize();

        token = token_;
        liquidationFee = UFixed18Lib.ratio(50, 100);
    }

    /**
     * @notice Deposits `amount` collateral from `msg.sender` to `account`'s `product`
     *         account
     * @param account Account to deposit the collateral for
     * @param product Product to credit the collateral to
     * @param amount Amount of collateral to deposit
     */
    function depositTo(address account, IProduct product, UFixed18 amount)
    notPaused
    collateralInvariant(account, product)
    external {
        _products[product].creditAccount(account, amount);
        token.pull(msg.sender, amount);

        emit Deposit(account, product, amount);
    }

    /**
     * @notice Withdraws `amount` collateral from `msg.sender`'s `product` account
     *         and sends it to `account`
     * @param account Account to withdraw the collateral to
     * @param product Product to withdraw the collateral from
     * @param amount Amount of collateral to withdraw
     */
    function withdrawTo(address account, IProduct product, UFixed18 amount)
    notPaused
    collateralInvariant(msg.sender, product)
    maintenanceInvariant(msg.sender, product)
    external {
        _products[product].debitAccount(msg.sender, amount);
        token.push(account, amount);

        emit Withdrawal(msg.sender, product, amount);
    }

    /**
     * @notice Liquidates `account`'s `product` collateral account
     * @dev Account must be under-collateralized, fee returned immediately to `msg.sender`
     * @param account Account to liquidate
     * @param product Product to liquidate for
     */
    function liquidate(address account, IProduct product) notPaused nonReentrant external {
        // settle
        product.settle();
        product.settleAccount(account);

        // liquidate
        UFixed18 totalMaintenance = product.maintenance(account);
        UFixed18 totalCollateral = collateral(account, product);

        if (!totalMaintenance.gt(totalCollateral))
            revert CollateralCantLiquidate(totalMaintenance, totalCollateral);

        product.closeAll(account);

        // claim fee
        UFixed18 fee = UFixed18Lib.min(totalCollateral, totalMaintenance.mul(liquidationFee));

        _products[product].debitAccount(account, fee);
        token.push(msg.sender, fee);

        emit Liquidation(account, product, msg.sender, fee);
    }

    /**
     * @notice Credits `amount` to `account`'s collateral account
     * @dev Callable only by the corresponding product as part of the settlement flywheel.
     *      Moves collateral within a product, any collateral leaving the product due to
     *      fees has already been accounted for in the settleProduct flywheel.
     *      Debits in excess of the account balance get recorded as shortfall, and can be
     *      resolved by the product owner as needed.
     * @param account Account to credit
     * @param amount Amount to credit the account (can be negative)
     */
    function settleAccount(address account, Fixed18 amount) onlyProduct external {
        IProduct product = IProduct(msg.sender);

        UFixed18 newShortfall = _products[product].settleAccount(account, amount);

        emit AccountSettle(product, account, amount, newShortfall);
    }

    /**
     * @notice Debits `amount` from product's total collateral account
     * @dev Callable only by the corresponding product as part of the settlement flywheel
     *      Removes collateral from the product as fees.
     * @param amount Amount to debit from the account
     */
    function settleProduct(UFixed18 amount) onlyProduct external {
        IProduct product = IProduct(msg.sender);

        address protocolTreasury = factory().treasury();
        address productTreasury = factory().treasury(product);

        UFixed18 protocolFee = amount.mul(factory().fee());
        UFixed18 productFee = amount.sub(protocolFee);

        _products[product].debit(amount);
        fees[protocolTreasury] = fees[protocolTreasury].add(protocolFee);
        fees[productTreasury] = fees[productTreasury].add(productFee);

        emit ProductSettle(product, protocolFee, productFee);
    }

    /**
     * @notice Returns the balance of `account`'s `product` collateral account
     * @param account Account to return for
     * @param product Product to return for
     * @return The balance of the collateral account
     */
    function collateral(address account, IProduct product) public view returns (UFixed18) {
        return _products[product].balances[account];
    }

    /**
     * @notice Returns the total balance of `product`'s collateral
     * @param product Product to return for
     * @return The total balance of collateral in the product
     */
    function collateral(IProduct product) public view returns (UFixed18) {
        return _products[product].total;
    }

    /**
     * @notice Returns the current shortfall of `product`'s collateral
     * @param product Product to return for
     * @return The current shortfall of the product
     */
    function shortfall(IProduct product) public view returns (UFixed18) {
        return _products[product].shortfall;
    }

    /**
     * @notice Returns whether `account`'s `product` collateral account can be liquidated
     * @param account Account to return for
     * @param product Product to return for
     * @return Whether the account can be liquidated
     */
    function liquidatable(address account, IProduct product) external view returns (bool) {
        return product.maintenance(account).gt(collateral(account, product));
    }

    /**
     * @notice Returns whether `account`'s `product` collateral account can be liquidated
     *         after the next oracle version settlement
     * @dev Takes into account the current pre-position on the account
     * @param account Account to return for
     * @param product Product to return for
     * @return Whether the account can be liquidated
     */
    function liquidatableNext(address account, IProduct product) external view returns (bool) {
        return product.maintenanceNext(account).gt(collateral(account, product));
    }

    /**
     * @notice Injects additional collateral into a product to resolve shortfall
     * @dev Shortfall is a measure of settled insolvency in the market
     *      This hook can be used by the product owner or an insurance fund to re-capitalize an insolvent market
     * @param product Product to resolve shortfall for
     * @param amount Amount of shortfall to resolve
     */
    function resolveShortfall(IProduct product, UFixed18 amount) notPaused external {
        _products[product].resolve(amount);
        token.pull(msg.sender, amount);

        emit ShortfallResolution(product, amount);
    }

    /**
     * @notice Claims all of `msg.sender`'s fees
     */
    function claimFee() notPaused external {
        UFixed18 amount = fees[msg.sender];

        fees[msg.sender] = UFixed18Lib.ZERO;
        token.push(msg.sender, amount);

        emit FeeClaim(msg.sender, amount);
    }

    /**
     * @notice Updates the liquidation fee
     * @param newLiquidationFee New liquidation fee
     */
    function updateLiquidationFee(UFixed18 newLiquidationFee) onlyOwner external {
        liquidationFee = newLiquidationFee;
        emit LiquidationFeeUpdated(newLiquidationFee);
    }

    /// @dev Ensure that the user has sufficient margin for both current and next maintenance
    modifier maintenanceInvariant(address account, IProduct product) {
        _;

        UFixed18 maintenance = product.maintenance(account);
        UFixed18 maintenanceNext = product.maintenanceNext(account);

        if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))
            revert CollateralInsufficientCollateralError();
    }

    /// @dev Ensure that the account is either empty or above the collateral minimum
    modifier collateralInvariant(address account, IProduct product) {
        _;

        UFixed18 accountCollateral = collateral(account, product);
        if (!accountCollateral.isZero() && accountCollateral.lt(factory().minCollateral()))
            revert CollateralUnderLimitError();
    }
}",2053
RealWorld_TA_60_UFactoryProvider_RealWorld_20240808134331.log,60,UFactoryProvider,68352,1686,70038,70.0,0.37548,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../interfaces/IFactory.sol"";
import ""../interfaces/IProduct.sol"";

/**
 * @title UFactoryProvider
 * @notice Mix-in that manages a factory pointer and associated permissioning modifiers.
 * @dev Uses unstructured storage so that it is safe to mix-in to upgreadable contracts without modifying
 *      their storage layout.
 */
abstract contract UFactoryProvider {
    error AlreadyInitializedError();
    error NotOwnerError(address sender);
    error NotProductError(address sender);
    error NotCollateralError(address sender);
    error NotControllerOwnerError(address sender, uint256 controllerId);
    error NotProductOwnerError(address sender, IProduct product);
    error PausedError();

    /// @dev unstructured storage slot for the factory address
    bytes32 private constant FACTORY_SLOT = keccak256(""equilibria.perennial.UFactoryProvider.factory"");

    /**
     * @notice Initializes the contract state
     * @param factory_ Protocol Factory contract address
     */
    function UFactoryProvider__initialize(IFactory factory_) internal {
        if (address(factory()) != address(0)) revert AlreadyInitializedError();

        _setFactory(factory_);
    }

    /**
     * @notice Reads the protocol Factory contract address from unstructured state
     * @return result Protocol Factory contract address
     */
    function factory() public view virtual returns (IFactory result) {
        bytes32 slot = FACTORY_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    /**
     * @notice Sets the protocol Factory contract address in unstructured state
     * @dev Internal helper
     */
    function _setFactory(IFactory newFactory) private {
        bytes32 slot = FACTORY_SLOT;
        assembly {
            sstore(slot, newFactory)
        }
    }

    /// @dev Only allow a valid product contract to call
    modifier onlyProduct {
        if (!factory().isProduct(IProduct(msg.sender))) revert NotProductError(msg.sender);

        _;
    }

    /// @dev Verify that `product` is a valid product contract
    modifier isProduct(IProduct product) {
        if (!factory().isProduct(product)) revert NotProductError(address(product));

        _;
    }

    /// @dev Only allow the Collateral contract to call
    modifier onlyCollateral {
        if (msg.sender != address(factory().collateral())) revert NotCollateralError(msg.sender);

        _;
    }

    /// @dev Only allow the protocol owner contract to call
    modifier onlyOwner() {
        if (msg.sender != factory().owner()) revert NotOwnerError(msg.sender);

        _;
    }

    /// @dev Only allow if the the protocol is currently unpaused
    modifier notPaused() {
        if (factory().isPaused()) revert PausedError();

        _;
    }
}",598
RealWorld_TA_60_OptimisticLedger_RealWorld_20240808133448.log,60,OptimisticLedger,92595,2724,95319,87.0,0.517455,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../utils/types/UFixed18.sol"";

/// @dev OptimisticLedger type
struct OptimisticLedger {
    /// @dev Individual account collateral balances
    mapping(address => UFixed18) balances;

    /// @dev Total ledger collateral balance
    UFixed18 total;

    /// @dev Total ledger collateral shortfall
    UFixed18 shortfall;
}

/**
 * @title OptimisticLedgerLib
 * @notice Library that manages a global vs account ledger where the global ledger is settled separately,
 *         and ahead of, the user-level accounts.
 * @dev    Ensures that no more collateral leaves the ledger than goes it, while allowing user-level accounts
 *         to settle as a follow up step. Overdrafts on the user-level are accounted as ""shortall"". Shortfall
 *         in the system is the quantity of insolvency that can be optionally resolved by the ledger owner.
 *         Until the shortfall is resolved, collateral may be withdrawn from the ledger on a FCFS basis. However
 *         once the ledger total has been depleted, users will not be able to withdraw even if they have non-zero
 *         user level balances until the shortfall is resolved, recapitalizing the ledger.
 */
library OptimisticLedgerLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    /**
     * @notice Credits `account` with `amount` collateral
     * @param self The struct to operate on
     * @param account Account to credit collateral to
     * @param amount Amount of collateral to credit
     */
    function creditAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {
        self.balances[account] = self.balances[account].add(amount);
        self.total = self.total.add(amount);
    }

    /**
     * @notice Debits `account` `amount` collateral
     * @param self The struct to operate on
     * @param account Account to debit collateral from
     * @param amount Amount of collateral to debit
     */
    function debitAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {
        self.balances[account] = self.balances[account].sub(amount);
        self.total = self.total.sub(amount);
    }

    /**
     * @notice Credits `account` with `amount` collateral
     * @dev Funds come from inside the product, not totals are updated
     *      Shortfall is created if more funds are debited from an account than exist
     * @param self The struct to operate on
     * @param account Account to credit collateral to
     * @param amount Amount of collateral to credit
     */
    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)
    internal returns (UFixed18 shortfall) {
        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);

        if (newBalance.sign() == -1) {
            shortfall = self.shortfall.add(newBalance.abs());
            newBalance = Fixed18Lib.ZERO;
        }

        self.balances[account] = newBalance.abs();
        self.shortfall = self.shortfall.add(shortfall);
    }

    /**
     * @notice Debits ledger globally `amount` collateral
     * @dev Removes balance from total that is accounted for elsewhere (e.g. product-level accumulators)
     * @param self The struct to operate on
     * @param amount Amount of collateral to debit
     */
    function debit(OptimisticLedger storage self, UFixed18 amount) internal {
        self.total = self.total.sub(amount);
    }

    /**
     * @notice Reduces the amount of collateral shortfall in the ledger
     * @param self The struct to operate on
     * @param amount Amount of shortfall to resolve
     */
    function resolve(OptimisticLedger storage self, UFixed18 amount) internal {
        self.shortfall = self.shortfall.sub(amount);
        self.total = self.total.add(amount);
    }
}",877
RealWorld_TA_60_Position_RealWorld_20240808130826.log,60,Position,134876,1931,136807,190.0,0.713,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""../../../utils/types/UFixed18.sol"";
import ""../accumulator/Accumulator.sol"";
import ""./PrePosition.sol"";

/// @dev Position type
struct Position {
    /// @dev Quantity of the maker position
    UFixed18 maker;
    /// @dev Quantity of the taker position
    UFixed18 taker;
}

/**
 * @title PositionLib
 * @notice Library that surfaces math and settlement computations for the Position type.
 * @dev Positions track the current quantity of the account's maker and taker positions respectively
 *      denominated as a unit of the product's payoff function.
 */
library PositionLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using PrePositionLib for PrePosition;

    function isEmpty(Position memory self) internal pure returns (bool) {
        return self.maker.isZero() && self.taker.isZero();
    }

    /**
     * @notice Adds position `a` and `b` together, returning the result
     * @param a The first position to sum
     * @param b The second position to sum
     * @return Resulting summed position
     */
    function add(Position memory a, Position memory b) internal pure returns (Position memory) {
        return Position({maker: a.maker.add(b.maker), taker: a.taker.add(b.taker)});
    }

    /**
     * @notice Subtracts position `b` from `a`, returning the result
     * @param a The position to subtract from
     * @param b The position to subtract
     * @return Resulting subtracted position
     */
    function sub(Position memory a, Position memory b) internal pure returns (Position memory) {
        return Position({maker: a.maker.sub(b.maker), taker: a.taker.sub(b.taker)});
    }

    /**
     * @notice Multiplies position `self` by accumulator `accumulator` and returns the resulting accumulator
     * @param self The Position to operate on
     * @param accumulator The accumulator to multiply by
     * @return Resulting multiplied accumulator
     */
    function mul(Position memory self, Accumulator memory accumulator) internal pure returns (Accumulator memory) {
        return Accumulator({
            maker: Fixed18Lib.from(self.maker).mul(accumulator.maker),
            taker: Fixed18Lib.from(self.taker).mul(accumulator.taker)
        });
    }

    /**
     * @notice Scales position `self` by fixed-decimal `scale` and returns the resulting position
     * @param self The Position to operate on
     * @param scale The Fixed-decimal to scale by
     * @return Resulting scaled position
     */
    function mul(Position memory self, UFixed18 scale) internal pure returns (Position memory) {
        return Position({maker: self.maker.mul(scale), taker: self.taker.mul(scale)});
    }

    /**
     * @notice Divides position `self` by `b` and returns the resulting accumulator
     * @param self The Position to operate on
     * @param b The number to divide by
     * @return Resulting divided accumulator
     */
    function div(Position memory self, uint256 b) internal pure returns (Accumulator memory) {
        return Accumulator({
            maker: Fixed18Lib.from(self.maker).div(Fixed18Lib.from(UFixed18Lib.from(b))),
            taker: Fixed18Lib.from(self.taker).div(Fixed18Lib.from(UFixed18Lib.from(b)))
        });
    }

    /**
     * @notice Returns the maximum of `self`'s maker and taker values
     * @param self The struct to operate on
     * @return Resulting maximum value
     */
    function max(Position memory self) internal pure returns (UFixed18) {
        return UFixed18Lib.max(self.maker, self.taker);
    }

    /**
     * @notice Sums the maker and taker together from a single position
     * @param self The struct to operate on
     * @return The sum of its maker and taker
     */
    function sum(Position memory self) internal pure returns (UFixed18) {
        return self.maker.add(self.taker);
    }

    /**
     * @notice Computes the next position after the pending-settlement position delta is included
     * @param self The current Position
     * @param pre The pending-settlement position delta
     * @return Next Position
     */
    function next(Position memory self, PrePosition memory pre) internal pure returns (Position memory) {
        return sub(add(self, pre.openPosition), pre.closePosition);
    }

    /**
     * @notice Returns the settled position at oracle version `toOracleVersion`
     * @dev Checks if a new position is ready to be settled based on the provided `toOracleVersion`
     *      and `pre` and returns accordingly
     * @param self The current Position
     * @param pre The pending-settlement position delta
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version to settle to
     * @return Settled position at oracle version
     * @return Fee accrued from opening or closing the position
     * @return Whether a new position was settled
     */
    function settled(Position memory self, PrePosition memory pre, IProductProvider provider, uint256 toOracleVersion) internal view returns (Position memory, UFixed18, bool) {
        return pre.canSettle(toOracleVersion) ? (next(self, pre), pre.computeFee(provider, toOracleVersion), true) : (self, UFixed18Lib.ZERO, false);
    }

    /**
     * @notice Returns the socialization factor for the current position
     * @dev Socialization account for the case where `taker` > `maker` temporarily due to a liquidation
     *      on the maker side. This dampens the taker's exposure pro-rata to ensure that the maker side
     *      is never exposed over 1 x short.
     * @param self The Position to operate on
     * @return Socialization factor
     */
    function socializationFactor(Position memory self) internal pure returns (UFixed18) {
        return self.taker.isZero() ? UFixed18Lib.ONE : UFixed18Lib.min(UFixed18Lib.ONE, self.maker.div(self.taker));
    }
}",1386
RealWorld_TA_60_IIncentivizer_RealWorld_20240808135130.log,60,IIncentivizer,70751,1870,72621,74.0,0.391155,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../interfaces/IFactory.sol"";
import ""../interfaces/IProduct.sol"";
import ""../product/types/position/Position.sol"";
import ""../utils/types/Token18.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/types/Fixed18.sol"";
import ""../incentivizer/types/ProgramInfo.sol"";

interface IIncentivizer {
    event ProgramsPerProductUpdated(uint256 newProgramsPerProduct);
    event FeeUpdated(UFixed18 newFee);
    event ProgramCompleted(uint256 indexed programId, uint256 versionComplete);
    event ProgramClosed(uint256 indexed programId, UFixed18 amount);
    event ProgramCreated(uint256 indexed programId, IProduct product, Token18 token, UFixed18 amountMaker, UFixed18 amountTaker, uint256 start, uint256 duration, uint256 grace, UFixed18 fee);
    event Claim(address indexed account, uint256 indexed programId, UFixed18 amount);
    event FeeClaim(Token18 indexed token, UFixed18 amount);

    error IncentivizerProgramNotClosableError();
    error IncentivizerTooManyProgramsError();
    error IncentivizerNotProgramOwnerError(address sender, uint256 programId);
    error IncentivizerInvalidProgramError(uint256 programId);

    function programsPerProduct() external view returns (uint256);
    function fee() external view returns (UFixed18);
    function programInfos(uint256 programId) external view returns (ProgramInfo memory);
    function fees(Token18 token) external view returns (UFixed18);
    function initialize(IFactory factory_) external;
    function create(ProgramInfo calldata info) external returns (uint256);
    function end(uint256 programId) external;
    function close(uint256 programId) external;
    function sync() external;
    function syncAccount(address account) external;
    function claim(IProduct product) external;
    function claim(uint256 programId) external;
    function claimFee(Token18[] calldata tokens) external;
    function unclaimed(address account, uint256 programId) external view returns (UFixed18);
    function latestVersion(address account, uint256 programId) external view returns (uint256);
    function settled(address account, uint256 programId) external view returns (UFixed18);
    function available(uint256 programId) external view returns (UFixed18);
    function versionComplete(uint256 programId) external view returns (uint256);
    function closed(uint256 programId) external view returns (bool);
    function programsForLength(IProduct product) external view returns (uint256);
    function programsForAt(IProduct product, uint256 index) external view returns (uint256);
    function owner(uint256 programId) external view returns (address);
    function treasury(uint256 programId) external view returns (address);
    function updateProgramsPerProduct(uint256 newProgramsPerProduct) external;
    function updateFee(UFixed18 newFee) external;
}",628
RealWorld_TA_60_MockUReentrancyGuard_RealWorld_20240808123236.log,60,MockUReentrancyGuard,34557,4135,38692,225.0,0.255485,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../unstructured/UReentrancyGuard.sol"";

contract MockUReentrancyGuard is UReentrancyGuard {
    bytes32 private constant STATUS_SLOT = keccak256(""equilibria.utils.UReentrancyGuard.status"");

    event NoOp();

    function __initialize() external {
        super.UReentrancyGuard__initialize();
    }

    function __status() external view returns (uint256 result) {
        bytes32 slot = STATUS_SLOT;
        assembly {
            result := sload(slot)
        }
    }

    function noReenter() nonReentrant public { emit NoOp(); }
    function reenterRecursive() nonReentrant public { reenterRecursive(); }
    function reenterDifferent() nonReentrant public { noReenter(); }
}",177
RealWorld_TA_60_Fixed18_RealWorld_20240808124513.log,60,Fixed18,195231,1404,196635,186.0,1.004235,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""./UFixed18.sol"";

/// @dev Fixed18 type
type Fixed18 is int256;

/**
 * @title Fixed18Lib
 * @notice Library for the signed fixed-decimal type.
 */
library Fixed18Lib {
    error Fixed18OverflowError(uint256 value);

    int256 private constant BASE = 1e18;
    Fixed18 public constant ZERO = Fixed18.wrap(0);
    Fixed18 public constant ONE = Fixed18.wrap(BASE);
    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);

    /**
     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal
     * @param a Unsigned fixed-decimal
     * @return New signed fixed-decimal
     */
    function from(UFixed18 a) internal pure returns (Fixed18) {
        uint256 value = UFixed18.unwrap(a);
        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);
        return Fixed18.wrap(int256(value));
    }

    /**
     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal
     * @param s Sign
     * @param m Unsigned fixed-decimal magnitude
     * @return New signed fixed-decimal
     */
    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {
        if (s > 0) return from(m);
        if (s < 0) return mul(from(m), NEG_ONE);
        return ZERO;
    }

    /**
     * @notice Creates a signed fixed-decimal from a signed integer
     * @param a Signed number
     * @return New signed fixed-decimal
     */
    function from(int256 a) internal pure returns (Fixed18) {
        return Fixed18.wrap(a * BASE);
    }

    /**
     * @notice Returns whether the signed fixed-decimal is equal to zero.
     * @param a Signed fixed-decimal
     * @return Whether the signed fixed-decimal is zero.
     */
    function isZero(Fixed18 a) internal pure returns (bool) {
        return Fixed18.unwrap(a) == 0;
    }

    /**
     * @notice Adds two signed fixed-decimals `a` and `b` together
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Resulting summed signed fixed-decimal
     */
    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));
    }

    /**
     * @notice Subtracts signed fixed-decimal `b` from `a`
     * @param a Signed fixed-decimal to subtract from
     * @param b Signed fixed-decimal to subtract
     * @return Resulting subtracted signed fixed-decimal
     */
    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));
    }

    /**
     * @notice Multiplies two signed fixed-decimals `a` and `b` together
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Resulting multiplied signed fixed-decimal
     */
    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);
    }

    /**
     * @notice Divides signed fixed-decimal `a` by `b`
     * @param a Signed fixed-decimal to divide
     * @param b Signed fixed-decimal to divide by
     * @return Resulting subtracted signed fixed-decimal
     */
    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is equal to `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is equal to `b`
     */
    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return compare(a, b) == 1;
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is greater than `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is greater than `b`
     */
    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return compare(a, b) == 2;
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is less than `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is less than `b`
     */
    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return compare(a, b) == 0;
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is greater than or equal to `b`
     */
    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return gt(a, b) || eq(a, b);
    }

    /**
     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Whether `a` is less than or equal to `b`
     */
    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {
        return lt(a, b) || eq(a, b);
    }

    /**
     * @notice Compares the signed fixed-decimals `a` and `b`
     * @dev Returns: 2 for greater than
     *               1 for equal to
     *               0 for less than
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Compare result of `a` and `b`
     */
    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {
        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));
        if (au > bu) return 2;
        if (au < bu) return 0;
        return 1;
    }

    /**
     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`
     * @param a First signed number
     * @param b Second signed number
     * @return Ratio of `a` over `b`
     */
    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {
        return Fixed18.wrap(a * BASE / b);
    }

    /**
     * @notice Returns the minimum of signed fixed-decimals `a` and `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Minimum of `a` and `b`
     */
    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));
        return Fixed18.wrap(au < bu ? au : bu);
    }

    /**
     * @notice Returns the maximum of signed fixed-decimals `a` and `b`
     * @param a First signed fixed-decimal
     * @param b Second signed fixed-decimal
     * @return Maximum of `a` and `b`
     */
    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {
        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));
        return Fixed18.wrap(au > bu ? au : bu);
    }

    /**
     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion
     * @param a Signed fixed-decimal
     * @return Truncated signed number
     */
    function truncate(Fixed18 a) internal pure returns (int256) {
        return Fixed18.unwrap(a) / BASE;
    }

    /**
     * @notice Returns the sign of the signed fixed-decimal
     * @dev Returns: -1 for negative
     *                0 for zero
     *                1 for positive
     * @param a Signed fixed-decimal
     * @return Sign of the signed fixed-decimal
     */
    function sign(Fixed18 a) internal pure returns (int256) {
        if (Fixed18.unwrap(a) > 0) return 1;
        if (Fixed18.unwrap(a) < 0) return -1;
        return 0;
    }

    /**
     * @notice Returns the absolute value of the signed fixed-decimal
     * @param a Signed fixed-decimal
     * @return Absolute value of the signed fixed-decimal
     */
    function abs(Fixed18 a) internal pure returns (UFixed18) {
        return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a);
    }
}",2105
RealWorld_TA_60_MockFixed18_RealWorld_20240808123911.log,60,MockFixed18,77528,1224,78752,161.0,0.41212,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../types/Fixed18.sol"";

contract MockFixed18 {
    function zero() external pure returns (Fixed18) {
        return Fixed18Lib.ZERO;
    }

    function one() external pure returns (Fixed18) {
        return Fixed18Lib.ONE;
    }

    function negOne() external pure returns (Fixed18) {
        return Fixed18Lib.NEG_ONE;
    }

    function from(UFixed18 a) external pure returns (Fixed18) {
        return Fixed18Lib.from(a);
    }

    function from(int256 s, UFixed18 m) external pure returns (Fixed18) {
        return Fixed18Lib.from(s, m);
    }

    function from(int256 a) external pure returns (Fixed18) {
        return Fixed18Lib.from(a);
    }

    function isZero(Fixed18 a) external pure returns (bool) {
        return Fixed18Lib.isZero(a);
    }

    function add(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.add(a, b);
    }

    function sub(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.sub(a, b);
    }

    function mul(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.mul(a, b);
    }

    function div(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.div(a, b);
    }

    function eq(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.eq(a, b);
    }

    function gt(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.gt(a, b);
    }

    function lt(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.lt(a, b);
    }

    function gte(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.gte(a, b);
    }

    function lte(Fixed18 a, Fixed18 b) external pure returns (bool) {
        return Fixed18Lib.lte(a, b);
    }

    function compare(Fixed18 a, Fixed18 b) external pure returns (uint256) {
        return Fixed18Lib.compare(a, b);
    }

    function ratio(int256 a, int256 b) external pure returns (Fixed18) {
        return Fixed18Lib.ratio(a, b);
    }

    function min(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.min(a, b);
    }

    function max(Fixed18 a, Fixed18 b) external pure returns (Fixed18) {
        return Fixed18Lib.max(a, b);
    }

    function truncate(Fixed18 a) external pure returns (int256) {
        return Fixed18Lib.truncate(a);
    }

    function sign(Fixed18 a) external pure returns (int256) {
        return Fixed18Lib.sign(a);
    }

    function abs(Fixed18 a) external pure returns (UFixed18) {
        return Fixed18Lib.abs(a);
    }
}",705
RealWorld_TA_60_ICollateral_RealWorld_20240808135017.log,60,ICollateral,59365,1404,60769,71.0,0.324905,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""./IProduct.sol"";
import ""../utils/types/UFixed18.sol"";
import ""../utils/types/Fixed18.sol"";
import ""../utils/types/Token18.sol"";

interface ICollateral {
    event Deposit(address indexed user, IProduct indexed product, UFixed18 amount);
    event Withdrawal(address indexed user, IProduct indexed product, UFixed18 amount);
    event AccountSettle(IProduct indexed product, address indexed account, Fixed18 amount, UFixed18 newShortfall);
    event ProductSettle(IProduct indexed product, UFixed18 protocolFee, UFixed18 productFee);
    event Liquidation(address indexed user, IProduct indexed product, address liquidator, UFixed18 fee);
    event ShortfallResolution(IProduct indexed product, UFixed18 amount);
    event LiquidationFeeUpdated(UFixed18 newLiquidationFeeUpdated);
    event FeeClaim(address indexed account, UFixed18 amount);

    error CollateralCantLiquidate(UFixed18 totalMaintenance, UFixed18 totalCollateral);
    error CollateralInsufficientCollateralError();
    error CollateralUnderLimitError();

    function token() external view returns (Token18);
    function liquidationFee() external view returns (UFixed18);
    function fees(address account) external view returns (UFixed18);
    function initialize(IFactory factory_, Token18 token_) external;
    function depositTo(address account, IProduct product, UFixed18 amount) external;
    function withdrawTo(address account, IProduct product, UFixed18 amount) external;
    function liquidate(address account, IProduct product) external;
    function settleAccount(address account, Fixed18 amount) external;
    function settleProduct(UFixed18 amount) external;
    function collateral(address account, IProduct product) external view returns (UFixed18);
    function collateral(IProduct product) external view returns (UFixed18);
    function shortfall(IProduct product) external view returns (UFixed18);
    function liquidatable(address account, IProduct product) external view returns (bool);
    function liquidatableNext(address account, IProduct product) external view returns (bool);
    function resolveShortfall(IProduct product, UFixed18 amount) external;
    function claimFee() external;
    function updateLiquidationFee(UFixed18 newLiquidationFee) external;
}",492
RealWorld_TA_60_MockToken18_RealWorld_20240808122111.log,60,MockToken18,48772,2705,51477,544.0,0.29796,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../types/Token18.sol"";

contract MockToken18 {
    function etherToken() external pure returns (Token18) {
        return Token18Lib.ETHER;
    }

    function isEther(Token18 token) external pure returns (bool) {
        return Token18Lib.isEther(token);
    }

    function push(Token18 self, address recipient) external {
        Token18Lib.push(self, recipient);
    }

    function push(Token18 self, address recipient, UFixed18 amount) external {
        Token18Lib.push(self, recipient, amount);
    }

    function pull(Token18 self, address benefactor, UFixed18 amount) external {
        Token18Lib.pull(self, benefactor, amount);
    }

    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) external {
        Token18Lib.pullTo(self, benefactor, recipient, amount);
    }

    function name(Token18 self) external view returns (string memory) {
        return Token18Lib.name(self);
    }

    function symbol(Token18 self) external view returns (string memory) {
        return Token18Lib.symbol(self);
    }

    function decimals(Token18 self) external view returns (uint8) {
        return Token18Lib.decimals(self);
    }

    function balanceOf(Token18 self) external view returns (UFixed18) {
        return Token18Lib.balanceOf(self);
    }

    function balanceOf(Token18 self, address account) external view returns (UFixed18) {
        return Token18Lib.balanceOf(self, account);
    }

    receive() external payable { }
}",351
RealWorld_TA_60_ShortEther_RealWorld_20240808132859.log,60,ShortEther,51310,3138,54448,166.0,0.31931,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/ProductProviderBase.sol"";

contract ShortEther is ProductProviderBase {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;

    constructor(IOracle oracle) ProductProviderBase(oracle) { }

    // Implementation

    function rate(Position memory position) external pure override returns (Fixed18) {
        if (position.maker.isZero()) return Fixed18Lib.ZERO;

        UFixed18 utilization = position.taker.div(position.maker);
        UFixed18 capped = UFixed18Lib.min(utilization, UFixed18Lib.ONE);
        Fixed18 centered = (Fixed18Lib.from(capped).sub(Fixed18Lib.ratio(1, 2))).mul(Fixed18Lib.from(2));

        return centered.div(Fixed18Lib.from(365 days));
    }

    function payoff(Fixed18 price) public pure override returns (Fixed18) {
        return Fixed18Lib.from(-1).mul(price);
    }

    function maintenance() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(30, 100);
    }

    function fundingFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ratio(10, 100);
    }

    function makerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function takerFee() external pure override returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function makerLimit() external pure override returns (UFixed18) {
        return UFixed18Lib.from(1000);
    }
}",361
RealWorld_TA_60_PrePosition_RealWorld_20240808130516.log,60,PrePosition,167218,3218,170436,187.0,0.90045,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./Position.sol"";
import ""../ProductProvider.sol"";

/// @dev PrePosition type
struct PrePosition {
    /// @dev Oracle version at which the new position delta was recorded
    uint256 oracleVersion;

    /// @dev Size of position to open at oracle version
    Position openPosition;

    /// @dev Size of position to close at oracle version
    Position closePosition;
}

/**
 * @title PrePositionLib
 * @notice Library that manages a pre-settlement position delta.
 * @dev PrePositions track the currently awaiting-settlement deltas to a settled Position. These are
 *      Primarily necessary to introduce lag into the settlement system such that oracle lag cannot be
 *      gamed to a user's advantage. When a user opens or closes a new position, it sits as a PrePosition
 *      for one oracle version until it's settle into the Position, making it then effective. PrePositions
 *      are automatically settled at the correct oracle version even if a flywheel call doesn't happen until
 *      several version into the future by using the historical version lookups in the corresponding ""Versioned""
 *      global state types.
 */
library PrePositionLib {
    using UFixed18Lib for UFixed18;
    using Fixed18Lib for Fixed18;
    using PositionLib for Position;
    using ProductProviderLib for IProductProvider;

    /**
     * @notice Returns whether there is no pending-settlement position delta
     * @dev Can be ""empty"" even with a non-zero oracleVersion if a position is opened and
     *      closed in the same version netting out to a zero position delta
     * @param self The struct to operate on
     * @return Whether the pending-settlement position delta is empty
     */
    function isEmpty(PrePosition memory self) internal pure returns (bool) {
        return self.openPosition.isEmpty() && self.closePosition.isEmpty();
    }

    /**
     * @notice Increments the maker side of the open position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The position amount to open
     */
    function openMake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.openPosition.maker = self.openPosition.maker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netMake(self);
    }

    /**
     * @notice Increments the maker side of the close position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The maker position amount to close
     */
    function closeMake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.closePosition.maker = self.closePosition.maker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netMake(self);
    }

    /**
     * @notice Increments the taker side of the open position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The taker position amount to open
     */
    function openTake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.openPosition.taker = self.openPosition.taker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netTake(self);
    }

    /**
     * @notice Increments the taker side of the close position delta
     * @dev Nets out open and close deltas to minimize the size of each
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @param amount The taker position amount to close
     */
    function closeTake(PrePosition storage self, IOracle oracle, UFixed18 amount) internal {
        self.closePosition.taker = self.closePosition.taker.add(amount);
        self.oracleVersion = oracle.currentVersion();
        netTake(self);
    }

    /**
     * @notice Nets out the open and close on the maker side of the position delta
     * @param self The struct to operate on
     */
    function netMake(PrePosition storage self) private {
        if (self.openPosition.maker.gt(self.closePosition.maker)) {
            self.openPosition.maker = self.openPosition.maker.sub(self.closePosition.maker);
            self.closePosition.maker = UFixed18Lib.ZERO;
        } else {
            self.closePosition.maker = self.closePosition.maker.sub(self.openPosition.maker);
            self.openPosition.maker = UFixed18Lib.ZERO;
        }
    }

    /**
     * @notice Nets out the open and close on the taker side of the position delta
     * @param self The struct to operate on
     */
    function netTake(PrePosition storage self) private {
        if (self.openPosition.taker.gt(self.closePosition.taker)) {
            self.openPosition.taker = self.openPosition.taker.sub(self.closePosition.taker);
            self.closePosition.taker = UFixed18Lib.ZERO;
        } else {
            self.closePosition.taker = self.closePosition.taker.sub(self.openPosition.taker);
            self.openPosition.taker = UFixed18Lib.ZERO;
        }
    }

    /**
     * @notice Returns whether the the pending position delta can be settled at version `toOracleVersion`
     * @dev Pending-settlement positions deltas can be settled (1) oracle version after they are recorded
     * @param self The struct to operate on
     * @param toOracleVersion The potential oracle version to settle
     * @return Whether the position delta can be settled
     */
    function canSettle(PrePosition memory self, uint256 toOracleVersion) internal pure returns (bool) {
        return !isEmpty(self) && toOracleVersion > self.oracleVersion;
    }

    /**
     * @notice Computes the fee incurred for opening or closing the pending-settlement position
     * @param self The struct to operate on
     * @param provider The parameter provider of the product
     * @param toOracleVersion The oracle version at which settlement takes place
     * @return positionFee The maker / taker fee incurred
     */
    function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {
        Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);
        Position memory positionDelta = self.openPosition.add(self.closePosition);

        (UFixed18 makerNotional, UFixed18 takerNotional) = (
            Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),
            Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()
        );

        positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));
        positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee()));
    }

    /**
     * @notice Computes the next oracle version to settle
     * @dev - If there is no pending-settlement position delta, returns the current oracle version
     *      - If the pending-settlement position delta is not yet ready to be settled, returns the current oracle version
     *      - Otherwise returns the oracle version at which the pending-settlement position delta can be first settled
     *
     *      Corresponds to point (b) in the Position settlement flow
     * @param self The struct to operate on
     * @param oracle The price oracle provider
     * @return Next oracle version to settle
     */
    function oracleVersionToSettle(PrePosition storage self, IOracle oracle) internal view returns (uint256) {
        uint256 current = oracle.currentVersion();
        uint256 next = self.oracleVersion + 1;

        if (next == 1) return current;      // no pre position
        if (next > current) return current; // pre in future
        return next;                        // settle pre
    }
}",1747
RealWorld_TA_60_ProductProviderBase_RealWorld_20240808130017.log,60,ProductProviderBase,51857,1570,53427,152.0,0.290685,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../interfaces/IProductProvider.sol"";
import ""../interfaces/IOracle.sol"";

/**
 * @title ProductProviderBase
 * @notice Abstract contract that implements the oracle and payoff function portion of the product provider.
 * @dev Should be extended when implemented a new product.
 */
abstract contract ProductProviderBase is IProductProvider {
    IOracle public oracle;

    /**
     * @notice Initializes the contract state
     * @param oracle_ Oracle price provider contract address
     */
    constructor(IOracle oracle_) {
        oracle = oracle_;
    }

    /**
     * @notice Returns the payoff function given a raw oracle price
     * @param price Raw oracle price
     * @return Payoff value
     */
    function payoff(Fixed18 price) public view virtual override returns (Fixed18);

    /**
     * @notice Pass-through hook to call sync() on the oracle provider
     */
    function sync() external override {
        return oracle.sync();
    }

    /**
     * @notice Returns the payoff value at oracle version `version`
     * @param version Oracle version to return for
     * @return Payoff value at oracle version
     */
    function priceAtVersion(uint256 version) external override view returns (Fixed18) {
        return payoff(oracle.priceAtVersion(version));
    }

    /**
     * @notice Returns the timestamp at oracle version `version`
     * @param version Oracle version to return for
     * @return Timestamp at oracle version
     */
    function timestampAtVersion(uint256 version) external override view returns (uint256) {
        return oracle.timestampAtVersion(version);
    }

    /**
     * @notice Returns the current oracle version
     * @return Current oracle version
     */
    function currentVersion() external override view returns (uint256) {
        return oracle.currentVersion();
    }
}",395
RealWorld_TA_60_IProduct_RealWorld_20240808134617.log,60,IProduct,57824,1583,59407,70.0,0.32078,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.10;

import ""../product/types/position/Position.sol"";
import ""../product/types/position/PrePosition.sol"";
import ""../product/types/accumulator/Accumulator.sol"";
import ""../utils/types/UFixed18.sol"";

interface IProduct {
    event Settle(uint256 preVersion, uint256 toVersion);
    event AccountSettle(address indexed account, uint256 preVersion, uint256 toVersion);
    event MakeOpened(address indexed account, UFixed18 amount);
    event TakeOpened(address indexed account, UFixed18 amount);
    event MakeClosed(address indexed account, UFixed18 amount);
    event TakeClosed(address indexed account, UFixed18 amount);

    error ProductInsufficientLiquidityError(UFixed18 socializationFactor);
    error ProductDoubleSidedError();
    error ProductOverClosedError();
    error ProductInsufficientCollateralError();
    error ProductInLiquidationError();
    error ProductMakerOverLimitError();

    function provider() external view returns (IProductProvider);
    function initialize(IProductProvider provider_) external;
    function settle() external;
    function settleAccount(address account) external;
    function openTake(UFixed18 amount) external;
    function closeTake(UFixed18 amount) external;
    function openMake(UFixed18 amount) external;
    function closeMake(UFixed18 amount) external;
    function closeAll(address account) external;
    function maintenance(address account) external view returns (UFixed18);
    function maintenanceNext(address account) external view returns (UFixed18);
    function isClosed(address account) external view returns (bool);
    function isLiquidating(address account) external view returns (bool);
    function position(address account) external view returns (Position memory);
    function pre(address account) external view returns (PrePosition memory);
    function latestVersion() external view returns (uint256);
    function positionAtVersion(uint256 oracleVersion) external view returns (Position memory);
    function pre() external view returns (PrePosition memory);
    function valueAtVersion(uint256 oracleVersion) external view returns (Accumulator memory);
    function shareAtVersion(uint256 oracleVersion) external view returns (Accumulator memory);
    function latestVersion(address account) external view returns (uint256);
}",474
RealWorld_TA_60_MockUFixed18_RealWorld_20240808123017.log,60,MockUFixed18,72290,1478,73768,137.0,0.39101,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""../types/UFixed18.sol"";

contract MockUFixed18 {
    function zero() external pure returns (UFixed18) {
        return UFixed18Lib.ZERO;
    }

    function one() external pure returns (UFixed18) {
        return UFixed18Lib.ONE;
    }

    function from(Fixed18 a) external pure returns (UFixed18) {
        return UFixed18Lib.from(a);
    }

    function from(uint256 a) external pure returns (UFixed18) {
        return UFixed18Lib.from(a);
    }

    function isZero(UFixed18 a) external pure returns (bool) {
        return UFixed18Lib.isZero(a);
    }

    function add(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.add(a, b);
    }

    function sub(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.sub(a, b);
    }

    function mul(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.mul(a, b);
    }

    function div(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.div(a, b);
    }

    function eq(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.eq(a, b);
    }

    function gt(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.gt(a, b);
    }

    function lt(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.lt(a, b);
    }

    function gte(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.gte(a, b);
    }

    function lte(UFixed18 a, UFixed18 b) external pure returns (bool) {
        return UFixed18Lib.lte(a, b);
    }

    function compare(UFixed18 a, UFixed18 b) external pure returns (uint256) {
        return UFixed18Lib.compare(a, b);
    }

    function ratio(uint256 a, uint256 b) external pure returns (UFixed18) {
        return UFixed18Lib.ratio(a, b);
    }

    function min(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.min(a, b);
    }

    function max(UFixed18 a, UFixed18 b) external pure returns (UFixed18) {
        return UFixed18Lib.max(a, b);
    }

    function truncate(UFixed18 a) external pure returns (uint256) {
        return UFixed18Lib.truncate(a);
    }
}",639
RealWorld_TA_60_AccountAccumulator_RealWorld_20240808132041.log,60,AccountAccumulator,42412,2311,44723,173.0,0.25828,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""./Accumulator.sol"";
import ""./VersionedAccumulator.sol"";
import ""../position/AccountPosition.sol"";

/// @dev AccountAccumulator type
struct AccountAccumulator {
    /// @dev latest version that the account was synced too
    uint256 latestVersion;
}

/**
 * @title AccountAccumulatorLib
 * @notice Library that manages syncing an account-level accumulator.
 */
library AccountAccumulatorLib {
    using PositionLib for Position;
    using AccumulatorLib for Accumulator;

    /**
     * @notice Syncs the account to oracle version `versionTo`
     * @param self The struct to operate on
     * @param global Pointer to global accumulator
     * @param position Pointer to global position
     * @param versionTo Oracle version to sync account to
     * @return value The value accumulated sync last sync
     */
    function syncTo(
        AccountAccumulator storage self,
        VersionedAccumulator storage global,
        AccountPosition storage position,
        uint256 versionTo
    ) internal returns (Accumulator memory value) {
        Accumulator memory valueAccumulated =
            global.valueAtVersion[versionTo].sub(global.valueAtVersion[self.latestVersion]);
        value = position.position.mul(valueAccumulated);
        self.latestVersion = versionTo;
    }
}",296
RealWorld_TA_60_ProgramInfo_RealWorld_20240808133827.log,60,ProgramInfo,81693,2393,84086,78.0,0.456325,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.10;

import ""../../interfaces/IProduct.sol"";
import ""../../product/types/position/Position.sol"";
import ""../../product/types/accumulator/Accumulator.sol"";
import ""../../utils/types/Token18.sol"";

struct ProgramInfo {
    /// @dev Product market contract to be incentivized
    IProduct product;

    /// @dev Amount of total maker and taker rewards
    Position amount;

    /// @dev start timestamp of the program
    uint256 start;

    /// @dev duration of the program (in seconds)
    uint256 duration;

    /// @dev grace period the program where funds can still be claimed (in seconds)
    uint256 grace;

    /// @dev Reward ERC20 token contract
    Token18 token;
}

library ProgramInfoLib {
    using UFixed18Lib for UFixed18;
    using PositionLib for Position;

    uint256 private constant MIN_DURATION = 1 days;
    uint256 private constant MAX_DURATION = 2 * 365 days;
    uint256 private constant MIN_GRACE = 7 days;
    uint256 private constant MAX_GRACE = 30 days;

    error ProgramAlreadyStartedError();
    error ProgramInvalidDurationError();
    error ProgramInvalidGraceError();

    /**
     * @notice Validates and creates a new Program
     * @param fee Global Incentivizer fee
     * @param info Un-sanitized static program information
     * @return programInfo Validated static program information with fee excluded
     * @return programFee Fee amount for the program
     */
    function create(UFixed18 fee, ProgramInfo memory info)
    internal view returns (ProgramInfo memory programInfo, UFixed18 programFee) {
        if (isStarted(info, block.timestamp)) revert ProgramAlreadyStartedError();
        if (info.duration < MIN_DURATION || info.duration > MAX_DURATION) revert ProgramInvalidDurationError();
        if (info.grace < MIN_GRACE || info.grace > MAX_GRACE) revert ProgramInvalidGraceError();

        Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee));

        programInfo = ProgramInfo({
            start: info.start,
            duration: info.duration,
            grace: info.grace,

            product: info.product,
            token: info.token,
            amount: amountAfterFee
        });
        programFee = info.amount.sub(amountAfterFee).sum();
    }

    /**
     * @notice Returns the maker and taker amounts per position share
     * @param self The ProgramInfo to operate on
     * @return programFee Amounts per share
     */
    function amountPerShare(ProgramInfo memory self) internal pure returns (Accumulator memory) {
        return self.amount.div(self.duration);
    }

    /**
     * @notice Returns whether the program has started by timestamp `timestamp`
     * @param self The ProgramInfo to operate on
     * @param timestamp Timestamp to check for
     * @return Whether the program has started
     */
    function isStarted(ProgramInfo memory self, uint256 timestamp) internal pure returns (bool) {
        return timestamp >= self.start;
    }

    /**
     * @notice Returns whether the program is completed by timestamp `timestamp`
     * @param self The ProgramInfo to operate on
     * @param timestamp Timestamp to check for
     * @return Whether the program is completed
     */
    function isComplete(ProgramInfo memory self, uint256 timestamp) internal pure returns (bool) {
        return timestamp >= (self.start + self.duration);
    }
}",742
RealWorld_TA_60_UFixed18_RealWorld_20240808124821.log,60,UFixed18,171710,1590,173300,172.0,0.89035,"// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import ""./Fixed18.sol"";

/// @dev UFixed18 type
type UFixed18 is uint256;

/**
 * @title UFixed18Lib
 * @notice Library for the unsigned fixed-decimal type.
 */
library UFixed18Lib {
    error UFixed18UnderflowError(int256 value);

    uint256 private constant BASE = 1e18;
    UFixed18 public constant ZERO = UFixed18.wrap(0);
    UFixed18 public constant ONE = UFixed18.wrap(BASE);

    /**
     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal
     * @param a Signed fixed-decimal
     * @return New unsigned fixed-decimal
     */
    function from(Fixed18 a) internal pure returns (UFixed18) {
        int256 value = Fixed18.unwrap(a);
        if (value < 0) revert UFixed18UnderflowError(value);
        return UFixed18.wrap(uint256(value));
    }

    /**
     * @notice Creates a unsigned fixed-decimal from a unsigned integer
     * @param a Unsigned number
     * @return New unsigned fixed-decimal
     */
    function from(uint256 a) internal pure returns (UFixed18) {
        return UFixed18.wrap(a * BASE);
    }

    /**
     * @notice Returns whether the unsigned fixed-decimal is equal to zero.
     * @param a Unsigned fixed-decimal
     * @return Whether the unsigned fixed-decimal is zero.
     */
    function isZero(UFixed18 a) internal pure returns (bool) {
        return UFixed18.unwrap(a) == 0;
    }

    /**
     * @notice Adds two unsigned fixed-decimals `a` and `b` together
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Resulting summed unsigned fixed-decimal
     */
    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));
    }

    /**
     * @notice Subtracts unsigned fixed-decimal `b` from `a`
     * @param a Unsigned fixed-decimal to subtract from
     * @param b Unsigned fixed-decimal to subtract
     * @return Resulting subtracted unsigned fixed-decimal
     */
    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));
    }

    /**
     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Resulting multiplied unsigned fixed-decimal
     */
    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);
    }

    /**
     * @notice Divides unsigned fixed-decimal `a` by `b`
     * @param a Unsigned fixed-decimal to divide
     * @param b Unsigned fixed-decimal to divide by
     * @return Resulting subtracted unsigned fixed-decimal
     */
    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is equal to `b`
     */
    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return compare(a, b) == 1;
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is greater than `b`
     */
    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return compare(a, b) == 2;
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is less than `b`
     */
    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return compare(a, b) == 0;
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is greater than or equal to `b`
     */
    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return gt(a, b) || eq(a, b);
    }

    /**
     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Whether `a` is less than or equal to `b`
     */
    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {
        return lt(a, b) || eq(a, b);
    }

    /**
     * @notice Compares the unsigned fixed-decimals `a` and `b`
     * @dev Returns: 2 for greater than
     *               1 for equal to
     *               0 for less than
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Compare result of `a` and `b`
     */
    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {
        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));
        if (au > bu) return 2;
        if (au < bu) return 0;
        return 1;
    }

    /**
     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`
     * @param a First unsigned number
     * @param b Second unsigned number
     * @return Ratio of `a` over `b`
     */
    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {
        return UFixed18.wrap(a * BASE / b);
    }

    /**
     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Minimum of `a` and `b`
     */
    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));
        return UFixed18.wrap(au < bu ? au : bu);
    }

    /**
     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`
     * @param a First unsigned fixed-decimal
     * @param b Second unsigned fixed-decimal
     * @return Maximum of `a` and `b`
     */
    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {
        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));
        return UFixed18.wrap(au > bu ? au : bu);
    }

    /**
     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion
     * @param a Unsigned fixed-decimal
     * @return Truncated unsigned number
     */
    function truncate(UFixed18 a) internal pure returns (uint256) {
        return UFixed18.unwrap(a) / BASE;
    }
}",1818
RealWorld_TA_61_IWETHGateway_RealWorld_20240808153250.log,61,IWETHGateway,27590,1934,29524,78.0,0.17663,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;

interface IWETHGateway {
    function depositETH(
        address lendingPool,
        address onBehalfOf,
        uint16 referralCode
    ) external payable;

    function withdrawETH(uint256 amount, address to) external;

    function getWETHAddress() external view returns (address);

    function getAWETHAddress() external view returns (address);

    function getLendingPoolAddress() external view returns (address);
}",108
RealWorld_TA_61_DataTypes_RealWorld_20240808154023.log,61,DataTypes,51323,1387,52710,66.0,0.284355,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;

library DataTypes {
    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.
    struct ReserveData {
        //stores the reserve configuration
        ReserveConfigurationMap configuration;
        //the liquidity index. Expressed in ray
        uint128 liquidityIndex;
        //variable borrow index. Expressed in ray
        uint128 variableBorrowIndex;
        //the current supply rate. Expressed in ray
        uint128 currentLiquidityRate;
        //the current variable borrow rate. Expressed in ray
        uint128 currentVariableBorrowRate;
        //the current stable borrow rate. Expressed in ray
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        //tokens addresses
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        //address of the interest rate strategy
        address interestRateStrategyAddress;
        //the id of the reserve. Represents the position in the list of the active reserves
        uint8 id;
    }

    struct ReserveConfigurationMap {
        //bit 0-15: LTV
        //bit 16-31: Liq. threshold
        //bit 32-47: Liq. bonus
        //bit 48-55: Decimals
        //bit 56: Reserve is active
        //bit 57: reserve is frozen
        //bit 58: borrowing is enabled
        //bit 59: stable rate borrowing enabled
        //bit 60-63: reserved
        //bit 64-79: reserve factor
        uint256 data;
    }

    struct UserConfigurationMap {
        uint256 data;
    }

    enum InterestRateMode {
        NONE,
        STABLE,
        VARIABLE
    }
}",398
RealWorld_TA_61_PriceOracle_RealWorld_20240808142434.log,61,PriceOracle,186820,3793,190613,106.0,1.00996,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    uint32 uniswapPriceAveragingPeriod;
    struct PriceData {
        address oracle;
        uint256 decimals;
    }
    /**
     * @notice stores the price oracle and its decimals for chainlink feeds
     **/
    mapping(address => PriceData) public chainlinkFeedAddresses;
    mapping(address => uint256) decimals;

    /**
     * @notice stores the addresses of price feeds for uniswap token pairs
     **/
    mapping(bytes32 => address) public uniswapPools;

    /**
     * @notice Used to initialize the price oracle contract
     * @dev can only be invoked once
     * @param _admin owner of the price oracle
     **/
    function initialize(address _admin) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
    }

    /**
     * @notice Used to get price of the num vs den token from chainlink
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];
        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) {
            return (0, 0);
        }
        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (
                roundID1,
                price1,
                ,
                timeStamp1,
                answeredInRound1
            ) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if(timeStamp1 == 0 || answeredInRound1 < roundID1) {
                return (0, 0);
            }
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (
                roundID2,
                price2,
                ,
                timeStamp2,
                answeredInRound2
            ) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if(timeStamp2 == 0 || answeredInRound2 < roundID2) {
                return (0, 0);
            }
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(10**30)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, 30);
    }

    /**
     * @notice Used to get decimals for a token
     * @param _token address of the token
     * @return number of decimals for the token
     **/
    function getDecimals(address _token) internal view returns (uint8) {
        if (_token == address(0)) {
            return 18;
        }

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    /**
     * @notice Used to get price of the num vs den token from uniswap
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) {
            return (0, 0);
        }

        int24 _twapTick = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _numTokens = OracleLibrary.getQuoteAtTick(_twapTick, 10**30, num, den);
        return (_numTokens, 30);
    }

    function getUniswapPoolTokenId(address num, address den) internal pure returns (bytes32) {
        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    /**
     * @notice Used to get price of the num vs den token
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }

    /**
     * @notice used to check if price feed exists between 2 tokens
     * @param token1 one of the token for which price feed is to be checked
     * @param token2 other token for which price feed is to be checked
     * @return if price feed exists for the token pair
     **/
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) {
            return true;
        }

        return false;
    }

    /**
     * @notice Used to set the price feed address for a token in chainlink
     * @dev only owner can set
     * @param token address of token for which price feed is added
     * @param priceOracle addrewss of the price feed for the token
     **/
    function setChainlinkFeedAddress(address token, address priceOracle) external onlyOwner {
        uint256 priceOracleDecimals = AggregatorV3Interface(priceOracle).decimals();
        chainlinkFeedAddresses[token] = PriceData(priceOracle, priceOracleDecimals);
        decimals[token] = getDecimals(token);
        emit ChainlinkFeedUpdated(token, priceOracle);
    }

    /**
     * @notice Used to set the price feed address for a token pair in uniswap
     * @dev only owner can set
     * @param token1 address of one of the tokens for which price feed is added
     * @param token2 address of other token for which price feed is added
     * @param pool addrewss of the price feed for the token pair
     **/
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'token1 and token2 should be different addresses');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    /**
     * @notice Used to set the period in which uniswap price is averaged
     * @dev only owner can set. This is used to prevent attacks to control price feed
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }
}",2032
RealWorld_TA_61_ICToken_RealWorld_20240808153411.log,61,ICToken,34328,2049,36377,227.0,0.21262,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

interface ICToken {
    function underlying() external view returns (address);

    function mint(uint256 mintAmount) external returns (uint256);

    function redeem(uint256 redeemTokens) external returns (uint256);

    function liquidateBorrow(
        address borrower,
        uint256 amount,
        address collateral
    ) external returns (uint256);

    function repayBorrow(uint256 repayAmount) external returns (uint256);

    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);

    function balanceOfUnderlying(address account) external returns (uint256);

    function exchangeRateCurrent() external returns (uint256);

    function exchangeRateStored() external view returns (uint256);

    function supplyRatePerBlock() external returns (uint256);

    function redeemUnderlying(uint256) external returns (uint256);
}",193
RealWorld_TA_61_Proxy_RealWorld_20240808142735.log,61,Proxy,24133,1335,25468,65.0,0.147365,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol';

contract SublimeProxy is TransparentUpgradeableProxy {
    constructor(
        address logic,
        address admin,
        bytes memory data
    ) payable TransparentUpgradeableProxy(logic, admin, data) {}
}",74
RealWorld_TA_61_IUniswapV3Factory_RealWorld_20240808151106.log,61,IUniswapV3Factory,93841,2148,95989,77.0,0.512165,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.6;

interface IUniswapV3Factory {
    /// @notice Emitted when the owner of the factory is changed
    /// @param oldOwner The owner before the owner was changed
    /// @param newOwner The owner after the owner was changed
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when a pool is created
    /// @param token0 The first token of the pool by address sort order
    /// @param token1 The second token of the pool by address sort order
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks
    /// @param pool The address of the created pool
    event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool);

    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
    /// @param fee The enabled fee, denominated in hundredths of a bip
    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);

    /// @notice Returns the current owner of the factory
    /// @dev Can be changed by the current owner via setOwner
    /// @return The address of the factory owner
    function owner() external view returns (address);

    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
    /// @return The tick spacing
    function feeAmountTickSpacing(uint24 fee) external view returns (int24);

    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
    /// @param tokenA The contract address of either token0 or token1
    /// @param tokenB The contract address of the other token
    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
    /// @return pool The pool address
    function getPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external view returns (address pool);

    /// @notice Creates a pool for the given two tokens and fee
    /// @param tokenA One of the two tokens in the desired pool
    /// @param tokenB The other of the two tokens in the desired pool
    /// @param fee The desired fee for the pool
    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
    /// are invalid.
    /// @return pool The address of the newly created pool
    function createPool(
        address tokenA,
        address tokenB,
        uint24 fee
    ) external returns (address pool);

    /// @notice Updates the owner of the factory
    /// @dev Must be called by the current owner
    /// @param _owner The new owner of the factory
    function setOwner(address _owner) external;

    /// @notice Enables a fee amount with the given tickSpacing
    /// @dev Fee amounts may never be removed once enabled
    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
}",886
RealWorld_TA_61_YearnYield_RealWorld_20240808145628.log,61,YearnYield,181510,5497,187007,144.0,1.01749,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IyVault.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into YVault
 * @author Sublime
 **/
contract YearnYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update liquidity token for a asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner nonReentrant returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @dev Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18);
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address vault, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialTokenBalance = IERC20(vault).balanceOf(address(this));

        //mint vault
        IyVault(vault).depositETH{value: amount}();

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(initialTokenBalance);
    }

    function _depositERC20(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 sharesBefore = IERC20(vault).balanceOf(address(this));

        //lock collateral in vault
        IERC20(asset).approve(vault, 0);
        IERC20(asset).approve(vault, amount);
        IyVault(vault).deposit(amount);

        sharesReceived = IERC20(vault).balanceOf(address(this)).sub(sharesBefore);
    }

    function _withdrawETH(address vault, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        IyVault(vault).withdrawETH(amount);

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address vault,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));

        IyVault(vault).withdraw(amount);

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    receive() external payable {}
}",1949
RealWorld_TA_61_GovernanceTester_RealWorld_20240808143140.log,61,GovernanceTester,29518,1793,31311,69.0,0.18345,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract GovernanceTester {
    address public gov;
    uint256 public value;

    event valueUpdated(address indexed governance, address indexed sender, uint256 v);

    modifier onlyGov() {
        require(msg.sender == gov, 'Only Governance should be able to hit');
        _;
    }

    constructor(address _gov, uint256 _val) {
        gov = _gov;
        value = _val;
    }

    function update(uint256 _value) public onlyGov {
        value = _value;
        emit valueUpdated(gov, msg.sender, _value);
    }
}",134
RealWorld_TA_61_Token_RealWorld_20240808142842.log,61,Token,29590,1848,31438,79.0,0.18491,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/access/Ownable.sol';

contract Token is ERC20, Ownable {
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
    }

    function mint(address _to, uint256 _amount) external onlyOwner {
        require(_amount != 0, 'Token::burn: invalid amount');
        _mint(_to, _amount);
    }
}",137
RealWorld_TA_61_Strategy_RealWorld_20240808143454.log,61,Strategy,74431,4315,78746,100.0,0.458455,"// SPDX-License-Identifier: MIT

pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../../interfaces/Invest/IyVault.sol';

import '../../interfaces/Invest/IyVault.sol';
import './IController.sol';

/*

 A strategy must implement the following calls;

 - deposit()
 - withdraw(address) must exclude any tokens used in the yield - Controller role - withdraw should return to Controller
 - withdraw(uint) - Controller | Vault role - withdraw should always return to vault
 - withdrawAll() - Controller | Vault role - withdraw should always return to vault
 - balanceOf()

 Where possible, strategies must remain as immutable as possible, instead of updating variables, we update the contract by linking it in the controller

*/

contract Strategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public want;
    address public governance;
    address public controller;
    address public strategist;

    constructor(address _controller, address _want) {
        governance = msg.sender;
        controller = _controller;
        want = _want;
    }

    function _approveAll() internal {
        // IERC20(token).approve(mcd_join_eth_a, uint256(-1));
    }

    function deposit() public view {
        uint256 _token = IERC20(want).balanceOf(address(this));
        if (_token > 0) {
            // approve yVaultDAI use DAI
            // yVault(yVaultDAI).depositAll();
        }
    }

    // Controller only function for creating additional rewards from dust
    function withdraw(IERC20 _asset) external returns (uint256 balance) {
        require(msg.sender == controller, '!controller');
        balance = _asset.balanceOf(address(this));
        _asset.safeTransfer(controller, balance);
    }

    // Withdraw partial funds, normally used with a vault withdrawal
    function withdraw(uint256 _amount) external {
        require(msg.sender == controller, '!controller');
        address _vault = IController(controller).vaults(address(want));
        require(_vault != address(0), '!vault'); // additional protection so we don't burn the funds

        IERC20(want).safeTransfer(_vault, _amount);
    }

    // Withdraw all funds, normally used when migrating strategies
    function withdrawAll() external returns (uint256 balance) {
        require(msg.sender == controller, '!controller');
        balance = IERC20(want).balanceOf(address(this));
        address _vault = IController(controller).vaults(address(want));
        IERC20(want).safeTransfer(_vault, balance);
    }

    function balanceOf() public view returns (uint256) {
        return IERC20(want).balanceOf(address(this));
    }

    function setGovernance(address _governance) external {
        require(msg.sender == governance, '!governance');
        governance = _governance;
    }

    function setController(address _controller) external {
        require(msg.sender == governance, '!governance');
        controller = _controller;
    }
}",648
RealWorld_TA_61_IVerification_RealWorld_20240808151225.log,61,IVerification,73476,1664,75140,72.0,0.40066,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IVerification {
    /// @notice Event emitted when a verifier is added as valid by admin
    /// @param verifier The address of the verifier contract to be added
    event VerifierAdded(address indexed verifier);

    /// @notice Event emitted when a verifier is to be marked as invalid by admin
    /// @param verifier The address of the verified contract to be marked as invalid
    event VerifierRemoved(address indexed verifier);

    /// @notice Event emitted when a master address is verified by a valid verifier
    /// @param masterAddress The masterAddress which is verifier by the verifier
    /// @param verifier The verifier which verified the masterAddress
    /// @param activatesAt Timestamp at which master address is considered active after the cooldown period
    event UserRegistered(address indexed masterAddress, address indexed verifier, uint256 activatesAt);

    /// @notice Event emitted when a master address is marked as invalid/unregisterd by a valid verifier
    /// @param masterAddress The masterAddress which is unregistered
    /// @param verifier The verifier which verified the masterAddress
    /// @param unregisteredBy The msg.sender by which the user was unregistered
    event UserUnregistered(address indexed masterAddress, address indexed verifier, address indexed unregisteredBy);

    /// @notice Event emitted when an address is linked to masterAddress
    /// @param linkedAddress The address which is linked to masterAddress
    /// @param masterAddress The masterAddress to which address is linked
    /// @param activatesAt Timestamp at which linked address is considered active after the cooldown period
    event AddressLinked(address indexed linkedAddress, address indexed masterAddress, uint256 activatesAt);

    /// @notice Event emitted when an address is unlinked from a masterAddress
    /// @param linkedAddress The address which is linked to masterAddress
    /// @param masterAddress The masterAddress to which address was linked
    event AddressUnlinked(address indexed linkedAddress, address indexed masterAddress);

    /// @notice Event emitted when master address placed a request to link another address to itself
    /// @param linkedAddress The address which is to be linked to masterAddress
    /// @param masterAddress The masterAddress to which address is to be linked
    event AddressLinkingRequested(address indexed linkedAddress, address indexed masterAddress);

    /// @notice Event emitted when master address cancels the request placed to link another address to itself
    /// @param linkedAddress The address which is to be linked to masterAddress
    /// @param masterAddress The masterAddress to which address is to be linked
    event AddressLinkingRequestCancelled(address indexed linkedAddress, address indexed masterAddress);

    /// @notice Event emitted when activation delay is updated
    /// @param activationDelay updated value of activationDelay in seconds
    event ActivationDelayUpdated(uint256 activationDelay);

    function isUser(address _user, address _verifier) external view returns (bool);

    function registerMasterAddress(address _masterAddress, bool _isMasterLinked) external;

    function unregisterMasterAddress(address _masterAddress, address _verifier) external;
}",651
RealWorld_TA_61_adminVerifier_RealWorld_20240808144841.log,61,adminVerifier,67627,2824,70451,82.0,0.394615,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract AdminVerifier is Initializable, IVerifier, OwnableUpgradeable {
    /**
     * @notice stores the verification contract instance
     */
    IVerification public verification;

    /**
     * @notice stores the user metadata against their address
     */
    mapping(address => string) public userData;

    /**
     * @notice emitted when verification contract address is updated
     * @param verification address of the updated verification contract
     */
    event VerificationUpdated(address indexed verification);

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    function initialize(address _admin, address _verification) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateVerification(_verification);
    }

    /**
     * @notice used to register user
     * @dev ohly owner can register users
     * @param _user address of the user being registered
     * @param _metadata metadata related to the user
     * @param _isMasterLinked should master address be linked to itself
     */
    function registerUser(
        address _user,
        string memory _metadata,
        bool _isMasterLinked
    ) external onlyOwner {
        require(bytes(userData[_user]).length == 0, 'User already exists');
        verification.registerMasterAddress(_user, _isMasterLinked);
        userData[_user] = _metadata;
        emit UserRegistered(_user, _isMasterLinked, _metadata);
    }

    /**
     * @notice used to unregister user
     * @dev ohly owner can unregister users
     * @param _user address of the user being unregistered
     */
    function unregisterUser(address _user) external onlyOwner {
        require(bytes(userData[_user]).length != 0, 'User doesnt exists');
        delete userData[_user];
        verification.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update verification contract address
     * @dev ohly owner can update
     * @param _verification address of the verification contract
     */
    function updateVerification(address _verification) external onlyOwner {
        _updateVerification(_verification);
    }

    function _updateVerification(address _verification) internal {
        verification = IVerification(_verification);
        emit VerificationUpdated(_verification);
    }
}",574
RealWorld_TA_61_FluxAggregator_RealWorld_20240808143003.log,61,FluxAggregator,37276,3013,40289,95.0,0.24664,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract FluxAggregator {
    uint256 public version = 3;
    uint8 public decimals;
    string public description;

    int256 public value = 1;
    uint80 latestRoundId = 5;

    function setValue(int256 newVal) public {
        value = newVal;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        return (0, value, 0, 0, 0);
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, value, 0, 0, 0);
    }
}",205
RealWorld_TA_61_Repayments_RealWorld_20240808150822.log,61,Repayments,454969,5195,460164,162.0,2.378745,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IRepayment.sol';

/**
 * @title Repayments contract
 * @dev For accuracy considering base itself as (10**30)
 * @notice Implements the functions related to repayments (payments that
 * have to made by the borrower back to the pool)
 * @author Sublime
 */
contract Repayments is Initializable, IRepayment, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    uint256 constant MAX_INT = 2**256 - 1;
    uint256 constant YEAR_IN_SECONDS = 365 days;

    IPoolFactory poolFactory;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repaymennt defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    uint256 gracePenaltyRate;
    uint256 gracePeriodFraction; // fraction of the repayment interval

    struct RepaymentVariables {
        uint256 repaidAmount;
        bool isLoanExtensionActive;
        uint256 loanDurationCovered;
        uint256 loanExtensionPeriod; // period for which the extension was granted, ie, if loanExtensionPeriod is 7 * 10**30, 7th instalment can be repaid by 8th instalment deadline
    }

    struct RepaymentConstants {
        uint256 numberOfTotalRepayments; // using it to check if RepaymentDetails Exists as repayment Interval!=0 in any case
        uint256 gracePenaltyRate;
        uint256 gracePeriodFraction;
        uint256 loanDuration;
        uint256 repaymentInterval;
        uint256 borrowRate;
        uint256 loanStartTime;
        address repayAsset;
    }

    /**
     * @notice used to maintain the variables related to repayment against a pool
     */
    mapping(address => RepaymentVariables) public repayVariables;

    /**
     * @notice used to maintain the constants related to repayment against a pool
     */
    mapping(address => RepaymentConstants) public repayConstants;

    /// @notice determines if the pool is active or not based on whether repayments have been started by the
    ///borrower for this particular pool or not
    /// @param _poolID address of the pool for which we want to test statu
    modifier isPoolInitialized(address _poolID) {
        require(repayConstants[_poolID].numberOfTotalRepayments != 0, 'Pool is not Initiliazed');
        _;
    }

    /// @notice modifier used to determine whether the current pool is valid or not
    /// @dev poolRegistry from IPoolFactory interface returns a bool
    modifier onlyValidPool() {
        require(poolFactory.poolRegistry(msg.sender), 'Repayments::onlyValidPool - Invalid Pool');
        _;
    }

    /**
     * @notice modifier used to check if msg.sender is the owner
     */
    modifier onlyOwner() {
        require(msg.sender == poolFactory.owner(), 'Not owner');
        _;
    }

    /// @notice Initializes the contract (similar to a constructor)
    /// @dev Since we cannot use constructors when using OpenZeppelin Upgrades, we use the initialize function
    ///and the initializer modifier makes sure that this function is called only once
    /// @param _poolFactory The address of the pool factory
    /// @param _gracePenaltyRate The penalty rate levied in the grace period
    /// @param _gracePeriodFraction The fraction of repayment interval that will be allowed as grace period
    function initialize(
        address _poolFactory,
        uint256 _gracePenaltyRate,
        uint256 _gracePeriodFraction
    ) external initializer {
        _updatePoolFactory(_poolFactory);
        _updateGracePenaltyRate(_gracePenaltyRate);
        _updateGracePeriodFraction(_gracePeriodFraction);
    }

    /**
     * @notice used to update pool factory address
     * @param _poolFactory address of pool factory contract
     */
    function updatePoolFactory(address _poolFactory) external onlyOwner {
        _updatePoolFactory(_poolFactory);
    }

    function _updatePoolFactory(address _poolFactory) internal {
        require(_poolFactory != address(0), '0 address not allowed');
        poolFactory = IPoolFactory(_poolFactory);
        emit PoolFactoryUpdated(_poolFactory);
    }

    /**
     * @notice used to update grace period as a fraction of repayment interval
     * @param _gracePeriodFraction updated value of gracePeriodFraction multiplied by 10**30
     */
    function updateGracePeriodFraction(uint256 _gracePeriodFraction) external onlyOwner {
        _updateGracePeriodFraction(_gracePeriodFraction);
    }

    function _updateGracePeriodFraction(uint256 _gracePeriodFraction) internal {
        gracePeriodFraction = _gracePeriodFraction;
        emit GracePeriodFractionUpdated(_gracePeriodFraction);
    }

    /**
     * @notice used to update grace penality rate
     * @param _gracePenaltyRate value of grace penality rate multiplied by 10**30
     */
    function updateGracePenaltyRate(uint256 _gracePenaltyRate) external onlyOwner {
        _updateGracePenaltyRate(_gracePenaltyRate);
    }

    function _updateGracePenaltyRate(uint256 _gracePenaltyRate) internal {
        gracePenaltyRate = _gracePenaltyRate;
        emit GracePenaltyRateUpdated(_gracePenaltyRate);
    }

    /// @notice For a valid pool, the repayment schedule is being initialized here
    /// @dev Imported from RepaymentStorage.sol repayConstants is a mapping(address => repayConstants)
    /// @param numberOfTotalRepayments The total number of repayments that will be required from the borrower
    /// @param repaymentInterval Intervals after which repayment will be due
    /// @param borrowRate The rate at which lending took place
    /// @param loanStartTime The starting time of the loan
    /// @param lentAsset The address of the asset that was lent (basically a ERC20 token address)
    function initializeRepayment(
        uint256 numberOfTotalRepayments,
        uint256 repaymentInterval,
        uint256 borrowRate,
        uint256 loanStartTime,
        address lentAsset
    ) external override onlyValidPool {
        repayConstants[msg.sender].gracePenaltyRate = gracePenaltyRate;
        repayConstants[msg.sender].gracePeriodFraction = gracePeriodFraction;
        repayConstants[msg.sender].numberOfTotalRepayments = numberOfTotalRepayments;
        repayConstants[msg.sender].loanDuration = repaymentInterval.mul(numberOfTotalRepayments).mul(10**30);
        repayConstants[msg.sender].repaymentInterval = repaymentInterval.mul(10**30);
        repayConstants[msg.sender].borrowRate = borrowRate;
        repayConstants[msg.sender].loanStartTime = loanStartTime.mul(10**30);
        repayConstants[msg.sender].repayAsset = lentAsset;
    }

    /**
     * @notice returns the number of repayment intervals that have been repaid,
     * if repayment interval = 10 secs, loan duration covered = 55 secs, repayment intervals covered = 5
     * @param _poolID address of the pool
     * @return scaled interest per second
     */

    function getInterestPerSecond(address _poolID) public view returns (uint256) {
        uint256 _activePrincipal = IPool(_poolID).totalSupply();
        uint256 _interestPerSecond = _activePrincipal.mul(repayConstants[_poolID].borrowRate).div(YEAR_IN_SECONDS);
        return _interestPerSecond;
    }

    /// @notice This function determines the number of completed instalments
    /// @param _poolID The address of the pool for which we want the completed instalments
    /// @return scaled instalments completed
    function getInstalmentsCompleted(address _poolID) public view returns (uint256) {
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _loanDurationCovered = repayVariables[_poolID].loanDurationCovered;
        uint256 _instalmentsCompleted = _loanDurationCovered.div(_repaymentInterval).mul(10**30); // dividing exponents, returns whole number rounded down

        return _instalmentsCompleted;
    }

    /// @notice This function determines the interest that is due for the borrower till the current instalment deadline
    /// @param _poolID The address of the pool for which we want the interest
    /// @return scaled interest due till instalment deadline
    function getInterestDueTillInstalmentDeadline(address _poolID) public view returns (uint256) {
        uint256 _interestPerSecond = getInterestPerSecond(_poolID);
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);
        uint256 _loanDurationCovered = repayVariables[_poolID].loanDurationCovered;
        uint256 _interestDueTillInstalmentDeadline = (
            _nextInstalmentDeadline.sub(repayConstants[_poolID].loanStartTime).sub(_loanDurationCovered)
        ).mul(_interestPerSecond).div(10**30);
        return _interestDueTillInstalmentDeadline;
    }

    /// @notice This function determines the timestamp of the next instalment deadline
    /// @param _poolID The address of the pool for which we want the next instalment deadline
    /// @return timestamp before which next instalment ends
    function getNextInstalmentDeadline(address _poolID) public view override returns (uint256) {
        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);
        if (_instalmentsCompleted == repayConstants[_poolID].numberOfTotalRepayments.mul(10**30)) {
            revert('Pool completely repaid');
        }
        uint256 _loanExtensionPeriod = repayVariables[_poolID].loanExtensionPeriod;
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _loanStartTime = repayConstants[_poolID].loanStartTime;
        uint256 _nextInstalmentDeadline;

        if (_loanExtensionPeriod > _instalmentsCompleted) {
            _nextInstalmentDeadline = ((_instalmentsCompleted.add(10**30).add(10**30)).mul(_repaymentInterval).div(10**30)).add(
                _loanStartTime
            );
        } else {
            _nextInstalmentDeadline = ((_instalmentsCompleted.add(10**30)).mul(_repaymentInterval).div(10**30)).add(_loanStartTime);
        }
        return _nextInstalmentDeadline;
    }

    /// @notice This function determine the current instalment interval
    /// @param _poolID The address of the pool for which we want the current instalment interval
    /// @return scaled instalment interval
    function getCurrentInstalmentInterval(address _poolID) public view returns (uint256) {
        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);
        return _instalmentsCompleted.add(10**30);
    }

    /// @notice This function determines the current (loan) interval
    /// @dev adding 10**30 to add 1. Considering base itself as (10**30)
    /// @param _poolID The address of the pool for which we want the current loan interval
    /// @return scaled current loan interval
    function getCurrentLoanInterval(address _poolID) external view override returns (uint256) {
        uint256 _loanStartTime = repayConstants[_poolID].loanStartTime;
        uint256 _currentTime = block.timestamp.mul(10**30);
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _currentInterval = ((_currentTime.sub(_loanStartTime)).mul(10**30).div(_repaymentInterval)).add(10**30);

        return _currentInterval;
    }

    /// @notice Check if grace penalty is applicable or not
    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool for which we want to inquire if grace penalty is applicable or not
    /// @return boolean value indicating if applicable or not
    function isGracePenaltyApplicable(address _poolID) public view returns (bool) {
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _currentTime = block.timestamp.mul(10**30);
        uint256 _gracePeriodFraction = repayConstants[_poolID].gracePeriodFraction;
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);
        uint256 _gracePeriodDeadline = _nextInstalmentDeadline.add(_gracePeriodFraction.mul(_repaymentInterval).div(10**30));

        require(_currentTime <= _gracePeriodDeadline, 'Borrower has defaulted');

        if (_currentTime <= _nextInstalmentDeadline) return false;
        else return true;
    }

    /// @notice Checks if the borrower has defaulted
    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool from which borrower borrowed
    /// @return bool indicating whether the borrower has defaulted
    function didBorrowerDefault(address _poolID) external view override returns (bool) {
        uint256 _repaymentInterval = repayConstants[_poolID].repaymentInterval;
        uint256 _currentTime = block.timestamp.mul(10**30);
        uint256 _gracePeriodFraction = repayConstants[_poolID].gracePeriodFraction;
        uint256 _nextInstalmentDeadline = getNextInstalmentDeadline(_poolID);
        uint256 _gracePeriodDeadline = _nextInstalmentDeadline.add(_gracePeriodFraction.mul(_repaymentInterval).div(10**30));
        if (_currentTime > _gracePeriodDeadline) return true;
        else return false;
    }

    /// @notice Determines entire interest remaining to be paid for the loan issued to the borrower
    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool for which we want to calculate remaining interest
    /// @return interest remaining
    function getInterestLeft(address _poolID) public view returns (uint256) {
        uint256 _interestPerSecond = getInterestPerSecond((_poolID));
        uint256 _loanDurationLeft = repayConstants[_poolID].loanDuration.sub(repayVariables[_poolID].loanDurationCovered);
        uint256 _interestLeft = _interestPerSecond.mul(_loanDurationLeft).div(10**30); // multiplying exponents

        return _interestLeft;
    }

    /// @notice Given there is no loan extension, find the overdue interest after missing the repayment deadline
    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool
    /// @return interest amount that is overdue
    function getInterestOverdue(address _poolID) public view returns (uint256) {
        require(repayVariables[_poolID].isLoanExtensionActive, 'No overdue');
        uint256 _instalmentsCompleted = getInstalmentsCompleted(_poolID);
        uint256 _interestPerSecond = getInterestPerSecond(_poolID);
        uint256 _interestOverdue = (
            (
                (_instalmentsCompleted.add(10**30)).mul(repayConstants[_poolID].repaymentInterval).div(10**30).sub(
                    repayVariables[_poolID].loanDurationCovered
                )
            )
        ).mul(_interestPerSecond).div(10**30);
        return _interestOverdue;
    }

    /// @notice Used to for your overdues, grace penalty and interest
    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool
    /// @param _amount amount repaid by the borrower
    function repay(address _poolID, uint256 _amount) external payable nonReentrant isPoolInitialized(_poolID) {
        address _asset = repayConstants[_poolID].repayAsset;
        uint256 _amountRepaid = _repay(_poolID, _amount, false);

        _transferTokens(msg.sender, _poolID, _asset, _amountRepaid);
    }

    function _repayExtension(address _poolID) internal returns (uint256) {
        if (repayVariables[_poolID].isLoanExtensionActive) {
            uint256 _interestOverdue = getInterestOverdue(_poolID);
            repayVariables[_poolID].isLoanExtensionActive = false; // deactivate loan extension flag
            repayVariables[_poolID].loanDurationCovered = (getInstalmentsCompleted(_poolID).add(10**30))
                .mul(repayConstants[_poolID].repaymentInterval)
                .div(10**30);
            emit ExtensionRepaid(_poolID, _interestOverdue);
            return _interestOverdue;
        } else {
            return 0;
        }
    }

    function _repayGracePenalty(address _poolID) internal returns (uint256) {
        bool _isBorrowerLate = isGracePenaltyApplicable(_poolID);

        if (_isBorrowerLate) {
            uint256 _penalty = repayConstants[_poolID].gracePenaltyRate.mul(getInterestDueTillInstalmentDeadline(_poolID)).div(10**30);
            emit GracePenaltyRepaid(_poolID, _penalty);
            return _penalty;
        } else {
            return 0;
        }
    }

    function _repayInterest(
        address _poolID,
        uint256 _amount,
        bool _isLastRepayment
    ) internal returns (uint256) {
        uint256 _interestLeft = getInterestLeft(_poolID);
        require((_amount < _interestLeft) != _isLastRepayment, 'Repayments::repay complete interest must be repaid along with principal');

        if (_amount < _interestLeft) {
            uint256 _interestPerSecond = getInterestPerSecond(_poolID);
            uint256 _newDurationRepaid = _amount.mul(10**30).div(_interestPerSecond); // dividing exponents
            repayVariables[_poolID].loanDurationCovered = repayVariables[_poolID].loanDurationCovered.add(_newDurationRepaid);
            emit InterestRepaid(_poolID, _amount);
            return _amount;
        } else {
            repayVariables[_poolID].loanDurationCovered = repayConstants[_poolID].loanDuration; // full interest repaid
            emit InterestRepaymentComplete(_poolID, _interestLeft);
            return _interestLeft;
        }
    }

    function _updateRepaidAmount(address _poolID, uint256 _scaledRepaidAmount) internal returns (uint256) {
        uint256 _toPay = _scaledRepaidAmount.div(10**30);
        repayVariables[_poolID].repaidAmount = repayVariables[_poolID].repaidAmount.add(_toPay);
        return _toPay;
    }

    function _repay(
        address _poolID,
        uint256 _amount,
        bool _isLastRepayment
    ) internal returns (uint256) {
        IPool _pool = IPool(_poolID);
        _amount = _amount * 10**30;
        uint256 _loanStatus = _pool.getLoanStatus();
        require(_loanStatus == uint(LoanStatus.ACTIVE) , 'Repayments:repayInterest Pool should be active.');

        uint256 _initialAmount = _amount;

        // pay off grace penality
        uint256 _gracePenaltyDue = _repayGracePenalty(_poolID);
        _amount = _amount.sub(_gracePenaltyDue, 'doesnt cover grace penality');

        // pay off the overdue
        uint256 _interestOverdue = _repayExtension(_poolID);
        _amount = _amount.sub(_interestOverdue, 'doesnt cover overdue interest');

        // pay interest
        uint256 _interestRepaid = _repayInterest(_poolID, _amount, _isLastRepayment);
        _amount = _amount.sub(_interestRepaid);

        return _updateRepaidAmount(_poolID, _initialAmount.sub(_amount));
    }

    /// @notice Used to pay off the principal of the loan, once the overdues and interests are repaid
    /// @dev (10**30) is included to maintain the accuracy of the arithmetic operations
    /// @param _poolID address of the pool
    function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {
        address _asset = repayConstants[_poolID].repayAsset;
        uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);
        IPool _pool = IPool(_poolID);

        require(!repayVariables[_poolID].isLoanExtensionActive, 'Repayments:repayPrincipal Repayment overdue unpaid');

        require(
            repayConstants[_poolID].loanDuration == repayVariables[_poolID].loanDurationCovered,
            'Repayments:repayPrincipal Unpaid interest'
        );

        uint256 _amount = _pool.totalSupply();
        uint256 _amountToPay = _amount.add(_interestToRepay);
        _transferTokens(msg.sender, _poolID, _asset, _amountToPay);
        emit PrincipalRepaid(_poolID, _amount);

        IPool(_poolID).closeLoan();
    }

    /// @notice Returns the total amount that has been repaid by the borrower till now
    /// @param _poolID address of the pool
    /// @return total amount repaid
    function getTotalRepaidAmount(address _poolID) external view override returns (uint256) {
        return repayVariables[_poolID].repaidAmount;
    }

    /// @notice This function activates the instalment deadline
    /// @param _poolID address of the pool for which deadline is extended
    function instalmentDeadlineExtended(address _poolID) external override {
        require(msg.sender == poolFactory.extension(), 'Repayments::repaymentExtended - Invalid caller');

        repayVariables[_poolID].isLoanExtensionActive = true;
        repayVariables[_poolID].loanExtensionPeriod = getCurrentInstalmentInterval(_poolID);
    }

    /// @notice Returns the loanDurationCovered till now and the interest per second which will help in interest calculation
    /// @param _poolID address of the pool for which we want to calculate interest
    /// @return Loan Duration Covered and the interest per second
    function getInterestCalculationVars(address _poolID) external view override returns (uint256, uint256) {
        uint256 _interestPerSecond = getInterestPerSecond(_poolID);
        return (repayVariables[_poolID].loanDurationCovered, _interestPerSecond);
    }

    /// @notice Returns the fraction of repayment interval decided as the grace period fraction
    /// @return grace period fraction
    function getGracePeriodFraction() external view override returns (uint256) {
        return gracePeriodFraction;
    }

    function _transferTokens(
        address _from,
        address _to,
        address _asset,
        uint256 _amount
    ) internal {
        if (_asset == address(0)) {
            (bool transferSuccess, ) = _to.call{value: _amount}('');
            require(transferSuccess, '_transferTokens: Transfer failed');
            if (msg.value != _amount) {
                (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}('');
                require(refundSuccess, '_transferTokens: Refund failed');
            }
        } else {
            IERC20(_asset).safeTransferFrom(_from, _to, _amount);
        }
    }
}",5192
RealWorld_TA_61_SavingsAccountUtil_RealWorld_20240808144012.log,61,SavingsAccountUtil,100948,4048,104996,105.0,0.5857,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../interfaces/ISavingsAccount.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';

library SavingsAccountUtil {
    using SafeERC20 for IERC20;

    function depositFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares,
        bool _toSavingsAccount
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);
        }
    }

    function directDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        bool _toSavingsAccount,
        address _strategy
    ) internal returns (uint256) {
        if (_toSavingsAccount) {
            return directSavingsAccountDeposit(_savingsAccount, _from, _to, _amount, _token, _strategy);
        } else {
            return transferTokens(_token, _amount, _from, _to);
        }
    }

    function directSavingsAccountDeposit(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        transferTokens(_token, _amount, _from, address(this));
        uint256 _ethValue;
        if (_token == address(0)) {
            _ethValue = _amount;
        } else {
            address _approveTo = _strategy;
            if (_strategy == address(0)) {
                _approveTo = address(_savingsAccount);
            }
            IERC20(_token).safeApprove(_approveTo, _amount);
        }
        _sharesReceived = _savingsAccount.deposit{value: _ethValue}(_amount, _token, _strategy, _to);
    }

    function savingsAccountTransfer(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256) {
        if (_from == address(this)) {
            _savingsAccount.transfer(_amount, _token, _strategy, _to);
        } else {
            _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);
        }
        return _amount;
    }

    function withdrawFromSavingsAccount(
        ISavingsAccount _savingsAccount,
        address _from,
        address _to,
        uint256 _amount,
        address _token,
        address _strategy,
        bool _withdrawShares
    ) internal returns (uint256 _amountReceived) {
        if (_from == address(this)) {
            _amountReceived = _savingsAccount.withdraw(_amount, _token, _strategy, payable(_to), _withdrawShares);
        } else {
            _amountReceived = _savingsAccount.withdrawFrom(_amount, _token, _strategy, _from, payable(_to), _withdrawShares);
        }
    }

    function transferTokens(
        address _token,
        uint256 _amount,
        address _from,
        address _to
    ) internal returns (uint256) {
        if (_amount == 0) {
            return 0;
        }
        if (_token == address(0)) {
            require(msg.value >= _amount, 'ethers provided should be greater than _amount');

            if (_to != address(this)) {
                (bool success, ) = payable(_to).call{value: _amount}('');
                require(success, 'Transfer failed');
            }
            if (msg.value > _amount) {
                (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}('');
                require(success, 'Transfer failed');
            }
            return _amount;
        }
        if (_from == address(this)) {
            IERC20(_token).safeTransfer(_to, _amount);
        } else {
            //pool
            IERC20(_token).safeTransferFrom(_from, _to, _amount);
        }
        return _amount;
    }
}",989
RealWorld_TA_61_Controller_RealWorld_20240808143252.log,61,Controller,159344,5564,164908,119.0,0.908,"/**
 *Submitted for verification at Etherscan.io on 2020-08-11
 */

// SPDX-License-Identifier: MIT

pragma solidity 0.7.6;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

interface IStrategy {
    function want() external view returns (address);

    function deposit() external;

    function withdraw(address) external;

    function withdraw(uint256) external;

    function withdrawAll() external returns (uint256);

    function balanceOf() external view returns (uint256);
}

interface Converter {
    function convert(address) external returns (uint256);
}

interface OneSplitAudit {
    function swap(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 minReturn,
        uint256[] calldata distribution,
        uint256 flags
    ) external payable returns (uint256 returnAmount);

    function getExpectedReturn(
        address fromToken,
        address destToken,
        uint256 amount,
        uint256 parts,
        uint256 flags // See constants in IOneSplit.sol
    ) external view returns (uint256 returnAmount, uint256[] memory distribution);
}

contract Controller {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address public governance;
    address public strategist;

    address public onesplit;
    address public rewards;
    mapping(address => address) public vaults;
    mapping(address => address) public strategies;
    mapping(address => mapping(address => address)) public converters;

    mapping(address => mapping(address => bool)) public approvedStrategies;

    uint256 public split = 500;
    uint256 public constant max = 10000;

    constructor(address _rewards) {
        governance = msg.sender;
        strategist = msg.sender;
        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);
        rewards = _rewards;
    }

    function setRewards(address _rewards) public {
        require(msg.sender == governance, '!governance');
        rewards = _rewards;
    }

    function setStrategist(address _strategist) public {
        require(msg.sender == governance, '!governance');
        strategist = _strategist;
    }

    function setSplit(uint256 _split) public {
        require(msg.sender == governance, '!governance');
        split = _split;
    }

    function setOneSplit(address _onesplit) public {
        require(msg.sender == governance, '!governance');
        onesplit = _onesplit;
    }

    function setGovernance(address _governance) public {
        require(msg.sender == governance, '!governance');
        governance = _governance;
    }

    function setVault(address _token, address _vault) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        require(vaults[_token] == address(0), 'vault');
        vaults[_token] = _vault;
    }

    function approveStrategy(address _token, address _strategy) public {
        require(msg.sender == governance, '!governance');
        approvedStrategies[_token][_strategy] = true;
    }

    function revokeStrategy(address _token, address _strategy) public {
        require(msg.sender == governance, '!governance');
        approvedStrategies[_token][_strategy] = false;
    }

    function setConverter(
        address _input,
        address _output,
        address _converter
    ) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        converters[_input][_output] = _converter;
    }

    function setStrategy(address _token, address _strategy) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        require(approvedStrategies[_token][_strategy], '!approved');

        address _current = strategies[_token];
        if (_current != address(0)) {
            IStrategy(_current).withdrawAll();
        }
        strategies[_token] = _strategy;
    }

    function earn(address _token, uint256 _amount) public {
        address _strategy = strategies[_token];
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            address converter = converters[_token][_want];
            IERC20(_token).safeTransfer(converter, _amount);
            _amount = Converter(converter).convert(_strategy);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        IStrategy(_strategy).deposit();
    }

    function balanceOf(address _token) external view returns (uint256) {
        return IStrategy(strategies[_token]).balanceOf();
    }

    function withdrawAll(address _token) public {
        require(msg.sender == strategist || msg.sender == governance, '!strategist');
        IStrategy(strategies[_token]).withdrawAll();
    }

    function inCaseTokensGetStuck(address _token, uint256 _amount) public {
        require(msg.sender == strategist || msg.sender == governance, '!governance');
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {
        require(msg.sender == strategist || msg.sender == governance, '!governance');
        IStrategy(_strategy).withdraw(_token);
    }

    function getExpectedReturn(
        address _strategy,
        address _token,
        uint256 parts
    ) public view returns (uint256 expected) {
        uint256 _balance = IERC20(_token).balanceOf(_strategy);
        address _want = IStrategy(_strategy).want();
        (expected, ) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);
    }

    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield
    function yearn(
        address _strategy,
        address _token,
        uint256 parts
    ) public {
        require(msg.sender == strategist || msg.sender == governance, '!governance');
        // This contract should never have value in it, but just incase since this is a public call
        uint256 _before = IERC20(_token).balanceOf(address(this));
        IStrategy(_strategy).withdraw(_token);
        uint256 _after = IERC20(_token).balanceOf(address(this));
        if (_after > _before) {
            uint256 _amount = _after.sub(_before);
            address _want = IStrategy(_strategy).want();
            uint256[] memory _distribution;
            uint256 _expected;
            _before = IERC20(_want).balanceOf(address(this));
            IERC20(_token).safeApprove(onesplit, 0);
            IERC20(_token).safeApprove(onesplit, _amount);
            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);
            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);
            _after = IERC20(_want).balanceOf(address(this));
            if (_after > _before) {
                _amount = _after.sub(_before);
                uint256 _reward = _amount.mul(split).div(max);
                earn(_want, _amount.sub(_reward));
                IERC20(_want).safeTransfer(rewards, _reward);
            }
        }
    }

    function withdraw(address _token, uint256 _amount) public {
        require(msg.sender == vaults[_token], '!vault');
        IStrategy(strategies[_token]).withdraw(_amount);
    }
}",1671
RealWorld_TA_61_IProtocolDataProvider_RealWorld_20240808154525.log,61,IProtocolDataProvider,53124,1585,54709,68.0,0.29732,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;

import {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';

interface IProtocolDataProvider {
    struct TokenData {
        string symbol;
        address tokenAddress;
    }

    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);

    function getAllReservesTokens() external view returns (TokenData[] memory);

    function getAllATokens() external view returns (TokenData[] memory);

    function getReserveConfigurationData(address asset)
        external
        view
        returns (
            uint256 decimals,
            uint256 ltv,
            uint256 liquidationThreshold,
            uint256 liquidationBonus,
            uint256 reserveFactor,
            bool usageAsCollateralEnabled,
            bool borrowingEnabled,
            bool stableBorrowRateEnabled,
            bool isActive,
            bool isFrozen
        );

    function getReserveData(address asset)
        external
        view
        returns (
            uint256 availableLiquidity,
            uint256 totalStableDebt,
            uint256 totalVariableDebt,
            uint256 liquidityRate,
            uint256 variableBorrowRate,
            uint256 stableBorrowRate,
            uint256 averageStableBorrowRate,
            uint256 liquidityIndex,
            uint256 variableBorrowIndex,
            uint40 lastUpdateTimestamp
        );

    function getUserReserveData(address asset, address user)
        external
        view
        returns (
            uint256 currentATokenBalance,
            uint256 currentStableDebt,
            uint256 currentVariableDebt,
            uint256 principalStableDebt,
            uint256 scaledVariableDebt,
            uint256 stableBorrowRate,
            uint256 liquidityRate,
            uint40 stableRateLastUpdated,
            bool usageAsCollateralEnabled
        );

    function getReserveTokensAddresses(address asset)
        external
        view
        returns (
            address aTokenAddress,
            address stableDebtTokenAddress,
            address variableDebtTokenAddress
        );
}",434
RealWorld_TA_61_IStrategyRegistry_RealWorld_20240808151616.log,61,IStrategyRegistry,46808,1896,48704,76.0,0.27196,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IStrategyRegistry {
    /**
     * @notice emitted when a strategy is added to registry
     * @param strategy address of the stratgy added
     */
    event StrategyAdded(address indexed strategy);

    /**
     * @notice emitted when a strategy is removed to registry
     * @param strategy address of the stratgy removed
     */
    event StrategyRemoved(address indexed strategy);

    /**
     * @notice emitted when a maximum number of approved strategies is updated
     * @param maxStrategies updated number of maximum approved strategies
     */
    event MaxStrategiesUpdated(uint256 maxStrategies);

    function registry(address _strategy) external view returns (bool);

    function getStrategies() external view returns (address[] memory);

    /**
     * @dev Add strategies to invest in. Please ensure that number of strategies are less than maxStrategies.
     * @param _strategy address of the owner of the savings account contract
     **/
    function addStrategy(address _strategy) external;

    /**
     * @dev Remove strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     **/
    function removeStrategy(uint256 _strategyIndex) external;

    /**
     * @dev Update strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     * @param _oldStrategy Strategy that is to be removed
     * @param _newStrategy Updated strategy
     **/
    function updateStrategy(
        uint256 _strategyIndex,
        address _oldStrategy,
        address _newStrategy
    ) external;
}",341
RealWorld_TA_61_IScaledBalanceToken_RealWorld_20240808153800.log,61,IScaledBalanceToken,27644,1201,28845,66.0,0.16224,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;

interface IScaledBalanceToken {
    /**
     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the
     * updated stored balance divided by the reserve's liquidity index at the moment of the update
     * @param user The user whose balance is calculated
     * @return The scaled balance of the user
     **/
    function scaledBalanceOf(address user) external view returns (uint256);
}",111
RealWorld_TA_61_IPool_RealWorld_20240808151735.log,61,IPool,87180,2563,89743,94.0,0.48716,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

interface IPool {
    /**
     * @notice Emitted when pool is cancelled either on borrower request or insufficient funds collected
     */
    event PoolCancelled();

    /**
     * @notice Emitted when pool is terminated by admin
     */
    event PoolTerminated();

    /**
     * @notice Emitted when pool is closed after repayments are complete
     */
    event PoolClosed();

    /**
     * @notice emitted when borrower posts collateral
     * @param borrower address of the borrower
     * @param amount amount denominated in collateral asset
     * @param sharesReceived shares received after transferring collaterla to pool savings strategy
     */
    event CollateralAdded(address indexed borrower, uint256 amount, uint256 sharesReceived);

    /**
     * @notice emitted when borrower posts collateral after a margin call
     * @param borrower address of the borrower
     * @param lender lender who margin called
     * @param amount amount denominated in collateral asset
     * @param sharesReceived shares received after transferring collaterla to pool savings strategy
     */
    event MarginCallCollateralAdded(address indexed borrower, address indexed lender, uint256 amount, uint256 sharesReceived);

    /**
     * @notice emitted when borrower withdraws excess collateral
     * @param borrower address of borrower
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(address indexed borrower, uint256 amount);

    /**
     * @notice emitted when lender supplies liquidity to a pool
     * @param amountSupplied amount that was supplied
     * @param lenderAddress address of the lender. allows for delegation of lending
     */
    event LiquiditySupplied(uint256 amountSupplied, address indexed lenderAddress);

    /**
     * @notice emitted when borrower withdraws loan
     * @param amount tokens the borrower withdrew, taking into account the deducted protocol fee
     * @param protocolFee protocol fee deducted when borrower withdrew the amount 
     */
    event AmountBorrowed(uint256 amount, uint256 protocolFee);

    /**
     * @notice emitted when lender withdraws from borrow pool
     * @param amount amount that lender withdraws from borrow pool
     * @param lenderAddress address to which amount is withdrawn
     */
    event LiquidityWithdrawn(uint256 amount, address indexed lenderAddress);

    /**
     * @notice emitted when lender exercises a margin/collateral call
     * @param lenderAddress address of the lender who exercises margin calls
     */
    event MarginCalled(address indexed lenderAddress);

    /**
     * @notice emitted when collateral backing lender is liquidated because of a margin call
     * @param liquidator address that calls the liquidateForLender() function
     * @param lender lender who initially exercised the margin call
     * @param _tokenReceived amount received by liquidator denominated in collateral asset
     */
    event LenderLiquidated(address indexed liquidator, address indexed lender, uint256 _tokenReceived);

    /**
     * @notice emitted when a pool is liquidated for missing repayment
     * @param liquidator address of the liquidator
     */
    event PoolLiquidated(address indexed liquidator);

    function getLoanStatus() external view returns (uint256);

    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable;

    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _isDirect
    ) external payable;

    function withdrawBorrowedAmount() external;

    function borrower() external returns (address);

    function getMarginCallEndTime(address _lender) external returns (uint256);

    function getBalanceDetails(address _lender) external view returns (uint256, uint256);

    function totalSupply() external view returns (uint256);

    function closeLoan() external payable;
}",815
RealWorld_TA_61_Verification_RealWorld_20240808144656.log,61,Verification,182805,3816,186621,103.0,0.990345,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';

/// @title Contract that handles linking identity of user to address
contract Verification is Initializable, IVerification, OwnableUpgradeable {
    struct LinkedAddress {
        address masterAddress;
        uint256 activatesAt;
    }

    /// @notice Delay in seconds after which addresses are activated once registered or linked
    uint256 public activationDelay;

    /// @notice Tells whether a given verifier is valid
    /// @dev Mapping that stores valid verifiers as added by admin. verifier -> true/false
    /// @return boolean that represents if the specified verifier is valid
    mapping(address => bool) public verifiers;

    /// @notice Maps masterAddress with the verifier that was used to verify it and the time when master address is active
    /// @dev Mapping is from masterAddress -> verifier -> activationTime
    /// @return Verifier used to verify the given master address
    mapping(address => mapping(address => uint256)) public masterAddresses;

    /// @notice Maps linkedAddresses with the master address and activation time
    /// @dev Mapping is linkedAddress -> (MasterAddress, activationTimestamp)
    /// @return Returns the master address and activation time for the linkedAddress
    mapping(address => LinkedAddress) public linkedAddresses;

    /// @notice Maps address to link with the master addres
    /// @dev Mapping is linkedAddress -> MasterAddress -> isPending
    /// @return Returns if linkedAddress has a pending request from master address
    mapping(address => mapping(address => bool)) public pendingLinkAddresses;

    /// @notice Prevents anyone other than a valid verifier from calling a function
    modifier onlyVerifier() {
        require(verifiers[msg.sender], 'Invalid verifier');
        _;
    }

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _activationDelay Delay in seconds after which addresses are registered or linked
    function initialize(address _admin, uint256 _activationDelay) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateActivationDelay(_activationDelay);
    }

    /// @notice owner can update activation delay
    /// @param _activationDelay updated value of activation delay for registered/linking addresses in seconds
    function updateActivationDelay(uint256 _activationDelay) external onlyOwner {
        _updateActivationDelay(_activationDelay);
    }

    function _updateActivationDelay(uint256 _activationDelay) internal {
        activationDelay = _activationDelay;
        emit ActivationDelayUpdated(_activationDelay);
    }

    /// @notice owner can add new verifier
    /// @dev Verifier can add master address or remove addresses added by it
    /// @param _verifier Address of the verifier contract
    function addVerifier(address _verifier) external onlyOwner {
        require(_verifier != address(0), 'V:AV-Verifier cant be 0 address');
        require(!verifiers[_verifier], 'V:AV-Verifier exists');
        verifiers[_verifier] = true;
        emit VerifierAdded(_verifier);
    }

    /// @notice owner can remove exisiting verifier
    /// @dev Verifier can add master address or remove addresses added by it
    /// @param _verifier Address of the verifier contract
    function removeVerifier(address _verifier) external onlyOwner {
        require(verifiers[_verifier], 'V:AV-Verifier doesnt exist');
        delete verifiers[_verifier];
        emit VerifierRemoved(_verifier);
    }

    /// @notice Only verifier can add register master address
    /// @dev Multiple accounts can be linked to master address to act on behalf. Master address can be registered by multiple verifiers
    /// @param _masterAddress address which is registered as verified
    /// @param _isMasterLinked boolean which specifies if the masterAddress has to be added as a linked address
    ///                         _isMasterLinked is used to support users who want to keep the master address as a cold wallet for security
    function registerMasterAddress(address _masterAddress, bool _isMasterLinked) external override onlyVerifier {
        require(masterAddresses[_masterAddress][msg.sender] == 0, 'V:RMA-Already registered');
        uint256 _masterAddressActivatesAt = block.timestamp + activationDelay;
        masterAddresses[_masterAddress][msg.sender] = _masterAddressActivatesAt;
        emit UserRegistered(_masterAddress, msg.sender, _masterAddressActivatesAt);

        if (_isMasterLinked) {
            _linkAddress(_masterAddress, _masterAddress);
        }
    }

    /// @notice Master address can be unregistered by registered verifier or owner
    /// @dev unregistering master address doesn't affect linked addreses mapping to master address, though they would not be verified by this verifier anymore
    /// @param _masterAddress address which is being unregistered
    /// @param _verifier verifier address from which master address is unregistered
    function unregisterMasterAddress(address _masterAddress, address _verifier) external override {
        if (msg.sender != super.owner()) {
            require(masterAddresses[_masterAddress][msg.sender] != 0 && msg.sender == _verifier, 'V:UMA-Invalid verifier');
        }
        delete masterAddresses[_masterAddress][_verifier];
        emit UserUnregistered(_masterAddress, _verifier, msg.sender);
    }

    function _linkAddress(address _linked, address _master) internal {
        uint256 _linkedAddressActivatesAt = block.timestamp + activationDelay;
        linkedAddresses[_linked] = LinkedAddress(_master, _linkedAddressActivatesAt);
        emit AddressLinked(_linked, _master, _linkedAddressActivatesAt);
    }

    /// @notice Used by master address to request linking another address to it
    /// @dev only master address can initiate linking of another address
    /// @param _linkedAddress address which is to be linked
    function requestAddressLinking(address _linkedAddress) external {
        require(linkedAddresses[_linkedAddress].masterAddress == address(0), 'V:LA-Address already linked');
        pendingLinkAddresses[_linkedAddress][msg.sender] = true;
        emit AddressLinkingRequested(_linkedAddress, msg.sender);
    }

    /// @notice Used by master address to cancel request linking another address to it
    /// @param _linkedAddress address which is to be linked
    function cancelAddressLinkingRequest(address _linkedAddress) external {
        require(pendingLinkAddresses[_linkedAddress][msg.sender], 'V:CALR-No pending request');
        delete pendingLinkAddresses[_linkedAddress][msg.sender];
        emit AddressLinkingRequestCancelled(_linkedAddress, msg.sender);
    }

    /// @notice Link an address with a master address
    /// @dev Master address to which the address is being linked need not be verified
    ///     link address can only accept the request made by a master address, but can't initiate a linking request
    /// @param _masterAddress master address to link to
    function linkAddress(address _masterAddress) external {
        require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');
        require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');
        _linkAddress(msg.sender, _masterAddress);
    }

    /// @notice Unlink address with master address
    /// @dev a single address can be linked to only one master address
    /// @param _linkedAddress Address that is being unlinked
    function unlinkAddress(address _linkedAddress) external {
        address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;
        require(_linkedTo != address(0), 'V:UA-Address not linked');
        require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');
        delete linkedAddresses[_linkedAddress];
        emit AddressUnlinked(_linkedAddress, _linkedTo);
    }

    /// @notice User to verify if an address is linked to a master address that is registered with verifier
    /// @dev view function
    /// @param _user address which has to be checked if mapped against a verified master address
    /// @param _verifier verifier with which master address has to be verified
    /// @return if the user is linke dto a registered master address
    function isUser(address _user, address _verifier) external view override returns (bool) {
        LinkedAddress memory _linkedAddress = linkedAddresses[_user];
        uint256 _masterActivatesAt = masterAddresses[_linkedAddress.masterAddress][_verifier];
        if (
            _linkedAddress.masterAddress == address(0) ||
            _linkedAddress.activatesAt > block.timestamp ||
            _masterActivatesAt == 0 ||
            _masterActivatesAt > block.timestamp
        ) {
            return false;
        }
        return true;
    }
}",1944
RealWorld_TA_61_SavingsAccount_RealWorld_20240808144159.log,61,SavingsAccount,367211,6545,373756,154.0,1.966955,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IYield.sol';

/**
 * @title Savings account contract with Methods related to savings account
 * @notice Implements the functions related to savings account
 * @author Sublime
 **/
contract SavingsAccount is ISavingsAccount, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of the strategy registry used to whitelist strategies
     */
    address public strategyRegistry;

    /**
     * @notice address of the credit lines contract
     */
    address public creditLine;

    /**
     * @notice mapping from user to token to strategy to balance of shares
     * @dev user -> token -> strategy (underlying address) -> amount (shares)
     */
    mapping(address => mapping(address => mapping(address => uint256))) public override balanceInShares;

    /**
     * @notice mapping from user to token to toAddress for approval to amount approved
     * @dev user => token => to => amount
     */
    mapping(address => mapping(address => mapping(address => uint256))) public allowance;

    /**
     * @notice modifier to check if address is the credit line
     * @param _caller address to check if credit line
     */
    modifier onlyCreditLine(address _caller) {
        require(_caller == creditLine, 'Invalid caller');
        _;
    }

    /**
     * @dev initialize the contract
     * @param _owner address of the owner of the savings account contract
     * @param _strategyRegistry address of the strategy registry
     * @param _creditLine address of the credit line contract
     **/
    function initialize(
        address _owner,
        address _strategyRegistry,
        address _creditLine
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateCreditLine(_creditLine);
        _updateStrategyRegistry(_strategyRegistry);
    }

    /**
     * @notice used to update credit line contract address
     * @dev only owner can update
     * @param _creditLine updated address of credit lines
     */
    function updateCreditLine(address _creditLine) external onlyOwner {
        _updateCreditLine(_creditLine);
    }

    function _updateCreditLine(address _creditLine) internal {
        require(_creditLine != address(0), 'SavingsAccount::initialize zero address');
        creditLine = _creditLine;
        emit CreditLineUpdated(_creditLine);
    }

    /**
     * @notice used to update strategy registry address
     * @dev only owner can update
     * @param _strategyRegistry updated address of strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'SavingsAccount::updateStrategyRegistry zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to deposit tokens into strategy via savings account
     * @dev if token is address(0), then it is Ether
     * @param _amount amount of tokens deposited
     * @param _token address of token contract
     * @param _strategy address of the strategy into which tokens are to be deposited
     * @param _to address to deposit to
     */
    function deposit(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external payable override nonReentrant returns (uint256) {
        require(_to != address(0), 'SavingsAccount::deposit receiver address should not be zero address');
        uint256 _sharesReceived = _deposit(_amount, _token, _strategy);
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_sharesReceived);
        emit Deposited(_to, _sharesReceived, _token, _strategy);
        return _sharesReceived;
    }

    function _deposit(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(_amount != 0, 'SavingsAccount::_deposit Amount must be greater than zero');
        _sharesReceived = _depositToYield(_amount, _token, _strategy);
    }

    function _depositToYield(
        uint256 _amount,
        address _token,
        address _strategy
    ) internal returns (uint256 _sharesReceived) {
        require(IStrategyRegistry(strategyRegistry).registry(_strategy), 'SavingsAccount::deposit strategy do not exist');
        uint256 _ethValue;

        if (_token == address(0)) {
            _ethValue = _amount;
            require(msg.value == _amount, 'SavingsAccount::deposit ETH sent must be equal to amount');
        }
        _sharesReceived = IYield(_strategy).lockTokens{value: _ethValue}(msg.sender, _token, _amount);
    }

    /**
     * @dev Used to switch saving strategy of an _token
     * @param _currentStrategy initial strategy of token
     * @param _newStrategy new strategy to invest
     * @param _token address of the token
     * @param _amount amount of tokens to be reinvested
     */
    function switchStrategy(
        uint256 _amount,
        address _token,
        address _currentStrategy,
        address _newStrategy
    ) external override nonReentrant {
        require(_currentStrategy != _newStrategy, 'SavingsAccount::switchStrategy Same strategy');
        require(IStrategyRegistry(strategyRegistry).registry(_newStrategy), 'SavingsAccount::_newStrategy do not exist');
        require(_amount != 0, 'SavingsAccount::switchStrategy Amount must be greater than zero');

        _amount = IYield(_currentStrategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_currentStrategy] = balanceInShares[msg.sender][_token][_currentStrategy].sub(
            _amount,
            'SavingsAccount::switchStrategy Insufficient balance'
        );

        uint256 _tokensReceived = IYield(_currentStrategy).unlockTokens(_token, _amount);

        uint256 _ethValue;
        if (_token != address(0)) {
            IERC20(_token).safeApprove(_newStrategy, _tokensReceived);
        } else {
            _ethValue = _tokensReceived;
        }
        _amount = _tokensReceived;
        
        uint256 _sharesReceived = IYield(_newStrategy).lockTokens{value: _ethValue}(address(this), _token, _tokensReceived);

        balanceInShares[msg.sender][_token][_newStrategy] = balanceInShares[msg.sender][_token][_newStrategy].add(_sharesReceived);
        emit StrategySwitched(msg.sender, _token, _amount, _sharesReceived, _currentStrategy, _newStrategy);
    }

    /**
     * @dev Used to withdraw token from Saving Account
     * @param _to address to which token should be sent
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */
    function withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdraw Amount must be greater than zero');

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdraw Insufficient amount'
        );

        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);

        emit Withdrawn(msg.sender, _to, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    /**
     * @dev Used to withdraw token from allowance of Saving Account
     * @param _from address from which tokens will be withdrawn
     * @param _to address to which token should be withdrawn
     * @param _amount amount of tokens to withdraw
     * @param _token address of the token to be withdrawn
     * @param _strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param _withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */

    function withdrawFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address payable _to,
        bool _withdrawShares
    ) external override nonReentrant returns (uint256) {
        require(_amount != 0, 'SavingsAccount::withdrawFrom Amount must be greater than zero');

        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::withdrawFrom allowance limit exceeding'
        );

        _amount = IYield(_strategy).getSharesForTokens(_amount, _token);

        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::withdrawFrom insufficient balance'
        );
        (address _receivedToken, uint256 _amountReceived) = _withdraw(_amount, _token, _strategy, _to, _withdrawShares);
        emit Withdrawn(_from, msg.sender, _amount, _token, _strategy, _withdrawShares);
        return _amountReceived;
    }

    function _withdraw(
        uint256 _amount,
        address _token,
        address _strategy,
        address payable _to,
        bool _withdrawShares
    ) internal returns (address _tokenReceived, uint256 _amountReceived) {
        if (_withdrawShares) {
            _tokenReceived = IYield(_strategy).liquidityToken(_token);
            require(_tokenReceived != address(0), 'Liquidity Tokens address cannot be address(0)');
            _amountReceived = IYield(_strategy).unlockShares(_tokenReceived, _amount);
        } else {
            _tokenReceived = _token;
            _amountReceived = IYield(_strategy).unlockTokens(_token, _amount);
        }
        _transfer(_amountReceived, _tokenReceived, _to);
    }

    function _transfer(
        uint256 _amount,
        address _token,
        address payable _to
    ) internal {
        if (_token == address(0)) {
            (bool _success, ) = _to.call{value: _amount}('');
            require(_success, 'Transfer failed');
        } else {
            IERC20(_token).safeTransfer(_to, _amount);
        }
    }

    /**
     * @notice used to withdraw a token from all strategies
     * @param _token address of token which is to be withdrawn
     */
    function withdrawAll(address _token) external override nonReentrant returns (uint256 _tokenReceived) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            if (balanceInShares[msg.sender][_token][_strategyList[i]] != 0 && _strategyList[i] != address(0)) {
                uint256 _amount = balanceInShares[msg.sender][_token][_strategyList[i]];
                _amount = IYield(_strategyList[i]).unlockTokens(_token, balanceInShares[msg.sender][_token][_strategyList[i]]);
                _tokenReceived = _tokenReceived.add(_amount);
                delete balanceInShares[msg.sender][_token][_strategyList[i]];
            }
        }

        if (_tokenReceived == 0) return 0;

        _transfer(_tokenReceived, _token, payable(msg.sender));

        emit WithdrawnAll(msg.sender, _tokenReceived, _token);
    }

    function withdrawAll(address _token, address _strategy) external override nonReentrant returns (uint256 _tokenReceived) {
        uint256 _sharesBalance = balanceInShares[msg.sender][_token][_strategy];

        if(_sharesBalance == 0) return 0;

        uint256 _amount = IYield(_strategy).unlockTokens(_token, _sharesBalance);

        delete balanceInShares[msg.sender][_token][_strategy];

        _transfer(_amount, _token, payable(msg.sender));

        emit Withdrawn(msg.sender, msg.sender, _amount, _token, _strategy, false);
    }

    /**
     * @notice used to approve allowance to an address
     * @dev this is prone to race condition, hence increaseAllowance is recommended
     * @param _amount amount of tokens approved
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function approve(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        allowance[msg.sender][_token][_to] = _amount;

        emit Approved(_token, msg.sender, _to, _amount);
    }

    /**
     * @notice used to increase allowance to an address
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _to address of the address approved to
     */
    function increaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].add(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used to decrease allowance to an address
     * @param _amount amount of tokens allowance is decreased by
     * @param _token address of token approved
     * @param _to address of the user approved to
     */
    function decreaseAllowance(
        uint256 _amount,
        address _token,
        address _to
    ) external override {
        uint256 _updatedAllowance = allowance[msg.sender][_token][_to].sub(_amount);
        allowance[msg.sender][_token][_to] = _updatedAllowance;

        emit Approved(_token, msg.sender, _to, _updatedAllowance);
    }

    /**
     * @notice used by credit lines to replenish the allowance once the credit line pricinpal is repaid
     * @param _amount amount of tokens allowance is increased by
     * @param _token address of token approved
     * @param _from address of the lender of the credit line which is being replenished
     */
    function increaseAllowanceToCreditLine(
        uint256 _amount,
        address _token,
        address _from
    ) external override onlyCreditLine(msg.sender) {
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].add(_amount);

        emit CreditLineAllowanceRefreshed(_token, _from, msg.sender, _amount);
    }

    /**
     * @notice used to transfer tokens
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transfer(
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transfer zero amount');

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        balanceInShares[msg.sender][_token][_strategy] = balanceInShares[msg.sender][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transfer insufficient funds'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = balanceInShares[_to][_token][_strategy].add(_amount);

        emit Transfer(_token, _strategy, msg.sender, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to transfer tokens from allowance by another address
     * @param _amount amount of tokens transferred
     * @param _token address of token transferred
     * @param _strategy address of the strategy from which tokens are transferred
     * @param _from address from whose allowance tokens are transferred
     * @param _to address of the user tokens are transferred to
     */
    function transferFrom(
        uint256 _amount,
        address _token,
        address _strategy,
        address _from,
        address _to
    ) external override returns (uint256) {
        require(_amount != 0, 'SavingsAccount::transferFrom zero amount');
        //update allowance
        allowance[_from][_token][msg.sender] = allowance[_from][_token][msg.sender].sub(
            _amount,
            'SavingsAccount::transferFrom allowance limit exceeding'
        );

        if (_strategy != address(0)) {
            _amount = IYield(_strategy).getSharesForTokens(_amount, _token);
        }

        //reduce sender's balance
        balanceInShares[_from][_token][_strategy] = balanceInShares[_from][_token][_strategy].sub(
            _amount,
            'SavingsAccount::transferFrom insufficient allowance'
        );

        //update receiver's balance
        balanceInShares[_to][_token][_strategy] = (balanceInShares[_to][_token][_strategy]).add(_amount);

        emit Transfer(_token, _strategy, _from, _to, _amount);

        return _amount;
    }

    /**
     * @notice used to query total tokens of a token with a user
     * @param _user address of the user
     * @param _token address of token
     * @return _totalTokens total number of tokens of the token with the user
     */
    function getTotalTokens(address _user, address _token) external override returns (uint256 _totalTokens) {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();

        for (uint256 i = 0; i < _strategyList.length; i++) {
            uint256 _liquidityShares = balanceInShares[_user][_token][_strategyList[i]];

            if (_liquidityShares != 0) {
                uint256 _tokenInStrategy = _liquidityShares;
                if (_strategyList[i] != address(0)) {
                    _tokenInStrategy = IYield(_strategyList[i]).getTokensForShares(_liquidityShares, _token);
                }

                _totalTokens = _totalTokens.add(_tokenInStrategy);
            }
        }
    }

    receive() external payable {}
}",4178
RealWorld_TA_61_AaveLendingPool_RealWorld_20240808154248.log,61,AaveLendingPool,33730,1241,34971,71.0,0.19347,"// SPDX-License-Identifier: agpl-3.0
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;

import './DataTypes.sol';
import './ILendingPoolAddressesProvider.sol';

interface AaveLendingPool {
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    /**
     * @dev Returns the state and configuration of the reserve
     * @param asset The address of the underlying asset of the reserve
     * @return The state of the reserve
     **/
    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);

    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);
}",185
RealWorld_TA_61_IVerifier_RealWorld_20240808151911.log,61,IVerifier,29201,1159,30360,183.0,0.169185,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IVerifier {
    /**
     * @notice emitted when a user is registered
     * @param user address of user registered
     * @param isMasterLinked if true, master address is also considered to be linked to itself
     * @param metadata any metadata related to registered user
     */
    event UserRegistered(address user, bool isMasterLinked, string metadata);

    /**
     * @notice emitted when a user is unregistered
     * @param user address of the user unregistered
     */
    event UserUnregistered(address user);
}",130
RealWorld_TA_61_IExtension_RealWorld_20240808152216.log,61,IExtension,47358,1431,48789,70.0,0.26541,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IExtension {
    /**
     * @notice emitted when the Voting Pass Ratio parameter for Pools is updated
     * @param votingPassRatio the new value of the voting pass threshold for  Pools
     */
    event VotingPassRatioUpdated(uint256 votingPassRatio);

    /**
     * @notice emitted when the pool factory is updated in extension
     * @param poolFactory updated address of pool factory
     */
    event PoolFactoryUpdated(address indexed poolFactory);

    /**
     * @notice emitted when an extension is requested by a borrower for Pools
     * @param extensionVoteEndTime the value of the vote end time for the requested extension
     */
    event ExtensionRequested(uint256 extensionVoteEndTime);

    /**
     * @notice emitted when the requested extension for Pools is approved
     * @param poolID the address of the pool for which extension passed
     */
    event ExtensionPassed(address poolID);

    /**
     * @notice emitted when the lender for Pools has voted on extension request
     * @param lender address of the lender who voted
     * @param totalExtensionSupport the value of the total extension support for the Pools
     * @param lastVoteTime the last time the lender has voted on an extension request
     */
    event LenderVoted(address indexed lender, uint256 totalExtensionSupport, uint256 lastVoteTime);

    function initializePoolExtension(uint256 _repaymentInterval) external;

    function closePoolExtension() external;

    function removeVotes(
        address _from,
        address _to,
        uint256 _amount
    ) external;
}",347
RealWorld_TA_61_PoolFactory_RealWorld_20240808150333.log,61,PoolFactory,530391,5600,535991,170.0,2.763955,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '../Proxy.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IStrategyRegistry.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/IPriceOracle.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';

/**
 * @title Pool Factory contract with methods for handling different pools
 * @notice Implements the functions related to Pool (CRUD)
 * @author Sublime
 */
contract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {
    /*
     * @notice Used to define limits for the Pool parameters
     * @param min the minimum threshold for the parameter
     * @param max the maximum threshold for the parameter
     */
    struct Limits {
        uint256 min;
        uint256 max;
    }

    /**
     * @notice function definition of the pool contract
     */
    bytes4 public poolInitFuncSelector; //  bytes4(keccak256(""initialize(uint256,address,address,address,uint256,uint256,uint256,uint256,bool)""))

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public poolImpl;

    /**
     * @notice address of the contract storing the user registry
     */
    address public override userRegistry;

    /**
     * @notice address of the contract storing the strategy registry
     */
    address public strategyRegistry;

    /**
     * @notice address of the latest implementation of the extension logic
     */
    address public override extension;

    /**
     * @notice address of the latest implementation of the repayment logic
     */
    address public override repaymentImpl;

    /**
     * @notice address of the latest implementation of the pool logic
     */
    address public override priceOracle;

    /**
     * @notice address of the savings account used
     */
    address public override savingsAccount;

    /**
     * @notice the time interval for the lenders to make contributions to pool
     */
    uint256 public override collectionPeriod;

    /**
     * @notice the time interval for the borrower to withdraw the loan from pool
     */
    uint256 public override loanWithdrawalDuration;

    /**
     * @notice the time interval for the active stage of the margin call
     */
    uint256 public override marginCallDuration;

    /**
     * @notice Fraction of the requested amount for pool below which pool is cancelled
     */
    uint256 public override minBorrowFraction;

    /**
     * @notice the fraction used for calculating the liquidator reward
     */
    uint256 public override liquidatorRewardFraction;

    /**
     * @notice the fraction used for calculating the penalty when the pool is cancelled
     */
    uint256 public override poolCancelPenaltyMultiple;

    /**
     * @notice Contract Address of no yield
     */
    address public override noStrategyAddress;

    uint256 protocolFeeFraction;
    address protocolFeeCollector;

    /*
     * @notice Used to mark assets supported for borrowing
     */
    mapping(address => bool) isBorrowToken;

    /*
     * @notice Used to mark supported collateral assets
     */
    mapping(address => bool) isCollateralToken;

    /**
     * @notice Used to keep track of valid pool addresses
     */
    mapping(address => bool) public override poolRegistry;

    /*
     * @notice Used to set the min/max borrow amount for Pools
     */
    Limits poolSizeLimit;

    /*
     * @notice Used to set the min/max collateral ratio for Pools
     */
    Limits idealCollateralRatioLimit;

    /*
     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools
     */
    Limits borrowRateLimit;

    /*
     * @notice used to set the min/max repayment interval for Pools
     */
    Limits repaymentIntervalLimit;

    /*
     * @notice used to set the min/max number of repayment intervals for Pools
     */
    Limits noOfRepaymentIntervalsLimit;

    /**
     * @notice functions affected by this modifier can only be invoked by the Pool
     */
    modifier onlyPool() {
        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');
        _;
    }

    /**
     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool
     */
    modifier onlyBorrower(address _verifier) {
        require(
            IVerification(userRegistry).isUser(msg.sender, _verifier),
            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'
        );
        _;
    }

    /**
     * @notice returns the owner of the pool
     */
    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {
        return OwnableUpgradeable.owner();
    }

    /**
     * @notice used to initialize the pool factory
     * @dev initializer can only be run once
     * @param _admin address of admin
     * @param _collectionPeriod period for which lenders can lend for pool
     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts
     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained
     * @param _poolInitFuncSelector function signature for initializing pool
     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by 10**30
     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by 10**30
     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by 10**30
     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee
     * @param _protocolFeeCollector address where protocol fee is collected
     * @param _noStrategy address of the no strategy address
     */
    function initialize(
        address _admin,
        uint256 _collectionPeriod,
        uint256 _loanWithdrawalDuration,
        uint256 _marginCallDuration,
        bytes4 _poolInitFuncSelector,
        uint256 _liquidatorRewardFraction,
        uint256 _poolCancelPenaltyMultiple,
        uint256 _minBorrowFraction,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        address _noStrategy
    ) external initializer {
        {
            OwnableUpgradeable.__Ownable_init();
            OwnableUpgradeable.transferOwnership(_admin);
        }
        _updateCollectionPeriod(_collectionPeriod);
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
        _updateMarginCallDuration(_marginCallDuration);
        _updatepoolInitFuncSelector(_poolInitFuncSelector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
        _updateMinBorrowFraction(_minBorrowFraction);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateNoStrategy(_noStrategy);
    }

    /**
     * @notice used to setImplementation addresses
     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke
     * @param _poolImpl address of the implementation address of pool
     * @param _repaymentImpl address of the implementation address of repayments
     * @param _userRegistry address of the user registry where users are verified
     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted
     * @param _priceOracle address of the price oracle
     * @param _savingsAccount address of the savings account contract
     * @param _extension address of the extension contract for pools
     */
    function setImplementations(
        address _poolImpl,
        address _repaymentImpl,
        address _userRegistry,
        address _strategyRegistry,
        address _priceOracle,
        address _savingsAccount,
        address _extension
    ) external onlyOwner {
        _updatePoolLogic(_poolImpl);
        _updateRepaymentImpl(_repaymentImpl);
        _updateSavingsAccount(_savingsAccount);
        _updatedExtension(_extension);
        _updateUserRegistry(_userRegistry);
        _updateStrategyRegistry(_strategyRegistry);
        _updatePriceoracle(_priceOracle);
    }

    /**
     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request
     * @param _poolSize loan amount requested
     * @param _borrowToken borrow asset requested
     * @param _collateralToken collateral asset requested
     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower
     * @param _borrowRate interest rate provided by the borrower
     * @param _repaymentInterval interval between the last dates of two repayment cycles
     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan
     * @param _poolSavingsStrategy savings strategy selected for the pool collateral
     * @param _collateralAmount collateral amount deposited
     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet
     * @param _salt random and unique initial seed
     */
    function createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _verifier,
        address _lenderVerifier
    ) external payable onlyBorrower(_verifier) {
        if (_collateralToken == address(0)) {
            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');
        }
        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');
        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');
        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');
        require(
            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),
            ""PoolFactory::createPool - Price feed doesn't support token pair""
        );
        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');
        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');
        require(
            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),
            'PoolFactory::createPool - Collateral Ratio not within limits'
        );
        require(
            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),
            'PoolFactory::createPool - Borrow rate not within limits'
        );
        require(
            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),
            'PoolFactory::createPool - Loan duration not within limits'
        );
        require(
            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),
            'PoolFactory::createPool - Repayment interval not within limits'
        );
        _createPool(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _salt,
            _lenderVerifier
        );
    }

    // @dev These functions are used to avoid stack too deep
    function _createPool(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        bytes32 _salt,
        address _lenderVerifier
    ) internal {
        bytes memory data = _encodePoolInitCall(
            _poolSize,
            _borrowRate,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier
        );
        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));
        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));
        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;

        address pool = _deploy(amount, salt, bytecode);

        poolRegistry[pool] = true;
        emit PoolCreated(pool, msg.sender);
    }

    // @dev These functions are used to avoid stack too deep
    function _encodePoolInitCall(
        uint256 _poolSize,
        uint256 _borrowRate,
        address _borrowToken,
        address _collateralToken,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier
    ) internal view returns (bytes memory data) {
        data = abi.encodeWithSelector(
            poolInitFuncSelector,
            _poolSize,
            _borrowRate,
            msg.sender,
            _borrowToken,
            _collateralToken,
            _idealCollateralRatio,
            _repaymentInterval,
            _noOfRepaymentIntervals,
            _poolSavingsStrategy,
            _collateralAmount,
            _transferFromSavingsAccount,
            _lenderVerifier,
            loanWithdrawalDuration,
            collectionPeriod
        );
    }

    /**
     * @dev Deploys a contract using `CREATE2`. The address where the contract
     * will be deployed can be known in advance via {computeAddress}.
     *
     * The bytecode for a contract can be obtained from Solidity with
     * `type(contractName).creationCode`.
     *
     * Requirements:
     *
     * - `bytecode` must not be empty.
     * - `salt` must have not been used for `bytecode` already.
     * - the factory must have a balance of at least `amount`.
     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.
     */
    function _deploy(
        uint256 amount,
        bytes32 salt,
        bytes memory bytecode
    ) internal returns (address addr) {
        require(bytecode.length != 0, 'Create2: bytecode length is zero');
        // solhint-disable-next-line no-inline-assembly
        assembly {
            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)
        }
        require(addr != address(0), 'Create2: Failed on deploy');
    }

    /**
     * @notice invoked to check if pool parameters are within thresholds
     * @param _value supplied value of the parameter
     * @param _min minimum threshold of the parameter
     * @param _max maximum threshold of the parameter
     */
    function isWithinLimits(
        uint256 _value,
        uint256 _min,
        uint256 _max
    ) internal pure returns (bool) {
        if (_min != 0 && _max != 0) {
            return (_value >= _min && _value <= _max);
        } else if (_min != 0) {
            return (_value >= _min);
        } else if (_max != 0) {
            return (_value <= _max);
        } else {
            return true;
        }
    }

    /**
     * @notice used to update the list of supported borrow tokens
     * @param _borrowToken address of the borrow asset
     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset
     */
    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {
        _updateSupportedBorrowTokens(_borrowToken, _isSupported);
    }

    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {
        isBorrowToken[_borrowToken] = _isSupported;
        emit BorrowTokenUpdated(_borrowToken, _isSupported);
    }

    /**
     * @notice used to update the list of supported Collateral tokens
     * @param _collateralToken address of the Collateral asset
     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset
     */
    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {
        _updateSupportedCollateralTokens(_collateralToken, _isSupported);
    }

    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {
        isCollateralToken[_collateralToken] = _isSupported;
        emit CollateralTokenUpdated(_collateralToken, _isSupported);
    }

    /**
     * @notice used to update the pointer to Initializer function of the proxy pool contract
     * @param _functionId updated function definition of the proxy pool contract
     */
    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {
        _updatepoolInitFuncSelector(_functionId);
    }

    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {
        poolInitFuncSelector = _functionId;
        emit PoolInitSelectorUpdated(_functionId);
    }

    /**
     * @notice used to update the Pool.sol logic
     * @param _poolLogic the address of the new Pool logic contract
     */
    function updatePoolLogic(address _poolLogic) external onlyOwner {
        _updatePoolLogic(_poolLogic);
    }

    function _updatePoolLogic(address _poolLogic) internal {
        poolImpl = _poolLogic;
        emit PoolLogicUpdated(_poolLogic);
    }

    /**
     * @notice used to update the user registry
     * @param _userRegistry address of the contract storing the user registry
     */
    function updateUserRegistry(address _userRegistry) external onlyOwner {
        _updateUserRegistry(_userRegistry);
    }

    function _updateUserRegistry(address _userRegistry) internal {
        userRegistry = _userRegistry;
        emit UserRegistryUpdated(_userRegistry);
    }

    /**
     * @notice used to update the strategy registry
     * @param _strategyRegistry address of the contract storing the strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the implementation of the repayment logic
     * @param _repaymentImpl address of the updated repayment.sol contract
     */
    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {
        _updateRepaymentImpl(_repaymentImpl);
    }

    function _updateRepaymentImpl(address _repaymentImpl) internal {
        repaymentImpl = _repaymentImpl;
        emit RepaymentImplUpdated(_repaymentImpl);
    }

    /**
     * @notice used to update contract address of nostrategy contract
     * @param _noStrategy address of the updated noYield.sol contract
     */
    function updateNoStrategy(address _noStrategy) external onlyOwner {
        _updateNoStrategy(_noStrategy);
    }

    function _updateNoStrategy(address _noStrategy) internal {
        noStrategyAddress = _noStrategy;
        emit NoStrategyUpdated(_noStrategy);
    }

    /**
     * @notice used to update the implementation of the price oracle logic
     * @param _priceOracle address of the updated price oracle contract
     */
    function updatePriceoracle(address _priceOracle) external onlyOwner {
        _updatePriceoracle(_priceOracle);
    }

    function _updatePriceoracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the extensions contract
     * @param _extension address of the updated extensions contract
     */
    function updatedExtension(address _extension) external onlyOwner {
        _updatedExtension(_extension);
    }

    function _updatedExtension(address _extension) internal {
        extension = _extension;
        emit ExtensionImplUpdated(_extension);
    }

    /**
     * @notice used to update the savings account contract
     * @param _savingsAccount address of the updated savings account contract
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the collection period of the Pool
     * @param _collectionPeriod updated value of the collection period
     */
    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {
        _updateCollectionPeriod(_collectionPeriod);
    }

    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {
        collectionPeriod = _collectionPeriod;
        emit CollectionPeriodUpdated(_collectionPeriod);
    }

    /**
     * @notice used to update the loan withdrawal duration by owner
     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration
     */
    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {
        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);
    }

    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {
        loanWithdrawalDuration = _loanWithdrawalDuration;
        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);
    }

    /**
     * @notice used to update the active stage of the margin call of the Pool
     * @param _marginCallDuration updated value of the margin call duration
     */
    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {
        _updateMarginCallDuration(_marginCallDuration);
    }

    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {
        marginCallDuration = _marginCallDuration;
        emit MarginCallDurationUpdated(_marginCallDuration);
    }

    /**
     * @notice used to update the min borrow fraction by owner
     * @param _minBorrowFraction updated value of min borrow fraction multiplied by 10**30
     */
    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {
        _updateMinBorrowFraction(_minBorrowFraction);
    }

    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {
        minBorrowFraction = _minBorrowFraction;
        emit MinBorrowFractionUpdated(_minBorrowFraction);
    }

    /**
     * @notice used to update the reward fraction for liquidation of the Pool
     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by 10**30
     */
    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {
        liquidatorRewardFraction = _liquidatorRewardFraction;
        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the pool cancel penalty multiple
     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by 10**30
     */
    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {
        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);
    }

    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {
        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;
        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);
    }

    /**
     * @notice used to update the fraction of borrowed amount charged as protocol fee
     * @param _protocolFee updated value of protocol fee fraction multiplied by 10**30
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the address in which protocol fee is collected
     * @param _protocolFeeCollector updated address of protocol fee collector
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the thresholds of the pool size of the Pool
     * @param _min updated value of the minimum threshold value of the pool size
     * @param _max updated value of the maximum threshold value of the pool size
     */
    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {
        poolSizeLimit = Limits(_min, _max);
        emit LimitsUpdated('PoolSize', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the collateral ratio of the Pool
     * @param _min updated value of the minimum threshold value of the collateral ratio
     * @param _max updated value of the maximum threshold value of the collateral ratio
     */
    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {
        idealCollateralRatioLimit = Limits(_min, _max);
        emit LimitsUpdated('CollateralRatio', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the borrow rate of the Pool
     * @param _min updated value of the minimum threshold value of the borrow rate
     * @param _max updated value of the maximum threshold value of the borrow rate
     */
    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {
        borrowRateLimit = Limits(_min, _max);
        emit LimitsUpdated('BorrowRate', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the repayment interval of the Pool
     * @param _min updated value of the minimum threshold value of the repayment interval
     * @param _max updated value of the maximum threshold value of the repayment interval
     */
    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {
        repaymentIntervalLimit = Limits(_min, _max);
        emit LimitsUpdated('RepaymentInterval', _min, _max);
    }

    /**
     * @notice used to update the thresholds of the number of repayment intervals of the Pool
     * @param _min updated value of the minimum threshold value of the number of repayment intervals
     * @param _max updated value of the maximum threshold value of the number of repayment intervals
     */
    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {
        noOfRepaymentIntervalsLimit = Limits(_min, _max);
        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);
    }

    /**
     * @notice used to query protocol fee fraction and address of the collector
     * @return protocolFee Fraction multiplied by 10**30
     * @return address of protocol fee collector
     */
    function getProtocolFeeData() external view override returns (uint256, address) {
        return (protocolFeeFraction, protocolFeeCollector);
    }
}",6187
RealWorld_TA_61_AaveYield_RealWorld_20240808145006.log,61,AaveYield,250338,4880,255218,125.0,1.34929,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/IWETHGateway.sol';
import '../interfaces/Invest/AaveLendingPool.sol';
import '../interfaces/Invest/IScaledBalanceToken.sol';
import '../interfaces/Invest/IProtocolDataProvider.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into Aave protocol
 * @author Sublime
 **/
contract AaveYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice address of wethGateway used to deposit ETH to aave
     */
    address public wethGateway;

    /**
     * @notice address of protocolDataProvider which provides info about aTokens related to any token
     */
    address public protocolDataProvider;

    /**
     * @notice address of lendingPoolAddressesProvider used to get the pool related to any token
     */
    address public lendingPoolAddressesProvider;

    /**
     * @notice address of savings account contract
     */
    address payable public savingsAccount;

    /**
     * @notice aave referral code to represent sublime
     */
    uint16 public referralCode;

    /**
     * @notice emitted when aave protocol related addresses are updated
     * @param wethGateway address of wethGateway
     * @param protocolDataProvider address of protocol data provider
     * @param lendingPoolAddressesProvider address of lending pool addresses provider
     */
    event AaveAddressesUpdated(
        address indexed wethGateway,
        address indexed protocolDataProvider,
        address indexed lendingPoolAddressesProvider
    );

    /**
     * @notice emitted when aave referral code is updated
     * @param referralCode updated referral code
     */
    event ReferralCodeUpdated(uint16 referralCode);

    /**
     * @notice verifies if savings account invoked the contract
     */
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice To initialize the contract addresses interacting with this contract
     * @dev can only be initialized once
     * @param _owner address of owner
     * @param _savingsAccount address of the savings account contract
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider the address of ProtocolDataProvider
     * @param _lendingPoolAddressesProvider the address of LendingPoolAddressesProvider
     **/
    function initialize(
        address _owner,
        address payable _savingsAccount,
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return aToken address of liquidity token
     **/
    function liquidityToken(address asset) public view override returns (address aToken) {
        if (asset == address(0)) {
            aToken = IWETHGateway(wethGateway).getAWETHAddress();
        } else {
            (aToken, , ) = IProtocolDataProvider(protocolDataProvider).getReserveTokensAddresses(asset);
        }
    }

    /**
     * @notice used to update savings account address
     * @dev only owner can update
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update aave protocol related addresses
     * @dev only owner can update
     * @param _wethGateway address of wethGateway
     * @param _protocolDataProvider address of protocol data provider
     * @param _lendingPoolAddressesProvider address of lending pool addresses provider
     */
    function updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) external onlyOwner {
        _updateAaveAddresses(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    function _updateAaveAddresses(
        address _wethGateway,
        address _protocolDataProvider,
        address _lendingPoolAddressesProvider
    ) internal {
        require(_wethGateway != address(0), 'Invest: WETHGateway:: zero address');
        require(_protocolDataProvider != address(0), 'Invest: protocolDataProvider:: zero address');
        require(_lendingPoolAddressesProvider != address(0), 'Invest: lendingPoolAddressesProvider:: zero address');
        wethGateway = _wethGateway;
        protocolDataProvider = _protocolDataProvider;
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        emit AaveAddressesUpdated(_wethGateway, _protocolDataProvider, _lendingPoolAddressesProvider);
    }

    /**
     * @notice used to update referral code
     * @dev only owner can update
     * @param _referralCode updated referral code
     */
    function updateReferralCode(uint16 _referralCode) external onlyOwner {
        referralCode = _referralCode;
        emit ReferralCodeUpdated(_referralCode);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(liquidityToken(_asset)).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');

        address investedTo;
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            (investedTo, sharesReceived) = _depositETH(amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            (investedTo, sharesReceived) = _depositERC20(asset, amount);
        }

        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');

        if (asset == address(0)) {
            received = _withdrawETH(amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @notice Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {
        if (shares == 0) return 0;
        address aToken = liquidityToken(asset);

        (, , , , , , , uint256 liquidityIndex, , ) = IProtocolDataProvider(protocolDataProvider).getReserveData(asset);

        amount = IScaledBalanceToken(aToken).scaledBalanceOf(address(this)).mul(liquidityIndex).mul(shares).div(
            IERC20(aToken).balanceOf(address(this))
        );
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external view override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = IWETHGateway(wethGateway).getAWETHAddress();

        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //lock collateral
        IWETHGateway(wethGateway).depositETH{value: amount}(lendingPool, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _depositERC20(address asset, uint256 amount) internal returns (address aToken, uint256 sharesReceived) {
        aToken = liquidityToken(asset);
        uint256 aTokensBefore = IERC20(aToken).balanceOf(address(this));

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        //approve collateral to vault
        IERC20(asset).approve(lendingPool, 0);
        IERC20(asset).approve(lendingPool, amount);

        //lock collateral in vault
        AaveLendingPool(lendingPool).deposit(asset, amount, address(this), referralCode);

        sharesReceived = IERC20(aToken).balanceOf(address(this)).sub(aTokensBefore);
    }

    function _withdrawETH(uint256 amount) internal returns (uint256 received) {
        IERC20(IWETHGateway(wethGateway).getAWETHAddress()).approve(wethGateway, amount);

        uint256 ethBalance = address(this).balance;

        //lock collateral
        IWETHGateway(wethGateway).withdrawETH(amount, address(this));

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(address asset, uint256 amount) internal returns (uint256 tokensReceived) {
        address aToken = liquidityToken(asset);

        address lendingPool = ILendingPoolAddressesProvider(lendingPoolAddressesProvider).getLendingPool();

        uint256 tokensBefore = IERC20(asset).balanceOf(address(this));

        IERC20(aToken).approve(lendingPool, amount);

        //withdraw collateral from vault
        AaveLendingPool(lendingPool).withdraw(asset, amount, address(this));

        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(tokensBefore);
    }

    receive() external payable {}
}",2772
RealWorld_TA_61_StrategyRegistry_RealWorld_20240808145854.log,61,StrategyRegistry,92664,3293,95957,90.0,0.52918,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IStrategyRegistry.sol';

contract StrategyRegistry is Initializable, OwnableUpgradeable, IStrategyRegistry {
    using SafeMath for uint256;

    /**
     * @notice list of whitelisted strategies
     **/
    address[] public strategies;
    /**
     * @notice max strategies allowed to be whitelisted
     * @dev this limit ensures that strategies array is not too big to iterate
     **/
    uint256 public maxStrategies;

    /**
     * @notice registry which maps whitelisted strategies to true
     **/
    mapping(address => bool) public override registry;

    /**
     * @notice used to initialize the paramters of strategy registry
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _maxStrategies maximum number of strategies allowed
     **/
    function initialize(address _owner, uint256 _maxStrategies) external initializer {
        require(_maxStrategies != 0, 'StrategyRegistry::initialize maxStrategies cannot be zero');
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateMaxStrategies(_maxStrategies);
    }

    /**
     * @notice used to update max strategies allowed
     * @dev only owner can invoke
     * @param _maxStrategies updated number of max strategies allowed
     **/
    function updateMaxStrategies(uint256 _maxStrategies) external onlyOwner {
        _updateMaxStrategies(_maxStrategies);
    }

    function _updateMaxStrategies(uint256 _maxStrategies) internal {
        require(_maxStrategies != 0, 'StrategyRegistry::updateMaxStrategies should be more than zero');
        maxStrategies = _maxStrategies;
        emit MaxStrategiesUpdated(_maxStrategies);
    }

    /**
     * @notice used to get whitelisted strategies list
     * @return array of whitelisted strategies
     **/
    function getStrategies() external view override returns (address[] memory) {
        return strategies;
    }

    /**
     * @dev Add strategies to invest in. Please ensure that number of strategies are less than maxStrategies.
     * @param _strategy address of the strategy contract
     **/
    function addStrategy(address _strategy) external override onlyOwner {
        require(strategies.length.add(1) <= maxStrategies, ""StrategyRegistry::addStrategy - Can't add more strategies"");
        require(!registry[_strategy], 'StrategyRegistry::addStrategy - Strategy already exists');
        require(_strategy != address(0), 'StrategyRegistry::addStrategy - _strategy cannot be address(0)');
        registry[_strategy] = true;
        strategies.push(_strategy);

        emit StrategyAdded(_strategy);
    }

    /**
     * @dev Remove strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     **/
    function removeStrategy(uint256 _strategyIndex) external override onlyOwner {
        address _strategy = strategies[_strategyIndex];
        strategies[_strategyIndex] = strategies[strategies.length.sub(1, 'StrategyRegistry::removeStrategy - No strategies exist')];
        strategies.pop();
        registry[_strategy] = false;

        emit StrategyRemoved(_strategy);
    }

    /**
     * @dev Update strategy to invest in.
     * @param _strategyIndex Index of the strategy to remove
     * @param _oldStrategy Strategy that is to be removed
     * @param _newStrategy Updated strategy
     **/
    function updateStrategy(
        uint256 _strategyIndex,
        address _oldStrategy,
        address _newStrategy
    ) external override onlyOwner {
        require(
            strategies[_strategyIndex] == _oldStrategy,
            ""StrategyRegistry::updateStrategy - index to update and strategy address don't match""
        );
        require(!registry[_newStrategy], 'StrategyRegistry::updateStrategy - New strategy already exists');
        strategies[_strategyIndex] = _newStrategy;

        registry[_oldStrategy] = false;
        emit StrategyRemoved(_oldStrategy);
        registry[_newStrategy] = true;
        emit StrategyAdded(_newStrategy);
    }
}",902
RealWorld_TA_61_IPriceOracle_RealWorld_20240808151500.log,61,IPriceOracle,44429,1739,46168,74.0,0.256925,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

interface IPriceOracle {
    /**
     * @notice emitted when chainlink price feed for a token is updated
     * @param token address of token for which price feed is updated
     * @param priceOracle address of the updated price feed for the token
     */
    event ChainlinkFeedUpdated(address indexed token, address indexed priceOracle);

    /**
     * @notice emitted when uniswap price feed for a token pair is updated
     * @param token1 address of numerator address in price feed
     * @param token2 address of denominator address in price feed
     * @param feedId unique id for the token pair irrespective of the order of tokens
     * @param pool address of the pool from which price feed can be queried
     */
    event UniswapFeedUpdated(address indexed token1, address indexed token2, bytes32 feedId, address indexed pool);

    /**
     * @notice emitted when price averaging window for uniswap price feeds is updated
     * @param uniswapPriceAveragingPeriod period during which uniswap prices are averaged over to avoid attacks
     */
    event UniswapPriceAveragingPeriodUpdated(uint32 uniswapPriceAveragingPeriod);

    function getLatestPrice(address num, address den) external view returns (uint256, uint256);

    function doesFeedExist(address token1, address token2) external view returns (bool);
}",312
RealWorld_TA_61_IController_RealWorld_20240808143855.log,61,IController,28238,2204,30442,75.0,0.18527,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IController {
    function vaults(address) external view returns (address);

    function strategies(address) external view returns (address);

    function rewards() external view returns (address);

    function approveStrategy(address, address) external;

    function setStrategy(address, address) external;

    function withdraw(address, uint256) external;

    function balanceOf(address) external view returns (uint256);

    function earn(address, uint256) external;
}",107
RealWorld_TA_61_CreditLine_RealWorld_20240808144435.log,61,CreditLine,849001,1140,850141,138.0,4.267805,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            ""Only Borrower or Lender who hasn't requested can accept""
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, ""CreditLine::_depositCollateral - value to transfer doesn't match argument"");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, ""CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount"");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}",10034
RealWorld_TA_61_IPoolFactory_RealWorld_20240808152329.log,61,IPoolFactory,127629,1719,129348,87.0,0.672525,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IPoolFactory {
    /**
     * @notice emitted when a Pool is created
     * @param pool the address of the Pool
     * @param borrower the address of the borrower who created the pool
     */
    event PoolCreated(address indexed pool, address indexed borrower);

    /**
     * @notice emitted when the init function definition Pool.sol logic is updated
     * @param updatedSelector the new init function definition for the Pool logic contract
     */
    event PoolInitSelectorUpdated(bytes4 updatedSelector);

    /**
     * @notice emitted when the Pool.sol logic is updated
     * @param updatedPoolLogic the address of the new Pool logic contract
     */
    event PoolLogicUpdated(address indexed updatedPoolLogic);

    /**
     * @notice emitted when the user registry is updated
     * @param updatedBorrowerRegistry address of the contract storing the user registry
     */
    event UserRegistryUpdated(address indexed updatedBorrowerRegistry);

    /**
     * @notice emitted when the strategy registry is updated
     * @param updatedStrategyRegistry address of the contract storing the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed updatedStrategyRegistry);

    /**
     * @notice emitted when the Repayments.sol logic is updated
     * @param updatedRepaymentImpl the address of the new implementation of the Repayments logic
     */
    event RepaymentImplUpdated(address indexed updatedRepaymentImpl);

    /**
     * @notice emitted when the PriceOracle.sol is updated
     * @param updatedPriceOracle address of the new implementation of the PriceOracle
     */
    event PriceOracleUpdated(address indexed updatedPriceOracle);

    /**
     * @notice emitted when the Extension.sol is updated
     * @param updatedExtension address of the new implementation of the Extension
     */
    event ExtensionImplUpdated(address indexed updatedExtension);

    /**
     * @notice emitted when the SavingsAccount.sol is updated
     * @param savingsAccount address of the new implementation of the SavingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when the collection period parameter for Pools is updated
     * @param updatedCollectionPeriod the new value of the collection period for Pools
     */
    event CollectionPeriodUpdated(uint256 updatedCollectionPeriod);

    /**
     * @notice emitted when the loan withdrawal parameter for Pools is updated
     * @param updatedLoanWithdrawalDuration the new value of the loan withdrawal period for Pools
     */
    event LoanWithdrawalDurationUpdated(uint256 updatedLoanWithdrawalDuration);

    /**
     * @notice emitted when the marginCallDuration variable is updated
     * @param updatedMarginCallDuration Duration (in seconds) for which a margin call is active
     */
    event MarginCallDurationUpdated(uint256 updatedMarginCallDuration);

    /**
     * @notice emitted when miBorrowFraction variable is updated
     * @param updatedMinBorrowFraction Updated value of miBorrowFraction
     */
    event MinBorrowFractionUpdated(uint256 updatedMinBorrowFraction);

    /**
     * @notice emitted when liquidatorRewardFraction variable is updated
     * @param updatedLiquidatorRewardFraction updated value of liquidatorRewardFraction
     */
    event LiquidatorRewardFractionUpdated(uint256 updatedLiquidatorRewardFraction);

    /**
     * @notice emitted when poolCancelPenaltyMultiple variable is updated
     * @param updatedPoolCancelPenaltyMultiple updated value of poolCancelPenaltyMultiple
     */
    event PoolCancelPenaltyMultipleUpdated(uint256 updatedPoolCancelPenaltyMultiple);

    /**
     * @notice emitted when fee that protocol changes for pools is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address updatedProtocolFeeCollector);

    /**
     * @notice emitted when threhsolds for one of the parameters (poolSizeLimit, collateralRatioLimit, borrowRateLimit, repaymentIntervalLimit, noOfRepaymentIntervalsLimit) is updated
     * @param limitType specifies the parameter whose limits are being updated
     * @param max maximum threshold value for limitType
     * @param min minimum threshold value for limitType
     */
    event LimitsUpdated(string indexed limitType, uint256 max, uint256 min);

    /**
     * @notice emitted when the list of supported borrow assets is updated
     * @param borrowToken address of the borrow asset
     * @param isSupported true if borrowToken is a valid borrow asset, false if borrowToken is an invalid borrow asset
     */
    event BorrowTokenUpdated(address indexed borrowToken, bool isSupported);

    /**
     * @notice emitted when the list of supported collateral assets is updated
     * @param collateralToken address of the collateral asset
     * @param isSupported true if collateralToken is a valid collateral asset, false if collateralToken is an invalid collateral asset
     */
    event CollateralTokenUpdated(address indexed collateralToken, bool isSupported);

    /**
     * @notice emitted when no strategy address in the pool is updated
     * @param noStrategy address of noYield contract
     */
    event NoStrategyUpdated(address noStrategy);

    function savingsAccount() external view returns (address);

    function owner() external view returns (address);

    function poolRegistry(address pool) external view returns (bool);

    function priceOracle() external view returns (address);

    function extension() external view returns (address);

    function repaymentImpl() external view returns (address);

    function userRegistry() external view returns (address);

    function collectionPeriod() external view returns (uint256);

    function loanWithdrawalDuration() external view returns (uint256);

    function marginCallDuration() external view returns (uint256);

    function minBorrowFraction() external view returns (uint256);

    function liquidatorRewardFraction() external view returns (uint256);

    function poolCancelPenaltyMultiple() external view returns (uint256);

    function getProtocolFeeData() external view returns (uint256, address);

    function noStrategyAddress() external view returns (address);
}",1320
RealWorld_TA_61_Extension_RealWorld_20240808150625.log,61,Extension,173500,4550,178050,115.0,0.9585,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IRepayment.sol';

/**
 * @title Extension contract with methods related to Extension period
 * @notice Implements the functions related to Extension period of the pool
 * @author Sublime
 */
contract Extension is Initializable, IExtension {
    using SafeMath for uint256;

    struct ExtensionVariables {
        bool hasExtensionPassed;
        uint256 totalExtensionSupport;
        uint256 extensionVoteEndTime;
        uint256 repaymentInterval;
        mapping(address => uint256) lastVotedExtension;
    }

    /**
     * @notice used to keep track of extension details against a pool
     */
    mapping(address => ExtensionVariables) public extensions;
    IPoolFactory poolFactory;
    /**
     * @notice used to store voting pass ratio for approving extension
     */
    uint256 public votingPassRatio;

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == poolFactory.owner(), 'Not owner');
        _;
    }

    /**
     * @notice checks if the address is pool's valid borrower
     * @param _pool address of the borrower
     */
    modifier onlyBorrower(address _pool) {
        require(IPool(_pool).borrower() == msg.sender, 'Not Borrower');
        _;
    }

    /**
     * @notice initializing the Pool and the voting pass ratio
     * @param _poolFactory address of the Pool
     * @param _votingPassRatio the value of the voting pass ratio
     */
    function initialize(address _poolFactory, uint256 _votingPassRatio) external initializer {
        _updatePoolFactory(_poolFactory);
        _updateVotingPassRatio(_votingPassRatio);
    }

    /**
     * @notice initializing the pool extension for the Pool
     * @param _repaymentInterval value of the repayment interval
     */
    function initializePoolExtension(uint256 _repaymentInterval) external override {
        IPoolFactory _poolFactory = poolFactory;
        require(extensions[msg.sender].repaymentInterval == 0, 'Extension::initializePoolExtension - already initialized');
        require(_poolFactory.poolRegistry(msg.sender), 'Repayments::onlyValidPool - Invalid Pool');
        extensions[msg.sender].repaymentInterval = _repaymentInterval;
    }

    /**
     * @notice used for requesting an extension by a borrower
     * @param _pool address of the Pool
     */
    function requestExtension(address _pool) external onlyBorrower(_pool) {
        uint256 _repaymentInterval = extensions[_pool].repaymentInterval;
        require(_repaymentInterval != 0, 'Extension::requestExtension - Uninitialized pool');
        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;
        require(block.timestamp > _extensionVoteEndTime, 'Extension::requestExtension - Extension requested already'); // _extensionVoteEndTime is 0 when no extension is active

        // This check is required so that borrower doesn't ask for more extension if previously an extension is already granted
        require(!extensions[_pool].hasExtensionPassed, 'Extension::requestExtension: Extension already availed');

        extensions[_pool].totalExtensionSupport = 0; // As we can multiple voting every time new voting start we have to make previous votes 0
        IRepayment _repayment = IRepayment(poolFactory.repaymentImpl());
        uint256 _nextDueTime = _repayment.getNextInstalmentDeadline(_pool);
        _extensionVoteEndTime = (_nextDueTime).div(10**30);
        extensions[_pool].extensionVoteEndTime = _extensionVoteEndTime; // this makes extension request single use
        emit ExtensionRequested(_extensionVoteEndTime);
    }

    /**
     * @notice used to rebalance votes of from and to addresses when pool tokens are transferred
     * @dev only pool can change its votes
     * @param _from address of user from whom pool tokens are transferred
     * @param _to address of user to whom pool tokens are transferred
     * @param _amount amount of pool tokens transferred
     */
    function removeVotes(
        address _from,
        address _to,
        uint256 _amount
    ) external override {
        address _pool = msg.sender;
        if (extensions[_pool].hasExtensionPassed) {
            return;
        }

        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;

        if (_extensionVoteEndTime != 0 && _extensionVoteEndTime <= block.timestamp) {
            if (extensions[_pool].lastVotedExtension[_from] == _extensionVoteEndTime) {
                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.sub(_amount);
            }

            if (extensions[_pool].lastVotedExtension[_to] == _extensionVoteEndTime) {
                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.add(_amount);
            }
        }
    }

    /**
     * @notice used for requesting an extension by a borrower
     * @param _pool address of the Pool
     */
    function voteOnExtension(address _pool) external {
        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;
        require(block.timestamp < _extensionVoteEndTime, 'Pool::voteOnExtension - Voting is over');

        (uint256 _balance, uint256 _totalSupply) = IPool(_pool).getBalanceDetails(msg.sender);
        require(_balance != 0, 'Pool::voteOnExtension - Not a valid lender for pool');

        uint256 _votingPassRatio = votingPassRatio;

        uint256 _lastVotedExtension = extensions[_pool].lastVotedExtension[msg.sender]; //Lender last vote time need to store it as it checks that a lender only votes once
        require(_lastVotedExtension != _extensionVoteEndTime, 'Pool::voteOnExtension - you have already voted');

        uint256 _extensionSupport = extensions[_pool].totalExtensionSupport;
        _lastVotedExtension = _extensionVoteEndTime;
        _extensionSupport = _extensionSupport.add(_balance);

        extensions[_pool].lastVotedExtension[msg.sender] = _lastVotedExtension;
        emit LenderVoted(msg.sender, _extensionSupport, _lastVotedExtension);
        extensions[_pool].totalExtensionSupport = _extensionSupport;

        if (((_extensionSupport)) >= (_totalSupply.mul(_votingPassRatio)).div(10**30)) {
            grantExtension(_pool);
        }
    }

    /**
     * @notice used for granting an extension for the repayment of loan
     * @param _pool address of the Pool
     */
    function grantExtension(address _pool) internal {
        IPoolFactory _poolFactory = poolFactory;
        IRepayment _repayment = IRepayment(_poolFactory.repaymentImpl());

        extensions[_pool].hasExtensionPassed = true;
        extensions[_pool].extensionVoteEndTime = block.timestamp; // voting is over

        _repayment.instalmentDeadlineExtended(_pool);

        emit ExtensionPassed(_pool);
    }

    /**
     * @notice used for closing the pool extension
     */
    function closePoolExtension() external override {
        delete extensions[msg.sender];
    }

    /**
     * @notice used for updating the voting pass ratio of the Pool
     * @param _votingPassRatio the value of the new voting pass ratio
     */
    function updateVotingPassRatio(uint256 _votingPassRatio) external onlyOwner {
        _updateVotingPassRatio(_votingPassRatio);
    }

    function _updateVotingPassRatio(uint256 _votingPassRatio) internal {
        votingPassRatio = _votingPassRatio;
        emit VotingPassRatioUpdated(_votingPassRatio);
    }

    /**
     * @notice used to update the pool factory contract address
     * @dev only owner can update
     * @param _poolFactory updated pool factory contract address
     */
    function updatePoolFactory(address _poolFactory) external onlyOwner {
        _updatePoolFactory(_poolFactory);
    }

    function _updatePoolFactory(address _poolFactory) internal {
        require(_poolFactory != address(0), 'Zero address not allowed');
        poolFactory = IPoolFactory(_poolFactory);
        emit PoolFactoryUpdated(_poolFactory);
    }
}",1806
RealWorld_TA_61_NoYield_RealWorld_20240808145213.log,61,NoYield,129399,5040,134439,115.0,0.747795,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to query liquidity token for a given asset
     * @param _asset address of the asset
     * @return _tokenAddress address of the lqiudity token for the asset
     **/
    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {
        _tokenAddress = _asset;
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        uint256 amount = IERC20(_asset).balanceOf(address(this));
        IERC20(_asset).safeTransfer(_wallet, received);
        received = amount;
    }

    /**
     * @notice Used to lock tokens in the protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        if (asset != address(0)) {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
        } else {
            require(msg.value == amount, 'Invest: ETH amount');
        }
        sharesReceived = amount;
        emit LockedTokens(user, asset, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from the protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return tokensReceived received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount)
        external
        override
        onlySavingsAccount
        nonReentrant
        returns (uint256 tokensReceived)
    {
        tokensReceived = _unlockTokens(asset, amount);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        received = _unlockTokens(asset, amount);
    }

    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        received = amount;
        if (asset == address(0)) {
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            IERC20(asset).safeTransfer(savingsAccount, received);
        }
        emit UnlockedTokens(asset, received);
    }

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {
        amount = shares;
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {
        shares = amount;
    }
}",1322
RealWorld_TA_61_ILendingPoolAddressesProvider_RealWorld_20240808153908.log,61,ILendingPoolAddressesProvider,56641,1831,58472,73.0,0.319825,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

/**
 * @title LendingPoolAddressesProvider contract
 * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles
 * - Acting also as factory of proxies and admin of those, so with right to change its implementations
 * - Owned by the Aave Governance
 * @author Aave
 **/
interface ILendingPoolAddressesProvider {
    event MarketIdSet(string newMarketId);
    event LendingPoolUpdated(address indexed newAddress);
    event ConfigurationAdminUpdated(address indexed newAddress);
    event EmergencyAdminUpdated(address indexed newAddress);
    event LendingPoolConfiguratorUpdated(address indexed newAddress);
    event LendingPoolCollateralManagerUpdated(address indexed newAddress);
    event PriceOracleUpdated(address indexed newAddress);
    event LendingRateOracleUpdated(address indexed newAddress);
    event ProxyCreated(bytes32 id, address indexed newAddress);
    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

    function getMarketId() external view returns (string memory);

    function setMarketId(string calldata marketId) external;

    function setAddress(bytes32 id, address newAddress) external;

    function setAddressAsProxy(bytes32 id, address impl) external;

    function getAddress(bytes32 id) external view returns (address);

    function getLendingPool() external view returns (address);

    function setLendingPoolImpl(address pool) external;

    function getLendingPoolConfigurator() external view returns (address);

    function setLendingPoolConfiguratorImpl(address configurator) external;

    function getLendingPoolCollateralManager() external view returns (address);

    function setLendingPoolCollateralManager(address manager) external;

    function getPoolAdmin() external view returns (address);

    function setPoolAdmin(address admin) external;

    function getEmergencyAdmin() external view returns (address);

    function setEmergencyAdmin(address admin) external;

    function getPriceOracle() external view returns (address);

    function setPriceOracle(address priceOracle) external;

    function getLendingRateOracle() external view returns (address);

    function setLendingRateOracle(address lendingRateOracle) external;
}",457
RealWorld_TA_61_IYield_RealWorld_20240808151339.log,61,IYield,67313,1995,69308,79.0,0.376465,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IYield {
    /**
     * @dev emitted when tokens are locked
     * @param user the address of user, tokens locked for
     * @param investedTo the address of contract to invest in
     * @param lpTokensReceived the amount of shares received
     **/
    event LockedTokens(address indexed user, address indexed investedTo, uint256 lpTokensReceived);

    /**
     * @dev emitted when tokens are unlocked/redeemed
     * @param investedTo the address of contract invested in
     * @param collateralReceived the amount of underlying asset received
     **/
    event UnlockedTokens(address indexed investedTo, uint256 collateralReceived);

    /**
     * @notice emitted when a shares are unlocked from yield
     * @param asset address of the base token for which shares are being withdrawn
     * @param sharesReleased amount of shares unlocked
     */
    event UnlockedShares(address indexed asset, uint256 sharesReleased);

    /**
     * @notice emitted when savings account address is updated
     * @param savingsAccount updated address of the savings account contract
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @dev Used to get liquidity token address from asset address
     * @param asset the address of underlying token
     * @return tokenAddress address of liquidity token
     **/
    function liquidityToken(address asset) external view returns (address tokenAddress);

    /**
     * @dev Used to lock tokens in available protocol
     * @param user the address of user locking tokens
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable returns (uint256 sharesReceived);

    /**
     * @dev Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of liquidity shares to unlock
     * @return tokensReceived amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external returns (uint256 tokensReceived);

    function unlockShares(address asset, uint256 amount) external returns (uint256 received);

    /**
     * @dev Used to get amount of underlying tokens for current number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) external returns (uint256 amount);

    function getSharesForTokens(uint256 amount, address asset) external returns (uint256 shares);
}",578
RealWorld_TA_61_yVault_RealWorld_20240808143636.log,61,yVault,241432,6121,247553,137.0,1.32958,"// SPDX-License-Identifier: MIT
/**
 *Submitted for verification at Etherscan.io on 2020-09-01
 */

pragma solidity 0.7.6;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/Address.sol';
import '@openzeppelin/contracts/GSN/Context.sol';

import './IController.sol';

contract ERC20 is Context {
    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance'));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, 'ERC20: decreased allowance below zero'));
        return true;
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        require(sender != address(0), 'ERC20: transfer from the zero address');
        require(recipient != address(0), 'ERC20: transfer to the zero address');

        _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), 'ERC20: mint to the zero address');

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), 'ERC20: burn from the zero address');

        _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        require(owner != address(0), 'ERC20: approve from the zero address');
        require(spender != address(0), 'ERC20: approve to the zero address');

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, 'ERC20: burn amount exceeds allowance'));
    }
}

contract ERC20Detailed is ERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals
    ) {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns (uint8) {
        return _decimals;
    }
}

library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(
        ERC20 token,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        ERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(
        ERC20 token,
        address spender,
        uint256 value
    ) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0), 'SafeERC20: approve from non-zero to non-zero allowance');
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        ERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        ERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, 'SafeERC20: decreased allowance below zero');
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function callOptionalReturn(ERC20 token, bytes memory data) private {
        require(address(token).isContract(), 'SafeERC20: call to non-contract');

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, 'SafeERC20: low-level call failed');

        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');
        }
    }
}

interface WETH {
    function deposit() external payable;

    function withdraw(uint256 wad) external;

    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);
}

contract yVault is ERC20, ERC20Detailed {
    using SafeERC20 for ERC20;
    using Address for address;
    using SafeMath for uint256;

    ERC20 public token;

    uint256 public min = 9990;
    uint256 public constant max = 10000;

    address public governance;
    address public controller;

    constructor(address _token, address _controller)
        ERC20Detailed(
            string(abi.encodePacked('yearn ', ERC20Detailed(_token).name())),
            string(abi.encodePacked('y', ERC20Detailed(_token).symbol())),
            ERC20Detailed(_token).decimals()
        )
    {
        token = ERC20(_token);
        governance = msg.sender;
        controller = _controller;
    }

    function balance() public view returns (uint256) {
        return token.balanceOf(address(this)).add(IController(controller).balanceOf(address(token)));
    }

    function setMin(uint256 _min) external {
        require(msg.sender == governance, '!governance');
        min = _min;
    }

    function setGovernance(address _governance) public {
        require(msg.sender == governance, '!governance');
        governance = _governance;
    }

    function setController(address _controller) public {
        require(msg.sender == governance, '!governance');
        controller = _controller;
    }

    // Custom logic in here for how much the vault allows to be borrowed
    // Sets minimum required on-hand to keep small withdrawals cheap
    function available() public view returns (uint256) {
        return token.balanceOf(address(this)).mul(min).div(max);
    }

    function earn() public {
        uint256 _bal = available();
        token.safeTransfer(controller, _bal);
        IController(controller).earn(address(token), _bal);
    }

    function depositAll() external {
        deposit(token.balanceOf(msg.sender));
    }

    function deposit(uint256 _amount) public {
        uint256 _pool = balance();
        uint256 _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = token.balanceOf(address(this));
        _amount = _after.sub(_before); // Additional check for deflationary tokens
        uint256 shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function depositETH() public payable {
        uint256 _pool = balance();
        uint256 _before = token.balanceOf(address(this));
        uint256 _amount = msg.value;
        WETH(address(token)).deposit{value: _amount}();
        uint256 _after = token.balanceOf(address(this));
        _amount = _after.sub(_before); // Additional check for deflationary tokens
        uint256 shares = 0;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount.mul(totalSupply())).div(_pool);
        }
        _mint(msg.sender, shares);
    }

    function withdrawAll() external {
        withdraw(balanceOf(msg.sender));
    }

    function withdrawAllETH() external {
        withdrawETH(balanceOf(msg.sender));
    }

    // Used to swap any borrowed reserve over the debt limit to liquidate to 'token'
    function harvest(address reserve, uint256 amount) external {
        require(msg.sender == controller, '!controller');
        require(reserve != address(token), 'token');
        ERC20(reserve).safeTransfer(controller, amount);
    }

    // No rebalance implementation for lower fees and faster swaps
    function withdraw(uint256 _shares) public {
        uint256 r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        // Check balance
        uint256 b = token.balanceOf(address(this));
        if (b < r) {
            uint256 _withdraw = r.sub(b);
            IController(controller).withdraw(address(token), _withdraw);
            uint256 _after = token.balanceOf(address(this));
            uint256 _diff = _after.sub(b);
            if (_diff < _withdraw) {
                r = b.add(_diff);
            }
        }

        token.safeTransfer(msg.sender, r);
    }

    // No rebalance implementation for lower fees and faster swaps
    function withdrawETH(uint256 _shares) public {
        uint256 r = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        // Check balance
        uint256 b = token.balanceOf(address(this));
        if (b < r) {
            uint256 _withdraw = r.sub(b);
            IController(controller).withdraw(address(token), _withdraw);
            uint256 _after = token.balanceOf(address(this));
            uint256 _diff = _after.sub(b);
            if (_diff < _withdraw) {
                r = b.add(_diff);
            }
        }

        WETH(address(token)).withdraw(r);
        msg.sender.transfer(r);
    }

    function getPricePerFullShare() public view returns (uint256) {
        return balance().mul(1e18).div(totalSupply());
    }

    receive() external payable {
        if (msg.sender != address(token)) {
            depositETH();
        }
    }
}",2645
RealWorld_TA_61_CompoundYield_RealWorld_20240808145410.log,61,CompoundYield,189754,6220,195974,136.0,1.07317,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

import '../interfaces/IYield.sol';
import '../interfaces/Invest/ICEther.sol';
import '../interfaces/Invest/ICToken.sol';

/**
 * @title Yield contract
 * @notice Implements the functions to lock/unlock tokens into available exchanges
 * @author Sublime
 **/
contract CompoundYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    /**
     * @notice stores the address of savings account contract
     **/
    address payable public savingsAccount;

    /**
     * @notice stores the address of liquidity token for a given base token
     */
    mapping(address => address) public override liquidityToken;

    /**
     * @notice emitted when liquidity token address of an asset is updated
     * @param asset the address of asset
     * @param protocolToken address of the liquidity token for the asset
     **/
    event ProtocolAddressesUpdated(address indexed asset, address indexed protocolToken);

    /**
     * @notice checks if contract is invoked by savings account
     **/
    modifier onlySavingsAccount() {
        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');
        _;
    }

    /**
     * @notice used to initialize the variables in the contract
     * @dev can only be called once
     * @param _owner address of the owner
     * @param _savingsAccount address of the savings account contract
     **/
    function initialize(address _owner, address payable _savingsAccount) external initializer {
        __Ownable_init();
        super.transferOwnership(_owner);

        _updateSavingsAccount(_savingsAccount);
    }

    /**
     * @notice used to update savings account contract address
     * @dev can only be called by owner
     * @param _savingsAccount address of updated savings account contract
     **/
    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address payable _savingsAccount) internal {
        require(_savingsAccount != address(0), 'Invest: zero address');
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update liquidity token for a asset
     * @dev can only be called by owner
     * @param _asset address of the token
     * @param _liquidityToken address of the liquidityToken for the given token
     **/
    function updateProtocolAddresses(address _asset, address _liquidityToken) external onlyOwner {
        liquidityToken[_asset] = _liquidityToken;
        emit ProtocolAddressesUpdated(_asset, _liquidityToken);
    }

    /**
     * @notice used to withdraw all tokens of a type in case of emergencies
     * @dev only owner can withdraw
     * @param _asset address of the token being withdrawn
     * @param _wallet address to which tokens are withdrawn
     */
    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {
        require(_wallet != address(0), 'cant burn');
        address investedTo = liquidityToken[_asset];
        uint256 amount = IERC20(investedTo).balanceOf(address(this));

        if (_asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = _wallet.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(_asset, investedTo, amount);
            IERC20(_asset).safeTransfer(_wallet, received);
        }
    }

    /**
     * @notice Used to lock tokens in available protocol
     * @dev Asset Tokens to be locked must be approved to this contract by user
     * @param user the address of user
     * @param asset the address of token to invest
     * @param amount the amount of asset
     * @return sharesReceived amount of shares received
     **/
    function lockTokens(
        address user,
        address asset,
        uint256 amount
    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];
        if (asset == address(0)) {
            require(msg.value == amount, 'Invest: ETH amount');
            sharesReceived = _depositETH(investedTo, amount);
        } else {
            IERC20(asset).safeTransferFrom(user, address(this), amount);
            sharesReceived = _depositERC20(asset, investedTo, amount);
        }
        emit LockedTokens(user, investedTo, sharesReceived);
    }

    /**
     * @notice Used to unlock tokens from available protocol
     * @param asset the address of underlying token
     * @param amount the amount of asset
     * @return received amount of tokens received
     **/
    function unlockTokens(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {
        require(amount != 0, 'Invest: amount');
        address investedTo = liquidityToken[asset];

        if (asset == address(0)) {
            received = _withdrawETH(investedTo, amount);
            (bool success, ) = savingsAccount.call{value: received}('');
            require(success, 'Transfer failed');
        } else {
            received = _withdrawERC(asset, investedTo, amount);
            IERC20(asset).safeTransfer(savingsAccount, received);
        }

        emit UnlockedTokens(asset, received);
    }

    /**
     * @notice Used to unlock shares
     * @param asset the address of underlying token
     * @param amount the amount of shares to unlock
     * @return received amount of shares received
     **/
    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {
        if (amount == 0) {
            return 0;
        }

        require(asset != address(0), 'Asset address cannot be address(0)');
        IERC20(asset).safeTransfer(savingsAccount, amount);

        emit UnlockedShares(asset, amount);
        return amount;
    }

    /**
     * @dev Used to get amount of underlying tokens for given number of shares
     * @param shares the amount of shares
     * @param asset the address of token locked
     * @return amount amount of underlying tokens
     **/
    function getTokensForShares(uint256 shares, address asset) public override returns (uint256 amount) {
        //balanceOfUnderlying returns underlying balance for total shares
        if (shares == 0) return 0;
        address cToken = liquidityToken[asset];
        amount = ICToken(cToken).balanceOfUnderlying(address(this)).mul(shares).div(IERC20(cToken).balanceOf(address(this)));
    }

    /**
     * @notice Used to get number of shares from an amount of underlying tokens
     * @param amount the amount of tokens
     * @param asset the address of token
     * @return shares amount of shares for given tokens
     **/
    function getSharesForTokens(uint256 amount, address asset) external override returns (uint256 shares) {
        shares = (amount.mul(1e18)).div(getTokensForShares(1e18, asset));
    }

    function _depositETH(address cToken, uint256 amount) internal returns (uint256 sharesReceived) {
        uint256 initialCTokenBalance = IERC20(cToken).balanceOf(address(this));

        //mint cToken
        ICEther(cToken).mint{value: amount}();

        sharesReceived = IERC20(cToken).balanceOf(address(this)).sub(initialCTokenBalance);
    }

    function _depositERC20(
        address asset,
        address cToken,
        uint256 amount
    ) internal returns (uint256 sharesReceived) {
        uint256 initialCTokenBalance = IERC20(cToken).balanceOf(address(this));
        //mint cToken
        IERC20(asset).approve(cToken, 0);
        IERC20(asset).approve(cToken, amount);
        require(ICToken(cToken).mint(amount) == 0, 'Error in minting tokens');
        sharesReceived = IERC20(cToken).balanceOf(address(this)).sub(initialCTokenBalance);
    }

    function _withdrawETH(address cToken, uint256 amount) internal returns (uint256 received) {
        uint256 ethBalance = address(this).balance;

        require(ICToken(cToken).redeem(amount) == 0, 'Error in unwrapping');

        received = address(this).balance.sub(ethBalance);
    }

    function _withdrawERC(
        address asset,
        address cToken,
        uint256 amount
    ) internal returns (uint256 tokensReceived) {
        uint256 initialAssetBalance = IERC20(asset).balanceOf(address(this));
        require(ICToken(cToken).redeem(amount) == 0, 'Error in unwrapping');
        tokensReceived = IERC20(asset).balanceOf(address(this)).sub(initialAssetBalance);
    }

    //to apply check
    receive() external payable {}
}",2039
RealWorld_TA_61_ISavingsAccount_RealWorld_20240808152610.log,61,ISavingsAccount,130989,3093,134082,398.0,0.716805,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface ISavingsAccount {
    /**
     * @notice emitted when tokens are deposited into savings account
     * @param user address of user depositing the tokens
     * @param sharesReceived amount of shares received for deposit
     * @param token address of token that is deposited
     * @param strategy strategy into which tokens are deposited
     */
    event Deposited(address indexed user, uint256 sharesReceived, address indexed token, address indexed strategy);

    /**
     * @notice emitted when tokens are switched from one strategy to another
     * @param user address of user switching strategies
     * @param token address of token for which strategies are switched
     * @param sharesDecreasedInCurrentStrategy shares decreased in current strategy
     * @param sharesIncreasedInNewStrategy shares increased in new strategy
     * @param currentStrategy address of the strategy from which tokens are switched
     * @param newStrategy address of the strategy to which tokens are switched
     */
    event StrategySwitched(
        address indexed user,
        address indexed token,
        uint256 sharesDecreasedInCurrentStrategy,
        uint256 sharesIncreasedInNewStrategy,
        address currentStrategy,
        address indexed newStrategy
    );

    /**
     * @notice emitted when tokens are withdrawn from savings account
     * @param from address of user from which tokens are withdrawn
     * @param to address of user to which tokens are withdrawn
     * @param sharesWithdrawn amount of shares withdrawn
     * @param token address of token that is withdrawn
     * @param strategy strategy into which tokens are withdrawn
     * @param withdrawShares flag to represent if shares are directly wirthdrawn
     */
    event Withdrawn(address indexed from, address indexed to, uint256 sharesWithdrawn, address indexed token, address strategy, bool withdrawShares);

    /**
     * @notice emitted when all tokens are withdrawn
     * @param user address of user withdrawing tokens
     * @param tokenReceived amount of tokens withdrawn
     * @param token address of the token withdrawn
     */
    event WithdrawnAll(address indexed user, uint256 tokenReceived, address indexed token);

    /**
     * @notice emitted when tokens are approved
     * @param token address of token approved
     * @param from address of user from who tokens are approved
     * @param to address of user to whom tokens are approved
     * @param amount amount of tokens approved
     */
    event Approved(address indexed token, address indexed from, address indexed to, uint256 amount);

    /**
     * @notice emitted when tokens are transferred
     * @param token address of token transferred
     * @param strategy address of strategy from which tokens are transferred
     * @param from address of user from whom tokens are transferred
     * @param to address of user to whom tokens are transferred
     * @param amount amount of tokens transferred
     */
    event Transfer(address indexed token, address strategy, address indexed from, address indexed to, uint256 amount);

    /**
     * @notice emitted when credit line address is updated
     * @param updatedCreditLine updated credit line contract address
     */
    event CreditLineUpdated(address indexed updatedCreditLine);

    /**
     * @notice emitted when strategy registry is updated
     * @param updatedStrategyRegistry updated strategy registry address
     */
    event StrategyRegistryUpdated(address indexed updatedStrategyRegistry);

    /**
     * @notice emitted when credit line allowance is refreshed
     * @param token token for which allowance is increased
     * @param from address of user from whcih allowance is increased
     * @param amount amount of tokens by which allowance is increased
     */
    event CreditLineAllowanceRefreshed(address indexed token, address indexed from, address indexed to, uint256 amount);

    function deposit(
        uint256 amount,
        address token,
        address strategy,
        address to
    ) external payable returns (uint256 sharesReceived);

    /**
     * @dev Used to switch saving strategy of an token
     * @param currentStrategy initial strategy of token
     * @param newStrategy new strategy to invest
     * @param token address of the token
     * @param amount amount of tokens to be reinvested
     */
    function switchStrategy(
        uint256 amount,
        address token,
        address currentStrategy,
        address newStrategy
    ) external;

    /**
     * @dev Used to withdraw token from Saving Account
     * @param withdrawTo address to which token should be sent
     * @param amount amount of tokens to withdraw
     * @param token address of the token to be withdrawn
     * @param strategy strategy from where token has to withdrawn(ex:- compound,Aave etc)
     * @param withdrawShares boolean indicating to withdraw in liquidity share or underlying token
     */
    function withdraw(
        uint256 amount,
        address token,
        address strategy,
        address payable withdrawTo,
        bool withdrawShares
    ) external returns (uint256);

    function withdrawAll(address token) external returns (uint256 tokenReceived);

    function withdrawAll(address token, address strategy) external returns (uint256 tokenReceived);

    function approve(
        uint256 amount,
        address token,
        address to
    ) external;

    function increaseAllowance(
        uint256 amount,
        address token,
        address to
    ) external;

    function decreaseAllowance(
        uint256 amount,
        address token,
        address to
    ) external;

    function transfer(
        uint256 amount,
        address token,
        address poolSavingsStrategy,
        address to
    ) external returns (uint256);

    function transferFrom(
        uint256 amount,
        address token,
        address poolSavingsStrategy,
        address from,
        address to
    ) external returns (uint256);

    function balanceInShares(
        address user,
        address token,
        address strategy
    ) external view returns (uint256);

    function increaseAllowanceToCreditLine(
        uint256 amount,
        address token,
        address from
    ) external;

    function withdrawFrom(
        uint256 amount,
        address token,
        address strategy,
        address from,
        address payable to,
        bool withdrawShares
    ) external returns (uint256 amountReceived);

    function getTotalTokens(address _user, address _token) external returns (uint256 _totalTokens);
}",1332
RealWorld_TA_61_ICEther_RealWorld_20240808154402.log,61,ICEther,24498,2092,26590,80.0,0.16433,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

interface ICEther {
    function mint() external payable;

    function repayBorrow() external payable;

    function repayBorrowBehalf(address borrower) external payable;

    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;
}",70
RealWorld_TA_61_Pool_RealWorld_20240808150026.log,61,Pool,842981,458,843439,185.0,4.224065,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}",10152
RealWorld_TA_61_IyVault_RealWorld_20240808154131.log,61,IyVault,30830,1841,32671,75.0,0.19097,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

interface IyVault {
    function earn() external;

    function depositAll() external;

    function deposit(uint256 _amount) external;

    function depositETH() external payable;

    function withdrawAll() external;

    function withdrawAllETH() external;

    function harvest(address reserve, uint256 amount) external;

    function withdraw(uint256 _shares) external;

    function withdrawETH(uint256 _shares) external;

    function getPricePerFullShare() external view returns (uint256);

    function balanceOf(address) external view returns (uint256);

    function setMin(uint256) external;

    function min() external returns (uint256);
}",147
RealWorld_TA_61_IRepayment_RealWorld_20240808152458.log,61,IRepayment,70955,1370,72325,69.0,0.382175,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;

interface IRepayment {
    /// @notice Event emitted when interest for the loann is partially repaid
    /// @param poolID The address of the pool to which interest was paid
    /// @param repayAmount Amount being repayed
    event InterestRepaid(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when all interest for the pool is repaid
    /// @param poolID The address of the pool to which interest was paid
    /// @param repayAmount Amount being repayed
    event InterestRepaymentComplete(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when pricipal is repaid
    /// @param poolID The address of the pool to which principal was paid
    /// @param repayAmount Amount being repayed
    event PrincipalRepaid(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when Grace penalty and interest for previous period is completely repaid
    /// @param poolID The address of the pool to which repayment was made
    /// @param repayAmount Amount being repayed
    event GracePenaltyRepaid(address indexed poolID, uint256 repayAmount);

    /// @notice Event emitted when repayment for extension is completely done
    /// @param poolID The address of the pool to which interest was paid
    /// @param repayAmount Amount being re-payed by the borrower
    event ExtensionRepaid(address indexed poolID, uint256 repayAmount); // Made during current period interest repayment

    /// @notice Event to denote changes in the configurations of the pool factory
    /// @param poolFactory updated pool factory address
    event PoolFactoryUpdated(address indexed poolFactory);

    /// @notice Event to denote changes in the configurations of the Grace Penalty Rate
    /// @param gracePenaltyRate updated gracePenaltyRate
    event GracePenaltyRateUpdated(uint256 indexed gracePenaltyRate);

    /// @notice Event to denote changes in the configurations of the Grace Period Fraction
    /// @param gracePeriodFraction updated gracePeriodFraction
    event GracePeriodFractionUpdated(uint256 indexed gracePeriodFraction);

    function initializeRepayment(
        uint256 numberOfTotalRepayments,
        uint256 repaymentInterval,
        uint256 borrowRate,
        uint256 loanStartTime,
        address lentAsset
    ) external;

    function getTotalRepaidAmount(address poolID) external view returns (uint256);

    function getInterestCalculationVars(address poolID) external view returns (uint256, uint256);

    function getCurrentLoanInterval(address poolID) external view returns (uint256);

    function instalmentDeadlineExtended(address _poolID) external;

    function didBorrowerDefault(address _poolID) external view returns (bool);

    function getGracePeriodFraction() external view returns (uint256);

    function getNextInstalmentDeadline(address _poolID) external view returns (uint256);
}",626
RealWorld_TA_61_Migrations_RealWorld_20240808142623.log,61,Migrations,25640,1576,27216,70.0,0.15972,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract Migrations {
    address public owner = msg.sender;
    uint256 public last_completed_migration;

    modifier restricted() {
        require(msg.sender == owner, ""This function is restricted to the contract's owner"");
        _;
    }

    function setCompleted(uint256 completed) public restricted {
        last_completed_migration = completed;
    }
}",85
RealWorld_TA_62_TrustAuthority.t_RealWorld_20240808155619.log,62,TrustAuthority.t,54263,1670,55933,72.0,0.304715,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {MockAuthChild} from ""./utils/mocks/MockAuthChild.sol"";

import {TrustAuthority} from ""../auth/authorities/TrustAuthority.sol"";

contract TrustAuthorityTest is DSTestPlus {
    TrustAuthority trust;
    MockAuthChild mockAuthChild;

    function setUp() public {
        trust = new TrustAuthority(address(this));
        mockAuthChild = new MockAuthChild();

        mockAuthChild.setAuthority(trust);
        mockAuthChild.setOwner(DEAD_ADDRESS);

        trust.setIsTrusted(address(this), false);
    }

    function invariantOwner() public {
        assertEq(mockAuthChild.owner(), DEAD_ADDRESS);
    }

    function invariantAuthority() public {
        assertEq(address(mockAuthChild.authority()), address(trust));
    }

    function testSanityChecks() public {
        assertFalse(trust.isTrusted(address(this)));
        assertFalse(trust.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));
        try mockAuthChild.updateFlag() {
            fail(""Trust Authority Let Attacker Update Flag"");
        } catch {}
    }

    function testUpdateTrust() public {
        forceTrust(address(this));
        assertTrue(trust.isTrusted(address(this)));
        assertTrue(trust.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));
        mockAuthChild.updateFlag();

        trust.setIsTrusted(address(this), false);
        assertFalse(trust.isTrusted(address(this)));
        assertFalse(trust.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));
        try mockAuthChild.updateFlag() {
            fail(""Trust Authority Allowed Attacker To Update Flag"");
        } catch {}
    }

    function forceTrust(address usr) internal {
        hevm.store(address(trust), keccak256(abi.encode(usr, uint256(0))), bytes32(uint256(1)));
    }
}",421
RealWorld_TA_62_HEVMHelpers_RealWorld_20240808165114.log,62,HEVMHelpers,200616,4743,205359,144.0,1.09794,"pragma solidity >=0.8.0;

import ""ds-test/test.sol"";
import ""./HEVMState.sol"";

contract HEVMHelpers is HEVMState, DSTest {

    event Debug(uint, bytes32);
    event SlotFound(address who, string sig, uint slot);
    event Logger(uint, bytes);
    function sigs(
        string memory sig
    )
        public
        pure
        returns (bytes4)
    {
        return bytes4(keccak256(bytes(sig)));
    }

    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
    // slot complexity:
    //  if flat, will be bytes32(uint256(uint));
    //  if map, will be keccak256(abi.encode(key, uint(slot)));
    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
    function find(
        string memory sig, // signature to check agains
        bytes32[] memory ins, // see slot complexity
        address who, // contract
        bytes32 set
    ) public {
        // calldata to test against
        bytes4 fsig = bytes4(keccak256(bytes(sig)));
        bytes memory dat = flatten(ins);
        bytes memory cald = abi.encodePacked(fsig, dat);

        // iterate thru slots
        for (uint256 i = 0; i < 30; i++) {
            bytes32 slot;
            if (ins.length > 0) {
                for (uint256 j = 0; j < ins.length; j++) {
                    if (j != 0) {
                        slot = keccak256(abi.encode(ins[j], slot));
                    } else {
                        slot = keccak256(abi.encode(ins[j], uint(i)));
                    }
                }
            } else {
                // no ins, so should be flat
                slot = bytes32(i);
            }
            // load slot
            bytes32 prev = hevm.load(who, slot);
            // store
            hevm.store(who, slot, set);
            // call
            (bool pass, bytes memory rdat) = who.staticcall(cald);
            pass; // ssh
            bytes32 fdat = bytesToBytes32(rdat, 0);
            // check if good
            if (fdat == set) {
                slots[who][fsig] = i;
                finds[who][fsig] = true;
                hevm.store(who, slot, prev);
                emit SlotFound(who, sig, i);
                break;
            }
            // reset storage
            hevm.store(who, slot, prev);
        }

        require(finds[who][fsig], ""!found"");
    }

    /// @notice write to an arbitrary slot given a function signature
    function writ(
        string memory sig, // signature to check agains
        bytes32[] memory ins, // see slot complexity
        uint256 depth, // see slot complexity
        address who, // contract
        bytes32 set // value to set storage as
    ) public {
        bytes4 fsig = sigs(sig);

        require(finds[who][fsig], ""!found"");
        bytes32 slot;
        if (ins.length > 0) {
            for (uint256 j = 0; j < ins.length; j++) {
                if (j != 0) {
                    slot = keccak256(abi.encode(ins[j], slot));
                } else {
                    slot = keccak256(abi.encode(ins[j], slots[who][fsig]));
                }
            }
        } else {
            // no ins, so should be flat
            slot = bytes32(slots[who][fsig]);
        }
        // add depth -- noop if 0
        slot = bytes32(uint256(slot) + depth);
        // set storage
        hevm.store(who, slot, set);
    }

    function write_flat(address who, string memory sig, uint256 value) public {
        bytes32[] memory ins = new bytes32[](0);
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                ins,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            ins,
            0,
            who,
            bytes32(value)
        );
    }

    function write_flat(address who, string memory sig, address value) public {
        bytes32[] memory ins = new bytes32[](0);
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                ins,
                who,
                bytes32(uint256(uint160(0xaaaCfBec6a24756c20D41914f2CABA817C0d8521)))
            );
        }
        writ(
            sig,
            ins,
            0,
            who,
            bytes32(uint256(uint160(value)))
        );
    }

    function write_map(address who, string memory sig, uint256 key, uint256 value) public {
        bytes32[] memory keys = new bytes32[](1);
        keys[0] = bytes32(uint256(key));
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            0,
            who,
            bytes32(value)
        );
    }

    function write_map(address who, string memory sig, uint256 key, address value) public {
        bytes32[] memory keys = new bytes32[](1);
        keys[0] = bytes32(uint256(uint160(key)));
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            0,
            who,
            bytes32(uint256(uint160(value)))
        );
    }


    function write_map(address who, string memory sig, address key, uint256 value) public {
        bytes32[] memory keys = new bytes32[](1);
        keys[0] = bytes32(uint256(uint160(key)));
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            0,
            who,
            bytes32(value)
        );
    }

    function write_map(address who, string memory sig, address key, address value) public {
        bytes32[] memory keys = new bytes32[](1);
        keys[0] = bytes32(uint256(uint160(key)));
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            0,
            who,
            bytes32(uint256(uint160(value)))
        );
    }

    function write_deep_map(address who, string memory sig, bytes32[] memory keys, uint256 value) public {
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            0,
            who,
            bytes32(value)
        );
    }

    function write_deep_map(address who, string memory sig, bytes32[] memory keys, address value) public {
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            0,
            who,
            bytes32(uint256(uint160(value)))
        );
    }

    function write_deep_map_struct(address who, string memory sig, bytes32[] memory keys, uint256 value, uint256 depth) public {
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            depth,
            who,
            bytes32(value)
        );
    }

    function write_deep_map_struct(address who, string memory sig, bytes32[] memory keys, address value, uint256 depth) public {
        if (!finds[who][sigs(sig)]) {
            find(
                sig,
                keys,
                who,
                bytes32(uint256(13371337))
            );
        }
        writ(
            sig,
            keys,
            depth,
            who,
            bytes32(uint256(uint160(value)))
        );
    }

    function bytesToBytes32(bytes memory b, uint offset) private pure returns (bytes32) {
        bytes32 out;

        for (uint i = 0; i < 32; i++) {
            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
        }
        return out;
    }

    function flatten(bytes32[] memory b) public pure returns (bytes memory)
    {
        bytes memory result = new bytes(b.length * 32);
        for (uint256 i = 0; i < b.length; i++) {
            bytes32 k = b[i];
            assembly {
                mstore(add(result, add(32, mul(32, i))), k)
            }
        }

        return result;
    }

    // call this to speed up on known storage slots. See SlotFound and add to setup()
    function addKnownHEVM(address who, bytes4 fsig, uint slot) public {
        slots[who][fsig] = slot;
        finds[who][fsig] = true;
    }
}",2134
RealWorld_TA_62_RolesAuthority.t_RealWorld_20240808155106.log,62,RolesAuthority.t,97573,2138,99711,75.0,0.530625,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {MockAuthChild} from ""./utils/mocks/MockAuthChild.sol"";

import {Auth, Authority} from ""../auth/Auth.sol"";
import {RolesAuthority} from ""../auth/authorities/RolesAuthority.sol"";

contract RolesAuthorityTest is DSTestPlus {
    RolesAuthority roles;
    MockAuthChild mockAuthChild;

    function setUp() public {
        roles = new RolesAuthority(address(this), Authority(address(0)));
        mockAuthChild = new MockAuthChild();

        mockAuthChild.setAuthority(roles);
        mockAuthChild.setOwner(DEAD_ADDRESS);
    }

    function invariantOwner() public {
        assertEq(roles.owner(), address(this));
        assertEq(mockAuthChild.owner(), DEAD_ADDRESS);
    }

    function invariantAuthority() public {
        assertEq(address(roles.authority()), address(0));
        assertEq(address(mockAuthChild.authority()), address(roles));
    }

    function testSanityChecks() public {
        assertEq(roles.getUserRoles(address(this)), bytes32(0));
        assertFalse(roles.isUserRoot(address(this)));
        assertFalse(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        try mockAuthChild.updateFlag() {
            fail(""Trust Authority Allowed Attacker To Update Flag"");
        } catch {}
    }

    function testBasics() public {
        uint8 rootRole = 0;
        uint8 adminRole = 1;
        uint8 modRole = 2;
        uint8 userRole = 3;

        roles.setUserRole(address(this), rootRole, true);
        roles.setUserRole(address(this), adminRole, true);

        assertEq32(
            0x0000000000000000000000000000000000000000000000000000000000000003,
            roles.getUserRoles(address(this))
        );

        roles.setRoleCapability(adminRole, address(mockAuthChild), MockAuthChild.updateFlag.selector, true);
        assertTrue(roles.doesRoleHaveCapability(adminRole, address(mockAuthChild), MockAuthChild.updateFlag.selector));
        assertTrue(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        mockAuthChild.updateFlag();

        roles.setRoleCapability(adminRole, address(mockAuthChild), MockAuthChild.updateFlag.selector, false);
        assertFalse(roles.doesRoleHaveCapability(adminRole, address(mockAuthChild), MockAuthChild.updateFlag.selector));
        assertFalse(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        assertTrue(roles.doesUserHaveRole(address(this), rootRole));
        assertTrue(roles.doesUserHaveRole(address(this), adminRole));

        assertFalse(roles.doesUserHaveRole(address(this), modRole));
        assertFalse(roles.doesUserHaveRole(address(this), userRole));
    }

    function testRoot() public {
        assertFalse(roles.isUserRoot(address(this)));
        assertFalse(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        roles.setRootUser(address(this), true);
        assertTrue(roles.isUserRoot(address(this)));
        assertTrue(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        roles.setRootUser(address(this), false);
        assertFalse(roles.isUserRoot(address(this)));
        assertFalse(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));
    }

    function testPublicCapabilities() public {
        assertFalse(roles.isCapabilityPublic(address(mockAuthChild), MockAuthChild.updateFlag.selector));
        assertFalse(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        roles.setPublicCapability(address(mockAuthChild), MockAuthChild.updateFlag.selector, true);
        assertTrue(roles.isCapabilityPublic(address(mockAuthChild), MockAuthChild.updateFlag.selector));
        assertTrue(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));

        roles.setPublicCapability(address(mockAuthChild), MockAuthChild.updateFlag.selector, false);
        assertFalse(roles.isCapabilityPublic(address(mockAuthChild), MockAuthChild.updateFlag.selector));
        assertFalse(roles.canCall(address(this), address(mockAuthChild), MockAuthChild.updateFlag.selector));
    }
}",903
RealWorld_TA_62_CREATE3_RealWorld_20240808162749.log,62,CREATE3,50994,1641,52635,70.0,0.28779,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

import {Bytes32AddressLib} from ""./Bytes32AddressLib.sol"";

/// @notice Deploy to deterministic addresses without an initcode factor.
/// @author Modified from 0xSequence (https://github.com/0xsequence/create3/blob/master/contracts/Create3.sol)
library CREATE3 {
    using Bytes32AddressLib for bytes32;

    bytes internal constant PROXY_BYTECODE = hex""67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3"";

    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);

    function deploy(bytes32 salt, bytes memory creationCode) internal returns (address deployed) {
        bytes memory proxyChildBytecode = PROXY_BYTECODE;

        deployed = getDeployed(salt);

        address proxy;
        assembly {
            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)
        }
        require(proxy != address(0), ""DEPLOYMENT_FAILED"");

        (bool success, ) = proxy.call(creationCode);
        require(success && deployed.code.length != 0, ""INITIALIZATION_FAILED"");
    }

    function getDeployed(bytes32 salt) internal view returns (address) {
        address proxy = keccak256(
            abi.encodePacked(
                // Prefix:
                bytes1(0xFF),
                // Creator:
                address(this),
                // Salt:
                salt,
                // Bytecode hash:
                PROXY_BYTECODE_HASH
            )
        ).fromLast20Bytes();

        return keccak256(abi.encodePacked(hex""d6_94"", proxy, hex""01"")).fromLast20Bytes();
    }
}",388
RealWorld_TA_62_Auth.t_RealWorld_20240808155346.log,62,Auth.t,52993,2462,55455,77.0,0.314205,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {MockAuthChild} from ""./utils/mocks/MockAuthChild.sol"";

import {Auth, Authority} from ""../auth/Auth.sol"";

contract BooleanAuthority is Authority {
    bool yes;

    constructor(bool _yes) {
        yes = _yes;
    }

    function canCall(
        address,
        address,
        bytes4
    ) public view override returns (bool) {
        return yes;
    }
}

contract AuthTest is DSTestPlus {
    MockAuthChild mockAuthChild;

    function setUp() public {
        mockAuthChild = new MockAuthChild();
    }

    function invariantOwner() public {
        assertEq(mockAuthChild.owner(), address(this));
    }

    function invariantAuthority() public {
        assertEq(address(mockAuthChild.authority()), address(0));
    }

    function testFailNonOwner1() public {
        mockAuthChild.setOwner(address(0));
        mockAuthChild.updateFlag();
    }

    function testFailNonOwner2() public {
        mockAuthChild.setOwner(address(0));
        mockAuthChild.setOwner(address(0));
    }

    function testFailRejectingAuthority1() public {
        mockAuthChild.setAuthority(Authority(address(new BooleanAuthority(false))));
        mockAuthChild.setOwner(address(0));
        mockAuthChild.updateFlag();
    }

    function testFailRejectingAuthority2() public {
        mockAuthChild.setAuthority(Authority(address(new BooleanAuthority(false))));
        mockAuthChild.setOwner(address(0));
        mockAuthChild.setOwner(address(0));
    }

    function testAcceptingOwner() public {
        mockAuthChild.setAuthority(Authority(address(new BooleanAuthority(true))));
        mockAuthChild.setOwner(address(0));
        mockAuthChild.updateFlag();
    }
}",399
RealWorld_TA_62_MockERC20_RealWorld_20240808161307.log,62,MockERC20,29445,2746,32191,81.0,0.202145,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import {ERC20} from ""../../../tokens/ERC20.sol"";

contract MockERC20 is ERC20 {
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) ERC20(_name, _symbol, _decimals) {}

    function mint(address to, uint256 value) public virtual {
        _mint(to, value);
    }

    function burn(address from, uint256 value) public virtual {
        _burn(from, value);
    }
}",125
RealWorld_TA_62_CREATE3.t_RealWorld_20240808160218.log,62,CREATE3.t,65210,1826,67036,72.0,0.36257,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {MockERC20} from ""./utils/mocks/MockERC20.sol"";
import {MockAuthChild} from ""./utils/mocks/MockAuthChild.sol"";
import {MockTrustChild} from ""./utils/mocks/MockTrustChild.sol"";

import {CREATE3} from ""../utils/CREATE3.sol"";

contract CREATE3Test is DSTestPlus {
    function testDeployERC20() public {
        bytes32 salt = keccak256(bytes(""A salt!""));

        MockERC20 deployed = MockERC20(
            CREATE3.deploy(salt, abi.encodePacked(type(MockERC20).creationCode, abi.encode(""Mock Token"", ""MOCK"", 18)))
        );

        assertEq(address(deployed), CREATE3.getDeployed(salt));

        assertEq(deployed.name(), ""Mock Token"");
        assertEq(deployed.symbol(), ""MOCK"");
        assertEq(deployed.decimals(), 18);
    }

    function testFailDoubleDeploySameBytecode() public {
        bytes32 salt = keccak256(bytes(""Salty...""));

        CREATE3.deploy(salt, type(MockAuthChild).creationCode);
        CREATE3.deploy(salt, type(MockAuthChild).creationCode);
    }

    function testFailDoubleDeployDifferentBytecode() public {
        bytes32 salt = keccak256(bytes(""and sweet!""));

        CREATE3.deploy(salt, type(MockAuthChild).creationCode);
        CREATE3.deploy(salt, type(MockTrustChild).creationCode);
    }

    function testDeployERC20(
        bytes32 salt,
        string calldata name,
        string calldata symbol,
        uint8 decimals
    ) public {
        MockERC20 deployed = MockERC20(
            CREATE3.deploy(salt, abi.encodePacked(type(MockERC20).creationCode, abi.encode(name, symbol, decimals)))
        );

        assertEq(address(deployed), CREATE3.getDeployed(salt));

        assertEq(deployed.name(), name);
        assertEq(deployed.symbol(), symbol);
        assertEq(deployed.decimals(), decimals);
    }

    function testFailDoubleDeploySameBytecode(bytes32 salt, bytes calldata bytecode) public {
        CREATE3.deploy(salt, bytecode);
        CREATE3.deploy(salt, bytecode);
    }

    function testFailDoubleDeployDifferentBytecode(
        bytes32 salt,
        bytes calldata bytecode1,
        bytes calldata bytecode2
    ) public {
        CREATE3.deploy(salt, bytecode1);
        CREATE3.deploy(salt, bytecode2);
    }
}",565
RealWorld_TA_62_Hevm_RealWorld_20240808164700.log,62,Hevm,44469,1244,45713,76.0,0.247225,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

interface Hevm {
    // Set block.timestamp (newTimestamp)
    function warp(uint256) external;
    // Set block.height (newHeight)
    function roll(uint256) external;
    // Loads a storage slot from an address (who, slot)
    function load(address,bytes32) external returns (bytes32);
    // Stores a value to an address' storage slot, (who, slot, value)
    function store(address,bytes32,bytes32) external;
    // Signs data, (privateKey, digest) => (r, v, s)
    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);
    // Gets address for a given private key, (privateKey) => (address)
    function addr(uint256) external returns (address);
    // Performs a foreign function call via terminal, (stringInputs) => (result)
    function ffi(string[] calldata) external returns (bytes memory);
    // Calls another contract with a specified `msg.sender`, (newSender, contract, input) => (success, returnData)
    function prank(address, address, bytes calldata) external payable returns (bool, bytes memory);
    // Sets an address' balance, (who, newBalance)
    function deal(address, uint256) external;
    // Sets an address' code, (who, newCode)
    function etch(address, bytes calldata) external;
}",314
RealWorld_TA_62_TrustAuthority_RealWorld_20240808162133.log,62,TrustAuthority,29796,1699,31495,68.0,0.18296,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

import {Trust} from ""../Trust.sol"";
import {Authority} from ""../Auth.sol"";

/// @notice Simple Authority that allows a Trust to be used as an Authority.
/// @author Original work by Transmissions11 (https://github.com/transmissions11)
contract TrustAuthority is Trust, Authority {
    constructor(address initialUser) Trust(initialUser) {}

    function canCall(
        address user,
        address,
        bytes4
    ) public view virtual override returns (bool) {
        return isTrusted[user];
    }
}",130
RealWorld_TA_62_HEVMTokenExtension_RealWorld_20240808164236.log,62,HEVMTokenExtension,80434,3728,84162,116.0,0.47673,"pragma solidity ^0.8.0;

import ""./HEVMState.sol"";
import ""solmate/tokens/ERC20.sol"";
import { HEVMHelpers } from ""./HEVMHelpers.sol"";

interface Checkpointing {
	function numCheckpoints ( address ) external view returns ( uint32 );
	function checkpoints ( address, uint32 ) external view returns ( uint32 fromBlock, uint96 votes );
}

// example usage:
//
//
// 		function getUSDC(uint256 amount) {
// 			address usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
// 			write_balanceOf_ts(usdc, address(this), amount);
// 		}

contract TokenExtensions is HEVMHelpers {
	// update balanceOf and total supply
	function write_balanceOf_ts(address who, address acct, uint256 value) public {
        uint256 bal = ERC20(who).balanceOf(acct);
        write_map(who, ""balanceOf(address)"", acct, value);

        uint256 newTS;
        if (bal > value) {
            uint256 negdelta = bal - value;
            newTS = ERC20(who).totalSupply() - negdelta;
        } else {
            uint256 posdelta = value - bal;
            newTS = ERC20(who).totalSupply() + posdelta;
        }

        write_flat(who, ""totalSupply()"", newTS);
    }

    // update balance of
    function write_balanceOf(address who, address acct, uint256 value) public {
        uint256 bal = ERC20(who).balanceOf(acct);
        write_map(who, ""balanceOf(address)"", acct, value);
    }

    // update balance of underlying
    function write_balanceOfUnderlying(address who, address acct, uint256 value) public {
        write_map(who, ""balanceOfUnderlying(address)"", acct, value);
    }

    // manually writes a checkpoint in a checkpointing token
    function write_checkpoint(address checkpointToken, address account, uint256 checkpoint, uint256 fromBlock, uint256 bal) public {
        bytes32[] memory keys = new bytes32[](2);
        keys[0] = bytes32(uint256(uint160(account)));
        keys[1] = bytes32(uint256(uint32(checkpoint)));
        write_deep_map_struct(address(checkpointToken), ""checkpoints(address,uint32)"", keys, fromBlock, 0);
        write_deep_map_struct(address(checkpointToken), ""checkpoints(address,uint32)"", keys, bal, 1);
    }

    function write_last_checkpoint(address checkpointToken, address account, uint256 votes) public {
        uint256 lcp = Checkpointing(checkpointToken).numCheckpoints(account);
        if (lcp > 0) {
          lcp = lcp - 1;
        }
        bytes32[] memory keys = new bytes32[](2);
        keys[0] = bytes32(uint256(uint160(account)));
        keys[1] = bytes32(uint256(uint32(lcp)));
        write_deep_map_struct(checkpointToken, ""checkpoints(address,uint32)"", keys, votes, 1);
        if (lcp == 0) {
          write_deep_map_struct(checkpointToken, ""checkpoints(address,uint32)"", keys, block.number - 1, 0);
          write_map(checkpointToken, ""numCheckpoints(address)"", account, 1);
        }
    }
}",720
RealWorld_TA_62_SafeTransferLib_RealWorld_20240808163118.log,62,SafeTransferLib,53325,2612,55937,76.0,0.318865,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import {ERC20} from ""../tokens/ERC20.sol"";

/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.
/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)
library SafeTransferLib {
    /*///////////////////////////////////////////////////////////////
                            ETH OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function safeTransferETH(address to, uint256 amount) internal {
        (bool success, ) = to.call{value: amount}(new bytes(0));

        require(success, ""ETH_TRANSFER_FAILED"");
    }

    /*///////////////////////////////////////////////////////////////
                           ERC20 OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function safeTransferFrom(
        ERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, amount)
        );

        require(success && (data.length == 0 || abi.decode(data, (bool))), ""TRANSFER_FROM_FAILED"");
    }

    function safeTransfer(
        ERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(ERC20.transfer.selector, to, amount)
        );

        require(success && (data.length == 0 || abi.decode(data, (bool))), ""TRANSFER_FAILED"");
    }

    function safeApprove(
        ERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(
            abi.encodeWithSelector(ERC20.approve.selector, to, amount)
        );

        require(success && (data.length == 0 || abi.decode(data, (bool))), ""APPROVE_FAILED"");
    }
}",414
RealWorld_TA_62_TestHelpers_RealWorld_20240808164935.log,62,TestHelpers,67330,2847,70177,97.0,0.39359,"pragma solidity >=0.8.0;

import ""./HEVMTokenExtension.sol"";

contract TestHelpers is TokenExtensions {
    function expect_revert_with(
        address who,
        string memory sig,
        bytes memory args,
        string memory revert_string
    )
        public
    {
        bytes memory calld = abi.encodePacked(sigs(sig), args);
        (bool success, bytes memory ret) = who.call(calld);
        assertTrue(!success);
        string memory ret_revert_string = abi.decode(slice(5, ret.length, ret), (string));
        assertEq(ret_revert_string, revert_string);
    }

    // In a passing test, expect a revert with a string (takes a function signature and args and *is* payable)
    function expect_revert_with(
        address who,
        string memory sig,
        bytes memory args,
        uint256 value,
        string memory revert_string
    )
        public
    {
        bytes memory calld = abi.encodePacked(sigs(sig), args);
        (bool success, bytes memory ret) = who.call{value: value}(calld);
        assertTrue(!success);
        string memory ret_revert_string = abi.decode(slice(5, ret.length, ret), (string));
        assertEq(ret_revert_string, revert_string);
    }

    // pass as a 4byte function signature instead
    function expect_revert_with(
        address who,
        bytes4 sig,
        bytes memory args,
        string memory revert_string
    )
        public
    {
        bytes memory calld = abi.encodePacked(sig, args);
        (bool success, bytes memory ret) = who.call(calld);
        assertTrue(!success);
        string memory ret_revert_string = abi.decode(slice(5, ret.length, ret), (string));
        assertEq(ret_revert_string, revert_string);
    }

    function expect_revert(
        address who,
        bytes4 sig,
        bytes memory args
    )
        public
    {
        bytes memory calld = abi.encodePacked(sig, args);
        (bool success, bytes memory ret) = who.call(calld);
        assertTrue(!success);
    }

    function slice(uint256 begin, uint256 end, bytes memory text) public pure returns (bytes memory) {
       bytes memory a = new bytes(end - begin + 1);
       for(uint i=0 ; i <= end - begin; i++) {
           a[i] = bytes(text)[i + begin - 1];
       }
       return a;
    }

    function ff(uint256 x) public {
        hevm.warp(block.timestamp + x);
    }

    function rev(uint256 x) public {
        hevm.warp(block.timestamp - x);
    }
}",567
RealWorld_TA_62_WETH.t_RealWorld_20240808160333.log,62,WETH.t,97052,3393,100445,95.0,0.55312,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {DSInvariantTest} from ""./utils/DSInvariantTest.sol"";

import {SafeTransferLib} from ""../utils/SafeTransferLib.sol"";

import {WETH} from ""../tokens/WETH.sol"";

contract WETHTest is DSTestPlus {
    WETH weth;

    function setUp() public {
        weth = new WETH();
    }

    function testDeposit() public {
        assertEq(weth.balanceOf(address(this)), 0);
        assertEq(weth.totalSupply(), 0);

        SafeTransferLib.safeTransferETH(address(weth), 1 ether);

        assertEq(weth.balanceOf(address(this)), 1 ether);
        assertEq(weth.totalSupply(), 1 ether);
    }

    function testFallbackDeposit() public {
        assertEq(weth.balanceOf(address(this)), 0);
        assertEq(weth.totalSupply(), 0);

        weth.deposit{value: 1 ether}();

        assertEq(weth.balanceOf(address(this)), 1 ether);
        assertEq(weth.totalSupply(), 1 ether);
    }

    function testWithdraw() public {
        uint256 startingBalance = address(this).balance;

        weth.deposit{value: 1 ether}();

        weth.withdraw(1 ether);

        uint256 balanceAfterWithdraw = address(this).balance;

        assertEq(balanceAfterWithdraw, startingBalance);
        assertEq(weth.balanceOf(address(this)), 0);
        assertEq(weth.totalSupply(), 0);
    }

    function testPartialWithdraw() public {
        weth.deposit{value: 1 ether}();

        uint256 balanceBeforeWithdraw = address(this).balance;

        weth.withdraw(0.5 ether);

        uint256 balanceAfterWithdraw = address(this).balance;

        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + 0.5 ether);
        assertEq(weth.balanceOf(address(this)), 0.5 ether);
        assertEq(weth.totalSupply(), 0.5 ether);
    }

    function testDeposit(uint256 amount) public {
        if (amount > address(this).balance) return;

        assertEq(weth.balanceOf(address(this)), 0);
        assertEq(weth.totalSupply(), 0);

        SafeTransferLib.safeTransferETH(address(weth), amount);

        assertEq(weth.balanceOf(address(this)), amount);
        assertEq(weth.totalSupply(), amount);
    }

    function testFallbackDeposit(uint256 amount) public {
        if (amount > address(this).balance) return;

        assertEq(weth.balanceOf(address(this)), 0);
        assertEq(weth.totalSupply(), 0);

        weth.deposit{value: amount}();

        assertEq(weth.balanceOf(address(this)), amount);
        assertEq(weth.totalSupply(), amount);
    }

    function testWithdraw(uint256 depositAmount, uint256 withdrawAmount) public {
        if (depositAmount > address(this).balance) return;
        if (withdrawAmount > depositAmount) return;

        weth.deposit{value: depositAmount}();

        uint256 balanceBeforeWithdraw = address(this).balance;

        weth.withdraw(withdrawAmount);

        uint256 balanceAfterWithdraw = address(this).balance;

        assertEq(balanceAfterWithdraw, balanceBeforeWithdraw + withdrawAmount);
        assertEq(weth.balanceOf(address(this)), depositAmount - withdrawAmount);
        assertEq(weth.totalSupply(), depositAmount - withdrawAmount);
    }

    receive() external payable {}
}

contract WETHInvariants is DSTestPlus, DSInvariantTest {
    WETHTester wethTester;
    WETH weth;

    function setUp() public {
        weth = new WETH();
        wethTester = new WETHTester{value: address(this).balance}(weth);

        addTargetContract(address(wethTester));
    }

    function invariantTotalSupplyEqualsBalance() public {
        assertEq(address(weth).balance, weth.totalSupply());
    }
}

contract WETHTester {
    WETH weth;

    constructor(WETH _weth) payable {
        weth = _weth;
    }

    function deposit(uint256 amount) public {
        weth.deposit{value: amount}();
    }

    function fallbackDeposit(uint256 amount) public {
        SafeTransferLib.safeTransferETH(address(weth), amount);
    }

    function withdraw(uint256 amount) public {
        weth.withdraw(amount);
    }

    receive() external payable {}
}",956
RealWorld_TA_62_DSInvariantTest_RealWorld_20240808160757.log,62,DSInvariantTest,26834,2320,29154,75.0,0.18057,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

contract DSInvariantTest {
    address[] private targets;

    function targetContracts() public view virtual returns (address[] memory) {
        require(targets.length > 0, ""NO_TARGET_CONTRACTS"");

        return targets;
    }

    function addTargetContract(address newTargetContract) internal virtual {
        targets.push(newTargetContract);
    }
}",91
RealWorld_TA_62_ReentrancyGuard.t_RealWorld_20240808160510.log,62,ReentrancyGuard.t,44780,3689,48469,93.0,0.29768,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";

import {ReentrancyGuard} from ""../utils/ReentrancyGuard.sol"";

contract RiskyContract is ReentrancyGuard {
    uint256 public enterTimes;

    function unprotectedCall() public {
        enterTimes++;
        if (enterTimes > 1) return;
        protectedCall();
    }

    function protectedCall() public nonReentrant {
        enterTimes++;
        if (enterTimes > 1) return;
        protectedCall();
    }

    function overprotectedCall() public nonReentrant {}
}

contract ReentrancyGuardTest is DSTestPlus {
    RiskyContract riskyContract;

    function setUp() public {
        riskyContract = new RiskyContract();
    }

    function invariantReentrancyStatusAlways1() public {
        assertEq(uint256(hevm.load(address(riskyContract), 0)), 1);
    }

    function testFailUnprotectedCall() public {
        riskyContract.unprotectedCall();

        assertEq(riskyContract.enterTimes(), 1);
    }

    function testProtectedCall() public {
        try riskyContract.protectedCall() {
            fail(""Reentrancy Guard Failed To Stop Attacker"");
        } catch {}
    }

    function testNoReentrancy() public {
        riskyContract.overprotectedCall();
    }
}",299
RealWorld_TA_62_MockTrustChild_RealWorld_20240808161135.log,62,MockTrustChild,24880,2718,27598,90.0,0.17876,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

import {Trust} from ""../../../auth/Trust.sol"";

contract MockTrustChild is Trust(msg.sender) {
    bool public flag;

    function updateFlag() public virtual requiresTrust {
        flag = true;
    }
}",66
RealWorld_TA_62_TestToken_RealWorld_20240808165340.log,62,TestToken,24859,1803,26662,78.0,0.160355,"pragma solidity ^0.8.0;

import ""solmate/tokens/ERC20.sol"";

contract TestToken is ERC20 {

	constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) 
    	ERC20(_name, _symbol, _decimals) 
    	public
    {

    }
}",74
RealWorld_TA_62_LockeERC20_RealWorld_20240808163859.log,62,LockeERC20,139311,2666,141977,104.0,0.749875,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import ""solmate/tokens/ERC20.sol"";

/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
abstract contract LockeERC20 {
    /*///////////////////////////////////////////////////////////////
                                  EVENTS
    //////////////////////////////////////////////////////////////*/

    event Transfer(address indexed from, address indexed to, uint256 amount);

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /*///////////////////////////////////////////////////////////////
                             METADATA STORAGE
    //////////////////////////////////////////////////////////////*/

    string public name;

    string public symbol;

    uint8 public immutable decimals;

    uint32 public immutable transferStartTime;

    /*///////////////////////////////////////////////////////////////
                              ERC20 STORAGE
    //////////////////////////////////////////////////////////////*/

    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;

    /*///////////////////////////////////////////////////////////////
                           EIP-2612 STORAGE
    //////////////////////////////////////////////////////////////*/

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    uint256 internal immutable INITIAL_CHAIN_ID;

    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;

    mapping(address => uint256) public nonces;

    /*///////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        address depositToken,
        uint256 streamId,
        uint32 endStream
    ) {

        // locke + depositTokenName + streamId = lockeUSD Coin-1
        name = string(abi.encodePacked(""locke"", ERC20(depositToken).name(), "": "", toString(streamId)));
        // locke + Symbol + streamId = lockeUSDC1
        // TODO: we could have start_time+stream_duration+depositlocktime as maturity-date
        // i.e. lockeETH8-AUG-14-2022
        symbol = string(abi.encodePacked(""locke"", ERC20(depositToken).symbol(), toString(streamId)));
        decimals = 18;

        transferStartTime = endStream;

        INITIAL_CHAIN_ID = block.chainid;
        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    }

    /*///////////////////////////////////////////////////////////////
                              ERC20 LOGIC
    //////////////////////////////////////////////////////////////*/

    modifier transferabilityDelay {
        // ensure the time is after start time
        require(block.timestamp >= transferStartTime, ""stream"");
        _;
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        allowance[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    function transfer(address to, uint256 amount) transferabilityDelay public virtual returns (bool) {
        balanceOf[msg.sender] -= amount;

        // This is safe because the sum of all user
        // balances can't exceed type(uint256).max!
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(msg.sender, to, amount);

        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) transferabilityDelay public virtual returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }

        balanceOf[from] -= amount;

        // This is safe because the sum of all user
        // balances can't exceed type(uint256).max!
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);

        return true;
    }

    /*///////////////////////////////////////////////////////////////
                              EIP-2612 LOGIC
    //////////////////////////////////////////////////////////////*/

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");

        // This is safe because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            bytes32 digest = keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    DOMAIN_SEPARATOR(),
                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
                )
            );

            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_PERMIT_SIGNATURE"");

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }

    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
    }

    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                    keccak256(bytes(name)),
                    keccak256(bytes(""1"")),
                    block.chainid,
                    address(this)
                )
            );
    }

    /*///////////////////////////////////////////////////////////////
                       INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;

        // This is safe because the sum of all user
        // balances can't exceed type(uint256).max!
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal virtual {
        balanceOf[from] -= amount;

        // This is safe because a user won't ever
        // have a balance larger than totalSupply!
        unchecked {
            totalSupply -= amount;
        }

        emit Transfer(from, address(0), amount);
    }


    // Helpers
    function toString(uint _i)
        internal
        pure
        returns (string memory) 
    {
        if (_i == 0) {
            return ""0"";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}",1431
RealWorld_TA_62_Locke.t_RealWorld_20240808164045.log,62,Locke.t,741291,68,741359,108.0,3.707815,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""./utils/LockeTest.sol"";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint(""blocktime"", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint(""nextStream"", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs(""fundStream(uint112)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                ""amt""
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                ""time""
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint(""gas_usage_no_fee"", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint(""nextStream2"", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint(""gas_usage_w_fee"", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs(""stake(uint112)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                ""amt""
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                ""!stream""
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                ""erc""
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs(""createIncentive(address,uint112)"");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            ""inc""
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs(""claimDepositTokens(uint112)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                ""sale""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs(""claimDepositTokens(uint112)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                ""amt""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs(""claimDepositTokens(uint112)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                ""lock""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs(""claimDepositTokens(uint112)"");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs(""creatorClaimSoldTokens(address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                ""!sale""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs(""creatorClaimSoldTokens(address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                ""claimed""
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs(""creatorClaimSoldTokens(address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                ""!creator""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs(""creatorClaimSoldTokens(address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                ""stream""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs(""claimFees(address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                ""stream""
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs(""flashloan(address,address,uint112,bytes)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, """"),
                ""erc""
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                ""f4""
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                ""f1""
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs(""recoverTokens(address,address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                ""time""
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs(""recoverTokens(address,address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                ""time""
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs(""recoverTokens(address,address)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                ""stream""
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs(""arbitraryCall(address,bytes)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), """"),
                ""inc""
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), """"),
                ""erc""
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs(""transfer(address,uint256)""), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs(""transfer(address,uint256)""), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs(""manualBurn(address,address)""), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs(""arbitraryCall(address,bytes)"");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                ""erc""
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs(""createStream(address,address,uint32,uint32,uint32,uint32,bool)"");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                ""past""
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    ""stream""
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                ""stream""
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                ""lock""
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                ""reward""
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), ""lockeTest Token B: 0"");
            assertEq(stream.symbol(), ""lockeTTB0"");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), ""lockeTest Token B: 1"");
            assertEq(stream.symbol(), ""lockeTTB1"");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), ""gov()"", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs(""updateStreamParams((uint32,uint32,uint32,uint32))""),
            abi.encode(newParams),
            ""!gov""
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), ""gov()"", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), ""gov()"", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs(""updateFeeParams((uint16,bool))""),
            abi.encode(newParams),
            ""!gov""
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), ""gov()"", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs(""updateFeeParams((uint16,bool))""),
            abi.encode(newParams),
            ""fee""
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}",8585
RealWorld_TA_62_SafeCastLib_RealWorld_20240808162901.log,62,SafeCastLib,33752,1198,34950,63.0,0.19272,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

/// @notice Safe unsigned integer casting library that reverts on overflow.
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)
library SafeCastLib {
    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {
        require(x <= type(uint224).max);

        y = uint224(x);
    }

    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {
        require(x <= type(uint128).max);

        y = uint128(x);
    }

    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {
        require(x <= type(uint64).max);

        y = uint64(x);
    }
}",188
RealWorld_TA_62_SafeTransferLib.t_RealWorld_20240808160042.log,62,SafeTransferLib.t,217617,2845,220462,93.0,1.144985,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""weird-erc20/ERC20.sol"";
import {ReturnsFalseToken} from ""weird-erc20/ReturnsFalse.sol"";
import {MissingReturnToken} from ""weird-erc20/MissingReturns.sol"";
import {TransferFromSelfToken} from ""weird-erc20/TransferFromSelf.sol"";
import {PausableToken} from ""weird-erc20/Pausable.sol"";

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";

import {SafeTransferLib, ERC20 as SolmateERC20} from ""../utils/SafeTransferLib.sol"";

contract SafeTransferLibTest is DSTestPlus {
    ReturnsFalseToken returnsFalse;
    MissingReturnToken missingReturn;
    TransferFromSelfToken transferFromSelf;
    PausableToken pausable;

    ERC20 erc20;

    function setUp() public {
        returnsFalse = new ReturnsFalseToken(type(uint256).max);
        missingReturn = new MissingReturnToken(type(uint256).max);
        transferFromSelf = new TransferFromSelfToken(type(uint256).max);

        pausable = new PausableToken(type(uint256).max);
        pausable.stop();

        erc20 = new ERC20(type(uint256).max);
    }

    function testTransferWithMissingReturn() public {
        verifySafeTransfer(address(missingReturn), address(0xBEEF), 1e18);
    }

    function testTransferWithTransferFromSelf() public {
        verifySafeTransfer(address(transferFromSelf), address(0xBEEF), 1e18);
    }

    function testTransferWithStandardERC20() public {
        verifySafeTransfer(address(erc20), address(0xBEEF), 1e18);
    }

    function testTransferWithNonContract() public {
        SafeTransferLib.safeTransfer(SolmateERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);
    }

    function testTransferFromWithMissingReturn() public {
        verifySafeTransferFrom(address(missingReturn), address(0xFEED), address(0xBEEF), 1e18);
    }

    function testTransferFromWithTransferFromSelf() public {
        verifySafeTransferFrom(address(transferFromSelf), address(0xFEED), address(0xBEEF), 1e18);
    }

    function testTransferFromWithStandardERC20() public {
        verifySafeTransferFrom(address(erc20), address(0xFEED), address(0xBEEF), 1e18);
    }

    function testTransferFromWithNonContract() public {
        SafeTransferLib.safeTransferFrom(SolmateERC20(address(0xBADBEEF)), address(0xFEED), address(0xBEEF), 1e18);
    }

    function testApproveWithMissingReturn() public {
        verifySafeApprove(address(missingReturn), address(0xBEEF), 1e18);
    }

    function testApproveWithTransferFromSelf() public {
        verifySafeApprove(address(transferFromSelf), address(0xBEEF), 1e18);
    }

    function testApproveWithStandardERC20() public {
        verifySafeApprove(address(transferFromSelf), address(0xBEEF), 1e18);
    }

    function testApproveWithNonContract() public {
        SafeTransferLib.safeApprove(SolmateERC20(address(0xBADBEEF)), address(0xBEEF), 1e18);
    }

    function testTransferETH() public {
        SafeTransferLib.safeTransferETH(address(0xBEEF), 1e18);
    }

    function testFailTransferWithReturnsFalse() public {
        verifySafeTransfer(address(returnsFalse), address(0xBEEF), 1e18);
    }

    function testFailTransferWithPausable() public {
        verifySafeTransfer(address(pausable), address(0xBEEF), 1e18);
    }

    function testFailTransferFromWithReturnsFalse() public {
        verifySafeTransferFrom(address(returnsFalse), address(0xFEED), address(0xBEEF), 1e18);
    }

    function testFailTransferFromWithPausable() public {
        verifySafeTransferFrom(address(pausable), address(0xFEED), address(0xBEEF), 1e18);
    }

    function testFailApproveWithReturnsFalse() public {
        verifySafeApprove(address(returnsFalse), address(0xBEEF), 1e18);
    }

    function testFailApproveWithPausable() public {
        verifySafeApprove(address(pausable), address(0xBEEF), 1e18);
    }

    function testTransferWithMissingReturn(address to, uint256 amount) public {
        verifySafeTransfer(address(missingReturn), to, amount);
    }

    function testTransferWithTransferFromSelf(address to, uint256 amount) public {
        verifySafeTransfer(address(transferFromSelf), to, amount);
    }

    function testTransferWithStandardERC20(address to, uint256 amount) public {
        verifySafeTransfer(address(erc20), to, amount);
    }

    function testFailTransferETHToContractWithoutFallback() public {
        SafeTransferLib.safeTransferETH(address(this), 1e18);
    }

    function testTransferWithNonContract(
        address nonContract,
        address to,
        uint256 amount
    ) public {
        if (nonContract.code.length > 0) return;

        if (uint256(uint160(nonContract)) <= 18) return; // Some precompiles cause reverts.

        SafeTransferLib.safeTransfer(SolmateERC20(nonContract), to, amount);
    }

    function testTransferFromWithMissingReturn(
        address from,
        address to,
        uint256 amount
    ) public {
        verifySafeTransferFrom(address(missingReturn), from, to, amount);
    }

    function testTransferFromWithTransferFromSelf(
        address from,
        address to,
        uint256 amount
    ) public {
        verifySafeTransferFrom(address(transferFromSelf), from, to, amount);
    }

    function testTransferFromWithStandardERC20(
        address from,
        address to,
        uint256 amount
    ) public {
        verifySafeTransferFrom(address(erc20), from, to, amount);
    }

    function testTransferFromWithNonContract(
        address nonContract,
        address from,
        address to,
        uint256 amount
    ) public {
        if (nonContract.code.length > 0) return;

        if (uint256(uint160(nonContract)) <= 18) return; // Some precompiles cause reverts.

        SafeTransferLib.safeTransferFrom(SolmateERC20(nonContract), from, to, amount);
    }

    function testApproveWithMissingReturn(address to, uint256 amount) public {
        verifySafeApprove(address(missingReturn), to, amount);
    }

    function testApproveWithTransferFromSelf(address to, uint256 amount) public {
        verifySafeApprove(address(transferFromSelf), to, amount);
    }

    function testApproveWithStandardERC20(address to, uint256 amount) public {
        verifySafeApprove(address(transferFromSelf), to, amount);
    }

    function testApproveWithNonContract(
        address nonContract,
        address to,
        uint256 amount
    ) public {
        if (nonContract.code.length > 0) return;

        if (uint256(uint160(nonContract)) <= 18) return; // Some precompiles cause reverts.

        SafeTransferLib.safeApprove(SolmateERC20(nonContract), to, amount);
    }

    function testTransferETH(address recipient, uint256 amount) public {
        if (uint256(uint160(recipient)) <= 18) return; // Some precompiles cause reverts.

        amount %= address(this).balance;

        SafeTransferLib.safeTransferETH(recipient, amount);
    }

    function testFailTransferWithReturnsFalse(address to, uint256 amount) public {
        verifySafeTransfer(address(returnsFalse), to, amount);
    }

    function testFailTransferWithPausable(address to, uint256 amount) public {
        verifySafeTransfer(address(pausable), to, amount);
    }

    function testFailTransferFromWithReturnsFalse(
        address from,
        address to,
        uint256 amount
    ) public {
        verifySafeTransferFrom(address(returnsFalse), from, to, amount);
    }

    function testFailTransferFromWithPausable(
        address from,
        address to,
        uint256 amount
    ) public {
        verifySafeTransferFrom(address(pausable), from, to, amount);
    }

    function testFailApproveWithReturnsFalse(address to, uint256 amount) public {
        verifySafeApprove(address(returnsFalse), to, amount);
    }

    function testFailApproveWithPausable(address to, uint256 amount) public {
        verifySafeApprove(address(pausable), to, amount);
    }

    function testFailTransferETHToContractWithoutFallback(uint256 amount) public {
        SafeTransferLib.safeTransferETH(address(this), amount);
    }

    function verifySafeTransfer(
        address token,
        address to,
        uint256 amount
    ) internal {
        uint256 preBal = ERC20(token).balanceOf(to);
        SafeTransferLib.safeTransfer(SolmateERC20(address(token)), to, amount);
        uint256 postBal = ERC20(token).balanceOf(to);

        if (to == address(this)) {
            assertEq(preBal, postBal);
        } else {
            assertEq(postBal - preBal, amount);
        }
    }

    function verifySafeTransferFrom(
        address token,
        address from,
        address to,
        uint256 amount
    ) internal {
        forceApprove(token, from, address(this), amount);
        SafeTransferLib.safeTransfer(SolmateERC20(token), from, amount);

        uint256 preBal = ERC20(token).balanceOf(to);
        SafeTransferLib.safeTransferFrom(SolmateERC20(token), from, to, amount);
        uint256 postBal = ERC20(token).balanceOf(to);

        if (from == to) {
            assertEq(preBal, postBal);
        } else {
            assertEq(postBal - preBal, amount);
        }
    }

    function verifySafeApprove(
        address token,
        address to,
        uint256 amount
    ) internal {
        SafeTransferLib.safeApprove(SolmateERC20(address(token)), to, amount);

        assertEq(ERC20(token).allowance(address(this), to), amount);
    }

    function forceApprove(
        address token,
        address from,
        address to,
        uint256 amount
    ) internal {
        uint256 slot = token == address(erc20) || token == address(pausable) ? 3 : 2;

        hevm.store(
            token,
            keccak256(abi.encode(to, keccak256(abi.encode(from, uint256(slot))))),
            bytes32(uint256(amount))
        );

        assertEq(ERC20(token).allowance(from, to), amount, ""wrong allowance"");
    }
}",2387
RealWorld_TA_62_SafeCastLib.t_RealWorld_20240808160646.log,62,SafeCastLib.t,67176,1433,68609,69.0,0.36454,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";

import {SafeCastLib} from ""../utils/SafeCastLib.sol"";

contract SafeCastLibTest is DSTestPlus {
    function testSafeCastTo224() public {
        assertEq(SafeCastLib.safeCastTo224(2.5e45), 2.5e45);
        assertEq(SafeCastLib.safeCastTo224(2.5e27), 2.5e27);
    }

    function testSafeCastTo128() public {
        assertEq(SafeCastLib.safeCastTo128(2.5e27), 2.5e27);
        assertEq(SafeCastLib.safeCastTo128(2.5e18), 2.5e18);
    }

    function testSafeCastTo64() public {
        assertEq(SafeCastLib.safeCastTo64(2.5e18), 2.5e18);
        assertEq(SafeCastLib.safeCastTo64(2.5e17), 2.5e17);
    }

    function testFailSafeCastTo224() public pure {
        SafeCastLib.safeCastTo224(type(uint224).max + 1);
    }

    function testFailSafeCastTo128() public pure {
        SafeCastLib.safeCastTo128(type(uint128).max + 1);
    }

    function testFailSafeCastTo64() public pure {
        SafeCastLib.safeCastTo64(type(uint64).max + 1);
    }

    function testSafeCastTo224(uint256 x) public {
        x %= type(uint224).max;

        assertEq(SafeCastLib.safeCastTo224(x), x);
    }

    function testSafeCastTo128(uint256 x) public {
        x %= type(uint128).max;

        assertEq(SafeCastLib.safeCastTo128(x), x);
    }

    function testSafeCastTo64(uint256 x) public {
        x %= type(uint64).max;

        assertEq(SafeCastLib.safeCastTo64(x), x);
    }

    function testFailSafeCastTo224(uint256 x) public pure {
        if (type(uint224).max > x) revert();

        SafeCastLib.safeCastTo224(x);
    }

    function testFailSafeCastTo128(uint256 x) public pure {
        if (type(uint128).max > x) revert();

        SafeCastLib.safeCastTo128(x);
    }

    function testFailSafeCastTo64(uint256 x) public pure {
        if (type(uint64).max > x) revert();

        SafeCastLib.safeCastTo64(x);
    }
}",580
RealWorld_TA_62_Hevm_RealWorld_20240808161030.log,62,Hevm,29667,1171,30838,63.0,0.171755,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;
pragma abicoder v2;

interface Hevm {
    function warp(uint256) external;

    function roll(uint256) external;

    function store(
        address,
        bytes32,
        bytes32
    ) external;

    function load(address, bytes32) external returns (bytes32);

    function sign(uint256, bytes32)
        external
        returns (
            uint8,
            bytes32,
            bytes32
        );

    function addr(uint256) external returns (address);

    function ffi(string[] calldata) external returns (bytes memory);
}",137
RealWorld_TA_62_demo_RealWorld_20240808154651.log,62,demo,190044,1659,191703,80.0,0.9834,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.4.23;

import ""../src/test.sol"";

contract DemoTest is DSTest {
    function test_this() public pure {
        require(true);
    }
    function test_logs() public {
        emit log(""-- log(string)"");
        emit log(""a string"");

        emit log(""-- log_named_uint(string, uint)"");
        log_named_uint(""uint"", 512);

        emit log(""-- log_named_int(string, int)"");
        log_named_int(""int"", -512);

        emit log(""-- log_named_address(string, address)"");
        log_named_address(""address"", address(this));

        emit log(""-- log_named_bytes32(string, bytes32)"");
        log_named_bytes32(""bytes32"", ""a string"");

        emit log(""-- log_named_bytes(string, bytes)"");
        log_named_bytes(""bytes"", hex""cafefe"");

        emit log(""-- log_named_string(string, string)"");
        log_named_string(""string"", ""a string"");

        emit log(""-- log_named_decimal_uint(string, uint, uint)"");
        log_named_decimal_uint(""decimal uint"", 1.0e18, 18);

        emit log(""-- log_named_decimal_int(string, int, uint)"");
        log_named_decimal_int(""decimal int"", -1.0e18, 18);
    }
    event log_old_named_uint(bytes32,uint);
    function test_old_logs() public {
        log_old_named_uint(""key"", 500);
        log_named_bytes32(""bkey"", ""val"");
    }
    function test_trace() public view {
        this.echo(""string 1"", ""string 2"");
    }
    function test_multiline() public {
        emit log(""a multiline\\n"" ""string"");
        emit log(""a multiline "" ""string"");
        log_bytes(""a string"");
        log_bytes(""a multiline\n"" ""string"");
        log_bytes(""a multiline\\n"" ""string"");
        emit log(unicode"""");
        logs(hex""0000"");
        log_named_bytes(""0x0000"", hex""0000"");
        logs(hex""ff"");
    }
    function echo(string memory s1, string memory s2) public pure
        returns (string memory, string memory)
    {
        return (s1, s2);
    }

    function prove_this(uint x) public {
        log_named_uint(""sym x"", x);
        assertGt(x + 1, 0);
    }

    function test_logn() public {
        assembly {
            log0(0x01, 0x02)
            log1(0x01, 0x02, 0x03)
            log2(0x01, 0x02, 0x03, 0x04)
            log3(0x01, 0x02, 0x03, 0x04, 0x05)
        }
    }

    event MyEvent(uint, uint indexed, uint, uint indexed);
    function test_events() public {
        emit MyEvent(1, 2, 3, 4);
    }

    function test_asserts() public {
        string memory err = ""this test has failed!"";
        emit log(""## assertTrue(bool)\n"");
        assertTrue(false);
        emit log(""\n"");
        assertTrue(false, err);

        emit log(""\n## assertEq(address,address)\n"");
        assertEq(address(this), msg.sender);
        emit log(""\n"");
        assertEq(address(this), msg.sender, err);

        emit log(""\n## assertEq32(bytes32,bytes32)\n"");
        assertEq32(""bytes 1"", ""bytes 2"");
        emit log(""\n"");
        assertEq32(""bytes 1"", ""bytes 2"", err);

        emit log(""\n## assertEq(bytes32,bytes32)\n"");
        assertEq32(""bytes 1"", ""bytes 2"");
        emit log(""\n"");
        assertEq32(""bytes 1"", ""bytes 2"", err);

        emit log(""\n## assertEq(uint,uint)\n"");
        assertEq(uint(0), 1);
        emit log(""\n"");
        assertEq(uint(0), 1, err);

        emit log(""\n## assertEq(int,int)\n"");
        assertEq(-1, -2);
        emit log(""\n"");
        assertEq(-1, -2, err);

        emit log(""\n## assertEqDecimal(int,int,uint)\n"");
        assertEqDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertEqDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertEqDecimal(uint,uint,uint)\n"");
        assertEqDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertEqDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertGt(uint,uint)\n"");
        assertGt(uint(0), 0);
        emit log(""\n"");
        assertGt(uint(0), 0, err);

        emit log(""\n## assertGt(int,int)\n"");
        assertGt(-1, -1);
        emit log(""\n"");
        assertGt(-1, -1, err);

        emit log(""\n## assertGtDecimal(int,int,uint)\n"");
        assertGtDecimal(-2.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertGtDecimal(-2.0e18, -1.1e18, 18, err);

        emit log(""\n## assertGtDecimal(uint,uint,uint)\n"");
        assertGtDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertGtDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertGe(uint,uint)\n"");
        assertGe(uint(0), 1);
        emit log(""\n"");
        assertGe(uint(0), 1, err);

        emit log(""\n## assertGe(int,int)\n"");
        assertGe(-1, 0);
        emit log(""\n"");
        assertGe(-1, 0, err);

        emit log(""\n## assertGeDecimal(int,int,uint)\n"");
        assertGeDecimal(-2.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertGeDecimal(-2.0e18, -1.1e18, 18, err);

        emit log(""\n## assertGeDecimal(uint,uint,uint)\n"");
        assertGeDecimal(uint(1.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertGeDecimal(uint(1.0e18), 1.1e18, 18, err);

        emit log(""\n## assertLt(uint,uint)\n"");
        assertLt(uint(0), 0);
        emit log(""\n"");
        assertLt(uint(0), 0, err);

        emit log(""\n## assertLt(int,int)\n"");
        assertLt(-1, -1);
        emit log(""\n"");
        assertLt(-1, -1, err);

        emit log(""\n## assertLtDecimal(int,int,uint)\n"");
        assertLtDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertLtDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertLtDecimal(uint,uint,uint)\n"");
        assertLtDecimal(uint(2.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertLtDecimal(uint(2.0e18), 1.1e18, 18, err);

        emit log(""\n## assertLe(uint,uint)\n"");
        assertLe(uint(1), 0);
        emit log(""\n"");
        assertLe(uint(1), 0, err);

        emit log(""\n## assertLe(int,int)\n"");
        assertLe(0, -1);
        emit log(""\n"");
        assertLe(0, -1, err);

        emit log(""\n## assertLeDecimal(int,int,uint)\n"");
        assertLeDecimal(-1.0e18, -1.1e18, 18);
        emit log(""\n"");
        assertLeDecimal(-1.0e18, -1.1e18, 18, err);

        emit log(""\n## assertLeDecimal(uint,uint,uint)\n"");
        assertLeDecimal(uint(2.0e18), 1.1e18, 18);
        emit log(""\n"");
        assertLeDecimal(uint(2.0e18), 1.1e18, 18, err);

        emit log(""\n## assertEq(string,string)\n"");
        string memory s1 = ""string 1"";
        string memory s2 = ""string 2"";
        assertEq(s1, s2);
        emit log(""\n"");
        assertEq(s1, s2, err);

        emit log(""\n## assertEq0(bytes,bytes)\n"");
        assertEq0(hex""abcdef01"", hex""abcdef02"");
        log(""\n"");
        assertEq0(hex""abcdef01"", hex""abcdef02"", err);
    }
}

contract DemoTestWithSetUp {
    function setUp() public {
    }
    function test_pass() public pure {
    }
}",2045
RealWorld_TA_62_ReentrancyGuard_RealWorld_20240808162412.log,62,ReentrancyGuard,29178,1201,30379,63.0,0.16991,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

/// @notice Gas optimized reentrancy protection for smart contracts.
/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
abstract contract ReentrancyGuard {
    uint256 private reentrancyStatus = 1;

    modifier nonReentrant() {
        require(reentrancyStatus == 1, ""REENTRANCY"");

        reentrancyStatus = 2;

        _;

        reentrancyStatus = 1;
    }
}",135
RealWorld_TA_62_LockeTest_RealWorld_20240808164434.log,62,LockeTest,87706,4022,91728,144.0,0.51897,"// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import ""../../Locke.sol"";
import { TestHelpers } from ""./TestHelpers.sol"";
import ""solmate/tokens/ERC20.sol"";
import ""./TestToken.sol"";

contract User is TestHelpers{
    ERC20 testTokenA;
    ERC20 testTokenB;
    ERC20 testTokenC;
    constructor(
        ERC20 _testTokenA,
        ERC20 _testTokenB,
        ERC20 _testTokenC
    ) {
        testTokenA = _testTokenA;
        testTokenB = _testTokenB;
        testTokenC = _testTokenC;
    }

    function doStake(Stream stream, address token, uint112 amount) public {
        write_balanceOf_ts(address(token), address(this), amount);
        ERC20(token).approve(address(stream), amount);
        stream.stake(amount);
    }

    function doWithdraw(Stream stream, uint112 amount) public {
        stream.withdraw(amount);
    }

    function doExit(Stream stream) public {
        stream.exit();
    }

    function doClaimReward(Stream stream) public {
        stream.claimReward();
    }

    function doCreateStream(StreamFactory factory, bool isSale) public returns (Stream){
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = factory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = factory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            isSale
            // false,
            // bytes32(0)
        );
        return stream;
    }

    function failClaimFees(Stream stream) public {
        bytes4 sig = sigs(""claimFees(address)"");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(this)),
            ""!gov""
        );
    }
}

abstract contract LockeTest is TestHelpers {
    // contracts
    StreamFactory defaultStreamFactory;


    ERC20 testTokenA;
    ERC20 testTokenB;
    ERC20 testTokenC;

    // users
    User internal alice;
    User internal bob;

    function setUp() public virtual {
        hevm.warp(1609459200); // jan 1, 2021
        testTokenA = ERC20(address(new TestToken(""Test Token A"", ""TTA"", 18)));
        testTokenB = ERC20(address(new TestToken(""Test Token B"", ""TTB"", 18)));
        testTokenC = ERC20(address(new TestToken(""Test Token C"", ""TTC"", 18)));
        write_balanceOf_ts(address(testTokenA), address(this), 100*10**18);
        write_balanceOf_ts(address(testTokenB), address(this), 100*10**18);
        write_balanceOf_ts(address(testTokenC), address(this), 100*10**18);
        assertEq(testTokenA.balanceOf(address(this)), 100*10**18);
        assertEq(testTokenB.balanceOf(address(this)), 100*10**18);

        defaultStreamFactory = new StreamFactory(address(this), address(this));

        alice = new User(testTokenA, testTokenB, testTokenC);
        bob = new User(testTokenA, testTokenB, testTokenC);

    }

    function createDefaultStream() public returns (Stream) {
        return defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            uint32(block.timestamp + 10), // 10 seconds in future
            4 weeks,
            26 weeks, // 6 months
            0,
            false
            // false,
            // bytes32(0)
        );
    }
}",808
RealWorld_TA_62_SSTORE2_RealWorld_20240808162640.log,62,SSTORE2,56584,1558,58142,67.0,0.31408,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

/// @notice Read and write to persistent storage at a fraction of the cost.
/// @author Modified from 0xSequence (https://github.com/0xsequence/sstore2/blob/master/contracts/SSTORE2.sol)
library SSTORE2 {
    uint256 internal constant DATA_OFFSET = 1;

    function write(bytes memory data) internal returns (address pointer) {
        bytes memory runtimeCode = abi.encodePacked(hex""00"", data);

        bytes memory creationCode = abi.encodePacked(
            hex""63"",
            uint32(runtimeCode.length),
            hex""80_60_0E_60_00_39_60_00_F3"",
            runtimeCode
        );

        assembly {
            pointer := create(0, add(creationCode, 32), mload(creationCode))
        }

        require(pointer != address(0), ""DEPLOYMENT_FAILED"");
    }

    function read(address pointer) internal view returns (bytes memory) {
        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);
    }

    function read(address pointer, uint256 start) internal view returns (bytes memory) {
        start += DATA_OFFSET;

        return readBytecode(pointer, start, pointer.code.length - start);
    }

    function read(
        address pointer,
        uint256 start,
        uint256 end
    ) internal view returns (bytes memory) {
        start += DATA_OFFSET;
        end += DATA_OFFSET;

        require(pointer.code.length >= end, ""OUT_OF_BOUNDS"");

        return readBytecode(pointer, start, end - start);
    }

    function readBytecode(
        address pointer,
        uint256 start,
        uint256 size
    ) private view returns (bytes memory data) {
        assembly {
            data := mload(0x40)
            mstore(0x40, add(data, and(add(add(size, add(start, 0x20)), 0x1f), not(0x1f))))
            mstore(data, size)
            extcodecopy(pointer, add(data, 0x20), start, size)
        }
    }
}",460
RealWorld_TA_62_DSTestPlus_RealWorld_20240808160914.log,62,DSTestPlus,53419,1453,54872,74.0,0.296155,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

import {DSTest} from ""ds-test/test.sol"";

import {Hevm} from ""./Hevm.sol"";

contract DSTestPlus is DSTest {
    Hevm internal constant hevm = Hevm(HEVM_ADDRESS);

    address internal constant DEAD_ADDRESS = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;

    string private checkpointLabel;
    uint256 private checkpointGasLeft;

    function startMeasuringGas(string memory label) internal virtual {
        checkpointLabel = label;
        checkpointGasLeft = gasleft();
    }

    function stopMeasuringGas() internal virtual {
        uint256 checkpointGasLeft2 = gasleft();

        string memory label = checkpointLabel;

        emit log_named_uint(string(abi.encodePacked(label, "" Gas"")), checkpointGasLeft - checkpointGasLeft2);
    }

    function fail(string memory err) internal virtual {
        emit log_named_string(""Error"", err);
        fail();
    }

    function assertFalse(bool data) internal virtual {
        assertTrue(!data);
    }

    function assertUint128Eq(uint128 num1, uint128 num2) internal virtual {
        assertEq(uint256(num1), uint256(num2));
    }

    function assertUint64Eq(uint64 num1, uint64 num2) internal virtual {
        assertEq(uint256(num1), uint256(num2));
    }

    function assertUint96Eq(uint96 num1, uint96 num2) internal virtual {
        assertEq(uint256(num1), uint256(num2));
    }

    function assertUint32Eq(uint32 num1, uint32 num2) internal virtual {
        assertEq(uint256(num1), uint256(num2));
    }

    function assertBytesEq(bytes memory b1, bytes memory b2) internal virtual {
        assertEq(keccak256(b1), keccak256(b2));
    }
}",415
RealWorld_TA_62_ERC20User_RealWorld_20240808161729.log,62,ERC20User,37546,2544,40090,83.0,0.23861,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import {ERC20} from ""../../../tokens/ERC20.sol"";

contract ERC20User {
    ERC20 token;

    constructor(ERC20 _token) {
        token = _token;
    }

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        return token.approve(spender, amount);
    }

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        return token.transfer(to, amount);
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        return token.transferFrom(from, to, amount);
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        return token.permit(owner, spender, value, deadline, v, r, s);
    }
}",222
RealWorld_TA_62_FixedPointMathLib.t_RealWorld_20240808155223.log,62,FixedPointMathLib.t,148709,2135,150844,81.0,0.786245,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";

import {FixedPointMathLib} from ""../utils/FixedPointMathLib.sol"";

contract FixedPointMathLibTest is DSTestPlus {
    function testFMul() public {
        assertEq(FixedPointMathLib.fmul(2.5e27, 0.5e27, FixedPointMathLib.RAY), 1.25e27);
        assertEq(FixedPointMathLib.fmul(2.5e18, 0.5e18, FixedPointMathLib.WAD), 1.25e18);
        assertEq(FixedPointMathLib.fmul(2.5e8, 0.5e8, FixedPointMathLib.YAD), 1.25e8);
    }

    function testFMulEdgeCases() public {
        assertEq(FixedPointMathLib.fmul(0, 1e18, FixedPointMathLib.WAD), 0);
        assertEq(FixedPointMathLib.fmul(1e18, 0, FixedPointMathLib.WAD), 0);
        assertEq(FixedPointMathLib.fmul(0, 0, FixedPointMathLib.WAD), 0);
        assertEq(FixedPointMathLib.fmul(1e18, 1e18, 0), 0);
    }

    function testFDiv() public {
        assertEq(FixedPointMathLib.fdiv(1e27, 2e27, FixedPointMathLib.RAY), 0.5e27);
        assertEq(FixedPointMathLib.fdiv(1e18, 2e18, FixedPointMathLib.WAD), 0.5e18);
        assertEq(FixedPointMathLib.fdiv(1e8, 2e8, FixedPointMathLib.YAD), 0.5e8);
    }

    function testFDivEdgeCases() public {
        assertEq(FixedPointMathLib.fdiv(1e8, 1e18, 0), 0);
        assertEq(FixedPointMathLib.fdiv(0, 1e18, FixedPointMathLib.WAD), 0);
    }

    function testFailFDivZeroY() public pure {
        FixedPointMathLib.fdiv(1e18, 0, FixedPointMathLib.WAD);
    }

    function testFailFDivZeroXY() public pure {
        FixedPointMathLib.fdiv(0, 0, FixedPointMathLib.WAD);
    }

    function testFailFDivXYB() public pure {
        FixedPointMathLib.fdiv(0, 0, 0);
    }

    function testFPow() public {
        assertEq(FixedPointMathLib.fpow(2e27, 2, FixedPointMathLib.RAY), 4e27);
        assertEq(FixedPointMathLib.fpow(2e18, 2, FixedPointMathLib.WAD), 4e18);
        assertEq(FixedPointMathLib.fpow(2e8, 2, FixedPointMathLib.YAD), 4e8);
    }

    function testSqrt() public {
        assertEq(FixedPointMathLib.sqrt(2704), 52);
        assertEq(FixedPointMathLib.sqrt(110889), 333);
        assertEq(FixedPointMathLib.sqrt(32239684), 5678);
    }

    function testMin() public {
        assertEq(FixedPointMathLib.min(4, 100), 4);
        assertEq(FixedPointMathLib.min(500, 400), 400);
        assertEq(FixedPointMathLib.min(10000, 10001), 10000);
        assertEq(FixedPointMathLib.min(1e18, 0.1e18), 0.1e18);
    }

    function testMax() public {
        assertEq(FixedPointMathLib.max(4, 100), 100);
        assertEq(FixedPointMathLib.max(500, 400), 500);
        assertEq(FixedPointMathLib.max(10000, 10001), 10001);
        assertEq(FixedPointMathLib.max(1e18, 0.1e18), 1e18);
    }

    function testFMul(
        uint256 x,
        uint256 y,
        uint256 baseUnit
    ) public {
        // Ignore cases where x * y overflows.
        unchecked {
            if (x != 0 && (x * y) / x != y) return;
        }

        assertEq(FixedPointMathLib.fmul(x, y, baseUnit), baseUnit == 0 ? 0 : (x * y) / baseUnit);
    }

    function testFailFMulOverflow(
        uint256 x,
        uint256 y,
        uint256 baseUnit
    ) public pure {
        // Ignore cases where x * y does not overflow.
        unchecked {
            if ((x * y) / x == y) revert();
        }

        FixedPointMathLib.fmul(x, y, baseUnit);
    }

    function testFDiv(
        uint256 x,
        uint256 y,
        uint256 baseUnit
    ) public {
        // Ignore cases where x * baseUnit overflows.
        unchecked {
            if (x != 0 && (x * baseUnit) / x != baseUnit) return;
        }

        // Ignore cases where y is zero because it will cause a revert.
        if (y == 0) {
            return;
        }

        assertEq(FixedPointMathLib.fdiv(x, y, baseUnit), (x * baseUnit) / y);
    }

    function testFailFDivOverflow(
        uint256 x,
        uint256 y,
        uint256 baseUnit
    ) public pure {
        // Ignore cases where x * baseUnit does not overflow.
        unchecked {
            if ((x * baseUnit) / x == baseUnit) revert();
        }

        FixedPointMathLib.fdiv(x, y, baseUnit);
    }

    function testFailFDivYZero(uint256 x, uint256 baseUnit) public pure {
        FixedPointMathLib.fdiv(x, 0, baseUnit);
    }

    function testSqrt(uint256 x) public {
        uint256 root = FixedPointMathLib.sqrt(x);
        uint256 next = root + 1;

        // Ignore cases where next * next overflows.
        unchecked {
            if (next * next < next) return;
        }

        assertTrue(root * root <= x && next * next > x);
    }

    function testMin(uint256 x, uint256 y) public {
        if (x < y) {
            assertEq(FixedPointMathLib.min(x, y), x);
        } else {
            assertEq(FixedPointMathLib.min(x, y), y);
        }
    }

    function testMax(uint256 x, uint256 y) public {
        if (x > y) {
            assertEq(FixedPointMathLib.max(x, y), x);
        } else {
            assertEq(FixedPointMathLib.max(x, y), y);
        }
    }
}",1544
RealWorld_TA_62_FixedPointMathLib_RealWorld_20240808162517.log,62,FixedPointMathLib,123766,2073,125839,81.0,0.66029,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Arithmetic library with operations for fixed-point numbers.
/// @author Modified from Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/math.sol)
/// and ABDK (https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol)
library FixedPointMathLib {
    /*///////////////////////////////////////////////////////////////
                            COMMON BASE UNITS
    //////////////////////////////////////////////////////////////*/

    uint256 internal constant YAD = 1e8;
    uint256 internal constant WAD = 1e18;
    uint256 internal constant RAY = 1e27;
    uint256 internal constant RAD = 1e45;

    /*///////////////////////////////////////////////////////////////
                         FIXED POINT OPERATIONS
    //////////////////////////////////////////////////////////////*/

    function fmul(
        uint256 x,
        uint256 y,
        uint256 baseUnit
    ) internal pure returns (uint256 z) {
        assembly {
            // Store x * y in z for now.
            z := mul(x, y)

            // Equivalent to require(x == 0 || (x * y) / x == y)
            if iszero(or(iszero(x), eq(div(z, x), y))) {
                revert(0, 0)
            }

            // If baseUnit is zero this will return zero instead of reverting.
            z := div(z, baseUnit)
        }
    }

    function fdiv(
        uint256 x,
        uint256 y,
        uint256 baseUnit
    ) internal pure returns (uint256 z) {
        assembly {
            // Store x * baseUnit in z for now.
            z := mul(x, baseUnit)

            if or(
                // Revert if y is zero to ensure we don't divide by zero below.
                iszero(y),
                // Equivalent to require(x == 0 || (x * baseUnit) / x == baseUnit)
                iszero(or(iszero(x), eq(div(z, x), baseUnit)))
            ) {
                revert(0, 0)
            }

            // We ensure y is not zero above, so there is never division by zero here.
            z := div(z, y)
        }
    }

    function fpow(
        uint256 x,
        uint256 n,
        uint256 baseUnit
    ) internal pure returns (uint256 z) {
        assembly {
            switch x
            case 0 {
                switch n
                case 0 {
                    z := baseUnit
                }
                default {
                    z := 0
                }
            }
            default {
                switch mod(n, 2)
                case 0 {
                    z := baseUnit
                }
                default {
                    z := x
                }
                let half := div(baseUnit, 2)
                for {
                    n := div(n, 2)
                } n {
                    n := div(n, 2)
                } {
                    let xx := mul(x, x)
                    if iszero(eq(div(xx, x), x)) {
                        revert(0, 0)
                    }
                    let xxRound := add(xx, half)
                    if lt(xxRound, xx) {
                        revert(0, 0)
                    }
                    x := div(xxRound, baseUnit)
                    if mod(n, 2) {
                        let zx := mul(z, x)
                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {
                            revert(0, 0)
                        }
                        let zxRound := add(zx, half)
                        if lt(zxRound, zx) {
                            revert(0, 0)
                        }
                        z := div(zxRound, baseUnit)
                    }
                }
            }
        }
    }

    /*///////////////////////////////////////////////////////////////
                        GENERAL NUMBER UTILITIES
    //////////////////////////////////////////////////////////////*/

    function sqrt(uint256 x) internal pure returns (uint256 result) {
        if (x == 0) return 0;

        result = 1;

        uint256 xAux = x;

        if (xAux >= 0x100000000000000000000000000000000) {
            xAux >>= 128;
            result <<= 64;
        }

        if (xAux >= 0x10000000000000000) {
            xAux >>= 64;
            result <<= 32;
        }

        if (xAux >= 0x100000000) {
            xAux >>= 32;
            result <<= 16;
        }

        if (xAux >= 0x10000) {
            xAux >>= 16;
            result <<= 8;
        }

        if (xAux >= 0x100) {
            xAux >>= 8;
            result <<= 4;
        }

        if (xAux >= 0x10) {
            xAux >>= 4;
            result <<= 2;
        }

        if (xAux >= 0x8) result <<= 1;

        unchecked {
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;
            result = (result + x / result) >> 1;

            uint256 roundedDownResult = x / result;

            if (result > roundedDownResult) result = roundedDownResult;
        }
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x < y ? x : y;
    }

    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {
        return x > y ? x : y;
    }
}",1246
RealWorld_TA_62_GenericUser_RealWorld_20240808161556.log,62,GenericUser,33844,3257,37101,91.0,0.23436,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity >=0.7.0;

contract GenericUser {
    function tryCall(address target, bytes memory data) public virtual returns (bool success, bytes memory returnData) {
        (success, returnData) = target.call(data);
    }

    function call(address target, bytes memory data) public virtual returns (bytes memory returnData) {
        bool success;
        (success, returnData) = target.call(data);

        if (!success) {
            if (returnData.length > 0) {
                assembly {
                    let returnDataSize := mload(returnData)
                    revert(add(32, returnData), returnDataSize)
                }
            } else {
                revert(""REVERTED_WITHOUT_MESSAGE"");
            }
        }
    }
}",169
RealWorld_TA_62_test_RealWorld_20240808154813.log,62,test,314640,1979,316619,91.0,1.61278,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log                    (string);
    event logs                   (bytes);

    event log_address            (address);
    event log_bytes32            (bytes32);
    event log_int                (int);
    event log_uint               (uint);
    event log_bytes              (bytes);
    event log_string             (string);

    event log_named_address      (string key, address val);
    event log_named_bytes32      (string key, bytes32 val);
    event log_named_decimal_int  (string key, int val, uint decimals);
    event log_named_decimal_uint (string key, uint val, uint decimals);
    event log_named_int          (string key, int val);
    event log_named_uint         (string key, uint val);
    event log_named_bytes        (string key, bytes val);
    event log_named_string       (string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));

    modifier mayRevert() { _; }
    modifier testopts(string memory) { _; }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint startGas = gasleft();
        _;
        uint endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }
    function assertEq(address a, address b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }
    function assertEq(bytes32 a, bytes32 b, string memory err) internal {
        if (a != b) {
            emit log_named_string (""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }
    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {
        assertEq(a, b, err);
    }

    function assertEq(int a, int b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }
    function assertEq(int a, int b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEq(uint a, uint b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }
    function assertEq(uint a, uint b, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }
    function assertEqDecimal(int a, int b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }
    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint a, uint b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGt(uint a, uint b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGt(int a, int b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGt(int a, int b, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }
    function assertGtDecimal(int a, int b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint a, uint b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertGe(uint a, uint b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGe(int a, int b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertGe(int a, int b, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }
    function assertGeDecimal(int a, int b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint a, uint b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLt(uint a, uint b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLt(int a, int b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLt(int a, int b, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }
    function assertLtDecimal(int a, int b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint a, uint b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }
    function assertLe(uint a, uint b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLe(int a, int b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }
    function assertLe(int a, int b, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }
    function assertLeDecimal(int a, int b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }
    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }
    function assertEq(string memory a, string memory b, string memory err) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {
        ok = true;
        if (a.length == b.length) {
            for (uint i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }
    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }
    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3539
RealWorld_TA_62_WETH_RealWorld_20240808163400.log,62,WETH,35983,1662,37645,72.0,0.213155,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

import {ERC20} from ""./ERC20.sol"";

import {SafeTransferLib} from ""../utils/SafeTransferLib.sol"";

/// @notice Minimalist and modern Wrapped Ether implementation.
/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)
contract WETH is ERC20(""Wrapped Ether"", ""WETH"", 18) {
    using SafeTransferLib for address;

    event Deposit(address indexed from, uint256 amount);

    event Withdrawal(address indexed to, uint256 amount);

    function deposit() public payable {
        _mint(msg.sender, msg.value);

        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        _burn(msg.sender, amount);

        msg.sender.safeTransferETH(amount);

        emit Withdrawal(msg.sender, amount);
    }

    receive() external payable {
        deposit();
    }
}",211
RealWorld_TA_62_Auth_RealWorld_20240808161855.log,62,Auth,50455,2063,52518,79.0,0.293535,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

/// @notice A generic interface for a contract which provides authorization data to an Auth instance.
/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
interface Authority {
    function canCall(
        address user,
        address target,
        bytes4 functionSig
    ) external view returns (bool);
}

/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.
/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
abstract contract Auth {
    event OwnerUpdated(address indexed owner);

    event AuthorityUpdated(Authority indexed authority);

    address public owner;

    Authority public authority;

    constructor(address _owner, Authority _authority) {
        owner = _owner;
        authority = _authority;

        emit OwnerUpdated(_owner);
        emit AuthorityUpdated(_authority);
    }

    function setOwner(address newOwner) public virtual requiresAuth {
        owner = newOwner;

        emit OwnerUpdated(owner);
    }

    function setAuthority(Authority newAuthority) public virtual requiresAuth {
        authority = newAuthority;

        emit AuthorityUpdated(authority);
    }

    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {
        Authority cachedAuthority = authority;

        if (address(cachedAuthority) != address(0)) {
            try cachedAuthority.canCall(user, address(this), functionSig) returns (bool canCall) {
                if (canCall) return true;
            } catch {}
        }

        return user == owner;
    }

    modifier requiresAuth() {
        require(isAuthorized(msg.sender, msg.sig), ""UNAUTHORIZED"");

        _;
    }
}",379
RealWorld_TA_62_MockAuthChild_RealWorld_20240808161431.log,62,MockAuthChild,25506,2898,28404,83.0,0.18549,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

import {Auth, Authority} from ""../../../auth/Auth.sol"";

contract MockAuthChild is Auth(msg.sender, Authority(address(0))) {
    bool public flag;

    function updateFlag() public virtual requiresAuth {
        flag = true;
    }
}",72
RealWorld_TA_62_Bytes32AddressLib.t_RealWorld_20240808155505.log,62,Bytes32AddressLib.t,37397,1480,38877,71.0,0.216585,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";

import {Bytes32AddressLib} from ""../utils/Bytes32AddressLib.sol"";

contract Bytes32AddressLibTest is DSTestPlus {
    function testFillLast12Bytes() public {
        assertEq(
            Bytes32AddressLib.fillLast12Bytes(0xfEEDFaCEcaFeBEEFfEEDFACecaFEBeeFfeEdfAce),
            0xfeedfacecafebeeffeedfacecafebeeffeedface000000000000000000000000
        );
    }

    function testFromLast20Bytes() public {
        assertEq(
            Bytes32AddressLib.fromLast20Bytes(0xfeedfacecafebeeffeedfacecafebeeffeedfacecafebeeffeedfacecafebeef),
            0xCAfeBeefFeedfAceCAFeBEEffEEDfaCecafEBeeF
        );
    }
}",228
RealWorld_TA_62_Bytes32AddressLib_RealWorld_20240808163007.log,62,Bytes32AddressLib,28291,1345,29636,69.0,0.168355,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

/// @notice Library for converting between addresses and bytes32 values.
/// @author Original work by Transmissions11 (https://github.com/transmissions11)
library Bytes32AddressLib {
    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {
        return address(uint160(uint256(bytesValue)));
    }

    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {
        return bytes32(bytes20(addressValue));
    }
}",119
RealWorld_TA_62_ERC20.t_RealWorld_20240808155733.log,62,ERC20.t,110996,3577,114573,101.0,0.62652,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {DSInvariantTest} from ""./utils/DSInvariantTest.sol"";

import {MockERC20} from ""./utils/mocks/MockERC20.sol"";
import {ERC20User} from ""./utils/users/ERC20User.sol"";

contract ERC20Test is DSTestPlus {
    MockERC20 token;

    function setUp() public {
        token = new MockERC20(""Token"", ""TKN"", 18);
    }

    function invariantMetadata() public {
        assertEq(token.name(), ""Token"");
        assertEq(token.symbol(), ""TKN"");
        assertEq(token.decimals(), 18);
    }

    function testMetaData(
        string calldata name,
        string calldata symbol,
        uint8 decimals
    ) public {
        MockERC20 tkn = new MockERC20(name, symbol, decimals);
        assertEq(tkn.name(), name);
        assertEq(tkn.symbol(), symbol);
        assertEq(tkn.decimals(), decimals);
    }

    function testMint(address from, uint256 amount) public {
        token.mint(from, amount);

        assertEq(token.totalSupply(), amount);
        assertEq(token.balanceOf(from), amount);
    }

    function testBurn(
        address from,
        uint256 mintAmount,
        uint256 burnAmount
    ) public {
        if (burnAmount > mintAmount) return;

        token.mint(from, mintAmount);
        token.burn(from, burnAmount);

        assertEq(token.totalSupply(), mintAmount - burnAmount);
        assertEq(token.balanceOf(from), mintAmount - burnAmount);
    }

    function testApprove(address from, uint256 amount) public {
        assertTrue(token.approve(from, amount));

        assertEq(token.allowance(address(this), from), amount);
    }

    function testTransfer(address from, uint256 amount) public {
        token.mint(address(this), amount);

        assertTrue(token.transfer(from, amount));
        assertEq(token.totalSupply(), amount);

        if (address(this) == from) {
            assertEq(token.balanceOf(address(this)), amount);
        } else {
            assertEq(token.balanceOf(address(this)), 0);
            assertEq(token.balanceOf(from), amount);
        }
    }

    function testTransferFrom(
        address to,
        uint256 approval,
        uint256 amount
    ) public {
        if (amount > approval) return;

        ERC20User from = new ERC20User(token);

        token.mint(address(from), amount);

        from.approve(address(this), approval);

        assertTrue(token.transferFrom(address(from), to, amount));
        assertEq(token.totalSupply(), amount);

        uint256 app = address(from) == address(this) || approval == type(uint256).max ? approval : approval - amount;
        assertEq(token.allowance(address(from), address(this)), app);

        if (address(from) == to) {
            assertEq(token.balanceOf(address(from)), amount);
        } else {
            assertEq(token.balanceOf(address(from)), 0);
            assertEq(token.balanceOf(to), amount);
        }
    }

    function testFailTransferFromInsufficientAllowance(
        address to,
        uint256 approval,
        uint256 amount
    ) public {
        require(approval < amount);

        ERC20User from = new ERC20User(token);

        token.mint(address(from), amount);
        from.approve(address(this), approval);
        token.transferFrom(address(from), to, amount);
    }

    function testFailTransferFromInsufficientBalance(
        address to,
        uint256 mintAmount,
        uint256 sendAmount
    ) public {
        require(mintAmount < sendAmount);

        ERC20User from = new ERC20User(token);

        token.mint(address(from), mintAmount);
        from.approve(address(this), sendAmount);
        token.transferFrom(address(from), to, sendAmount);
    }
}

contract ERC20Invariants is DSTestPlus, DSInvariantTest {
    BalanceSum balanceSum;
    MockERC20 token;

    function setUp() public {
        token = new MockERC20(""Token"", ""TKN"", 18);
        balanceSum = new BalanceSum(token);

        addTargetContract(address(balanceSum));
    }

    function invariantBalanceSum() public {
        assertEq(token.totalSupply(), balanceSum.sum());
    }
}

contract BalanceSum {
    MockERC20 token;
    uint256 public sum;

    constructor(MockERC20 _token) {
        token = _token;
    }

    function mint(address from, uint256 amount) public {
        token.mint(from, amount);
        sum += amount;
    }

    function burn(address from, uint256 amount) public {
        token.burn(from, amount);
        sum -= amount;
    }

    function approve(address to, uint256 amount) public {
        token.approve(to, amount);
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public {
        token.transferFrom(from, to, amount);
    }

    function transfer(address to, uint256 amount) public {
        token.transfer(to, amount);
    }
}",1087
RealWorld_TA_62_ERC20_RealWorld_20240808163237.log,62,ERC20,110106,2027,112133,81.0,0.59107,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.8.0;

/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.
/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)
abstract contract ERC20 {
    /*///////////////////////////////////////////////////////////////
                                  EVENTS
    //////////////////////////////////////////////////////////////*/

    event Transfer(address indexed from, address indexed to, uint256 amount);

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /*///////////////////////////////////////////////////////////////
                             METADATA STORAGE
    //////////////////////////////////////////////////////////////*/

    string public name;

    string public symbol;

    uint8 public immutable decimals;

    /*///////////////////////////////////////////////////////////////
                              ERC20 STORAGE
    //////////////////////////////////////////////////////////////*/

    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    mapping(address => mapping(address => uint256)) public allowance;

    /*///////////////////////////////////////////////////////////////
                           EIP-2612 STORAGE
    //////////////////////////////////////////////////////////////*/

    bytes32 public constant PERMIT_TYPEHASH =
        keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");

    uint256 internal immutable INITIAL_CHAIN_ID;

    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;

    mapping(address => uint256) public nonces;

    /*///////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;

        INITIAL_CHAIN_ID = block.chainid;
        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    }

    /*///////////////////////////////////////////////////////////////
                              ERC20 LOGIC
    //////////////////////////////////////////////////////////////*/

    function approve(address spender, uint256 amount) public virtual returns (bool) {
        allowance[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    function transfer(address to, uint256 amount) public virtual returns (bool) {
        balanceOf[msg.sender] -= amount;

        // This is safe because the sum of all user
        // balances can't exceed type(uint256).max!
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(msg.sender, to, amount);

        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }

        balanceOf[from] -= amount;

        // This is safe because the sum of all user
        // balances can't exceed type(uint256).max!
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(from, to, amount);

        return true;
    }

    /*///////////////////////////////////////////////////////////////
                              EIP-2612 LOGIC
    //////////////////////////////////////////////////////////////*/

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline >= block.timestamp, ""PERMIT_DEADLINE_EXPIRED"");

        // This is safe because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            bytes32 digest = keccak256(
                abi.encodePacked(
                    ""\x19\x01"",
                    DOMAIN_SEPARATOR(),
                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
                )
            );

            address recoveredAddress = ecrecover(digest, v, r, s);
            require(recoveredAddress != address(0) && recoveredAddress == owner, ""INVALID_PERMIT_SIGNATURE"");

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }

    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
    }

    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
                    keccak256(bytes(name)),
                    keccak256(bytes(""1"")),
                    block.chainid,
                    address(this)
                )
            );
    }

    /*///////////////////////////////////////////////////////////////
                       INTERNAL MINT/BURN LOGIC
    //////////////////////////////////////////////////////////////*/

    function _mint(address to, uint256 amount) internal virtual {
        totalSupply += amount;

        // This is safe because the sum of all user
        // balances can't exceed type(uint256).max!
        unchecked {
            balanceOf[to] += amount;
        }

        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal virtual {
        balanceOf[from] -= amount;

        // This is safe because a user won't ever
        // have a balance larger than totalSupply!
        unchecked {
            totalSupply -= amount;
        }

        emit Transfer(from, address(0), amount);
    }
}",1094
RealWorld_TA_62_Trust.t_RealWorld_20240808154947.log,62,Trust.t,46649,2423,49072,77.0,0.281705,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";
import {MockTrustChild} from ""./utils/mocks/MockTrustChild.sol"";

contract TrustTest is DSTestPlus {
    MockTrustChild mockTrustChild;

    function setUp() public {
        mockTrustChild = new MockTrustChild();

        mockTrustChild.setIsTrusted(address(this), false);
    }

    function testFailTrustNotTrusted(address usr) public {
        mockTrustChild.setIsTrusted(usr, true);
    }

    function testFailDistrustNotTrusted(address usr) public {
        mockTrustChild.setIsTrusted(usr, false);
    }

    function testTrust(address usr) public {
        if (usr == address(this)) return;
        forceTrust(address(this));

        assertFalse(mockTrustChild.isTrusted(usr));
        mockTrustChild.setIsTrusted(usr, true);
        assertTrue(mockTrustChild.isTrusted(usr));
    }

    function testDistrust(address usr) public {
        if (usr == address(this)) return;
        forceTrust(address(this));
        forceTrust(usr);

        assertTrue(mockTrustChild.isTrusted(usr));
        mockTrustChild.setIsTrusted(usr, false);
        assertFalse(mockTrustChild.isTrusted(usr));
    }

    function forceTrust(address usr) internal {
        hevm.store(address(mockTrustChild), keccak256(abi.encode(usr, uint256(0))), bytes32(uint256(1)));
    }
}",334
RealWorld_TA_62_Trust_RealWorld_20240808162016.log,62,Trust,33847,2261,36108,75.0,0.214455,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

/// @notice Ultra minimal authorization logic for smart contracts.
/// @author Inspired by Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/auth.sol)
abstract contract Trust {
    event UserTrustUpdated(address indexed user, bool trusted);

    mapping(address => bool) public isTrusted;

    constructor(address initialUser) {
        isTrusted[initialUser] = true;

        emit UserTrustUpdated(initialUser, true);
    }

    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {
        isTrusted[user] = trusted;

        emit UserTrustUpdated(user, trusted);
    }

    modifier requiresTrust() {
        require(isTrusted[msg.sender], ""UNTRUSTED"");

        _;
    }
}",181
RealWorld_TA_62_SSTORE2.t_RealWorld_20240808155916.log,62,SSTORE2.t,96766,1954,98720,84.0,0.52291,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from ""./utils/DSTestPlus.sol"";

import {SSTORE2} from ""../utils/SSTORE2.sol"";

contract SSTORE2Test is DSTestPlus {
    function testWriteRead() public {
        bytes memory testBytes = abi.encode(""this is a test"");

        address pointer = SSTORE2.write(testBytes);

        assertBytesEq(SSTORE2.read(pointer), testBytes);
    }

    function testWriteReadFullStartBound() public {
        assertBytesEq(SSTORE2.read(SSTORE2.write(hex""11223344""), 0), hex""11223344"");
    }

    function testWriteReadCustomStartBound() public {
        assertBytesEq(SSTORE2.read(SSTORE2.write(hex""11223344""), 1), hex""223344"");
    }

    function testWriteReadFullBoundedRead() public {
        bytes memory testBytes = abi.encode(""this is a test"");

        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), 0, testBytes.length), testBytes);
    }

    function testWriteReadCustomBounds() public {
        assertBytesEq(SSTORE2.read(SSTORE2.write(hex""11223344""), 1, 3), hex""2233"");
    }

    function testWriteReadEmptyBound() public {
        SSTORE2.read(SSTORE2.write(hex""11223344""), 3, 3);
    }

    function testFailReadInvalidPointer() public view {
        SSTORE2.read(DEAD_ADDRESS);
    }

    function testFailReadInvalidPointerCustomStartBound() public view {
        SSTORE2.read(DEAD_ADDRESS, 1);
    }

    function testFailReadInvalidPointerCustomBounds() public view {
        SSTORE2.read(DEAD_ADDRESS, 2, 4);
    }

    function testFailWriteReadOutOfStartBound() public {
        SSTORE2.read(SSTORE2.write(hex""11223344""), 41000);
    }

    function testFailWriteReadEmptyOutOfBounds() public {
        SSTORE2.read(SSTORE2.write(hex""11223344""), 42000, 42000);
    }

    function testFailWriteReadOutOfBounds() public {
        SSTORE2.read(SSTORE2.write(hex""11223344""), 41000, 42000);
    }

    function testWriteRead(bytes calldata testBytes) public {
        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes)), testBytes);
    }

    function testWriteReadCustomStartBound(bytes calldata testBytes, uint256 startIndex) public {
        if (testBytes.length == 0) return;

        startIndex %= testBytes.length;

        assertBytesEq(SSTORE2.read(SSTORE2.write(testBytes), startIndex), bytes(testBytes[startIndex:]));
    }

    function testWriteReadCustomBounds(
        bytes calldata testBytes,
        uint256 startIndex,
        uint256 endIndex
    ) public {
        if (testBytes.length == 0) return;

        startIndex %= testBytes.length;
        endIndex %= testBytes.length;

        if (startIndex > endIndex) return;

        assertBytesEq(
            SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex),
            bytes(testBytes[startIndex:endIndex])
        );
    }

    function testFailReadInvalidPointer(address pointer) public view {
        SSTORE2.read(pointer);
    }

    function testFailReadInvalidPointerCustomStartBound(address pointer, uint256 startIndex) public view {
        SSTORE2.read(pointer, startIndex);
    }

    function testFailReadInvalidPointerCustomBounds(
        address pointer,
        uint256 startIndex,
        uint256 endIndex
    ) public view {
        SSTORE2.read(pointer, startIndex, endIndex);
    }

    function testFailWriteReadCustomStartBoundOutOfRange(bytes calldata testBytes, uint256 startIndex) public {
        if (testBytes.length >= startIndex) revert();

        SSTORE2.read(SSTORE2.write(testBytes), startIndex);
    }

    function testFailWriteReadCustomBoundsOutOfRange(
        bytes calldata testBytes,
        uint256 startIndex,
        uint256 endIndex
    ) public {
        if (endIndex >= startIndex) revert();

        SSTORE2.read(SSTORE2.write(testBytes), startIndex, endIndex);
    }
}",900
RealWorld_TA_62_HEVMState_RealWorld_20240808164818.log,62,HEVMState,27100,1535,28635,75.0,0.1662,"pragma solidity >=0.8.0;

import {Hevm} from ""./Hevm.sol"";

contract HEVMState {
    bytes20 constant CHEAT_CODE =
        bytes20(uint160(uint(keccak256('hevm cheat code'))));
    Hevm hevm = Hevm(address(CHEAT_CODE));

    address me = address(this);

    mapping (address => mapping(bytes4 => uint256)) public slots;
    mapping (address => mapping(bytes4 => bool)) public finds;
}",101
RealWorld_TA_62_Locke_RealWorld_20240808163514.log,62,Locke,583087,8343,591430,222.0,3.082295,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";

// ====== Governance =====
contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    /// Update pending governor
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    /// Accepts governorship
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    /// Remove governor
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    // ====== Modifiers =======
    /// Governed function
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    // ====== Modifiers =======
    /// Governed function
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}

// ====== Stream =====
contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    // ======= Structs ========
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    // ======= Storage ========
    // ==== Immutables =====
    // stream start time
    uint32 private immutable startTime;
    // length of stream
    uint32 private immutable streamDuration;
    // length of time depositTokens are locked after stream ends
    uint32 private immutable depositLockDuration;
    // length of time rewardTokens are locked after stream ends
    uint32 private immutable rewardLockDuration;

    // end of stream
    uint32 private immutable endStream;
    // end of deposit lock
    uint32 private immutable endDepositLock;
    // end of reward lock
    uint32 private immutable endRewardLock;

    // Token given to depositer
    address public immutable rewardToken;
    // Token deposited
    address public immutable depositToken;

    // This stream's id
    uint64 public immutable streamId;

    // fee percent on reward tokens
    uint16 private immutable feePercent;
    // are fees enabled
    bool private immutable feeEnabled;

    // deposits are basically a *sale* to the stream creator if true
    bool public immutable isSale;

    // stream creator
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    // ============

    //  == sloc a ==
    // internal reward token amount to be given to depositors
    uint112 private rewardTokenAmount;
    // internal deposit token amount locked/to be sold to stream creator
    uint112 private depositTokenAmount;
    // ============

    // == slot b ==
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    // ============

    // == slot c ==
    uint256 private cumulativeRewardPerToken;
    // ============

    // == slot d ==
    uint256 private totalVirtualBalance;
    // ============

    // == slot e ==
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    // ============

    // mapping of address to number of tokens not yet streamed over
    mapping (address => TokenStream) public tokensNotYetStreamed;

    // external incentives to stream creator
    mapping (address => uint112) public incentives;

    // ======= Events ========
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    // ======= Modifiers ========
    modifier updateStream(address who) {
        // save bytecode space by making it a jump instead of inlining at cost of gas
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            // set lastUpdates if need be
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            // accumulate reward per token info
            cumulativeRewardPerToken = rewardPerToken();

            // update user rewards
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            // update users last cumulative reward per token
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            // update users unstreamed balance
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                // some time has passed since this user last interacted
                // update ts not yet streamed
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            // handle global unstreamed
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            // stream tokens over
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            // already ensure that blocktimestamp is less than endStream so guaranteed ok here
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) // inherit factory governance
        public 
    {
        // set fee info
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        // limit feePercent
        require(feePercent < 10000, ""fee"");
    
        // store streamParams
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        // set tokens
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        // set streamId
        streamId = _streamId;

        // set sale info
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    /**
     * @dev Returns relevant internal token amounts
    **/
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    /**
     * @dev Returns fee parameters
    **/
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    /**
     * @dev Returns stream parameters
    **/
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            // time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        // duration / timeRemaining * amount
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    /**
     * @dev Allows _anyone_ to fund this stream, if its before the stream start time
    **/
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        // transfer from sender
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        // if fee is enabled, take a fee
        if (feeEnabled) {
            // Safety:
            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying
            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112
            //  3. amount is guaranteed to be greater than feeAmt
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            // since this operation can be repeated, we cannot assume no overflow so use checked math
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

    /**
     *  @dev Deposits depositTokens into this stream
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // require(block.timestamp < endStream, ""stake:!stream"");

        // transfer tokens over
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            // not a straight sale, so give the user some receipt tokens
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

    /**
     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,
     *  up to their tokensNotYetStreamed amount
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        // do the transfer
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed
     *  and burns receiptTokens if its not a sale.
     * 
     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw
    */ 
    function exit() public updateStream(msg.sender) {
        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

    /**
     *  @dev Allows anyone to incentivize this stream with extra tokens
     *  and requires the incentive to not be the reward or deposit token
    */ 
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

    /**
     *  @dev Allows the stream creator to claim an incentive once the stream is done
    */ 
    function claimIncentive(address token) public lock {
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

    /**
     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount
     *  is greater than the requested amount
    */ 
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable
        // we dont need to updateStream(msg.sender)
        require(amount > 0, ""amt"");

        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over
        require(block.timestamp > endDepositLock, ""lock"");

        // burn the receiptTokens
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        // send the receipt token holder back the funds
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

    /**
     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens
    */ 
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        // accumulate reward per token info
        cumulativeRewardPerToken = rewardPerToken();

        // update user rewards
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        // update users last cumulative reward per token
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        // transfer the tokens
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

    /**
     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale
    */ 
    function creatorClaimSoldTokens(address destination) public lock {
        // can only claim when its a sale
        require(isSale, ""!sale"");

        // only can claim once
        require(!claimedDepositTokens, ""claimed"");
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

    /**
     *  @dev Allows the governance contract of the factory to select a destination
     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount
    */ 
    function claimFees(address destination) public lock externallyGoverned {
        // Stream is done
        require(block.timestamp >= endStream, ""stream"");

        // reset fee amount
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            // transfer and emit event
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            // transfer and emit event
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    // ======== Non-protocol functions ========

    /**
     *  @dev Allows the stream creator to save tokens
     *  There are some limitations to this:
     *      1. if its deposit token:
     *          - DepositLock is fully done
     *          - There are excess deposit tokens (balance - depositTokenAmount)
     *      2. if its the reward token:
     *          - RewardLock is fully done
     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)
     *      3. if incentivized:
     *          - excesss defined as bal - incentives[token]
    */ 
    function recoverTokens(address token, address recipient) public lock {
        // NOTE: it is the stream creators responsibility to save
        // tokens on behalf of their users.
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            // get the balance of this contract
            // check what isnt claimable by either party
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            // allow saving of the token
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            // check current balance vs internal balance
            //
            // NOTE: if a token rebases, i.e. changes balance out from under us,
            // most of this contract breaks and rugs depositors. this isn't exclusive
            // to this function but this function would in theory allow someone to rug
            // and recover the excess (if it is worth anything)

            // check what isnt claimable by depositors and governance
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        // not reward token nor deposit nor incentivized token, free to transfer
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    /**
     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee
    */
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        // the `to` contract should have a public function with the signature:
        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; // 10bps fee

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    /**
     *  @dev Allows inherited governance contract to call functions on behalf of this contract
     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances
     *  that may matter are guaranteed to not change.
     * 
     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract
    */
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        // cannot have an active incentive for the callee
        require(incentives[who] == 0, ""inc"");
        // cannot be to deposit token nor reward token
        require(who != depositToken && who != rewardToken, ""erc"");

        // get token balances
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        // require no change in balances
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    // ======= Structs ========
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    // ======= Storage ========
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%

    // =======  Events  =======
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    /**
     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract
     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After
     * lockDuration is completed, the depositTokens can be claimed by the original depositors
     * 
    **/
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        // perform checks

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        // DATA VALIDATION:
        //  there is no real concept of ""sane"" limits here, and if misconfigured its ultimated
        //  not a massive deal so no data validation is done
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",6655
RealWorld_TA_62_RolesAuthority_RealWorld_20240808162243.log,62,RolesAuthority,89420,2497,91917,87.0,0.49704,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity >=0.7.0;

import {Auth, Authority} from ""../Auth.sol"";

/// @notice Role based Authority that supports up to 256 roles.
/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)
contract RolesAuthority is Auth, Authority {
    /*///////////////////////////////////////////////////////////////
                                  EVENTS
    //////////////////////////////////////////////////////////////*/

    event UserRootUpdated(address indexed user, bool enabled);

    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);

    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);

    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);

    /*///////////////////////////////////////////////////////////////
                               CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/
    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}

    /*///////////////////////////////////////////////////////////////
                             USER ROLE STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(address => bool) public isUserRoot;

    mapping(address => bytes32) public getUserRoles;

    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {
        unchecked {
            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));

            return bytes32(0) != getUserRoles[user] & shifted;
        }
    }

    /*///////////////////////////////////////////////////////////////
                        ROLE CAPABILITY STORAGE
    //////////////////////////////////////////////////////////////*/

    mapping(address => mapping(bytes4 => bytes32)) public getRoleCapabilities;

    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;

    function doesRoleHaveCapability(
        uint8 role,
        address target,
        bytes4 functionSig
    ) public view virtual returns (bool) {
        unchecked {
            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));

            return bytes32(0) != getRoleCapabilities[target][functionSig] & shifted;
        }
    }

    /*///////////////////////////////////////////////////////////////
                          AUTHORIZATION LOGIC
    //////////////////////////////////////////////////////////////*/

    function canCall(
        address user,
        address target,
        bytes4 functionSig
    ) public view virtual override returns (bool) {
        if (isCapabilityPublic[target][functionSig]) return true;

        return bytes32(0) != getUserRoles[user] & getRoleCapabilities[target][functionSig] || isUserRoot[user];
    }

    /*///////////////////////////////////////////////////////////////
                  ROLE CAPABILITY CONFIGURATION LOGIC
    //////////////////////////////////////////////////////////////*/

    function setPublicCapability(
        address target,
        bytes4 functionSig,
        bool enabled
    ) public virtual requiresAuth {
        isCapabilityPublic[target][functionSig] = enabled;

        emit PublicCapabilityUpdated(target, functionSig, enabled);
    }

    function setRoleCapability(
        uint8 role,
        address target,
        bytes4 functionSig,
        bool enabled
    ) public virtual requiresAuth {
        bytes32 lastRoles = getRoleCapabilities[target][functionSig];

        unchecked {
            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));

            getRoleCapabilities[target][functionSig] = enabled ? lastRoles | shifted : lastRoles & ~shifted;
        }

        emit RoleCapabilityUpdated(role, target, functionSig, enabled);
    }

    /*///////////////////////////////////////////////////////////////
                      USER ROLE ASSIGNMENT LOGIC
    //////////////////////////////////////////////////////////////*/

    function setUserRole(
        address user,
        uint8 role,
        bool enabled
    ) public virtual requiresAuth {
        bytes32 lastRoles = getUserRoles[user];

        unchecked {
            bytes32 shifted = bytes32(uint256(uint256(2)**uint256(role)));

            getUserRoles[user] = enabled ? lastRoles | shifted : lastRoles & ~shifted;
        }

        emit UserRoleUpdated(user, role, enabled);
    }

    function setRootUser(address user, bool enabled) public virtual requiresAuth {
        isUserRoot[user] = enabled;

        emit UserRootUpdated(user, enabled);
    }
}",818
RealWorld_TA_64_ObservationLib_RealWorld_20240808185936.log,64,ObservationLib,102577,1732,104309,97.0,0.547525,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

import ""./OverflowSafeComparatorLib.sol"";
import ""./RingBufferLib.sol"";

/**
* @title Observation Library
* @notice This library allows one to store an array of timestamped values and efficiently binary search them.
* @dev Largely pulled from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/c05a0e2c8c08c460fb4d05cfdda30b3ad8deeaac/contracts/libraries/Oracle.sol
* @author PoolTogether Inc.
*/
library ObservationLib {
    using OverflowSafeComparatorLib for uint32;
    using SafeCast for uint256;

    /// @notice The maximum number of observations
    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24

    /**
    * @notice Observation, which includes an amount and timestamp.
    * @param amount `amount` at `timestamp`.
    * @param timestamp Recorded `timestamp`.
    */
    struct Observation {
        uint224 amount;
        uint32 timestamp;
    }

    /**
    * @notice Fetches Observations `beforeOrAt` and `atOrAfter` a `_target`, eg: where [`beforeOrAt`, `atOrAfter`] is satisfied.
    * The result may be the same Observation, or adjacent Observations.
    * @dev The answer must be contained in the array used when the target is located within the stored Observation.
    * boundaries: older than the most recent Observation and younger, or the same age as, the oldest Observation.
    * @dev  If `_newestObservationIndex` is less than `_oldestObservationIndex`, it means that we've wrapped around the circular buffer.
    *       So the most recent observation will be at `_oldestObservationIndex + _cardinality - 1`, at the beginning of the circular buffer.
    * @param _observations List of Observations to search through.
    * @param _newestObservationIndex Index of the newest Observation. Right side of the circular buffer.
    * @param _oldestObservationIndex Index of the oldest Observation. Left side of the circular buffer.
    * @param _target Timestamp at which we are searching the Observation.
    * @param _cardinality Cardinality of the circular buffer we are searching through.
    * @param _time Timestamp at which we perform the binary search.
    * @return beforeOrAt Observation recorded before, or at, the target.
    * @return atOrAfter Observation recorded at, or after, the target.
    */
    function binarySearch(
        Observation[MAX_CARDINALITY] storage _observations,
        uint24 _newestObservationIndex,
        uint24 _oldestObservationIndex,
        uint32 _target,
        uint24 _cardinality,
        uint32 _time
    ) internal view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
        uint256 leftSide = _oldestObservationIndex;
        uint256 rightSide = _newestObservationIndex < leftSide
            ? leftSide + _cardinality - 1
            : _newestObservationIndex;
        uint256 currentIndex;

        while (true) {
            // We start our search in the middle of the `leftSide` and `rightSide`.
            // After each iteration, we narrow down the search to the left or the right side while still starting our search in the middle.
            currentIndex = (leftSide + rightSide) / 2;

            beforeOrAt = _observations[uint24(RingBufferLib.wrap(currentIndex, _cardinality))];
            uint32 beforeOrAtTimestamp = beforeOrAt.timestamp;

            // We've landed on an uninitialized timestamp, keep searching higher (more recently).
            if (beforeOrAtTimestamp == 0) {
                leftSide = currentIndex + 1;
                continue;
            }

            atOrAfter = _observations[uint24(RingBufferLib.nextIndex(currentIndex, _cardinality))];

            bool targetAtOrAfter = beforeOrAtTimestamp.lte(_target, _time);

            // Check if we've found the corresponding Observation.
            if (targetAtOrAfter && _target.lte(atOrAfter.timestamp, _time)) {
                break;
            }

            // If `beforeOrAtTimestamp` is greater than `_target`, then we keep searching lower. To the left of the current index.
            if (!targetAtOrAfter) {
                rightSide = currentIndex - 1;
            } else {
                // Otherwise, we keep searching higher. To the left of the current index.
                leftSide = currentIndex + 1;
            }
        }
    }
}",1006
RealWorld_TA_64_DrawBeacon_RealWorld_20240808180802.log,64,DrawBeacon,318856,4862,323718,131.0,1.69152,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""./interfaces/IDrawBeacon.sol"";
import ""./interfaces/IDrawBuffer.sol"";


/**
  * @title  PoolTogether V4 DrawBeacon
  * @author PoolTogether Inc Team
  * @notice Manages RNG (random number generator) requests and pushing Draws onto DrawBuffer.
            The DrawBeacon has 3 major actions for requesting a random number: start, cancel and complete.
            To create a new Draw, the user requests a new random number from the RNG service.
            When the random number is available, the user can create the draw using the create() method
            which will push the draw onto the DrawBuffer.
            If the RNG service fails to deliver a rng, when the request timeout elapses, the user can cancel the request.
*/
contract DrawBeacon is IDrawBeacon, Ownable {
    using SafeCast for uint256;
    using SafeERC20 for IERC20;

    /* ============ Variables ============ */

    /// @notice RNG contract interface
    RNGInterface internal rng;

    /// @notice Current RNG Request
    RngRequest internal rngRequest;

    /// @notice DrawBuffer address
    IDrawBuffer internal drawBuffer;

    /**
     * @notice RNG Request Timeout.  In fact, this is really a ""complete draw"" timeout.
     * @dev If the rng completes the award can still be cancelled.
     */
    uint32 internal rngTimeout;

    /// @notice Seconds between beacon period request
    uint32 internal beaconPeriodSeconds;

    /// @notice Epoch timestamp when beacon period can start
    uint64 internal beaconPeriodStartedAt;

    /**
     * @notice Next Draw ID to use when pushing a Draw onto DrawBuffer
     * @dev Starts at 1. This way we know that no Draw has been recorded at 0.
     */
    uint32 internal nextDrawId;

    /* ============ Structs ============ */

    /**
     * @notice RNG Request
     * @param id          RNG request ID
     * @param lockBlock   Block number that the RNG request is locked
     * @param requestedAt Time when RNG is requested
     */
    struct RngRequest {
        uint32 id;
        uint32 lockBlock;
        uint64 requestedAt;
    }

    /* ============ Events ============ */

    /**
     * @notice Emit when the DrawBeacon is deployed.
     * @param nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.
     * @param beaconPeriodStartedAt Timestamp when beacon period starts.
     */
    event Deployed(
        uint32 nextDrawId,
        uint64 beaconPeriodStartedAt
    );

    /* ============ Modifiers ============ */

    modifier requireDrawNotStarted() {
        _requireDrawNotStarted();
        _;
    }

    modifier requireCanStartDraw() {
        require(_isBeaconPeriodOver(), ""DrawBeacon/beacon-period-not-over"");
        require(!isRngRequested(), ""DrawBeacon/rng-already-requested"");
        _;
    }

    modifier requireCanCompleteRngRequest() {
        require(isRngRequested(), ""DrawBeacon/rng-not-requested"");
        require(isRngCompleted(), ""DrawBeacon/rng-not-complete"");
        _;
    }

    /* ============ Constructor ============ */

    /**
     * @notice Deploy the DrawBeacon smart contract.
     * @param _owner Address of the DrawBeacon owner
     * @param _drawBuffer The address of the draw buffer to push draws to
     * @param _rng The RNG service to use
     * @param _nextDrawId Draw ID at which the DrawBeacon should start. Can't be inferior to 1.
     * @param _beaconPeriodStart The starting timestamp of the beacon period.
     * @param _beaconPeriodSeconds The duration of the beacon period in seconds
     */
    constructor(
        address _owner,
        IDrawBuffer _drawBuffer,
        RNGInterface _rng,
        uint32 _nextDrawId,
        uint64 _beaconPeriodStart,
        uint32 _beaconPeriodSeconds,
        uint32 _rngTimeout
    ) Ownable(_owner) {
        require(_beaconPeriodStart > 0, ""DrawBeacon/beacon-period-greater-than-zero"");
        require(address(_rng) != address(0), ""DrawBeacon/rng-not-zero"");
        require(_nextDrawId >= 1, ""DrawBeacon/next-draw-id-gte-one"");

        beaconPeriodStartedAt = _beaconPeriodStart;
        nextDrawId = _nextDrawId;

        _setBeaconPeriodSeconds(_beaconPeriodSeconds);
        _setDrawBuffer(_drawBuffer);
        _setRngService(_rng);
        _setRngTimeout(_rngTimeout);

        emit Deployed(_nextDrawId, _beaconPeriodStart);
        emit BeaconPeriodStarted(_beaconPeriodStart);
    }

    /* ============ Public Functions ============ */

    /**
     * @notice Returns whether the random number request has completed.
     * @return True if a random number request has completed, false otherwise.
     */
    function isRngCompleted() public view override returns (bool) {
        return rng.isRequestComplete(rngRequest.id);
    }

    /**
     * @notice Returns whether a random number has been requested
     * @return True if a random number has been requested, false otherwise.
     */
    function isRngRequested() public view override returns (bool) {
        return rngRequest.id != 0;
    }

    /**
     * @notice Returns whether the random number request has timed out.
     * @return True if a random number request has timed out, false otherwise.
     */
    function isRngTimedOut() public view override returns (bool) {
        if (rngRequest.requestedAt == 0) {
            return false;
        } else {
            return rngTimeout + rngRequest.requestedAt < _currentTime();
        }
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawBeacon
    function canStartDraw() external view override returns (bool) {
        return _isBeaconPeriodOver() && !isRngRequested();
    }

    /// @inheritdoc IDrawBeacon
    function canCompleteDraw() external view override returns (bool) {
        return isRngRequested() && isRngCompleted();
    }

    /// @notice Calculates the next beacon start time, assuming all beacon periods have occurred between the last and now.
    /// @return The next beacon period start time
    function calculateNextBeaconPeriodStartTimeFromCurrentTime() external view returns (uint64) {
        return
            _calculateNextBeaconPeriodStartTime(
                beaconPeriodStartedAt,
                beaconPeriodSeconds,
                _currentTime()
            );
    }

    /// @inheritdoc IDrawBeacon
    function calculateNextBeaconPeriodStartTime(uint64 _time)
        external
        view
        override
        returns (uint64)
    {
        return
            _calculateNextBeaconPeriodStartTime(
                beaconPeriodStartedAt,
                beaconPeriodSeconds,
                _time
            );
    }

    /// @inheritdoc IDrawBeacon
    function cancelDraw() external override {
        require(isRngTimedOut(), ""DrawBeacon/rng-not-timedout"");
        uint32 requestId = rngRequest.id;
        uint32 lockBlock = rngRequest.lockBlock;
        delete rngRequest;
        emit DrawCancelled(requestId, lockBlock);
    }

    /// @inheritdoc IDrawBeacon
    function completeDraw() external override requireCanCompleteRngRequest {
        uint256 randomNumber = rng.randomNumber(rngRequest.id);
        uint32 _nextDrawId = nextDrawId;
        uint64 _beaconPeriodStartedAt = beaconPeriodStartedAt;
        uint32 _beaconPeriodSeconds = beaconPeriodSeconds;
        uint64 _time = _currentTime();

        // create Draw struct
        IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({
            winningRandomNumber: randomNumber,
            drawId: _nextDrawId,
            timestamp: rngRequest.requestedAt, // must use the startAward() timestamp to prevent front-running
            beaconPeriodStartedAt: _beaconPeriodStartedAt,
            beaconPeriodSeconds: _beaconPeriodSeconds
        });

        drawBuffer.pushDraw(_draw);

        // to avoid clock drift, we should calculate the start time based on the previous period start time.
        uint64 nextBeaconPeriodStartedAt = _calculateNextBeaconPeriodStartTime(
            _beaconPeriodStartedAt,
            _beaconPeriodSeconds,
            _time
        );
        beaconPeriodStartedAt = nextBeaconPeriodStartedAt;
        nextDrawId = _nextDrawId + 1;

        // Reset the rngReqeust state so Beacon period can start again.
        delete rngRequest;

        emit DrawCompleted(randomNumber);
        emit BeaconPeriodStarted(nextBeaconPeriodStartedAt);
    }

    /// @inheritdoc IDrawBeacon
    function beaconPeriodRemainingSeconds() external view override returns (uint64) {
        return _beaconPeriodRemainingSeconds();
    }

    /// @inheritdoc IDrawBeacon
    function beaconPeriodEndAt() external view override returns (uint64) {
        return _beaconPeriodEndAt();
    }

    function getBeaconPeriodSeconds() external view returns (uint32) {
        return beaconPeriodSeconds;
    }

    function getBeaconPeriodStartedAt() external view returns (uint64) {
        return beaconPeriodStartedAt;
    }

    function getDrawBuffer() external view returns (IDrawBuffer) {
        return drawBuffer;
    }

    function getNextDrawId() external view returns (uint32) {
        return nextDrawId;
    }

    /// @inheritdoc IDrawBeacon
    function getLastRngLockBlock() external view override returns (uint32) {
        return rngRequest.lockBlock;
    }

    function getLastRngRequestId() external view override returns (uint32) {
        return rngRequest.id;
    }

    function getRngService() external view returns (RNGInterface) {
        return rng;
    }

    function getRngTimeout() external view returns (uint32) {
        return rngTimeout;
    }

    /// @inheritdoc IDrawBeacon
    function isBeaconPeriodOver() external view override returns (bool) {
        return _isBeaconPeriodOver();
    }

    /// @inheritdoc IDrawBeacon
    function setDrawBuffer(IDrawBuffer newDrawBuffer)
        external
        override
        onlyOwner
        returns (IDrawBuffer)
    {
        return _setDrawBuffer(newDrawBuffer);
    }

    /// @inheritdoc IDrawBeacon
    function startDraw() external override requireCanStartDraw {
        (address feeToken, uint256 requestFee) = rng.getRequestFee();

        if (feeToken != address(0) && requestFee > 0) {
            IERC20(feeToken).safeIncreaseAllowance(address(rng), requestFee);
        }

        (uint32 requestId, uint32 lockBlock) = rng.requestRandomNumber();
        rngRequest.id = requestId;
        rngRequest.lockBlock = lockBlock;
        rngRequest.requestedAt = _currentTime();

        emit DrawStarted(requestId, lockBlock);
    }

    /// @inheritdoc IDrawBeacon
    function setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds)
        external
        override
        onlyOwner
        requireDrawNotStarted
    {
        _setBeaconPeriodSeconds(_beaconPeriodSeconds);
    }

    /// @inheritdoc IDrawBeacon
    function setRngTimeout(uint32 _rngTimeout) external override onlyOwner requireDrawNotStarted {
        _setRngTimeout(_rngTimeout);
    }

    /// @inheritdoc IDrawBeacon
    function setRngService(RNGInterface _rngService)
        external
        override
        onlyOwner
        requireDrawNotStarted
    {
        _setRngService(_rngService);
    }

    /**
     * @notice Sets the RNG service that the Prize Strategy is connected to
     * @param _rngService The address of the new RNG service interface
     */
    function _setRngService(RNGInterface _rngService) internal
    {
        rng = _rngService;
        emit RngServiceUpdated(_rngService);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculates when the next beacon period will start
     * @param _beaconPeriodStartedAt The timestamp at which the beacon period started
     * @param _beaconPeriodSeconds The duration of the beacon period in seconds
     * @param _time The timestamp to use as the current time
     * @return The timestamp at which the next beacon period would start
     */
    function _calculateNextBeaconPeriodStartTime(
        uint64 _beaconPeriodStartedAt,
        uint32 _beaconPeriodSeconds,
        uint64 _time
    ) internal pure returns (uint64) {
        uint64 elapsedPeriods = (_time - _beaconPeriodStartedAt) / _beaconPeriodSeconds;
        return _beaconPeriodStartedAt + (elapsedPeriods * _beaconPeriodSeconds);
    }

    /**
     * @notice returns the current time.  Used for testing.
     * @return The current time (block.timestamp)
     */
    function _currentTime() internal view virtual returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * @notice Returns the timestamp at which the beacon period ends
     * @return The timestamp at which the beacon period ends
     */
    function _beaconPeriodEndAt() internal view returns (uint64) {
        return beaconPeriodStartedAt + beaconPeriodSeconds;
    }

    /**
     * @notice Returns the number of seconds remaining until the prize can be awarded.
     * @return The number of seconds remaining until the prize can be awarded.
     */
    function _beaconPeriodRemainingSeconds() internal view returns (uint64) {
        uint64 endAt = _beaconPeriodEndAt();
        uint64 time = _currentTime();

        if (endAt <= time) {
            return 0;
        }

        return endAt - time;
    }

    /**
     * @notice Returns whether the beacon period is over.
     * @return True if the beacon period is over, false otherwise
     */
    function _isBeaconPeriodOver() internal view returns (bool) {
        return _beaconPeriodEndAt() <= _currentTime();
    }

    /**
     * @notice Check to see draw is in progress.
     */
    function _requireDrawNotStarted() internal view {
        uint256 currentBlock = block.number;

        require(
            rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock,
            ""DrawBeacon/rng-in-flight""
        );
    }

    /**
     * @notice Set global DrawBuffer variable.
     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.
     * @param _newDrawBuffer  DrawBuffer address
     * @return DrawBuffer
     */
    function _setDrawBuffer(IDrawBuffer _newDrawBuffer) internal returns (IDrawBuffer) {
        IDrawBuffer _previousDrawBuffer = drawBuffer;
        require(address(_newDrawBuffer) != address(0), ""DrawBeacon/draw-history-not-zero-address"");

        require(
            address(_newDrawBuffer) != address(_previousDrawBuffer),
            ""DrawBeacon/existing-draw-history-address""
        );

        drawBuffer = _newDrawBuffer;

        emit DrawBufferUpdated(_newDrawBuffer);

        return _newDrawBuffer;
    }

    /**
     * @notice Sets the beacon period in seconds.
     * @param _beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.
     */
    function _setBeaconPeriodSeconds(uint32 _beaconPeriodSeconds) internal {
        require(_beaconPeriodSeconds > 0, ""DrawBeacon/beacon-period-greater-than-zero"");
        beaconPeriodSeconds = _beaconPeriodSeconds;

        emit BeaconPeriodSecondsUpdated(_beaconPeriodSeconds);
    }

    /**
     * @notice Sets the RNG request timeout in seconds.  This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.
     * @param _rngTimeout The RNG request timeout in seconds.
     */
    function _setRngTimeout(uint32 _rngTimeout) internal {
        require(_rngTimeout > 60, ""DrawBeacon/rng-timeout-gt-60-secs"");
        rngTimeout = _rngTimeout;

        emit RngTimeoutSet(_rngTimeout);
    }
}",3606
RealWorld_TA_64_IPrizeFlush_RealWorld_20240808175427.log,64,IPrizeFlush,51468,1809,53277,77.0,0.29352,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IReserve.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IStrategy.sol"";

interface IPrizeFlush {
    /**
     * @notice Emit when the flush function has executed.
     * @param destination Address receiving funds
     * @param amount      Amount of tokens transferred
     */
    event Flushed(address indexed destination, uint256 amount);

    /**
     * @notice Emit when destination is set.
     * @param destination Destination address
     */
    event DestinationSet(address destination);

    /**
     * @notice Emit when strategy is set.
     * @param strategy Strategy address
     */
    event StrategySet(IStrategy strategy);

    /**
     * @notice Emit when reserve is set.
     * @param reserve Reserve address
     */
    event ReserveSet(IReserve reserve);

    /// @notice Read global destination variable.
    function getDestination() external view returns (address);

    /// @notice Read global reserve variable.
    function getReserve() external view returns (IReserve);

    /// @notice Read global strategy variable.
    function getStrategy() external view returns (IStrategy);

    /// @notice Set global destination variable.
    function setDestination(address _destination) external returns (address);

    /// @notice Set global reserve variable.
    function setReserve(IReserve _reserve) external returns (IReserve);

    /// @notice Set global strategy variable.
    function setStrategy(IStrategy _strategy) external returns (IStrategy);

    /**
     * @notice Migrate interest from PrizePool to PrizeDistributor in a single transaction.
     * @dev    Captures interest, checkpoint data and transfers tokens to final destination.
     * @return True if operation is successful.
     */
    function flush() external returns (bool);
}",399
RealWorld_TA_64_PrizeDistributionFactoryV2_RealWorld_20240808174247.log,64,PrizeDistributionFactoryV2,221879,3472,225351,121.0,1.178835,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionBuffer.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionSource.sol"";
import ""@pooltogether/v4-core/contracts/libraries/ExtendedSafeCastLib.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""./interfaces/IPrizeTierHistoryV2.sol"";

/**
 * @title PrizeDistributionFactoryV2
 * @author PoolTogether Inc.
 * @notice The PrizeDistributionFactoryV2 populates a Prize Distribution Buffer for a prize pool.  It uses a PrizeTierHistoryV2, Draw Buffer and Ticket
 * to compute the correct prize distribution.  It automatically sets the cardinality based on
 * the DPR (Draw Percentage Rate), prize, minPickCost and the total ticket supply.
 */
contract PrizeDistributionFactoryV2 is Ownable {
    using ExtendedSafeCastLib for uint256;

    /* ============ Events ============ */

    /**
     * @notice Emitted when a new Prize Distribution is pushed.
     * @param drawId The draw id for which the prize distribution was pushed
     */
    event PrizeDistributionPushed(uint32 indexed drawId);

    /**
     * @notice Emitted when a Prize Distribution is set (overrides another).
     * @param drawId The draw id for which the prize distribution was set
     */
    event PrizeDistributionSet(uint32 indexed drawId);

    /* ============ Variables ============ */

    /// @notice The prize tier history to pull tier information from.
    IPrizeTierHistoryV2 public immutable prizeTierHistory;

    /// @notice The draw buffer to pull the draw from.
    IDrawBuffer public immutable drawBuffer;

    /**
     * @notice The prize distribution buffer to push and set.
     * @dev This contract must be the manager or owner of the buffer.
     */
    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;

    /// @notice The ticket whose average total supply will be measured to calculate the portion of picks
    ITicket public immutable ticket;

    /// @notice The minimum cost of each pick.  Used to calculate the cardinality.
    uint256 public immutable minPickCost;

    /**
     * @notice Unit of normalization.
     * @dev The Draw Percentage Rate (DPR) being a 1e9 number,
     *      we need to normalize calculations by scaling up or down by 1e9
     */
    uint32 public constant RATE_NORMALIZATION = 1e9;

    /* ============ Constructor ============ */

    /**
     * @notice PrizeDistributionFactoryV2 constructor.
     * @param _owner Address of the contract owner
     * @param _prizeTierHistory Address of the IPrizeTierHistoryV2 contract
     * @param _drawBuffer Address of the DrawBuffer contract
     * @param _prizeDistributionBuffer Address of the PrizeDistributionBuffer contract
     * @param _ticket Address of the Prize Pool Ticket contract
     * @param _minPickCost Minimum cost of a pick for a draw
     */
    constructor(
        address _owner,
        IPrizeTierHistoryV2 _prizeTierHistory,
        IDrawBuffer _drawBuffer,
        IPrizeDistributionBuffer _prizeDistributionBuffer,
        ITicket _ticket,
        uint256 _minPickCost
    ) Ownable(_owner) {
        require(_owner != address(0), ""PDC/owner-zero"");
        require(address(_prizeTierHistory) != address(0), ""PDC/pth-zero"");
        require(address(_drawBuffer) != address(0), ""PDC/db-zero"");
        require(address(_prizeDistributionBuffer) != address(0), ""PDC/pdb-zero"");
        require(address(_ticket) != address(0), ""PDC/ticket-zero"");
        require(_minPickCost > 0, ""PDC/pick-cost-gt-zero"");

        minPickCost = _minPickCost;
        prizeTierHistory = _prizeTierHistory;
        drawBuffer = _drawBuffer;
        prizeDistributionBuffer = _prizeDistributionBuffer;
        ticket = _ticket;
    }

    /* ============ External Functions ============ */

    /**
     * @notice Push a new prize distribution onto the PrizeDistributionBuffer.
     *         PrizeTier and Draw for the given draw id will be pulled in and the prize distribution will be computed.
     * @param _drawId The draw id to compute for
     * @return The resulting Prize Distribution
     */
    function pushPrizeDistribution(uint32 _drawId)
        external
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        IPrizeDistributionBuffer.PrizeDistribution
            memory _prizeDistribution = _calculatePrizeDistribution(_drawId);

        prizeDistributionBuffer.pushPrizeDistribution(_drawId, _prizeDistribution);

        emit PrizeDistributionPushed(_drawId);

        return _prizeDistribution;
    }

    /**
     * @notice Allows the owner to override an existing prize distribution in the buffer.
     *         PrizeTier and Draw for the given draw id will be pulled in and the prize distribution will be computed.
     * @param _drawId The draw id to compute for
     * @return The resulting Prize Distribution
     */
    function setPrizeDistribution(uint32 _drawId)
        external
        onlyOwner
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        IPrizeDistributionBuffer.PrizeDistribution
            memory _prizeDistribution = _calculatePrizeDistribution(_drawId);

        prizeDistributionBuffer.setPrizeDistribution(_drawId, _prizeDistribution);

        emit PrizeDistributionSet(_drawId);

        return _prizeDistribution;
    }

    /**
     * @notice Calculate Prize Distribution for a given drawId
     * @param _drawId Draw ID
     * @return PrizeDistribution
     */
    function calculatePrizeDistribution(uint32 _drawId)
        external
        view
        virtual
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        return _calculatePrizeDistribution(_drawId);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculate Prize Distribution for a given drawId
     * @param _drawId Draw ID
     * @return PrizeDistribution
     */
    function _calculatePrizeDistribution(uint32 _drawId)
        internal
        view
        virtual
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        IPrizeTierHistoryV2.PrizeTierV2 memory _prizeTier = prizeTierHistory.getPrizeTier(_drawId);
        IDrawBeacon.Draw memory _draw = drawBuffer.getDraw(_drawId);

        (
            uint64[] memory _startTimes,
            uint64[] memory _endTimes
        ) = _calculateDrawPeriodTimestampOffsets(
                _draw.timestamp,
                _draw.beaconPeriodSeconds,
                _prizeTier.endTimestampOffset
            );

        uint256 _totalSupply = ticket.getAverageTotalSuppliesBetween(_startTimes, _endTimes)[0];

        (uint8 _cardinality, uint104 _numberOfPicks) = _calculateCardinalityAndNumberOfPicks(
            _prizeTier.bitRangeSize,
            _prizeTier.prize,
            _prizeTier.dpr,
            minPickCost,
            _totalSupply
        );

        IPrizeDistributionBuffer.PrizeDistribution
            memory _prizeDistribution = IPrizeDistributionSource.PrizeDistribution({
                bitRangeSize: _prizeTier.bitRangeSize,
                matchCardinality: _cardinality,
                startTimestampOffset: _draw.beaconPeriodSeconds,
                endTimestampOffset: _prizeTier.endTimestampOffset,
                maxPicksPerUser: _prizeTier.maxPicksPerUser,
                expiryDuration: _prizeTier.expiryDuration,
                numberOfPicks: _numberOfPicks,
                tiers: _prizeTier.tiers,
                prize: _prizeTier.prize
            });

        return _prizeDistribution;
    }

    /**
     * @notice Compute prize pool cardinality and number of picks for a draw.
     * @dev `cardinality` must be gte to one, that's why we use a do/while loop to increase it.
     * @param _bitRangeSize Bit range size
     * @param _prize Total prize amount
     * @param _dpr Draw percentage rate
     * @param _minPickCost Minimum cost for a pick
     * @param _totalSupply Prize Pool Ticket total supply
     * @return cardinality and number of picks
     */
    function _calculateCardinalityAndNumberOfPicks(
        uint8 _bitRangeSize,
        uint256 _prize,
        uint32 _dpr,
        uint256 _minPickCost,
        uint256 _totalSupply
    ) internal pure returns (uint8 cardinality, uint104 numberOfPicks) {
        uint256 _odds = (_dpr * _totalSupply) / _prize;

        if (_odds == 0) {
            return (cardinality = 1, numberOfPicks);
        }

        /**
         * maxPicks = totalSupply / minPickCost
         * targetPicks = maxPicks / odds = (totalSupply / minPickCost) / ((dpr * totalSupply) / prize)
         * targetPicks = (1 / minPickCost) / ((dpr * 1) / prize) = prize / (dpr * minPickCost)
         */
        uint256 _targetPicks = (_prize * RATE_NORMALIZATION) / (_dpr * _minPickCost);

        do {
            cardinality++;
        } while (_calculateTotalPicks(_bitRangeSize, cardinality + 1) < _targetPicks);

        numberOfPicks = ((_calculateTotalPicks(_bitRangeSize, cardinality) * _odds) /
            RATE_NORMALIZATION).toUint104();
    }

    /**
     * @notice Calculate Draw period start and end timestamp.
     * @param _timestamp Timestamp at which the draw was created by the DrawBeacon
     * @param _startOffset Draw start time offset in seconds
     * @param _endOffset Draw end time offset in seconds
     * @return Draw start and end timestamp
     */
    function _calculateDrawPeriodTimestampOffsets(
        uint64 _timestamp,
        uint32 _startOffset,
        uint32 _endOffset
    ) internal pure returns (uint64[] memory, uint64[] memory) {
        uint64[] memory _startTimestamps = new uint64[](1);
        uint64[] memory _endTimestamps = new uint64[](1);

        _startTimestamps[0] = _timestamp - _startOffset;
        _endTimestamps[0] = _timestamp - _endOffset;

        return (_startTimestamps, _endTimestamps);
    }

    /**
     * @notice Calculate total picks for a draw.
     * @param _bitRangeSize Bit range size
     * @param _cardinality Cardinality
     * @return Total number of picks
     */
    function _calculateTotalPicks(uint8 _bitRangeSize, uint8 _cardinality)
        internal
        pure
        returns (uint256)
    {
        return (2**_bitRangeSize)**_cardinality;
    }
}",2427
RealWorld_TA_64_DrawBuffer_RealWorld_20240808181357.log,64,DrawBuffer,138317,2986,141303,161.0,0.751305,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./interfaces/IDrawBuffer.sol"";
import ""./interfaces/IDrawBeacon.sol"";
import ""./libraries/DrawRingBufferLib.sol"";

/**
  * @title  PoolTogether V4 DrawBuffer
  * @author PoolTogether Inc Team
  * @notice The DrawBuffer provides historical lookups of Draws via a circular ring buffer.
            Historical Draws can be accessed on-chain using a drawId to calculate ring buffer storage slot.
            The Draw settings can be created by manager/owner and existing Draws can only be updated the owner.
            Once a starting Draw has been added to the ring buffer, all following draws must have a sequential Draw ID.
    @dev    A DrawBuffer store a limited number of Draws before beginning to overwrite (managed via the cardinality) previous Draws.
    @dev    All mainnet DrawBuffer(s) are updated directly from a DrawBeacon, but non-mainnet DrawBuffer(s) (Matic, Optimism, Arbitrum, etc...)
            will receive a cross-chain message, duplicating the mainnet Draw configuration - enabling a prize savings liquidity network.
*/
contract DrawBuffer is IDrawBuffer, Manageable {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    /// @notice Draws ring buffer max length.
    uint16 public constant MAX_CARDINALITY = 256;

    /// @notice Draws ring buffer array.
    IDrawBeacon.Draw[MAX_CARDINALITY] private drawRingBuffer;

    /// @notice Holds ring buffer information
    DrawRingBufferLib.Buffer internal bufferMetadata;

    /* ============ Deploy ============ */

    /**
     * @notice Deploy DrawBuffer smart contract.
     * @param _owner Address of the owner of the DrawBuffer.
     * @param _cardinality Draw ring buffer cardinality.
     */
    constructor(address _owner, uint8 _cardinality) Ownable(_owner) {
        bufferMetadata.cardinality = _cardinality;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawBuffer
    function getBufferCardinality() external view override returns (uint32) {
        return bufferMetadata.cardinality;
    }

    /// @inheritdoc IDrawBuffer
    function getDraw(uint32 drawId) external view override returns (IDrawBeacon.Draw memory) {
        return drawRingBuffer[_drawIdToDrawIndex(bufferMetadata, drawId)];
    }

    /// @inheritdoc IDrawBuffer
    function getDraws(uint32[] calldata _drawIds)
        external
        view
        override
        returns (IDrawBeacon.Draw[] memory)
    {
        IDrawBeacon.Draw[] memory draws = new IDrawBeacon.Draw[](_drawIds.length);
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        for (uint256 index = 0; index < _drawIds.length; index++) {
            draws[index] = drawRingBuffer[_drawIdToDrawIndex(buffer, _drawIds[index])];
        }

        return draws;
    }

    /// @inheritdoc IDrawBuffer
    function getDrawCount() external view override returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        if (buffer.lastDrawId == 0) {
            return 0;
        }

        uint32 bufferNextIndex = buffer.nextIndex;

        if (drawRingBuffer[bufferNextIndex].timestamp != 0) {
            return buffer.cardinality;
        } else {
            return bufferNextIndex;
        }
    }

    /// @inheritdoc IDrawBuffer
    function getNewestDraw() external view override returns (IDrawBeacon.Draw memory) {
        return _getNewestDraw(bufferMetadata);
    }

    /// @inheritdoc IDrawBuffer
    function getOldestDraw() external view override returns (IDrawBeacon.Draw memory) {
        // oldest draw should be next available index, otherwise it's at 0
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;
        IDrawBeacon.Draw memory draw = drawRingBuffer[buffer.nextIndex];

        if (draw.timestamp == 0) {
            // if draw is not init, then use draw at 0
            draw = drawRingBuffer[0];
        }

        return draw;
    }

    /// @inheritdoc IDrawBuffer
    function pushDraw(IDrawBeacon.Draw memory _draw)
        external
        override
        onlyManagerOrOwner
        returns (uint32)
    {
        return _pushDraw(_draw);
    }

    /// @inheritdoc IDrawBuffer
    function setDraw(IDrawBeacon.Draw memory _newDraw) external override onlyOwner returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;
        uint32 index = buffer.getIndex(_newDraw.drawId);
        drawRingBuffer[index] = _newDraw;
        emit DrawSet(_newDraw.drawId, _newDraw);
        return _newDraw.drawId;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Convert a Draw.drawId to a Draws ring buffer index pointer.
     * @dev    The getNewestDraw.drawId() is used to calculate a Draws ID delta position.
     * @param _drawId Draw.drawId
     * @return Draws ring buffer index pointer
     */
    function _drawIdToDrawIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        internal
        pure
        returns (uint32)
    {
        return _buffer.getIndex(_drawId);
    }

    /**
     * @notice Read newest Draw from the draws ring buffer.
     * @dev    Uses the lastDrawId to calculate the most recently added Draw.
     * @param _buffer Draw ring buffer
     * @return IDrawBeacon.Draw
     */
    function _getNewestDraw(DrawRingBufferLib.Buffer memory _buffer)
        internal
        view
        returns (IDrawBeacon.Draw memory)
    {
        return drawRingBuffer[_buffer.getIndex(_buffer.lastDrawId)];
    }

    /**
     * @notice Push Draw onto draws ring buffer history.
     * @dev    Push new draw onto draws list via authorized manager or owner.
     * @param _newDraw IDrawBeacon.Draw
     * @return Draw.drawId
     */
    function _pushDraw(IDrawBeacon.Draw memory _newDraw) internal returns (uint32) {
        DrawRingBufferLib.Buffer memory _buffer = bufferMetadata;
        drawRingBuffer[_buffer.nextIndex] = _newDraw;
        bufferMetadata = _buffer.push(_newDraw.drawId);

        emit DrawSet(_newDraw.drawId, _newDraw);

        return _newDraw.drawId;
    }
}",1422
RealWorld_TA_64_Ticket_RealWorld_20240808193620.log,64,Ticket,271977,3918,275895,121.0,1.438245,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./libraries/ExtendedSafeCastLib.sol"";
import ""./libraries/TwabLib.sol"";
import ""./interfaces/ITicket.sol"";
import ""./ControlledToken.sol"";

/**
  * @title  PoolTogether V4 Ticket
  * @author PoolTogether Inc Team
  * @notice The Ticket extends the standard ERC20 and ControlledToken interfaces with time-weighted average balance functionality.
            The average balance held by a user between two timestamps can be calculated, as well as the historic balance.  The
            historic total supply is available as well as the average total supply between two timestamps.

            A user may ""delegate"" their balance; increasing another user's historic balance while retaining their tokens.
*/
contract Ticket is ControlledToken, ITicket {
    using SafeERC20 for IERC20;
    using ExtendedSafeCastLib for uint256;

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DELEGATE_TYPEHASH =
        keccak256(""Delegate(address user,address delegate,uint256 nonce,uint256 deadline)"");

    /// @notice Record of token holders TWABs for each account.
    mapping(address => TwabLib.Account) internal userTwabs;

    /// @notice Record of tickets total supply and ring buff parameters used for observation.
    TwabLib.Account internal totalSupplyTwab;

    /// @notice Mapping of delegates.  Each address can delegate their ticket power to another.
    mapping(address => address) internal delegates;

    /* ============ Constructor ============ */

    /**
     * @notice Constructs Ticket with passed parameters.
     * @param _name ERC20 ticket token name.
     * @param _symbol ERC20 ticket token symbol.
     * @param decimals_ ERC20 ticket token decimals.
     * @param _controller ERC20 ticket controller address (ie: Prize Pool address).
     */
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) ControlledToken(_name, _symbol, decimals_, _controller) {}

    /* ============ External Functions ============ */

    /// @inheritdoc ITicket
    function getAccountDetails(address _user)
        external
        view
        override
        returns (TwabLib.AccountDetails memory)
    {
        return userTwabs[_user].details;
    }

    /// @inheritdoc ITicket
    function getTwab(address _user, uint16 _index)
        external
        view
        override
        returns (ObservationLib.Observation memory)
    {
        return userTwabs[_user].twabs[_index];
    }

    /// @inheritdoc ITicket
    function getBalanceAt(address _user, uint64 _target) external view override returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getBalanceAt(
                account.twabs,
                account.details,
                uint32(_target),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getAverageBalancesBetween(
        address _user,
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) external view override returns (uint256[] memory) {
        return _getAverageBalancesBetween(userTwabs[_user], _startTimes, _endTimes);
    }

    /// @inheritdoc ITicket
    function getAverageTotalSuppliesBetween(
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) external view override returns (uint256[] memory) {
        return _getAverageBalancesBetween(totalSupplyTwab, _startTimes, _endTimes);
    }

    /// @inheritdoc ITicket
    function getAverageBalanceBetween(
        address _user,
        uint64 _startTime,
        uint64 _endTime
    ) external view override returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                uint32(_startTime),
                uint32(_endTime),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getBalancesAt(address _user, uint64[] calldata _targets)
        external
        view
        override
        returns (uint256[] memory)
    {
        uint256 length = _targets.length;
        uint256[] memory _balances = new uint256[](length);

        TwabLib.Account storage twabContext = userTwabs[_user];
        TwabLib.AccountDetails memory details = twabContext.details;

        for (uint256 i = 0; i < length; i++) {
            _balances[i] = TwabLib.getBalanceAt(
                twabContext.twabs,
                details,
                uint32(_targets[i]),
                uint32(block.timestamp)
            );
        }

        return _balances;
    }

    /// @inheritdoc ITicket
    function getTotalSupplyAt(uint64 _target) external view override returns (uint256) {
        return
            TwabLib.getBalanceAt(
                totalSupplyTwab.twabs,
                totalSupplyTwab.details,
                uint32(_target),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getTotalSuppliesAt(uint64[] calldata _targets)
        external
        view
        override
        returns (uint256[] memory)
    {
        uint256 length = _targets.length;
        uint256[] memory totalSupplies = new uint256[](length);

        TwabLib.AccountDetails memory details = totalSupplyTwab.details;

        for (uint256 i = 0; i < length; i++) {
            totalSupplies[i] = TwabLib.getBalanceAt(
                totalSupplyTwab.twabs,
                details,
                uint32(_targets[i]),
                uint32(block.timestamp)
            );
        }

        return totalSupplies;
    }

    /// @inheritdoc ITicket
    function delegateOf(address _user) external view override returns (address) {
        return delegates[_user];
    }

    /// @inheritdoc ITicket
    function controllerDelegateFor(address _user, address _to) external override onlyController {
        _delegate(_user, _to);
    }

    /// @inheritdoc ITicket
    function delegateWithSignature(
        address _user,
        address _newDelegate,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external virtual override {
        require(block.timestamp <= _deadline, ""Ticket/delegate-expired-deadline"");

        bytes32 structHash = keccak256(abi.encode(_DELEGATE_TYPEHASH, _user, _newDelegate, _useNonce(_user), _deadline));

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(hash, _v, _r, _s);
        require(signer == _user, ""Ticket/delegate-invalid-signature"");

        _delegate(_user, _newDelegate);
    }

    /// @inheritdoc ITicket
    function delegate(address _to) external virtual override {
        _delegate(msg.sender, _to);
    }

    /// @notice Delegates a users chance to another
    /// @param _user The user whose balance should be delegated
    /// @param _to The delegate
    function _delegate(address _user, address _to) internal {
        uint256 balance = balanceOf(_user);
        address currentDelegate = delegates[_user];

        if (currentDelegate == _to) {
            return;
        }

        delegates[_user] = _to;

        _transferTwab(currentDelegate, _to, balance);

        emit Delegated(_user, _to);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Retrieves the average balances held by a user for a given time frame.
     * @param _account The user whose balance is checked.
     * @param _startTimes The start time of the time frame.
     * @param _endTimes The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function _getAverageBalancesBetween(
        TwabLib.Account storage _account,
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) internal view returns (uint256[] memory) {
        uint256 startTimesLength = _startTimes.length;
        require(startTimesLength == _endTimes.length, ""Ticket/start-end-times-length-match"");

        TwabLib.AccountDetails memory accountDetails = _account.details;

        uint256[] memory averageBalances = new uint256[](startTimesLength);
        uint32 currentTimestamp = uint32(block.timestamp);

        for (uint256 i = 0; i < startTimesLength; i++) {
            averageBalances[i] = TwabLib.getAverageBalanceBetween(
                _account.twabs,
                accountDetails,
                uint32(_startTimes[i]),
                uint32(_endTimes[i]),
                currentTimestamp
            );
        }

        return averageBalances;
    }

    // @inheritdoc ERC20
    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {
        if (_from == _to) {
            return;
        }

        address _fromDelegate;
        if (_from != address(0)) {
            _fromDelegate = delegates[_from];
        }

        address _toDelegate;
        if (_to != address(0)) {
            _toDelegate = delegates[_to];
        }

        _transferTwab(_fromDelegate, _toDelegate, _amount);
    }

    /// @notice Transfers the given TWAB balance from one user to another
    /// @param _from The user to transfer the balance from.  May be zero in the event of a mint.
    /// @param _to The user to transfer the balance to.  May be zero in the event of a burn.
    /// @param _amount The balance that is being transferred.
    function _transferTwab(address _from, address _to, uint256 _amount) internal {
        // If we are transferring tokens from a delegated account to an undelegated account
        if (_from != address(0)) {
            _decreaseUserTwab(_from, _amount);

            if (_to == address(0)) {
                _decreaseTotalSupplyTwab(_amount);
            }
        }

        // If we are transferring tokens from an undelegated account to a delegated account
        if (_to != address(0)) {
            _increaseUserTwab(_to, _amount);

            if (_from == address(0)) {
                _increaseTotalSupplyTwab(_amount);
            }
        }
    }

    /**
     * @notice Increase `_to` TWAB balance.
     * @param _to Address of the delegate.
     * @param _amount Amount of tokens to be added to `_to` TWAB balance.
     */
    function _increaseUserTwab(
        address _to,
        uint256 _amount
    ) internal {
        if (_amount == 0) {
            return;
        }

        TwabLib.Account storage _account = userTwabs[_to];

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        ) = TwabLib.increaseBalance(_account, _amount.toUint208(), uint32(block.timestamp));

        _account.details = accountDetails;

        if (isNew) {
            emit NewUserTwab(_to, twab);
        }
    }

    /**
     * @notice Decrease `_to` TWAB balance.
     * @param _to Address of the delegate.
     * @param _amount Amount of tokens to be added to `_to` TWAB balance.
     */
    function _decreaseUserTwab(
        address _to,
        uint256 _amount
    ) internal {
        if (_amount == 0) {
            return;
        }

        TwabLib.Account storage _account = userTwabs[_to];

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        ) = TwabLib.decreaseBalance(
                _account,
                _amount.toUint208(),
                ""Ticket/twab-burn-lt-balance"",
                uint32(block.timestamp)
            );

        _account.details = accountDetails;

        if (isNew) {
            emit NewUserTwab(_to, twab);
        }
    }

    /// @notice Decreases the total supply twab.  Should be called anytime a balance moves from delegated to undelegated
    /// @param _amount The amount to decrease the total by
    function _decreaseTotalSupplyTwab(uint256 _amount) internal {
        if (_amount == 0) {
            return;
        }

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory tsTwab,
            bool tsIsNew
        ) = TwabLib.decreaseBalance(
                totalSupplyTwab,
                _amount.toUint208(),
                ""Ticket/burn-amount-exceeds-total-supply-twab"",
                uint32(block.timestamp)
            );

        totalSupplyTwab.details = accountDetails;

        if (tsIsNew) {
            emit NewTotalSupplyTwab(tsTwab);
        }
    }

    /// @notice Increases the total supply twab.  Should be called anytime a balance moves from undelegated to delegated
    /// @param _amount The amount to increase the total by
    function _increaseTotalSupplyTwab(uint256 _amount) internal {
        if (_amount == 0) {
            return;
        }

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory _totalSupply,
            bool tsIsNew
        ) = TwabLib.increaseBalance(totalSupplyTwab, _amount.toUint208(), uint32(block.timestamp));

        totalSupplyTwab.details = accountDetails;

        if (tsIsNew) {
            emit NewTotalSupplyTwab(_totalSupply);
        }
    }
}",3022
RealWorld_TA_64_IPrizePool_RealWorld_20240808193323.log,64,IPrizePool,168501,2590,171091,92.0,0.894305,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../external/compound/ICompLike.sol"";
import ""../interfaces/ITicket.sol"";

interface IPrizePool {
    /// @dev Event emitted when controlled token is added
    event ControlledTokenAdded(ITicket indexed token);

    event AwardCaptured(uint256 amount);

    /// @dev Event emitted when assets are deposited
    event Deposited(
        address indexed operator,
        address indexed to,
        ITicket indexed token,
        uint256 amount
    );

    /// @dev Event emitted when interest is awarded to a winner
    event Awarded(address indexed winner, ITicket indexed token, uint256 amount);

    /// @dev Event emitted when external ERC20s are awarded to a winner
    event AwardedExternalERC20(address indexed winner, address indexed token, uint256 amount);

    /// @dev Event emitted when external ERC20s are transferred out
    event TransferredExternalERC20(address indexed to, address indexed token, uint256 amount);

    /// @dev Event emitted when external ERC721s are awarded to a winner
    event AwardedExternalERC721(address indexed winner, address indexed token, uint256[] tokenIds);

    /// @dev Event emitted when assets are withdrawn
    event Withdrawal(
        address indexed operator,
        address indexed from,
        ITicket indexed token,
        uint256 amount,
        uint256 redeemed
    );

    /// @dev Event emitted when the Balance Cap is set
    event BalanceCapSet(uint256 balanceCap);

    /// @dev Event emitted when the Liquidity Cap is set
    event LiquidityCapSet(uint256 liquidityCap);

    /// @dev Event emitted when the Prize Strategy is set
    event PrizeStrategySet(address indexed prizeStrategy);

    /// @dev Event emitted when the Ticket is set
    event TicketSet(ITicket indexed ticket);

    /// @dev Emitted when there was an error thrown awarding an External ERC721
    event ErrorAwardingExternalERC721(bytes error);

    /// @notice Deposit assets into the Prize Pool in exchange for tokens
    /// @param to The address receiving the newly minted tokens
    /// @param amount The amount of assets to deposit
    function depositTo(address to, uint256 amount) external;

    /// @notice Deposit assets into the Prize Pool in exchange for tokens,
    /// then sets the delegate on behalf of the caller.
    /// @param to The address receiving the newly minted tokens
    /// @param amount The amount of assets to deposit
    /// @param delegate The address to delegate to for the caller
    function depositToAndDelegate(address to, uint256 amount, address delegate) external;

    /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
    /// @param from The address to redeem tokens from.
    /// @param amount The amount of tokens to redeem for assets.
    /// @return The actual amount withdrawn
    function withdrawFrom(address from, uint256 amount) external returns (uint256);

    /// @notice Called by the prize strategy to award prizes.
    /// @dev The amount awarded must be less than the awardBalance()
    /// @param to The address of the winner that receives the award
    /// @param amount The amount of assets to be awarded
    function award(address to, uint256 amount) external;

    /// @notice Returns the balance that is available to award.
    /// @dev captureAwardBalance() should be called first
    /// @return The total amount of assets to be awarded for the current prize
    function awardBalance() external view returns (uint256);

    /// @notice Captures any available interest as award balance.
    /// @dev This function also captures the reserve fees.
    /// @return The total amount of assets to be awarded for the current prize
    function captureAwardBalance() external returns (uint256);

    /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
    /// @param externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function canAwardExternal(address externalToken) external view returns (bool);

    // @dev Returns the total underlying balance of all assets. This includes both principal and interest.
    /// @return The underlying balance of assets
    function balance() external returns (uint256);

    /**
     * @notice Read internal Ticket accounted balance.
     * @return uint256 accountBalance
     */
    function getAccountedBalance() external view returns (uint256);

    /**
     * @notice Read internal balanceCap variable
     */
    function getBalanceCap() external view returns (uint256);

    /**
     * @notice Read internal liquidityCap variable
     */
    function getLiquidityCap() external view returns (uint256);

    /**
     * @notice Read ticket variable
     */
    function getTicket() external view returns (ITicket);

    /**
     * @notice Read token variable
     */
    function getToken() external view returns (address);

    /**
     * @notice Read prizeStrategy variable
     */
    function getPrizeStrategy() external view returns (address);

    /// @dev Checks if a specific token is controlled by the Prize Pool
    /// @param controlledToken The address of the token to check
    /// @return True if the token is a controlled token, false otherwise
    function isControlled(ITicket controlledToken) external view returns (bool);

    /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
    /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
    /// @param to The address of the winner that receives the award
    /// @param externalToken The address of the external asset token being awarded
    /// @param amount The amount of external assets to be awarded
    function transferExternalERC20(
        address to,
        address externalToken,
        uint256 amount
    ) external;

    /// @notice Called by the Prize-Strategy to award external ERC20 prizes
    /// @dev Used to award any arbitrary tokens held by the Prize Pool
    /// @param to The address of the winner that receives the award
    /// @param amount The amount of external assets to be awarded
    /// @param externalToken The address of the external asset token being awarded
    function awardExternalERC20(
        address to,
        address externalToken,
        uint256 amount
    ) external;

    /// @notice Called by the prize strategy to award external ERC721 prizes
    /// @dev Used to award any arbitrary NFTs held by the Prize Pool
    /// @param to The address of the winner that receives the award
    /// @param externalToken The address of the external NFT token being awarded
    /// @param tokenIds An array of NFT Token IDs to be transferred
    function awardExternalERC721(
        address to,
        address externalToken,
        uint256[] calldata tokenIds
    ) external;

    /// @notice Allows the owner to set a balance cap per `token` for the pool.
    /// @dev If a user wins, his balance can go over the cap. He will be able to withdraw the excess but not deposit.
    /// @dev Needs to be called after deploying a prize pool to be able to deposit into it.
    /// @param balanceCap New balance cap.
    /// @return True if new balance cap has been successfully set.
    function setBalanceCap(uint256 balanceCap) external returns (bool);

    /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
    /// @param liquidityCap The new liquidity cap for the prize pool
    function setLiquidityCap(uint256 liquidityCap) external;

    /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
    /// @param _prizeStrategy The new prize strategy.
    function setPrizeStrategy(address _prizeStrategy) external;

    /// @notice Set prize pool ticket.
    /// @param ticket Address of the ticket to set.
    /// @return True if ticket has been successfully set.
    function setTicket(ITicket ticket) external returns (bool);

    /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
    /// @param compLike The COMP-like token held by the prize pool that should be delegated
    /// @param to The address to delegate to
    function compLikeDelegate(ICompLike compLike, address to) external;
}",1791
RealWorld_TA_64_DrawRingBufferLib_RealWorld_20240808185543.log,64,DrawRingBufferLib,61749,1456,63205,71.0,0.337865,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./RingBufferLib.sol"";

/// @title Library for creating and managing a draw ring buffer.
library DrawRingBufferLib {
    /// @notice Draw buffer struct.
    struct Buffer {
        uint32 lastDrawId;
        uint32 nextIndex;
        uint32 cardinality;
    }

    /// @notice Helper function to know if the draw ring buffer has been initialized.
    /// @dev since draws start at 1 and are monotonically increased, we know we are uninitialized if nextIndex = 0 and lastDrawId = 0.
    /// @param _buffer The buffer to check.
    function isInitialized(Buffer memory _buffer) internal pure returns (bool) {
        return !(_buffer.nextIndex == 0 && _buffer.lastDrawId == 0);
    }

    /// @notice Push a draw to the buffer.
    /// @param _buffer The buffer to push to.
    /// @param _drawId The drawID to push.
    /// @return The new buffer.
    function push(Buffer memory _buffer, uint32 _drawId) internal pure returns (Buffer memory) {
        require(!isInitialized(_buffer) || _drawId == _buffer.lastDrawId + 1, ""DRB/must-be-contig"");

        return
            Buffer({
                lastDrawId: _drawId,
                nextIndex: uint32(RingBufferLib.nextIndex(_buffer.nextIndex, _buffer.cardinality)),
                cardinality: _buffer.cardinality
            });
    }

    /// @notice Get draw ring buffer index pointer.
    /// @param _buffer The buffer to get the `nextIndex` from.
    /// @param _drawId The draw id to get the index for.
    /// @return The draw ring buffer index pointer.
    function getIndex(Buffer memory _buffer, uint32 _drawId) internal pure returns (uint32) {
        require(isInitialized(_buffer) && _drawId <= _buffer.lastDrawId, ""DRB/future-draw"");

        uint32 indexOffset = _buffer.lastDrawId - _drawId;
        require(indexOffset < _buffer.cardinality, ""DRB/expired-draw"");

        uint256 mostRecent = RingBufferLib.newestIndex(_buffer.nextIndex, _buffer.cardinality);

        return uint32(RingBufferLib.offset(uint32(mostRecent), indexOffset, _buffer.cardinality));
    }
}",513
RealWorld_TA_64_IPrizeTierHistoryV2_RealWorld_20240808180036.log,64,IPrizeTierHistoryV2,92971,1704,94675,85.0,0.498935,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/DrawBeacon.sol"";

/**
 * @title  PoolTogether V4 IPrizeTierHistoryV2
 * @author PoolTogether Inc Team
 * @notice IPrizeTierHistoryV2 is the base contract for PrizeTierHistoryV2
 */
interface IPrizeTierHistoryV2 {
    /**
     * @notice PrizeTierV2 struct
     * @dev    Adds Draw Percentage Rate (DPR) parameter to PrizeTier struct
     */
    struct PrizeTierV2 {
        uint8 bitRangeSize;
        uint32 drawId;
        uint32 maxPicksPerUser;
        uint32 expiryDuration;
        uint32 endTimestampOffset;
        uint32 dpr;
        uint256 prize;
        uint32[16] tiers;
    }

    /**
     * @notice Emit when new PrizeTierV2 is added to history
     * @param drawId    Draw ID
     * @param prizeTier PrizeTierV2 parameters
     */
    event PrizeTierPushed(uint32 indexed drawId, PrizeTierV2 prizeTier);

    /**
     * @notice Emitted when existing PrizeTierV2 is updated in history
     * @param drawId    Draw ID
     * @param prizeTier PrizeTierV2 parameters
     */
    event PrizeTierSet(uint32 indexed drawId, PrizeTierV2 prizeTier);

    /**
     * @notice Push PrizeTierV2 struct onto `prizeTiers` array.
     * @dev Callable only by the owner or manager.
     * @dev `drawId` must be greater than the latest one stored in `history`.
     * @param nextPrizeTier Next PrizeTierV2 struct
     */
    function push(PrizeTierV2 calldata nextPrizeTier) external;

    /**
     * @notice Replace PrizeTierV2 struct in `prizeTiers` array.
     * @dev    Callable only by the owner.
     * @param newPrizeTier PrizeTierV2 parameters
     */
    function replace(PrizeTierV2 calldata newPrizeTier) external;

    /**
     * @notice Pop the latest prize tier stored in the `prizeTiers` array and replace it with the new prize tier.
     * @dev    Callable only by the owner.
     * @param newPrizeTier Updated PrizeTierV2 struct
     * @return drawId Draw ID of the PrizeTierV2 that was pushed
     */
    function popAndPush(PrizeTierV2 calldata newPrizeTier) external returns (uint32 drawId);

    /**
     * @notice Returns the number of Prize Tier structs pushed
     * @return The number of prize tiers that have been pushed
     */
    function count() external view returns (uint256);

    /**
     * @notice Read PrizeTierHistory struct from history array.
     * @param drawId Draw ID
     * @return prizeTier
     */
    function getPrizeTier(uint32 drawId) external view returns (PrizeTierV2 memory prizeTier);

    /**
     * @notice Read PrizeTierV2 struct using Draw ID as the input
     * @param drawIds Draw ID
     * @return prizeTierList PrizeTierV2[] - Parameters to calculate PrizeDistrubtion
     */
    function getPrizeTierList(uint32[] calldata drawIds)
        external
        view
        returns (PrizeTierV2[] memory prizeTierList);

    /**
     * @notice Get prize tier at the specified `index`.
     * @param index Index at which to get the prize tier
     * @return PrizeTier at `index`
     */
    function getPrizeTierAtIndex(uint256 index) external view returns (PrizeTierV2 memory);

    /**
     * @notice Read first Draw ID used to initialize history
     * @return Draw ID of first PrizeTierV2 record
     */
    function getOldestDrawId() external view returns (uint32);

    /**
     * @notice Read last Draw ID stored in the history.
     * @return Draw ID of the last recorded PrizeTier record
     */
    function getNewestDrawId() external view returns (uint32);
}",908
RealWorld_TA_64_IDrawCalculator_RealWorld_20240808191745.log,64,IDrawCalculator,57657,1347,59004,73.0,0.315225,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./ITicket.sol"";
import ""./IDrawBuffer.sol"";
import ""../PrizeDistributionBuffer.sol"";
import ""../PrizeDistributor.sol"";

/**
 * @title  PoolTogether V4 IDrawCalculator
 * @author PoolTogether Inc Team
 * @notice The DrawCalculator interface.
 */
interface IDrawCalculator {
    struct PickPrize {
        bool won;
        uint8 tierIndex;
    }

    ///@notice Emitted when the contract is initialized
    event Deployed(
        ITicket indexed ticket,
        IDrawBuffer indexed drawBuffer,
        IPrizeDistributionBuffer indexed prizeDistributionBuffer
    );

    ///@notice Emitted when the prizeDistributor is set/updated
    event PrizeDistributorSet(PrizeDistributor indexed prizeDistributor);

    /**
     * @notice Calculates the prize amount for a user for Multiple Draws. Typically called by a PrizeDistributor.
     * @param user User for which to calculate prize amount.
     * @param drawIds drawId array for which to calculate prize amounts for.
     * @param data The ABI encoded pick indices for all Draws. Expected to be winning picks. Pick indices must be less than the totalUserPicks.
     * @return List of awardable prize amounts ordered by drawId.
     */
    function calculate(
        address user,
        uint32[] calldata drawIds,
        bytes calldata data
    ) external view returns (uint256[] memory, bytes memory);

    /**
     * @notice Read global DrawBuffer variable.
     * @return IDrawBuffer
     */
    function getDrawBuffer() external view returns (IDrawBuffer);

    /**
     * @notice Read global DrawBuffer variable.
     * @return IDrawBuffer
     */
    function getPrizeDistributionBuffer() external view returns (IPrizeDistributionBuffer);

    /**
     * @notice Returns a users balances expressed as a fraction of the total supply over time.
     * @param user The users address
     * @param drawIds The drawsId to consider
     * @return Array of balances
     */
    function getNormalizedBalancesForDrawIds(address user, uint32[] calldata drawIds)
        external
        view
        returns (uint256[] memory);

}",482
RealWorld_TA_64_PrizeFlush_RealWorld_20240808173749.log,64,PrizeFlush,107901,2428,110329,94.0,0.588065,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./interfaces/IPrizeFlush.sol"";

/**
 * @title  PoolTogether V4 PrizeFlush
 * @author PoolTogether Inc Team
 * @notice The PrizeFlush contract helps capture interest from the PrizePool and move collected funds
           to a designated PrizeDistributor contract. When deployed, the destination, reserve and strategy
           addresses are set and used as static parameters during every ""flush"" execution. The parameters can be
           reset by the Owner if necessary.
 */
contract PrizeFlush is IPrizeFlush, Manageable {
    /**
     * @notice Destination address for captured interest.
     * @dev Should be set to the PrizeDistributor address.
     */
    address internal destination;

    /// @notice Reserve address.
    IReserve internal reserve;

    /// @notice Strategy address.
    IStrategy internal strategy;

    /**
     * @notice Emitted when contract has been deployed.
     * @param destination Destination address
     * @param reserve Strategy address
     * @param strategy Reserve address
     *
     */
    event Deployed(
        address indexed destination,
        IReserve indexed reserve,
        IStrategy indexed strategy
    );

    /* ============ Constructor ============ */

    /**
     * @notice Deploy Prize Flush.
     * @param _owner Prize Flush owner address
     * @param _destination Destination address
     * @param _strategy Strategy address
     * @param _reserve Reserve address
     *
     */
    constructor(
        address _owner,
        address _destination,
        IStrategy _strategy,
        IReserve _reserve
    ) Ownable(_owner) {
        _setDestination(_destination);
        _setReserve(_reserve);
        _setStrategy(_strategy);

        emit Deployed(_destination, _reserve, _strategy);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeFlush
    function getDestination() external view override returns (address) {
        return destination;
    }

    /// @inheritdoc IPrizeFlush
    function getReserve() external view override returns (IReserve) {
        return reserve;
    }

    /// @inheritdoc IPrizeFlush
    function getStrategy() external view override returns (IStrategy) {
        return strategy;
    }

    /// @inheritdoc IPrizeFlush
    function setDestination(address _destination) external override onlyOwner returns (address) {
        _setDestination(_destination);
        emit DestinationSet(_destination);
        return _destination;
    }

    /// @inheritdoc IPrizeFlush
    function setReserve(IReserve _reserve) external override onlyOwner returns (IReserve) {
        _setReserve(_reserve);
        emit ReserveSet(_reserve);
        return _reserve;
    }

    /// @inheritdoc IPrizeFlush
    function setStrategy(IStrategy _strategy) external override onlyOwner returns (IStrategy) {
        _setStrategy(_strategy);
        emit StrategySet(_strategy);
        return _strategy;
    }

    /// @inheritdoc IPrizeFlush
    function flush() external override onlyManagerOrOwner returns (bool) {
        // Captures interest from PrizePool and distributes funds using a PrizeSplitStrategy.
        strategy.distribute();

        // After funds are distributed using PrizeSplitStrategy we EXPECT funds to be located in the Reserve.
        IReserve _reserve = reserve;
        IERC20 _token = _reserve.getToken();
        uint256 _amount = _token.balanceOf(address(_reserve));

        // IF the tokens were succesfully moved to the Reserve, now move them to the destination (PrizeDistributor) address.
        if (_amount > 0) {
            address _destination = destination;

            // Create checkpoint and transfers new total balance to PrizeDistributor
            _reserve.withdrawTo(_destination, _amount);

            emit Flushed(_destination, _amount);
            return true;
        }

        return false;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Set global destination variable.
     * @dev `_destination` cannot be the zero address.
     * @param _destination Destination address
     */
    function _setDestination(address _destination) internal {
        require(_destination != address(0), ""Flush/destination-not-zero-address"");
        destination = _destination;
    }

    /**
     * @notice Set global reserve variable.
     * @dev `_reserve` cannot be the zero address.
     * @param _reserve Reserve address
     */
    function _setReserve(IReserve _reserve) internal {
        require(address(_reserve) != address(0), ""Flush/reserve-not-zero-address"");
        reserve = _reserve;
    }

    /**
     * @notice Set global strategy variable.
     * @dev `_strategy` cannot be the zero address.
     * @param _strategy Strategy address
     */
    function _setStrategy(IStrategy _strategy) internal {
        require(address(_strategy) != address(0), ""Flush/strategy-not-zero-address"");
        strategy = _strategy;
    }
}",1092
RealWorld_TA_64_ITwabRewards_RealWorld_20240808175700.log,64,ITwabRewards,135042,2391,137433,109.0,0.72303,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title  PoolTogether V4 ITwabRewards
 * @author PoolTogether Inc Team
 * @notice TwabRewards contract interface.
 */
interface ITwabRewards {
    /**
     * @notice Struct to keep track of each promotion's settings.
     * @param creator Addresss of the promotion creator
     * @param startTimestamp Timestamp at which the promotion starts
     * @param numberOfEpochs Number of epochs the promotion will last for
     * @param epochDuration Duration of one epoch in seconds
     * @param createdAt Timestamp at which the promotion was created
     * @param token Address of the token to be distributed as reward
     * @param tokensPerEpoch Number of tokens to be distributed per epoch
     * @param rewardsUnclaimed Amount of rewards that have not been claimed yet
     */
    struct Promotion {
        address creator;
        uint64 startTimestamp;
        uint8 numberOfEpochs;
        uint48 epochDuration;
        uint48 createdAt;
        IERC20 token;
        uint256 tokensPerEpoch;
        uint256 rewardsUnclaimed;
    }

    /**
     * @notice Creates a new promotion.
     * @dev For sake of simplicity, `msg.sender` will be the creator of the promotion.
     * @dev `_latestPromotionId` starts at 0 and is incremented by 1 for each new promotion.
     * So the first promotion will have id 1, the second 2, etc.
     * @dev The transaction will revert if the amount of reward tokens provided is not equal to `_tokensPerEpoch * _numberOfEpochs`.
     * This scenario could happen if the token supplied is a fee on transfer one.
     * @param _token Address of the token to be distributed
     * @param _startTimestamp Timestamp at which the promotion starts
     * @param _tokensPerEpoch Number of tokens to be distributed per epoch
     * @param _epochDuration Duration of one epoch in seconds
     * @param _numberOfEpochs Number of epochs the promotion will last for
     * @return Id of the newly created promotion
     */
    function createPromotion(
        IERC20 _token,
        uint64 _startTimestamp,
        uint256 _tokensPerEpoch,
        uint48 _epochDuration,
        uint8 _numberOfEpochs
    ) external returns (uint256);

    /**
     * @notice End currently active promotion and send promotion tokens back to the creator.
     * @dev Will only send back tokens from the epochs that have not completed.
     * @param _promotionId Promotion id to end
     * @param _to Address that will receive the remaining tokens if there are any left
     * @return true if operation was successful
     */
    function endPromotion(uint256 _promotionId, address _to) external returns (bool);

    /**
     * @notice Delete an inactive promotion and send promotion tokens back to the creator.
     * @dev Will send back all the tokens that have not been claimed yet by users.
     * @dev This function will revert if the promotion is still active.
     * @dev This function will revert if the grace period is not over yet.
     * @param _promotionId Promotion id to destroy
     * @param _to Address that will receive the remaining tokens if there are any left
     * @return True if operation was successful
     */
    function destroyPromotion(uint256 _promotionId, address _to) external returns (bool);

    /**
     * @notice Extend promotion by adding more epochs.
     * @param _promotionId Id of the promotion to extend
     * @param _numberOfEpochs Number of epochs to add
     * @return True if the operation was successful
     */
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs) external returns (bool);

    /**
     * @notice Claim rewards for a given promotion and epoch.
     * @dev Rewards can be claimed on behalf of a user.
     * @dev Rewards can only be claimed for a past epoch.
     * @param _user Address of the user to claim rewards for
     * @param _promotionId Id of the promotion to claim rewards for
     * @param _epochIds Epoch ids to claim rewards for
     * @return Total amount of rewards claimed
     */
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint8[] calldata _epochIds
    ) external returns (uint256);

    /**
     * @notice Get settings for a specific promotion.
     * @param _promotionId Id of the promotion to get settings for
     * @return Promotion settings
     */
    function getPromotion(uint256 _promotionId) external view returns (Promotion memory);

    /**
     * @notice Get the current epoch id of a promotion.
     * @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
     * @param _promotionId Id of the promotion to get current epoch for
     * @return Current epoch id of the promotion
     */
    function getCurrentEpochId(uint256 _promotionId) external view returns (uint256);

    /**
     * @notice Get the total amount of tokens left to be rewarded.
     * @param _promotionId Id of the promotion to get the total amount of tokens left to be rewarded for
     * @return Amount of tokens left to be rewarded
     */
    function getRemainingRewards(uint256 _promotionId) external view returns (uint256);

    /**
     * @notice Get amount of tokens to be rewarded for a given epoch.
     * @dev Rewards amount can only be retrieved for epochs that are over.
     * @dev Will revert if `_epochId` is over the total number of epochs or if epoch is not over.
     * @dev Will return 0 if the user average balance of tickets is 0.
     * @dev Will be 0 if user has already claimed rewards for the epoch.
     * @param _user Address of the user to get amount of rewards for
     * @param _promotionId Id of the promotion from which the epoch is
     * @param _epochIds Epoch ids to get reward amount for
     * @return Amount of tokens per epoch to be rewarded
     */
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint8[] calldata _epochIds
    ) external view returns (uint256[] memory);
}",1395
RealWorld_TA_64_PrizePool_RealWorld_20240808191213.log,64,PrizePool,319978,4734,324712,152.0,1.69457,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../interfaces/IPrizePool.sol"";
import ""../interfaces/ITicket.sol"";

/**
  * @title  PoolTogether V4 PrizePool
  * @author PoolTogether Inc Team
  * @notice Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.
            Users deposit and withdraw from this contract to participate in Prize Pool.
            Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
            Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
*/
abstract contract PrizePool is IPrizePool, Ownable, ReentrancyGuard, IERC721Receiver {
    using SafeCast for uint256;
    using SafeERC20 for IERC20;
    using ERC165Checker for address;

    /// @notice Semver Version
    string public constant VERSION = ""4.0.0"";

    /// @notice Prize Pool ticket. Can only be set once by calling `setTicket()`.
    ITicket internal ticket;

    /// @notice The Prize Strategy that this Prize Pool is bound to.
    address internal prizeStrategy;

    /// @notice The total amount of tickets a user can hold.
    uint256 internal balanceCap;

    /// @notice The total amount of funds that the prize pool can hold.
    uint256 internal liquidityCap;

    /// @notice the The awardable balance
    uint256 internal _currentAwardBalance;

    /* ============ Modifiers ============ */

    /// @dev Function modifier to ensure caller is the prize-strategy
    modifier onlyPrizeStrategy() {
        require(msg.sender == prizeStrategy, ""PrizePool/only-prizeStrategy"");
        _;
    }

    /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
    modifier canAddLiquidity(uint256 _amount) {
        require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
        _;
    }

    /* ============ Constructor ============ */

    /// @notice Deploy the Prize Pool
    /// @param _owner Address of the Prize Pool owner
    constructor(address _owner) Ownable(_owner) ReentrancyGuard() {
        _setLiquidityCap(type(uint256).max);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizePool
    function balance() external override returns (uint256) {
        return _balance();
    }

    /// @inheritdoc IPrizePool
    function awardBalance() external view override returns (uint256) {
        return _currentAwardBalance;
    }

    /// @inheritdoc IPrizePool
    function canAwardExternal(address _externalToken) external view override returns (bool) {
        return _canAwardExternal(_externalToken);
    }

    /// @inheritdoc IPrizePool
    function isControlled(ITicket _controlledToken) external view override returns (bool) {
        return _isControlled(_controlledToken);
    }

    /// @inheritdoc IPrizePool
    function getAccountedBalance() external view override returns (uint256) {
        return _ticketTotalSupply();
    }

    /// @inheritdoc IPrizePool
    function getBalanceCap() external view override returns (uint256) {
        return balanceCap;
    }

    /// @inheritdoc IPrizePool
    function getLiquidityCap() external view override returns (uint256) {
        return liquidityCap;
    }

    /// @inheritdoc IPrizePool
    function getTicket() external view override returns (ITicket) {
        return ticket;
    }

    /// @inheritdoc IPrizePool
    function getPrizeStrategy() external view override returns (address) {
        return prizeStrategy;
    }

    /// @inheritdoc IPrizePool
    function getToken() external view override returns (address) {
        return address(_token());
    }

    /// @inheritdoc IPrizePool
    function captureAwardBalance() external override nonReentrant returns (uint256) {
        uint256 ticketTotalSupply = _ticketTotalSupply();
        uint256 currentAwardBalance = _currentAwardBalance;

        // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
        uint256 currentBalance = _balance();
        uint256 totalInterest = (currentBalance > ticketTotalSupply)
            ? currentBalance - ticketTotalSupply
            : 0;

        uint256 unaccountedPrizeBalance = (totalInterest > currentAwardBalance)
            ? totalInterest - currentAwardBalance
            : 0;

        if (unaccountedPrizeBalance > 0) {
            currentAwardBalance = totalInterest;
            _currentAwardBalance = currentAwardBalance;

            emit AwardCaptured(unaccountedPrizeBalance);
        }

        return currentAwardBalance;
    }

    /// @inheritdoc IPrizePool
    function depositTo(address _to, uint256 _amount)
        external
        override
        nonReentrant
        canAddLiquidity(_amount)
    {
        _depositTo(msg.sender, _to, _amount);
    }

    /// @inheritdoc IPrizePool
    function depositToAndDelegate(address _to, uint256 _amount, address _delegate)
        external
        override
        nonReentrant
        canAddLiquidity(_amount)
    {
        _depositTo(msg.sender, _to, _amount);
        ticket.controllerDelegateFor(msg.sender, _delegate);
    }

    /// @notice Transfers tokens in from one user and mints tickets to another
    /// @notice _operator The user to transfer tokens from
    /// @notice _to The user to mint tickets to
    /// @notice _amount The amount to transfer and mint
    function _depositTo(address _operator, address _to, uint256 _amount) internal
    {
        require(_canDeposit(_to, _amount), ""PrizePool/exceeds-balance-cap"");

        ITicket _ticket = ticket;

        _token().safeTransferFrom(_operator, address(this), _amount);

        _mint(_to, _amount, _ticket);
        _supply(_amount);

        emit Deposited(_operator, _to, _ticket, _amount);
    }

    /// @inheritdoc IPrizePool
    function withdrawFrom(address _from, uint256 _amount)
        external
        override
        nonReentrant
        returns (uint256)
    {
        ITicket _ticket = ticket;

        // burn the tickets
        _ticket.controllerBurnFrom(msg.sender, _from, _amount);

        // redeem the tickets
        uint256 _redeemed = _redeem(_amount);

        _token().safeTransfer(_from, _redeemed);

        emit Withdrawal(msg.sender, _from, _ticket, _amount, _redeemed);

        return _redeemed;
    }

    /// @inheritdoc IPrizePool
    function award(address _to, uint256 _amount) external override onlyPrizeStrategy {
        if (_amount == 0) {
            return;
        }

        uint256 currentAwardBalance = _currentAwardBalance;

        require(_amount <= currentAwardBalance, ""PrizePool/award-exceeds-avail"");

        unchecked {
            _currentAwardBalance = currentAwardBalance - _amount;
        }

        ITicket _ticket = ticket;

        _mint(_to, _amount, _ticket);

        emit Awarded(_to, _ticket, _amount);
    }

    /// @inheritdoc IPrizePool
    function transferExternalERC20(
        address _to,
        address _externalToken,
        uint256 _amount
    ) external override onlyPrizeStrategy {
        if (_transferOut(_to, _externalToken, _amount)) {
            emit TransferredExternalERC20(_to, _externalToken, _amount);
        }
    }

    /// @inheritdoc IPrizePool
    function awardExternalERC20(
        address _to,
        address _externalToken,
        uint256 _amount
    ) external override onlyPrizeStrategy {
        if (_transferOut(_to, _externalToken, _amount)) {
            emit AwardedExternalERC20(_to, _externalToken, _amount);
        }
    }

    /// @inheritdoc IPrizePool
    function awardExternalERC721(
        address _to,
        address _externalToken,
        uint256[] calldata _tokenIds
    ) external override onlyPrizeStrategy {
        require(_canAwardExternal(_externalToken), ""PrizePool/invalid-external-token"");

        if (_tokenIds.length == 0) {
            return;
        }

        uint256[] memory _awardedTokenIds = new uint256[](_tokenIds.length); 
        bool hasAwardedTokenIds;

        for (uint256 i = 0; i < _tokenIds.length; i++) {
            try IERC721(_externalToken).safeTransferFrom(address(this), _to, _tokenIds[i]) {
                hasAwardedTokenIds = true;
                _awardedTokenIds[i] = _tokenIds[i];
            } catch (
                bytes memory error
            ) {
                emit ErrorAwardingExternalERC721(error);
            }
        }
        if (hasAwardedTokenIds) { 
            emit AwardedExternalERC721(_to, _externalToken, _awardedTokenIds);
        }
    }

    /// @inheritdoc IPrizePool
    function setBalanceCap(uint256 _balanceCap) external override onlyOwner returns (bool) {
        _setBalanceCap(_balanceCap);
        return true;
    }

    /// @inheritdoc IPrizePool
    function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
        _setLiquidityCap(_liquidityCap);
    }

    /// @inheritdoc IPrizePool
    function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {
        require(address(_ticket) != address(0), ""PrizePool/ticket-not-zero-address"");
        require(address(ticket) == address(0), ""PrizePool/ticket-already-set"");

        ticket = _ticket;

        emit TicketSet(_ticket);

        _setBalanceCap(type(uint256).max);

        return true;
    }

    /// @inheritdoc IPrizePool
    function setPrizeStrategy(address _prizeStrategy) external override onlyOwner {
        _setPrizeStrategy(_prizeStrategy);
    }

    /// @inheritdoc IPrizePool
    function compLikeDelegate(ICompLike _compLike, address _to) external override onlyOwner {
        if (_compLike.balanceOf(address(this)) > 0) {
            _compLike.delegate(_to);
        }
    }

    /// @inheritdoc IERC721Receiver
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    /* ============ Internal Functions ============ */

    /// @notice Transfer out `amount` of `externalToken` to recipient `to`
    /// @dev Only awardable `externalToken` can be transferred out
    /// @param _to Recipient address
    /// @param _externalToken Address of the external asset token being transferred
    /// @param _amount Amount of external assets to be transferred
    /// @return True if transfer is successful
    function _transferOut(
        address _to,
        address _externalToken,
        uint256 _amount
    ) internal returns (bool) {
        require(_canAwardExternal(_externalToken), ""PrizePool/invalid-external-token"");

        if (_amount == 0) {
            return false;
        }

        IERC20(_externalToken).safeTransfer(_to, _amount);

        return true;
    }

    /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
    /// @param _to The user who is receiving the tokens
    /// @param _amount The amount of tokens they are receiving
    /// @param _controlledToken The token that is going to be minted
    function _mint(
        address _to,
        uint256 _amount,
        ITicket _controlledToken
    ) internal {
        _controlledToken.controllerMint(_to, _amount);
    }

    /// @dev Checks if `user` can deposit in the Prize Pool based on the current balance cap.
    /// @param _user Address of the user depositing.
    /// @param _amount The amount of tokens to be deposited into the Prize Pool.
    /// @return True if the Prize Pool can receive the specified `amount` of tokens.
    function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {
        uint256 _balanceCap = balanceCap;

        if (_balanceCap == type(uint256).max) return true;

        return (ticket.balanceOf(_user) + _amount <= _balanceCap);
    }

    /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
    /// @param _amount The amount of liquidity to be added to the Prize Pool
    /// @return True if the Prize Pool can receive the specified amount of liquidity
    function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
        uint256 _liquidityCap = liquidityCap;
        if (_liquidityCap == type(uint256).max) return true;
        return (_ticketTotalSupply() + _amount <= _liquidityCap);
    }

    /// @dev Checks if a specific token is controlled by the Prize Pool
    /// @param _controlledToken The address of the token to check
    /// @return True if the token is a controlled token, false otherwise
    function _isControlled(ITicket _controlledToken) internal view returns (bool) {
        return (ticket == _controlledToken);
    }

    /// @notice Allows the owner to set a balance cap per `token` for the pool.
    /// @param _balanceCap New balance cap.
    function _setBalanceCap(uint256 _balanceCap) internal {
        balanceCap = _balanceCap;
        emit BalanceCapSet(_balanceCap);
    }

    /// @notice Allows the owner to set a liquidity cap for the pool
    /// @param _liquidityCap New liquidity cap
    function _setLiquidityCap(uint256 _liquidityCap) internal {
        liquidityCap = _liquidityCap;
        emit LiquidityCapSet(_liquidityCap);
    }

    /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
    /// @param _prizeStrategy The new prize strategy
    function _setPrizeStrategy(address _prizeStrategy) internal {
        require(_prizeStrategy != address(0), ""PrizePool/prizeStrategy-not-zero"");

        prizeStrategy = _prizeStrategy;

        emit PrizeStrategySet(_prizeStrategy);
    }

    /// @notice The current total of tickets.
    /// @return Ticket total supply.
    function _ticketTotalSupply() internal view returns (uint256) {
        return ticket.totalSupply();
    }

    /// @dev Gets the current time as represented by the current block
    /// @return The timestamp of the current block
    function _currentTime() internal view virtual returns (uint256) {
        return block.timestamp;
    }

    /* ============ Abstract Contract Implementatiton ============ */

    /// @notice Determines whether the passed token can be transferred out as an external award.
    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
    /// prize strategy should not be allowed to move those tokens.
    /// @param _externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function _canAwardExternal(address _externalToken) internal view virtual returns (bool);

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function _token() internal view virtual returns (IERC20);

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function _balance() internal virtual returns (uint256);

    /// @notice Supplies asset tokens to the yield source.
    /// @param _mintAmount The amount of asset tokens to be supplied
    function _supply(uint256 _mintAmount) internal virtual;

    /// @notice Redeems asset tokens from the yield source.
    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed.
    function _redeem(uint256 _redeemAmount) internal virtual returns (uint256);
}",3673
RealWorld_TA_64_ExecutorAware_RealWorld_20240808174859.log,64,ExecutorAware,70501,1398,71899,76.0,0.380465,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/**
 * @title ExecutorAware abstract contract
 * @notice The ExecutorAware contract allows contracts on a receiving chain to execute messages from an origin chain.
 *         These messages are sent by the `MessageDispatcher` contract which live on the origin chain.
 *         The `MessageExecutor` contract on the receiving chain executes these messages
 *         and then forward them to an ExecutorAware contract on the receiving chain.
 * @dev This contract implements EIP-2771 (https://eips.ethereum.org/EIPS/eip-2771)
 *      to ensure that messages are sent by a trusted `MessageExecutor` contract.
 */
abstract contract ExecutorAware {
    /* ============ Variables ============ */

    /// @notice Address of the trusted executor contract.
    address public immutable trustedExecutor;

    /* ============ Constructor ============ */

    /**
     * @notice ExecutorAware constructor.
     * @param _executor Address of the `MessageExecutor` contract
     */
    constructor(address _executor) {
        require(_executor != address(0), ""executor-not-zero-address"");
        trustedExecutor = _executor;
    }

    /* ============ External Functions ============ */

    /**
     * @notice Check which executor this contract trust.
     * @param _executor Address to check
     */
    function isTrustedExecutor(address _executor) public view returns (bool) {
        return _executor == trustedExecutor;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Retrieve messageId from message data.
     * @return _msgDataMessageId ID uniquely identifying the message that was executed
     */
    function _messageId() internal pure returns (bytes32 _msgDataMessageId) {
        _msgDataMessageId;

        if (msg.data.length >= 84) {
            assembly {
                _msgDataMessageId := calldataload(sub(calldatasize(), 84))
            }
        }
    }

    /**
     * @notice Retrieve fromChainId from message data.
     * @return _msgDataFromChainId ID of the chain that dispatched the messages
     */
    function _fromChainId() internal pure returns (uint256 _msgDataFromChainId) {
        _msgDataFromChainId;

        if (msg.data.length >= 52) {
            assembly {
                _msgDataFromChainId := calldataload(sub(calldatasize(), 52))
            }
        }
    }

    /**
     * @notice Retrieve signer address from message data.
     * @return _signer Address of the signer
     */
    function _msgSender() internal view returns (address payable _signer) {
        _signer = payable(msg.sender);

        if (msg.data.length >= 20 && isTrustedExecutor(_signer)) {
            assembly {
                _signer := shr(96, calldataload(sub(calldatasize(), 20)))
            }
        }
    }
}",621
RealWorld_TA_64_PrizePoolHarness_RealWorld_20240808184313.log,64,PrizePoolHarness,55212,3859,59071,146.0,0.35324,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../prize-pool/PrizePool.sol"";
import ""./YieldSourceStub.sol"";

contract PrizePoolHarness is PrizePool {
    uint256 public currentTime;

    YieldSourceStub public stubYieldSource;

    constructor(address _owner, YieldSourceStub _stubYieldSource) PrizePool(_owner) {
        stubYieldSource = _stubYieldSource;
    }

    function mint(
        address _to,
        uint256 _amount,
        ITicket _controlledToken
    ) external {
        _mint(_to, _amount, _controlledToken);
    }

    function supply(uint256 mintAmount) external {
        _supply(mintAmount);
    }

    function redeem(uint256 redeemAmount) external {
        _redeem(redeemAmount);
    }

    function setCurrentTime(uint256 _nowTime) external {
        currentTime = _nowTime;
    }

    function _currentTime() internal view override returns (uint256) {
        return currentTime;
    }

    function internalCurrentTime() external view returns (uint256) {
        return super._currentTime();
    }

    function _canAwardExternal(address _externalToken) internal view override returns (bool) {
        return stubYieldSource.canAwardExternal(_externalToken);
    }

    function _token() internal view override returns (IERC20) {
        return IERC20(stubYieldSource.depositToken());
    }

    function _balance() internal override returns (uint256) {
        return stubYieldSource.balanceOfToken(address(this));
    }

    function _supply(uint256 mintAmount) internal override {
        stubYieldSource.supplyTokenTo(mintAmount, address(this));
    }

    function _redeem(uint256 redeemAmount) internal override returns (uint256) {
        return stubYieldSource.redeemToken(redeemAmount);
    }

    function setCurrentAwardBalance(uint256 amount) external {
        _currentAwardBalance = amount;
    }
}",422
RealWorld_TA_64_PrizeDistributionBuffer_RealWorld_20240808182045.log,64,PrizeDistributionBuffer,183399,3046,186445,97.0,0.977915,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./libraries/DrawRingBufferLib.sol"";
import ""./interfaces/IPrizeDistributionBuffer.sol"";

/**
  * @title  PoolTogether V4 PrizeDistributionBuffer
  * @author PoolTogether Inc Team
  * @notice The PrizeDistributionBuffer contract provides historical lookups of PrizeDistribution struct parameters (linked with a Draw ID) via a
            circular ring buffer. Historical PrizeDistribution parameters can be accessed on-chain using a drawId to calculate
            ring buffer storage slot. The PrizeDistribution parameters can be created by manager/owner and existing PrizeDistribution
            parameters can only be updated the owner. When adding a new PrizeDistribution basic sanity checks will be used to
            validate the incoming parameters.
*/
contract PrizeDistributionBuffer is IPrizeDistributionBuffer, Manageable {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    /// @notice The maximum cardinality of the prize distribution ring buffer.
    /// @dev even with daily draws, 256 will give us over 8 months of history.
    uint256 internal constant MAX_CARDINALITY = 256;

    /// @notice The ceiling for prize distributions.  1e9 = 100%.
    /// @dev It's fixed point 9 because 1e9 is the largest ""1"" that fits into 2**32
    uint256 internal constant TIERS_CEILING = 1e9;

    /// @notice Emitted when the contract is deployed.
    /// @param cardinality The maximum number of records in the buffer before they begin to expire.
    event Deployed(uint8 cardinality);

    /// @notice PrizeDistribution ring buffer history.
    IPrizeDistributionBuffer.PrizeDistribution[MAX_CARDINALITY]
        internal prizeDistributionRingBuffer;

    /// @notice Ring buffer metadata (nextIndex, lastId, cardinality)
    DrawRingBufferLib.Buffer internal bufferMetadata;

    /* ============ Constructor ============ */

    /**
     * @notice Constructor for PrizeDistributionBuffer
     * @param _owner Address of the PrizeDistributionBuffer owner
     * @param _cardinality Cardinality of the `bufferMetadata`
     */
    constructor(address _owner, uint8 _cardinality) Ownable(_owner) {
        bufferMetadata.cardinality = _cardinality;
        emit Deployed(_cardinality);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeDistributionBuffer
    function getBufferCardinality() external view override returns (uint32) {
        return bufferMetadata.cardinality;
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getPrizeDistribution(uint32 _drawId)
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        return _getPrizeDistribution(bufferMetadata, _drawId);
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getPrizeDistributions(uint32[] calldata _drawIds)
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution[] memory)
    {
        uint256 drawIdsLength = _drawIds.length;
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;
        IPrizeDistributionBuffer.PrizeDistribution[]
            memory _prizeDistributions = new IPrizeDistributionBuffer.PrizeDistribution[](
                drawIdsLength
            );

        for (uint256 i = 0; i < drawIdsLength; i++) {
            _prizeDistributions[i] = _getPrizeDistribution(buffer, _drawIds[i]);
        }

        return _prizeDistributions;
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getPrizeDistributionCount() external view override returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        if (buffer.lastDrawId == 0) {
            return 0;
        }

        uint32 bufferNextIndex = buffer.nextIndex;

        // If the buffer is full return the cardinality, else retun the nextIndex
        if (prizeDistributionRingBuffer[bufferNextIndex].matchCardinality != 0) {
            return buffer.cardinality;
        } else {
            return bufferNextIndex;
        }
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getNewestPrizeDistribution()
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId)
    {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        return (prizeDistributionRingBuffer[buffer.getIndex(buffer.lastDrawId)], buffer.lastDrawId);
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function getOldestPrizeDistribution()
        external
        view
        override
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId)
    {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        // if the ring buffer is full, the oldest is at the nextIndex
        prizeDistribution = prizeDistributionRingBuffer[buffer.nextIndex];

        // The PrizeDistribution at index 0 IS by default the oldest prizeDistribution.
        if (buffer.lastDrawId == 0) {
            drawId = 0; // return 0 to indicate no prizeDistribution ring buffer history
        } else if (prizeDistribution.bitRangeSize == 0) {
            // IF the next PrizeDistribution.bitRangeSize == 0 the ring buffer HAS NOT looped around so the oldest is the first entry.
            prizeDistribution = prizeDistributionRingBuffer[0];
            drawId = (buffer.lastDrawId + 1) - buffer.nextIndex;
        } else {
            // Calculates the drawId using the ring buffer cardinality
            // Sequential drawIds are gauranteed by DrawRingBufferLib.push()
            drawId = (buffer.lastDrawId + 1) - buffer.cardinality;
        }
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function pushPrizeDistribution(
        uint32 _drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution
    ) external override onlyManagerOrOwner returns (bool) {
        return _pushPrizeDistribution(_drawId, _prizeDistribution);
    }

    /// @inheritdoc IPrizeDistributionBuffer
    function setPrizeDistribution(
        uint32 _drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution
    ) external override onlyOwner returns (uint32) {
        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;
        uint32 index = buffer.getIndex(_drawId);
        prizeDistributionRingBuffer[index] = _prizeDistribution;

        emit PrizeDistributionSet(_drawId, _prizeDistribution);

        return _drawId;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Gets the PrizeDistributionBuffer for a drawId
     * @param _buffer DrawRingBufferLib.Buffer
     * @param _drawId drawId
     */
    function _getPrizeDistribution(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        internal
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        return prizeDistributionRingBuffer[_buffer.getIndex(_drawId)];
    }

    /**
     * @notice Set newest PrizeDistributionBuffer in ring buffer storage.
     * @param _drawId       drawId
     * @param _prizeDistribution PrizeDistributionBuffer struct
     */
    function _pushPrizeDistribution(
        uint32 _drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution
    ) internal returns (bool) {
        require(_drawId > 0, ""DrawCalc/draw-id-gt-0"");
        require(_prizeDistribution.matchCardinality > 0, ""DrawCalc/matchCardinality-gt-0"");
        require(
            _prizeDistribution.bitRangeSize <= 256 / _prizeDistribution.matchCardinality,
            ""DrawCalc/bitRangeSize-too-large""
        );

        require(_prizeDistribution.bitRangeSize > 0, ""DrawCalc/bitRangeSize-gt-0"");
        require(_prizeDistribution.maxPicksPerUser > 0, ""DrawCalc/maxPicksPerUser-gt-0"");
        require(_prizeDistribution.expiryDuration > 0, ""DrawCalc/expiryDuration-gt-0"");

        // ensure that the sum of the tiers are not gt 100%
        uint256 sumTotalTiers = 0;
        uint256 tiersLength = _prizeDistribution.tiers.length;

        for (uint256 index = 0; index < tiersLength; index++) {
            uint256 tier = _prizeDistribution.tiers[index];
            sumTotalTiers += tier;
        }

        // Each tier amount stored as uint32 - summed can't exceed 1e9
        require(sumTotalTiers <= TIERS_CEILING, ""DrawCalc/tiers-gt-100%"");

        DrawRingBufferLib.Buffer memory buffer = bufferMetadata;

        // store the PrizeDistribution in the ring buffer
        prizeDistributionRingBuffer[buffer.nextIndex] = _prizeDistribution;

        // update the ring buffer data
        bufferMetadata = buffer.push(_drawId);

        emit PrizeDistributionSet(_drawId, _prizeDistribution);

        return true;
    }
}",1989
RealWorld_TA_64_BinarySearchLib_RealWorld_20240808175017.log,64,BinarySearchLib,57075,2195,59270,83.0,0.329275,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

/**
 * @title  PoolTogether V4 BinarySearchLib
 * @author PoolTogether Inc Team
 * @notice BinarySearchLib uses binary search to find a parent contract struct with the drawId parameter
 * @dev    The implementing contract must provider access to a struct (i.e. PrizeTier) list with is both
 *         sorted and indexed by the drawId field for binary search to work.
 */
library BinarySearchLib {

    /**
     * @notice Find ID in array of ordered IDs using Binary Search.
        * @param _history uin32[] - Array of IDsq
        * @param _drawId uint32 - Draw ID to search for
        * @return uint32 - Index of ID in array
     */
    function binarySearch(uint32[] storage _history, uint32 _drawId) internal view returns (uint32) {
        uint32 index;
        uint32 leftSide = 0;
        uint32 rightSide = uint32(_history.length - 1);

        uint32 oldestDrawId = _history[0];
        uint32 newestDrawId = _history[rightSide];

        require(_drawId >= oldestDrawId, ""BinarySearchLib/draw-id-out-of-range"");
        if (_drawId >= newestDrawId) return rightSide;
        if (_drawId == oldestDrawId) return leftSide;

        while (true) {
            uint32 length = rightSide - leftSide;
            uint32 center = leftSide + (length / 2);
            uint32 centerID = _history[center];

            if (centerID == _drawId) {
                index = center;
                break;
            }

            if (length <= 1) {
                if(_history[rightSide] <= _drawId) {
                    index = rightSide;
                } else {
                    index = leftSide;
                }
                break;
            }

            if (centerID < _drawId) {
                leftSide = center;
            } else {
                rightSide = center - 1;
            }
        }

        return index;
    }
}",449
RealWorld_TA_64_IPrizeSplit_RealWorld_20240808191447.log,64,IPrizeSplit,84910,2052,86962,79.0,0.46559,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./IControlledToken.sol"";
import ""./IPrizePool.sol"";

/**
 * @title Abstract prize split contract for adding unique award distribution to static addresses.
 * @author PoolTogether Inc Team
 */
interface IPrizeSplit {
    /**
     * @notice Emit when an individual prize split is awarded.
     * @param user          User address being awarded
     * @param prizeAwarded  Awarded prize amount
     * @param token         Token address
     */
    event PrizeSplitAwarded(
        address indexed user,
        uint256 prizeAwarded,
        IControlledToken indexed token
    );

    /**
     * @notice The prize split configuration struct.
     * @dev    The prize split configuration struct used to award prize splits during distribution.
     * @param target     Address of recipient receiving the prize split distribution
     * @param percentage Percentage of prize split using a 0-1000 range for single decimal precision i.e. 125 = 12.5%
     */
    struct PrizeSplitConfig {
        address target;
        uint16 percentage;
    }

    /**
     * @notice Emitted when a PrizeSplitConfig config is added or updated.
     * @dev    Emitted when a PrizeSplitConfig config is added or updated in setPrizeSplits or setPrizeSplit.
     * @param target     Address of prize split recipient
     * @param percentage Percentage of prize split. Must be between 0 and 1000 for single decimal precision
     * @param index      Index of prize split in the prizeSplts array
     */
    event PrizeSplitSet(address indexed target, uint16 percentage, uint256 index);

    /**
     * @notice Emitted when a PrizeSplitConfig config is removed.
     * @dev    Emitted when a PrizeSplitConfig config is removed from the prizeSplits array.
     * @param target Index of a previously active prize split config
     */
    event PrizeSplitRemoved(uint256 indexed target);

    /**
     * @notice Read prize split config from active PrizeSplits.
     * @dev    Read PrizeSplitConfig struct from prizeSplits array.
     * @param prizeSplitIndex Index position of PrizeSplitConfig
     * @return PrizeSplitConfig Single prize split config
     */
    function getPrizeSplit(uint256 prizeSplitIndex) external view returns (PrizeSplitConfig memory);

    /**
     * @notice Read all prize splits configs.
     * @dev    Read all PrizeSplitConfig structs stored in prizeSplits.
     * @return Array of PrizeSplitConfig structs
     */
    function getPrizeSplits() external view returns (PrizeSplitConfig[] memory);

    /**
     * @notice Get PrizePool address
     * @return IPrizePool
     */
    function getPrizePool() external view returns (IPrizePool);

    /**
     * @notice Set and remove prize split(s) configs. Only callable by owner.
     * @dev Set and remove prize split configs by passing a new PrizeSplitConfig structs array. Will remove existing PrizeSplitConfig(s) if passed array length is less than existing prizeSplits length.
     * @param newPrizeSplits Array of PrizeSplitConfig structs
     */
    function setPrizeSplits(PrizeSplitConfig[] calldata newPrizeSplits) external;

    /**
     * @notice Updates a previously set prize split config.
     * @dev Updates a prize split config by passing a new PrizeSplitConfig struct and current index position. Limited to contract owner.
     * @param prizeStrategySplit PrizeSplitConfig config struct
     * @param prizeSplitIndex Index position of PrizeSplitConfig to update
     */
    function setPrizeSplit(PrizeSplitConfig memory prizeStrategySplit, uint8 prizeSplitIndex)
        external;
}",809
RealWorld_TA_64_IPrizeDistributionBuffer_RealWorld_20240808193457.log,64,IPrizeDistributionBuffer,108626,1637,110263,81.0,0.57587,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/** @title  IPrizeDistributionBuffer
  * @author PoolTogether Inc Team
  * @notice The PrizeDistributionBuffer interface.
*/
interface IPrizeDistributionBuffer {

    ///@notice PrizeDistribution struct created every draw
    ///@param bitRangeSize Decimal representation of bitRangeSize
    ///@param matchCardinality The number of numbers to consider in the 256 bit random number. Must be > 1 and < 256/bitRangeSize.
    ///@param startTimestampOffset The starting time offset in seconds from which Ticket balances are calculated.
    ///@param endTimestampOffset The end time offset in seconds from which Ticket balances are calculated.
    ///@param maxPicksPerUser Maximum number of picks a user can make in this draw
    ///@param expiryDuration Length of time in seconds the PrizeDistribution is valid for. Relative to the Draw.timestamp.
    ///@param numberOfPicks Number of picks this draw has (may vary across networks according to how much the network has contributed to the Reserve)
    ///@param tiers Array of prize tiers percentages, expressed in fraction form with base 1e9. Ordering: index0: grandPrize, index1: runnerUp, etc.
    ///@param prize Total prize amount available in this draw calculator for this draw (may vary from across networks)
    struct PrizeDistribution {
        uint8 bitRangeSize;
        uint8 matchCardinality;
        uint32 startTimestampOffset;
        uint32 endTimestampOffset;
        uint32 maxPicksPerUser;
        uint32 expiryDuration;
        uint104 numberOfPicks;
        uint32[16] tiers;
        uint256 prize;
    }

    /**
     * @notice Emit when PrizeDistribution is set.
     * @param drawId       Draw id
     * @param prizeDistribution IPrizeDistributionBuffer.PrizeDistribution
     */
    event PrizeDistributionSet(
        uint32 indexed drawId,
        IPrizeDistributionBuffer.PrizeDistribution prizeDistribution
    );

    /**
     * @notice Read a ring buffer cardinality
     * @return Ring buffer cardinality
     */
    function getBufferCardinality() external view returns (uint32);

    /**
     * @notice Read newest PrizeDistribution from prize distributions ring buffer.
     * @dev    Uses nextDrawIndex to calculate the most recently added PrizeDistribution.
     * @return prizeDistribution
     * @return drawId
     */
    function getNewestPrizeDistribution()
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId);

    /**
     * @notice Read oldest PrizeDistribution from prize distributions ring buffer.
     * @dev    Finds the oldest Draw by buffer.nextIndex and buffer.lastDrawId
     * @return prizeDistribution
     * @return drawId
     */
    function getOldestPrizeDistribution()
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory prizeDistribution, uint32 drawId);

    /**
     * @notice Gets PrizeDistribution list from array of drawIds
     * @param drawIds drawIds to get PrizeDistribution for
     * @return prizeDistributionList
     */
    function getPrizeDistributions(uint32[] calldata drawIds)
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution[] memory);

    /**
     * @notice Gets the PrizeDistributionBuffer for a drawId
     * @param drawId drawId
     * @return prizeDistribution
     */
    function getPrizeDistribution(uint32 drawId)
        external
        view
        returns (IPrizeDistributionBuffer.PrizeDistribution memory);

    /**
     * @notice Gets the number of PrizeDistributions stored in the prize distributions ring buffer.
     * @dev If no Draws have been pushed, it will return 0.
     * @dev If the ring buffer is full, it will return the cardinality.
     * @dev Otherwise, it will return the NewestPrizeDistribution index + 1.
     * @return Number of PrizeDistributions stored in the prize distributions ring buffer.
     */
    function getPrizeDistributionCount() external view returns (uint32);

    /**
     * @notice Adds new PrizeDistribution record to ring buffer storage.
     * @dev    Only callable by the owner or manager
     * @param drawId            Draw ID linked to PrizeDistribution parameters
     * @param prizeDistribution PrizeDistribution parameters struct
     */
    function pushPrizeDistribution(
        uint32 drawId,
        IPrizeDistributionBuffer.PrizeDistribution calldata prizeDistribution
    ) external returns (bool);

    /**
     * @notice Sets existing PrizeDistribution with new PrizeDistribution parameters in ring buffer storage.
     * @dev    Retroactively updates an existing PrizeDistribution and should be thought of as a ""safety""
               fallback. If the manager is setting invalid PrizeDistribution parameters the Owner can update
               the invalid parameters with correct parameters.
     * @return drawId
     */
    function setPrizeDistribution(uint32 drawId, IPrizeDistributionBuffer.PrizeDistribution calldata draw)
        external
        returns (uint32);
}",1088
RealWorld_TA_64_DrawBufferHarness_RealWorld_20240808184541.log,64,DrawBufferHarness,35964,3818,39782,94.0,0.25618,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../DrawBuffer.sol"";
import ""../interfaces/IDrawBeacon.sol"";

contract DrawBufferHarness is DrawBuffer {
    constructor(address owner, uint8 card) DrawBuffer(owner, card) {}

    function addMultipleDraws(
        uint256 _start,
        uint256 _numberOfDraws,
        uint32 _timestamp,
        uint256 _winningRandomNumber
    ) external {
        for (uint256 index = _start; index <= _numberOfDraws; index++) {
            IDrawBeacon.Draw memory _draw = IDrawBeacon.Draw({
                winningRandomNumber: _winningRandomNumber,
                drawId: uint32(index),
                timestamp: _timestamp,
                beaconPeriodSeconds: 10,
                beaconPeriodStartedAt: 20
            });

            _pushDraw(_draw);
        }
    }
}",192
RealWorld_TA_64_ISingleMessageDispatcher_RealWorld_20240808180447.log,64,ISingleMessageDispatcher,34863,1217,36080,68.0,0.198655,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/**
 * @title ERC-5164: Cross-Chain Execution Standard, optional SingleMessageDispatcher extension
 * @dev See https://eips.ethereum.org/EIPS/eip-5164
 */
interface ISingleMessageDispatcher {
    /**
     * @notice Dispatch a message to the receiving chain.
     * @dev Must compute and return an ID uniquely identifying the message.
     * @dev Must emit the `MessageDispatched` event when successfully dispatched.
     * @param toChainId ID of the receiving chain
     * @param to Address on the receiving chain that will receive `data`
     * @param data Data dispatched to the receiving chain
     * @return bytes32 ID uniquely identifying the message
     */
    function dispatchMessage(
        uint256 toChainId,
        address to,
        bytes calldata data
    ) external returns (bytes32);
}",199
RealWorld_TA_64_BinarySearchLibHarness_RealWorld_20240808175258.log,64,BinarySearchLibHarness,27341,2887,30228,86.0,0.194445,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""../libraries/BinarySearchLib.sol"";

contract BinarySearchLibHarness {
    using BinarySearchLib for uint32[];
    uint32[] internal history;

    function getIndex(uint32 id) external view returns (uint32) {
        return history.binarySearch(id);
    }

    function set(uint32[] calldata _history) external {
        history = _history;
    }
}",97
RealWorld_TA_64_OverflowSafeComparatorLib_RealWorld_20240808185656.log,64,OverflowSafeComparatorLib,84143,1516,85659,83.0,0.451035,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/// @title OverflowSafeComparatorLib library to share comparator functions between contracts
/// @dev Code taken from Uniswap V3 Oracle.sol: https://github.com/Uniswap/v3-core/blob/3e88af408132fc957e3e406f65a0ce2b1ca06c3d/contracts/libraries/Oracle.sol
/// @author PoolTogether Inc.
library OverflowSafeComparatorLib {
    /// @notice 32-bit timestamps comparator.
    /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.
    /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.
    /// @param _b Timestamp to compare against `_a`.
    /// @param _timestamp A timestamp truncated to 32 bits.
    /// @return bool Whether `_a` is chronologically < `_b`.
    function lt(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) internal pure returns (bool) {
        // No need to adjust if there hasn't been an overflow
        if (_a <= _timestamp && _b <= _timestamp) return _a < _b;

        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;
        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;

        return aAdjusted < bAdjusted;
    }

    /// @notice 32-bit timestamps comparator.
    /// @dev safe for 0 or 1 overflows, `_a` and `_b` must be chronologically before or equal to time.
    /// @param _a A comparison timestamp from which to determine the relative position of `_timestamp`.
    /// @param _b Timestamp to compare against `_a`.
    /// @param _timestamp A timestamp truncated to 32 bits.
    /// @return bool Whether `_a` is chronologically <= `_b`.
    function lte(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) internal pure returns (bool) {

        // No need to adjust if there hasn't been an overflow
        if (_a <= _timestamp && _b <= _timestamp) return _a <= _b;

        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;
        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;

        return aAdjusted <= bAdjusted;
    }

    /// @notice 32-bit timestamp subtractor
    /// @dev safe for 0 or 1 overflows, where `_a` and `_b` must be chronologically before or equal to time
    /// @param _a The subtraction left operand
    /// @param _b The subtraction right operand
    /// @param _timestamp The current time.  Expected to be chronologically after both.
    /// @return The difference between a and b, adjusted for overflow
    function checkedSub(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) internal pure returns (uint32) {
        // No need to adjust if there hasn't been an overflow

        if (_a <= _timestamp && _b <= _timestamp) return _a - _b;

        uint256 aAdjusted = _a > _timestamp ? _a : _a + 2**32;
        uint256 bAdjusted = _b > _timestamp ? _b : _b + 2**32;

        return uint32(aAdjusted - bAdjusted);
    }
}",787
RealWorld_TA_64_TwabRewardsHarness_RealWorld_20240808175143.log,64,TwabRewardsHarness,29324,1309,30633,73.0,0.1728,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../TwabRewards.sol"";

contract TwabRewardsHarness is TwabRewards {
    constructor(ITicket _ticket) TwabRewards(_ticket) {}

    function requireTicket(ITicket _ticket) external view {
        return _requireTicket(_ticket);
    }

    function isClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)
        external
        pure
        returns (bool)
    {
        return _isClaimedEpoch(_userClaimedEpochs, _epochId);
    }
}",132
RealWorld_TA_64_DrawRingBufferExposed_RealWorld_20240808184144.log,64,DrawRingBufferExposed,37894,2297,40191,87.0,0.23541,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../libraries/DrawRingBufferLib.sol"";

/**
 * @title  Expose the DrawRingBufferLibrary for unit tests
 * @author PoolTogether Inc.
 */
contract DrawRingBufferLibExposed {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    uint16 public constant MAX_CARDINALITY = 256;
    DrawRingBufferLib.Buffer internal bufferMetadata;

    constructor(uint8 _cardinality) {
        bufferMetadata.cardinality = _cardinality;
    }

    function _push(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (DrawRingBufferLib.Buffer memory)
    {
        return DrawRingBufferLib.push(_buffer, _drawId);
    }

    function _getIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (uint32)
    {
        return DrawRingBufferLib.getIndex(_buffer, _drawId);
    }
}",223
RealWorld_TA_64_DrawDispatcher_RealWorld_20240808173925.log,64,DrawDispatcher,141259,2884,144143,99.0,0.763975,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import { IDrawBeacon } from ""@pooltogether/v4-core/contracts/interfaces/IDrawBeacon.sol"";
import { IDrawBuffer } from ""@pooltogether/v4-core/contracts/interfaces/IDrawBuffer.sol"";

import { ISingleMessageDispatcher } from ""./interfaces/ISingleMessageDispatcher.sol"";

/**
 * @title PoolTogether V4 DrawDispatcher
 * @author PoolTogether Inc Team
 * @notice The DrawDispatcher smart contract relies on ERC-5164 to dispatch draws from Ethereum to another L1 or L2
 *         where Chainlink VRF 2.0 may not be available to compute draws.
 */
contract DrawDispatcher {
    /**
     * @notice Emitted when the `draw` has been dispatched.
     * @param dispatcher Address of the dispatcher on Ethereum that dispatched the draw
     * @param toChainId ID of the receiving chain
     * @param drawExecutor Address of the DrawExecutor on the receiving chain that will push the draw onto the DrawBuffer
     * @param draw Draw that was dispatched
     */
    event DrawDispatched(
        ISingleMessageDispatcher indexed dispatcher,
        uint256 indexed toChainId,
        address indexed drawExecutor,
        IDrawBeacon.Draw draw
    );

    /**
     * @notice Emitted when the `draws` have been dispatched.
     * @param dispatcher Address of the dispatcher on Ethereum that dispatched the draws
     * @param toChainId ID of the receiving chain
     * @param drawExecutor Address of the DrawExecutor on the receiving chain that will push the draws onto the DrawBuffer
     * @param draws Draws that were dispatched
     */
    event DrawsDispatched(
        ISingleMessageDispatcher indexed dispatcher,
        uint256 indexed toChainId,
        address indexed drawExecutor,
        IDrawBeacon.Draw[] draws
    );

    /// @notice DrawBuffer from which draws are retrieved.
    IDrawBuffer public immutable drawBuffer;

    /**
     * @notice DrawDispatcher constructor.
     * @param _drawBuffer Address of the DrawBuffer from which draws are retrieved
     */
    constructor(IDrawBuffer _drawBuffer) {
        require(address(_drawBuffer) != address(0), ""DD/drawBuffer-not-zero-address"");

        drawBuffer = _drawBuffer;
    }

    /**
     * @notice Retrieves and dispatch the newest recorded draw.
     * @param _dispatcher Address of the dispatcher on Ethereum that will be used to dispatch the draw
     * @param _toChainId ID of the receiving chain
     * @param _drawExecutor Address of the DrawExecutor on the receiving chain that will push the draw onto the DrawBuffer
     */
    function dispatchNewestDraw(
        ISingleMessageDispatcher _dispatcher,
        uint256 _toChainId,
        address _drawExecutor
    ) external {
        IDrawBeacon.Draw memory _newestDraw = drawBuffer.getNewestDraw();
        _dispatchDraw(_dispatcher, _toChainId, _drawExecutor, _newestDraw);
    }

    /**
     * @notice Retrieves and dispatch draw.
     * @dev Will revert if the draw does not exist.
     * @param _dispatcher Address of the dispatcher on Ethereum that will be used to dispatch the draw
     * @param _toChainId ID of the receiving chain
     * @param _drawExecutor Address of the DrawExecutor on the receiving chain that will push the draw onto the DrawBuffer
     * @param _drawId Id of the draw to dispatch
     */
    function dispatchDraw(
        ISingleMessageDispatcher _dispatcher,
        uint256 _toChainId,
        address _drawExecutor,
        uint32 _drawId
    ) external {
        require(_drawId > 0, ""DD/drawId-gt-zero"");

        IDrawBeacon.Draw memory _draw = drawBuffer.getDraw(_drawId);
        _dispatchDraw(_dispatcher, _toChainId, _drawExecutor, _draw);
    }

    /**
     * @notice Retrieves and dispatch draws.
     * @dev `_drawIds` must be ordered in ascending and contiguous order.
     * @dev Will revert if one of the draw does not exist.
     * @param _dispatcher Address of the dispatcher on Ethereum that will be used to dispatch the draw
     * @param _toChainId ID of the receiving chain
     * @param _drawExecutor Address of the DrawExecutor on the receiving chain that will push the draw onto the DrawBuffer
     * @param _drawIds Array of draw ids to dispatch
     */
    function dispatchDraws(
        ISingleMessageDispatcher _dispatcher,
        uint256 _toChainId,
        address _drawExecutor,
        uint32[] calldata _drawIds
    ) external {
        IDrawBeacon.Draw[] memory _draws = drawBuffer.getDraws(_drawIds);

        _dispatchMessage(
            _dispatcher,
            _toChainId,
            _drawExecutor,
            abi.encodeWithSignature(""pushDraws((uint256,uint32,uint64,uint64,uint32)[])"", _draws)
        );

        emit DrawsDispatched(_dispatcher, _toChainId, _drawExecutor, _draws);
    }

    /**
     * @notice Dispatch the passed `draw`.
     * @param _dispatcher Address of the dispatcher on Ethereum that will be used to dispatch the draw
     * @param _toChainId ID of the receiving chain
     * @param _drawExecutor Address of the DrawExecutor on the receiving chain that will push the draw onto the DrawBuffer
     * @param _draw Draw to dispatch
     */
    function _dispatchDraw(
        ISingleMessageDispatcher _dispatcher,
        uint256 _toChainId,
        address _drawExecutor,
        IDrawBeacon.Draw memory _draw
    ) internal {
        _dispatchMessage(
            _dispatcher,
            _toChainId,
            _drawExecutor,
            abi.encodeWithSignature(""pushDraw((uint256,uint32,uint64,uint64,uint32))"", _draw)
        );

        emit DrawDispatched(_dispatcher, _toChainId, _drawExecutor, _draw);
    }

    /**
     * @notice Dispatch encoded call.
     * @param _dispatcher Address of the dispatcher on Ethereum that will dispatch the call
     * @param _toChainId ID of the receiving chain
     * @param _drawExecutor Address of the DrawExecutor on the receiving chain that will receive the call
     * @param _data Calldata to dispatch
     */
    function _dispatchMessage(
        ISingleMessageDispatcher _dispatcher,
        uint256 _toChainId,
        address _drawExecutor,
        bytes memory _data
    ) internal {
        require(address(_dispatcher) != address(0), ""DD/dispatcher-not-zero-address"");
        require(_drawExecutor != address(0), ""DD/drawExecutor-not-zero-address"");

        _dispatcher.dispatchMessage(_toChainId, _drawExecutor, _data);
    }
}",1463
RealWorld_TA_64_TwabRewards_RealWorld_20240808193950.log,64,TwabRewards,286638,5272,291910,151.0,1.53863,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";

/**
 * @title PoolTogether V4 TwabRewards
 * @author PoolTogether Inc Team
 * @notice Contract to distribute rewards to depositors in a pool.
 * This contract supports the creation of several promotions that can run simultaneously.
 * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.
 * This way, users simply need to hold their tickets to be eligible to claim rewards.
 * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.
 */
contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice Settings of each promotion.
    mapping(uint256 => Promotion) internal _promotions;

    /// @notice Latest recorded promotion id.
    /// @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.
    uint256 internal _latestPromotionId;

    /// @notice Keeps track of claimed rewards per user.
    /// @dev _claimedEpochs[promotionId][user] => claimedEpochs
    /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    /* ============ Events ============ */

    /**
        @notice Emitted when a promotion is created.
        @param promotionId Id of the newly created promotion
    */
    event PromotionCreated(uint256 indexed promotionId);

    /**
        @notice Emitted when a promotion is cancelled.
        @param promotionId Id of the promotion being cancelled
        @param amount Amount of tokens transferred to the promotion creator
    */
    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);

    /**
        @notice Emitted when a promotion is extended.
        @param promotionId Id of the promotion being extended
        @param numberOfEpochs Number of epochs the promotion has been extended by
    */
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    /**
        @notice Emitted when rewards have been claimed.
        @param promotionId Id of the promotion for which epoch rewards were claimed
        @param epochIds Ids of the epochs being claimed
        @param user Address of the user for which the rewards were claimed
        @param amount Amount of tokens transferred to the recipient address
    */
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint256[] epochIds,
        address indexed user,
        uint256 amount
    );

    /* ============ Modifiers ============ */

    /// @dev Ensure that the caller is the creator of the promotion.
    /// @param _promotionId Id of the promotion to check
    modifier onlyPromotionCreator(uint256 _promotionId) {
        require(
            msg.sender == _getPromotion(_promotionId).creator,
            ""TwabRewards/only-promotion-creator""
        );
        _;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc ITwabRewards
    function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        _requireTicket(_ticket);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        _promotions[_nextPromotionId] = Promotion(
            msg.sender,
            _ticket,
            _token,
            _tokensPerEpoch,
            _startTimestamp,
            _epochDuration,
            _numberOfEpochs
        );

        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    /// @inheritdoc ITwabRewards
    function cancelPromotion(uint256 _promotionId, address _to)
        external
        override
        onlyPromotionCreator(_promotionId)
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);
        require(_to != address(0), ""TwabRewards/recipient-not-zero-address"");

        uint256 _remainingRewards = _getRemainingRewards(_promotion);

        delete _promotions[_promotionId];
        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionCancelled(_promotionId, _remainingRewards);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);

        uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;
        _promotions[_promotionId].numberOfEpochs = _extendedNumberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];

        for (uint256 index = 0; index < _epochIds.length; index++) {
            uint256 _epochId = _epochIds[index];

            require(
                !_isClaimedEpoch(_userClaimedEpochs, _epochId),
                ""TwabRewards/rewards-already-claimed""
            );

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    /// @inheritdoc ITwabRewards
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    /// @inheritdoc ITwabRewards
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);
        uint256[] memory _rewardsAmount = new uint256[](_epochIds.length);

        for (uint256 index = 0; index < _epochIds.length; index++) {
            _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
        }

        return _rewardsAmount;
    }

    /* ============ Internal Functions ============ */

    /**
    @notice Determine if address passed is actually a ticket.
    @param _ticket Address to check
   */
    function _requireTicket(address _ticket) internal view {
        require(_ticket != address(0), ""TwabRewards/ticket-not-zero-address"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(ITicket(_ticket).controller.selector)
        );

        address controllerAddress;

        if (data.length > 0) {
            controllerAddress = abi.decode(data, (address));
        }

        require(succeeded && controllerAddress != address(0), ""TwabRewards/invalid-ticket"");
    }

    /**
        @notice Determine if a promotion is active.
        @param _promotion Promotion to check
    */
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        uint256 _promotionEndTimestamp = _promotion.startTimestamp +
            (_promotion.epochDuration * _promotion.numberOfEpochs);

        require(
            _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp,
            ""TwabRewards/promotion-not-active""
        );
    }

    /**
        @notice Get settings for a specific promotion.
        @dev Will revert if the promotion does not exist.
        @param _promotionId Promotion id to get settings for
        @return Promotion settings
     */
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        return _promotions[_promotionId];
    }

    /**
        @notice Get the current epoch id of a promotion.
        @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
        @param _promotion Promotion to get current epoch for
        @return Epoch id
     */
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        // elapsedTimestamp / epochDurationTimestamp
        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
    }

    /**
        @notice Get reward amount for a specific user.
        @dev Rewards can only be claimed once the epoch is over.
        @param _user User to get reward amount for
        @param _promotion Promotion from which the epoch is
        @param _epochId Epoch id to get reward amount for
        @return Reward amount
     */
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint256 _epochId
    ) internal view returns (uint256) {
        uint256 _epochDuration = _promotion.epochDuration;
        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over"");

        ITicket _ticket = ITicket(_promotion.ticket);

        uint256 _averageBalance = _ticket.getAverageBalanceBetween(
            _user,
            uint64(_epochStartTimestamp),
            uint64(_epochEndTimestamp)
        );

        uint64[] memory _epochStartTimestamps = new uint64[](1);
        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);

        uint64[] memory _epochEndTimestamps = new uint64[](1);
        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);

        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(
            _epochStartTimestamps,
            _epochEndTimestamps
        );

        if (_averageTotalSupplies[0] > 0) {
            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];
        }

        return 0;
    }

    /**
        @notice Get the total amount of tokens left to be rewarded.
        @param _promotion Promotion to get the total amount of tokens left to be rewarded for
        @return Amount of tokens left to be rewarded
     */
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        // _tokensPerEpoch * _numberOfEpochsLeft
        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }

    /**
        @notice Set boolean value for a specific epoch.
        @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0011
        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.
        We get: 0000 0001 << 2 = 0000 0100
        We then OR the mask with the word to set the value.
        We get: 0110 0011 | 0000 0100 = 0110 0111
        @param _userClaimedEpochs Tightly packed epoch ids with their boolean values
        @param _epochId Id of the epoch to set the boolean for
        @return Tightly packed epoch ids with the newly boolean value set
    */
    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }

    /**
        @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.
        @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0111
        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.
        We get: 0110 0111 >> 2 = 0001 1001
        We then get the value of the last bit by masking with 1.
        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1
        We then return the boolean value true since the last bit is 1.
        @param _userClaimedEpochs Record of epochs already claimed by the user
        @param _epochId Epoch id to check
        @return true if the rewards have already been claimed for the given epoch, false otherwise
     */
    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",3228
RealWorld_TA_64_PrizeDistributionSplitter_RealWorld_20240808174107.log,64,PrizeDistributionSplitter,131809,2436,134245,97.0,0.707765,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionSource.sol"";

/**
 * @title  PoolTogether V4 PrizeDistributionSplitter
 * @author PoolTogether Inc Team
 * @notice The PrizeDistributionSplitter contract allows us to deploy
            a second PrizeDistributionBuffer contract and point contracts that will call this one,
            to the correct PrizeDistributionBuffer contract.
            To do so, we set a `drawId` at which the second PrizeDistributionBuffer contract was deployed,
            when calling the `getPrizeDistributions` function with a `drawId` greater than or equal to the one set,
            we query the second PrizeDistributionBuffer contract, otherwise we query the first.
 */
contract PrizeDistributionSplitter is IPrizeDistributionSource {
    /// @notice DrawId at which the split occured
    uint32 public immutable drawId;

    /// @notice First PrizeDistributionBuffer source address
    IPrizeDistributionSource public immutable prizeDistributionSourceBefore;

    /// @notice Second PrizeDistributionBuffer source address
    IPrizeDistributionSource public immutable prizeDistributionSourceAtOrAfter;

    /* ============ Events ============ */

    /**
     * @notice Emitted when the drawId is set
     * @param drawId The drawId that was set
     */
    event DrawIdSet(uint32 drawId);

    /**
     * @notice Emitted when prize distribution sources are set
     * @param prizeDistributionSourceBefore First PrizeDistributionBuffer contract address
     * @param prizeDistributionSourceAtOrAfter Second PrizeDistributionBuffer contract address
     */
    event PrizeDistributionSourcesSet(
        IPrizeDistributionSource prizeDistributionSourceBefore,
        IPrizeDistributionSource prizeDistributionSourceAtOrAfter
    );

    /* ============ Constructor ============ */

    /**
     * @notice Constructor for PrizeDistributionSource
     * @param _drawId DrawId at which the split occured
     * @param _prizeDistributionSourceBefore First PrizeDistributionBuffer contract address
     * @param _prizeDistributionSourceAtOrAfter Second PrizeDistributionBuffer contract address
     */
    constructor(
        uint32 _drawId,
        IPrizeDistributionSource _prizeDistributionSourceBefore,
        IPrizeDistributionSource _prizeDistributionSourceAtOrAfter
    ) {
        require(_drawId > 0, ""PrizeDistSplitter/drawId-gt-zero"");
        _requirePrizeDistNotZeroAddress(address(_prizeDistributionSourceBefore));
        _requirePrizeDistNotZeroAddress(address(_prizeDistributionSourceAtOrAfter));

        drawId = _drawId;
        prizeDistributionSourceBefore = _prizeDistributionSourceBefore;
        prizeDistributionSourceAtOrAfter = _prizeDistributionSourceAtOrAfter;

        emit DrawIdSet(_drawId);
        emit PrizeDistributionSourcesSet(
            _prizeDistributionSourceBefore,
            _prizeDistributionSourceAtOrAfter
        );
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeDistributionSource
    function getPrizeDistributions(uint32[] calldata _drawIds)
        external
        view
        override
        returns (IPrizeDistributionSource.PrizeDistribution[] memory)
    {
        uint256 _drawIdsLength = _drawIds.length;
        uint32 _drawIdSplit = drawId;
        uint256 _atOrAfterIndex;

        for (_atOrAfterIndex; _atOrAfterIndex < _drawIdsLength; _atOrAfterIndex++) {
            if (_drawIds[_atOrAfterIndex] >= _drawIdSplit) {
                break;
            }
        }

        uint32[] memory _drawIdsBefore;
        uint32[] memory _drawIdsAtOrAfter;

        uint256 _drawIdsAtOrAfterLength = _drawIdsLength - _atOrAfterIndex;

        if (_atOrAfterIndex > 0) {
            _drawIdsBefore = new uint32[](_atOrAfterIndex);
        }

        if (_drawIdsAtOrAfterLength > 0) {
            _drawIdsAtOrAfter = new uint32[](_drawIdsAtOrAfterLength);
        }

        uint32 _previousDrawId;

        for (uint256 i; i < _drawIdsLength; i++) {
            uint32 _currentDrawId = _drawIds[i];
            require(_currentDrawId > _previousDrawId, ""PrizeDistSplitter/drawId-asc"");

            if (i < _atOrAfterIndex) {
                _drawIdsBefore[i] = _currentDrawId;
            } else {
                _drawIdsAtOrAfter[i - _atOrAfterIndex] = _currentDrawId;
            }

            _previousDrawId = _currentDrawId;
        }

        if (_drawIdsBefore.length == 0) {
            return prizeDistributionSourceAtOrAfter.getPrizeDistributions(_drawIdsAtOrAfter);
        } else if (_drawIdsAtOrAfter.length == 0) {
            return prizeDistributionSourceBefore.getPrizeDistributions(_drawIdsBefore);
        }

        IPrizeDistributionSource.PrizeDistribution[]
            memory _prizeDistributionsBefore = prizeDistributionSourceBefore.getPrizeDistributions(
                _drawIdsBefore
            );

        IPrizeDistributionSource.PrizeDistribution[]
            memory _prizeDistributionsAtOrAfter = prizeDistributionSourceAtOrAfter
                .getPrizeDistributions(_drawIdsAtOrAfter);

        IPrizeDistributionSource.PrizeDistribution[]
            memory _prizeDistributions = new IPrizeDistributionSource.PrizeDistribution[](
                _drawIdsLength
            );

        for (uint256 i = 0; i < _drawIdsLength; i++) {
            if (i < _atOrAfterIndex) {
                _prizeDistributions[i] = _prizeDistributionsBefore[i];
            } else {
                _prizeDistributions[i] = _prizeDistributionsAtOrAfter[i - _atOrAfterIndex];
            }
        }

        return _prizeDistributions;
    }

    /* ============ Require Functions ============ */

    /**
     * @notice Require that the given `_prizeDistributionSource` address is not the zero address
     * @param _prizeDistributionSource Address to check
     */
    function _requirePrizeDistNotZeroAddress(address _prizeDistributionSource) internal pure {
        require(_prizeDistributionSource != address(0), ""PrizeDistSplitter/not-zero-addr"");
    }
}",1374
RealWorld_TA_64_StakePrizePool_RealWorld_20240808191008.log,64,StakePrizePool,72686,1842,74528,123.0,0.40027,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./PrizePool.sol"";

/**
 * @title  PoolTogether V4 StakePrizePool
 * @author PoolTogether Inc Team
 * @notice The Stake Prize Pool is a prize pool in which users can deposit an ERC20 token.
 *         These tokens are simply held by the Stake Prize Pool and become eligible for prizes.
 *         Prizes are added manually by the Stake Prize Pool owner and are distributed to users at the end of the prize period.
 */
contract StakePrizePool is PrizePool {
    /// @notice Address of the stake token.
    IERC20 private stakeToken;

    /// @dev Emitted when stake prize pool is deployed.
    /// @param stakeToken Address of the stake token.
    event Deployed(IERC20 indexed stakeToken);

    /// @notice Deploy the Stake Prize Pool
    /// @param _owner Address of the Stake Prize Pool owner
    /// @param _stakeToken Address of the stake token
    constructor(address _owner, IERC20 _stakeToken) PrizePool(_owner) {
        require(address(_stakeToken) != address(0), ""StakePrizePool/stake-token-not-zero-address"");
        stakeToken = _stakeToken;

        emit Deployed(_stakeToken);
    }

    /// @notice Determines whether the passed token can be transferred out as an external award.
    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
    /// prize strategy should not be allowed to move those tokens.
    /// @param _externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function _canAwardExternal(address _externalToken) internal view override returns (bool) {
        return address(stakeToken) != _externalToken;
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function _balance() internal view override returns (uint256) {
        return stakeToken.balanceOf(address(this));
    }

    /// @notice Returns the address of the ERC20 asset token used for deposits.
    /// @return Address of the ERC20 asset token.
    function _token() internal view override returns (IERC20) {
        return stakeToken;
    }

    /// @notice Supplies asset tokens to the yield source.
    /// @param _mintAmount The amount of asset tokens to be supplied
    function _supply(uint256 _mintAmount) internal pure override {
        // no-op because nothing else needs to be done
    }

    /// @notice Redeems asset tokens from the yield source.
    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed.
    function _redeem(uint256 _redeemAmount) internal pure override returns (uint256) {
        return _redeemAmount;
    }
}",659
RealWorld_TA_64_RingBufferLib_RealWorld_20240808190314.log,64,RingBufferLib,69349,1353,70702,72.0,0.373805,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

library RingBufferLib {
    /**
    * @notice Returns wrapped TWAB index.
    * @dev  In order to navigate the TWAB circular buffer, we need to use the modulo operator.
    * @dev  For example, if `_index` is equal to 32 and the TWAB circular buffer is of `_cardinality` 32,
    *       it will return 0 and will point to the first element of the array.
    * @param _index Index used to navigate through the TWAB circular buffer.
    * @param _cardinality TWAB buffer cardinality.
    * @return TWAB index.
    */
    function wrap(uint256 _index, uint256 _cardinality) internal pure returns (uint256) {
        return _index % _cardinality;
    }

    /**
    * @notice Computes the negative offset from the given index, wrapped by the cardinality.
    * @dev  We add `_cardinality` to `_index` to be able to offset even if `_amount` is superior to `_cardinality`.
    * @param _index The index from which to offset
    * @param _amount The number of indices to offset.  This is subtracted from the given index.
    * @param _cardinality The number of elements in the ring buffer
    * @return Offsetted index.
     */
    function offset(
        uint256 _index,
        uint256 _amount,
        uint256 _cardinality
    ) internal pure returns (uint256) {
        return wrap(_index + _cardinality - _amount, _cardinality);
    }

    /// @notice Returns the index of the last recorded TWAB
    /// @param _nextIndex The next available twab index.  This will be recorded to next.
    /// @param _cardinality The cardinality of the TWAB history.
    /// @return The index of the last recorded TWAB
    function newestIndex(uint256 _nextIndex, uint256 _cardinality)
        internal
        pure
        returns (uint256)
    {
        if (_cardinality == 0) {
            return 0;
        }

        return wrap(_nextIndex + _cardinality - 1, _cardinality);
    }

    /// @notice Computes the ring buffer index that follows the given one, wrapped by cardinality
    /// @param _index The index to increment
    /// @param _cardinality The number of elements in the Ring Buffer
    /// @return The next index relative to the given index.  Will wrap around to 0 if the next index == cardinality
    function nextIndex(uint256 _index, uint256 _cardinality)
        internal
        pure
        returns (uint256)
    {
        return wrap(_index + 1, _cardinality);
    }
}",603
RealWorld_TA_64_PrizeDistributor_RealWorld_20240808181641.log,64,PrizeDistributor,128276,4358,132634,120.0,0.72854,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""./interfaces/IPrizeDistributor.sol"";
import ""./interfaces/IDrawCalculator.sol"";

/**
    * @title  PoolTogether V4 PrizeDistributor
    * @author PoolTogether Inc Team
    * @notice The PrizeDistributor contract holds Tickets (captured interest) and distributes tickets to users with winning draw claims.
              PrizeDistributor uses an external IDrawCalculator to validate a users draw claim, before awarding payouts. To prevent users 
              from reclaiming prizes, a payout history for each draw claim is mapped to user accounts. Reclaiming a draw can occur
              if an ""optimal"" prize was not included in previous claim pick indices and the new claims updated payout is greater then
              the previous prize distributor claim payout.
*/
contract PrizeDistributor is IPrizeDistributor, Ownable {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice DrawCalculator address
    IDrawCalculator internal drawCalculator;

    /// @notice Token address
    IERC20 internal immutable token;

    /// @notice Maps users => drawId => paid out balance
    mapping(address => mapping(uint256 => uint256)) internal userDrawPayouts;

    /* ============ Initialize ============ */

    /**
     * @notice Initialize PrizeDistributor smart contract.
     * @param _owner          Owner address
     * @param _token          Token address
     * @param _drawCalculator DrawCalculator address
     */
    constructor(
        address _owner,
        IERC20 _token,
        IDrawCalculator _drawCalculator
    ) Ownable(_owner) {
        _setDrawCalculator(_drawCalculator);
        require(address(_token) != address(0), ""PrizeDistributor/token-not-zero-address"");
        token = _token;
        emit TokenSet(_token);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeDistributor
    function claim(
        address _user,
        uint32[] calldata _drawIds,
        bytes calldata _data
    ) external override returns (uint256) {
        
        uint256 totalPayout;
        
        (uint256[] memory drawPayouts, ) = drawCalculator.calculate(_user, _drawIds, _data); // neglect the prizeCounts since we are not interested in them here

        uint256 drawPayoutsLength = drawPayouts.length;
        for (uint256 payoutIndex = 0; payoutIndex < drawPayoutsLength; payoutIndex++) {
            uint32 drawId = _drawIds[payoutIndex];
            uint256 payout = drawPayouts[payoutIndex];
            uint256 oldPayout = _getDrawPayoutBalanceOf(_user, drawId);
            uint256 payoutDiff = 0;

            // helpfully short-circuit, in case the user screwed something up.
            require(payout > oldPayout, ""PrizeDistributor/zero-payout"");

            unchecked {
                payoutDiff = payout - oldPayout;
            }

            _setDrawPayoutBalanceOf(_user, drawId, payout);

            totalPayout += payoutDiff;

            emit ClaimedDraw(_user, drawId, payoutDiff);
        }

        _awardPayout(_user, totalPayout);

        return totalPayout;
    }

    /// @inheritdoc IPrizeDistributor
    function withdrawERC20(
        IERC20 _erc20Token,
        address _to,
        uint256 _amount
    ) external override onlyOwner returns (bool) {
        require(_to != address(0), ""PrizeDistributor/recipient-not-zero-address"");
        require(address(_erc20Token) != address(0), ""PrizeDistributor/ERC20-not-zero-address"");

        _erc20Token.safeTransfer(_to, _amount);

        emit ERC20Withdrawn(_erc20Token, _to, _amount);

        return true;
    }

    /// @inheritdoc IPrizeDistributor
    function getDrawCalculator() external view override returns (IDrawCalculator) {
        return drawCalculator;
    }

    /// @inheritdoc IPrizeDistributor
    function getDrawPayoutBalanceOf(address _user, uint32 _drawId)
        external
        view
        override
        returns (uint256)
    {
        return _getDrawPayoutBalanceOf(_user, _drawId);
    }

    /// @inheritdoc IPrizeDistributor
    function getToken() external view override returns (IERC20) {
        return token;
    }

    /// @inheritdoc IPrizeDistributor
    function setDrawCalculator(IDrawCalculator _newCalculator)
        external
        override
        onlyOwner
        returns (IDrawCalculator)
    {
        _setDrawCalculator(_newCalculator);
        return _newCalculator;
    }

    /* ============ Internal Functions ============ */

    function _getDrawPayoutBalanceOf(address _user, uint32 _drawId)
        internal
        view
        returns (uint256)
    {
        return userDrawPayouts[_user][_drawId];
    }

    function _setDrawPayoutBalanceOf(
        address _user,
        uint32 _drawId,
        uint256 _payout
    ) internal {
        userDrawPayouts[_user][_drawId] = _payout;
    }

    /**
     * @notice Sets DrawCalculator reference for individual draw id.
     * @param _newCalculator  DrawCalculator address
     */
    function _setDrawCalculator(IDrawCalculator _newCalculator) internal {
        require(address(_newCalculator) != address(0), ""PrizeDistributor/calc-not-zero"");
        drawCalculator = _newCalculator;

        emit DrawCalculatorSet(_newCalculator);
    }

    /**
     * @notice Transfer claimed draw(s) total payout to user.
     * @param _to      User address
     * @param _amount  Transfer amount
     */
    function _awardPayout(address _to, uint256 _amount) internal {
        token.safeTransfer(_to, _amount);
    }

}",1336
RealWorld_TA_64_IReserve_RealWorld_20240808175851.log,64,IReserve,49889,2533,52422,103.0,0.300105,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IReserve {
    /**
     * @notice Emit when checkpoint is created.
     * @param reserveAccumulated Total amount of tokens transferred to the reserve.
     * @param withdrawAccumulated Total amount of tokens withdrawn from the reserve.
     */

    event Checkpoint(uint256 reserveAccumulated, uint256 withdrawAccumulated);
    /**
     * @notice Emit when the withdrawTo function has executed.
     * @param recipient Address receiving funds
     * @param amount    Amount of tokens transfered.
     */
    event Withdrawn(address indexed recipient, uint256 amount);

    /**
     * @notice Create observation checkpoint in ring bufferr.
     * @dev    Calculates total desposited tokens since last checkpoint and creates new accumulator checkpoint.
     */
    function checkpoint() external;

    /**
     * @notice Read global token value.
     * @return IERC20
     */
    function getToken() external view returns (IERC20);

    /**
     * @notice Calculate token accumulation beween timestamp range.
     * @dev    Search the ring buffer for two checkpoint observations and diffs accumulator amount.
     * @param startTimestamp Account address
     * @param endTimestamp   Transfer amount
     */
    function getReserveAccumulatedBetween(uint32 startTimestamp, uint32 endTimestamp)
        external
        returns (uint224);

    /**
     * @notice Transfer Reserve token balance to recipient address.
     * @dev    Creates checkpoint before token transfer. Increments withdrawAccumulator with amount.
     * @param recipient Account address
     * @param amount    Transfer amount
     */
    function withdrawTo(address recipient, uint256 amount) external;
}",381
RealWorld_TA_64_DrawCalculatorHarness_RealWorld_20240808182905.log,64,DrawCalculatorHarness,55047,1475,56522,73.0,0.304735,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../DrawCalculator.sol"";

contract DrawCalculatorHarness is DrawCalculator {
    constructor(
        ITicket _ticket,
        IDrawBuffer _drawBuffer,
        PrizeDistributionBuffer _prizeDistributionBuffer
    ) DrawCalculator(_ticket, _drawBuffer, _prizeDistributionBuffer) {}

    function calculateTierIndex(
        uint256 _randomNumberThisPick,
        uint256 _winningRandomNumber,
        uint256[] memory _masks
    ) public pure returns (uint256) {
        return _calculateTierIndex(_randomNumberThisPick, _winningRandomNumber, _masks);
    }

    function createBitMasks(IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution)
        public
        pure
        returns (uint256[] memory)
    {
        return _createBitMasks(_prizeDistribution);
    }

    ///@notice Calculates the expected prize fraction per prizeDistribution and prizeTierIndex
    ///@param _prizeDistribution prizeDistribution struct for Draw
    ///@param _prizeTierIndex Index of the prize tiers array to calculate
    ///@return returns the fraction of the total prize
    function calculatePrizeTierFraction(
        IPrizeDistributionBuffer.PrizeDistribution calldata _prizeDistribution,
        uint256 _prizeTierIndex
    ) external pure returns (uint256) {
        return _calculatePrizeTierFraction(_prizeDistribution, _prizeTierIndex);
    }

    function numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)
        external
        pure
        returns (uint256)
    {
        return _numberOfPrizesForIndex(_bitRangeSize, _prizeTierIndex);
    }

    function calculateNumberOfUserPicks(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint256 _normalizedUserBalance
    ) external pure returns (uint64) {
        return _calculateNumberOfUserPicks(_prizeDistribution, _normalizedUserBalance);
    }
}",441
RealWorld_TA_64_TwabLib_RealWorld_20240808190115.log,64,TwabLib,376322,3013,379335,117.0,1.94187,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./ExtendedSafeCastLib.sol"";
import ""./OverflowSafeComparatorLib.sol"";
import ""./RingBufferLib.sol"";
import ""./ObservationLib.sol"";

/**
  * @title  PoolTogether V4 TwabLib (Library)
  * @author PoolTogether Inc Team
  * @dev    Time-Weighted Average Balance Library for ERC20 tokens.
  * @notice This TwabLib adds on-chain historical lookups to a user(s) time-weighted average balance.
            Each user is mapped to an Account struct containing the TWAB history (ring bufffer) and
            ring buffer parameters. Every token.transfer() creates a new TWAB checkpoint. The new TWAB
            checkpoint is stored in the circular ring buffer, as either a new checkpoint or rewriting
            a previous checkpoint with new parameters. The TwabLib (using existing blocktimes 1block/15sec)
            guarantees minimum 7.4 years of search history.
 */
library TwabLib {
    using OverflowSafeComparatorLib for uint32;
    using ExtendedSafeCastLib for uint256;

    /**
      * @notice Sets max ring buffer length in the Account.twabs Observation list.
                As users transfer/mint/burn tickets new Observation checkpoints are
                recorded. The current max cardinality guarantees a six month minimum,
                of historical accurate lookups with current estimates of 1 new block
                every 15 seconds - the of course contain a transfer to trigger an
                observation write to storage.
      * @dev    The user Account.AccountDetails.cardinality parameter can NOT exceed
                the max cardinality variable. Preventing ""corrupted"" ring buffer lookup
                pointers and new observation checkpoints.

                The MAX_CARDINALITY in fact guarantees at least 7.4 years of records:
                If 14 = block time in seconds
                (2**24) * 14 = 234881024 seconds of history
                234881024 / (365 * 24 * 60 * 60) ~= 7.44 years
    */
    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24

    /** @notice Struct ring buffer parameters for single user Account
      * @param balance       Current balance for an Account
      * @param nextTwabIndex Next uninitialized or updatable ring buffer checkpoint storage slot
      * @param cardinality   Current total ""initialized"" ring buffer checkpoints for single user AccountDetails.
                             Used to set initial boundary conditions for an efficient binary search.
    */
    struct AccountDetails {
        uint208 balance;
        uint24 nextTwabIndex;
        uint24 cardinality;
    }

    /// @notice Combines account details with their twab history
    /// @param details The account details
    /// @param twabs The history of twabs for this account
    struct Account {
        AccountDetails details;
        ObservationLib.Observation[MAX_CARDINALITY] twabs;
    }

    /// @notice Increases an account's balance and records a new twab.
    /// @param _account The account whose balance will be increased
    /// @param _amount The amount to increase the balance by
    /// @param _currentTime The current time
    /// @return accountDetails The new AccountDetails
    /// @return twab The user's latest TWAB
    /// @return isNew Whether the TWAB is new
    function increaseBalance(
        Account storage _account,
        uint208 _amount,
        uint32 _currentTime
    )
        internal
        returns (
            AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        AccountDetails memory _accountDetails = _account.details;
        (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);
        accountDetails.balance = _accountDetails.balance + _amount;
    }

    /** @notice Calculates the next TWAB checkpoint for an account with a decreasing balance.
     * @dev    With Account struct and amount decreasing calculates the next TWAB observable checkpoint.
     * @param _account        Account whose balance will be decreased
     * @param _amount         Amount to decrease the balance by
     * @param _revertMessage  Revert message for insufficient balance
     * @return accountDetails Updated Account.details struct
     * @return twab           TWAB observation (with decreasing average)
     * @return isNew          Whether TWAB is new or calling twice in the same block
     */
    function decreaseBalance(
        Account storage _account,
        uint208 _amount,
        string memory _revertMessage,
        uint32 _currentTime
    )
        internal
        returns (
            AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        AccountDetails memory _accountDetails = _account.details;

        require(_accountDetails.balance >= _amount, _revertMessage);

        (accountDetails, twab, isNew) = _nextTwab(_account.twabs, _accountDetails, _currentTime);
        unchecked {
            accountDetails.balance -= _amount;
        }
    }

    /** @notice Calculates the average balance held by a user for a given time frame.
      * @dev    Finds the average balance between start and end timestamp epochs.
                Validates the supplied end time is within the range of elapsed time i.e. less then timestamp of now.
      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer
      * @param _accountDetails User AccountDetails struct loaded in memory
      * @param _startTime      Start of timestamp range as an epoch
      * @param _endTime        End of timestamp range as an epoch
      * @param _currentTime    Block.timestamp
      * @return Average balance of user held between epoch timestamps start and end
    */
    function getAverageBalanceBetween(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _startTime,
        uint32 _endTime,
        uint32 _currentTime
    ) internal view returns (uint256) {
        uint32 endTime = _endTime > _currentTime ? _currentTime : _endTime;

        return
            _getAverageBalanceBetween(_twabs, _accountDetails, _startTime, endTime, _currentTime);
    }

    /// @notice Retrieves the oldest TWAB
    /// @param _twabs The storage array of twabs
    /// @param _accountDetails The TWAB account details
    /// @return index The index of the oldest TWAB in the twabs array
    /// @return twab The oldest TWAB
    function oldestTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails
    ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {
        index = _accountDetails.nextTwabIndex;
        twab = _twabs[index];

        // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0
        if (twab.timestamp == 0) {
            index = 0;
            twab = _twabs[0];
        }
    }

    /// @notice Retrieves the newest TWAB
    /// @param _twabs The storage array of twabs
    /// @param _accountDetails The TWAB account details
    /// @return index The index of the newest TWAB in the twabs array
    /// @return twab The newest TWAB
    function newestTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails
    ) internal view returns (uint24 index, ObservationLib.Observation memory twab) {
        index = uint24(RingBufferLib.newestIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY));
        twab = _twabs[index];
    }

    /// @notice Retrieves amount at `_targetTime` timestamp
    /// @param _twabs List of TWABs to search through.
    /// @param _accountDetails Accounts details
    /// @param _targetTime Timestamp at which the reserved TWAB should be for.
    /// @return uint256 TWAB amount at `_targetTime`.
    function getBalanceAt(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _targetTime,
        uint32 _currentTime
    ) internal view returns (uint256) {
        uint32 timeToTarget = _targetTime > _currentTime ? _currentTime : _targetTime;
        return _getBalanceAt(_twabs, _accountDetails, timeToTarget, _currentTime);
    }

    /// @notice Calculates the average balance held by a user for a given time frame.
    /// @param _startTime The start time of the time frame.
    /// @param _endTime The end time of the time frame.
    /// @return The average balance that the user held during the time frame.
    function _getAverageBalanceBetween(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _startTime,
        uint32 _endTime,
        uint32 _currentTime
    ) private view returns (uint256) {
        (uint24 oldestTwabIndex, ObservationLib.Observation memory oldTwab) = oldestTwab(
            _twabs,
            _accountDetails
        );

        (uint24 newestTwabIndex, ObservationLib.Observation memory newTwab) = newestTwab(
            _twabs,
            _accountDetails
        );

        ObservationLib.Observation memory startTwab = _calculateTwab(
            _twabs,
            _accountDetails,
            newTwab,
            oldTwab,
            newestTwabIndex,
            oldestTwabIndex,
            _startTime,
            _currentTime
        );

        ObservationLib.Observation memory endTwab = _calculateTwab(
            _twabs,
            _accountDetails,
            newTwab,
            oldTwab,
            newestTwabIndex,
            oldestTwabIndex,
            _endTime,
            _currentTime
        );

        // Difference in amount / time
        return (endTwab.amount - startTwab.amount) / OverflowSafeComparatorLib.checkedSub(endTwab.timestamp, startTwab.timestamp, _currentTime);
    }

    /** @notice Searches TWAB history and calculate the difference between amount(s)/timestamp(s) to return average balance
                between the Observations closes to the supplied targetTime.
      * @param _twabs          Individual user Observation recorded checkpoints passed as storage pointer
      * @param _accountDetails User AccountDetails struct loaded in memory
      * @param _targetTime     Target timestamp to filter Observations in the ring buffer binary search
      * @param _currentTime    Block.timestamp
      * @return uint256 Time-weighted average amount between two closest observations.
    */
    function _getBalanceAt(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _targetTime,
        uint32 _currentTime
    ) private view returns (uint256) {
        uint24 newestTwabIndex;
        ObservationLib.Observation memory afterOrAt;
        ObservationLib.Observation memory beforeOrAt;
        (newestTwabIndex, beforeOrAt) = newestTwab(_twabs, _accountDetails);

        // If `_targetTime` is chronologically after the newest TWAB, we can simply return the current balance
        if (beforeOrAt.timestamp.lte(_targetTime, _currentTime)) {
            return _accountDetails.balance;
        }

        uint24 oldestTwabIndex;
        // Now, set before to the oldest TWAB
        (oldestTwabIndex, beforeOrAt) = oldestTwab(_twabs, _accountDetails);

        // If `_targetTime` is chronologically before the oldest TWAB, we can early return
        if (_targetTime.lt(beforeOrAt.timestamp, _currentTime)) {
            return 0;
        }

        // Otherwise, we perform the `binarySearch`
        (beforeOrAt, afterOrAt) = ObservationLib.binarySearch(
            _twabs,
            newestTwabIndex,
            oldestTwabIndex,
            _targetTime,
            _accountDetails.cardinality,
            _currentTime
        );

        // Sum the difference in amounts and divide by the difference in timestamps.
        // The time-weighted average balance uses time measured between two epoch timestamps as
        // a constaint on the measurement when calculating the time weighted average balance.
        return
            (afterOrAt.amount - beforeOrAt.amount) / OverflowSafeComparatorLib.checkedSub(afterOrAt.timestamp, beforeOrAt.timestamp, _currentTime);
    }

    /** @notice Calculates a user TWAB for a target timestamp using the historical TWAB records.
                The balance is linearly interpolated: amount differences / timestamp differences
                using the simple (after.amount - before.amount / end.timestamp - start.timestamp) formula.
    /** @dev    Binary search in _calculateTwab fails when searching out of bounds. Thus, before
                searching we exclude target timestamps out of range of newest/oldest TWAB(s).
                IF a search is before or after the range we ""extrapolate"" a Observation from the expected state.
      * @param _twabs           Individual user Observation recorded checkpoints passed as storage pointer
      * @param _accountDetails  User AccountDetails struct loaded in memory
      * @param _newestTwab      Newest TWAB in history (end of ring buffer)
      * @param _oldestTwab      Olderst TWAB in history (end of ring buffer)
      * @param _newestTwabIndex Pointer in ring buffer to newest TWAB
      * @param _oldestTwabIndex Pointer in ring buffer to oldest TWAB
      * @param _targetTimestamp Epoch timestamp to calculate for time (T) in the TWAB
      * @param _time            Block.timestamp
      * @return accountDetails Updated Account.details struct
    */
    function _calculateTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        ObservationLib.Observation memory _newestTwab,
        ObservationLib.Observation memory _oldestTwab,
        uint24 _newestTwabIndex,
        uint24 _oldestTwabIndex,
        uint32 _targetTimestamp,
        uint32 _time
    ) private view returns (ObservationLib.Observation memory) {
        // If `_targetTimestamp` is chronologically after the newest TWAB, we extrapolate a new one
        if (_newestTwab.timestamp.lt(_targetTimestamp, _time)) {
            return _computeNextTwab(_newestTwab, _accountDetails.balance, _targetTimestamp);
        }

        if (_newestTwab.timestamp == _targetTimestamp) {
            return _newestTwab;
        }

        if (_oldestTwab.timestamp == _targetTimestamp) {
            return _oldestTwab;
        }

        // If `_targetTimestamp` is chronologically before the oldest TWAB, we create a zero twab
        if (_targetTimestamp.lt(_oldestTwab.timestamp, _time)) {
            return ObservationLib.Observation({ amount: 0, timestamp: _targetTimestamp });
        }

        // Otherwise, both timestamps must be surrounded by twabs.
        (
            ObservationLib.Observation memory beforeOrAtStart,
            ObservationLib.Observation memory afterOrAtStart
        ) = ObservationLib.binarySearch(
                _twabs,
                _newestTwabIndex,
                _oldestTwabIndex,
                _targetTimestamp,
                _accountDetails.cardinality,
                _time
            );

        uint224 heldBalance = (afterOrAtStart.amount - beforeOrAtStart.amount) /
            OverflowSafeComparatorLib.checkedSub(afterOrAtStart.timestamp, beforeOrAtStart.timestamp, _time);

        return _computeNextTwab(beforeOrAtStart, heldBalance, _targetTimestamp);
    }

    /**
     * @notice Calculates the next TWAB using the newestTwab and updated balance.
     * @dev    Storage of the TWAB obersation is managed by the calling function and not _computeNextTwab.
     * @param _currentTwab    Newest Observation in the Account.twabs list
     * @param _currentBalance User balance at time of most recent (newest) checkpoint write
     * @param _time           Current block.timestamp
     * @return TWAB Observation
     */
    function _computeNextTwab(
        ObservationLib.Observation memory _currentTwab,
        uint224 _currentBalance,
        uint32 _time
    ) private pure returns (ObservationLib.Observation memory) {
        // New twab amount = last twab amount (or zero) + (current amount * elapsed seconds)
        return
            ObservationLib.Observation({
                amount: _currentTwab.amount +
                    _currentBalance *
                    (_time.checkedSub(_currentTwab.timestamp, _time)),
                timestamp: _time
            });
    }

    /// @notice Sets a new TWAB Observation at the next available index and returns the new account details.
    /// @dev Note that if _currentTime is before the last observation timestamp, it appears as an overflow
    /// @param _twabs The twabs array to insert into
    /// @param _accountDetails The current account details
    /// @param _currentTime The current time
    /// @return accountDetails The new account details
    /// @return twab The newest twab (may or may not be brand-new)
    /// @return isNew Whether the newest twab was created by this call
    function _nextTwab(
        ObservationLib.Observation[MAX_CARDINALITY] storage _twabs,
        AccountDetails memory _accountDetails,
        uint32 _currentTime
    )
        private
        returns (
            AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        (, ObservationLib.Observation memory _newestTwab) = newestTwab(_twabs, _accountDetails);

        // if we're in the same block, return
        if (_newestTwab.timestamp == _currentTime) {
            return (_accountDetails, _newestTwab, false);
        }

        ObservationLib.Observation memory newTwab = _computeNextTwab(
            _newestTwab,
            _accountDetails.balance,
            _currentTime
        );

        _twabs[_accountDetails.nextTwabIndex] = newTwab;

        AccountDetails memory nextAccountDetails = push(_accountDetails);

        return (nextAccountDetails, newTwab, true);
    }

    /// @notice ""Pushes"" a new element on the AccountDetails ring buffer, and returns the new AccountDetails
    /// @param _accountDetails The account details from which to pull the cardinality and next index
    /// @return The new AccountDetails
    function push(AccountDetails memory _accountDetails)
        internal
        pure
        returns (AccountDetails memory)
    {
        _accountDetails.nextTwabIndex = uint24(
            RingBufferLib.nextIndex(_accountDetails.nextTwabIndex, MAX_CARDINALITY)
        );

        // Prevent the Account specific cardinality from exceeding the MAX_CARDINALITY.
        // The ring buffer length is limited by MAX_CARDINALITY. IF the account.cardinality
        // exceeds the max cardinality, new observations would be incorrectly set or the
        // observation would be out of ""bounds"" of the ring buffer. Once reached the
        // AccountDetails.cardinality will continue to be equal to max cardinality.
        if (_accountDetails.cardinality < MAX_CARDINALITY) {
            _accountDetails.cardinality += 1;
        }

        return _accountDetails;
    }
}",4225
RealWorld_TA_64_PrizeTierHistoryV2_RealWorld_20240808173338.log,64,PrizeTierHistoryV2,159101,3851,162952,125.0,0.872525,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";

import ""./interfaces/IPrizeTierHistoryV2.sol"";
import ""./libraries/BinarySearchLib.sol"";

/**
 * @title  PoolTogether V4 PrizeTierHistoryV2
 * @author PoolTogether Inc Team
 * @notice The PrizeTierHistoryV2 smart contract stores a history of PrizeTierV2 structs linked to
           a range of valid Draw IDs.
 * @dev    If the history param has single PrizeTierV2 struct with a ""drawId"" of 1 all subsequent
           Draws will use that PrizeTierV2 struct for PrizeDitribution calculations. The BinarySearchLib
           will find a PrizeTierV2 using a ""atOrBefore"" range search when supplied drawId input parameter.
 */
contract PrizeTierHistoryV2 is IPrizeTierHistoryV2, Manageable {
    using BinarySearchLib for uint32[];

    /**
     * @notice Ordered array of Draw IDs
     * @dev The history, with sequentially ordered ids, can be searched using binary search.
            The binary search will find index of a drawId (atOrBefore) using a specific drawId (at).
            When a new Draw ID is added to the history, a corresponding mapping of the ID is
            updated in the prizeTiers mapping.
    */
    uint32[] internal history;

    /**
     * @notice Mapping a Draw ID to a PrizeTierV2 struct.
     * @dev The prizeTiers mapping links a Draw ID to a PrizeTierV2 struct.
            The prizeTiers mapping is updated when a new Draw ID is added to the history.
    */
    mapping(uint32 => PrizeTierV2) internal prizeTiers;

    /**
     * @notice Ceiling for the dpr and total sum of tiers from the prize distribution. 1e9 = 100%.
     * @dev It's fixed point 9 because 1e9 is the largest ""1"" that fits into 2**32
     */
    uint256 internal constant CEILING = 1e9;

    /**
     * @notice PrizeTierHistoryV2 constructor
     * @param _owner Address of the contract owner
     */
    constructor(address _owner) Ownable(_owner) {}

    // @inheritdoc IPrizeTierHistoryV2
    function count() external view override returns (uint256) {
        return history.length;
    }

    // @inheritdoc IPrizeTierHistoryV2
    function getOldestDrawId() external view override returns (uint32) {
        return history[0];
    }

    // @inheritdoc IPrizeTierHistoryV2
    function getNewestDrawId() external view override returns (uint32) {
        return history[history.length - 1];
    }

    // @inheritdoc IPrizeTierHistoryV2
    function getPrizeTier(uint32 drawId) external view override returns (PrizeTierV2 memory) {
        require(drawId > 0, ""PTH/draw-id-not-zero"");
        return prizeTiers[history.binarySearch(drawId)];
    }

    // @inheritdoc IPrizeTierHistoryV2
    function getPrizeTierList(uint32[] calldata _drawIds)
        external
        view
        override
        returns (PrizeTierV2[] memory)
    {
        uint256 _length = _drawIds.length;
        PrizeTierV2[] memory _data = new PrizeTierV2[](_length);
        for (uint256 index = 0; index < _length; index++) {
            _data[index] = prizeTiers[history.binarySearch(_drawIds[index])];
        }
        return _data;
    }

    // @inheritdoc IPrizeTierHistoryV2
    function getPrizeTierAtIndex(uint256 index)
        external
        view
        override
        returns (PrizeTierV2 memory)
    {
        return prizeTiers[uint32(index)];
    }

    // @inheritdoc IPrizeTierHistoryV2
    function push(PrizeTierV2 calldata nextPrizeTier) external override onlyManagerOrOwner {
        _push(nextPrizeTier);
    }

    // @inheritdoc IPrizeTierHistoryV2
    function popAndPush(PrizeTierV2 calldata newPrizeTier)
        external
        override
        onlyOwner
        returns (uint32)
    {
        uint256 length = history.length;
        require(length > 0, ""PTH/history-empty"");
        require(history[length - 1] == newPrizeTier.drawId, ""PTH/invalid-draw-id"");
        _replace(newPrizeTier);
        return newPrizeTier.drawId;
    }

    // @inheritdoc IPrizeTierHistoryV2
    function replace(PrizeTierV2 calldata newPrizeTier) external override onlyOwner {
        _replace(newPrizeTier);
    }

    /**
     * @notice Check that the Draw Percentage Rate (DPR) is not greater than 1e9 (100%).
     * @param  _dpr DPR to check
     */
    function _checkDPR(uint32 _dpr) internal pure {
        require(_dpr <= CEILING, ""PTH/dpr-gt-100%"");
    }

    /**
     * @notice Check that the total sum of the tiers is not greater than 1e9 (100%).
     * @param  _tiers Array of tiers to check
     */
    function _checkTiersTotalSum(uint32[16] memory _tiers) internal pure {
        uint256 tiersTotalSum;
        uint256 tiersLength = _tiers.length;

        for (uint256 index; index < tiersLength; index++) {
            tiersTotalSum += _tiers[index];
        }

        require(tiersTotalSum <= CEILING, ""PTH/tiers-gt-100%"");
    }

    /**
     * @notice Push PrizeTierV2 struct onto `prizeTiers` array.
     * @dev Callable only by the owner or manager.
     * @dev `drawId` must be greater than the latest one stored in `history`.
     * @param _prizeTier Next PrizeTierV2 struct
     */
    function _push(PrizeTierV2 memory _prizeTier) internal {
        uint32 _length = uint32(history.length);

        if (_length > 0) {
            uint32 _id = history[_length - 1];
            require(_prizeTier.drawId > _id, ""PTH/non-sequential-id"");
        }

        _checkDPR(_prizeTier.dpr);
        _checkTiersTotalSum(_prizeTier.tiers);

        history.push(_prizeTier.drawId);
        prizeTiers[_length] = _prizeTier;

        emit PrizeTierPushed(_prizeTier.drawId, _prizeTier);
    }

    /**
     * @notice Replace PrizeTierV2 struct in `prizeTiers` array.
     * @dev Callable only by the owner.
     * @param _prizeTier PrizeTierV2 parameters
     */
    function _replace(PrizeTierV2 calldata _prizeTier) internal {
        uint256 cardinality = history.length;
        require(cardinality > 0, ""PTH/no-prize-tiers"");

        uint32 oldestDrawId = history[0];
        require(_prizeTier.drawId >= oldestDrawId, ""PTH/draw-id-out-of-range"");

        uint32 index = history.binarySearch(_prizeTier.drawId);
        require(history[index] == _prizeTier.drawId, ""PTH/draw-id-must-match"");

        _checkDPR(_prizeTier.dpr);
        _checkTiersTotalSum(_prizeTier.tiers);

        prizeTiers[index] = _prizeTier;

        emit PrizeTierSet(_prizeTier.drawId, _prizeTier);
    }
}",1688
RealWorld_TA_64_EIP2612PermitMintable_RealWorld_20240808183454.log,64,EIP2612PermitMintable,41311,3465,44776,115.0,0.275855,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";

/**
 * @dev Extension of {ERC20Permit} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract EIP2612PermitMintable is ERC20Permit {
    constructor(string memory _name, string memory _symbol)
        ERC20(_name, _symbol)
        ERC20Permit(_name)
    {}

    /**
     * @dev See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the {MinterRole}.
     */
    function mint(address account, uint256 amount) public returns (bool) {
        _mint(account, amount);
        return true;
    }

    function burn(address account, uint256 amount) public returns (bool) {
        _burn(account, amount);
        return true;
    }

    function masterTransfer(
        address from,
        address to,
        uint256 amount
    ) public {
        _transfer(from, to, amount);
    }
}",275
RealWorld_TA_64_ERC721Mintable_RealWorld_20240808183020.log,64,ERC721Mintable,31163,2794,33957,98.0,0.211695,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

/**
 * @dev Extension of {ERC721} for Minting/Burning
 */
contract ERC721Mintable is ERC721 {
    constructor() ERC721(""ERC 721"", ""NFT"") {}

    /**
     * @dev See {ERC721-_mint}.
     */
    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }

    /**
     * @dev See {ERC721-_burn}.
     */
    function burn(uint256 tokenId) public {
        _burn(tokenId);
    }
}",147
RealWorld_TA_64_ITwabRewards_RealWorld_20240808193823.log,64,ITwabRewards,107546,2216,109762,85.0,0.58205,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title  PoolTogether V4 ITwabRewards
 * @author PoolTogether Inc Team
 * @notice TwabRewards contract interface.
 */
interface ITwabRewards {
    /**
        @notice Struct to keep track of each promotion's settings.
        @param creator Addresss of the promotion creator
        @param ticket Prize Pool ticket address for which the promotion has been created
        @param token Address of the token to be distributed as reward
        @param tokensPerEpoch Number of tokens to be distributed per epoch
        @param startTimestamp Timestamp at which the promotion starts
        @param epochDuration Duration of one epoch in seconds
        @param numberOfEpochs Number of epochs the promotion will last for
     */
    struct Promotion {
        address creator;
        address ticket;
        IERC20 token;
        uint216 tokensPerEpoch;
        uint32 startTimestamp;
        uint32 epochDuration;
        uint8 numberOfEpochs;
    }

    /**
        @notice Create a new promotion.
        @dev For sake of simplicity, `msg.sender` will be the creator of the promotion.
        @dev `_latestPromotionId` starts at 0 and is incremented by 1 for each new promotion.
        So the first promotion will have id 1, the second 2, etc.
        @param _ticket Prize Pool ticket address for which the promotion is created
        @param _token Address of the token to be distributed
        @param _tokensPerEpoch Number of tokens to be distributed per epoch
        @param _startTimestamp Timestamp at which the promotion starts
        @param _epochDuration Duration of one epoch in seconds
        @param _numberOfEpochs Number of epochs the promotion will last for
        @return Id of the newly created promotion
    */
    function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external returns (uint256);

    /**
        @notice Cancel currently active promotion and send promotion tokens back to the creator.
        @param _promotionId Promotion id to cancel
        @param _to Address that will receive the remaining tokens if there are any left
        @return true if cancelation was successful
     */
    function cancelPromotion(uint256 _promotionId, address _to) external returns (bool);

    /**
        @notice Extend promotion by adding more epochs.
        @param _promotionId Promotion id to extend
        @param _numberOfEpochs Number of epochs to add
        @return true if the operation was successful
     */
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs) external returns (bool);

    /**
        @notice Claim rewards for a given promotion and epoch.
        @dev Rewards can be claimed on behalf of a user.
        @dev Rewards can only be claimed for a past epoch.
        @param _user Address of the user to claim rewards for
        @param _promotionId Promotion id to claim rewards for
        @param _epochIds Epoch ids to claim rewards for
        @return Amount of rewards claimed
     */
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external returns (uint256);

    /**
        @notice Get settings for a specific promotion.
        @param _promotionId Promotion id to get settings for
        @return Promotion settings
     */
    function getPromotion(uint256 _promotionId) external view returns (Promotion memory);

    /**
        @notice Get the current epoch id of a promotion.
        @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
        @param _promotionId Promotion id to get current epoch for
        @return Epoch id
     */
    function getCurrentEpochId(uint256 _promotionId) external view returns (uint256);

    /**
        @notice Get the total amount of tokens left to be rewarded.
        @param _promotionId Promotion id to get the total amount of tokens left to be rewarded for
        @return Amount of tokens left to be rewarded
     */
    function getRemainingRewards(uint256 _promotionId) external view returns (uint256);

    /**
        @notice Get amount of tokens to be rewarded for a given epoch.
        @dev Will be 0 if user has already claimed rewards for the epoch.
        @param _user Address of the user to get amount of rewards for
        @param _promotionId Promotion id from which the epoch is
        @param _epochIds Epoch ids to get reward amount for
        @return Amount of tokens to be rewarded
     */
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external view returns (uint256[] memory);
}",1072
RealWorld_TA_64_PrizeDistributionFactory_RealWorld_20240808173545.log,64,PrizeDistributionFactory,196107,3419,199526,122.0,1.048915,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionBuffer.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/IPrizeDistributionSource.sol"";
import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""./interfaces/IPrizeTierHistory.sol"";

/**
 * @title Prize Distribution Factory
 * @author PoolTogether Inc.
 * @notice The Prize Distribution Factory populates a Prize Distribution Buffer for a prize pool.  It uses a Prize Tier History, Draw Buffer and Ticket
 * to compute the correct prize distribution.  It automatically sets the cardinality based on the minPickCost and the total network ticket supply.
 */
contract PrizeDistributionFactory is Manageable {
    using ExtendedSafeCastLib for uint256;

    /// @notice Emitted when a new Prize Distribution is pushed.
    /// @param drawId The draw id for which the prize dist was pushed
    /// @param totalNetworkTicketSupply The total network ticket supply that was used to compute the cardinality and portion of picks
    event PrizeDistributionPushed(uint32 indexed drawId, uint256 totalNetworkTicketSupply);

    /// @notice Emitted when a Prize Distribution is set (overrides another)
    /// @param drawId The draw id for which the prize dist was set
    /// @param totalNetworkTicketSupply The total network ticket supply that was used to compute the cardinality and portion of picks
    event PrizeDistributionSet(uint32 indexed drawId, uint256 totalNetworkTicketSupply);

    /// @notice The prize tier history to pull tier information from
    IPrizeTierHistory public immutable prizeTierHistory;

    /// @notice The draw buffer to pull the draw from
    IDrawBuffer public immutable drawBuffer;

    /// @notice The prize distribution buffer to push and set.  This contract must be the manager or owner of the buffer.
    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;

    /// @notice The ticket whose average total supply will be measured to calculate the portion of picks
    ITicket public immutable ticket;

    /// @notice The minimum cost of each pick.  Used to calculate the cardinality.
    uint256 public immutable minPickCost;

    constructor(
        address _owner,
        IPrizeTierHistory _prizeTierHistory,
        IDrawBuffer _drawBuffer,
        IPrizeDistributionBuffer _prizeDistributionBuffer,
        ITicket _ticket,
        uint256 _minPickCost
    ) Ownable(_owner) {
        require(_owner != address(0), ""PDC/owner-zero"");
        require(address(_prizeTierHistory) != address(0), ""PDC/pth-zero"");
        require(address(_drawBuffer) != address(0), ""PDC/db-zero"");
        require(address(_prizeDistributionBuffer) != address(0), ""PDC/pdb-zero"");
        require(address(_ticket) != address(0), ""PDC/ticket-zero"");
        require(_minPickCost > 0, ""PDC/pick-cost-gt-zero"");

        minPickCost = _minPickCost;
        prizeTierHistory = _prizeTierHistory;
        drawBuffer = _drawBuffer;
        prizeDistributionBuffer = _prizeDistributionBuffer;
        ticket = _ticket;
    }

    /**
     * @notice Allows the owner or manager to push a new prize distribution onto the buffer.
     * The PrizeTier and Draw for the given draw id will be pulled in, and the total network ticket supply will be used to calculate cardinality.
     * @param _drawId The draw id to compute for
     * @param _totalNetworkTicketSupply The total supply of tickets across all prize pools for the network that the ticket belongs to.
     * @return The resulting Prize Distribution
     */
    function pushPrizeDistribution(uint32 _drawId, uint256 _totalNetworkTicketSupply)
        external
        onlyManagerOrOwner
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        IPrizeDistributionBuffer.PrizeDistribution
            memory prizeDistribution = calculatePrizeDistribution(
                _drawId,
                _totalNetworkTicketSupply
            );
        prizeDistributionBuffer.pushPrizeDistribution(_drawId, prizeDistribution);

        emit PrizeDistributionPushed(_drawId, _totalNetworkTicketSupply);

        return prizeDistribution;
    }

    /**
     * @notice Allows the owner or manager to override an existing prize distribution in the buffer.
     * The PrizeTier and Draw for the given draw id will be pulled in, and the total network ticket supply will be used to calculate cardinality.
     * @param _drawId The draw id to compute for
     * @param _totalNetworkTicketSupply The total supply of tickets across all prize pools for the network that the ticket belongs to.
     * @return The resulting Prize Distribution
     */
    function setPrizeDistribution(uint32 _drawId, uint256 _totalNetworkTicketSupply)
        external
        onlyOwner
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        IPrizeDistributionBuffer.PrizeDistribution
            memory prizeDistribution = calculatePrizeDistribution(
                _drawId,
                _totalNetworkTicketSupply
            );
        prizeDistributionBuffer.setPrizeDistribution(_drawId, prizeDistribution);

        emit PrizeDistributionSet(_drawId, _totalNetworkTicketSupply);

        return prizeDistribution;
    }

    /**
     * @notice Calculates what the prize distribution will be, given a draw id and total network ticket supply.
     * @param _drawId The draw id to pull from the Draw Buffer and Prize Tier History
     * @param _totalNetworkTicketSupply The total of all ticket supplies across all prize pools in this network
     * @return PrizeDistribution using info from the Draw for the given draw id, total network ticket supply, and PrizeTier for the draw.
     */
    function calculatePrizeDistribution(uint32 _drawId, uint256 _totalNetworkTicketSupply)
        public
        view
        virtual
        returns (IPrizeDistributionBuffer.PrizeDistribution memory)
    {
        IDrawBeacon.Draw memory draw = drawBuffer.getDraw(_drawId);
        return
            calculatePrizeDistributionWithDrawData(
                _drawId,
                _totalNetworkTicketSupply,
                draw.beaconPeriodSeconds,
                draw.timestamp
            );
    }

    /**
     * @notice Calculates what the prize distribution will be, given a draw id and total network ticket supply.
     * @param _drawId The draw from which to use the Draw and
     * @param _totalNetworkTicketSupply The sum of all ticket supplies across all prize pools on the network
     * @param _beaconPeriodSeconds The beacon period in seconds
     * @param _drawTimestamp The timestamp at which the draw RNG request started.
     * @return A PrizeDistribution based on the given params and PrizeTier for the passed draw id
     */
    function calculatePrizeDistributionWithDrawData(
        uint32 _drawId,
        uint256 _totalNetworkTicketSupply,
        uint32 _beaconPeriodSeconds,
        uint64 _drawTimestamp
    ) public view virtual returns (IPrizeDistributionBuffer.PrizeDistribution memory) {
        uint256 maxPicks = _totalNetworkTicketSupply / minPickCost;

        IPrizeDistributionBuffer.PrizeDistribution
            memory prizeDistribution = _calculatePrizeDistribution(
                _drawId,
                _beaconPeriodSeconds,
                maxPicks
            );

        uint64[] memory startTimestamps = new uint64[](1);
        uint64[] memory endTimestamps = new uint64[](1);

        startTimestamps[0] = _drawTimestamp - prizeDistribution.startTimestampOffset;
        endTimestamps[0] = _drawTimestamp - prizeDistribution.endTimestampOffset;

        uint256[] memory ticketAverageTotalSupplies = ticket.getAverageTotalSuppliesBetween(
            startTimestamps,
            endTimestamps
        );

        require(
            _totalNetworkTicketSupply >= ticketAverageTotalSupplies[0],
            ""PDF/invalid-network-supply""
        );

        if (_totalNetworkTicketSupply > 0) {
            prizeDistribution.numberOfPicks = uint256(
                (prizeDistribution.numberOfPicks * ticketAverageTotalSupplies[0]) /
                    _totalNetworkTicketSupply
            ).toUint104();
        } else {
            prizeDistribution.numberOfPicks = 0;
        }

        return prizeDistribution;
    }

    /**
     * @notice Gets the PrizeDistributionBuffer for a drawId
     * @param _drawId drawId
     * @param _startTimestampOffset The start timestamp offset to use for the prize distribution
     * @param _maxPicks The maximum picks that the distribution should allow.  The Prize Distribution's numberOfPicks will be less than or equal to this number.
     * @return prizeDistribution
     */
    function _calculatePrizeDistribution(
        uint32 _drawId,
        uint32 _startTimestampOffset,
        uint256 _maxPicks
    ) internal view virtual returns (IPrizeDistributionBuffer.PrizeDistribution memory) {
        IPrizeTierHistory.PrizeTier memory prizeTier = prizeTierHistory.getPrizeTier(_drawId);

        uint8 cardinality;
        do {
            cardinality++;
        } while ((2**prizeTier.bitRangeSize)**(cardinality + 1) < _maxPicks);

        IPrizeDistributionBuffer.PrizeDistribution
            memory prizeDistribution = IPrizeDistributionSource.PrizeDistribution({
                bitRangeSize: prizeTier.bitRangeSize,
                matchCardinality: cardinality,
                startTimestampOffset: _startTimestampOffset,
                endTimestampOffset: prizeTier.endTimestampOffset,
                maxPicksPerUser: prizeTier.maxPicksPerUser,
                expiryDuration: prizeTier.expiryDuration,
                numberOfPicks: uint256((2**prizeTier.bitRangeSize)**cardinality).toUint104(),
                tiers: prizeTier.tiers,
                prize: prizeTier.prize
            });

        return prizeDistribution;
    }
}",2124
RealWorld_TA_64_ControlledToken_RealWorld_20240808181226.log,64,ControlledToken,89741,2058,91799,89.0,0.489865,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";

import ""./interfaces/IControlledToken.sol"";

/**
 * @title  PoolTogether V4 Controlled ERC20 Token
 * @author PoolTogether Inc Team
 * @notice  ERC20 Tokens with a controller for minting & burning
 */
contract ControlledToken is ERC20Permit, IControlledToken {
    /* ============ Global Variables ============ */

    /// @notice Interface to the contract responsible for controlling mint/burn
    address public override immutable controller;

    /// @notice ERC20 controlled token decimals.
    uint8 private immutable _decimals;

    /* ============ Events ============ */

    /// @dev Emitted when contract is deployed
    event Deployed(string name, string symbol, uint8 decimals, address indexed controller);

    /* ============ Modifiers ============ */

    /// @dev Function modifier to ensure that the caller is the controller contract
    modifier onlyController() {
        require(msg.sender == address(controller), ""ControlledToken/only-controller"");
        _;
    }

    /* ============ Constructor ============ */

    /// @notice Deploy the Controlled Token with Token Details and the Controller
    /// @param _name The name of the Token
    /// @param _symbol The symbol for the Token
    /// @param decimals_ The number of decimals for the Token
    /// @param _controller Address of the Controller contract for minting & burning
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) ERC20Permit(""PoolTogether ControlledToken"") ERC20(_name, _symbol) {
        require(address(_controller) != address(0), ""ControlledToken/controller-not-zero-address"");
        controller = _controller;

        require(decimals_ > 0, ""ControlledToken/decimals-gt-zero"");
        _decimals = decimals_;

        emit Deployed(_name, _symbol, decimals_, _controller);
    }

    /* ============ External Functions ============ */

    /// @notice Allows the controller to mint tokens for a user account
    /// @dev May be overridden to provide more granular control over minting
    /// @param _user Address of the receiver of the minted tokens
    /// @param _amount Amount of tokens to mint
    function controllerMint(address _user, uint256 _amount)
        external
        virtual
        override
        onlyController
    {
        _mint(_user, _amount);
    }

    /// @notice Allows the controller to burn tokens from a user account
    /// @dev May be overridden to provide more granular control over burning
    /// @param _user Address of the holder account to burn tokens from
    /// @param _amount Amount of tokens to burn
    function controllerBurn(address _user, uint256 _amount)
        external
        virtual
        override
        onlyController
    {
        _burn(_user, _amount);
    }

    /// @notice Allows an operator via the controller to burn tokens on behalf of a user account
    /// @dev May be overridden to provide more granular control over operator-burning
    /// @param _operator Address of the operator performing the burn action via the controller contract
    /// @param _user Address of the holder account to burn tokens from
    /// @param _amount Amount of tokens to burn
    function controllerBurnFrom(
        address _operator,
        address _user,
        uint256 _amount
    ) external virtual override onlyController {
        if (_operator != _user) {
            _approve(_user, _operator, allowance(_user, _operator) - _amount);
        }

        _burn(_user, _amount);
    }

    /// @notice Returns the ERC20 controlled token decimals.
    /// @dev This value should be equal to the decimals of the token used to deposit into the pool.
    /// @return uint8 decimals.
    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}",865
RealWorld_TA_64_ExtendedSafeCastLib_RealWorld_20240808185821.log,64,ExtendedSafeCastLib,63984,1263,65247,73.0,0.34518,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

/**
 * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
 * checks.
 *
 * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
 * easily result in undesired exploitation or bugs, since developers usually
 * assume that overflows raise errors. `SafeCast` restores this intuition by
 * reverting the transaction when such an operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 *
 * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
 * all math on `uint256` and `int256` and then downcasting.
 */
library ExtendedSafeCastLib {

    /**
     * @dev Returns the downcasted uint104 from uint256, reverting on
     * overflow (when the input is greater than largest uint104).
     *
     * Counterpart to Solidity's `uint104` operator.
     *
     * Requirements:
     *
     * - input must fit into 104 bits
     */
    function toUint104(uint256 _value) internal pure returns (uint104) {
        require(_value <= type(uint104).max, ""SafeCast: value doesn't fit in 104 bits"");
        return uint104(_value);
    }

    /**
     * @dev Returns the downcasted uint208 from uint256, reverting on
     * overflow (when the input is greater than largest uint208).
     *
     * Counterpart to Solidity's `uint208` operator.
     *
     * Requirements:
     *
     * - input must fit into 208 bits
     */
    function toUint208(uint256 _value) internal pure returns (uint208) {
        require(_value <= type(uint208).max, ""SafeCast: value doesn't fit in 208 bits"");
        return uint208(_value);
    }

    /**
     * @dev Returns the downcasted uint224 from uint256, reverting on
     * overflow (when the input is greater than largest uint224).
     *
     * Counterpart to Solidity's `uint224` operator.
     *
     * Requirements:
     *
     * - input must fit into 224 bits
     */
    function toUint224(uint256 _value) internal pure returns (uint224) {
        require(_value <= type(uint224).max, ""SafeCast: value doesn't fit in 224 bits"");
        return uint224(_value);
    }
}",556
RealWorld_TA_64_ITicket_RealWorld_20240808192542.log,64,ITicket,161757,2523,164280,97.0,0.859245,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../libraries/TwabLib.sol"";
import ""./IControlledToken.sol"";

interface ITicket is IControlledToken {
    /**
     * @notice A struct containing details for an Account.
     * @param balance The current balance for an Account.
     * @param nextTwabIndex The next available index to store a new twab.
     * @param cardinality The number of recorded twabs (plus one!).
     */
    struct AccountDetails {
        uint224 balance;
        uint16 nextTwabIndex;
        uint16 cardinality;
    }

    /**
     * @notice Combines account details with their twab history.
     * @param details The account details.
     * @param twabs The history of twabs for this account.
     */
    struct Account {
        AccountDetails details;
        ObservationLib.Observation[65535] twabs;
    }

    /**
     * @notice Emitted when TWAB balance has been delegated to another user.
     * @param delegator Address of the delegator.
     * @param delegate Address of the delegate.
     */
    event Delegated(address indexed delegator, address indexed delegate);

    /**
     * @notice Emitted when ticket is initialized.
     * @param name Ticket name (eg: PoolTogether Dai Ticket (Compound)).
     * @param symbol Ticket symbol (eg: PcDAI).
     * @param decimals Ticket decimals.
     * @param controller Token controller address.
     */
    event TicketInitialized(string name, string symbol, uint8 decimals, address indexed controller);

    /**
     * @notice Emitted when a new TWAB has been recorded.
     * @param delegate The recipient of the ticket power (may be the same as the user).
     * @param newTwab Updated TWAB of a ticket holder after a successful TWAB recording.
     */
    event NewUserTwab(
        address indexed delegate,
        ObservationLib.Observation newTwab
    );

    /**
     * @notice Emitted when a new total supply TWAB has been recorded.
     * @param newTotalSupplyTwab Updated TWAB of tickets total supply after a successful total supply TWAB recording.
     */
    event NewTotalSupplyTwab(ObservationLib.Observation newTotalSupplyTwab);

    /**
     * @notice Retrieves the address of the delegate to whom `user` has delegated their tickets.
     * @dev Address of the delegate will be the zero address if `user` has not delegated their tickets.
     * @param user Address of the delegator.
     * @return Address of the delegate.
     */
    function delegateOf(address user) external view returns (address);

    /**
    * @notice Delegate time-weighted average balances to an alternative address.
    * @dev    Transfers (including mints) trigger the storage of a TWAB in delegate(s) account, instead of the
              targetted sender and/or recipient address(s).
    * @dev    To reset the delegate, pass the zero address (0x000.000) as `to` parameter.
    * @dev Current delegate address should be different from the new delegate address `to`.
    * @param  to Recipient of delegated TWAB.
    */
    function delegate(address to) external;

    /**
     * @notice Allows the controller to delegate on a users behalf.
     * @param user The user for whom to delegate
     * @param delegate The new delegate
     */
    function controllerDelegateFor(address user, address delegate) external;

    /**
     * @notice Allows a user to delegate via signature
     * @param user The user who is delegating
     * @param delegate The new delegate
     * @param deadline The timestamp by which this must be submitted
     * @param v The v portion of the ECDSA sig
     * @param r The r portion of the ECDSA sig
     * @param s The s portion of the ECDSA sig
     */
    function delegateWithSignature(
        address user,
        address delegate,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @notice Gets a users twab context.  This is a struct with their balance, next twab index, and cardinality.
     * @param user The user for whom to fetch the TWAB context.
     * @return The TWAB context, which includes { balance, nextTwabIndex, cardinality }
     */
    function getAccountDetails(address user) external view returns (TwabLib.AccountDetails memory);

    /**
     * @notice Gets the TWAB at a specific index for a user.
     * @param user The user for whom to fetch the TWAB.
     * @param index The index of the TWAB to fetch.
     * @return The TWAB, which includes the twab amount and the timestamp.
     */
    function getTwab(address user, uint16 index)
        external
        view
        returns (ObservationLib.Observation memory);

    /**
     * @notice Retrieves `user` TWAB balance.
     * @param user Address of the user whose TWAB is being fetched.
     * @param timestamp Timestamp at which we want to retrieve the TWAB balance.
     * @return The TWAB balance at the given timestamp.
     */
    function getBalanceAt(address user, uint64 timestamp) external view returns (uint256);

    /**
     * @notice Retrieves `user` TWAB balances.
     * @param user Address of the user whose TWABs are being fetched.
     * @param timestamps Timestamps range at which we want to retrieve the TWAB balances.
     * @return `user` TWAB balances.
     */
    function getBalancesAt(address user, uint64[] calldata timestamps)
        external
        view
        returns (uint256[] memory);

    /**
     * @notice Retrieves the average balance held by a user for a given time frame.
     * @param user The user whose balance is checked.
     * @param startTime The start time of the time frame.
     * @param endTime The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function getAverageBalanceBetween(
        address user,
        uint64 startTime,
        uint64 endTime
    ) external view returns (uint256);

    /**
     * @notice Retrieves the average balances held by a user for a given time frame.
     * @param user The user whose balance is checked.
     * @param startTimes The start time of the time frame.
     * @param endTimes The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function getAverageBalancesBetween(
        address user,
        uint64[] calldata startTimes,
        uint64[] calldata endTimes
    ) external view returns (uint256[] memory);

    /**
     * @notice Retrieves the total supply TWAB balance at the given timestamp.
     * @param timestamp Timestamp at which we want to retrieve the total supply TWAB balance.
     * @return The total supply TWAB balance at the given timestamp.
     */
    function getTotalSupplyAt(uint64 timestamp) external view returns (uint256);

    /**
     * @notice Retrieves the total supply TWAB balance between the given timestamps range.
     * @param timestamps Timestamps range at which we want to retrieve the total supply TWAB balance.
     * @return Total supply TWAB balances.
     */
    function getTotalSuppliesAt(uint64[] calldata timestamps)
        external
        view
        returns (uint256[] memory);

    /**
     * @notice Retrieves the average total supply balance for a set of given time frames.
     * @param startTimes Array of start times.
     * @param endTimes Array of end times.
     * @return The average total supplies held during the time frame.
     */
    function getAverageTotalSuppliesBetween(
        uint64[] calldata startTimes,
        uint64[] calldata endTimes
    ) external view returns (uint256[] memory);
}",1708
RealWorld_TA_64_PrizeSplitStrategyHarness_RealWorld_20240808182556.log,64,PrizeSplitStrategyHarness,27935,3471,31406,92.0,0.209095,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../prize-strategy/PrizeSplitStrategy.sol"";

contract PrizeSplitStrategyHarness is PrizeSplitStrategy {
    constructor(address _owner, IPrizePool _prizePool) PrizeSplitStrategy(_owner, _prizePool) {}

    function awardPrizeSplitAmount(address target, uint256 amount) external {
        return _awardPrizeSplitAmount(target, amount);
    }
}",101
RealWorld_TA_64_DrawExecutor_RealWorld_20240808174451.log,64,DrawExecutor,89257,2438,91695,92.0,0.495045,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IDrawBuffer.sol"";

import { ExecutorAware } from ""./abstract/ExecutorAware.sol"";

/**
 * @title PoolTogether V4 DrawExecutor
 * @author PoolTogether Inc Team
 * @notice The DrawExecutor smart contract relies on ERC-5164 to receive draws from Ethereum
 *         and push them onto the DrawBuffer.
 * @dev This contract does not ensure draw ordering and draws should always be bridged in ascending and contiguous order.
 */
contract DrawExecutor is ExecutorAware {
    /**
     * @notice Emitted when the `draw` has been pushed.
     * @param draw Draw that was pushed
     */
    event DrawPushed(IDrawBeacon.Draw draw);

    /**
     * @notice Emitted when the `draws` have been pushed.
     * @param draws Draws that were pushed
     */
    event DrawsPushed(IDrawBeacon.Draw[] draws);

    /// @notice ID of the origin chain.
    uint256 public immutable originChainId;

    /// @notice DrawDispatcher contract on the origin chain that dispatch the draws.
    address public immutable drawDispatcher;

    /// @notice DrawBuffer onto which draws are pushed.
    IDrawBuffer public immutable drawBuffer;

    /**
     * @notice DrawExecutor constructor.
     * @param _originChainId ID of the origin chain
     * @param _drawDispatcher Address of the DrawDispatcher on the origin chain that dispatch the draws
     * @param _executor Address of the ERC-5164 contract that executes the bridged calls
     * @param _drawBuffer Address of the DrawBuffer onto which draws are pushed
     */
    constructor(
        uint256 _originChainId,
        address _drawDispatcher,
        address _executor,
        IDrawBuffer _drawBuffer
    ) ExecutorAware(_executor) {
        require(_originChainId != 0, ""DE/originChainId-not-zero"");
        require(address(_drawDispatcher) != address(0), ""DE/drawDispatcher-not-zero-adrs"");
        require(address(_drawBuffer) != address(0), ""DE/drawBuffer-not-zero-address"");

        originChainId = _originChainId;
        drawDispatcher = _drawDispatcher;
        drawBuffer = _drawBuffer;
    }

    /**
     * @notice Push `draw` onto the DrawBuffer.
     * @dev Only the `executor` is able to call this function.
     * @param _draw Draw to push
     */
    function pushDraw(IDrawBeacon.Draw calldata _draw) external {
        _checkSender();

        drawBuffer.pushDraw(_draw);

        emit DrawPushed(_draw);
    }

    /**
     * @notice Push `draws` onto the DrawBuffer.
     * @dev Only the `executor` is able to call this function.
     * @dev `draws` must be ordered in ascending and contiguous order.
     * @param _draws Draws to push
     */
    function pushDraws(IDrawBeacon.Draw[] calldata _draws) external {
        _checkSender();

        uint256 _drawsLength = _draws.length;

        for (uint256 i; i < _drawsLength; i++) {
            drawBuffer.pushDraw(_draws[i]);
        }

        emit DrawsPushed(_draws);
    }

    /**
     * @notice Checks that:
     *          - the call has been dispatched from the supported chain
     *          - the sender on the receiving chain is the executor
     *          - the sender on the origin chain is the DrawDispatcher
     */
    function _checkSender() internal view {
        require(_fromChainId() == originChainId, ""DE/l1-chainId-not-supported"");
        require(isTrustedExecutor(msg.sender), ""DE/l2-sender-not-executor"");
        require(_msgSender() == address(drawDispatcher), ""DE/l1-sender-not-dispatcher"");
    }
}",840
RealWorld_TA_64_IReserve_RealWorld_20240808192838.log,64,IReserve,49421,2789,52210,91.0,0.302885,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IReserve {
    /**
     * @notice Emit when checkpoint is created.
     * @param reserveAccumulated  Total depsosited
     * @param withdrawAccumulated Total withdrawn
     */

    event Checkpoint(uint256 reserveAccumulated, uint256 withdrawAccumulated);
    /**
     * @notice Emit when the withdrawTo function has executed.
     * @param recipient Address receiving funds
     * @param amount    Amount of tokens transfered.
     */
    event Withdrawn(address indexed recipient, uint256 amount);

    /**
     * @notice Create observation checkpoint in ring bufferr.
     * @dev    Calculates total desposited tokens since last checkpoint and creates new accumulator checkpoint.
     */
    function checkpoint() external;

    /**
     * @notice Read global token value.
     * @return IERC20
     */
    function getToken() external view returns (IERC20);

    /**
     * @notice Calculate token accumulation beween timestamp range.
     * @dev    Search the ring buffer for two checkpoint observations and diffs accumulator amount.
     * @param startTimestamp Account address
     * @param endTimestamp   Transfer amount
     */
    function getReserveAccumulatedBetween(uint32 startTimestamp, uint32 endTimestamp)
        external
        returns (uint224);

    /**
     * @notice Transfer Reserve token balance to recipient address.
     * @dev    Creates checkpoint before token transfer. Increments withdrawAccumulator with amount.
     * @param recipient Account address
     * @param amount    Transfer amount
     */
    function withdrawTo(address recipient, uint256 amount) external;
}",372
RealWorld_TA_64_EIP2612PermitAndDeposit_RealWorld_20240808190428.log,64,EIP2612PermitAndDeposit,113647,2266,115913,86.0,0.613555,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""../interfaces/IPrizePool.sol"";
import ""../interfaces/ITicket.sol"";

/**
 * @notice Secp256k1 signature values.
 * @param deadline Timestamp at which the signature expires
 * @param v `v` portion of the signature
 * @param r `r` portion of the signature
 * @param s `s` portion of the signature
 */
struct Signature {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

/**
 * @notice Delegate signature to allow delegation of tickets to delegate.
 * @param delegate Address to delegate the prize pool tickets to
 * @param signature Delegate signature
 */
struct DelegateSignature {
    address delegate;
    Signature signature;
}

/// @title Allows users to approve and deposit EIP-2612 compatible tokens into a prize pool in a single transaction.
/// @custom:experimental This contract has not been fully audited yet.
contract EIP2612PermitAndDeposit {
    using SafeERC20 for IERC20;

    /**
     * @notice Permits this contract to spend on a user's behalf and deposits into the prize pool.
     * @dev The `spender` address required by the permit function is the address of this contract.
     * @param _prizePool Address of the prize pool to deposit into
     * @param _amount Amount of tokens to deposit into the prize pool
     * @param _to Address that will receive the tickets
     * @param _permitSignature Permit signature
     * @param _delegateSignature Delegate signature
     */
    function permitAndDepositToAndDelegate(
        IPrizePool _prizePool,
        uint256 _amount,
        address _to,
        Signature calldata _permitSignature,
        DelegateSignature calldata _delegateSignature
    ) external {
        ITicket _ticket = _prizePool.getTicket();
        address _token = _prizePool.getToken();

        IERC20Permit(_token).permit(
            msg.sender,
            address(this),
            _amount,
            _permitSignature.deadline,
            _permitSignature.v,
            _permitSignature.r,
            _permitSignature.s
        );

        _depositToAndDelegate(
            address(_prizePool),
            _ticket,
            _token,
            _amount,
            _to,
            _delegateSignature
        );
    }

    /**
     * @notice Deposits user's token into the prize pool and delegate tickets.
     * @param _prizePool Address of the prize pool to deposit into
     * @param _amount Amount of tokens to deposit into the prize pool
     * @param _to Address that will receive the tickets
     * @param _delegateSignature Delegate signature
     */
    function depositToAndDelegate(
        IPrizePool _prizePool,
        uint256 _amount,
        address _to,
        DelegateSignature calldata _delegateSignature
    ) external {
        ITicket _ticket = _prizePool.getTicket();
        address _token = _prizePool.getToken();

        _depositToAndDelegate(
            address(_prizePool),
            _ticket,
            _token,
            _amount,
            _to,
            _delegateSignature
        );
    }

    /**
     * @notice Deposits user's token into the prize pool and delegate tickets.
     * @param _prizePool Address of the prize pool to deposit into
     * @param _ticket Address of the ticket minted by the prize pool
     * @param _token Address of the token used to deposit into the prize pool
     * @param _amount Amount of tokens to deposit into the prize pool
     * @param _to Address that will receive the tickets
     * @param _delegateSignature Delegate signature
     */
    function _depositToAndDelegate(
        address _prizePool,
        ITicket _ticket,
        address _token,
        uint256 _amount,
        address _to,
        DelegateSignature calldata _delegateSignature
    ) internal {
        _depositTo(_token, msg.sender, _amount, _prizePool, _to);

        Signature memory signature = _delegateSignature.signature;

        _ticket.delegateWithSignature(
            _to,
            _delegateSignature.delegate,
            signature.deadline,
            signature.v,
            signature.r,
            signature.s
        );
    }

    /**
     * @notice Deposits user's token into the prize pool.
     * @param _token Address of the EIP-2612 token to approve and deposit
     * @param _owner Token owner's address (Authorizer)
     * @param _amount Amount of tokens to deposit
     * @param _prizePool Address of the prize pool to deposit into
     * @param _to Address that will receive the tickets
     */
    function _depositTo(
        address _token,
        address _owner,
        uint256 _amount,
        address _prizePool,
        address _to
    ) internal {
        IERC20(_token).safeTransferFrom(_owner, address(this), _amount);
        IERC20(_token).safeIncreaseAllowance(_prizePool, _amount);
        IPrizePool(_prizePool).depositTo(_to, _amount);
    }
}",1166
RealWorld_TA_64_IPrizeTierHistory_RealWorld_20240808180321.log,64,IPrizeTierHistory,85755,1977,87732,84.0,0.468315,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;
import ""@pooltogether/v4-core/contracts/DrawBeacon.sol"";

/**
 * @title  PoolTogether V4 IPrizeTierHistory
 * @author PoolTogether Inc Team
 * @notice IPrizeTierHistory is the base contract for PrizeTierHistory
 */
interface IPrizeTierHistory {
    /// @notice Linked Draw and PrizeDistribution parameters storage schema
    struct PrizeTier {
        uint8 bitRangeSize;
        uint32 drawId;
        uint32 maxPicksPerUser;
        uint32 expiryDuration;
        uint32 endTimestampOffset;
        uint256 prize;
        uint32[16] tiers;
    }

    /**
     * @notice Emitted when new PrizeTier is added to history
     * @param drawId    Draw ID
     * @param prizeTier PrizeTier parameters
     */
    event PrizeTierPushed(uint32 indexed drawId, PrizeTier prizeTier);

    /**
     * @notice Emitted when existing PrizeTier is updated in history
     * @param drawId    Draw ID
     * @param prizeTier PrizeTier parameters
     */
    event PrizeTierSet(uint32 indexed drawId, PrizeTier prizeTier);

    /**
     * @notice Push PrizeTier struct onto `prizeTiers` array.
     * @dev Callable only by the owner or manager.
     * @dev `drawId` must be greater than the latest one stored in `history`.
     * @param nextPrizeTier Next PrizeTier struct
     */
    function push(PrizeTier calldata nextPrizeTier) external;

    /**
     * @notice Replace PrizeTier struct in `prizeTiers` array.
     * @dev    Callable only by the owner.
     * @param newPrizeTier PrizeTier parameters
     */
    function replace(PrizeTier calldata newPrizeTier) external;

    /**
     * @notice Pop the latest prize tier stored in the `prizeTiers` array and replace it with the new prize tier.
     * @dev    Callable only by the owner.
     * @param newPrizeTier Updated PrizeTier struct
     * @return drawId Draw ID of the PrizeTier that was pushed
     */
    function popAndPush(PrizeTier calldata newPrizeTier) external returns (uint32 drawId);

    /**
     * @notice Returns the number of Prize Tier structs pushed.
     * @return The number of prize tiers that have been pushed
     */
    function count() external view returns (uint256);

    /**
     * @notice Read PrizeTierHistory struct from history array.
     * @param drawId Draw ID
     * @return prizeTier
     */
    function getPrizeTier(uint32 drawId) external view returns (PrizeTier memory prizeTier);

    /**
     * @notice Read PrizeTierHistory List from history array.
     * @param drawIds Draw ID array
     * @return prizeTierList
     */
    function getPrizeTierList(uint32[] calldata drawIds)
        external
        view
        returns (PrizeTier[] memory prizeTierList);

    /**
     * @notice Get prize tier at the specified `index`.
     * @param index Index at which to get the prize tier
     * @return PrizeTier at `index`
     */
    function getPrizeTierAtIndex(uint256 index) external view returns (PrizeTier memory);

    /**
     * @notice Read first Draw ID used to initialize history.
     * @return Draw ID of first PrizeTier record
     */
    function getOldestDrawId() external view returns (uint32);

    /**
     * @notice Read last Draw ID stored in the history.
     * @return Draw ID of the last recorded PrizeTier record
     */
    function getNewestDrawId() external view returns (uint32);
}",818
RealWorld_TA_64_TicketHarness_RealWorld_20240808182730.log,64,TicketHarness,56549,3182,59731,93.0,0.346385,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

import ""../Ticket.sol"";

contract TicketHarness is Ticket {
    using SafeCast for uint256;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) Ticket(_name, _symbol, decimals_, _controller) {}

    function flashLoan(address _to, uint256 _amount) external {
        _mint(_to, _amount);
        _burn(_to, _amount);
    }

    function burn(address _from, uint256 _amount) external {
        _burn(_from, _amount);
    }

    function mint(address _to, uint256 _amount) external {
        _mint(_to, _amount);
    }

    function mintTwice(address _to, uint256 _amount) external {
        _mint(_to, _amount);
        _mint(_to, _amount);
    }

    /// @dev we need to use a different function name than `transfer`
    /// otherwise it collides with the `transfer` function of the `ERC20` contract
    function transferTo(
        address _sender,
        address _recipient,
        uint256 _amount
    ) external {
        _transfer(_sender, _recipient, _amount);
    }

    function getBalanceTx(address _user, uint32 _target) external view returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getBalanceAt(account.twabs, account.details, _target, uint32(block.timestamp));
    }

    function getAverageBalanceTx(
        address _user,
        uint32 _startTime,
        uint32 _endTime
    ) external view returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                uint32(_startTime),
                uint32(_endTime),
                uint32(block.timestamp)
            );
    }
}",444
RealWorld_TA_64_DrawCalculator_RealWorld_20240808180557.log,64,DrawCalculator,338855,3599,342454,122.0,1.766255,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./interfaces/IDrawCalculator.sol"";
import ""./interfaces/ITicket.sol"";
import ""./interfaces/IDrawBuffer.sol"";
import ""./interfaces/IPrizeDistributionBuffer.sol"";
import ""./interfaces/IDrawBeacon.sol"";

/**
  * @title  PoolTogether V4 DrawCalculator
  * @author PoolTogether Inc Team
  * @notice The DrawCalculator calculates a user's prize by matching a winning random number against
            their picks. A users picks are generated deterministically based on their address and balance
            of tickets held. Prize payouts are divided into multiple tiers: grand prize, second place, etc...
            A user with a higher average weighted balance (during each draw period) will be given a large number of
            picks to choose from, and thus a higher chance to match the winning numbers.
*/
contract DrawCalculator is IDrawCalculator {

    /// @notice DrawBuffer address
    IDrawBuffer public immutable drawBuffer;

    /// @notice Ticket associated with DrawCalculator
    ITicket public immutable ticket;

    /// @notice The stored history of draw settings.  Stored as ring buffer.
    IPrizeDistributionBuffer public immutable prizeDistributionBuffer;

    /// @notice The tiers array length
    uint8 public constant TIERS_LENGTH = 16;

    /* ============ Constructor ============ */

    /// @notice Constructor for DrawCalculator
    /// @param _ticket Ticket associated with this DrawCalculator
    /// @param _drawBuffer The address of the draw buffer to push draws to
    /// @param _prizeDistributionBuffer PrizeDistributionBuffer address
    constructor(
        ITicket _ticket,
        IDrawBuffer _drawBuffer,
        IPrizeDistributionBuffer _prizeDistributionBuffer
    ) {
        require(address(_ticket) != address(0), ""DrawCalc/ticket-not-zero"");
        require(address(_prizeDistributionBuffer) != address(0), ""DrawCalc/pdb-not-zero"");
        require(address(_drawBuffer) != address(0), ""DrawCalc/dh-not-zero"");

        ticket = _ticket;
        drawBuffer = _drawBuffer;
        prizeDistributionBuffer = _prizeDistributionBuffer;

        emit Deployed(_ticket, _drawBuffer, _prizeDistributionBuffer);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IDrawCalculator
    function calculate(
        address _user,
        uint32[] calldata _drawIds,
        bytes calldata _pickIndicesForDraws
    ) external view override returns (uint256[] memory, bytes memory) {
        uint64[][] memory pickIndices = abi.decode(_pickIndicesForDraws, (uint64 [][]));
        require(pickIndices.length == _drawIds.length, ""DrawCalc/invalid-pick-indices-length"");

        // READ list of IDrawBeacon.Draw using the drawIds from drawBuffer
        IDrawBeacon.Draw[] memory draws = drawBuffer.getDraws(_drawIds);

        // READ list of IPrizeDistributionBuffer.PrizeDistribution using the drawIds
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer
            .getPrizeDistributions(_drawIds);

        // The userBalances are fractions representing their portion of the liquidity for a draw.
        uint256[] memory userBalances = _getNormalizedBalancesAt(_user, draws, _prizeDistributions);

        // The users address is hashed once.
        bytes32 _userRandomNumber = keccak256(abi.encodePacked(_user));

        return _calculatePrizesAwardable(
                userBalances,
                _userRandomNumber,
                draws,
                pickIndices,
                _prizeDistributions
            );
    }

    /// @inheritdoc IDrawCalculator
    function getDrawBuffer() external view override returns (IDrawBuffer) {
        return drawBuffer;
    }

    /// @inheritdoc IDrawCalculator
    function getPrizeDistributionBuffer()
        external
        view
        override
        returns (IPrizeDistributionBuffer)
    {
        return prizeDistributionBuffer;
    }

    /// @inheritdoc IDrawCalculator
    function getNormalizedBalancesForDrawIds(address _user, uint32[] calldata _drawIds)
        external
        view
        override
        returns (uint256[] memory)
    {
        IDrawBeacon.Draw[] memory _draws = drawBuffer.getDraws(_drawIds);
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions = prizeDistributionBuffer
            .getPrizeDistributions(_drawIds);

        return _getNormalizedBalancesAt(_user, _draws, _prizeDistributions);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculates the prizes awardable for each Draw passed.
     * @param _normalizedUserBalances Fractions representing the user's portion of the liquidity for each draw.
     * @param _userRandomNumber       Random number of the user to consider over draws
     * @param _draws                  List of Draws
     * @param _pickIndicesForDraws    Pick indices for each Draw
     * @param _prizeDistributions     PrizeDistribution for each Draw

     */
    function _calculatePrizesAwardable(
        uint256[] memory _normalizedUserBalances,
        bytes32 _userRandomNumber,
        IDrawBeacon.Draw[] memory _draws,
        uint64[][] memory _pickIndicesForDraws,
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions
    ) internal view returns (uint256[] memory prizesAwardable, bytes memory prizeCounts) {
        
        uint256[] memory _prizesAwardable = new uint256[](_normalizedUserBalances.length);
        uint256[][] memory _prizeCounts = new uint256[][](_normalizedUserBalances.length);

        uint64 timeNow = uint64(block.timestamp);



        // calculate prizes awardable for each Draw passed
        for (uint32 drawIndex = 0; drawIndex < _draws.length; drawIndex++) {

            require(timeNow < _draws[drawIndex].timestamp + _prizeDistributions[drawIndex].expiryDuration, ""DrawCalc/draw-expired"");

            uint64 totalUserPicks = _calculateNumberOfUserPicks(
                _prizeDistributions[drawIndex],
                _normalizedUserBalances[drawIndex]
            );

            (_prizesAwardable[drawIndex], _prizeCounts[drawIndex]) = _calculate(
                _draws[drawIndex].winningRandomNumber,
                totalUserPicks,
                _userRandomNumber,
                _pickIndicesForDraws[drawIndex],
                _prizeDistributions[drawIndex]
            );
        }
        prizeCounts = abi.encode(_prizeCounts);
        prizesAwardable = _prizesAwardable;
    }

    /**
     * @notice Calculates the number of picks a user gets for a Draw, considering the normalized user balance and the PrizeDistribution.
     * @dev Divided by 1e18 since the normalized user balance is stored as a fixed point 18 number
     * @param _prizeDistribution The PrizeDistribution to consider
     * @param _normalizedUserBalance The normalized user balances to consider
     * @return The number of picks a user gets for a Draw
     */
    function _calculateNumberOfUserPicks(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint256 _normalizedUserBalance
    ) internal pure returns (uint64) {
        return uint64((_normalizedUserBalance * _prizeDistribution.numberOfPicks) / 1 ether);
    }

    /**
     * @notice Calculates the normalized balance of a user against the total supply for timestamps
     * @param _user The user to consider
     * @param _draws The draws we are looking at
     * @param _prizeDistributions The prize tiers to consider (needed for draw timestamp offsets)
     * @return An array of normalized balances
     */
    function _getNormalizedBalancesAt(
        address _user,
        IDrawBeacon.Draw[] memory _draws,
        IPrizeDistributionBuffer.PrizeDistribution[] memory _prizeDistributions
    ) internal view returns (uint256[] memory) {
        uint256 drawsLength = _draws.length;
        uint64[] memory _timestampsWithStartCutoffTimes = new uint64[](drawsLength);
        uint64[] memory _timestampsWithEndCutoffTimes = new uint64[](drawsLength);

        // generate timestamps with draw cutoff offsets included
        for (uint32 i = 0; i < drawsLength; i++) {
            unchecked {
                _timestampsWithStartCutoffTimes[i] =
                    _draws[i].timestamp - _prizeDistributions[i].startTimestampOffset;
                _timestampsWithEndCutoffTimes[i] =
                    _draws[i].timestamp - _prizeDistributions[i].endTimestampOffset;
            }
        }

        uint256[] memory balances = ticket.getAverageBalancesBetween(
            _user,
            _timestampsWithStartCutoffTimes,
            _timestampsWithEndCutoffTimes
        );

        uint256[] memory totalSupplies = ticket.getAverageTotalSuppliesBetween(
            _timestampsWithStartCutoffTimes,
            _timestampsWithEndCutoffTimes
        );

        uint256[] memory normalizedBalances = new uint256[](drawsLength);

        // divide balances by total supplies (normalize)
        for (uint256 i = 0; i < drawsLength; i++) {
            if(totalSupplies[i] == 0){
                normalizedBalances[i] = 0;
            }
            else {
                normalizedBalances[i] = (balances[i] * 1 ether) / totalSupplies[i];
            }
        }

        return normalizedBalances;
    }

    /**
     * @notice Calculates the prize amount for a PrizeDistribution over given picks
     * @param _winningRandomNumber Draw's winningRandomNumber
     * @param _totalUserPicks      number of picks the user gets for the Draw
     * @param _userRandomNumber    users randomNumber for that draw
     * @param _picks               users picks for that draw
     * @param _prizeDistribution   PrizeDistribution for that draw
     * @return prize (if any), prizeCounts (if any)
     */
    function _calculate(
        uint256 _winningRandomNumber,
        uint256 _totalUserPicks,
        bytes32 _userRandomNumber,
        uint64[] memory _picks,
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution
    ) internal pure returns (uint256 prize, uint256[] memory prizeCounts) {
        
        // create bitmasks for the PrizeDistribution
        uint256[] memory masks = _createBitMasks(_prizeDistribution);
        uint32 picksLength = uint32(_picks.length);
        uint256[] memory _prizeCounts = new uint256[](_prizeDistribution.tiers.length);

        uint8 maxWinningTierIndex = 0;

        require(
            picksLength <= _prizeDistribution.maxPicksPerUser,
            ""DrawCalc/exceeds-max-user-picks""
        );

        // for each pick, find number of matching numbers and calculate prize distributions index
        for (uint32 index = 0; index < picksLength; index++) {
            require(_picks[index] < _totalUserPicks, ""DrawCalc/insufficient-user-picks"");

            if (index > 0) {
                require(_picks[index] > _picks[index - 1], ""DrawCalc/picks-ascending"");
            }

            // hash the user random number with the pick value
            uint256 randomNumberThisPick = uint256(
                keccak256(abi.encode(_userRandomNumber, _picks[index]))
            );

            uint8 tiersIndex = _calculateTierIndex(
                randomNumberThisPick,
                _winningRandomNumber,
                masks
            );

            // there is prize for this tier index
            if (tiersIndex < TIERS_LENGTH) {
                if (tiersIndex > maxWinningTierIndex) {
                    maxWinningTierIndex = tiersIndex;
                }
                _prizeCounts[tiersIndex]++;
            }
        }

        // now calculate prizeFraction given prizeCounts
        uint256 prizeFraction = 0;
        uint256[] memory prizeTiersFractions = _calculatePrizeTierFractions(
            _prizeDistribution,
            maxWinningTierIndex
        );

        // multiple the fractions by the prizeCounts and add them up
        for (
            uint256 prizeCountIndex = 0;
            prizeCountIndex <= maxWinningTierIndex;
            prizeCountIndex++
        ) {
            if (_prizeCounts[prizeCountIndex] > 0) {
                prizeFraction +=
                    prizeTiersFractions[prizeCountIndex] *
                    _prizeCounts[prizeCountIndex];
            }
        }

        // return the absolute amount of prize awardable
        // div by 1e9 as prize tiers are base 1e9
        prize = (prizeFraction * _prizeDistribution.prize) / 1e9; 
        prizeCounts = _prizeCounts;
    }

    ///@notice Calculates the tier index given the random numbers and masks
    ///@param _randomNumberThisPick users random number for this Pick
    ///@param _winningRandomNumber The winning number for this draw
    ///@param _masks The pre-calculate bitmasks for the prizeDistributions
    ///@return The position within the prize tier array (0 = top prize, 1 = runner-up prize, etc)
    function _calculateTierIndex(
        uint256 _randomNumberThisPick,
        uint256 _winningRandomNumber,
        uint256[] memory _masks
    ) internal pure returns (uint8) {
        uint8 numberOfMatches = 0;
        uint8 masksLength = uint8(_masks.length);

        // main number matching loop
        for (uint8 matchIndex = 0; matchIndex < masksLength; matchIndex++) {
            uint256 mask = _masks[matchIndex];

            if ((_randomNumberThisPick & mask) != (_winningRandomNumber & mask)) {
                // there are no more sequential matches since this comparison is not a match
                if (masksLength == numberOfMatches) {
                    return 0;
                } else {
                    return masksLength - numberOfMatches;
                }
            }

            // else there was a match
            numberOfMatches++;
        }

        return masksLength - numberOfMatches;
    }

    /**
     * @notice Create an array of bitmasks equal to the PrizeDistribution.matchCardinality length
     * @param _prizeDistribution The PrizeDistribution to use to calculate the masks
     * @return An array of bitmasks
     */
    function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)
        internal
        pure
        returns (uint256[] memory)
    {
        uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);
        masks[0] =  (2**_prizeDistribution.bitRangeSize) - 1;

        for (uint8 maskIndex = 1; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {
            // shift mask bits to correct position and insert in result mask array
            masks[maskIndex] = masks[maskIndex - 1] << _prizeDistribution.bitRangeSize;
        }

        return masks;
    }

    /**
     * @notice Calculates the expected prize fraction per PrizeDistributions and distributionIndex
     * @param _prizeDistribution prizeDistribution struct for Draw
     * @param _prizeTierIndex Index of the prize tiers array to calculate
     * @return returns the fraction of the total prize (fixed point 9 number)
     */
    function _calculatePrizeTierFraction(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint256 _prizeTierIndex
    ) internal pure returns (uint256) {
         // get the prize fraction at that index
        uint256 prizeFraction = _prizeDistribution.tiers[_prizeTierIndex];

        // calculate number of prizes for that index
        uint256 numberOfPrizesForIndex = _numberOfPrizesForIndex(
            _prizeDistribution.bitRangeSize,
            _prizeTierIndex
        );

        return prizeFraction / numberOfPrizesForIndex;
    }

    /**
     * @notice Generates an array of prize tiers fractions
     * @param _prizeDistribution prizeDistribution struct for Draw
     * @param maxWinningTierIndex Max length of the prize tiers array
     * @return returns an array of prize tiers fractions
     */
    function _calculatePrizeTierFractions(
        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,
        uint8 maxWinningTierIndex
    ) internal pure returns (uint256[] memory) {
        uint256[] memory prizeDistributionFractions = new uint256[](
            maxWinningTierIndex + 1
        );

        for (uint8 i = 0; i <= maxWinningTierIndex; i++) {
            prizeDistributionFractions[i] = _calculatePrizeTierFraction(
                _prizeDistribution,
                i
            );
        }

        return prizeDistributionFractions;
    }

    /**
     * @notice Calculates the number of prizes for a given prizeDistributionIndex
     * @param _bitRangeSize Bit range size for Draw
     * @param _prizeTierIndex Index of the prize tier array to calculate
     * @return returns the fraction of the total prize (base 1e18)
     */
    function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)
        internal
        pure
        returns (uint256)
    {
        if (_prizeTierIndex > 0) {
            return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) );
        } else {
            return 1;
        }
    }
}",3851
RealWorld_TA_64_ExtendedSafeCastLibHarness_RealWorld_20240808185432.log,64,ExtendedSafeCastLibHarness,28870,1177,30047,69.0,0.16789,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/ExtendedSafeCastLib.sol"";

contract ExtendedSafeCastLibHarness {
    using ExtendedSafeCastLib for uint256;

    function toUint104(uint256 value) external pure returns (uint104) {
        return value.toUint104();
    }

    function toUint208(uint256 value) external pure returns (uint208) {
        return value.toUint208();
    }

    function toUint224(uint256 value) external pure returns (uint224) {
        return value.toUint224();
    }
}",126
RealWorld_TA_64_DrawRingBufferLibHarness_RealWorld_20240808185026.log,64,DrawRingBufferLibHarness,40710,2042,42752,78.0,0.24439,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/DrawRingBufferLib.sol"";

/**
 * @title  Expose the DrawRingBufferLib for unit tests
 * @author PoolTogether Inc.
 */
contract DrawRingBufferLibHarness {
    using DrawRingBufferLib for DrawRingBufferLib.Buffer;

    uint16 public constant MAX_CARDINALITY = 256;
    DrawRingBufferLib.Buffer internal bufferMetadata;

    constructor(uint8 _cardinality) {
        bufferMetadata.cardinality = _cardinality;
    }

    function _push(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (DrawRingBufferLib.Buffer memory)
    {
        return DrawRingBufferLib.push(_buffer, _drawId);
    }

    function _getIndex(DrawRingBufferLib.Buffer memory _buffer, uint32 _drawId)
        external
        pure
        returns (uint32)
    {
        return DrawRingBufferLib.getIndex(_buffer, _drawId);
    }

    function _isInitialized(DrawRingBufferLib.Buffer memory _buffer) external pure returns (bool) {
        return DrawRingBufferLib.isInitialized(_buffer);
    }
}",258
RealWorld_TA_64_TwabLibraryExposed_RealWorld_20240808183200.log,64,TwabLibraryExposed,80084,2589,82673,88.0,0.4522,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../libraries/TwabLib.sol"";
import ""../libraries/RingBufferLib.sol"";

/// @title TwabLibExposed contract to test TwabLib library
/// @author PoolTogether Inc.
contract TwabLibExposed {
    uint24 public constant MAX_CARDINALITY = 16777215;

    using TwabLib for ObservationLib.Observation[MAX_CARDINALITY];

    TwabLib.Account account;

    event Updated(
        TwabLib.AccountDetails accountDetails,
        ObservationLib.Observation twab,
        bool isNew
    );

    function details() external view returns (TwabLib.AccountDetails memory) {
        return account.details;
    }

    function twabs() external view returns (ObservationLib.Observation[] memory) {
        ObservationLib.Observation[] memory _twabs = new ObservationLib.Observation[](
            account.details.cardinality
        );

        for (uint256 i = 0; i < _twabs.length; i++) {
            _twabs[i] = account.twabs[i];
        }

        return _twabs;
    }

    function increaseBalance(uint256 _amount, uint32 _currentTime)
        external
        returns (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        (accountDetails, twab, isNew) = TwabLib.increaseBalance(account, uint208(_amount), _currentTime);
        account.details = accountDetails;
        emit Updated(accountDetails, twab, isNew);
    }

    function decreaseBalance(
        uint256 _amount,
        string memory _revertMessage,
        uint32 _currentTime
    )
        external
        returns (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        )
    {
        (accountDetails, twab, isNew) = TwabLib.decreaseBalance(
            account,
            uint208(_amount),
            _revertMessage,
            _currentTime
        );

        account.details = accountDetails;

        emit Updated(accountDetails, twab, isNew);
    }

    function getAverageBalanceBetween(
        uint32 _startTime,
        uint32 _endTime,
        uint32 _currentTime
    ) external view returns (uint256) {
        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                _startTime,
                _endTime,
                _currentTime
            );
    }

    function oldestTwab()
        external
        view
        returns (uint24 index, ObservationLib.Observation memory twab)
    {
        return TwabLib.oldestTwab(account.twabs, account.details);
    }

    function newestTwab()
        external
        view
        returns (uint24 index, ObservationLib.Observation memory twab)
    {
        return TwabLib.newestTwab(account.twabs, account.details);
    }

    function getBalanceAt(uint32 _target, uint32 _currentTime) external view returns (uint256) {
        return TwabLib.getBalanceAt(account.twabs, account.details, _target, _currentTime);
    }

    function push(TwabLib.AccountDetails memory _accountDetails) external pure returns (TwabLib.AccountDetails memory) {
        return TwabLib.push(_accountDetails);
    }
}",712
RealWorld_TA_64_DrawBeaconHarness_RealWorld_20240808183817.log,64,DrawBeaconHarness,43037,2896,45933,90.0,0.273105,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";

import ""../DrawBeacon.sol"";
import ""../interfaces/IDrawBuffer.sol"";

contract DrawBeaconHarness is DrawBeacon {
    constructor(
        address _owner,
        IDrawBuffer _drawBuffer,
        RNGInterface _rng,
        uint32 _nextDrawId,
        uint64 _beaconPeriodStart,
        uint32 _drawPeriodSeconds,
        uint32 _rngTimeout
    ) DrawBeacon(_owner, _drawBuffer, _rng, _nextDrawId, _beaconPeriodStart, _drawPeriodSeconds, _rngTimeout) {}

    uint64 internal time;

    function setCurrentTime(uint64 _time) external {
        time = _time;
    }

    function _currentTime() internal view override returns (uint64) {
        return time;
    }

    function currentTime() external view returns (uint64) {
        return _currentTime();
    }

    function _currentTimeInternal() external view returns (uint64) {
        return super._currentTime();
    }

    function setRngRequest(uint32 requestId, uint32 lockBlock) external {
        rngRequest.id = requestId;
        rngRequest.lockBlock = lockBlock;
    }
}",278
RealWorld_TA_64_PrizeSplitStrategy_RealWorld_20240808182224.log,64,PrizeSplitStrategy,71114,2351,73465,83.0,0.40259,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./PrizeSplit.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IPrizePool.sol"";

/**
  * @title  PoolTogether V4 PrizeSplitStrategy
  * @author PoolTogether Inc Team
  * @notice Captures PrizePool interest for PrizeReserve and additional PrizeSplit recipients.
            The PrizeSplitStrategy will have at minimum a single PrizeSplit with 100% of the captured
            interest transfered to the PrizeReserve. Additional PrizeSplits can be added, depending on
            the deployers requirements (i.e. percentage to charity). In contrast to previous PoolTogether
            iterations, interest can be captured independent of a new Draw. Ideally (to save gas) interest
            is only captured when also distributing the captured prize(s) to applicable Prize Distributor(s).
*/
contract PrizeSplitStrategy is PrizeSplit, IStrategy {
    /**
     * @notice PrizePool address
     */
    IPrizePool internal immutable prizePool;

    /**
     * @notice Deployed Event
     * @param owner Contract owner
     * @param prizePool Linked PrizePool contract
     */
    event Deployed(address indexed owner, IPrizePool prizePool);

    /* ============ Constructor ============ */

    /**
     * @notice Deploy the PrizeSplitStrategy smart contract.
     * @param _owner     Owner address
     * @param _prizePool PrizePool address
     */
    constructor(address _owner, IPrizePool _prizePool) Ownable(_owner) {
        require(
            address(_prizePool) != address(0),
            ""PrizeSplitStrategy/prize-pool-not-zero-address""
        );
        prizePool = _prizePool;
        emit Deployed(_owner, _prizePool);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IStrategy
    function distribute() external override returns (uint256) {
        uint256 prize = prizePool.captureAwardBalance();

        if (prize == 0) return 0;

        uint256 prizeRemaining = _distributePrizeSplits(prize);

        emit Distributed(prize - prizeRemaining);

        return prize;
    }

    /// @inheritdoc IPrizeSplit
    function getPrizePool() external view override returns (IPrizePool) {
        return prizePool;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Award ticket tokens to prize split recipient.
     * @dev Award ticket tokens to prize split recipient via the linked PrizePool contract.
     * @param _to Recipient of minted tokens.
     * @param _amount Amount of minted tokens.
     */
    function _awardPrizeSplitAmount(address _to, uint256 _amount) internal override {
        IControlledToken _ticket = prizePool.getTicket();
        prizePool.award(_to, _amount);
        emit PrizeSplitAwarded(_to, _amount, _ticket);
    }
}",637
RealWorld_TA_64_TwabRewards_RealWorld_20240808174626.log,64,TwabRewards,381647,4969,386616,150.0,2.007615,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";

/**
 * @title PoolTogether V4 TwabRewards
 * @author PoolTogether Inc Team
 * @notice Contract to distribute rewards to depositors in a pool.
 * This contract supports the creation of several promotions that can run simultaneously.
 * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.
 * This way, users simply need to hold their tickets to be eligible to claim rewards.
 * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.
 * @dev This contract supports only one prize pool ticket.
 * @dev This contract does not support the use of fee on transfer tokens.
 */
contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice Prize pool ticket for which the promotions are created.
    ITicket public immutable ticket;

    /// @notice Period during which the promotion owner can't destroy a promotion.
    uint32 public constant GRACE_PERIOD = 60 days;

    /// @notice Settings of each promotion.
    mapping(uint256 => Promotion) internal _promotions;

    /**
     * @notice Latest recorded promotion id.
     * @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.
     */
    uint256 internal _latestPromotionId;

    /**
     * @notice Keeps track of claimed rewards per user.
     * @dev _claimedEpochs[promotionId][user] => claimedEpochs
     * @dev We pack epochs claimed by a user into a uint256. So we can't store more than 256 epochs.
     */
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    /* ============ Events ============ */

    /**
     * @notice Emitted when a promotion is created.
     * @param promotionId Id of the newly created promotion
     */
    event PromotionCreated(uint256 indexed promotionId);

    /**
     * @notice Emitted when a promotion is ended.
     * @param promotionId Id of the promotion being ended
     * @param recipient Address of the recipient that will receive the remaining rewards
     * @param amount Amount of tokens transferred to the recipient
     * @param epochNumber Epoch number at which the promotion ended
     */
    event PromotionEnded(
        uint256 indexed promotionId,
        address indexed recipient,
        uint256 amount,
        uint8 epochNumber
    );

    /**
     * @notice Emitted when a promotion is destroyed.
     * @param promotionId Id of the promotion being destroyed
     * @param recipient Address of the recipient that will receive the unclaimed rewards
     * @param amount Amount of tokens transferred to the recipient
     */
    event PromotionDestroyed(
        uint256 indexed promotionId,
        address indexed recipient,
        uint256 amount
    );

    /**
     * @notice Emitted when a promotion is extended.
     * @param promotionId Id of the promotion being extended
     * @param numberOfEpochs Number of epochs the promotion has been extended by
     */
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    /**
     * @notice Emitted when rewards have been claimed.
     * @param promotionId Id of the promotion for which epoch rewards were claimed
     * @param epochIds Ids of the epochs being claimed
     * @param user Address of the user for which the rewards were claimed
     * @param amount Amount of tokens transferred to the recipient address
     */
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint8[] epochIds,
        address indexed user,
        uint256 amount
    );

    /* ============ Constructor ============ */

    /**
     * @notice Constructor of the contract.
     * @param _ticket Prize Pool ticket address for which the promotions will be created
     */
    constructor(ITicket _ticket) {
        _requireTicket(_ticket);
        ticket = _ticket;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc ITwabRewards
    function createPromotion(
        IERC20 _token,
        uint64 _startTimestamp,
        uint256 _tokensPerEpoch,
        uint48 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        require(_tokensPerEpoch > 0, ""TwabRewards/tokens-not-zero"");
        require(_epochDuration > 0, ""TwabRewards/duration-not-zero"");
        _requireNumberOfEpochs(_numberOfEpochs);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        uint256 _amount = _tokensPerEpoch * _numberOfEpochs;

        _promotions[_nextPromotionId] = Promotion({
            creator: msg.sender,
            startTimestamp: _startTimestamp,
            numberOfEpochs: _numberOfEpochs,
            epochDuration: _epochDuration,
            createdAt: uint48(block.timestamp),
            token: _token,
            tokensPerEpoch: _tokensPerEpoch,
            rewardsUnclaimed: _amount
        });

        uint256 _beforeBalance = _token.balanceOf(address(this));

        _token.safeTransferFrom(msg.sender, address(this), _amount);

        uint256 _afterBalance = _token.balanceOf(address(this));

        require(_beforeBalance + _amount == _afterBalance, ""TwabRewards/promo-amount-diff"");

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    /// @inheritdoc ITwabRewards
    function endPromotion(uint256 _promotionId, address _to) external override returns (bool) {
        require(_to != address(0), ""TwabRewards/payee-not-zero-addr"");

        Promotion memory _promotion = _getPromotion(_promotionId);
        _requirePromotionCreator(_promotion);
        _requirePromotionActive(_promotion);

        uint8 _epochNumber = uint8(_getCurrentEpochId(_promotion));
        _promotions[_promotionId].numberOfEpochs = _epochNumber;

        uint256 _remainingRewards = _getRemainingRewards(_promotion);
        _promotions[_promotionId].rewardsUnclaimed -= _remainingRewards;

        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionEnded(_promotionId, _to, _remainingRewards, _epochNumber);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function destroyPromotion(uint256 _promotionId, address _to) external override returns (bool) {
        require(_to != address(0), ""TwabRewards/payee-not-zero-addr"");

        Promotion memory _promotion = _getPromotion(_promotionId);
        _requirePromotionCreator(_promotion);

        uint256 _promotionEndTimestamp = _getPromotionEndTimestamp(_promotion);
        uint256 _promotionCreatedAt = _promotion.createdAt;

        uint256 _gracePeriodEndTimestamp = (
            _promotionEndTimestamp < _promotionCreatedAt
                ? _promotionCreatedAt
                : _promotionEndTimestamp
        ) + GRACE_PERIOD;

        require(block.timestamp >= _gracePeriodEndTimestamp, ""TwabRewards/grace-period-active"");

        uint256 _rewardsUnclaimed = _promotion.rewardsUnclaimed;
        delete _promotions[_promotionId];

        _promotion.token.safeTransfer(_to, _rewardsUnclaimed);

        emit PromotionDestroyed(_promotionId, _to, _rewardsUnclaimed);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        _requireNumberOfEpochs(_numberOfEpochs);

        Promotion memory _promotion = _getPromotion(_promotionId);
        _requirePromotionActive(_promotion);

        uint8 _currentNumberOfEpochs = _promotion.numberOfEpochs;

        require(
            _numberOfEpochs <= (type(uint8).max - _currentNumberOfEpochs),
            ""TwabRewards/epochs-over-limit""
        );

        _promotions[_promotionId].numberOfEpochs = _currentNumberOfEpochs + _numberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;

        _promotions[_promotionId].rewardsUnclaimed += _amount;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint8[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];
        uint256 _epochIdsLength = _epochIds.length;

        for (uint256 index = 0; index < _epochIdsLength; index++) {
            uint8 _epochId = _epochIds[index];

            require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), ""TwabRewards/rewards-claimed"");

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;
        _promotions[_promotionId].rewardsUnclaimed -= _rewardsAmount;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    /// @inheritdoc ITwabRewards
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    /// @inheritdoc ITwabRewards
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint8[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _epochIdsLength = _epochIds.length;
        uint256[] memory _rewardsAmount = new uint256[](_epochIdsLength);

        for (uint256 index = 0; index < _epochIdsLength; index++) {
            if (_isClaimedEpoch(_claimedEpochs[_promotionId][_user], _epochIds[index])) {
                _rewardsAmount[index] = 0;
            } else {
                _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
            }
        }

        return _rewardsAmount;
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Determine if address passed is actually a ticket.
     * @param _ticket Address to check
     */
    function _requireTicket(ITicket _ticket) internal view {
        require(address(_ticket) != address(0), ""TwabRewards/ticket-not-zero-addr"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(_ticket.controller.selector)
        );

        require(
            succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0,
            ""TwabRewards/invalid-ticket""
        );
    }

    /**
     * @notice Allow a promotion to be created or extended only by a positive number of epochs.
     * @param _numberOfEpochs Number of epochs to check
     */
    function _requireNumberOfEpochs(uint8 _numberOfEpochs) internal pure {
        require(_numberOfEpochs > 0, ""TwabRewards/epochs-not-zero"");
    }

    /**
     * @notice Determine if a promotion is active.
     * @param _promotion Promotion to check
     */
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        require(
            _getPromotionEndTimestamp(_promotion) > block.timestamp,
            ""TwabRewards/promotion-inactive""
        );
    }

    /**
     * @notice Determine if msg.sender is the promotion creator.
     * @param _promotion Promotion to check
     */
    function _requirePromotionCreator(Promotion memory _promotion) internal view {
        require(msg.sender == _promotion.creator, ""TwabRewards/only-promo-creator"");
    }

    /**
     * @notice Get settings for a specific promotion.
     * @dev Will revert if the promotion does not exist.
     * @param _promotionId Promotion id to get settings for
     * @return Promotion settings
     */
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        Promotion memory _promotion = _promotions[_promotionId];
        require(_promotion.creator != address(0), ""TwabRewards/invalid-promotion"");
        return _promotion;
    }

    /**
     * @notice Compute promotion end timestamp.
     * @param _promotion Promotion to compute end timestamp for
     * @return Promotion end timestamp
     */
    function _getPromotionEndTimestamp(Promotion memory _promotion)
        internal
        pure
        returns (uint256)
    {
        unchecked {
            return
                _promotion.startTimestamp + (_promotion.epochDuration * _promotion.numberOfEpochs);
        }
    }

    /**
     * @notice Get the current epoch id of a promotion.
     * @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
     * @dev We return the current epoch id if the promotion has not ended.
     * If the current timestamp is before the promotion start timestamp, we return 0.
     * Otherwise, we return the epoch id at the current timestamp. This could be greater than the number of epochs of the promotion.
     * @param _promotion Promotion to get current epoch for
     * @return Epoch id
     */
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        uint256 _currentEpochId;

        if (block.timestamp > _promotion.startTimestamp) {
            unchecked {
                _currentEpochId =
                    (block.timestamp - _promotion.startTimestamp) /
                    _promotion.epochDuration;
            }
        }

        return _currentEpochId;
    }

    /**
     * @notice Get reward amount for a specific user.
     * @dev Rewards can only be calculated once the epoch is over.
     * @dev Will revert if `_epochId` is over the total number of epochs or if epoch is not over.
     * @dev Will return 0 if the user average balance of tickets is 0.
     * @param _user User to get reward amount for
     * @param _promotion Promotion from which the epoch is
     * @param _epochId Epoch id to get reward amount for
     * @return Reward amount
     */
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint8 _epochId
    ) internal view returns (uint256) {
        uint64 _epochDuration = _promotion.epochDuration;
        uint64 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint64 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp >= _epochEndTimestamp, ""TwabRewards/epoch-not-over"");
        require(_epochId < _promotion.numberOfEpochs, ""TwabRewards/invalid-epoch-id"");

        uint256 _averageBalance = ticket.getAverageBalanceBetween(
            _user,
            _epochStartTimestamp,
            _epochEndTimestamp
        );

        if (_averageBalance > 0) {
            uint64[] memory _epochStartTimestamps = new uint64[](1);
            _epochStartTimestamps[0] = _epochStartTimestamp;

            uint64[] memory _epochEndTimestamps = new uint64[](1);
            _epochEndTimestamps[0] = _epochEndTimestamp;

            uint256 _averageTotalSupply = ticket.getAverageTotalSuppliesBetween(
                _epochStartTimestamps,
                _epochEndTimestamps
            )[0];

            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupply;
        }

        return 0;
    }

    /**
     * @notice Get the total amount of tokens left to be rewarded.
     * @param _promotion Promotion to get the total amount of tokens left to be rewarded for
     * @return Amount of tokens left to be rewarded
     */
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        if (block.timestamp > _getPromotionEndTimestamp(_promotion)) {
            return 0;
        }

        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }

    /**
    * @notice Set boolean value for a specific epoch.
    * @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0011
        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.
        We get: 0000 0001 << 2 = 0000 0100
        We then OR the mask with the word to set the value.
        We get: 0110 0011 | 0000 0100 = 0110 0111
    * @param _userClaimedEpochs Tightly packed epoch ids with their boolean values
    * @param _epochId Id of the epoch to set the boolean for
    * @return Tightly packed epoch ids with the newly boolean value set
    */
    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }

    /**
    * @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.
    * @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0111
        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.
        We get: 0110 0111 >> 2 = 0001 1001
        We then get the value of the last bit by masking with 1.
        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1
        We then return the boolean value true since the last bit is 1.
    * @param _userClaimedEpochs Record of epochs already claimed by the user
    * @param _epochId Epoch id to check
    * @return true if the rewards have already been claimed for the given epoch, false otherwise
     */
    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint8 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",4364
RealWorld_TA_64_PrizeSplit_RealWorld_20240808182349.log,64,PrizeSplit,133020,4516,137536,125.0,0.75542,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Ownable.sol"";

import ""../interfaces/IPrizeSplit.sol"";

/**
 * @title PrizeSplit Interface
 * @author PoolTogether Inc Team
 */
abstract contract PrizeSplit is IPrizeSplit, Ownable {
    /* ============ Global Variables ============ */
    PrizeSplitConfig[] internal _prizeSplits;

    uint16 public constant ONE_AS_FIXED_POINT_3 = 1000;

    /* ============ External Functions ============ */

    /// @inheritdoc IPrizeSplit
    function getPrizeSplit(uint256 _prizeSplitIndex)
        external
        view
        override
        returns (PrizeSplitConfig memory)
    {
        return _prizeSplits[_prizeSplitIndex];
    }

    /// @inheritdoc IPrizeSplit
    function getPrizeSplits() external view override returns (PrizeSplitConfig[] memory) {
        return _prizeSplits;
    }

    /// @inheritdoc IPrizeSplit
    function setPrizeSplits(PrizeSplitConfig[] calldata _newPrizeSplits)
        external
        override
        onlyOwner
    {
        uint256 newPrizeSplitsLength = _newPrizeSplits.length;
        require(newPrizeSplitsLength <= type(uint8).max, ""PrizeSplit/invalid-prizesplits-length"");

        // Add and/or update prize split configs using _newPrizeSplits PrizeSplitConfig structs array.
        for (uint256 index = 0; index < newPrizeSplitsLength; index++) {
            PrizeSplitConfig memory split = _newPrizeSplits[index];

            // REVERT when setting the canonical burn address.
            require(split.target != address(0), ""PrizeSplit/invalid-prizesplit-target"");

            // IF the CURRENT prizeSplits length is below the NEW prizeSplits
            // PUSH the PrizeSplit struct to end of the list.
            if (_prizeSplits.length <= index) {
                _prizeSplits.push(split);
            } else {
                // ELSE update an existing PrizeSplit struct with new parameters
                PrizeSplitConfig memory currentSplit = _prizeSplits[index];

                // IF new PrizeSplit DOES NOT match the current PrizeSplit
                // WRITE to STORAGE with the new PrizeSplit
                if (
                    split.target != currentSplit.target ||
                    split.percentage != currentSplit.percentage
                ) {
                    _prizeSplits[index] = split;
                } else {
                    continue;
                }
            }

            // Emit the added/updated prize split config.
            emit PrizeSplitSet(split.target, split.percentage, index);
        }

        // Remove old prize splits configs. Match storage _prizesSplits.length with the passed newPrizeSplits.length
        while (_prizeSplits.length > newPrizeSplitsLength) {
            uint256 _index;
            unchecked {
                _index = _prizeSplits.length - 1;
            }
            _prizeSplits.pop();
            emit PrizeSplitRemoved(_index);
        }

        // Total prize split do not exceed 100%
        uint256 totalPercentage = _totalPrizeSplitPercentageAmount();
        require(totalPercentage <= ONE_AS_FIXED_POINT_3, ""PrizeSplit/invalid-prizesplit-percentage-total"");
    }

    /// @inheritdoc IPrizeSplit
    function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)
        external
        override
        onlyOwner
    {
        require(_prizeSplitIndex < _prizeSplits.length, ""PrizeSplit/nonexistent-prizesplit"");
        require(_prizeSplit.target != address(0), ""PrizeSplit/invalid-prizesplit-target"");

        // Update the prize split config
        _prizeSplits[_prizeSplitIndex] = _prizeSplit;

        // Total prize split do not exceed 100%
        uint256 totalPercentage = _totalPrizeSplitPercentageAmount();
        require(totalPercentage <= ONE_AS_FIXED_POINT_3, ""PrizeSplit/invalid-prizesplit-percentage-total"");

        // Emit updated prize split config
        emit PrizeSplitSet(
            _prizeSplit.target,
            _prizeSplit.percentage,
            _prizeSplitIndex
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Calculates total prize split percentage amount.
     * @dev Calculates total PrizeSplitConfig percentage(s) amount. Used to check the total does not exceed 100% of award distribution.
     * @return Total prize split(s) percentage amount
     */
    function _totalPrizeSplitPercentageAmount() internal view returns (uint256) {
        uint256 _tempTotalPercentage;
        uint256 prizeSplitsLength = _prizeSplits.length;

        for (uint256 index = 0; index < prizeSplitsLength; index++) {
            _tempTotalPercentage += _prizeSplits[index].percentage;
        }

        return _tempTotalPercentage;
    }

    /**
     * @notice Distributes prize split(s).
     * @dev Distributes prize split(s) by awarding ticket or sponsorship tokens.
     * @param _prize Starting prize award amount
     * @return The remainder after splits are taken
     */
    function _distributePrizeSplits(uint256 _prize) internal returns (uint256) {
        uint256 _prizeTemp = _prize;
        uint256 prizeSplitsLength = _prizeSplits.length;

        for (uint256 index = 0; index < prizeSplitsLength; index++) {
            PrizeSplitConfig memory split = _prizeSplits[index];
            uint256 _splitAmount = (_prize * split.percentage) / 1000;

            // Award the prize split distribution amount.
            _awardPrizeSplitAmount(split.target, _splitAmount);

            // Update the remaining prize amount after distributing the prize split percentage.
            _prizeTemp -= _splitAmount;
        }

        return _prizeTemp;
    }

    /**
     * @notice Mints ticket or sponsorship tokens to prize split recipient.
     * @dev Mints ticket or sponsorship tokens to prize split recipient via the linked PrizePool contract.
     * @param _target Recipient of minted tokens
     * @param _amount Amount of minted tokens
     */
    function _awardPrizeSplitAmount(address _target, uint256 _amount) internal virtual;
}",1380
RealWorld_TA_64_IStrategy_RealWorld_20240808175546.log,64,IStrategy,36412,1270,37682,72.0,0.20746,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/v4-core/contracts/interfaces/IControlledToken.sol"";

interface IStrategy {
    /**
     * @notice Emit when a strategy captures award amount from PrizePool.
     * @param totalPrizeCaptured  Total prize captured from the PrizePool
     */
    event Distributed(uint256 totalPrizeCaptured);

    /**
     * @notice Emit when an individual prize split is awarded.
     * @param user          User address being awarded
     * @param prizeAwarded  Awarded prize amount
     * @param token         Token address
     */
    event PrizeSplitAwarded(
        address indexed user,
        uint256 prizeAwarded,
        IControlledToken indexed token
    );

    /**
     * @notice Capture the award balance and distribute to prize splits.
     * @dev    Permissionless function to initialize distribution of interst
     * @return Prize captured from PrizePool
     */
    function distribute() external returns (uint256);
}",222
RealWorld_TA_64_ObservationLibHarness_RealWorld_20240808185301.log,64,ObservationLibHarness,44034,3125,47159,89.0,0.28267,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/ObservationLib.sol"";

/// @title Time-Weighted Average Balance Library
/// @notice This library allows you to efficiently track a user's historic balance.  You can get a
/// @author PoolTogether Inc.
contract ObservationLibHarness {
    /// @notice The maximum number of twab entries
    uint24 public constant MAX_CARDINALITY = 16777215; // 2**24

    ObservationLib.Observation[MAX_CARDINALITY] observations;

    function setObservations(ObservationLib.Observation[] calldata _observations) external {
        for (uint256 i = 0; i < _observations.length; i++) {
            observations[i] = _observations[i];
        }
    }

    function binarySearch(
        uint24 _observationIndex,
        uint24 _oldestObservationIndex,
        uint32 _target,
        uint24 _cardinality,
        uint32 _time
    )
        external
        view
        returns (
            ObservationLib.Observation memory beforeOrAt,
            ObservationLib.Observation memory atOrAfter
        )
    {
        return
            ObservationLib.binarySearch(
                observations,
                _observationIndex,
                _oldestObservationIndex,
                _target,
                _cardinality,
                _time
            );
    }
}",293
RealWorld_TA_64_ICompLike_RealWorld_20240808190715.log,64,ICompLike,24042,1581,25623,73.0,0.15183,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface ICompLike is IERC20 {
    function getCurrentVotes(address account) external view returns (uint96);

    function delegate(address delegate) external;
}",69
RealWorld_TA_64_Reserve_RealWorld_20240808181843.log,64,Reserve,193787,3626,197413,120.0,1.041455,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/IReserve.sol"";
import ""./libraries/ObservationLib.sol"";
import ""./libraries/RingBufferLib.sol"";

/**
    * @title  PoolTogether V4 Reserve
    * @author PoolTogether Inc Team
    * @notice The Reserve contract provides historical lookups of a token balance increase during a target timerange.
              As the Reserve contract transfers OUT tokens, the withdraw accumulator is increased. When tokens are
              transfered IN new checkpoint *can* be created if checkpoint() is called after transfering tokens.
              By using the reserve and withdraw accumulators to create a new checkpoint, any contract or account
              can lookup the balance increase of the reserve for a target timerange.   
    * @dev    By calculating the total held tokens in a specific time range, contracts that require knowledge 
              of captured interest during a draw period, can easily call into the Reserve and deterministically
              determine the newly aqcuired tokens for that time range. 
 */
contract Reserve is IReserve, Manageable {
    using SafeERC20 for IERC20;

    /// @notice ERC20 token
    IERC20 public immutable token;

    /// @notice Total withdraw amount from reserve
    uint224 public withdrawAccumulator;
    uint32 private _gap;

    uint24 internal nextIndex;
    uint24 internal cardinality;

    /// @notice The maximum number of twab entries
    uint24 internal constant MAX_CARDINALITY = 16777215; // 2**24 - 1

    ObservationLib.Observation[MAX_CARDINALITY] internal reserveAccumulators;

    /* ============ Events ============ */

    event Deployed(IERC20 indexed token);

    /* ============ Constructor ============ */

    /**
     * @notice Constructs Ticket with passed parameters.
     * @param _owner Owner address
     * @param _token ERC20 address
     */
    constructor(address _owner, IERC20 _token) Ownable(_owner) {
        token = _token;
        emit Deployed(_token);
    }

    /* ============ External Functions ============ */

    /// @inheritdoc IReserve
    function checkpoint() external override {
        _checkpoint();
    }

    /// @inheritdoc IReserve
    function getToken() external view override returns (IERC20) {
        return token;
    }

    /// @inheritdoc IReserve
    function getReserveAccumulatedBetween(uint32 _startTimestamp, uint32 _endTimestamp)
        external
        view
        override
        returns (uint224)
    {
        require(_startTimestamp < _endTimestamp, ""Reserve/start-less-then-end"");
        uint24 _cardinality = cardinality;
        uint24 _nextIndex = nextIndex;

        (uint24 _newestIndex, ObservationLib.Observation memory _newestObservation) = _getNewestObservation(_nextIndex);
        (uint24 _oldestIndex, ObservationLib.Observation memory _oldestObservation) = _getOldestObservation(_nextIndex);

        uint224 _start = _getReserveAccumulatedAt(
            _newestObservation,
            _oldestObservation,
            _newestIndex,
            _oldestIndex,
            _cardinality,
            _startTimestamp
        );

        uint224 _end = _getReserveAccumulatedAt(
            _newestObservation,
            _oldestObservation,
            _newestIndex,
            _oldestIndex,
            _cardinality,
            _endTimestamp
        );

        return _end - _start;
    }

    /// @inheritdoc IReserve
    function withdrawTo(address _recipient, uint256 _amount) external override onlyManagerOrOwner {
        _checkpoint();

        withdrawAccumulator += uint224(_amount);
        
        token.safeTransfer(_recipient, _amount);

        emit Withdrawn(_recipient, _amount);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Find optimal observation checkpoint using target timestamp
     * @dev    Uses binary search if target timestamp is within ring buffer range.
     * @param _newestObservation ObservationLib.Observation
     * @param _oldestObservation ObservationLib.Observation
     * @param _newestIndex The index of the newest observation
     * @param _oldestIndex The index of the oldest observation
     * @param _cardinality       RingBuffer Range
     * @param _timestamp          Timestamp target
     *
     * @return Optimal reserveAccumlator for timestamp.
     */
    function _getReserveAccumulatedAt(
        ObservationLib.Observation memory _newestObservation,
        ObservationLib.Observation memory _oldestObservation,
        uint24 _newestIndex,
        uint24 _oldestIndex,
        uint24 _cardinality,
        uint32 _timestamp
    ) internal view returns (uint224) {
        uint32 timeNow = uint32(block.timestamp);

        // IF empty ring buffer exit early.
        if (_cardinality == 0) return 0;

        /**
         * Ring Buffer Search Optimization
         * Before performing binary search on the ring buffer check
         * to see if timestamp is within range of [o T n] by comparing
         * the target timestamp to the oldest/newest observation.timestamps
         * IF the timestamp is out of the ring buffer range avoid starting
         * a binary search, because we can return NULL or oldestObservation.amount
         */

        /**
         * IF oldestObservation.timestamp is after timestamp: T[old ]
         * the Reserve did NOT have a balance or the ring buffer
         * no longer contains that timestamp checkpoint.
         */
        if (_oldestObservation.timestamp > _timestamp) {
            return 0;
        }

        /**
         * IF newestObservation.timestamp is before timestamp: [ new]T
         * return _newestObservation.amount since observation
         * contains the highest checkpointed reserveAccumulator.
         */
        if (_newestObservation.timestamp <= _timestamp) {
            return _newestObservation.amount;
        }

        // IF the timestamp is witin range of ring buffer start/end: [new T old]
        // FIND the closest observation to the left(or exact) of timestamp: [OT ]
        (
            ObservationLib.Observation memory beforeOrAt,
            ObservationLib.Observation memory atOrAfter
        ) = ObservationLib.binarySearch(
                reserveAccumulators,
                _newestIndex,
                _oldestIndex,
                _timestamp,
                _cardinality,
                timeNow
            );

        // IF target timestamp is EXACT match for atOrAfter.timestamp observation return amount.
        // NOT having an exact match with atOrAfter means values will contain accumulator value AFTER the searchable range.
        // ELSE return observation.totalDepositedAccumulator closest to LEFT of target timestamp.
        if (atOrAfter.timestamp == _timestamp) {
            return atOrAfter.amount;
        } else {
            return beforeOrAt.amount;
        }
    }

    /// @notice Records the currently accrued reserve amount.
    function _checkpoint() internal {
        uint24 _cardinality = cardinality;
        uint24 _nextIndex = nextIndex;
        uint256 _balanceOfReserve = token.balanceOf(address(this));
        uint224 _withdrawAccumulator = withdrawAccumulator; //sload
        (uint24 newestIndex, ObservationLib.Observation memory newestObservation) = _getNewestObservation(_nextIndex);

        /**
         * IF tokens have been deposited into Reserve contract since the last checkpoint
         * create a new Reserve balance checkpoint. The will will update multiple times in a single block.
         */
        if (_balanceOfReserve + _withdrawAccumulator > newestObservation.amount) {
            uint32 nowTime = uint32(block.timestamp);

            // checkpointAccumulator = currentBalance + totalWithdraws
            uint224 newReserveAccumulator = uint224(_balanceOfReserve) + _withdrawAccumulator;

            // IF newestObservation IS NOT in the current block.
            // CREATE observation in the accumulators ring buffer.
            if (newestObservation.timestamp != nowTime) {
                reserveAccumulators[_nextIndex] = ObservationLib.Observation({
                    amount: newReserveAccumulator,
                    timestamp: nowTime
                });
                nextIndex = uint24(RingBufferLib.nextIndex(_nextIndex, MAX_CARDINALITY));
                if (_cardinality < MAX_CARDINALITY) {
                    cardinality = _cardinality + 1;
                }
            }
            // ELSE IF newestObservation IS in the current block.
            // UPDATE the checkpoint previously created in block history.
            else {
                reserveAccumulators[newestIndex] = ObservationLib.Observation({
                    amount: newReserveAccumulator,
                    timestamp: nowTime
                });
            }

            emit Checkpoint(newReserveAccumulator, _withdrawAccumulator);
        }
    }

    /// @notice Retrieves the oldest observation
    /// @param _nextIndex The next index of the Reserve observations
    function _getOldestObservation(uint24 _nextIndex)
        internal
        view
        returns (uint24 index, ObservationLib.Observation memory observation)
    {
        index = _nextIndex;
        observation = reserveAccumulators[index];

        // If the TWAB is not initialized we go to the beginning of the TWAB circular buffer at index 0
        if (observation.timestamp == 0) {
            index = 0;
            observation = reserveAccumulators[0];
        }
    }

    /// @notice Retrieves the newest observation
    /// @param _nextIndex The next index of the Reserve observations
    function _getNewestObservation(uint24 _nextIndex)
        internal
        view
        returns (uint24 index, ObservationLib.Observation memory observation)
    {
        index = uint24(RingBufferLib.newestIndex(_nextIndex, MAX_CARDINALITY));
        observation = reserveAccumulators[index];
    }
}",2181
RealWorld_TA_64_ReserveHarness_RealWorld_20240808183949.log,64,ReserveHarness,35872,5413,41285,113.0,0.28762,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../Reserve.sol"";
import ""./ERC20Mintable.sol"";

contract ReserveHarness is Reserve {
    constructor(address _owner, IERC20 _token) Reserve(_owner, _token) {}

    function setObservationsAt(ObservationLib.Observation[] calldata observations) external {
        for (uint256 i = 0; i < observations.length; i++) {
            reserveAccumulators[i] = observations[i];
        }

        nextIndex = uint24(observations.length);
        cardinality = uint24(observations.length);
    }

    function doubleCheckpoint(ERC20Mintable _token, uint256 _amount) external {
        _checkpoint();
        _token.mint(address(this), _amount);
        _checkpoint();
    }
}",176
RealWorld_TA_64_PrizeTierHistory_RealWorld_20240808173148.log,64,PrizeTierHistory,143963,3090,147053,107.0,0.781615,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;
import ""@pooltogether/owner-manager-contracts/contracts/Manageable.sol"";
import ""./interfaces/IPrizeTierHistory.sol"";
import ""./libraries/BinarySearchLib.sol"";

/**
 * @title  PoolTogether V4 PrizeTierHistory
 * @author PoolTogether Inc Team
 * @notice The PrizeTierHistory smart contract stores a history of PrizeTier structs linked to
           a range of valid Draw IDs.
 * @dev    If the history param has single PrizeTier struct with a ""drawId"" of 1 all subsequent
           Draws will use that PrizeTier struct for PrizeDitribution calculations. The BinarySearchLib
           will find a PrizeTier using a ""atOrBefore"" range search when supplied drawId input parameter.
 */
contract PrizeTierHistory is IPrizeTierHistory, Manageable {
    // @dev The uint32[] type is extended with a binarySearch(uint32) function.
    using BinarySearchLib for uint32[];

    /**
     * @notice Ordered array of Draw IDs
     * @dev The history, with sequentially ordered ids, can be searched using binary search.
            The binary search will find index of a drawId (atOrBefore) using a specific drawId (at).
            When a new Draw ID is added to the history, a corresponding mapping of the ID is
            updated in the prizeTiers mapping.
    */
    uint32[] internal history;

    /**
     * @notice Mapping a Draw ID to a PrizeTier struct.
     * @dev The prizeTiers mapping links a Draw ID to a PrizeTier struct.
            The prizeTiers mapping is updated when a new Draw ID is added to the history.
    */
    mapping(uint32 => PrizeTier) internal prizeTiers;

    /**
     * @notice Ceiling for the total sum of tiers from the prize distribution. 1e9 = 100%.
     * @dev It's fixed point 9 because 1e9 is the largest ""1"" that fits into 2**32
     */
    uint256 internal constant TIERS_CEILING = 1e9;

    constructor(address owner) Ownable(owner) {}

    // @inheritdoc IPrizeTierHistory
    function count() external view override returns (uint256) {
        return history.length;
    }

    // @inheritdoc IPrizeTierHistory
    function getOldestDrawId() external view override returns (uint32) {
        return history[0];
    }

    // @inheritdoc IPrizeTierHistory
    function getNewestDrawId() external view override returns (uint32) {
        return history[history.length - 1];
    }

    // @inheritdoc IPrizeTierHistory
    function getPrizeTier(uint32 drawId) external view override returns (PrizeTier memory) {
        require(drawId > 0, ""PrizeTierHistory/draw-id-not-zero"");
        return prizeTiers[history.binarySearch(drawId)];
    }

    // @inheritdoc IPrizeTierHistory
    function getPrizeTierList(uint32[] calldata _drawIds)
        external
        view
        override
        returns (PrizeTier[] memory)
    {
        uint256 _length = _drawIds.length;
        PrizeTier[] memory _data = new PrizeTier[](_length);
        for (uint256 index = 0; index < _length; index++) {
            _data[index] = prizeTiers[history.binarySearch(_drawIds[index])];
        }
        return _data;
    }

    // @inheritdoc IPrizeTierHistory
    function getPrizeTierAtIndex(uint256 index) external view override returns (PrizeTier memory) {
        return prizeTiers[uint32(index)];
    }

    // @inheritdoc IPrizeTierHistory
    function push(PrizeTier calldata nextPrizeTier) external override onlyManagerOrOwner {
        _push(nextPrizeTier);
    }

    // @inheritdoc IPrizeTierHistory
    function popAndPush(PrizeTier calldata newPrizeTier)
        external
        override
        onlyOwner
        returns (uint32)
    {
        uint256 length = history.length;
        require(length > 0, ""PrizeTierHistory/history-empty"");
        require(history[length - 1] == newPrizeTier.drawId, ""PrizeTierHistory/invalid-draw-id"");
        _replace(newPrizeTier);
        return newPrizeTier.drawId;
    }

    // @inheritdoc IPrizeTierHistory
    function replace(PrizeTier calldata newPrizeTier) external override onlyOwner {
        _replace(newPrizeTier);
    }

    /**
     * @notice Check that the total sum of the tiers is not greater than 1e9 (100%).
     * @param  _tiers Array of tiers to check
     */
    function _checkTiersTotalSum(uint32[16] memory _tiers) internal pure {
        uint256 tiersTotalSum;
        uint256 tiersLength = _tiers.length;

        for (uint256 index; index < tiersLength; index++) {
            tiersTotalSum += _tiers[index];
        }

        require(tiersTotalSum <= TIERS_CEILING, ""PrizeTierHistory/tiers-gt-100%"");
    }

    /**
     * @notice Push PrizeTier struct onto `prizeTiers` array.
     * @dev Callable only by the owner or manager.
     * @dev `drawId` must be greater than the latest one stored in `history`.
     * @param _prizeTier Next PrizeTier struct
     */
    function _push(PrizeTier memory _prizeTier) internal {
        uint32 _length = uint32(history.length);

        if (_length > 0) {
            uint32 _id = history[_length - 1];
            require(_prizeTier.drawId > _id, ""PrizeTierHistory/non-sequential-id"");
        }

        _checkTiersTotalSum(_prizeTier.tiers);

        history.push(_prizeTier.drawId);
        prizeTiers[_length] = _prizeTier;

        emit PrizeTierPushed(_prizeTier.drawId, _prizeTier);
    }

    /**
     * @notice Replace PrizeTier struct in `prizeTiers` array.
     * @dev Callable only by the owner.
     * @param _prizeTier PrizeTier parameters
     */
    function _replace(PrizeTier calldata _prizeTier) internal {
        uint256 cardinality = history.length;
        require(cardinality > 0, ""PrizeTierHistory/no-prize-tiers"");

        uint32 oldestDrawId = history[0];
        require(_prizeTier.drawId >= oldestDrawId, ""PrizeTierHistory/draw-id-out-of-range"");

        uint32 index = history.binarySearch(_prizeTier.drawId);
        require(history[index] == _prizeTier.drawId, ""PrizeTierHistory/draw-id-must-match"");

        _checkTiersTotalSum(_prizeTier.tiers);

        prizeTiers[index] = _prizeTier;

        emit PrizeTierSet(_prizeTier.drawId, _prizeTier);
    }
}",1525
RealWorld_TA_64_IControlledToken_RealWorld_20240808193146.log,64,IControlledToken,48845,1910,50755,95.0,0.282425,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/** @title IControlledToken
  * @author PoolTogether Inc Team
  * @notice ERC20 Tokens with a controller for minting & burning.
*/
interface IControlledToken is IERC20 {

    /** 
        @notice Interface to the contract responsible for controlling mint/burn
    */
    function controller() external view returns (address);

    /** 
      * @notice Allows the controller to mint tokens for a user account
      * @dev May be overridden to provide more granular control over minting
      * @param user Address of the receiver of the minted tokens
      * @param amount Amount of tokens to mint
    */
    function controllerMint(address user, uint256 amount) external;

    /** 
      * @notice Allows the controller to burn tokens from a user account
      * @dev May be overridden to provide more granular control over burning
      * @param user Address of the holder account to burn tokens from
      * @param amount Amount of tokens to burn
    */
    function controllerBurn(address user, uint256 amount) external;

    /** 
      * @notice Allows an operator via the controller to burn tokens on behalf of a user account
      * @dev May be overridden to provide more granular control over operator-burning
      * @param operator Address of the operator performing the burn action via the controller contract
      * @param user Address of the holder account to burn tokens from
      * @param amount Amount of tokens to burn
    */
    function controllerBurnFrom(
        address operator,
        address user,
        uint256 amount
    ) external;
}",373
RealWorld_TA_64_RNGServiceMock_RealWorld_20240808183651.log,64,RNGServiceMock,42984,2671,45655,84.0,0.26834,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";

contract RNGServiceMock is RNGInterface {
    uint256 internal random;
    address internal feeToken;
    uint256 internal requestFee;

    function getLastRequestId() external pure override returns (uint32 requestId) {
        return 1;
    }

    function setRequestFee(address _feeToken, uint256 _requestFee) external {
        feeToken = _feeToken;
        requestFee = _requestFee;
    }

    /// @return _feeToken
    /// @return _requestFee
    function getRequestFee()
        external
        view
        override
        returns (address _feeToken, uint256 _requestFee)
    {
        return (feeToken, requestFee);
    }

    function setRandomNumber(uint256 _random) external {
        random = _random;
    }

    function requestRandomNumber() external pure override returns (uint32, uint32) {
        return (1, 1);
    }

    function isRequestComplete(uint32) external pure override returns (bool) {
        return true;
    }

    function randomNumber(uint32) external view override returns (uint256) {
        return random;
    }
}",274
RealWorld_TA_64_PrizeSplitHarness_RealWorld_20240808183330.log,64,PrizeSplitHarness,31721,2332,34053,82.0,0.205245,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../prize-strategy/PrizeSplit.sol"";
import ""../interfaces/IControlledToken.sol"";

contract PrizeSplitHarness is PrizeSplit {
    constructor(address _owner) Ownable(_owner) {}

    function _awardPrizeSplitAmount(address target, uint256 amount) internal override {
        emit PrizeSplitAwarded(target, amount, IControlledToken(address(0)));
    }

    function awardPrizeSplitAmount(address target, uint256 amount) external {
        return _awardPrizeSplitAmount(target, amount);
    }

    function getPrizePool() external pure override returns (IPrizePool) {
        return IPrizePool(address(0));
    }
}",160
RealWorld_TA_64_IMessageExecutor_RealWorld_20240808180203.log,64,IMessageExecutor,60784,1751,62535,76.0,0.33894,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""./ISingleMessageDispatcher.sol"";

/**
 * @title MessageExecutor interface
 * @notice MessageExecutor interface of the ERC-5164 standard as defined in the EIP.
 */
interface IMessageExecutor {
    /**
     * @notice Message data structure
     * @param to Address that will be dispatched on the receiving chain
     * @param data Data that will be sent to the `to` address
     */
    struct Message {
        address to;
        bytes data;
    }

    /**
     * @notice Emitted when a message has successfully been executed.
     * @param fromChainId ID of the chain that dispatched the message
     * @param messageId ID uniquely identifying the message that was executed
     */
    event MessageIdExecuted(uint256 indexed fromChainId, bytes32 indexed messageId);

    /**
     * @notice Execute message from the origin chain.
     * @dev Should authenticate that the call has been performed by the bridge transport layer.
     * @dev Must revert if the message fails.
     * @dev Must emit the `ExecutedMessage` event once the message has been executed.
     * @param to Address that will receive `data`
     * @param data Data forwarded to address `to`
     * @param messageId ID uniquely identifying the message
     * @param fromChainId ID of the chain that dispatched the message
     * @param from Address of the sender on the origin chain
     */
    function executeMessage(
        address to,
        bytes calldata data,
        bytes32 messageId,
        uint256 fromChainId,
        address from
    ) external;

    /**
     * @notice Execute a batch messages from the origin chain.
     * @dev Should authenticate that the call has been performed by the bridge transport layer.
     * @dev Must revert if one of the messages fails.
     * @dev Must emit the `ExecutedMessageBatch` event once messages have been executed.
     * @param messages Array of messages being executed
     * @param messageId ID uniquely identifying the messages
     * @param fromChainId ID of the chain that dispatched the messages
     * @param from Address of the sender on the origin chain
     */
    function executeMessageBatch(
        Message[] calldata messages,
        bytes32 messageId,
        uint256 fromChainId,
        address from
    ) external;
}",503
RealWorld_TA_64_YieldSourcePrizePool_RealWorld_20240808190830.log,64,YieldSourcePrizePool,98951,3401,102352,96.0,0.562775,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./PrizePool.sol"";

/**
 * @title  PoolTogether V4 YieldSourcePrizePool
 * @author PoolTogether Inc Team
 * @notice The Yield Source Prize Pool uses a yield source contract to generate prizes.
 *         Funds that are deposited into the prize pool are then deposited into a yield source. (i.e. Aave, Compound, etc...)
 */
contract YieldSourcePrizePool is PrizePool {
    using SafeERC20 for IERC20;
    using Address for address;

    /// @notice Address of the yield source.
    IYieldSource public immutable yieldSource;

    /// @dev Emitted when yield source prize pool is deployed.
    /// @param yieldSource Address of the yield source.
    event Deployed(address indexed yieldSource);

    /// @notice Emitted when stray deposit token balance in this contract is swept
    /// @param amount The amount that was swept
    event Swept(uint256 amount);

    /// @notice Deploy the Prize Pool and Yield Service with the required contract connections
    /// @param _owner Address of the Yield Source Prize Pool owner
    /// @param _yieldSource Address of the yield source
    constructor(address _owner, IYieldSource _yieldSource) PrizePool(_owner) {
        require(
            address(_yieldSource) != address(0),
            ""YieldSourcePrizePool/yield-source-not-zero-address""
        );

        yieldSource = _yieldSource;

        // A hack to determine whether it's an actual yield source
        (bool succeeded, bytes memory data) = address(_yieldSource).staticcall(
            abi.encodePacked(_yieldSource.depositToken.selector)
        );
        address resultingAddress;
        if (data.length > 0) {
            resultingAddress = abi.decode(data, (address));
        }
        require(succeeded && resultingAddress != address(0), ""YieldSourcePrizePool/invalid-yield-source"");

        emit Deployed(address(_yieldSource));
    }

    /// @notice Sweeps any stray balance of deposit tokens into the yield source.
    /// @dev This becomes prize money
    function sweep() external nonReentrant onlyOwner {
        uint256 balance = _token().balanceOf(address(this));
        _supply(balance);

        emit Swept(balance);
    }

    /// @notice Determines whether the passed token can be transferred out as an external award.
    /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
    /// prize strategy should not be allowed to move those tokens.
    /// @param _externalToken The address of the token to check
    /// @return True if the token may be awarded, false otherwise
    function _canAwardExternal(address _externalToken) internal view override returns (bool) {
        IYieldSource _yieldSource = yieldSource;
        return (
            _externalToken != address(_yieldSource) &&
            _externalToken != _yieldSource.depositToken()
        );
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function _balance() internal override returns (uint256) {
        return yieldSource.balanceOfToken(address(this));
    }

    /// @notice Returns the address of the ERC20 asset token used for deposits.
    /// @return Address of the ERC20 asset token.
    function _token() internal view override returns (IERC20) {
        return IERC20(yieldSource.depositToken());
    }

    /// @notice Supplies asset tokens to the yield source.
    /// @param _mintAmount The amount of asset tokens to be supplied
    function _supply(uint256 _mintAmount) internal override {
        _token().safeIncreaseAllowance(address(yieldSource), _mintAmount);
        yieldSource.supplyTokenTo(_mintAmount, address(this));
    }

    /// @notice Redeems asset tokens from the yield source.
    /// @param _redeemAmount The amount of yield-bearing tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed.
    function _redeem(uint256 _redeemAmount) internal override returns (uint256) {
        return yieldSource.redeemToken(_redeemAmount);
    }
}",974
RealWorld_TA_64_IDrawBuffer_RealWorld_20240808191900.log,64,IDrawBuffer,76367,1504,77871,400.0,0.411915,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../interfaces/IDrawBeacon.sol"";

/** @title  IDrawBuffer
  * @author PoolTogether Inc Team
  * @notice The DrawBuffer interface.
*/
interface IDrawBuffer {
    /**
     * @notice Emit when a new draw has been created.
     * @param drawId Draw id
     * @param draw The Draw struct
     */
    event DrawSet(uint32 indexed drawId, IDrawBeacon.Draw draw);

    /**
     * @notice Read a ring buffer cardinality
     * @return Ring buffer cardinality
     */
    function getBufferCardinality() external view returns (uint32);

    /**
     * @notice Read a Draw from the draws ring buffer.
     * @dev    Read a Draw using the Draw.drawId to calculate position in the draws ring buffer.
     * @param drawId Draw.drawId
     * @return IDrawBeacon.Draw
     */
    function getDraw(uint32 drawId) external view returns (IDrawBeacon.Draw memory);

    /**
     * @notice Read multiple Draws from the draws ring buffer.
     * @dev    Read multiple Draws using each drawId to calculate position in the draws ring buffer.
     * @param drawIds Array of drawIds
     * @return IDrawBeacon.Draw[]
     */
    function getDraws(uint32[] calldata drawIds) external view returns (IDrawBeacon.Draw[] memory);

    /**
     * @notice Gets the number of Draws held in the draw ring buffer.
     * @dev If no Draws have been pushed, it will return 0.
     * @dev If the ring buffer is full, it will return the cardinality.
     * @dev Otherwise, it will return the NewestDraw index + 1.
     * @return Number of Draws held in the draw ring buffer.
     */
    function getDrawCount() external view returns (uint32);

    /**
     * @notice Read newest Draw from draws ring buffer.
     * @dev    Uses the nextDrawIndex to calculate the most recently added Draw.
     * @return IDrawBeacon.Draw
     */
    function getNewestDraw() external view returns (IDrawBeacon.Draw memory);

    /**
     * @notice Read oldest Draw from draws ring buffer.
     * @dev    Finds the oldest Draw by comparing and/or diffing totalDraws with the cardinality.
     * @return IDrawBeacon.Draw
     */
    function getOldestDraw() external view returns (IDrawBeacon.Draw memory);

    /**
     * @notice Push Draw onto draws ring buffer history.
     * @dev    Push new draw onto draws history via authorized manager or owner.
     * @param draw IDrawBeacon.Draw
     * @return Draw.drawId
     */
    function pushDraw(IDrawBeacon.Draw calldata draw) external returns (uint32);

    /**
     * @notice Set existing Draw in draws ring buffer with new parameters.
     * @dev    Updating a Draw should be used sparingly and only in the event an incorrect Draw parameter has been stored.
     * @param newDraw IDrawBeacon.Draw
     * @return Draw.drawId
     */
    function setDraw(IDrawBeacon.Draw calldata newDraw) external returns (uint32);
}",700
RealWorld_TA_64_Ticket_RealWorld_20240808181016.log,64,Ticket,271188,3334,274522,127.0,1.42262,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./libraries/ExtendedSafeCastLib.sol"";
import ""./libraries/TwabLib.sol"";
import ""./interfaces/ITicket.sol"";
import ""./ControlledToken.sol"";

/**
  * @title  PoolTogether V4 Ticket
  * @author PoolTogether Inc Team
  * @notice The Ticket extends the standard ERC20 and ControlledToken interfaces with time-weighted average balance functionality.
            The average balance held by a user between two timestamps can be calculated, as well as the historic balance.  The
            historic total supply is available as well as the average total supply between two timestamps.

            A user may ""delegate"" their balance; increasing another user's historic balance while retaining their tokens.
*/
contract Ticket is ControlledToken, ITicket {
    using SafeERC20 for IERC20;
    using ExtendedSafeCastLib for uint256;

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _DELEGATE_TYPEHASH =
        keccak256(""Delegate(address user,address delegate,uint256 nonce,uint256 deadline)"");

    /// @notice Record of token holders TWABs for each account.
    mapping(address => TwabLib.Account) internal userTwabs;

    /// @notice Record of tickets total supply and ring buff parameters used for observation.
    TwabLib.Account internal totalSupplyTwab;

    /// @notice Mapping of delegates.  Each address can delegate their ticket power to another.
    mapping(address => address) internal delegates;

    /* ============ Constructor ============ */

    /**
     * @notice Constructs Ticket with passed parameters.
     * @param _name ERC20 ticket token name.
     * @param _symbol ERC20 ticket token symbol.
     * @param decimals_ ERC20 ticket token decimals.
     * @param _controller ERC20 ticket controller address (ie: Prize Pool address).
     */
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_,
        address _controller
    ) ControlledToken(_name, _symbol, decimals_, _controller) {}

    /* ============ External Functions ============ */

    /// @inheritdoc ITicket
    function getAccountDetails(address _user)
        external
        view
        override
        returns (TwabLib.AccountDetails memory)
    {
        return userTwabs[_user].details;
    }

    /// @inheritdoc ITicket
    function getTwab(address _user, uint16 _index)
        external
        view
        override
        returns (ObservationLib.Observation memory)
    {
        return userTwabs[_user].twabs[_index];
    }

    /// @inheritdoc ITicket
    function getBalanceAt(address _user, uint64 _target) external view override returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getBalanceAt(
                account.twabs,
                account.details,
                uint32(_target),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getAverageBalancesBetween(
        address _user,
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) external view override returns (uint256[] memory) {
        return _getAverageBalancesBetween(userTwabs[_user], _startTimes, _endTimes);
    }

    /// @inheritdoc ITicket
    function getAverageTotalSuppliesBetween(
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) external view override returns (uint256[] memory) {
        return _getAverageBalancesBetween(totalSupplyTwab, _startTimes, _endTimes);
    }

    /// @inheritdoc ITicket
    function getAverageBalanceBetween(
        address _user,
        uint64 _startTime,
        uint64 _endTime
    ) external view override returns (uint256) {
        TwabLib.Account storage account = userTwabs[_user];

        return
            TwabLib.getAverageBalanceBetween(
                account.twabs,
                account.details,
                uint32(_startTime),
                uint32(_endTime),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getBalancesAt(address _user, uint64[] calldata _targets)
        external
        view
        override
        returns (uint256[] memory)
    {
        uint256 length = _targets.length;
        uint256[] memory _balances = new uint256[](length);

        TwabLib.Account storage twabContext = userTwabs[_user];
        TwabLib.AccountDetails memory details = twabContext.details;

        for (uint256 i = 0; i < length; i++) {
            _balances[i] = TwabLib.getBalanceAt(
                twabContext.twabs,
                details,
                uint32(_targets[i]),
                uint32(block.timestamp)
            );
        }

        return _balances;
    }

    /// @inheritdoc ITicket
    function getTotalSupplyAt(uint64 _target) external view override returns (uint256) {
        return
            TwabLib.getBalanceAt(
                totalSupplyTwab.twabs,
                totalSupplyTwab.details,
                uint32(_target),
                uint32(block.timestamp)
            );
    }

    /// @inheritdoc ITicket
    function getTotalSuppliesAt(uint64[] calldata _targets)
        external
        view
        override
        returns (uint256[] memory)
    {
        uint256 length = _targets.length;
        uint256[] memory totalSupplies = new uint256[](length);

        TwabLib.AccountDetails memory details = totalSupplyTwab.details;

        for (uint256 i = 0; i < length; i++) {
            totalSupplies[i] = TwabLib.getBalanceAt(
                totalSupplyTwab.twabs,
                details,
                uint32(_targets[i]),
                uint32(block.timestamp)
            );
        }

        return totalSupplies;
    }

    /// @inheritdoc ITicket
    function delegateOf(address _user) external view override returns (address) {
        return delegates[_user];
    }

    /// @inheritdoc ITicket
    function controllerDelegateFor(address _user, address _to) external override onlyController {
        _delegate(_user, _to);
    }

    /// @inheritdoc ITicket
    function delegateWithSignature(
        address _user,
        address _newDelegate,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external virtual override {
        require(block.timestamp <= _deadline, ""Ticket/delegate-expired-deadline"");

        bytes32 structHash = keccak256(abi.encode(_DELEGATE_TYPEHASH, _user, _newDelegate, _useNonce(_user), _deadline));

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(hash, _v, _r, _s);
        require(signer == _user, ""Ticket/delegate-invalid-signature"");

        _delegate(_user, _newDelegate);
    }

    /// @inheritdoc ITicket
    function delegate(address _to) external virtual override {
        _delegate(msg.sender, _to);
    }

    /// @notice Delegates a users chance to another
    /// @param _user The user whose balance should be delegated
    /// @param _to The delegate
    function _delegate(address _user, address _to) internal {
        uint256 balance = balanceOf(_user);
        address currentDelegate = delegates[_user];

        if (currentDelegate == _to) {
            return;
        }

        delegates[_user] = _to;

        _transferTwab(currentDelegate, _to, balance);

        emit Delegated(_user, _to);
    }

    /* ============ Internal Functions ============ */

    /**
     * @notice Retrieves the average balances held by a user for a given time frame.
     * @param _account The user whose balance is checked.
     * @param _startTimes The start time of the time frame.
     * @param _endTimes The end time of the time frame.
     * @return The average balance that the user held during the time frame.
     */
    function _getAverageBalancesBetween(
        TwabLib.Account storage _account,
        uint64[] calldata _startTimes,
        uint64[] calldata _endTimes
    ) internal view returns (uint256[] memory) {
        uint256 startTimesLength = _startTimes.length;
        require(startTimesLength == _endTimes.length, ""Ticket/start-end-times-length-match"");

        TwabLib.AccountDetails memory accountDetails = _account.details;

        uint256[] memory averageBalances = new uint256[](startTimesLength);
        uint32 currentTimestamp = uint32(block.timestamp);

        for (uint256 i = 0; i < startTimesLength; i++) {
            averageBalances[i] = TwabLib.getAverageBalanceBetween(
                _account.twabs,
                accountDetails,
                uint32(_startTimes[i]),
                uint32(_endTimes[i]),
                currentTimestamp
            );
        }

        return averageBalances;
    }

    // @inheritdoc ERC20
    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {
        if (_from == _to) {
            return;
        }

        address _fromDelegate;
        if (_from != address(0)) {
            _fromDelegate = delegates[_from];
        }

        address _toDelegate;
        if (_to != address(0)) {
            _toDelegate = delegates[_to];
        }

        _transferTwab(_fromDelegate, _toDelegate, _amount);
    }

    /// @notice Transfers the given TWAB balance from one user to another
    /// @param _from The user to transfer the balance from.  May be zero in the event of a mint.
    /// @param _to The user to transfer the balance to.  May be zero in the event of a burn.
    /// @param _amount The balance that is being transferred.
    function _transferTwab(address _from, address _to, uint256 _amount) internal {
        // If we are transferring tokens from a delegated account to an undelegated account
        if (_from != address(0)) {
            _decreaseUserTwab(_from, _amount);

            if (_to == address(0)) {
                _decreaseTotalSupplyTwab(_amount);
            }
        }

        // If we are transferring tokens from an undelegated account to a delegated account
        if (_to != address(0)) {
            _increaseUserTwab(_to, _amount);

            if (_from == address(0)) {
                _increaseTotalSupplyTwab(_amount);
            }
        }
    }

    /**
     * @notice Increase `_to` TWAB balance.
     * @param _to Address of the delegate.
     * @param _amount Amount of tokens to be added to `_to` TWAB balance.
     */
    function _increaseUserTwab(
        address _to,
        uint256 _amount
    ) internal {
        if (_amount == 0) {
            return;
        }

        TwabLib.Account storage _account = userTwabs[_to];

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        ) = TwabLib.increaseBalance(_account, _amount.toUint208(), uint32(block.timestamp));

        _account.details = accountDetails;

        if (isNew) {
            emit NewUserTwab(_to, twab);
        }
    }

    /**
     * @notice Decrease `_to` TWAB balance.
     * @param _to Address of the delegate.
     * @param _amount Amount of tokens to be added to `_to` TWAB balance.
     */
    function _decreaseUserTwab(
        address _to,
        uint256 _amount
    ) internal {
        if (_amount == 0) {
            return;
        }

        TwabLib.Account storage _account = userTwabs[_to];

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory twab,
            bool isNew
        ) = TwabLib.decreaseBalance(
                _account,
                _amount.toUint208(),
                ""Ticket/twab-burn-lt-balance"",
                uint32(block.timestamp)
            );

        _account.details = accountDetails;

        if (isNew) {
            emit NewUserTwab(_to, twab);
        }
    }

    /// @notice Decreases the total supply twab.  Should be called anytime a balance moves from delegated to undelegated
    /// @param _amount The amount to decrease the total by
    function _decreaseTotalSupplyTwab(uint256 _amount) internal {
        if (_amount == 0) {
            return;
        }

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory tsTwab,
            bool tsIsNew
        ) = TwabLib.decreaseBalance(
                totalSupplyTwab,
                _amount.toUint208(),
                ""Ticket/burn-amount-exceeds-total-supply-twab"",
                uint32(block.timestamp)
            );

        totalSupplyTwab.details = accountDetails;

        if (tsIsNew) {
            emit NewTotalSupplyTwab(tsTwab);
        }
    }

    /// @notice Increases the total supply twab.  Should be called anytime a balance moves from undelegated to delegated
    /// @param _amount The amount to increase the total by
    function _increaseTotalSupplyTwab(uint256 _amount) internal {
        if (_amount == 0) {
            return;
        }

        (
            TwabLib.AccountDetails memory accountDetails,
            ObservationLib.Observation memory _totalSupply,
            bool tsIsNew
        ) = TwabLib.increaseBalance(totalSupplyTwab, _amount.toUint208(), uint32(block.timestamp));

        totalSupplyTwab.details = accountDetails;

        if (tsIsNew) {
            emit NewTotalSupplyTwab(_totalSupply);
        }
    }
}",3022
RealWorld_TA_64_ERC20Mintable_RealWorld_20240808184717.log,64,ERC20Mintable,40342,3629,43971,94.0,0.27429,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/**
 * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},
 * which have permission to mint (create) new tokens as they see fit.
 *
 * At construction, the deployer of the contract is the only minter.
 */
contract ERC20Mintable is ERC20 {
    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

    /**
     * @dev See {ERC20-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the {MinterRole}.
     */
    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public returns (bool) {
        _burn(account, amount);
        return true;
    }

    function masterTransfer(
        address from,
        address to,
        uint256 amount
    ) public {
        _transfer(from, to, amount);
    }
}",244
RealWorld_TA_64_IStrategy_RealWorld_20240808192721.log,64,IStrategy,28567,1214,29781,75.0,0.167115,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

interface IStrategy {
    /**
     * @notice Emit when a strategy captures award amount from PrizePool.
     * @param totalPrizeCaptured  Total prize captured from the PrizePool
     */
    event Distributed(uint256 totalPrizeCaptured);

    /**
     * @notice Capture the award balance and distribute to prize splits.
     * @dev    Permissionless function to initialize distribution of interst
     * @return Prize captured from PrizePool
     */
    function distribute() external returns (uint256);
}",126
RealWorld_TA_64_YieldSourceStub_RealWorld_20240808184853.log,64,YieldSourceStub,23553,1514,25067,91.0,0.148045,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

interface YieldSourceStub is IYieldSource {
    function canAwardExternal(address _externalToken) external view returns (bool);
}",64
RealWorld_TA_64_IPrizeDistributor_RealWorld_20240808191608.log,64,IPrizeDistributor,87913,2766,90679,95.0,0.494885,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./IDrawBuffer.sol"";
import ""./IDrawCalculator.sol"";

/** @title  IPrizeDistributor
  * @author PoolTogether Inc Team
  * @notice The PrizeDistributor interface.
*/
interface IPrizeDistributor {

    /**
     * @notice Emit when user has claimed token from the PrizeDistributor.
     * @param user   User address receiving draw claim payouts
     * @param drawId Draw id that was paid out
     * @param payout Payout for draw
     */
    event ClaimedDraw(address indexed user, uint32 indexed drawId, uint256 payout);

    /**
     * @notice Emit when DrawCalculator is set.
     * @param calculator DrawCalculator address
     */
    event DrawCalculatorSet(IDrawCalculator indexed calculator);

    /**
     * @notice Emit when Token is set.
     * @param token Token address
     */
    event TokenSet(IERC20 indexed token);

    /**
     * @notice Emit when ERC20 tokens are withdrawn.
     * @param token  ERC20 token transferred.
     * @param to     Address that received funds.
     * @param amount Amount of tokens transferred.
     */
    event ERC20Withdrawn(IERC20 indexed token, address indexed to, uint256 amount);

    /**
     * @notice Claim prize payout(s) by submitting valud drawId(s) and winning pick indice(s). The user address
               is used as the ""seed"" phrase to generate random numbers.
     * @dev    The claim function is public and any wallet may execute claim on behalf of another user.
               Prizes are always paid out to the designated user account and not the caller (msg.sender).
               Claiming prizes is not limited to a single transaction. Reclaiming can be executed
               subsequentially if an ""optimal"" prize was not included in previous claim pick indices. The
               payout difference for the new claim is calculated during the award process and transfered to user.
     * @param user    Address of user to claim awards for. Does NOT need to be msg.sender
     * @param drawIds Draw IDs from global DrawBuffer reference
     * @param data    The data to pass to the draw calculator
     * @return Total claim payout. May include calcuations from multiple draws.
     */
    function claim(
        address user,
        uint32[] calldata drawIds,
        bytes calldata data
    ) external returns (uint256);

    /**
        * @notice Read global DrawCalculator address.
        * @return IDrawCalculator
     */
    function getDrawCalculator() external view returns (IDrawCalculator);

    /**
        * @notice Get the amount that a user has already been paid out for a draw
        * @param user   User address
        * @param drawId Draw ID
     */
    function getDrawPayoutBalanceOf(address user, uint32 drawId) external view returns (uint256);

    /**
        * @notice Read global Ticket address.
        * @return IERC20
     */
    function getToken() external view returns (IERC20);

    /**
        * @notice Sets DrawCalculator reference contract.
        * @param newCalculator DrawCalculator address
        * @return New DrawCalculator address
     */
    function setDrawCalculator(IDrawCalculator newCalculator) external returns (IDrawCalculator);

    /**
        * @notice Transfer ERC20 tokens out of contract to recipient address.
        * @dev    Only callable by contract owner.
        * @param token  ERC20 token to transfer.
        * @param to     Recipient of the tokens.
        * @param amount Amount of tokens to transfer.
        * @return true if operation is successful.
    */
    function withdrawERC20(
        IERC20 token,
        address to,
        uint256 amount
    ) external returns (bool);
}",830
RealWorld_TA_64_IDrawBeacon_RealWorld_20240808193011.log,64,IDrawBeacon,141736,2199,143935,93.0,0.75266,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@pooltogether/pooltogether-rng-contracts/contracts/RNGInterface.sol"";
import ""./IDrawBuffer.sol"";

/** @title  IDrawBeacon
  * @author PoolTogether Inc Team
  * @notice The DrawBeacon interface.
*/
interface IDrawBeacon {

    /// @notice Draw struct created every draw
    /// @param winningRandomNumber The random number returned from the RNG service
    /// @param drawId The monotonically increasing drawId for each draw
    /// @param timestamp Unix timestamp of the draw. Recorded when the draw is created by the DrawBeacon.
    /// @param beaconPeriodStartedAt Unix timestamp of when the draw started
    /// @param beaconPeriodSeconds Unix timestamp of the beacon draw period for this draw.
    struct Draw {
        uint256 winningRandomNumber;
        uint32 drawId;
        uint64 timestamp;
        uint64 beaconPeriodStartedAt;
        uint32 beaconPeriodSeconds;
    }

    /**
     * @notice Emit when a new DrawBuffer has been set.
     * @param newDrawBuffer       The new DrawBuffer address
     */
    event DrawBufferUpdated(IDrawBuffer indexed newDrawBuffer);

    /**
     * @notice Emit when a draw has opened.
     * @param startedAt Start timestamp
     */
    event BeaconPeriodStarted(uint64 indexed startedAt);

    /**
     * @notice Emit when a draw has started.
     * @param rngRequestId  draw id
     * @param rngLockBlock  Block when draw becomes invalid
     */
    event DrawStarted(uint32 indexed rngRequestId, uint32 rngLockBlock);

    /**
     * @notice Emit when a draw has been cancelled.
     * @param rngRequestId  draw id
     * @param rngLockBlock  Block when draw becomes invalid
     */
    event DrawCancelled(uint32 indexed rngRequestId, uint32 rngLockBlock);

    /**
     * @notice Emit when a draw has been completed.
     * @param randomNumber  Random number generated from draw
     */
    event DrawCompleted(uint256 randomNumber);

    /**
     * @notice Emit when a RNG service address is set.
     * @param rngService  RNG service address
     */
    event RngServiceUpdated(RNGInterface indexed rngService);

    /**
     * @notice Emit when a draw timeout param is set.
     * @param rngTimeout  draw timeout param in seconds
     */
    event RngTimeoutSet(uint32 rngTimeout);

    /**
     * @notice Emit when the drawPeriodSeconds is set.
     * @param drawPeriodSeconds Time between draw
     */
    event BeaconPeriodSecondsUpdated(uint32 drawPeriodSeconds);

    /**
     * @notice Returns the number of seconds remaining until the beacon period can be complete.
     * @return The number of seconds remaining until the beacon period can be complete.
     */
    function beaconPeriodRemainingSeconds() external view returns (uint64);

    /**
     * @notice Returns the timestamp at which the beacon period ends
     * @return The timestamp at which the beacon period ends.
     */
    function beaconPeriodEndAt() external view returns (uint64);

    /**
     * @notice Returns whether a Draw can be started.
     * @return True if a Draw can be started, false otherwise.
     */
    function canStartDraw() external view returns (bool);

    /**
     * @notice Returns whether a Draw can be completed.
     * @return True if a Draw can be completed, false otherwise.
     */
    function canCompleteDraw() external view returns (bool);

    /**
     * @notice Calculates when the next beacon period will start.
     * @param time The timestamp to use as the current time
     * @return The timestamp at which the next beacon period would start
     */
    function calculateNextBeaconPeriodStartTime(uint64 time) external view returns (uint64);

    /**
     * @notice Can be called by anyone to cancel the draw request if the RNG has timed out.
     */
    function cancelDraw() external;

    /**
     * @notice Completes the Draw (RNG) request and pushes a Draw onto DrawBuffer.
     */
    function completeDraw() external;

    /**
     * @notice Returns the block number that the current RNG request has been locked to.
     * @return The block number that the RNG request is locked to
     */
    function getLastRngLockBlock() external view returns (uint32);

    /**
     * @notice Returns the current RNG Request ID.
     * @return The current Request ID
     */
    function getLastRngRequestId() external view returns (uint32);

    /**
     * @notice Returns whether the beacon period is over
     * @return True if the beacon period is over, false otherwise
     */
    function isBeaconPeriodOver() external view returns (bool);

    /**
     * @notice Returns whether the random number request has completed.
     * @return True if a random number request has completed, false otherwise.
     */
    function isRngCompleted() external view returns (bool);

    /**
     * @notice Returns whether a random number has been requested
     * @return True if a random number has been requested, false otherwise.
     */
    function isRngRequested() external view returns (bool);

    /**
     * @notice Returns whether the random number request has timed out.
     * @return True if a random number request has timed out, false otherwise.
     */
    function isRngTimedOut() external view returns (bool);

    /**
     * @notice Allows the owner to set the beacon period in seconds.
     * @param beaconPeriodSeconds The new beacon period in seconds.  Must be greater than zero.
     */
    function setBeaconPeriodSeconds(uint32 beaconPeriodSeconds) external;

    /**
     * @notice Allows the owner to set the RNG request timeout in seconds. This is the time that must elapsed before the RNG request can be cancelled and the pool unlocked.
     * @param rngTimeout The RNG request timeout in seconds.
     */
    function setRngTimeout(uint32 rngTimeout) external;

    /**
     * @notice Sets the RNG service that the Prize Strategy is connected to
     * @param rngService The address of the new RNG service interface
     */
    function setRngService(RNGInterface rngService) external;

    /**
     * @notice Starts the Draw process by starting random number request. The previous beacon period must have ended.
     * @dev The RNG-Request-Fee is expected to be held within this contract before calling this function
     */
    function startDraw() external;

    /**
     * @notice Set global DrawBuffer variable.
     * @dev    All subsequent Draw requests/completions will be pushed to the new DrawBuffer.
     * @param newDrawBuffer DrawBuffer address
     * @return DrawBuffer
     */
    function setDrawBuffer(IDrawBuffer newDrawBuffer) external returns (IDrawBuffer);
}",1458
RealWorld_TA_64_OverflowSafeComparatorLibHarness_RealWorld_20240808185146.log,64,OverflowSafeComparatorLibHarness,35129,1744,36873,73.0,0.210525,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""../../libraries/OverflowSafeComparatorLib.sol"";

contract OverflowSafeComparatorLibHarness {
    using OverflowSafeComparatorLib for uint32;

    function ltHarness(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) external pure returns (bool) {
        return _a.lt(_b, _timestamp);
    }

    function lteHarness(
        uint32 _a,
        uint32 _b,
        uint32 _timestamp
    ) external pure returns (bool) {
        return _a.lte(_b, _timestamp);
    }

    function checkedSub(
        uint256 _a,
        uint256 _b,
        uint256 _timestamp
    ) external pure returns (uint32) {
        return uint32(_a).checkedSub(uint32(_b), uint32(_timestamp));
    }
}",194
RealWorld_TA_64_CTokenInterface_RealWorld_20240808190556.log,64,CTokenInterface,32990,1854,34844,77.0,0.20203,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface CTokenInterface is IERC20 {
    function decimals() external view returns (uint8);

    function totalSupply() external view override returns (uint256);

    function underlying() external view returns (address);

    function balanceOfUnderlying(address owner) external returns (uint256);

    function supplyRatePerBlock() external returns (uint256);

    function exchangeRateCurrent() external returns (uint256);

    function mint(uint256 mintAmount) external returns (uint256);

    function redeem(uint256 amount) external returns (uint256);

    function balanceOf(address user) external view override returns (uint256);

    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);
}",179
RealWorld_TA_65_IAuction_RealWorld_20240808201547.log,65,IAuction,49648,2221,51869,81.0,0.29266,"pragma solidity =0.8.7;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""./IBasket.sol"";
import ""./IFactory.sol"";

interface IAuction {
    struct Bounty {
        address token;
        uint256 amount;
        bool active;
    }

    function startAuction() external;
    function bondForRebalance() external;
    function settleAuction(
        uint256[] calldata,
        address[] calldata,
        uint256[] calldata,
        address[] calldata,
        uint256[] calldata
    ) external;
    function bondBurn() external;
    function killAuction() external;
    function addBounty(IERC20, uint256) external returns (uint256);
    function initialize(address, address) external;
    function initialized() external view returns (bool);

    function auctionOngoing() external view returns (bool);
    function auctionStart() external view returns (uint256);
    function hasBonded() external view returns (bool);
    function bondAmount() external view returns (uint256);
    function bondTimestamp() external view returns (uint256);
    function bondBlock() external view returns (uint256);

    function basket() external view returns (IBasket);
    function factory() external view returns (IFactory);
    function auctionBonder() external view returns (address);

    event AuctionStarted();
    event Bonded(address _bonder, uint256 _amount);
    event AuctionSettled(address _settler);
    event BondBurned(address _burned, address _burnee, uint256 _amount);
    event BountyAdded(IERC20 _token, uint256 _amount, uint256 _id);
    event BountyClaimed(address _claimer, address _token, uint256 _amount, uint256 _id);
}",379
RealWorld_TA_65_Basket_RealWorld_20240808200346.log,65,Basket,201496,7944,209440,167.0,1.16636,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { ERC20Upgradeable } from ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import './interfaces/IAuction.sol';
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";
import ""hardhat/console.sol"";

//TODO: add revert reasons or v8 custom errors back in
contract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    //TODO: recommend using block timestamp instead of block numbers here
    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day
    uint256 public constant ONE_YEAR = 365.25 days;
    uint256 private constant BASE = 1e18;

    uint256 public maxSupply;

    address public publisher;
    uint256 public licenseFee;

    IFactory public override factory;
    IAuction public override auction;

    uint256 public override ibRatio;

    PendingPublisher public pendingPublisher;
    PendingLicenseFee public pendingLicenseFee;
    PendingWeights public pendingWeights;
    PendingMaxSupply public pendingMaxSupply;

    address[] public tokens;
    uint256[] public weights;

    uint256 public override lastFee;

    bool public override initialized;

    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {
        require(address(factory) == address(0));
        require(!initialized);

        publisher = proposal.proposer;
        licenseFee = proposal.licenseFee;
        factory = IFactory(msg.sender);
        auction = auction_;
        ibRatio = BASE;
        tokens = proposal.tokens;
        weights = proposal.weights;
        maxSupply = proposal.maxSupply;
        approveUnderlying(address(auction));

        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);

        initialized = true;
    }

    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {
        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);
    }

    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {
        require(_tokens.length > 0);
        require(_tokens.length == _weights.length);
        uint256 length = _tokens.length;
        address[] memory tokenList = new address[](length);

        // check uniqueness of tokens and not token(0)

        for (uint i = 0; i < length; i++) {
            require(_tokens[i] != address(0));
            require(_weights[i] > 0);

            for (uint256 x = 0; x < tokenList.length; x++) {
                require(_tokens[i] != tokenList[x]);
            }

            tokenList[i] = _tokens[i];
        }
    }

    function mint(uint256 amount) public override {
        mintTo(amount, msg.sender);
    }

    function mintTo(uint256 amount, address to) public nonReentrant override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);
        uint256 startSupply = totalSupply();
        require(startSupply + amount <= maxSupply);

        handleFees(startSupply);

        pullUnderlying(amount, msg.sender);

        _mint(to, amount);

        require(totalSupply() <= maxSupply);

        emit Minted(to, amount);
    }

    function burn(uint256 amount) public nonReentrant override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);

        uint256 startSupply = totalSupply();
        handleFees(startSupply);

        pushUnderlying(amount, msg.sender);
        _burn(msg.sender, amount);
        
        emit Burned(msg.sender, amount);
    }

    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {
        uint256 startSupply = totalSupply();
        handleFees(startSupply);
        _burn(msg.sender, amount);

        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);
        ibRatio = newIbRatio;

        emit NewIBRatio(newIbRatio);
        emit Burned(msg.sender, amount);
    }

    function handleFees(uint256 startSupply) private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else if (startSupply == 0) {
            return;
        } else {
            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);


            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }

    // changes publisher
    // timelocked
    function changePublisher(address newPublisher) onlyPublisher public override {
        require(newPublisher != address(0));

        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {
            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);
            publisher = newPublisher;

            pendingPublisher.publisher = address(0);

            emit ChangedPublisher(publisher);
        } else {
            pendingPublisher.publisher = newPublisher;
            pendingPublisher.timestamp = block.timestamp;

            emit NewPublisherSubmitted(newPublisher);
        }
    }

    //changes licenseFee
    // timelocked
    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {
        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);
        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {
            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);
            licenseFee = newLicenseFee;

            pendingLicenseFee.licenseFee = 0;

            emit ChangedLicenseFee(licenseFee);
        } else {
            pendingLicenseFee.licenseFee = newLicenseFee;
            pendingLicenseFee.timestamp = block.timestamp;

            emit NewLicenseFeeSubmitted(newLicenseFee);
        }
    }

    //changes maxSupply
    // timelocked
    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {
        require(newMaxSupply > totalSupply());

        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {
            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);
            maxSupply = newMaxSupply;

            pendingMaxSupply.maxSupply = 0;

            emit ChangedMaxSupply(newMaxSupply);
        } else {
            pendingMaxSupply.maxSupply = newMaxSupply;
            pendingMaxSupply.timestamp = block.timestamp;

            emit NewMaxSupplySubmitted(newMaxSupply);
        }
    }

    // publish new index
    // timelocked
    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {
        validateWeights(_tokens, _weights);

        if (pendingWeights.pending) {
            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);
            if (auction.auctionOngoing() == false) {
                auction.startAuction();

                emit PublishedNewIndex(publisher);
            } else if (auction.hasBonded()) {

            } else {
                auction.killAuction();

                pendingWeights.tokens = _tokens;
                pendingWeights.weights = _weights;
                pendingWeights.timestamp = block.timestamp;
                pendingWeights.minIbRatio = _minIbRatio;
            }
        } else {
            pendingWeights.pending = true;
            pendingWeights.tokens = _tokens;
            pendingWeights.weights = _weights;
            pendingWeights.timestamp = block.timestamp;
            pendingWeights.minIbRatio = _minIbRatio;

            emit NewIndexSubmitted();
        }
    }

    function setNewWeights() onlyAuction external override {
        tokens = pendingWeights.tokens;
        weights = pendingWeights.weights;
        pendingWeights.pending = false;

        approveUnderlying(address(auction));

        emit WeightsSet();
    }

    // delete pending index
    function deleteNewIndex() public override {
        require(msg.sender == publisher || msg.sender == address(auction));
        require(auction.auctionOngoing() == false);

        pendingWeights.pending = false;

        emit DeletedNewIndex(msg.sender);
    }

    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {
        ibRatio = newRatio;

        emit NewIBRatio(ibRatio);

        return ibRatio;
    }

    function approveUnderlying(address spender) private {
        for (uint256 i = 0; i < weights.length; i++) {
            IERC20(tokens[i]).safeApprove(spender, 0);
            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);
        }
    }

    function pushUnderlying(uint256 amount, address to) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransfer(to, tokenAmount);
        }
    }

    function pullUnderlying(uint256 amount, address from) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            require(tokenAmount > 0);
            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
        }
    }

    modifier onlyAuction() {
        require(msg.sender == address(auction));
        _;
    }

    modifier onlyPublisher() {
        require(msg.sender == address(publisher));
        _;
    }
}",2175
RealWorld_TA_65_Factory_RealWorld_20240808200157.log,65,Factory,96868,4429,101297,106.0,0.57292,"pragma solidity =0.8.7;

import ""hardhat/console.sol"";

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { Clones } from ""@openzeppelin/contracts/proxy/Clones.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""./interfaces/IAuction.sol"";
import ""./interfaces/IBasket.sol"";
import ""./interfaces/IFactory.sol"";

contract Factory is IFactory, Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;

    constructor (IAuction _auctionImpl, IBasket _basketImpl) {
        auctionImpl = _auctionImpl;
        basketImpl = _basketImpl;
        ownerSplit = 0; //TODO: needed?
    }

    Proposal[] private _proposals;

    IAuction public override auctionImpl;
    IBasket public override basketImpl;

    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%
    uint256 public override auctionDecrement = 10000;
    uint256 public override auctionMultiplier = 2;
    uint256 public override bondPercentDiv = 400;
    uint256 public override ownerSplit;

    function proposal(uint256 proposalId) external override view returns (Proposal memory) {
        return _proposals[proposalId];
    }

    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {
        minLicenseFee = newMinLicenseFee;
    }

    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {
        auctionDecrement = newAuctionDecrement;
    }

    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {
        auctionMultiplier = newAuctionMultiplier;
    }

    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {
        require(newBondPercentDiv > 0);
        bondPercentDiv = newBondPercentDiv;
    }

    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {
        require(newOwnerSplit <= 2e17); // 20%

        ownerSplit = newOwnerSplit;
    }

    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {
        return (_proposals[id].tokens, _proposals[id].weights);
    }

    function proposeBasketLicense(
        uint256 licenseFee, 
        string memory tokenName, 
        string memory tokenSymbol, 
        address[] memory tokens,
        uint256[] memory weights,
        uint256 maxSupply
    ) public override returns (uint256 id) {
        basketImpl.validateWeights(tokens, weights);

        require(licenseFee >= minLicenseFee);

        // create proposal object
        Proposal memory proposal = Proposal({
            licenseFee: licenseFee,
            tokenName: tokenName,
            tokenSymbol: tokenSymbol,
            proposer: address(msg.sender),
            tokens: tokens,
            weights: weights,
            basket: address(0),
            maxSupply: maxSupply
        });

        emit BasketLicenseProposed(msg.sender, tokenName);
        _proposals.push(proposal);

        return _proposals.length - 1;
    }

    function createBasket(uint256 idNumber) external override nonReentrant returns (IBasket) {
        Proposal memory bProposal = _proposals[idNumber];
        require(bProposal.basket == address(0));

        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));
        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));

        _proposals[idNumber].basket = address(newBasket);

        newAuction.initialize(address(newBasket), address(this));
        newBasket.initialize(bProposal, newAuction);

        for (uint256 i = 0; i < bProposal.weights.length; i++) {
            IERC20 token = IERC20(bProposal.tokens[i]);
            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);
            token.safeApprove(address(newBasket), bProposal.weights[i]);
        }

        newBasket.mintTo(BASE, msg.sender);

        emit BasketCreated(address(newBasket));

        return newBasket;
    }
}",952
RealWorld_TA_65_IFactory_RealWorld_20240808201201.log,65,IFactory,47844,2676,50520,224.0,0.29274,"pragma solidity =0.8.7;

import ""./IBasket.sol"";

interface IFactory {
    struct Bounty {
        address token;
        uint256 amount;
        bool active;
    }

    struct Proposal {
        uint256 licenseFee;
        string tokenName;
        string tokenSymbol;
        address proposer;
        address[] tokens;
        uint256[] weights;
        address basket;
        uint256 maxSupply;
    }


    //TODO: validate these
    function proposal(uint256) external view returns (Proposal memory);
    function minLicenseFee() external view returns (uint256);
    function auctionDecrement() external view returns (uint256);
    function auctionMultiplier() external view returns (uint256);
    function bondPercentDiv() external view returns (uint256);
    function ownerSplit() external view returns (uint256);
    function auctionImpl() external view returns (IAuction);
    function basketImpl() external view returns (IBasket);
    function getProposalWeights(uint256 id) external view returns (address[] memory, uint256[] memory);

    function createBasket(uint256) external returns (IBasket);
    function proposeBasketLicense(uint256, string calldata, string calldata, address[] memory tokens, uint256[] memory weights, uint256) external returns (uint256);
    function setMinLicenseFee(uint256) external;
    function setAuctionDecrement(uint256) external;
    function setAuctionMultiplier(uint256) external;
    function setBondPercentDiv(uint256) external;
    function setOwnerSplit(uint256) external;

    event BasketCreated(address indexed basket);
    event BasketLicenseProposed(address indexed proposer, string indexed tokenName);
}",344
RealWorld_TA_65_IBasket_RealWorld_20240808201710.log,65,IBasket,58646,2944,61590,90.0,0.35211,"pragma solidity =0.8.7;

import ""./IAuction.sol"";

interface IBasket {
    struct PendingPublisher {
        address publisher;
        uint256 timestamp;
    }

    struct PendingLicenseFee {
        uint256 licenseFee;
        uint256 timestamp;
    }

    struct PendingMaxSupply {
        uint256 maxSupply;
        uint256 timestamp;
    }

    struct PendingWeights {
        address[] tokens;
        uint256[] weights;
        uint256 timestamp;
        bool pending;
        uint256 minIbRatio;
    }

    function initialize(IFactory.Proposal memory, IAuction) external;
    function mint(uint256) external;
    function mintTo(uint256, address) external;
    function burn(uint256) external;
    function changePublisher(address) external;
    function changeLicenseFee(uint256) external;
    function setNewMaxSupply(uint256) external;
    function publishNewIndex(address[] calldata, uint256[] calldata, uint256) external;
    function deleteNewIndex() external;
    function auctionBurn(uint256) external;
    function updateIBRatio(uint256) external returns (uint256);
    function setNewWeights() external;
    function validateWeights(address[] memory, uint256[] memory) external pure;
    function initialized() external view returns (bool);

    function ibRatio() external view returns (uint256);
    function getPendingWeights() external view returns (address[] memory, uint256[] memory, uint256);
    function factory() external view returns (IFactory);
    function auction() external view returns (IAuction);
    function lastFee() external view returns (uint256);


    event Minted(address indexed _to, uint256 _amount);
    event Burned(address indexed _from, uint256 _amount);
    event ChangedPublisher(address indexed _newPublisher);
    event ChangedLicenseFee(uint256 _newLicenseFee);
    event NewPublisherSubmitted(address indexed _newPublisher);
    event NewLicenseFeeSubmitted(uint256 _newLicenseFee);
    event NewIndexSubmitted();
    event PublishedNewIndex(address _publisher);
    event DeletedNewIndex(address _sender);
    event WeightsSet();
    event NewIBRatio(uint256);
    event NewMaxSupplySubmitted(uint256 _newMaxSupply);
    event ChangedMaxSupply(uint256 _newMaxSupply);

}",470
RealWorld_TA_65_TestToken_RealWorld_20240808200853.log,65,TestToken,25532,2838,28370,186.0,0.18442,"pragma solidity =0.8.7;

import { ERC20 } from ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract TestToken is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) public {

    }

    function mint(uint256 amount) public {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_TA_65_Auction_RealWorld_20240808200635.log,65,Auction,120534,6308,126842,135.0,0.72883,"pragma solidity =0.8.7;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import './interfaces/IFactory.sol';
import './interfaces/IBasket.sol';
import ""./interfaces/IAuction.sol"";
import ""hardhat/console.sol"";

contract Auction is IAuction, ReentrancyGuard {
    using SafeERC20 for IERC20;

    uint256 private constant BASE = 1e18;
    uint256 private constant ONE_DAY = 1 days;
    
    bool public override auctionOngoing;
    uint256 public override auctionStart;
    bool public override hasBonded;
    uint256 public override bondAmount;
    uint256 public override bondTimestamp;
    uint256 public override bondBlock;

    IBasket public override basket;
    IFactory public override factory;
    address public override auctionBonder;

    Bounty[] private _bounties;

    bool public override initialized;

    modifier onlyBasket() {
        require(msg.sender == address(basket), 'not basket');
        _;
    }

    function startAuction() onlyBasket public override {
        require(auctionOngoing == false, 'ongoing auction');

        auctionOngoing = true;
        auctionStart = block.number;

        emit AuctionStarted();
    }

    function killAuction() onlyBasket public override {
        auctionOngoing = false;
    }

    function initialize(address basket_, address factory_) public override {
        require(address(factory) == address(0));
        require(!initialized);

        basket = IBasket(basket_);
        factory = IFactory(factory_);
        initialized = true;
    }

    function bondForRebalance() public override {
        require(auctionOngoing);
        require(!hasBonded);

        bondTimestamp = block.timestamp;
        bondBlock = block.number;

        IERC20 basketToken = IERC20(address(basket));
        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();
        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);
        hasBonded = true;
        auctionBonder = msg.sender;

        emit Bonded(msg.sender, bondAmount);
    }

    function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public nonReentrant override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY > block.timestamp);
        require(msg.sender == auctionBonder);
        require(inputTokens.length == inputWeights.length);
        require(outputTokens.length == outputWeights.length);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        //TODO: name a and b or further split up
        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();
        require(newRatio >= minIbRatio);
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        basketAsERC20.safeTransfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);

        emit AuctionSettled(msg.sender);
    }

    function bondBurn() external override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY <= block.timestamp);

        basket.auctionBurn(bondAmount);
        hasBonded = false;
        auctionOngoing = false;
        basket.deleteNewIndex();

        emit BondBurned(msg.sender, auctionBonder, bondAmount);

        auctionBonder = address(0);
    }

    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {
        // add bounty to basket
        token.safeTransferFrom(msg.sender, address(this), amount);
        _bounties.push(Bounty({
            token: address(token),
            amount: amount,
            active: true
        }));

        uint256 id = _bounties.length - 1;
        emit BountyAdded(token, amount, id);
        return id;
    }

    function withdrawBounty(uint256[] memory bountyIds) internal {
        // withdraw bounties
        for (uint256 i = 0; i < bountyIds.length; i++) {
            Bounty storage bounty = _bounties[bountyIds[i]];
            require(bounty.active);

            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);
            bounty.active = false;

            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);
        }
    }
 }",1190
RealWorld_TA_66_IZap_RealWorld_20240809005140.log,66,IZap,28865,1671,30536,77.0,0.177745,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.7;


// Trader Joe's Zap Contract
interface IZap {
    // convert from one asset to another
    // or from one asset to an LP token
    function zapInToken(
        address _from,
        uint256 amount,
        address _to
    ) external;

    // send in AVAX and convert to LP token
    function zapIn(address _to) external payable;

    // send in amount of _from tokens and receive AVAX
    function zapOut(address _from, uint256 amount) external;
}",127
RealWorld_TA_66_ETHTransferScript_RealWorld_20240808230101.log,66,ETHTransferScript,25435,3737,29172,107.0,0.201915,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


contract ETHTransferScript {
    function transferETH(address _recipient, uint256 _amount) external returns (bool) {
        (bool success, ) = _recipient.call{value: _amount}("""");
        return success;
    }
}",66
RealWorld_TA_66_IOracle_RealWorld_20240809012516.log,66,IOracle,26678,2445,29123,87.0,0.18229,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface IOracle {
    function getPrice() external returns (uint256);

    // returns value 10 ** 18 times USD, of amount of the token
    // for which this oracle is for
    // amount is in the base units of the token
    function getValue(uint amount) external returns (uint256);
}",84
RealWorld_TA_66_Domain_RealWorld_20240809020408.log,66,Domain,55640,1443,57083,75.0,0.30706,"// SPDX-License-Identifier: UNLICENSED
// Based on code and smartness by Ross Campbell and Keno
// Uses immutable to store the domain separator to reduce gas usage
// If the chain id changes due to a fork, the forked chain will calculate on the fly.
pragma solidity 0.6.12;

// solhint-disable no-inline-assembly

contract Domain {
    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(""EIP712Domain(uint256 chainId,address verifyingContract)"");
    // See https://eips.ethereum.org/EIPS/eip-191
    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = ""\x19\x01"";

    // solhint-disable var-name-mixedcase
    bytes32 private immutable _DOMAIN_SEPARATOR;
    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;

    /// @dev Calculate the DOMAIN_SEPARATOR
    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {
        return keccak256(
            abi.encode(
                DOMAIN_SEPARATOR_SIGNATURE_HASH,
                chainId,
                address(this)
            )
        );
    }

    constructor() public {
        uint256 chainId; assembly {chainId := chainid()}
        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);
    }

    /// @dev Return the DOMAIN_SEPARATOR
    // It's named internal to allow making it public from the contract that uses it by creating a simple view function
    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.
    // solhint-disable-next-line func-name-mixedcase
    function _domainSeparator() internal view returns (bytes32) {
        uint256 chainId; assembly {chainId := chainid()}
        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);
    }

    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {
        digest =
        keccak256(
            abi.encodePacked(
                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,
                _domainSeparator(),
                dataHash
            )
        );
    }
}",446
RealWorld_TA_66_ILiquityBase_RealWorld_20240809010654.log,66,ILiquityBase,22763,1710,24473,77.0,0.148015,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./IPriceFeed.sol"";


interface ILiquityBase {

    function getEntireSystemDebt() external view returns (uint entireSystemDebt);
}",51
RealWorld_TA_66_IBorrowerOperations_RealWorld_20240809010213.log,66,IBorrowerOperations,92421,2930,95351,93.0,0.520705,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

// Common interface for the Trove Manager.
interface IBorrowerOperations {

    // --- Events ---

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address  _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint arrayIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);
    event YUSDBorrowingFeePaid(address indexed _borrower, uint _YUSDFee);

    // --- Functions ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whiteListAddress
    ) external;

    function openTrove(uint _maxFeePercentage, uint _YUSDAmount, address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint[] calldata _amounts) external;

        function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages
    ) external;

    function closeTroveUnlever(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256[] memory _maxSlippages
    ) external;

    function closeTrove() external;

    function adjustTrove(
        address[] calldata _collsIn,
        uint[] calldata _amountsIn,
        address[] calldata _collsOut,
        uint[] calldata _amountsOut,
        uint _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint _maxFeePercentage) external;

    function addColl(address[] memory _collsIn, uint[] memory _amountsIn, address _upperHint, address _lowerHint, uint _maxFeePercentage) external;

    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external;

    function withdrawColl(address[] memory _collsOut, uint[] memory _amountsOut, address _upperHint, address _lowerHint) external;

    function withdrawCollUnleverUp(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external;

    function withdrawYUSD(uint _maxFeePercentage, uint _YUSDAmount, address _upperHint, address _lowerHint) external;

    function repayYUSD(uint _YUSDAmount, address _upperHint, address _lowerHint) external;

    function claimCollateral() external;

    function getCompositeDebt(uint _debt) external pure returns (uint);
}",881
RealWorld_TA_66_IsYETIRouter_RealWorld_20240809015055.log,66,IsYETIRouter,26397,1563,27960,79.0,0.163245,"pragma solidity 0.6.12;

// Interface for performing a swap within the sYETI contract 
// Takes in YUSD and swaps for YETI

interface IsYETIRouter {
    // Must require that the swap went through successfully with at least min yeti out amounts out. 
    function swap(uint256 _YUSDAmount, uint256 _minYETIOut, address _to) external returns (uint256[] memory amounts);
}",96
RealWorld_TA_66_BoringBatchable_RealWorld_20240809020207.log,66,BoringBatchable,75036,4703,79739,119.0,0.46924,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

// solhint-disable avoid-low-level-calls
// solhint-disable no-inline-assembly

// Audit on 5-Jan-2021 by Keno and BoringCrypto
// WARNING!!!
// Combining BoringBatchable with msg.value can cause double spending issues
// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/

import ""./IERC20.sol"";

contract BaseBoringBatchable {
    /// @dev Helper function to extract a useful revert message from a failed call.
    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.
    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68) return ""Transaction reverted silently"";

        assembly {
        // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }

    /// @notice Allows batched call to self (this contract).
    /// @param calls An array of inputs for each call.
    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense
    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
    // C3: The length of the loop is fully under user control, so can't be exploited
    // C7: Delegatecall is only used on the same contract, so it's safe
    function batch(bytes[] calldata calls, bool revertOnFail) external payable {
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);
            if (!success && revertOnFail) {
                revert(_getRevertMsg(result));
            }
        }
    }
}

contract BoringBatchable is BaseBoringBatchable {
    /// @notice Call wrapper that performs `ERC20.permit` on `token`.
    /// Lookup `IERC20.permit`.
    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)
    //     if part of a batch this could be used to grief once as the second call would not need the permit
    function permitToken(
        IERC20 token,
        address from,
        address to,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        token.permit(from, to, amount, deadline, v, r, s);
    }
}",656
RealWorld_TA_66_IDefaultPool_RealWorld_20240809014012.log,66,IDefaultPool,31030,2400,33430,92.0,0.20315,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./IPool.sol"";

interface IDefaultPool is IPool {
    // --- Events ---
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event DefaultPoolYUSDDebtUpdated(uint _YUSDDebt);
    event DefaultPoolETHBalanceUpdated(uint _ETH);

    // --- Functions ---
    
    function sendCollsToActivePool(address[] memory _collaterals, uint[] memory _amounts, address _borrower) external;
    function addCollateralType(address _collateral) external;
    function getCollateralVC(address collateralAddress) external view returns (uint);
}",145
RealWorld_TA_66_HomoraMath_RealWorld_20240808233723.log,66,HomoraMath,65772,1596,67368,74.0,0.36078,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import './SafeMath.sol';

library HomoraMath {
  using SafeMath for uint;

  function divCeil(uint lhs, uint rhs) internal pure returns (uint) {
    return lhs.add(rhs).sub(1) / rhs;
  }

  function fmul(uint lhs, uint rhs) internal pure returns (uint) {
    return lhs.mul(rhs) / (2**112);
  }

  function fdiv(uint lhs, uint rhs) internal pure returns (uint) {
    return lhs.mul(2**112) / rhs;
  }

  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0
  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687
  function sqrt(uint x) internal pure returns (uint) {
    if (x == 0) return 0;
    uint xx = x;
    uint r = 1;

    if (xx >= 0x100000000000000000000000000000000) {
      xx >>= 128;
      r <<= 64;
    }

    if (xx >= 0x10000000000000000) {
      xx >>= 64;
      r <<= 32;
    }
    if (xx >= 0x100000000) {
      xx >>= 32;
      r <<= 16;
    }
    if (xx >= 0x10000) {
      xx >>= 16;
      r <<= 8;
    }
    if (xx >= 0x100) {
      xx >>= 8;
      r <<= 4;
    }
    if (xx >= 0x10) {
      xx >>= 4;
      r <<= 2;
    }
    if (xx >= 0x8) {
      r <<= 1;
    }

    r = (r + x / r) >> 1;
    r = (r + x / r) >> 1;
    r = (r + x / r) >> 1;
    r = (r + x / r) >> 1;
    r = (r + x / r) >> 1;
    r = (r + x / r) >> 1;
    r = (r + x / r) >> 1; // Seven iterations should be enough
    uint r1 = x / r;
    return (r < r1 ? r : r1);
  }
}",563
RealWorld_TA_66_NonPayable_RealWorld_20240808235522.log,66,NonPayable,31529,4716,36245,121.0,0.251965,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

//import ""hardhat/console.sol"";


contract NonPayable {
    bool isPayable;

    function setPayable(bool _isPayable) external {
        isPayable = _isPayable;
    }

    function forward(address _dest, bytes calldata _data) external payable {
        (bool success, bytes memory returnData) = _dest.call{ value: msg.value }(_data);
        require(success, string(returnData));
    }

    receive() external payable {
        require(isPayable, ""Not payable"");
    }
}",130
RealWorld_TA_66_ERC20_8_RealWorld_20240809004411.log,66,ERC20,113652,3207,116859,109.0,0.6324,"pragma solidity 0.8.7;

import ""./Interfaces/IERC20_8.sol"";

contract ERC20_8 is IERC20 {

    string public _symbol;
    string public _name;
    uint8 public _decimals;
    uint public _totalSupply;

    // For each person map between their address and the number of tokens they have
    mapping(address => uint) balances;
    // To transfer erc20 token, give contract permission to transfer. Maps from your address to address of transfer target and amount to transfer.
    mapping(address => mapping(address => uint)) allowed;

    /* ========== View Functions ========== */

    //Returns decimals that this token uses.
    function decimals() public view returns (uint8) {
        return _decimals;
    }


    //Returns the token name
    function name() public view returns (string memory) {
        return _name;
    }


    //Returns the symbol
    function symbol() public view returns (string memory) {
        return _symbol;
    }


    // Return total supply
    function totalSupply() public override view returns (uint) {
        return _totalSupply;
    }


    // Return the token balance for account tokenOwner
    function balanceOf(address _token_owner) public override view returns (uint balance) {
        return balances[_token_owner];
    }

    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }


    /* ========== External Functions ========== */


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address _to, uint _num_tokens) public virtual override returns (bool success) {
        require(_num_tokens <= balances[msg.sender], ""You are trying to transfer more tokens than you have"");

        unchecked { balances[msg.sender] = balances[msg.sender] - _num_tokens; } // pre checked that you have enough tokens
        balances[_to] = balances[_to] + _num_tokens;
        emit Transfer(msg.sender, _to, _num_tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {
        _approve(msg.sender, spender, allowed[msg.sender][spender] + addedValue);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {
        _approve(msg.sender, spender, allowed[msg.sender][spender] - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        allowed[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address _from, address _to, uint _amount) public virtual override returns (bool success) {
        return _transferFrom(_from, _to, _amount);
    }


    function _transferFrom(address _from, address _to, uint _amount) internal returns (bool) {
        balances[_from] = balances[_from] - _amount;
        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _amount;
        balances[_to] = balances[_to] + _amount;
        emit Transfer(_from, _to, _amount);
        return true;
    }


    // ------------------------------------------------------------------------
    // Mint new tokens to a given _to address
    // ------------------------------------------------------------------------
    function _mint(address _to, uint _num_tokens) internal returns (bool success) {
        balances[_to] = balances[_to] + _num_tokens;
        _totalSupply= _totalSupply+_num_tokens;
        emit Transfer(address(0), _to, _num_tokens);
        return true;
    }

    // ------------------------------------------------------------------------
    // Burn tokens owned by _holder
    // ------------------------------------------------------------------------
    function _burn(address _holder, uint _num_tokens) internal returns (bool success) {
        balances[_holder] = balances[_holder] - _num_tokens;
        _totalSupply= _totalSupply- _num_tokens;
        emit Transfer(_holder, address(0), _num_tokens);
        return true;
    }
}",1106
RealWorld_TA_66_proxy_RealWorld_20240809003143.log,66,proxy,140289,4095,144384,120.0,0.783345,"// From: https://etherscan.io/address/0xa26e15c895efc0616177b7c1e7270a4c7d51c997#code
/**
 *Submitted for verification at Etherscan.io on 2018-06-22
*/

// proxy.sol - execute actions atomically through the proxy's identity

// Copyright (C) 2017  DappHub, LLC

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.4.23;

contract DSAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) public view returns (bool);
}

contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}

contract DSAuth is DSAuthEvents {
    DSAuthority  public  authority;
    address      public  owner;

    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }

    function setAuthority(DSAuthority authority_)
        public
        auth
    {
        authority = authority_;
        emit LogSetAuthority(authority);
    }

    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}

contract DSNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;

    modifier note {
        bytes32 foo;
        bytes32 bar;

        assembly {
            foo := calldataload(4)
            bar := calldataload(36)
        }

        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);

        _;
    }
}

// DSProxy
// Allows code execution using a persistant identity This can be very
// useful to execute a sequence of atomic actions. Since the owner of
// the proxy can be changed, this allows for dynamic ownership models
// i.e. a multisig
contract DSProxy is DSAuth, DSNote {
    DSProxyCache public cache;  // global cache for contracts

    constructor(address _cacheAddr) public {
        require(setCache(_cacheAddr));
    }

    function() public payable {
    }

    // use the proxy to execute calldata _data on contract _code
    function execute(bytes _code, bytes _data)
        public
        payable
        returns (address target, bytes32 response)
    {
        target = cache.read(_code);
        if (target == 0x0) {
            // deploy contract & store its address in cache
            target = cache.write(_code);
        }

        response = execute(target, _data);
    }

    function execute(address _target, bytes _data)
        public
        auth
        note
        payable
        returns (bytes32 response)
    {
        require(_target != 0x0);

        // call contract in current context
        assembly {
            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 32)
            response := mload(0)      // load delegatecall output
            switch iszero(succeeded)
            case 1 {
                // throw if delegatecall failed
                revert(0, 0)
            }
        }
    }

    //set new cache
    function setCache(address _cacheAddr)
        public
        auth
        note
        returns (bool)
    {
        require(_cacheAddr != 0x0);        // invalid cache address
        cache = DSProxyCache(_cacheAddr);  // overwrite cache
        return true;
    }
}

// DSProxyFactory
// This factory deploys new proxy instances through build()
// Deployed proxy addresses are logged
contract DSProxyFactory {
    event Created(address indexed sender, address indexed owner, address proxy, address cache);
    mapping(address=>bool) public isProxy;
    DSProxyCache public cache = new DSProxyCache();

    // deploys a new proxy instance
    // sets owner of proxy to caller
    function build() public returns (DSProxy proxy) {
        proxy = build(msg.sender);
    }

    // deploys a new proxy instance
    // sets custom owner of proxy
    function build(address owner) public returns (DSProxy proxy) {
        proxy = new DSProxy(cache);
        emit Created(msg.sender, owner, address(proxy), address(cache));
        proxy.setOwner(owner);
        isProxy[proxy] = true;
    }
}

// DSProxyCache
// This global cache stores addresses of contracts previously deployed
// by a proxy. This saves gas from repeat deployment of the same
// contracts and eliminates blockchain bloat.

// By default, all proxies deployed from the same factory store
// contracts in the same cache. The cache a proxy instance uses can be
// changed.  The cache uses the sha3 hash of a contract's bytecode to
// lookup the address
contract DSProxyCache {
    mapping(bytes32 => address) cache;

    function read(bytes _code) public view returns (address) {
        bytes32 hash = keccak256(_code);
        return cache[hash];
    }

    function write(bytes _code) public returns (address target) {
        assembly {
            target := create(0, add(_code, 0x20), mload(_code))
            switch iszero(extcodesize(target))
            case 1 {
                // throw if contract failed to deploy
                revert(0, 0)
            }
        }
        bytes32 hash = keccak256(_code);
        cache[hash] = target;
    }
}",1439
RealWorld_TA_66_ERC20_RealWorld_20240809020525.log,66,ERC20,145620,4032,149652,119.0,0.80874,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;
import ""./IERC20.sol"";
import ""./Domain.sol"";

// solhint-disable no-inline-assembly
// solhint-disable not-rely-on-time

// Data part taken out for building of contracts that receive delegate calls
contract ERC20Data {
    /// @notice owner > balance mapping.
    mapping(address => uint256) public balanceOf;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;
}

abstract contract ERC20 is IERC20, Domain {
    /// @notice owner > balance mapping.
    mapping(address => uint256) public override balanceOf;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param amount of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 amount) public returns (bool) {
        // If `amount` is 0, or `msg.sender` is `to` nothing happens
        if (amount != 0 || msg.sender == to) {
            uint256 srcBalance = balanceOf[msg.sender];
            require(srcBalance >= amount, ""ERC20: balance too low"");
            if (msg.sender != to) {
                require(to != address(0), ""ERC20: no zero address""); // Moved down so low balance calls safe some gas

                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked
                balanceOf[to] += amount;
            }
        }
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param amount The token amount to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        // If `amount` is 0, or `from` is `to` nothing happens
        if (amount != 0) {
            uint256 srcBalance = balanceOf[from];
            require(srcBalance >= amount, ""ERC20: balance too low"");

            if (from != to) {
                uint256 spenderAllowance = allowance[from][msg.sender];
                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
                if (spenderAllowance != type(uint256).max) {
                    require(spenderAllowance >= amount, ""ERC20: allowance too low"");
                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked
                }
                require(to != address(0), ""ERC20: no zero address""); // Moved down so other failed calls safe some gas

                balanceOf[from] = srcBalance - amount; // Underflow is checked
                balanceOf[to] += amount;
            }
        }
        emit Transfer(from, to, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""ERC20: Owner cannot be 0"");
        require(block.timestamp < deadline, ""ERC20: Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""ERC20: Invalid Signature""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }
}

contract ERC20WithSupply is IERC20, ERC20 {
    uint256 public override totalSupply;

    function _mint(address user, uint256 amount) internal {
        uint256 newTotalSupply = totalSupply + amount;
        require(newTotalSupply >= totalSupply, ""Mint overflow"");
        totalSupply = newTotalSupply;
        balanceOf[user] += amount;
        emit Transfer(address(0), user, amount);
    }

    function _burn(address user, uint256 amount) internal {
        require(balanceOf[user] >= amount, ""Burn too much"");
        totalSupply -= amount;
        balanceOf[user] -= amount;
        emit Transfer(user, address(0), amount);
    }
}",1500
RealWorld_TA_66_LiquityBase_RealWorld_20240808232335.log,66,LiquityBase,134064,4283,138347,107.0,0.75598,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./LiquityMath.sol"";
import ""../Interfaces/IActivePool.sol"";
import ""../Interfaces/IDefaultPool.sol"";
import ""../Interfaces/ILiquityBase.sol"";
import ""./YetiCustomBase.sol"";


/* 
* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and
* common functions. 
*/
contract LiquityBase is ILiquityBase, YetiCustomBase {

    uint constant public _100pct = 1e18; // 1e18 == 100%

    uint constant public _110pct = 11e17; // 1.1e18 == 110%

    // Minimum collateral ratio for individual troves
    uint constant public MCR = 11e17; // 110%

    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.
    uint constant public CCR = 15e17; // 150%

    // Amount of YUSD to be locked in gas pool on opening troves
    uint constant public YUSD_GAS_COMPENSATION = 200e18;

    // Minimum amount of net YUSD debt a must have
    uint constant public MIN_NET_DEBT = 1800e18;
    // uint constant public MIN_NET_DEBT = 0; 

    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%

    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%
    uint constant public REDEMPTION_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%

    IActivePool internal activePool;

    IDefaultPool internal defaultPool;

    // --- Gas compensation functions ---

    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation
    function _getCompositeDebt(uint _debt) internal pure returns (uint) {
        return _debt.add(YUSD_GAS_COMPENSATION);
    }


    function _getNetDebt(uint _debt) internal pure returns (uint) {
        return _debt.sub(YUSD_GAS_COMPENSATION);
    }



    // Return the system's Total Virtual Coin Balance
    // Virtual Coins are a way to keep track of the system collateralization given
    // the collateral ratios of each collateral type
    function getEntireSystemColl() public view returns (uint) {
        uint activeColl = activePool.getVC();
        uint liquidatedColl = defaultPool.getVC();

        return activeColl.add(liquidatedColl);
    }


    function getEntireSystemDebt() public override view returns (uint) {
        uint activeDebt = activePool.getYUSDDebt();
        uint closedDebt = defaultPool.getYUSDDebt();

        return activeDebt.add(closedDebt);
    }


    function _getICRColls(newColls memory _colls, uint _debt) internal view returns (uint ICR) {
        uint totalVC = _getVCColls(_colls);
        ICR = LiquityMath._computeCR(totalVC, _debt);
    }


    function _getVC(address[] memory _tokens, uint[] memory _amounts) internal view returns (uint totalVC) {
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""Not same length"");
        for (uint256 i; i < tokensLen; ++i) {
            uint tokenVC = whitelist.getValueVC(_tokens[i], _amounts[i]);
            totalVC = totalVC.add(tokenVC);
        }
    }


    function _getVCColls(newColls memory _colls) internal view returns (uint VC) {
        uint256 tokensLen = _colls.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            uint valueVC = whitelist.getValueVC(_colls.tokens[i], _colls.amounts[i]);
            VC = VC.add(valueVC);
        }
    }


    function _getUSDColls(newColls memory _colls) internal view returns (uint USDValue) {
        uint256 tokensLen = _colls.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            uint valueUSD = whitelist.getValueUSD(_colls.tokens[i], _colls.amounts[i]);
            USDValue = USDValue.add(valueUSD);
        }
    }


    function _getTCR() internal view returns (uint TCR) {
        uint entireSystemColl = getEntireSystemColl();
        uint entireSystemDebt = getEntireSystemDebt();
        
        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt);
    }


    function _checkRecoveryMode() internal view returns (bool) {
        uint TCR = _getTCR();
        return TCR < CCR;
    }

    // fee and amount are denominated in dollar
    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {
        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);
        require(feePercentage <= _maxFeePercentage, ""Fee > max"");
    }

    // checks coll has a nonzero balance of at least one token in coll.tokens
    function _CollsIsNonZero(newColls memory _colls) internal pure returns (bool) {
        uint256 tokensLen = _colls.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            if (_colls.amounts[i] != 0) {
                return true;
            }
        }
        return false;
    }


    // Check whether or not the system *would be* in Recovery Mode, given the entire system coll and debt.
    // returns true if the system would be in recovery mode and false if not
    function _checkPotentialRecoveryMode(uint _entireSystemColl, uint _entireSystemDebt)
    internal
    pure
    returns (bool)
    {
        uint TCR = LiquityMath._computeCR(_entireSystemColl, _entireSystemDebt);

        return TCR < CCR;
    }



}",1360
RealWorld_TA_66_LUSDTokenCaller_RealWorld_20240808234342.log,66,LUSDTokenCaller,37363,3760,41123,102.0,0.262015,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IYUSDToken.sol"";

contract YUSDTokenCaller {
    IYUSDToken YUSD;

    function setYUSD(IYUSDToken _YUSD) external {
        YUSD = _YUSD;
    }

    function yusdMint(address _account, uint _amount) external {
        YUSD.mint(_account, _amount);
    }

    function yusdBurn(address _account, uint _amount) external {
        YUSD.burn(_account, _amount);
    }

    function yusdSendToPool(address _sender,  address _poolAddress, uint256 _amount) external {
        YUSD.sendToPool(_sender, _poolAddress, _amount);
    }

    function yusdReturnFromPool(address _poolAddress, address _receiver, uint256 _amount ) external {
        YUSD.returnFromPool(_poolAddress, _receiver, _amount);
    }
}",211
RealWorld_TA_66_MockTellor_RealWorld_20240809001818.log,66,MockTellor,42575,3805,46380,111.0,0.288975,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


contract MockTellor {

    // --- Mock price data ---

    bool didRetrieve = true; // default to a positive retrieval
    uint private price;
    uint private updateTime;

    bool private revertRequest;

    // --- Setters for mock price data ---

    function setPrice(uint _price) external {
        price = _price;
    }

      function setDidRetrieve(bool _didRetrieve) external {
        didRetrieve = _didRetrieve;
    }

    function setUpdateTime(uint _updateTime) external {
        updateTime = _updateTime;
    }

      function setRevertRequest() external {
        revertRequest = !revertRequest;
    }

    // --- Mock data reporting functions --- 

    function getTimestampbyRequestIDandIndex(uint, uint) external view returns (uint) {
        return updateTime;
    }

    function getNewValueCountbyRequestId(uint) external view returns (uint) {
        if (revertRequest) {require (1 == 0, ""Tellor request reverted"");}
        return 1;
    }

    function retrieveData(uint256, uint256) external view returns (uint256) {
        return price;
    }



}",257
RealWorld_TA_66_IERC20_RealWorld_20240809005927.log,66,IERC20,77961,1610,79571,81.0,0.422005,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

/**
 * Based on the OpenZeppelin IER20 interface:
 * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol
 *
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",724
RealWorld_TA_66_Address_RealWorld_20240808232941.log,66,Address,166976,2325,169301,91.0,0.88138,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.11;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size != 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.3._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.3._
     */
    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length != 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1774
RealWorld_TA_66_ITellor_RealWorld_20240809010813.log,66,ITellor,387669,4307,391976,163.0,2.024485,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;

interface ITellor {
    /**
     * @dev Helps initialize a dispute by assigning it a disputeId
     * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the
     * invalidated value information to POS voting
     * @param _requestId being disputed
     * @param _timestamp being disputed
     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value
     * requires 5 miners to submit a value.
     */
    function beginDispute(
        uint256 _requestId,
        uint256 _timestamp,
        uint256 _minerIndex
    ) external;

    /**
     * @dev Allows token holders to vote
     * @param _disputeId is the dispute id
     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)
     */
    function vote(uint256 _disputeId, bool _supportsDispute) external;

    /**
     * @dev tallies the votes.
     * @param _disputeId is the dispute id
     */
    function tallyVotes(uint256 _disputeId) external;

    /**
     * @dev Allows for a fork to be proposed
     * @param _propNewTellorAddress address for new proposed Tellor
     */
    function proposeFork(address _propNewTellorAddress) external;

    /**
     * @dev Add tip to Request value from oracle
     * @param _requestId being requested to be mined
     * @param _tip amount the requester is willing to pay to be get on queue. Miners
     * mine the onDeckQueryHash, or the api with the highest payout pool
     */
    function addTip(uint256 _requestId, uint256 _tip) external;

    /**
     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)
     * @param _nonce uint submitted by miner
     * @param _requestId the apiId being mined
     * @param _value of api query
     *
     */
    function submitMiningSolution(
        string calldata _nonce,
        uint256 _requestId,
        uint256 _value
    ) external;

    /**
     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)
     * @param _nonce uint submitted by miner
     * @param _requestId is the array of the 5 PSR's being mined
     * @param _value is an array of 5 values
     */
    function submitMiningSolution(
        string calldata _nonce,
        uint256[5] calldata _requestId,
        uint256[5] calldata _value
    ) external;

    /**
     * @dev Allows the current owner to propose transfer control of the contract to a
     * newOwner and the ownership is pending until the new owner calls the claimOwnership
     * function
     * @param _pendingOwner The address to transfer ownership to.
     */
    function proposeOwnership(address payable _pendingOwner) external;

    /**
     * @dev Allows the new owner to claim control of the contract
     */
    function claimOwnership() external;

    /**
     * @dev This function allows miners to deposit their stake.
     */
    function depositStake() external;

    /**
     * @dev This function allows stakers to request to withdraw their stake (no longer stake)
     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they
     * can withdraw the stake
     */
    function requestStakingWithdraw() external;

    /**
     * @dev This function allows users to withdraw their stake after a 7 day waiting period from request
     */
    function withdrawStake() external;

    /**
     * @dev This function approves a _spender an _amount of tokens to use
     * @param _spender address
     * @param _amount amount the spender is being approved for
     * @return true if spender appproved successfully
     */
    function approve(address _spender, uint256 _amount) external returns (bool);

    /**
     * @dev Allows for a transfer of tokens to _to
     * @param _to The address to send tokens to
     * @param _amount The amount of tokens to send
     * @return true if transfer is successful
     */
    function transfer(address _to, uint256 _amount) external returns (bool);

    /**
     * @dev Sends _amount tokens to _to from _from on the condition it
     * is approved by _from
     * @param _from The address holding the tokens being transferred
     * @param _to The address of the recipient
     * @param _amount The amount of tokens to be transferred
     * @return True if the transfer was successful
     */
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) external returns (bool);

    /**
     * @dev Allows users to access the token's name
     */
    function name() external pure returns (string memory);

    /**
     * @dev Allows users to access the token's symbol
     */
    function symbol() external pure returns (string memory);

    /**
     * @dev Allows users to access the number of decimals
     */
    function decimals() external pure returns (uint8);

    /**
     * @dev Getter for the current variables that include the 5 requests Id's
     * @return _challenge _requestIds _difficultky _tip the challenge, 5 requestsId, difficulty and tip
     */
    function getNewCurrentVariables()
        external
        view
        returns (
            bytes32 _challenge,
            uint256[5] memory _requestIds,
            uint256 _difficutly,
            uint256 _tip
        );

    /**
     * @dev Getter for the top tipped 5 requests Id's
     * @return _requestIds the 5 requestsId
     */
    function getTopRequestIDs()
        external
        view
        returns (uint256[5] memory _requestIds);

    /**
     * @dev Getter for the 5 requests Id's next in line to get mined
     * @return idsOnDeck tipsOnDeck  the 5 requestsId
     */
    function getNewVariablesOnDeck()
        external
        view
        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);

    /**
     * @dev Updates the Tellor address after a proposed fork has
     * passed the vote and day has gone by without a dispute
     * @param _disputeId the disputeId for the proposed fork
     */
    function updateTellor(uint256 _disputeId) external;

    /**
     * @dev Allows disputer to unlock the dispute fee
     * @param _disputeId to unlock fee from
     */
    function unlockDisputeFee(uint256 _disputeId) external;

    /**
     * @param _user address
     * @param _spender address
     * @return Returns the remaining allowance of tokens granted to the _spender from the _user
     */
    function allowance(address _user, address _spender)
        external
        view
        returns (uint256);

    /**
     * @dev This function returns whether or not a given user is allowed to trade a given amount
     * @param _user address
     * @param _amount uint of amount
     * @return true if the user is alloed to trade the amount specified
     */
    function allowedToTrade(address _user, uint256 _amount)
        external
        view
        returns (bool);

    /**
     * @dev Gets balance of owner specified
     * @param _user is the owner address used to look up the balance
     * @return Returns the balance associated with the passed in _user
     */
    function balanceOf(address _user) external view returns (uint256);

    /**
     * @dev Queries the balance of _user at a specific _blockNumber
     * @param _user The address from which the balance will be retrieved
     * @param _blockNumber The block number when the balance is queried
     * @return The balance at _blockNumber
     */
    function balanceOfAt(address _user, uint256 _blockNumber)
        external
        view
        returns (uint256);

    /**
     * @dev This function tells you if a given challenge has been completed by a given miner
     * @param _challenge the challenge to search for
     * @param _miner address that you want to know if they solved the challenge
     * @return true if the _miner address provided solved the
     */
    function didMine(bytes32 _challenge, address _miner)
        external
        view
        returns (bool);

    /**
     * @dev Checks if an address voted in a given dispute
     * @param _disputeId to look up
     * @param _address to look up
     * @return bool of whether or not party voted
     */
    function didVote(uint256 _disputeId, address _address)
        external
        view
        returns (bool);

    /**
     * @dev allows Tellor to read data from the addressVars mapping
     * @param _data is the keccak256(""variable_name"") of the variable that is being accessed.
     * These are examples of how the variables are saved within other functions:
     * addressVars[keccak256(""_owner"")]
     * addressVars[keccak256(""tellorContract"")]
     * return address
     */
    function getAddressVars(bytes32 _data) external view returns (address);

    /**
     * @dev Gets all dispute variables
     * @param _disputeId to look up
     * @return bytes32 hash of dispute
     * @return bool executed where true if it has been voted on
     * @return bool disputeVotePassed
     * @return bool isPropFork true if the dispute is a proposed fork
     * @return address of reportedMiner
     * @return address of reportingParty
     * @return address of proposedForkAddress
     *    uint of requestId
     *    uint of timestamp
     *    uint of value
     *    uint of minExecutionDate
     *    uint of numberOfVotes
     *    uint of blocknumber
     *    uint of minerSlot
     *    uint of quorum
     *    uint of fee
     * @return int count of the current tally
     */
    function getAllDisputeVars(uint256 _disputeId)
        external
        view
        returns (
            bytes32,
            bool,
            bool,
            bool,
            address,
            address,
            address,
            uint256[9] memory,
            int256
        );

    /**
     * @dev Getter function for variables for the requestId being currently mined(currentRequestId)
     * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request
     */
    function getCurrentVariables()
        external
        view
        returns (
            bytes32,
            uint256,
            uint256,
            string memory,
            uint256,
            uint256
        );

    /**
     * @dev Checks if a given hash of miner,requestId has been disputed
     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));
     * @return uint disputeId
     */
    function getDisputeIdByDisputeHash(bytes32 _hash)
        external
        view
        returns (uint256);

    /**
     * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId
     * @param _disputeId is the dispute id;
     * @param _data the variable to pull from the mapping. _data = keccak256(""variable_name"") where variable_name is
     * the variables/strings used to save the data in the mapping. The variables names are
     * commented out under the disputeUintVars under the Dispute struct
     * @return uint value for the bytes32 data submitted
     */
    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)
        external
        view
        returns (uint256);

    /**
     * @dev Gets the a value for the latest timestamp available
     * @return value for timestamp of last proof of work submited
     * @return true if the is a timestamp for the lastNewValue
     */
    function getLastNewValue() external view returns (uint256, bool);

    /**
     * @dev Gets the a value for the latest timestamp available
     * @param _requestId being requested
     * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't
     */
    function getLastNewValueById(uint256 _requestId)
        external
        view
        returns (uint256, bool);

    /**
     * @dev Gets blocknumber for mined timestamp
     * @param _requestId to look up
     * @param _timestamp is the timestamp to look up blocknumber
     * @return uint of the blocknumber which the dispute was mined
     */
    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)
        external
        view
        returns (uint256);

    /**
     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp
     * @param _requestId to look up
     * @param _timestamp is the timestamp to look up miners for
     * @return the 5 miners' addresses
     */
    function getMinersByRequestIdAndTimestamp(
        uint256 _requestId,
        uint256 _timestamp
    ) external view returns (address[5] memory);

    /**
     * @dev Counts the number of values that have been submited for the request
     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that
     * request so far
     * @param _requestId the requestId to look up
     * @return uint count of the number of values received for the requestId
     */
    function getNewValueCountbyRequestId(uint256 _requestId)
        external
        view
        returns (uint256);

    /**
     * @dev Getter function for the specified requestQ index
     * @param _index to look up in the requestQ array
     * @return uint of reqeuestId
     */
    function getRequestIdByRequestQIndex(uint256 _index)
        external
        view
        returns (uint256);

    /**
     * @dev Getter function for requestId based on timestamp
     * @param _timestamp to check requestId
     * @return uint of reqeuestId
     */
    function getRequestIdByTimestamp(uint256 _timestamp)
        external
        view
        returns (uint256);

    /**
     * @dev Getter function for requestId based on the queryHash
     * @param _request is the hash(of string api and granularity) to check if a request already exists
     * @return uint requestId
     */
    function getRequestIdByQueryHash(bytes32 _request)
        external
        view
        returns (uint256);

    /**
     * @dev Getter function for the requestQ array
     * @return the requestQ arrray
     */
    function getRequestQ() external view returns (uint256[51] memory);

    /**
     * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct
     * for the requestId specified
     * @param _requestId to look up
     * @param _data the variable to pull from the mapping. _data = keccak256(""variable_name"") where variable_name is
     * the variables/strings used to save the data in the mapping. The variables names are
     * commented out under the apiUintVars under the requestDetails struct
     * @return uint value of the apiUintVars specified in _data for the requestId specified
     */
    function getRequestUintVars(uint256 _requestId, bytes32 _data)
        external
        view
        returns (uint256);

    /**
     * @dev Gets the API struct variables that are not mappings
     * @param _requestId to look up
     * @return string of api to query
     * @return string of symbol of api to query
     * @return bytes32 hash of string
     * @return bytes32 of the granularity(decimal places) requested
     * @return uint of index in requestQ array
     * @return uint of current payout/tip for this requestId
     */
    function getRequestVars(uint256 _requestId)
        external
        view
        returns (
            string memory,
            string memory,
            bytes32,
            uint256,
            uint256,
            uint256
        );

    /**
     * @dev This function allows users to retireve all information about a staker
     * @param _staker address of staker inquiring about
     * @return uint current state of staker
     * @return uint startDate of staking
     */
    function getStakerInfo(address _staker)
        external
        view
        returns (uint256, uint256);

    /**
     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp
     * @param _requestId to look up
     * @param _timestamp is the timestampt to look up miners for
     * @return address[5] array of 5 addresses ofminers that mined the requestId
     */
    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)
        external
        view
        returns (uint256[5] memory);

    /**
     * @dev Gets the timestamp for the value based on their index
     * @param _requestID is the requestId to look up
     * @param _index is the value index to look up
     * @return uint timestamp
     */
    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)
        external
        view
        returns (uint256);

    /**
     * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable
     * @param _data the variable to pull from the mapping. _data = keccak256(""variable_name"") where variable_name is
     * the variables/strings used to save the data in the mapping. The variables names are
     * commented out under the uintVars under the TellorStorageStruct struct
     * This is an example of how data is saved into the mapping within other functions:
     * self.uintVars[keccak256(""stakerCount"")]
     * @return uint of specified variable
     */
    function getUintVar(bytes32 _data) external view returns (uint256);

    /**
     * @dev Getter function for next requestId on queue/request with highest payout at time the function is called
     * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string
     */
    function getVariablesOnDeck()
        external
        view
        returns (
            uint256,
            uint256,
            string memory
        );

    /**
     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp
     * @param _requestId to look up
     * @param _timestamp is the timestamp to look up miners for
     * @return bool true if requestId/timestamp is under dispute
     */
    function isInDispute(uint256 _requestId, uint256 _timestamp)
        external
        view
        returns (bool);

    /**
     * @dev Retreive value from oracle based on timestamp
     * @param _requestId being requested
     * @param _timestamp to retreive data/value from
     * @return value for timestamp submitted
     */
    function retrieveData(uint256 _requestId, uint256 _timestamp)
        external
        view
        returns (uint256);

    /**
     * @dev Getter for the total_supply of oracle tokens
     * @return uint total supply
     */
    function totalSupply() external view returns (uint256);
}",4340
RealWorld_TA_66_ILPTokenWrapper_RealWorld_20240808231837.log,66,ILPTokenWrapper,24257,1388,25645,70.0,0.149045,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


interface ILPTokenWrapper {
    function stake(uint256 amount) external;
    function withdraw(uint256 amount) external;
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}",69
RealWorld_TA_66_ITraderJoeZap_RealWorld_20240809011337.log,66,ITraderJoeZap,21912,2022,23934,79.0,0.15,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ITraderJoeZap {
    function zapOut(address _from, uint256 amount) external;
}",40
RealWorld_TA_66_ITroveManagerRedemptions_RealWorld_20240809012927.log,66,ITroveManagerRedemptions,27401,1465,28866,72.0,0.166305,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ITroveManagerRedemptions {
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintNICR,
        uint _maxIterations,
        // uint _maxFeePercentage,
        address _redeemSender
    )
    external;
}",110
RealWorld_TA_66_IPriceCurve_RealWorld_20240809011742.log,66,IPriceCurve,53288,2944,56232,97.0,0.32532,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface IPriceCurve {
    function setAddresses(address _whitelistAddress) external;

    function setDecayTime(uint _decayTime) external;

    /** 
     * Returns fee based on inputted collateral VC balance and total VC balance of system. 
     * fee is in terms of percentage * 1e18. 
     * If the fee were 1%, this would be 0.01 * 1e18 = 1e16
     */
    function getFee(uint256 _collateralVCInput, uint256 _collateralVCBalancePost, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) external view returns (uint256 fee);

    // Same function, updates the fee as well. Called only by whitelist. 
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) external returns (uint256 fee);

    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. 
    // Called only by whitelist. 
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external;

    // Gets the fee cap and time currently. Used for setting new values for next price curve. 
    // returns lastFeePercent, lastFeeTime
    function getFeeCapAndTime() external view returns (uint256 _lastFeePercent, uint256 _lastFeeTime);

    /** 
     * Returns fee based on decay since last fee calculation, which we take to be 
     * a reasonable fee amount. If it has decayed a certain amount since then, we let
     * the new fee amount slide. 
     */
    function calculateDecayedFee() external view returns (uint256 fee);
}",403
RealWorld_TA_66_LPTokenPriceFeed_RealWorld_20240808230608.log,66,LPTokenPriceFeed,54972,2469,57441,83.0,0.32424,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import '../Dependencies/SafeMath.sol';

import '../Dependencies/HomoraMath.sol';
import '../Interfaces/IBaseOracle.sol';
import '../Interfaces/IPriceFeed.sol';
import '../Interfaces/IUniswapV2Pair.sol';
import ""../Dependencies/Ownable.sol"";

contract UniswapV2LPTokenPriceFeed is IPriceFeed, Ownable {
  using SafeMath for uint;
  using HomoraMath for uint;

  IBaseOracle base;
  address pair;

  function setParam(IBaseOracle _base, address _pair) external onlyOwner {
    base = _base;
    pair = _pair;
  }

  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.
  function fetchPrice_v() external view override returns (uint) {
    address token0 = IUniswapV2Pair(pair).token0();
    address token1 = IUniswapV2Pair(pair).token1();
    uint totalSupply = IUniswapV2Pair(pair).totalSupply();
    (uint r0, uint r1, ) = IUniswapV2Pair(pair).getReserves();
    uint sqrtK = HomoraMath.sqrt(r0.mul(r1)).fdiv(totalSupply); // in 2**112
    uint px0 = base.getPrice(token0); // in 2**112
    uint px1 = base.getPrice(token1); // in 2**112
    // fair token0 amt: sqrtK * sqrt(px1/px0)
    // fair token1 amt: sqrtK * sqrt(px0/px1)
    // fair lp price = 2 * sqrt(px0 * px1)
    // split into 2 sqrts multiplication to prevent uint overflow (note the 2**112)
    return sqrtK.mul(2).mul(HomoraMath.sqrt(px0)).div(2**56).mul(HomoraMath.sqrt(px1)).div(2**56);
  }


}",432
RealWorld_TA_66_BorrowerOperations_RealWorld_20240808223855.log,66,BorrowerOperations,1156433,1169,1157602,168.0,5.805545,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/ReentrancyGuard.sol"";
import ""./Interfaces/IWAsset.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, ""BO:MIN_NET_DEBT==0"");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, ""WrongLeverage"");
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), ""BO:RouteLeverUpNotSent"");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, ""WrongSlippage"");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), ""BO:YUSDNotSentUnLever"");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), ""BO:TransferCollsFailed"");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), ""BO:BadColl"");
            require(_amounts[i] != 0, ""BO:NoAmounts"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BO:0Adjust""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), ""BO:TroveInactive"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), ""BO:TroveActive"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, ""BO:NoDebtChange"");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], ""BO:OverlapColls"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BO:InRecMode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BO:InRecMode""
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, ""BOps:Len0"");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, ""BO:LenMismatch"");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BO:ReqICR>MCR""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BO:ReqICR>CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BO:RecMode:ICR<oldICR""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BO:ReqTCR>CCR""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BO:netDebt<2000""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BO:InvalidYUSDRepay""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BO:InsuffYUSDBal""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert(""BO:InvalidMaxFee"");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  ""_requireValidRouterParams: _finalRoutedColls length mismatch"");
    //     require(_amounts.length == _routers.length, ""_requireValidRouterParams: _routers length mismatch"");
    //     require(_amounts.length == _minSwapAmounts.length, ""_minSwapAmounts: finalRoutedColls length mismatch"");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), ""_requireValidRouterParams: not a valid router"");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], ""_requireRouterAVAXIndicesInOrder: indices out of order"");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}",13817
RealWorld_TA_66_IWAsset_RealWorld_20240809013154.log,66,IWAsset,30545,3328,33873,105.0,0.219285,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


// Wrapped Asset
interface IWAsset  {

    function wrap(uint _amount, address _from, address _to, address _rewardOwner) external;
    
    function unwrapFor(address _from, address _to, uint amount) external;

    function updateReward(address from, address to, uint amount) external;

    function claimReward(address _to) external;

    function claimRewardFor(address _for) external;

    function getPendingRewards(address _for) external returns (address[] memory, uint[] memory);

    function endTreasuryReward(address _to, uint _amount) external;
}",141
RealWorld_TA_66_ITroveManager_RealWorld_20240809014306.log,66,ITroveManager,170483,3685,174168,112.0,0.926115,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./ILiquityBase.sol"";
import ""./IStabilityPool.sol"";
import ""./IYUSDToken.sol"";
import ""./IYETIToken.sol"";
import ""./ISYETI.sol"";
import ""./IActivePool.sol"";
import ""./IDefaultPool.sol"";


// Common interface for the Trove Manager.
interface ITroveManager is ILiquityBase {

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YETITokenAddressChanged(address _yetiTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);
    event Redemption(uint _attemptedYUSDAmount, uint _actualYUSDAmount, uint YUSDfee, address[] tokens, uint[] amounts);
    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);
    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);
    event LTermsUpdated(uint _L_ETH, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_YUSDDebt);
    event TroveIndexUpdated(address _borrower, uint _newIndex);

    // --- Functions ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external;

    function stabilityPool() external view returns (IStabilityPool);
    function yusdToken() external view returns (IYUSDToken);
    function yetiToken() external view returns (IYETIToken);
    function sYETI() external view returns (ISYETI);

    function getTroveOwnersCount() external view returns (uint);

    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);

    function getCurrentICR(address _borrower) external view returns (uint);

    function liquidate(address _borrower) external;

    function batchLiquidateTroves(address[] calldata _troveArray, address _liquidator) external;

    function redeemCollateral(
        uint _YUSDAmount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintNICR,
        uint _maxIterations
    ) external;

    function updateStakeAndTotalStakes(address _borrower) external;

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external;

    function updateTroveRewardSnapshots(address _borrower) external;

    function addTroveOwnerToArray(address _borrower) external returns (uint index);

    function applyPendingRewards(address _borrower) external;

//    function getPendingETHReward(address _borrower) external view returns (uint);
    function getPendingCollRewards(address _borrower) external view returns (address[] memory, uint[] memory);

    function getPendingYUSDDebtReward(address _borrower) external view returns (uint);

     function hasPendingRewards(address _borrower) external view returns (bool);

//    function getEntireDebtAndColl(address _borrower) external view returns (
//        uint debt,
//        uint coll,
//        uint pendingYUSDDebtReward,
//        uint pendingETHReward
//    );

    function closeTrove(address _borrower) external;

    function removeStake(address _borrower) external;

    function removeStakeTMR(address _borrower) external;
    function updateTroveDebt(address _borrower, uint debt) external;

    function getRedemptionRate() external view returns (uint);
    function getRedemptionRateWithDecay() external view returns (uint);

    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);

    function getBorrowingRate() external view returns (uint);
    function getBorrowingRateWithDecay() external view returns (uint);

    function getBorrowingFee(uint YUSDDebt) external view returns (uint);
    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view returns (uint);

    function decayBaseRateFromBorrowing() external;

    function getTroveStatus(address _borrower) external view returns (uint);

    function isTroveActive(address _borrower) external view returns (bool);

    function getTroveStake(address _borrower, address _token) external view returns (uint);

    function getTotalStake(address _token) external view returns (uint);

    function getTroveDebt(address _borrower) external view returns (uint);

    function getL_Coll(address _token) external view returns (uint);

    function getL_YUSD(address _token) external view returns (uint);

    function getRewardSnapshotColl(address _borrower, address _token) external view returns (uint);

    function getRewardSnapshotYUSD(address _borrower, address _token) external view returns (uint);

    // returns the VC value of a trove
    function getTroveVC(address _borrower) external view returns (uint);

    function getTroveColls(address _borrower) external view returns (address[] memory, uint[] memory);

    function getCurrentTroveState(address _borrower) external view returns (address[] memory, uint[] memory, uint);

    function setTroveStatus(address _borrower, uint num) external;

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external;

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint);

    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint);

    function getTCR() external view returns (uint);

    function checkRecoveryMode() external view returns (bool);

    function closeTroveRedemption(address _borrower) external;

    function closeTroveLiquidation(address _borrower) external;

    function removeStakeTLR(address _borrower) external;

    function updateBaseRate(uint newBaseRate) external;

    function calcDecayedBaseRate() external view returns (uint);

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external;

    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external;

    function getEntireDebtAndColls(address _borrower) external view
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory);

    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external;

    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external;

}",1827
RealWorld_TA_66_CommunityIssuanceTester_RealWorld_20240808234934.log,66,CommunityIssuanceTester,38292,5803,44095,142.0,0.30752,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../YETI/CommunityIssuance.sol"";

contract CommunityIssuanceTester is CommunityIssuance {
    function obtainYETI(uint _amount) external {
        yetiToken.transfer(msg.sender, _amount);
    }

    function getCumulativeIssuanceFraction() external view returns (uint) {
       return _getCumulativeIssuanceFraction();
    }

    function unprotectedIssueYETI() external returns (uint) {
        // No checks on caller address
       
        uint latestTotalYETIIssued = YETISupplyCap.mul(_getCumulativeIssuanceFraction()).div(DECIMAL_PRECISION);
        uint issuance = latestTotalYETIIssued.sub(totalYETIIssued);
      
        totalYETIIssued = latestTotalYETIIssued;
        return issuance;
    }
}",195
RealWorld_TA_66_IStabilityPool_RealWorld_20240809013736.log,66,IStabilityPool,193418,4063,197481,154.0,1.04835,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./ICollateralReceiver.sol"";

/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an ETH gain, as the ETH collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 */
interface IStabilityPool is ICollateralReceiver {

    // --- Events ---
    
    event StabilityPoolETHBalanceUpdated(uint _newBalance);
    event StabilityPoolYUSDBalanceUpdated(uint _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint _P);
    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);
    event UserDepositChanged(address indexed _depositor, uint _newDeposit);
    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);

    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _YUSDLoss);
    event YETIPaidToDepositor(address indexed _depositor, uint _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint _YETI);
    event EtherSent(address _to, uint _amount);

    // --- Functions ---

    /*
     * Called only once on init, to set addresses of other Liquity contracts
     * Callable only by owner, renounces ownership at the end
     */
    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    )
        external;

    /*
     * Initial checks:
     * - Frontend is registered or zero address
     * - Sender is not a registered frontend
     * - _amount is not zero
     * ---
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, ETH) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint _amount, address _frontEndTag) external;

    /*
     * Initial checks:
     * - _amount is zero or there are no under collateralized troves left in the system
     * - User has a non zero deposit
     * ---
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, ETH) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint _amount) external;


    /*
     * Initial checks:
     * - Frontend (sender) not already registered
     * - User (sender) has no deposit
     * - _kickbackRate is in the range [0, 100%]
     * ---
     * Front end makes a one-time selection of kickback rate upon registering
     */
    function registerFrontEnd(uint _kickbackRate) external;

    /*
     * Initial checks:
     * - Caller is TroveManager
     * ---
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(uint _debt, address[] memory _assets, uint[] memory _amountsAdded) external;

//    /*
//     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,
//     * to exclude edge cases like ETH received from a self-destruct.
//     */
//    function getETH() external view returns (uint);
    
     //*
//     * Calculates and returns the total gains a depositor has accumulated 
//     */
    function  getDepositorGains(address _depositor) external view returns (address[] memory assets, uint[] memory amounts);


    /*
     * Returns the total amount of VC held by the pool, accounted for by multipliying the
     * internal balances of collaterals by the price that is found at the time getVC() is called.
     */
    function getVC() external view returns (uint);

    /*
     * Returns YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
     */
    function getTotalYUSDDeposits() external view returns (uint);

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
     * which they made their deposit.
     */
    function getDepositorYETIGain(address _depositor) external view returns (uint);

    /*
     * Return the YETI gain earned by the front end.
     */
    function getFrontEndYETIGain(address _frontEnd) external view returns (uint);

    /*
     * Return the user's compounded deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) external view returns (uint);

    /*
     * Return the front end's compounded stake.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);

    /*
     * Add collateral type to totalColl 
     */
    function addCollateralType(address _collateral) external;

    function getDepositSnapshotS(address depositor, address collateral) external view returns (uint);

    function getCollateral(address _collateral) external view returns (uint);

    function getAllCollateral() external view returns (address[] memory, uint256[] memory);

}",2087
RealWorld_TA_66_CollSurplusPool_RealWorld_20240808222208.log,66,CollSurplusPool,159454,6402,165856,133.0,0.92531,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Interfaces/IWAsset.sol"";


/**
 * The CollSurplusPool holds all the bonus collateral that occurs from liquidations and
 * redemptions, to be claimed by the trove owner.
 */
contract CollSurplusPool is Ownable, CheckContract, ICollSurplusPool, LiquityBase {
    using SafeMath for uint256;

    string public constant NAME = ""CollSurplusPool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal troveManagerRedemptionsAddress;
    address internal activePoolAddress;

    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts
    newColls internal poolColl;

    // Collateral surplus claimable by trove owners
    mapping(address => newColls) internal balances;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);

    event CollBalanceUpdated(address indexed _account);
    event CollateralSent(address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _troveManagerRedemptionsAddress,
        address _activePoolAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_activePoolAddress);
        checkContract(_whitelistAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        activePoolAddress = _activePoolAddress;
        whitelist = IWhitelist(_whitelistAddress);

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);

        _renounceOwnership();
    }

    /*
     * Returns the VC of the contract
     *
     * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
     *
     * Computed when called by taking the collateral balances and
     * multiplying them by the corresponding price and ratio and then summing that
     */
    function getCollVC() external view override returns (uint256) {
        return _getVCColls(poolColl);
    }

    /*
     * View function for getting the amount claimable by a particular trove owner.
     */
    function getAmountClaimable(address _account, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        if (balances[_account].amounts.length > collateralIndex) {
            return balances[_account].amounts[collateralIndex];
        }
        return 0;
    }

    /*
     * Returns the collateralBalance for a given collateral
     *
     * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
     */
    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return poolColl.amounts[collateralIndex];
    }

    /*
     *
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // --- Pool functionality ---

    // Surplus value is accounted by the trove manager.
    function accountSurplus(
        address _account,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) external override {
        _requireCallerIsTroveManager();
        balances[_account] = _sumColls(balances[_account], _tokens, _amounts);
        emit CollBalanceUpdated(_account);
    }

    // Function called by borrower operations which claims the collateral that is owned by
    // a particular trove user.
    function claimColl(address _account) external override {
        _requireCallerIsBorrowerOperations();

        newColls memory claimableColl = balances[_account];
        require(_CollsIsNonZero(claimableColl), ""CSP: No collateral available"");

        balances[_account].amounts = new uint256[](poolColl.tokens.length); // sets balance of account to 0
        emit CollBalanceUpdated(_account);

        poolColl.amounts = _leftSubColls(poolColl, claimableColl.tokens, claimableColl.amounts);
        emit CollateralSent(_account);

        bool success = _sendColl(_account, claimableColl);
        require(success, ""CSP: sending Collateral failed"");
    }

    // --- 'require' functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (
            msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTroveManager() internal view {
        if (
            msg.sender != troveManagerAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != activePoolAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert(""CSP: External caller not allowed"");
    }

    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
    }

    // Adds collateral type from the whitelist.
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

    // Function to send collateral out to an address, and checks if the asset is wrapped so that it can 
    // unwrap in that case. 
    function _sendColl(address _to, newColls memory _colls) internal returns (bool) {
        uint256 tokensLen = _colls.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                // CSP actually owns these assets so it transfers it from this contract to the _to param. 
                IWAsset(token).unwrapFor(_to, _to, _colls.amounts[i]);
            } else {
                // Otherwise transfer like normal ERC20
                if (!IERC20(token).transfer(_to, _colls.amounts[i])) {
                    return false;
                }
            }
        }
        return true;
    }
}",1640
RealWorld_TA_66_IMasterChefJoeV2_RealWorld_20240809004901.log,66,IMasterChefJoeV2,35503,1866,37369,77.0,0.214835,"pragma solidity 0.8.7;

import ""./IRewarder.sol"";


interface IMasterChefJoeV2 {
    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. JOEs to distribute per second.
        uint256 lastRewardTimestamp; // Last timestamp that JOEs distribution occurs.
        uint256 accJoePerShare; // Accumulated JOEs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    // Deposit LP tokens to MasterChef for JOE allocation.
    function deposit(uint256 _pid, uint256 _amount) external;

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) external;

    // get data on a pool given _pid
    function poolInfo(uint _pid) external returns (PoolInfo memory pool);
}",203
RealWorld_TA_66_IBaseOracle_RealWorld_20240809011620.log,66,IBaseOracle,24735,1982,26717,81.0,0.163315,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface IBaseOracle {
  /// @dev Return the value of the given input as USD per unit.
  /// @param token The ERC-20 token to check the value.
  function getPrice(address token) external view returns (uint);

}",67
RealWorld_TA_66_LiquityBaseTester_RealWorld_20240809003005.log,66,LiquityBaseTester,99156,3335,102491,96.0,0.56248,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;
// pragma experimental ABIEncoderV2;

import ""../Dependencies/LiquityBase.sol"";

// test contract to test Liquity base functions with custom newColls struct
contract LiquityBaseTester is LiquityBase {

    event Sum(address[] tokens, uint[] amounts);

    function setAddresses(address _whitelist, address _defaultPool, address _activePool) external {
        whitelist = IWhitelist(_whitelist);
        defaultPool = IDefaultPool(_defaultPool);
        activePool = IActivePool(_activePool);
    }

    function _toColls(address[] memory _colls, uint[] memory _amounts) internal pure returns (newColls memory colls) {
        colls.tokens = _colls;
        colls.amounts = _amounts;
    }

    function createCollExample() external pure returns (address[] memory tokens, uint[] memory amounts) {
        tokens = new address[](2);
        amounts = new uint[](2);
        tokens[0] = address(1);
        tokens[1] = address(2);
        amounts[0] = 1e18;
        amounts[1] = 2e18;
    }

    // call sumColls with two newColls struct
    function sumCollsTwoColls(address[] memory _tokens1, uint[] memory _amounts1,
                        address[] memory _tokens2, uint[] memory _amounts2) external returns
    (address[] memory, uint[] memory) {
        newColls memory resultOfSum = _sumColls(newColls(_tokens1, _amounts1), newColls(_tokens2, _amounts2));
        emit Sum(resultOfSum.tokens, resultOfSum.amounts);
        return (resultOfSum.tokens, resultOfSum.amounts);
    }

    // call sumColls with one newColls struct and one split into arrays
    function sumCollsOneCollsOneSplit(address[] memory _tokens1, uint[] memory _amounts1,
        address[] memory _tokens2, uint[] memory _amounts2) external returns
    (address[] memory, uint[] memory) {
        newColls memory resultOfSum = _sumColls(newColls(_tokens1, _amounts1), _tokens2, _amounts2);
        emit Sum(resultOfSum.tokens, resultOfSum.amounts);
        return (resultOfSum.tokens, resultOfSum.amounts);
    }

    // call sumColls with one newColls struct and one split into arrays
    function sumCollsTwoSplit(address[] memory _tokens1, uint[] memory _amounts1,
        address[] memory _tokens2, uint[] memory _amounts2) external returns
    (address[] memory, uint[] memory) {
        newColls memory resultOfSum = _sumColls(_tokens1, _amounts1, _tokens2, _amounts2);
        emit Sum(resultOfSum.tokens, resultOfSum.amounts);
        return (resultOfSum.tokens, resultOfSum.amounts);
    }

    // call _leftSumColls
    function leftSumColls(address[] memory _tokens1, uint[] memory _amounts1,
        address[] memory _tokens2, uint[] memory _amounts2) external {
        uint[] memory sumAmounts = _leftSumColls(newColls(_tokens1, _amounts1), _tokens2, _amounts2);
        address[] memory tokens;
        emit Sum(tokens, sumAmounts);
    }

    // call _leftSubColls
    function leftSubColls(address[] memory _tokens1, uint[] memory _amounts1,
        address[] memory _tokens2, uint[] memory _amounts2) external {
        uint[] memory diffAmounts = _leftSubColls(newColls(_tokens1, _amounts1), _tokens2, _amounts2);
        address[] memory tokens;
        emit Sum(tokens, diffAmounts);
    }

    // call _subColls
    function subColls(address[] memory _tokens1, uint[] memory _amounts1,
        address[] memory _tokens2, uint[] memory _amounts2) external {
        newColls memory diff = _subColls(newColls(_tokens1, _amounts1), _tokens2, _amounts2);
        emit Sum(diff.tokens, diff.amounts);
    }
}",952
RealWorld_TA_66_IJoeZapper_RealWorld_20240809011217.log,66,IJoeZapper,24404,1643,26047,78.0,0.15488,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

// Interface for Joe zapper which can take any token or avax payable. 
interface IJoeZapper {
    function zapInToken(address _from, uint256 amount, address _to) external;

    function zapIn(address _to) external payable;
}",72
RealWorld_TA_66_LockupContractFactory_RealWorld_20240809015730.log,66,LockupContractFactory,76754,2686,79440,87.0,0.43749,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/CheckContract.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";
import ""../Interfaces/ILockupContractFactory.sol"";
import ""./LockupContract.sol"";

/*
* The LockupContractFactory deploys LockupContracts - its main purpose is to keep a registry of valid deployed 
* LockupContracts. 
* 
* This registry is checked by YETIToken when the Liquity deployer attempts to transfer YETI tokens. During the first year
* since system deployment, the Liquity deployer is only allowed to transfer YETI to valid LockupContracts that have been
* deployed by and recorded in the LockupContractFactory. This ensures the deployer's YETI can't be traded or staked in the
* first year, and can only be sent to a verified LockupContract which unlocks at least one year after system deployment.
*
* LockupContracts can of course be deployed directly, but only those deployed through and recorded in the LockupContractFactory 
* will be considered ""valid"" by YETIToken. This is a convenient way to verify that the target address is a genuine
* LockupContract.
*/

contract LockupContractFactory is ILockupContractFactory, Ownable, CheckContract {
    using SafeMath for uint;

    // --- Data ---
    bytes32 constant public NAME = ""LockupContractFactory"";

    uint constant public SECONDS_IN_ONE_YEAR = 31536000;

    address public yetiTokenAddress;
    
    mapping (address => address) public lockupContractToDeployer;

    // --- Events ---

    event YETITokenAddressSet(address _yetiTokenAddress);
    event LockupContractDeployedThroughFactory(address _lockupContractAddress, address _beneficiary, uint _unlockTime, address _deployer);

    // --- Functions ---

    function setYETITokenAddress(address _yetiTokenAddress) external override onlyOwner {
        checkContract(_yetiTokenAddress);

        yetiTokenAddress = _yetiTokenAddress;
        emit YETITokenAddressSet(_yetiTokenAddress);

        _renounceOwnership();
    }

    function deployLockupContract(address _beneficiary, uint _unlockTime) external override {
        address yetiTokenAddressCached = yetiTokenAddress;
        _requireYETIAddressIsSet(yetiTokenAddressCached);
        LockupContract lockupContract = new LockupContract(
                                                        yetiTokenAddressCached,
                                                        _beneficiary, 
                                                        _unlockTime);

        lockupContractToDeployer[address(lockupContract)] = msg.sender;
        emit LockupContractDeployedThroughFactory(address(lockupContract), _beneficiary, _unlockTime, msg.sender);
    }

    function isRegisteredLockup(address _contractAddress) public view override returns (bool) {
        return lockupContractToDeployer[_contractAddress] != address(0);
    }

    // --- 'require'  functions ---
    function _requireYETIAddressIsSet(address _yetiTokenAddress) internal pure {
        require(_yetiTokenAddress != address(0), ""LCF: YETI Address is not set"");
    }
}",684
RealWorld_TA_66_BaseMath_RealWorld_20240808232218.log,66,BaseMath,21469,1263,22732,75.0,0.132605,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;


contract BaseMath {
    uint constant public DECIMAL_PRECISION = 1e18;
}",37
RealWorld_TA_66_PriceFeedTester_RealWorld_20240808235914.log,66,PriceFeedTester,26173,3166,29339,96.0,0.194185,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../PriceFeed.sol"";

contract PriceFeedTester is PriceFeed {

    function setLastGoodPrice(uint _lastGoodPrice) external {
        lastGoodPrice = _lastGoodPrice;
    }

    function setStatus(Status _status) external {
        status = _status;
    }
}",76
RealWorld_TA_66_HintHelpers_RealWorld_20240808220934.log,66,HintHelpers,174239,4454,178693,125.0,0.960275,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";

/** 
 * Hint helpers is a contract for giving approximate insert positions for a trove after 
 * an operation, such as partial redemption re-insert, adjust trove, etc. 
 */

contract HintHelpers is LiquityBase, Ownable, CheckContract {
    bytes32 constant public NAME = ""HintHelpers"";

    ISortedTroves internal sortedTroves;
    ITroveManager internal troveManager;

    // --- Events ---

    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event TroveManagerAddressChanged(address _troveManagerAddress);
    event WhitelistAddressChanged(address _troveManagerAddress);

    // --- Dependency setters ---

    function setAddresses(
        address _sortedTrovesAddress,
        address _troveManagerAddress,
        address _whitelistAddress
    )
        external
        onlyOwner
    {
        checkContract(_sortedTrovesAddress);
        checkContract(_troveManagerAddress);
        checkContract(_whitelistAddress);

        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        whitelist = IWhitelist(_whitelistAddress);

        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit WhitelistAddressChanged(_troveManagerAddress);

        _renounceOwnership();
    }

    // --- Functions ---

    /* getRedemptionHints() - Helper function for finding the right hints to pass to redeemCollateral().
     *
     * It simulates a redemption of `_YUSDamount` to figure out where the redemption sequence will start and what state the final Trove
     * of the sequence will end up in.
     *
     * Returns three hints:
     *  - `firstRedemptionHint` is the address of the first Trove with ICR >= MCR (i.e. the first Trove that will be redeemed).
     *  - `partialRedemptionHintICR` is the final ICR of the last Trove of the sequence after being hit by partial redemption,
     *     or zero in case of no partial redemption.
     *  - `truncatedYUSDamount` is the maximum amount that can be redeemed out of the the provided `_YUSDamount`. This can be lower than
     *    `_YUSDamount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the
     *    minimum allowed value (i.e. MIN_NET_DEBT).
     *
     * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero
     * will leave it uncapped.
     */

    function getRedemptionHints(
        uint _YUSDamount, 
        uint _maxIterations
    )
        external
        view
        returns (
            address firstRedemptionHint,
            uint partialRedemptionHintICR,
            uint truncatedYUSDamount
        )
    {
        ISortedTroves sortedTrovesCached = sortedTroves;

        uint remainingYUSD = _YUSDamount;
        address currentTroveuser = sortedTrovesCached.getLast();

        while (currentTroveuser != address(0) && sortedTroves.getOldICR(currentTroveuser) < MCR) {
            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);
        }

        firstRedemptionHint = currentTroveuser;

        if (_maxIterations == 0) {
            _maxIterations = uint(-1);
        }

        while (currentTroveuser != address(0) && remainingYUSD != 0 && _maxIterations-- != 0) {
            uint netYUSDDebt = _getNetDebt(troveManager.getTroveDebt(currentTroveuser))
                .add(troveManager.getPendingYUSDDebtReward(currentTroveuser));

            if (netYUSDDebt > remainingYUSD) { // Partial redemption
                if (netYUSDDebt > MIN_NET_DEBT) { // MIN NET DEBT = 1800
                    uint maxRedeemableYUSD = LiquityMath._min(remainingYUSD, netYUSDDebt.sub(MIN_NET_DEBT));

                    uint newColl = _calculateVCAfterRedemption(currentTroveuser, maxRedeemableYUSD);
                    uint newDebt = netYUSDDebt.sub(maxRedeemableYUSD);

                    uint compositeDebt = _getCompositeDebt(newDebt);
                    partialRedemptionHintICR = LiquityMath._computeCR(newColl, compositeDebt);

                    remainingYUSD = remainingYUSD.sub(maxRedeemableYUSD);
                }
                break;
            } else { // Full redemption in this case
                remainingYUSD = remainingYUSD.sub(netYUSDDebt);
            }

            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);
        }

        truncatedYUSDamount = _YUSDamount.sub(remainingYUSD);
    }

    // Function for calculating the VC of a trove after a redemption, since the value is given out proportionally to the 
    // USD Value of the collateral. Same function is used in TroveManagerRedemptions for the same purpose. 
    function _calculateVCAfterRedemption(address _borrower, uint _YUSDAmount) internal view returns (uint newCollVC) {
        newColls memory colls;
        (colls.tokens, colls.amounts, ) = troveManager.getCurrentTroveState(_borrower);

        uint256[] memory finalAmounts = new uint256[](colls.tokens.length);

        uint totalCollUSD = _getUSDColls(colls);
        uint baseLot = _YUSDAmount.mul(DECIMAL_PRECISION);

        // redemption addresses are the same as coll addresses for trove
        uint256 tokensLen = colls.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            uint tokenAmount = colls.amounts[i];
            uint tokenAmountToRedeem = baseLot.mul(tokenAmount).div(totalCollUSD).div(DECIMAL_PRECISION);
            finalAmounts[i] = tokenAmount.sub(tokenAmountToRedeem);
        }

        newCollVC = _getVC(colls.tokens, finalAmounts);
    }


    /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the 
    sortedTroves list from the correct insert position of the Trove to be inserted. 
    
    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function 
    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:

    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will 
    be <= sqrt(length) positions away from the correct insert position.
    */
    function getApproxHint(uint _CR, uint _numTrials, uint _inputRandomSeed)
        external
        view
        returns (address hintAddress, uint diff, uint latestRandomSeed)
    {
        uint arrayLength = troveManager.getTroveOwnersCount();

        if (arrayLength == 0) {
            return (address(0), 0, _inputRandomSeed);
        }

        hintAddress = sortedTroves.getLast();
        diff = LiquityMath._getAbsoluteDifference(_CR, sortedTroves.getOldICR(hintAddress));
        latestRandomSeed = _inputRandomSeed;

        uint i = 1;

        while (i < _numTrials) {
            latestRandomSeed = uint(keccak256(abi.encodePacked(latestRandomSeed)));

            uint arrayIndex = latestRandomSeed % arrayLength;
            address currentAddress = troveManager.getTroveFromTroveOwnersArray(arrayIndex);
            uint currentICR = sortedTroves.getOldICR(currentAddress);

            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer
            uint currentDiff = LiquityMath._getAbsoluteDifference(currentICR, _CR);

            if (currentDiff < diff) {
                diff = currentDiff;
                hintAddress = currentAddress;
            }
            ++i;
        }
    }
}",1841
RealWorld_TA_66_BorrowerOperationsTester_RealWorld_20240809000941.log,66,BorrowerOperationsTester,52661,2567,55228,95.0,0.314645,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../BorrowerOperations.sol"";

/* Tester contract inherits from BorrowerOperations, and provides external functions 
for testing the parent's internal functions. */
contract BorrowerOperationsTester is BorrowerOperations {


    function getNewICRFromTroveChange
    (
        uint _newVC,
        uint _debt,
        uint _debtChange,
        bool _isDebtIncrease
    ) 
    external
    pure
    returns (uint)
    {
        return _getNewICRFromTroveChange(_newVC, _debt, _debtChange, _isDebtIncrease);
    }


    function getNewTCRFromTroveChange
    (
        uint _collChange, 
        bool isCollIncrease,  
        uint _debtChange, 
        bool isDebtIncrease
    )
    external 
    view
    returns (uint) 
    {
        return _getNewTCRFromTroveChange(_collChange, isCollIncrease, _debtChange, isDebtIncrease);
    }

    function getVC(address[] memory _tokens, uint[] memory _amounts) external view returns (uint) {
        return _getVC(_tokens, _amounts);
    }

    function sumColls(address[] memory _tokens1, uint[] memory _amounts1, 
        address[] memory _tokens2, uint[] memory _amounts2) 
        external view returns (address[] memory, uint[] memory) {
        newColls memory result =  _sumColls(_tokens1, _amounts1, _tokens2, _amounts2);
        return (result.tokens, result.amounts);
    }

    function get_MIN_NET_DEBT() external pure returns (uint) {
        return MIN_NET_DEBT;
    }

    // Payable fallback function
    receive() external payable { }
}",407
RealWorld_TA_66_ILQTYStaking_RealWorld_20240809011921.log,66,ILQTYStaking,45662,2095,47757,80.0,0.27021,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ISYETI {

    // --- Events --
    
    event YETITokenAddressSet(address _yetiTokenAddress);
    event YUSDTokenAddressSet(address _yusdTokenAddress);
    event TroveManagerAddressSet(address _troveManager);
    event TroveManagerRedemptionsAddressSet(address _troveManagerRedemptions);
    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);
    event ActivePoolAddressSet(address _activePoolAddress);

    event StakeChanged(address indexed staker, uint newStake);
    event StakingGainsWithdrawn(address indexed staker, uint YUSDGain);
    event F_YUSDUpdated(uint _F_YUSD);
    event TotalYETIStakedUpdated(uint _totalYETIStaked);
    event StakerSnapshotsUpdated(address _staker, uint _F_YUSD);

    // --- Functions ---

    function setAddresses
    (
        address _yetiTokenAddress,
        address _yusdTokenAddress,
        address _troveManagerAddress, 
        address _troveManagerRedemptionsAddress,
        address _borrowerOperationsAddress,
        address _activePoolAddress
    )  external;

    function stake(uint _YETIamount) external;

    function unstake(uint _YETIamount) external;

    function increaseF_YUSD(uint _YETIFee) external;

    function getPendingYUSDGain(address _user) external view returns (uint);
}",326
RealWorld_TA_66_ActivePoolTester_RealWorld_20240809002531.log,66,ActivePoolTester,31219,7690,38909,168.0,0.309895,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../ActivePool.sol"";

contract ActivePoolTester is ActivePool {
    
    function unprotectedIncreaseYUSDDebt(uint _amount) external {
        YUSDDebt  = YUSDDebt.add(_amount);
    }
    
    function unprotectedPayable() external payable {
        // @KingYet: Commented
        // ETH = ETH.add(msg.value);
    }
}",95
RealWorld_TA_66_IWhitelist_RealWorld_20240809010050.log,66,IWhitelist,51262,1899,53161,81.0,0.29429,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


interface IWhitelist {
    function getValidCollateral() view external returns (address[] memory);

    function setAddresses(
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _collSurplusPoolAddress, 
        address _borrowerOperationsAddress
    ) external;

    function isValidRouter(address _router) external view returns (bool);
    function getOracle(address _collateral) view external returns (address);
    function getRatio(address _collateral) view external returns (uint256);
    function getIsActive(address _collateral) view external returns (bool);
    function getPriceCurve(address _collateral) external view returns (address);
    function getDecimals(address _collateral) external view returns (uint256);
    function getFee(address _collateral, uint _collateralVCInput, uint256 _collateralVCBalancePost, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) external view returns (uint256 fee);
    function getFeeAndUpdate(address _collateral, uint _collateralVCInput, uint256 _collateralVCBalancePost, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) external returns (uint256 fee);
    function getIndex(address _collateral) external view returns (uint256);
    function isWrapped(address _collateral) external view returns (bool);
    function setDefaultRouter(address _collateral, address _router) external;

    function getValueVC(address _collateral, uint _amount) view external returns (uint);
    function getValueUSD(address _collateral, uint _amount) view external returns (uint256);
    function getDefaultRouterAddress(address _collateral) external view returns (address);
}",379
RealWorld_TA_66_ReentrancyGuard_RealWorld_20240808232102.log,66,ReentrancyGuard,71545,1175,72720,74.0,0.381225,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)

pragma solidity 0.6.11;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor () public {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}",638
RealWorld_TA_66_EchidnaTester_RealWorld_20240809002011.log,66,EchidnaTester,374468,6710,381178,197.0,2.00654,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../TroveManager.sol"";
import ""../BorrowerOperations.sol"";
import ""../ActivePool.sol"";
import ""../DefaultPool.sol"";
import ""../StabilityPool.sol"";
import ""../GasPool.sol"";
import ""../CollSurplusPool.sol"";
import ""../YUSDToken.sol"";
import ""./PriceFeedTestnet.sol"";
import ""../SortedTroves.sol"";
import ""../TroveManagerLiquidations.sol"";
import ""../TroveManagerRedemptions.sol"";
import ""../Dependencies/Whitelist.sol"";
import ""./EchidnaProxy.sol"";


// Run with:
// rm -f fuzzTests/corpus/* # (optional)
// ~/.local/bin/echidna-test contracts/TestContracts/EchidnaTester.sol --contract EchidnaTester --config fuzzTests/echidna_config.yaml

contract EchidnaTester {
    using SafeMath for uint;

    uint constant private NUMBER_OF_ACTORS = 100;
    uint constant private INITIAL_BALANCE = 1e24;
    uint private MCR;
    uint private CCR;
    uint private YUSD_GAS_COMPENSATION;

    TroveManager public troveManager;
    TroveManagerLiquidations public troveManagerLiquidations;
    TroveManagerRedemptions public troveManagerRedemptions;
    BorrowerOperations public borrowerOperations;
    ActivePool public activePool;
    DefaultPool public defaultPool;
    StabilityPool public stabilityPool;
    GasPool public gasPool;
    CollSurplusPool public collSurplusPool;
    YUSDToken public yusdToken;
    PriceFeedTestnet priceFeedTestnet;
    SortedTroves sortedTroves;
    Whitelist whitelist;

    EchidnaProxy[NUMBER_OF_ACTORS] public echidnaProxies;

    uint private numberOfTroves;

    constructor() public payable {
        troveManager = new TroveManager();
        borrowerOperations = new BorrowerOperations();
        activePool = new ActivePool();
        defaultPool = new DefaultPool();
        stabilityPool = new StabilityPool();
        gasPool = new GasPool();
        troveManagerLiquidations = new TroveManagerLiquidations();
        troveManagerRedemptions = new TroveManagerRedemptions();
        yusdToken = new YUSDToken(
            address(troveManager),
            address(troveManagerLiquidations),
            address(troveManagerRedemptions),
            address(stabilityPool),
            address(borrowerOperations)
        );
        whitelist = new Whitelist();

        collSurplusPool = new CollSurplusPool();
        priceFeedTestnet = new PriceFeedTestnet();

        sortedTroves = new SortedTroves();

        troveManager.setAddresses(address(borrowerOperations), 
            address(activePool), address(defaultPool), 
            address(stabilityPool), address(gasPool), address(collSurplusPool),
            address(priceFeedTestnet), address(yusdToken), 
            address(sortedTroves), address(0), address(0), address(0), address(0));
       
        borrowerOperations.setAddresses(address(troveManager), 
            address(activePool), address(defaultPool), 
            address(stabilityPool), address(gasPool), address(collSurplusPool),
            address(priceFeedTestnet), address(sortedTroves), 
            address(yusdToken), address(0));

        activePool.setAddresses(address(borrowerOperations), 
            address(troveManager), address(stabilityPool), address(defaultPool), address(whitelist),
            address(troveManagerLiquidations), address(troveManagerRedemptions), address(collSurplusPool)
        );

        defaultPool.setAddresses(address(troveManager), address(activePool), address(whitelist), address(0));
        
        stabilityPool.setAddresses(address(borrowerOperations), 
            address(troveManager), address(activePool), address(yusdToken), 
            address(sortedTroves), address(0), address(0), address(troveManagerLiquidations)); 

        collSurplusPool.setAddresses(address(borrowerOperations), 
             address(troveManager), address(troveManagerRedemptions), address(activePool), address(whitelist));
    
        sortedTroves.setParams(1e18, address(troveManager), address(borrowerOperations), address(troveManagerRedemptions));

        for (uint i = 0; i < NUMBER_OF_ACTORS; i++) {
            echidnaProxies[i] = new EchidnaProxy(troveManager, borrowerOperations, stabilityPool, yusdToken);
            (bool success, ) = address(echidnaProxies[i]).call{value: INITIAL_BALANCE}("""");
            require(success, ""proxy called failed"");
        }

        MCR = borrowerOperations.MCR();
        CCR = borrowerOperations.CCR();
        YUSD_GAS_COMPENSATION = borrowerOperations.YUSD_GAS_COMPENSATION();
        require(MCR != 0, ""MCR <= 0"");
        require(CCR != 0, ""CCR <= 0"");

        priceFeedTestnet.setPrice(1e22);
    }

    // @KingYeti: added this helper function
    function _getVC(address[] memory _tokens, uint[] memory _amounts) internal view returns (uint totalVC) {
        require(_tokens.length == _amounts.length, ""_getVC: length mismatch"");
        for (uint i = 0; i < _tokens.length; i++) {
            address token = _tokens[i];
            uint tokenVC = whitelist.getValueVC(token, _amounts[i]);
            totalVC = totalVC.add(tokenVC);
        }
        return totalVC;
    }

    // TroveManager

//    function liquidateExt(uint _i, address _user) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].liquidatePrx(_user);
//    }
//
//    function liquidateTrovesExt(uint _i, uint _n) external {
//        // pass
//        // @KingYeti: we no longer have this function
////        uint actor = _i % NUMBER_OF_ACTORS;
////        echidnaProxies[actor].liquidateTrovesPrx(_n);
//    }
//
//    function batchLiquidateTrovesExt(uint _i, address[] calldata _troveArray) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].batchLiquidateTrovesPrx(_troveArray);
//    }
//
//    function redeemCollateralExt(
//        uint _i,
//        uint _YUSDAmount,
//        address _firstRedemptionHint,
//        address _upperPartialRedemptionHint,
//        address _lowerPartialRedemptionHint,
//        uint _partialRedemptionHintNICR
//    ) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].redeemCollateralPrx(_YUSDAmount, _firstRedemptionHint, _upperPartialRedemptionHint, _lowerPartialRedemptionHint, _partialRedemptionHintNICR, 0, 0);
//    }
//
//    // Borrower Operations
//
//    function getAdjustedETH(uint actorBalance, uint _ETH, uint ratio) internal view returns (uint) {
//        uint price = priceFeedTestnet.getPrice();
//        require(price != 0);
//        uint minETH = ratio.mul(YUSD_GAS_COMPENSATION).div(price);
//        require(actorBalance > minETH);
//        uint ETH = minETH + _ETH % (actorBalance - minETH);
//        return ETH;
//    }
//
//    // @KingYeti: changed parameters
//    function getAdjustedYUSD(address[] memory _tokens, uint[] memory _amounts, uint _YUSDAmount, uint ratio) internal view returns (uint) {
//        uint VC = _getVC(_tokens, _amounts);
//        uint YUSDAmount = _YUSDAmount;
//        uint compositeDebt = YUSDAmount.add(YUSD_GAS_COMPENSATION);
//        uint ICR = LiquityMath._computeCR(VC, compositeDebt);
//        if (ICR < ratio) {
//            compositeDebt = VC.div(ratio);
//            YUSDAmount = compositeDebt.sub(YUSD_GAS_COMPENSATION);
//        }
//        return YUSDAmount;
//    }
//
//    // @KingYeti: changed parameters
//    function openTroveExt(uint _i, address[] memory _tokens, uint[] memory _amounts, uint _YUSDAmount) public payable {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        EchidnaProxy echidnaProxy = echidnaProxies[actor];
//        uint actorBalance = address(echidnaProxy).balance;
//
//        // we pass in CCR instead of MCR in case its the first one
//        uint ETH = getAdjustedETH(actorBalance, _ETH, CCR);
//        uint YUSDAmount = getAdjustedYUSD(_tokens, _amounts, _YUSDAmount, CCR);
//
//        //console.log('ETH', ETH);
//        //console.log('YUSDAmount', YUSDAmount);
//
//        echidnaProxy.openTrovePrx(_tokens, _amounts, YUSDAmount, address(0), address(0), 0);
//
//        numberOfTroves = troveManager.getTroveOwnersCount();
//        assert(numberOfTroves != 0);
//        // canary
//        //assert(numberOfTroves == 0);
//    }
//
//    function openTroveRawExt(uint _i, uint _ETH, uint _YUSDAmount, address _upperHint, address _lowerHint, uint _maxFee) public payable {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].openTrovePrx(_ETH, _YUSDAmount, _upperHint, _lowerHint, _maxFee);
//    }
//
//    function addCollExt(uint _i, uint _ETH) external payable {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        EchidnaProxy echidnaProxy = echidnaProxies[actor];
//        uint actorBalance = address(echidnaProxy).balance;
//
//        uint ETH = getAdjustedETH(actorBalance, _ETH, MCR);
//
//        echidnaProxy.addCollPrx(ETH, address(0), address(0));
//    }
//
//    function addCollRawExt(uint _i, uint _ETH, address _upperHint, address _lowerHint) external payable {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].addCollPrx(_ETH, _upperHint, _lowerHint);
//    }
//
//    function withdrawCollExt(uint _i, uint _amount, address _upperHint, address _lowerHint) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].withdrawCollPrx(_amount, _upperHint, _lowerHint);
//    }
//
//    function withdrawYUSDExt(uint _i, uint _amount, address _upperHint, address _lowerHint, uint _maxFee) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].withdrawYUSDPrx(_amount, _upperHint, _lowerHint, _maxFee);
//    }
//
//    function repayYUSDExt(uint _i, uint _amount, address _upperHint, address _lowerHint) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].repayYUSDPrx(_amount, _upperHint, _lowerHint);
//    }
//
//    function closeTroveExt(uint _i) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].closeTrovePrx();
//    }
//
//    function adjustTroveExt(uint _i, uint _ETH, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease) external payable {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        EchidnaProxy echidnaProxy = echidnaProxies[actor];
//        uint actorBalance = address(echidnaProxy).balance;
//
//        uint ETH = getAdjustedETH(actorBalance, _ETH, MCR);
//        uint debtChange = _debtChange;
//        if (_isDebtIncrease) {
//            debtChange = getAdjustedYUSD(ETH, uint(_debtChange), MCR);
//        }
//        echidnaProxy.adjustTrovePrx(ETH, _collWithdrawal, debtChange, _isDebtIncrease, address(0), address(0), 0);
//    }
//
//    function adjustTroveRawExt(uint _i, uint _ETH, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFee) external payable {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].adjustTrovePrx(_ETH, _collWithdrawal, _debtChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFee);
//    }
//
//    // Pool Manager
//
//    function provideToSPExt(uint _i, uint _amount, address _frontEndTag) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].provideToSPPrx(_amount, _frontEndTag);
//    }
//
//    function withdrawFromSPExt(uint _i, uint _amount) external {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].withdrawFromSPPrx(_amount);
//    }
//
//    // YUSD Token
//
//    function transferExt(uint _i, address recipient, uint256 amount) external returns (bool) {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].transferPrx(recipient, amount);
//    }
//
//    function approveExt(uint _i, address spender, uint256 amount) external returns (bool) {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].approvePrx(spender, amount);
//    }
//
//    function transferFromExt(uint _i, address sender, address recipient, uint256 amount) external returns (bool) {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].transferFromPrx(sender, recipient, amount);
//    }
//
//    function increaseAllowanceExt(uint _i, address spender, uint256 addedValue) external returns (bool) {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].increaseAllowancePrx(spender, addedValue);
//    }
//
//    function decreaseAllowanceExt(uint _i, address spender, uint256 subtractedValue) external returns (bool) {
//        uint actor = _i % NUMBER_OF_ACTORS;
//        echidnaProxies[actor].decreaseAllowancePrx(spender, subtractedValue);
//    }
//
//    // PriceFeed
//
//    function setPriceExt(uint256 _price) external {
//        bool result = priceFeedTestnet.setPrice(_price);
//        assert(result);
//    }
//
//    // --------------------------
//    // Invariants and properties
//    // --------------------------
//
//    function echidna_canary_number_of_troves() public view returns(bool) {
//        if (numberOfTroves > 20) {
//            return false;
//        }
//
//        return true;
//    }
//
//    function echidna_canary_active_pool_balance() public view returns(bool) {
//        if (address(activePool).balance != 0) {
//            return false;
//        }
//        return true;
//    }
//
//    function echidna_troves_order() external view returns(bool) {
//        address currentTrove = sortedTroves.getFirst();
//        address nextTrove = sortedTroves.getNext(currentTrove);
//
//        while (currentTrove != address(0) && nextTrove != address(0)) {
//            if (troveManager.getNominalICR(nextTrove) > troveManager.getNominalICR(currentTrove)) {
//                return false;
//            }
//            // Uncomment to check that the condition is meaningful
//            //else return false;
//
//            currentTrove = nextTrove;
//            nextTrove = sortedTroves.getNext(currentTrove);
//        }
//
//        return true;
//    }
//
//    /**
//     * Status
//     * Minimum debt (gas compensation)
//     * Stake != 0
//     */
//    function echidna_trove_properties() public view returns(bool) {
//        address currentTrove = sortedTroves.getFirst();
//        while (currentTrove != address(0)) {
//            // Status
//            if (TroveManager.Status(troveManager.getTroveStatus(currentTrove)) != TroveManager.Status.active) {
//                return false;
//            }
//            // Uncomment to check that the condition is meaningful
//            //else return false;
//
//            // Minimum debt (gas compensation)
//            if (troveManager.getTroveDebt(currentTrove) < YUSD_GAS_COMPENSATION) {
//                return false;
//            }
//            // Uncomment to check that the condition is meaningful
//            //else return false;
//
//            // Stake != 0
//            if (troveManager.getTroveStake(currentTrove) == 0) {
//                return false;
//            }
//            // Uncomment to check that the condition is meaningful
//            //else return false;
//
//            currentTrove = sortedTroves.getNext(currentTrove);
//        }
//        return true;
//    }
//
//    function echidna_ETH_balances() public view returns(bool) {
//        if (address(troveManager).balance != 0) {
//            return false;
//        }
//
//        if (address(borrowerOperations).balance != 0) {
//            return false;
//        }
//
//        if (address(activePool).balance != activePool.getCollateral(weth.address)) {
//            return false;
//        }
//
//        if (address(defaultPool).balance != defaultPool.getCollateral(weth.address)) {
//            return false;
//        }
//
//        if (address(stabilityPool).balance != stabilityPool.getETH()) {
//            return false;
//        }
//
//        if (address(yusdToken).balance != 0) {
//            return false;
//        }
//
//        if (address(priceFeedTestnet).balance != 0) {
//            return false;
//        }
//
//        if (address(sortedTroves).balance != 0) {
//            return false;
//        }
//
//        return true;
//    }
//
//    function echidna_price() public view returns(bool) {
//        uint price = priceFeedTestnet.getPrice();
//
//        if (price == 0) {
//            return false;
//        }
//        // Uncomment to check that the condition is meaningful
//        //else return false;
//
//        return true;
//    }
//
//    // Total YUSD matches
//    function echidna_YUSD_global_balances() public view returns(bool) {
//        uint totalSupply = yusdToken.totalSupply();
//        uint gasPoolBalance = yusdToken.balanceOf(address(gasPool));
//
//        uint activePoolBalance = activePool.getYUSDDebt();
//        uint defaultPoolBalance = defaultPool.getYUSDDebt();
//        if (totalSupply != activePoolBalance + defaultPoolBalance) {
//            return false;
//        }
//
//        uint stabilityPoolBalance = stabilityPool.getTotalYUSDDeposits();
//        address currentTrove = sortedTroves.getFirst();
//        uint trovesBalance;
//        while (currentTrove != address(0)) {
//            trovesBalance += yusdToken.balanceOf(address(currentTrove));
//            currentTrove = sortedTroves.getNext(currentTrove);
//        }
//        // we cannot state equality because tranfers are made to external addresses too
//        if (totalSupply <= stabilityPoolBalance + trovesBalance + gasPoolBalance) {
//            return false;
//        }
//
//        return true;
//    }

    /*
    function echidna_test() public view returns(bool) {
        return true;
    }
    */
}",4500
RealWorld_TA_66_LiquityMathTester_RealWorld_20240808234821.log,66,LiquityMathTester,32330,1223,33553,71.0,0.18611,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/LiquityMath.sol"";

/* Tester contract for math functions in Math.sol library. */

contract LiquityMathTester {

    function callMax(uint _a, uint _b) external pure returns (uint) {
        return LiquityMath._max(_a, _b);
    }

    // Non-view wrapper for gas test
    function callDecPowTx(uint _base, uint _n) external pure returns (uint) {
        return LiquityMath._decPow(_base, _n);
    }

    // External wrapper
    function callDecPow(uint _base, uint _n) external pure returns (uint) {
        return LiquityMath._decPow(_base, _n);
    }
}",167
RealWorld_TA_66_IERC20_RealWorld_20240809020051.log,66,IERC20,33332,1455,34787,74.0,0.19576,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;

interface IERC20 {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function increaseAllowance(address spender, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /// @notice EIP 2612
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",179
RealWorld_TA_66_Address_RealWorld_20240809003930.log,66,Address,174327,2017,176344,96.0,0.911975,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)

pragma solidity 0.8.7;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length != 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        (bool success, ) = recipient.call{value: amount}("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, ""Address: low-level delegate call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), ""Address: delegate call to non-contract"");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length != 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1872
RealWorld_TA_66_ILockupContractFactory_RealWorld_20240809012043.log,66,ILockupContractFactory,30538,2454,32992,87.0,0.20177,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;
    
interface ILockupContractFactory {
    
    // --- Events ---

    event YETITokenAddressSet(address _yetiTokenAddress);
    event LockupContractDeployedThroughFactory(address _lockupContractAddress, address _beneficiary, uint _unlockTime, address _deployer);

    // --- Functions ---

    function setYETITokenAddress(address _yetiTokenAddress) external;

    function deployLockupContract(address _beneficiary, uint _unlockTime) external;

    function isRegisteredLockup(address _addr) external view returns (bool);
}",137
RealWorld_TA_66_IActivePool_RealWorld_20240809012212.log,66,IActivePool,40406,2729,43135,91.0,0.25661,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./IPool.sol"";

    
interface IActivePool is IPool {
    // --- Events ---
    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolCollateralBalanceUpdated(address _collateral, uint _amount);

    // --- Functions ---
    
    function sendCollaterals(address _to, address[] memory _tokens, uint[] memory _amounts) external returns (bool);
    function sendCollateralsUnwrap(
        address _from,
        address _to,
        address[] memory _tokens,
        uint[] memory _amounts) external returns (bool);

    function sendSingleCollateral(address _to, address _token, uint256 _amount) external returns (bool);

    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external returns (bool);

    function getCollateralVC(address collateralAddress) external view returns (uint);
    function addCollateralType(address _collateral) external;
}",259
RealWorld_TA_66_BoringOwnable_RealWorld_20240809021011.log,66,BoringOwnable,60085,2039,62124,82.0,0.341205,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;

// Audit on 5-Jan-2021 by Keno and BoringCrypto
// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto

contract BoringOwnableData {
    address public owner;
    address public pendingOwner;
}

contract BoringOwnable is BoringOwnableData {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice `owner` defaults to msg.sender on construction.
    constructor() public {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.
    /// Can only be invoked by the current `owner`.
    /// @param newOwner Address of the new owner.
    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.
    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.
    function transferOwnership(
        address newOwner,
        bool direct,
        bool renounce
    ) public onlyOwner {
        if (direct) {
            // Checks
            require(newOwner != address(0) || renounce, ""Ownable: zero address"");

            // Effects
            emit OwnershipTransferred(owner, newOwner);
            owner = newOwner;
            pendingOwner = address(0);
        } else {
            // Effects
            pendingOwner = newOwner;
        }
    }

    /// @notice Needs to be called by `pendingOwner` to claim ownership.
    function claimOwnership() public {
        address _pendingOwner = pendingOwner;

        // Checks
        require(msg.sender == _pendingOwner, ""Ownable: caller != pending owner"");

        // Effects
        emit OwnershipTransferred(owner, _pendingOwner);
        owner = _pendingOwner;
        pendingOwner = address(0);
    }

    /// @notice Only allows the `owner` to execute the function.
    modifier onlyOwner() {
        require(msg.sender == owner, ""Ownable: caller is not the owner"");
        _;
    }
}",501
RealWorld_TA_66_Pool2Unipool_RealWorld_20240808230733.log,66,Pool2Unipool,203467,5866,209333,152.0,1.134655,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/LiquityMath.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";
import ""../Dependencies/CheckContract.sol"";
import ""../Interfaces/IYETIToken.sol"";
import ""./Dependencies/SafeERC20.sol"";
import ""./Interfaces/ILPTokenWrapper.sol"";
import ""./Interfaces/IUnipool.sol"";



// Adapted from: https://github.com/Synthetixio/Unipool/blob/master/contracts/Unipool.sol
// Some more useful references:
// Synthetix proposal: https://sips.synthetix.io/sips/sip-31
// Original audit: https://github.com/sigp/public-audits/blob/master/synthetix/unipool/review.pdf
// Incremental changes (commit by commit) from the original to this version: https://github.com/liquity/dev/pull/271

// LPTokenWrapper contains the basic staking functionality
contract LPTokenWrapper is ILPTokenWrapper {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public uniToken;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function stake(uint256 amount) public virtual override {
        _totalSupply = _totalSupply.add(amount);
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        uniToken.safeTransferFrom(msg.sender, address(this), amount);
    }

    function withdraw(uint256 amount) public virtual override {
        _totalSupply = _totalSupply.sub(amount);
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        uniToken.safeTransfer(msg.sender, amount);
    }
}

/*
 * On deployment a new Uniswap pool will be created for the pair YUSD/ETH and its token will be set here.

 * Essentially the way it works is:

 * - Liquidity providers add funds to the Uniswap pool, and get UNIv2 LP tokens in exchange
 * - Liquidity providers stake those UNIv2 LP tokens into Unipool rewards contract
 * - Liquidity providers accrue rewards, proportional to the amount of staked tokens and staking time
 * - Liquidity providers can claim their rewards when they want
 * - Liquidity providers can unstake UNIv2 LP tokens to exit the program (i.e., stop earning rewards) when they want

 * Funds for rewards will only be added once, on deployment of YETI token,
 * which will happen after this contract is deployed and before this `setParams` in this contract is called.

 * If at some point the total amount of staked tokens is zero, the clock will be stopped,
 * so the period will be extended by the time during which the staking pool is empty,
 * in order to avoid getting YETI tokens locked.
 * That also means that the start time for the program will be the event that occurs first:
 * either YETI token contract is deployed, and therefore YETI tokens are minted to Unipool contract,
 * or first liquidity provider stakes UNIv2 LP tokens into it.
 */
contract Pool2Unipool is LPTokenWrapper, Ownable, CheckContract, IUnipool {
    bytes32 constant public NAME = ""Pool2Unipool"";

    uint256 public duration;
    IYETIToken public yetiToken;

    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    event YETITokenAddressChanged(address _yetiTokenAddress);
    event UniTokenAddressChanged(address _uniTokenAddress);
    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);

    // initialization function
    function setParams(
        address _yetiTokenAddress,
        address _uniTokenAddress,
        uint _duration
    )
        external
        override
        onlyOwner
    {
        checkContract(_yetiTokenAddress);
        checkContract(_uniTokenAddress);

        uniToken = IERC20(_uniTokenAddress);
        yetiToken = IYETIToken(_yetiTokenAddress);
        //duration = _duration;

        // This function must be commented out as it assumes an allocation already exists
        // for this pool immediately after creation. 
        //_notifyRewardAmount(yetiToken.getLpRewardsEntitlement(), _duration);

        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit UniTokenAddressChanged(_uniTokenAddress);

        // this must be done in setReward
        //_renounceOwnership();
    }

    // This function is separate from setParams because the YETI allocation cannot be done in code
    function setReward(
        uint _duration
    )
        external
        onlyOwner
    {
        duration = _duration;
        require(yetiToken.balanceOf(address(this)) != 0, ""setReward can only be called once YETI has been allocated to this contract"");
        // This function must be commented out as it assumes an allocation already exists
        // for this pool immediately after creation. 
        _notifyRewardAmount(yetiToken.balanceOf(address(this)), _duration);
        _renounceOwnership();
    }

    // Returns current timestamp if the rewards program has not finished yet, end time otherwise
    function lastTimeRewardApplicable() public view override returns (uint256) {
        return LiquityMath._min(block.timestamp, periodFinish);
    }

    // Returns the amount of rewards that correspond to each staked token
    function rewardPerToken() public view override returns (uint256) {
        if (totalSupply() == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored.add(
                lastTimeRewardApplicable()
                    .sub(lastUpdateTime)
                    .mul(rewardRate)
                    .mul(1e18)
                    .div(totalSupply())
            );
    }

    // Returns the amount that an account can claim
    function earned(address account) public view override returns (uint256) {
        return
            balanceOf(account)
                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))
                .div(1e18)
                .add(rewards[account]);
    }

    // stake visibility is public as overriding LPTokenWrapper's stake() function
    function stake(uint256 amount) public override {
        require(amount != 0, ""Cannot stake 0"");
        require(address(uniToken) != address(0), ""Liquidity Pool Token has not been set yet"");

        _updatePeriodFinish();
        _updateAccountReward(msg.sender);

        super.stake(amount);

        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount) public override {
        require(amount != 0, ""Cannot withdraw 0"");
        require(address(uniToken) != address(0), ""Liquidity Pool Token has not been set yet"");

        _updateAccountReward(msg.sender);

        super.withdraw(amount);

        emit Withdrawn(msg.sender, amount);
    }

    // Shortcut to be able to unstake tokens and claim rewards in one transaction
    function withdrawAndClaim() external override {
        withdraw(balanceOf(msg.sender));
        claimReward();
    }

    function claimReward() public override {
        require(address(uniToken) != address(0), ""Liquidity Pool Token has not been set yet"");

        _updatePeriodFinish();
        _updateAccountReward(msg.sender);

        uint256 reward = earned(msg.sender);

        require(reward != 0, ""Nothing to claim"");

        rewards[msg.sender] = 0;
        yetiToken.transfer(msg.sender, reward);
        emit RewardPaid(msg.sender, reward);
    }

    // Used only on initialization, sets the reward rate and the end time for the program
    function _notifyRewardAmount(uint256 _reward, uint256 _duration) internal {
        require(_reward != 0, ""_notifyRewardAmount: reward is 0"");
        require(_reward == yetiToken.balanceOf(address(this)), ""_notifyRewardAmount: reward not equal to balance"");
        require(periodFinish == 0, ""_notifyRewardAmount: periodFinish != 0"");

        _updateReward();

        rewardRate = _reward.div(_duration);

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp.add(_duration);
        emit RewardAdded(_reward);
    }

    // Adjusts end time for the program after periods of zero total supply
    function _updatePeriodFinish() internal {
        if (totalSupply() == 0) {
            require(periodFinish != 0, ""_updatePeriodFinish: periodFinish <= 0"");
            /*
             * If the finish period has been reached (but there are remaining rewards due to zero stake),
             * to get the new finish date we must add to the current timestamp the difference between
             * the original finish time and the last update, i.e.:
             *
             * periodFinish = block.timestamp.add(periodFinish.sub(lastUpdateTime));
             *
             * If we have not reached the end yet, we must extend it by adding to it the difference between
             * the current timestamp and the last update (the period where the supply has been empty), i.e.:
             *
             * periodFinish = periodFinish.add(block.timestamp.sub(lastUpdateTime));
             *
             * Both formulas are equivalent.
             */
            periodFinish = periodFinish.add(block.timestamp.sub(lastUpdateTime));
        }
    }

    function _updateReward() internal {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
    }

    function _updateAccountReward(address account) internal {
        _updateReward();

        require(account != address(0), ""_updateAccountReward: account is address(0)"");

        rewards[account] = earned(account);
        userRewardPerTokenPaid[account] = rewardPerTokenStored;
    }
}",2192
RealWorld_TA_66_ERC20Token_RealWorld_20240809003345.log,66,ERC20Token,204817,2262,207079,105.0,1.069325,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;


/**
 * Based on OpenZeppelin's SafeMath:
 * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol
 *
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, ""SafeMath: addition overflow"");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, ""SafeMath: subtraction overflow"");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     *
     * _Available since v2.4.0._
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, ""SafeMath: division by zero"");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b != 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, ""SafeMath: modulo by zero"");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     *
     * _Available since v2.4.0._
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }

}

// ----------------------------------------------------------------------------
// Implementation of ERC20 Standard. Useful for testing
// ----------------------------------------------------------------------------
contract ERC20Token {
    using SafeMath for uint;

    string public _symbol;
    string public _name;
    uint8 public _decimals;
    uint public _totalSupply;

    // For each person map between their address and the number of tokens they have
    mapping(address => uint) balances;
    // To transfer erc20 token, give contract permission to transfer. Maps from your address to address of transfer target and amount to transfer.
    mapping(address => mapping(address => uint)) allowed;


    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(string memory ERC20_symbol, string memory ERC20_name, uint8 ERC20_decimals) public {
        _symbol = ERC20_symbol;
        _name = ERC20_name;
        _decimals = ERC20_decimals;
        _totalSupply = 0;
    }

    //Returns decimals that this token uses.
    function decimals() public view returns (uint8) {
        return _decimals;
    }


    //Returns the token name
    function name() public view returns (string memory) {
        return _name;
    }


    //Returns the symbol
    function symbol() public view returns (string memory) {
        return _symbol;
    }


    // Return total supply
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }


    // Return the token balance for account tokenOwner
    function balanceOf(address _token_owner) public view returns (uint balance) {
        return balances[_token_owner];
    }


    // ------------------------------------------------------------------------
    // Transfer the balance from token owner's account to to account
    // - Owner's account must have sufficient balance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transfer(address _to, uint _num_tokens) public returns (bool success) {
        require(_num_tokens <= balances[msg.sender], ""You are trying to transfer more tokens than you have"");

        balances[msg.sender] = balances[msg.sender].sub(_num_tokens);
        balances[_to] = balances[_to].add(_num_tokens);
        emit Transfer(msg.sender, _to, _num_tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Mint new tokens to a given _to address
    // ------------------------------------------------------------------------
    function mint(address _to, uint _num_tokens) public returns (bool success) {
        balances[_to] = balances[_to].add(_num_tokens);
        emit Transfer(address(0), _to, _num_tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Token owner can approve for spender to transferFrom(...) tokens
    // from the token owner's account
    //
    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
    // recommends that there are no checks for the approval double-spend attack
    // as this should be implemented in user interfaces
    // ------------------------------------------------------------------------
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Transfer tokens from the from account to the to account
    //
    // The calling account must already have sufficient tokens approve(...)-d
    // for spending from the from account and
    // - From account must have sufficient balance to transfer
    // - Spender must have sufficient allowance to transfer
    // - 0 value transfers are allowed
    // ------------------------------------------------------------------------
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(balances[from] >= tokens, ""You are trying to transfer more tokens than from has"");
        require(allowed[from][msg.sender] >= tokens, ""You are trying to transfer more tokens than you have approved"");
        balances[from] = balances[from].sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }


    // ------------------------------------------------------------------------
    // Returns the amount of tokens approved by the owner that can be
    // transferred to the spender's account
    // ------------------------------------------------------------------------
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }
}",2225
RealWorld_TA_66_LockupContract_RealWorld_20240809015555.log,66,LockupContract,74292,3111,77403,93.0,0.43368,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/SafeMath.sol"";
import ""../Interfaces/IYETIToken.sol"";

/*
* The lockup contract architecture utilizes a single LockupContract, with an unlockTime. The unlockTime is passed as an argument 
* to the LockupContract's constructor. The contract's balance can be withdrawn by the beneficiary when block.timestamp > unlockTime. 
* At construction, the contract checks that unlockTime is at least one year later than the Liquity system's deployment time. 
*/
contract LockupContract {
    using SafeMath for uint;

    // --- Data ---
    bytes32 constant public NAME = ""LockupContract"";

    uint constant public SECONDS_IN_ONE_YEAR = 31536000;

    address public immutable beneficiary;

    IYETIToken public immutable yetiToken;

    // Unlock time is the Unix point in time at which the beneficiary can withdraw.
    uint public unlockTime;

    // --- Events ---

    event LockupContractCreated(address _beneficiary, uint _unlockTime);
    event LockupContractEmptied(uint _YETIwithdrawal);

    // --- Functions ---

    constructor 
    (
        address _yetiTokenAddress,
        address _beneficiary, 
        uint _unlockTime
    )
        public 
    {
        IYETIToken cachedYetiToken = IYETIToken(_yetiTokenAddress);
        yetiToken = cachedYetiToken;

        /*
        * Set the unlock time to a chosen instant in the future, as long as it is at least 1 year after
        * the system was deployed 
        */
        _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(_unlockTime, cachedYetiToken);
        unlockTime = _unlockTime;
        
        beneficiary =  _beneficiary;
        emit LockupContractCreated(_beneficiary, _unlockTime);
    }

    function withdrawYETI() external {
        _requireCallerIsBeneficiary();
        _requireLockupDurationHasPassed();

        IYETIToken yetiTokenCached = yetiToken;
        uint YETIBalance = yetiTokenCached.balanceOf(address(this));
        yetiTokenCached.transfer(beneficiary, YETIBalance);
        emit LockupContractEmptied(YETIBalance);
    }

    // --- 'require' functions ---

    function _requireCallerIsBeneficiary() internal view {
        require(msg.sender == beneficiary, ""LockupContract: caller is not the beneficiary"");
    }

    function _requireLockupDurationHasPassed() internal view {
        require(block.timestamp >= unlockTime, ""LockupContract: The lockup duration must have passed"");
    }

    function _requireUnlockTimeIsAtLeastOneYearAfterSystemDeployment(uint _unlockTime, IYETIToken _yetiToken) internal view {
        uint systemDeploymentTime = _yetiToken.getDeploymentStartTime();
        require(_unlockTime >= systemDeploymentTime.add(SECONDS_IN_ONE_YEAR), ""LockupContract: unlock time must be at least one year after system deployment"");
    }
}",650
RealWorld_TA_66_EchidnaProxy_RealWorld_20240808235158.log,66,EchidnaProxy,119529,3850,123379,118.0,0.674645,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../TroveManager.sol"";
import ""../BorrowerOperations.sol"";
import ""../StabilityPool.sol"";
import ""../YUSDToken.sol"";

contract EchidnaProxy {
    TroveManager troveManager;
    BorrowerOperations borrowerOperations;
    StabilityPool stabilityPool;
    YUSDToken yusdToken;

    constructor(
        TroveManager _troveManager,
        BorrowerOperations _borrowerOperations,
        StabilityPool _stabilityPool,
        YUSDToken _yusdToken
    ) public {
        troveManager = _troveManager;
        borrowerOperations = _borrowerOperations;
        stabilityPool = _stabilityPool;
        yusdToken = _yusdToken;
    }

    receive() external payable {
        // do nothing
    }

    // TroveManager

    function liquidatePrx(address _user) external {
        troveManager.liquidate(_user);
    }

    function liquidateTrovesPrx(uint _n) external {
        // pass
        // @KingYeti: we no longer have this function
//        troveManager.liquidateTroves(_n);
    }

    function batchLiquidateTrovesPrx(address[] calldata _troveArray) external {
        troveManager.batchLiquidateTroves(_troveArray, msg.sender);
    }

    function redeemCollateralPrx(
        uint _YUSDAmount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintNICR,
        uint _maxIterations
        // uint _maxFee
    ) external {
        troveManager.redeemCollateral(_YUSDAmount, _YUSDMaxFee, _firstRedemptionHint, _upperPartialRedemptionHint, _lowerPartialRedemptionHint, _partialRedemptionHintNICR, _maxIterations);
    }

    // Borrower Operations
    // @KingYeti: changed parameters
    function openTrovePrx(
        uint _maxFeePercentage,
        uint _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint[] memory _amounts
    ) external payable {
        borrowerOperations.openTrove(
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // @KingYeti: changed params
    function addCollPrx(address[] memory _collsIn, uint[] memory _amountsIn, address _upperHint, address _lowerHint, uint _maxFeePercentage) external payable {
        borrowerOperations.addColl(_collsIn, _amountsIn, _upperHint, _lowerHint, _maxFeePercentage);
    }

    function withdrawCollPrx(address[] memory _collsOut, uint[] memory _amountsOut, address _upperHint, address _lowerHint) external {
        borrowerOperations.withdrawColl(_collsOut, _amountsOut, _upperHint, _lowerHint);
    }

    function withdrawYUSDPrx(uint _amount, address _upperHint, address _lowerHint, uint _maxFee) external {
        borrowerOperations.withdrawYUSD(_maxFee, _amount, _upperHint, _lowerHint);
    }

    function repayYUSDPrx(uint _amount, address _upperHint, address _lowerHint) external {
        borrowerOperations.repayYUSD(_amount, _upperHint, _lowerHint);
    }

    function closeTrovePrx() external {
        borrowerOperations.closeTrove();
    }

    function adjustTrovePrx(
        address[] memory _collsIn,
        uint[] memory _amountsIn,
        address[] memory _collsOut,
        uint[] memory _amountsOut,
        uint _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint _maxFeePercentage) external {
        borrowerOperations.adjustTrove(
            _collsIn,
            _amountsIn,
            _collsOut, _amountsOut, _YUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage
        );
    }

    // Pool Manager
    function provideToSPPrx(uint _amount, address _frontEndTag) external {
        stabilityPool.provideToSP(_amount, _frontEndTag);
    }

    function withdrawFromSPPrx(uint _amount) external {
        stabilityPool.withdrawFromSP(_amount);
    }

    // YUSD Token

    function transferPrx(address recipient, uint256 amount) external returns (bool) {
        return yusdToken.transfer(recipient, amount);
    }

    function approvePrx(address spender, uint256 amount) external returns (bool) {
        return yusdToken.increaseAllowance(spender, amount);
    }

    function transferFromPrx(address sender, address recipient, uint256 amount) external returns (bool) {
        return yusdToken.transferFrom(sender, recipient, amount);
    }

    function increaseAllowancePrx(address spender, uint256 addedValue) external returns (bool) {
        require(yusdToken.approve(spender, 0));
        return yusdToken.increaseAllowance(spender, addedValue);
    }

    function decreaseAllowancePrx(address spender, uint256 subtractedValue) external returns (bool) {
        return yusdToken.decreaseAllowance(spender, subtractedValue);
    }
}",1207
RealWorld_TA_66_DefaultPool_RealWorld_20240808222626.log,66,DefaultPool,176551,5552,182103,149.0,0.993795,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IDefaultPool.sol"";
import ""./Interfaces/IActivePool.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Default Pool holds the collateral and YUSD debt (but not YUSD tokens) from liquidations that have been redistributed
 * to active troves but not yet ""applied"", i.e. not yet recorded on a recipient active trove's struct.
 *
 * When a trove makes an operation that applies its pending collateral and YUSD debt, its pending collateral and YUSD debt is moved
 * from the Default Pool to the Active Pool.
 */
contract DefaultPool is Ownable, CheckContract, IDefaultPool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    string public constant NAME = ""DefaultPool"";

    address internal troveManagerAddress;
    address internal activePoolAddress;
    address internal whitelistAddress;
    address internal yetiFinanceTreasury;

    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts
    newColls internal poolColl;

    uint256 internal YUSDDebt;

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event DefaultPoolYUSDDebtUpdated(uint256 _YUSDDebt);
    event DefaultPoolBalanceUpdated(address _collateral, uint256 _amount);
    event DefaultPoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _whitelistAddress, 
        address _yetiTreasuryAddress
    ) external onlyOwner {
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_yetiTreasuryAddress);

        troveManagerAddress = _troveManagerAddress;
        activePoolAddress = _activePoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        whitelistAddress = _whitelistAddress;
        yetiFinanceTreasury = _yetiTreasuryAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
     * Returns the collateralBalance for a given collateral
     *
     * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
     */
    function getCollateral(address _collateral) public view override returns (uint256) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }

    /*
     * Returns the VC of the contract
     *
     * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
     *
     * Computed when called by taking the collateral balances and
     * multiplying them by the corresponding price and ratio and then summing that
     */
    function getVC() external view override returns (uint256 totalVC) {
        uint256 tokensLen = poolColl.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address collateral = poolColl.tokens[i];
            uint256 amount = poolColl.amounts[i];

            uint256 collateralVC = whitelist.getValueVC(collateral, amount);
            totalVC = totalVC.add(collateralVC);
        }
    }

    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint256) {
        return YUSDDebt;
    }

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _collateral, uint256 _amount) internal {
        address activePool = activePoolAddress;
        uint256 index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);

        IERC20(_collateral).safeTransfer(activePool, _amount);

        emit DefaultPoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, activePool, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollsToActivePool(address[] memory _tokens, uint256[] memory _amounts, address _borrower)
        external
        override
    {
        _requireCallerIsTroveManager();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""DP:Length mismatch"");
        uint256 thisAmounts;
        address thisToken;
        for (uint256 i; i < tokensLen; ++i) {
            thisAmounts = _amounts[i];
            if(thisAmounts != 0) {
                thisToken = _tokens[i];
                
                // If asset is wrapped, then that means it came from the active pool (originally) and we need to update rewards from 
                // the treasury which would have owned the rewards, to the new borrower who will be accumulating this new 
                // reward. 
                if (whitelist.isWrapped(thisToken)) {
                    // This call claims the tokens for the treasury and also transfers them to the default pool as an intermediary so 
                    // that it can transfer.
                    IWAsset(thisToken).endTreasuryReward(address(this), thisAmounts);
                    // Call transfer
                    _sendCollateral(thisToken, thisAmounts);
                    // Then finally transfer rewards to the borrower
                    IWAsset(thisToken).updateReward(address(this), _borrower, thisAmounts);
                } else {
                    // Otherwise just send. 
                    _sendCollateral(thisToken, thisAmounts);
                }
            }
        }
        IActivePool(activePoolAddress).receiveCollateral(_tokens, _amounts);
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint256 _amount) external override {
        _requireCallerIsTroveManager();
        YUSDDebt = YUSDDebt.add(_amount);
        emit DefaultPoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool.
    function decreaseYUSDDebt(uint256 _amount) external override {
        _requireCallerIsTroveManager();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit DefaultPoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != activePoolAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTroveManager() internal view {
        if (msg.sender != troveManagerAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert(""DP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit DefaultPoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }
}",1846
RealWorld_TA_66_BorrowerOperationsScript_RealWorld_20240808225106.log,66,BorrowerOperationsScript,65871,3617,69488,104.0,0.401695,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;
//
import ""../Dependencies/CheckContract.sol"";
import ""../Interfaces/IBorrowerOperations.sol"";


contract BorrowerOperationsScript is CheckContract {
    IBorrowerOperations immutable borrowerOperations;

    constructor(IBorrowerOperations _borrowerOperations) public {
        checkContract(address(_borrowerOperations));
        borrowerOperations = _borrowerOperations;
    }

    function openTrove(uint _maxFeePercentage,
        uint _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint[] memory _amounts
        ) external payable {
        borrowerOperations.openTrove(_maxFeePercentage, _YUSDAmount, _upperHint,_lowerHint, _colls, _amounts);
    }

    function addColl(address[] memory _collsIn, uint[] memory _amountsIn, address _upperHint, address _lowerHint, uint _maxFeePercentage) external payable {
borrowerOperations.addColl(_collsIn, _amountsIn, _upperHint, _lowerHint, _maxFeePercentage);
    }

    function withdrawColl(address[] memory _collsOut, uint[] memory _amountsOut, address _upperHint, address _lowerHint) external {
borrowerOperations.withdrawColl(_collsOut, _amountsOut, _upperHint, _lowerHint);
    }

    function withdrawYUSD(uint _amount, address _upperHint, address _lowerHint, uint _maxFee) external {
        borrowerOperations.withdrawYUSD(_maxFee, _amount, _upperHint, _lowerHint);
    }

    function repayYUSD(uint _amount, address _upperHint, address _lowerHint) external {
        borrowerOperations.repayYUSD(_amount, _upperHint, _lowerHint);
    }

    function closeTrove() external {
        borrowerOperations.closeTrove();
    }

    function adjustTrove(address[] memory _collsIn,
        uint[] memory _amountsIn,
        address[] memory _collsOut,
        uint[] memory _amountsOut,
        uint _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint _maxFeePercentage) external payable {
        borrowerOperations.adjustTrove(_collsIn,
            _amountsIn,
            _collsOut, _amountsOut, _YUSDChange, _isDebtIncrease, _upperHint, _lowerHint, _maxFeePercentage);
    }

    function claimCollateral() external {
        borrowerOperations.claimCollateral();
    }
}",557
RealWorld_TA_66_LiquityMath_RealWorld_20240808233605.log,66,LiquityMath,95207,1898,97105,76.0,0.513995,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./SafeMath.sol"";

library LiquityMath {
    using SafeMath for uint;

    uint internal constant DECIMAL_PRECISION = 1e18;
    uint internal constant HALF_DECIMAL_PRECISION = 5e17;

    function _min(uint _a, uint _b) internal pure returns (uint) {
        return (_a < _b) ? _a : _b;
    }

    function _max(uint _a, uint _b) internal pure returns (uint) {
        return (_a >= _b) ? _a : _b;
    }

    /* 
    * Multiply two decimal numbers and use normal rounding rules:
    * -round product up if 19'th mantissa digit >= 5
    * -round product down if 19'th mantissa digit < 5
    *
    * Used only inside the exponentiation, _decPow().
    */
    function decMul(uint x, uint y) internal pure returns (uint decProd) {
        uint prod_xy = x.mul(y);

        decProd = prod_xy.add(HALF_DECIMAL_PRECISION).div(DECIMAL_PRECISION);
    }

    /* 
    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.
    * 
    * Uses the efficient ""exponentiation by squaring"" algorithm. O(log(n)) complexity. 
    * 
    * Called by two functions that represent time in units of minutes:
    * 1) TroveManager._calcDecayedBaseRate
    * 2) CommunityIssuance._getCumulativeIssuanceFraction 
    * 
    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals
    * ""minutes in 1000 years"": 60 * 24 * 365 * 1000
    * 
    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be
    * negligibly different from just passing the cap, since: 
    *
    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years
    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible
    */
    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {
       
        if (_minutes > 5256e5) {_minutes = 5256e5;}  // cap to avoid overflow
    
        if (_minutes == 0) {return DECIMAL_PRECISION;}

        uint y = DECIMAL_PRECISION;
        uint x = _base;
        uint n = _minutes;

        // Exponentiation-by-squaring
        while (n > 1) {
            if (n % 2 == 0) {
                x = decMul(x, x);
                n = n.div(2);
            } else { // if (n % 2 != 0)
                y = decMul(x, y);
                x = decMul(x, x);
                n = (n.sub(1)).div(2);
            }
        }

        return decMul(x, y);
  }

    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {
        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);
    }

    //  _coll should be the amount of VC and _debt is debt of YUSD\
    // new collateral ratio is 10**18 times the collateral ratio. (150% => 1.5e18)
    function _computeCR(uint _coll, uint _debt) internal pure returns (uint) {
        if (_debt != 0) {
            uint newCollRatio = _coll.mul(1e18).div(_debt);
            return newCollRatio;
        }
        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents ""infinite"" CR.
        else { // if (_debt == 0)
            return 2**256 - 1; 
        }
    }

}",912
RealWorld_TA_66_LiquitySafeMath128_RealWorld_20240808233229.log,66,LiquitySafeMath128,30303,1552,31855,74.0,0.182555,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

// uint128 addition and subtraction, with overflow protection.

library LiquitySafeMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128) {
        uint128 c = a + b;
        require(c >= a, ""LiquitySafeMath128: addition overflow"");

        return c;
    }
   
    function sub(uint128 a, uint128 b) internal pure returns (uint128) {
        require(b <= a, ""LiquitySafeMath128: subtraction overflow"");
        uint128 c = a - b;

        return c;
    }
}",140
RealWorld_TA_66_Address_RealWorld_20240808231413.log,66,Address,148863,2058,150921,87.0,0.785475,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size != 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, ""Address: insufficient balance"");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("""");
        require(success, ""Address: unable to send value, recipient may have reverted"");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain`call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, ""Address: low-level call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, ""Address: low-level call with value failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, ""Address: insufficient balance for call"");
        require(isContract(target), ""Address: call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, ""Address: low-level static call failed"");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), ""Address: static call to non-contract"");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length != 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}",1557
RealWorld_TA_66_PriceFeedTestnet_RealWorld_20240809000232.log,66,PriceFeedTestnet,40825,2430,43255,98.0,0.252725,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IPriceFeed.sol"";

/*
* PriceFeed placeholder for testnet and development. The price is simply set manually and saved in a state 
* variable. The contract does not connect to a live Chainlink price feed. 
*/
contract PriceFeedTestnet is IPriceFeed {
    
    uint256 private _price = 200 * 1e18;

    // --- Functions ---

    // View price getter for simplicity in tests
    function getPrice() external view returns (uint256) {
        return _price;
    }

    // function fetchPrice() external override returns (uint256) {
    //     // Fire an event just like the mainnet version would.
    //     // This lets the subgraph rely on events to get the latest price even when developing locally.
    //     emit LastGoodPriceUpdated(_price);
    //     return _price;
    // }

    function fetchPrice_v() view external override returns (uint) {
        return _price;
    }

    // Manual external price setter.
    function setPrice(uint256 price) external returns (bool) {
        _price = price;
        return true;
    }
}",255
RealWorld_TA_66_IPriceFeed_RealWorld_20240809012806.log,66,IPriceFeed,24422,1526,25948,79.0,0.15263,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface IPriceFeed {

    // --- Events ---
    event LastGoodPriceUpdated(uint _lastGoodPrice);

    // --- Function ---
    // function fetchPrice() external returns (uint);

    function fetchPrice_v() view external returns (uint);
}",69
RealWorld_TA_66_ISortedTroves_RealWorld_20240809005808.log,66,ISortedTroves,50453,1550,52003,77.0,0.283265,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

// Common interface for the SortedTroves Doubly Linked List.
interface ISortedTroves {

    // --- Events ---
    
    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);
    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);
    event NodeAdded(address _id, uint _NICR);
    event NodeRemoved(address _id);

    // --- Functions ---
    
    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress, address _troveManagerRedemptionsAddress) external;

    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;

    function remove(address _id) external;

    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;

    function contains(address _id) external view returns (bool);

    function isFull() external view returns (bool);

    function isEmpty() external view returns (bool);

    function getSize() external view returns (uint256);

    function getMaxSize() external view returns (uint256);

    function getFirst() external view returns (address);

    function getLast() external view returns (address);

    function getNext(address _id) external view returns (address);

    function getPrev(address _id) external view returns (address);

    function getOldICR(address _id) external view returns (uint256);

    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);

    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);
}",375
RealWorld_TA_66_ISYETI_RealWorld_20240809013616.log,66,ISYETI,76083,1648,77731,78.0,0.413375,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ISYETI {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);

    function mint(uint256 amount) external returns (bool);
    function burn(address to, uint256 shares) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",693
RealWorld_TA_66_AAVETokenOracle_RealWorld_20240808230430.log,66,AAVETokenOracle,37088,2940,40028,96.0,0.24424,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import '../Dependencies/SafeMath.sol';

import '../Interfaces/IBaseOracle.sol';

import ""../Dependencies/Ownable.sol"";

interface IWAAVE {
    function aavePerShare() external returns (uint);
}

contract AAVEOracle is Ownable {
  using SafeMath for uint;

  IBaseOracle base;
  address underlying;
  IWAAVE WAAVE;

  function setParam(IBaseOracle _base, address _WAAVE, address _underlying) external onlyOwner {
    base = _base;
    underlying = _underlying;
    WAAVE=IWAAVE(_WAAVE);
  }

  function fetchPrice_v() external returns (uint) {
    return WAAVE.aavePerShare()*base.getPrice(underlying)/1e18;
  }
  function fetchPrice() external returns (uint) {
    return WAAVE.aavePerShare()*base.getPrice(underlying)/1e18;
  }
}",213
RealWorld_TA_66_IYetiRouter_RealWorld_20240809013458.log,66,IYetiRouter,45751,1652,47403,76.0,0.261795,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

// Interface which handles routing of tokens to between wrapped versions etc and YUSD or other ERC20s. 
interface IYetiRouter {

    // Goes from some token (YUSD likely) and gives a certain amount of token out.
    // Auto transfers to active pool. 
    // Goes from _startingTokenAddress to _endingTokenAddress, pulling tokens from _fromUser, of _amount, and gets _minSwapAmount out _endingTokenAddress
    function route(address _fromUser, address _startingTokenAddress, address _endingTokenAddress, uint _amount, uint _minSwapAmount) external returns (uint256 _amountOut);

    // Takes the address of the token required in, and gives a certain amount of any token (YUSD likely) out
    // User first withdraws that collateral from the active pool, then performs this swap. Unwraps tokens
    // for the user in that case. 
    // Goes from _startingTokenAddress to _endingTokenAddress, pulling tokens from _fromUser, of _amount, and gets _minSwapAmount out _endingTokenAddress. 
    // Use case: Takes token from trove debt which has been transfered to the owner and then swaps it for YUSD, intended to repay debt. 
    function unRoute(address _fromUser, address _startingTokenAddress, address _endingTokenAddress, uint _amount, uint _minSwapAmount) external returns (uint256 _amountOut);
}",322
RealWorld_TA_66_CheckContract_RealWorld_20240808231949.log,66,CheckContract,30277,1488,31765,71.0,0.181145,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


contract CheckContract {
    /**
     * Check that the account is an already deployed non-destroyed contract.
     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12
     */
    function checkContract(address _account) internal view {
        require(_account != address(0), ""Account cannot be zero address"");

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(_account) }
        require(size != 0, ""Account code size cannot be zero"");
    }
}",144
RealWorld_TA_66_BQITokenOracle_RealWorld_20240808230250.log,66,BQITokenOracle,37898,3470,41368,98.0,0.25889,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import '../Dependencies/SafeMath.sol';

import '../Interfaces/IBaseOracle.sol';

import ""../Dependencies/Ownable.sol"";

interface IQIToken {
    function exchangeRateCurrent() external returns (uint);
    function underlying() external returns (address);
}

contract BQIOracle is Ownable {
  using SafeMath for uint;

  IBaseOracle base;
  address underlying;
  IQIToken BQI;

  function setParam(IBaseOracle _base, address _BQI, address _underlying) external onlyOwner {
    base = _base;
    underlying = _underlying;
    BQI=IQIToken(_BQI);
  }

  function fetchPrice_v() external returns (uint) {
    return BQI.exchangeRateCurrent()*base.getPrice(underlying)/1e18;
  }
  function fetchPrice() external returns (uint) {
    return BQI.exchangeRateCurrent()*base.getPrice(underlying)/1e18;
  }
}",220
RealWorld_TA_66_Destructible_RealWorld_20240809001632.log,66,Destructible,23941,2954,26895,104.0,0.178785,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

contract Destructible {
    
    receive() external payable {}
    
    function destruct(address payable _receiver) external {
        selfdestruct(_receiver);
    }
}",50
RealWorld_TA_66_IWAsset_RealWorld_20240809005414.log,66,IWAsset,32029,2732,34761,90.0,0.214785,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.7;


// Wrapped Asset
interface IWAsset {

    function wrap(uint _amount, address _from, address _to, address _rewardOwner) external;

    function unwrap(uint amount) external;

    function unwrapFor(address _from, address _to, uint amount) external;

    function updateReward(address from, address to, uint amount) external;

    function claimReward(address _to) external;

    function getPendingRewards(address _for) external view returns (address[] memory tokens, uint[] memory amounts);

    function getUserInfo(address _user) external returns (uint, uint, uint);

    function endTreasuryReward(address _to, uint _amount) external;
}",156
RealWorld_TA_66_LQTYStaking_RealWorld_20240808215721.log,66,LQTYStaking,205635,5781,211416,146.0,1.143795,"SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""../Dependencies/BaseMath.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";
import ""../Dependencies/CheckContract.sol"";
import ""hardhat/console.sol"";
import ""../Interfaces/IYETIToken.sol"";
import ""../Interfaces/ISYETI.sol"";
import ""../Dependencies/LiquityMath.sol"";
import ""../Interfaces/IYUSDToken.sol"";

contract SYETI is ISYETI, Ownable, CheckContract, BaseMath {
    using SafeMath for uint;

    // --- Data ---
    bytes32 constant public NAME = ""YETIStaking"";

    mapping( address => uint) public stakes;
    uint public totalYETIStaked;

    uint public F_YUSD; // Running sum of YETI fees per-YETI-staked

    // User snapshots of F_YUSD, taken at the point at which their latest deposit was made
    mapping (address => Snapshot) public snapshots;

    struct Snapshot {
        uint F_YUSD_Snapshot;
    }

    IYETIToken public yetiToken;
    IYUSDToken public yusdToken;

    address public troveManagerAddress;
    address public troveManagerRedemptionsAddress;
    address public borrowerOperationsAddress;
    address public activePoolAddress;

    // --- Events ---

    event YETITokenAddressSet(address _yetiTokenAddress);
    event YUSDTokenAddressSet(address _yusdTokenAddress);
    event TroveManagerAddressSet(address _troveManager);
    event TroveManagerRedemptionsAddressSet(address _troveManagerRedemptionsAddress);
    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);
    event ActivePoolAddressSet(address _activePoolAddress);

    event StakeChanged(address indexed staker, uint newStake);
    event StakingGainsWithdrawn(address indexed staker, uint YUSDGain);
    event F_YUSDUpdated(uint _F_YUSD);
    event TotalYETIStakedUpdated(uint _totalYETIStaked);
    event EtherSent(address _account, uint _amount);
    event StakerSnapshotsUpdated(address _staker, uint _F_YUSD);

    // --- Functions ---

    function setAddresses
    (
        address _yetiTokenAddress,
        address _yusdTokenAddress,
        address _troveManagerAddress,
        address _troveManagerRedemptionsAddress,
        address _borrowerOperationsAddress,
        address _activePoolAddress
    )
        external
        onlyOwner
        override
    {
        checkContract(_yetiTokenAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_troveManagerAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);

        yetiToken = IYETIToken(_yetiTokenAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        troveManagerAddress = _troveManagerAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePoolAddress = _activePoolAddress;

        emit YETITokenAddressSet(_yetiTokenAddress);
        emit YETITokenAddressSet(_yusdTokenAddress);
        emit TroveManagerAddressSet(_troveManagerAddress);
        emit TroveManagerRedemptionsAddressSet(_troveManagerRedemptionsAddress);
        emit BorrowerOperationsAddressSet(_borrowerOperationsAddress);
        emit ActivePoolAddressSet(_activePoolAddress);

        _renounceOwnership();
    }

    // If caller has a pre-existing stake, send any accumulated YUSD gains to them.
    function stake(uint _YETIamount) external override {
        _requireNonZeroAmount(_YETIamount);

        uint currentStake = stakes[msg.sender];

//        uint ETHGain;
        uint YUSDGain;
        // Grab any accumulated ETH and YUSD gains from the current stake
        if (currentStake != 0) {
//            ETHGain = _getPendingETHGain(msg.sender);
            YUSDGain = _getPendingYUSDGain(msg.sender);
        }

       _updateUserSnapshots(msg.sender);

        uint newStake = currentStake.add(_YETIamount);

        // Increase users stake and total YETI staked
        stakes[msg.sender] = newStake;
        totalYETIStaked = totalYETIStaked.add(_YETIamount);
        emit TotalYETIStakedUpdated(totalYETIStaked);

        // Transfer YETI from caller to this contract
        yetiToken.sendToSYETI(msg.sender, _YETIamount);

        emit StakeChanged(msg.sender, newStake);
        emit StakingGainsWithdrawn(msg.sender, YUSDGain);

         // Send accumulated YUSD gains to the caller
        if (currentStake != 0) {
            yusdToken.transfer(msg.sender, YUSDGain);
//            _sendETHGainToUser(ETHGain);
        }
    }

    // Unstake the YETI and send the it back to the caller, along with their accumulated YUSD gains.
    // If requested amount > stake, send their entire stake.
    function unstake(uint _YETIamount) external override {
        uint currentStake = stakes[msg.sender];
        _requireUserHasStake(currentStake);

        // Grab any accumulated YUSD gains from the current stake
//        uint ETHGain = _getPendingETHGain(msg.sender);
        uint YUSDGain = _getPendingYUSDGain(msg.sender);

        _updateUserSnapshots(msg.sender);

        if (_YETIamount != 0) {
            uint YETIToWithdraw = LiquityMath._min(_YETIamount, currentStake);

            uint newStake = currentStake.sub(YETIToWithdraw);

            // Decrease user's stake and total YETI staked
            stakes[msg.sender] = newStake;
            totalYETIStaked = totalYETIStaked.sub(YETIToWithdraw);
            emit TotalYETIStakedUpdated(totalYETIStaked);

            // Transfer unstaked YETI to user
            yetiToken.transfer(msg.sender, YETIToWithdraw);

            emit StakeChanged(msg.sender, newStake);
        }

        emit StakingGainsWithdrawn(msg.sender, YUSDGain);

        // Send accumulated YUSD gains to the caller
        yusdToken.transfer(msg.sender, YUSDGain);
//        _sendETHGainToUser(ETHGain);
    }

    // --- Reward-per-unit-staked increase functions. Called by Liquity core contracts ---

//    function increaseF_ETH(uint _ETHFee) external override {
//        _requireCallerIsTroveManager();
//        uint ETHFeePerYETIStaked;
//
//        if (totalYETIStaked != 0) {ETHFeePerYETIStaked = _ETHFee.mul(DECIMAL_PRECISION).div(totalYETIStaked);}
//
//        F_ETH = F_ETH.add(ETHFeePerYETIStaked);
//        emit F_ETHUpdated(F_ETH);
//    }

    function increaseF_YUSD(uint _YUSDFee) external override {
        _requireCallerIsBOOrTM();
        uint YUSDFeePerYETIStaked;

        if (totalYETIStaked != 0) {YUSDFeePerYETIStaked = _YUSDFee.mul(DECIMAL_PRECISION).div(totalYETIStaked);}

        F_YUSD = F_YUSD.add(YUSDFeePerYETIStaked);
        emit F_YUSDUpdated(F_YUSD);
    }

    // --- Pending reward functions ---

//    function getPendingETHGain(address _user) external view override returns (uint) {
//        return _getPendingETHGain(_user);
//    }
//
//    function _getPendingETHGain(address _user) internal view returns (uint) {
//        uint F_ETH_Snapshot = snapshots[_user].F_ETH_Snapshot;
//        uint ETHGain = stakes[_user].mul(F_ETH.sub(F_ETH_Snapshot)).div(DECIMAL_PRECISION);
//        return ETHGain;
//    }

    function getPendingYUSDGain(address _user) external view override returns (uint) {
        return _getPendingYUSDGain(_user);
    }

    function _getPendingYUSDGain(address _user) internal view returns (uint) {
        uint F_YUSD_Snapshot = snapshots[_user].F_YUSD_Snapshot;
        uint YUSDGain = stakes[_user].mul(F_YUSD.sub(F_YUSD_Snapshot)).div(DECIMAL_PRECISION);
        return YUSDGain;
    }

    // --- Internal helper functions ---

    function _updateUserSnapshots(address _user) internal {
//        snapshots[_user].F_ETH_Snapshot = F_ETH;
        snapshots[_user].F_YUSD_Snapshot = F_YUSD;
        emit StakerSnapshotsUpdated(_user, F_YUSD);
    }

//    function _sendETHGainToUser(uint ETHGain) internal {
//        emit EtherSent(msg.sender, ETHGain);
//        (bool success, ) = msg.sender.call{value: ETHGain}("""");
//        require(success, ""SYETI: Failed to send accumulated ETHGain"");
//    }

    // --- 'require' functions ---

    function _requireCallerIsTroveManager() internal view {
        require(msg.sender == troveManagerAddress, ""SYETI: caller is not TroveM"");
    }

    function _requireCallerIsBOOrTM() internal view {
        require(((msg.sender == troveManagerAddress)
        || (msg.sender == borrowerOperationsAddress))
        || (msg.sender == troveManagerRedemptionsAddress),
            ""SYETI: caller is not BorrowerOps"");
    }

     function _requireCallerIsActivePool() internal view {
        require(msg.sender == activePoolAddress, ""SYETI: caller is not ActivePool"");
    }

    function _requireUserHasStake(uint currentStake) internal pure {
        require(currentStake != 0, 'SYETI: User must have a non-zero stake');
    }

    function _requireNonZeroAmount(uint _amount) internal pure {
        require(_amount != 0, 'SYETI: Amount must be non-zero');
    }

    receive() external payable {
        _requireCallerIsActivePool();
    }
}",2246
RealWorld_TA_66_ITellorCaller_RealWorld_20240809013041.log,66,ITellorCaller,22864,1604,24468,71.0,0.1464,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ITellorCaller {
    function getTellorCurrentValue(uint256 _requestId) external view returns (bool, uint256, uint256);
}",49
RealWorld_TA_66_IUnipool_RealWorld_20240808231718.log,66,IUnipool,28595,2184,30779,77.0,0.186655,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


interface IUnipool {
    function setParams(address _yetiTokenAddress, address _uniTokenAddress, uint256 _duration) external;
    function lastTimeRewardApplicable() external view returns (uint256);
    function rewardPerToken() external view returns (uint256);
    function earned(address account) external view returns (uint256);
    function withdrawAndClaim() external;
    function claimReward() external;
    //function notifyRewardAmount(uint256 reward) external;
}",117
RealWorld_TA_66_ICollSurplusPool_RealWorld_20240809011458.log,66,ICollSurplusPool,42506,1965,44471,80.0,0.25183,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/YetiCustomBase.sol"";
import ""./ICollateralReceiver.sol"";


interface ICollSurplusPool is ICollateralReceiver {

    // --- Events ---
    
    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);

    event CollBalanceUpdated(address indexed _account);
    event CollateralSent(address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _troveManagerRedemptionsAddress,
        address _activePoolAddress,
        address _whitelistAddress
    ) external;

    function getCollVC() external view returns (uint);

    function getAmountClaimable(address _account, address _collateral) external view returns (uint);

    function getCollateral(address _collateral) external view returns (uint);

    function getAllCollateral() external view returns (address[] memory, uint256[] memory);

    function accountSurplus(address _account, address[] memory _tokens, uint[] memory _amounts) external;

    function claimColl(address _account) external;

    function addCollateralType(address _collateral) external;
}",290
RealWorld_TA_66_AggregatorV3Interface_RealWorld_20240808233114.log,66,AggregatorV3Interface,38873,1615,40488,73.0,0.226665,"// SPDX-License-Identifier: UNLICENSED
// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol

pragma solidity 0.6.11;

interface AggregatorV3Interface {

  function decimals() external view returns (uint8);
  function description() external view returns (string memory);
  function version() external view returns (uint256);

  // getRoundData and latestRoundData should both raise ""No data present""
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    );
}",237
RealWorld_TA_66_MultiTroveGetter_RealWorld_20240808221400.log,66,MultiTroveGetter,102512,3625,106137,98.0,0.58506,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;
pragma experimental ABIEncoderV2;

import ""./TroveManager.sol"";
import ""./SortedTroves.sol"";
import ""./Dependencies/Whitelist.sol"";

/*  Helper contract for grabbing Trove data for the front end. Not part of the core Liquity system. */
contract MultiTroveGetter {
    struct CombinedTroveData {
        address owner;

        uint debt;
        address[] colls;
        uint[] amounts;

        address[] allColls;
        uint[] stakeAmounts;
        uint[] snapshotAmounts;
        uint[] snapshotYUSDDebts;
    }

    TroveManager public troveManager; // XXX Troves missing from ITroveManager?
    ISortedTroves public sortedTroves;
    IWhitelist public whitelist;

    constructor(TroveManager _troveManager, ISortedTroves _sortedTroves, IWhitelist _whitelist) public {
        troveManager = _troveManager;
        sortedTroves = _sortedTroves;
        whitelist = _whitelist;
    }

    function getMultipleSortedTroves(int _startIdx, uint _count)
        external view returns (CombinedTroveData[] memory _troves)
    {
        uint startIdx;
        bool descend;

        if (_startIdx >= 0) {
            startIdx = uint(_startIdx);
            descend = true;
        } else {
            startIdx = uint(-(_startIdx + 1));
            descend = false;
        }

        uint sortedTrovesSize = sortedTroves.getSize();

        if (startIdx >= sortedTrovesSize) {
            _troves = new CombinedTroveData[](0);
        } else {
            uint maxCount = sortedTrovesSize - startIdx;

            if (_count > maxCount) {
                _count = maxCount;
            }

            if (descend) {
                _troves = _getMultipleSortedTrovesFromHead(startIdx, _count);
            } else {
                _troves = _getMultipleSortedTrovesFromTail(startIdx, _count);
            }
        }
    }

    function _getMultipleSortedTrovesFromHead(uint _startIdx, uint _count)
        internal view returns (CombinedTroveData[] memory _troves)
    {
        address currentTroveowner = sortedTroves.getFirst();

        for (uint idx = 0; idx < _startIdx; ++idx) {
            currentTroveowner = sortedTroves.getNext(currentTroveowner);
        }

        _troves = new CombinedTroveData[](_count);

        for (uint idx = 0; idx < _count; ++idx) {
            _troves[idx] = _getCombinedTroveData(currentTroveowner);
            currentTroveowner = sortedTroves.getNext(currentTroveowner);
        }
    }

    function _getMultipleSortedTrovesFromTail(uint _startIdx, uint _count)
        internal view returns (CombinedTroveData[] memory _troves)
    {
        address currentTroveowner = sortedTroves.getLast();

        for (uint idx = 0; idx < _startIdx; ++idx) {
            currentTroveowner = sortedTroves.getPrev(currentTroveowner);
        }

        _troves = new CombinedTroveData[](_count);

        for (uint idx = 0; idx < _count; ++idx) {
            _troves[idx] = _getCombinedTroveData(currentTroveowner);
            currentTroveowner = sortedTroves.getPrev(currentTroveowner);
        }
    }

    function _getCombinedTroveData(address _troveOwner) internal view returns (CombinedTroveData memory data) {
        data.owner = _troveOwner;
        data.debt = troveManager.getTroveDebt(_troveOwner);
        (data.colls, data.amounts) = troveManager.getTroveColls(_troveOwner);

        data.allColls = whitelist.getValidCollateral();
        data.stakeAmounts = new uint[](data.allColls.length);
        data.snapshotAmounts = new uint[](data.allColls.length);
        uint256 collsLen = data.allColls.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = data.allColls[i];

            data.stakeAmounts[i] = troveManager.getTroveStake(_troveOwner, token);
            data.snapshotAmounts[i] = troveManager.getRewardSnapshotColl(_troveOwner, token);
            data.snapshotYUSDDebts[i] = troveManager.getRewardSnapshotYUSD(_troveOwner, token);
        }
    }
}",992
RealWorld_TA_66_MockAggregator_RealWorld_20240809002821.log,66,MockAggregator,75000,3294,78294,102.0,0.44088,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/AggregatorV3Interface.sol"";
import ""hardhat/console.sol"";

contract MockAggregator is AggregatorV3Interface {
    
    // storage variables to hold the mock data
    uint8 private decimalsVal = 8;
    int private price;
    int private prevPrice;
    uint private updateTime;
    uint private prevUpdateTime;

    uint80 private latestRoundId;
    uint80 private prevRoundId;

    bool latestRevert;
    bool prevRevert;
    bool decimalsRevert;

    // --- Functions ---

    function setDecimals(uint8 _decimals) external {
        decimalsVal = _decimals;
    }

    function setPrice(int _price) external {
        price = _price;
    }

    function setPrevPrice(int _prevPrice) external {
        prevPrice = _prevPrice;
    }

    function setPrevUpdateTime(uint _prevUpdateTime) external {
        prevUpdateTime = _prevUpdateTime;
    }

    function setUpdateTime(uint _updateTime) external  {
        updateTime = _updateTime;
    }

    function setLatestRevert() external  {
        latestRevert = !latestRevert;
    }

    function setPrevRevert() external  {
        prevRevert = !prevRevert;
    }

    function setDecimalsRevert() external {
        decimalsRevert = !decimalsRevert;
    }

    function setLatestRoundId(uint80 _latestRoundId) external {
        latestRoundId = _latestRoundId;
    }

      function setPrevRoundId(uint80 _prevRoundId) external {
        prevRoundId = _prevRoundId;
    }
    

    // --- Getters that adhere to the AggregatorV3 interface ---

    function decimals() external override view returns (uint8) {
        if (decimalsRevert) {require(1== 0, ""decimals reverted"");}

        return decimalsVal;
    }

    function latestRoundData()
        external
        override
        view
    returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    ) 
    {    
        if (latestRevert) { require(1== 0, ""latestRoundData reverted"");}

        return (latestRoundId, price, 0, updateTime, 0); 
    }

    function getRoundData(uint80)
    external
    override 
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    ) {
        if (prevRevert) {require( 1== 0, ""getRoundData reverted"");}

        return (prevRoundId, prevPrice, 0, updateTime, 0);
    }

    function description() external override view returns (string memory) {
        return """";
    }
    function version() external override view returns (uint256) {
        return 1;
    }
}",645
RealWorld_TA_66_IYETIToken_RealWorld_20240809014146.log,66,IYETIToken,25545,1985,27530,78.0,0.167425,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./IERC20.sol"";
import ""./IERC2612.sol"";

interface IYETIToken is IERC20, IERC2612 {

    function sendToSYETI(address _sender, uint256 _amount) external;

    function getDeploymentStartTime() external view returns (uint256);

}",81
RealWorld_TA_66_ITroveManagerLiquidations_RealWorld_20240809011058.log,66,ITroveManagerLiquidations,22680,1792,24472,77.0,0.14924,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


interface ITroveManagerLiquidations {
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external;
}",48
RealWorld_TA_66_ERC20Router_RealWorld_20240808224716.log,66,ERC20Router,83120,4477,87597,110.0,0.50514,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""../Interfaces/IYetiRouter.sol"";
import ""../Interfaces/IERC20.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../YUSDToken.sol"";

// ERC20 router contract to be used for routing YUSD -> ERC20 and then wrapping.
// simple router using TJ router. 
contract ERC20Router is IYetiRouter {
    using SafeMath for uint256;

    address internal activePoolAddress;
    address internal traderJoeRouter;
    address internal yusdTokenAddress;
    string public name;

    constructor(
        string memory _name,
        address _activePoolAddress,
        address _traderJoeRouter, 
        address _yusdTokenAddress
    ) public {
        name = _name;
        activePoolAddress = _activePoolAddress;
        traderJoeRouter = _traderJoeRouter;
        yusdTokenAddress = _yusdTokenAddress;
    }

    // Takes the address of the token in, and gives a certain amount of token out.
    // Auto transfers to active pool.
    function route(
        address _fromUser,
        address _startingTokenAddress,
        address _endingTokenAddress,
        uint256 _amount,
        uint256 _minSwapAmount
    ) public override returns (uint256) {
        require(
            _startingTokenAddress == yusdTokenAddress,
            ""Cannot route from a token other than YUSD""
        );
        address[] memory path = new address[](2);
        path[0] = yusdTokenAddress;
        path[1] = _endingTokenAddress;
        IERC20(yusdTokenAddress).transferFrom(_fromUser, address(this), _amount);
        IERC20(yusdTokenAddress).approve(traderJoeRouter, _amount);
        uint256[] memory amounts = IRouter(traderJoeRouter).swapExactTokensForTokens(
            _amount,
            1,
            path,
            activePoolAddress,
            block.timestamp
        );
        require(
            amounts[1] >= _minSwapAmount,
            ""Did not receive enough tokens to account for slippage""
        );

        return amounts[1];
    }

    function unRoute(
        address _fromUser,
        address _startingTokenAddress,
        address _endingTokenAddress,
        uint256 _amount,
        uint256 _minSwapAmount
    ) external override returns (uint256) {
        require(
            _endingTokenAddress == yusdTokenAddress,
            ""Cannot unroute from a token other than YUSD""
        );
        address[] memory path = new address[](2);
        path[0] = _startingTokenAddress;
        path[1] = yusdTokenAddress;
        IERC20(_startingTokenAddress).transferFrom(_fromUser, address(this), _amount);
        IERC20(_startingTokenAddress).approve(traderJoeRouter, _amount);
        uint256[] memory amounts = IRouter(traderJoeRouter).swapExactTokensForTokens(
            _amount,
            1,
            path,
            _fromUser,
            block.timestamp
        );
        require(
            amounts[1] >= _minSwapAmount,
            ""Did not receive enough tokens to account for slippage""
        );

        return amounts[1];

    }
}

// Router for Uniswap V2, performs YUSD -> YETI swaps
interface IRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}",766
RealWorld_TA_66_ICommunityIssuance_RealWorld_20240809012345.log,66,ICommunityIssuance,30652,2571,33223,89.0,0.20468,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ICommunityIssuance { 
    
    // --- Events ---
    
    event YETITokenAddressSet(address _yetiTokenAddress);
    event StabilityPoolAddressSet(address _stabilityPoolAddress);
    event TotalYETIIssuedUpdated(uint _totalYETIIssued);

    // --- Functions ---

    function setAddresses(address _yetiTokenAddress, address _stabilityPoolAddress) external;

    function issueYETI() external returns (uint);

    function sendYETI(address _account, uint _YETIamount) external;
}",136
RealWorld_TA_66_GasPool_RealWorld_20240808221932.log,66,GasPool,33083,1290,34373,69.0,0.191215,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;


/**
 * The purpose of this contract is to hold YUSD tokens for gas compensation:
 * https://github.com/liquity/dev#gas-compensation
 * When a borrower opens a trove, an additional 50 YUSD debt is issued,
 * and 50 YUSD is minted and sent to this contract.
 * When a borrower closes their active trove, this gas compensation is refunded:
 * 50 YUSD is burned from the this contract's balance, and the corresponding
 * 50 YUSD debt on the trove is cancelled.
 * See this issue for more context: https://github.com/liquity/dev/issues/186
 */
contract GasPool {
    // do nothing, as the core contracts have permission to send to and burn from this address
}",176
RealWorld_TA_66_CDPManagerTester_RealWorld_20240809001413.log,66,CDPManagerTester,116703,5792,122495,137.0,0.699355,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../TroveManager.sol"";

/* Tester contract inherits from TroveManager, and provides external functions 
for testing the parent's internal functions. */

contract TroveManagerTester is TroveManager {

    function computeICR(address[] memory _tokens, uint[] memory _amounts, uint _debt) external view returns (uint) {
        uint sumCollateralVCs;
        for (uint i = 0; i < _amounts.length; i++) {
            sumCollateralVCs = sumCollateralVCs.add(whitelist.getValueVC(_tokens[i], _amounts[i]));
        }
        return LiquityMath._computeCR(sumCollateralVCs, _debt);
    }

//    function getCollGasCompensation(address[] memory _tokens, uint[] memory _amounts) external view returns (address[] memory, uint[] memory) {
//        newColls memory coll;
//        coll.tokens = _tokens;
//        coll.amounts = _amounts;
//        newColls memory CollGasCompensation = _getCollGasCompensation(coll);
//        return (CollGasCompensation.tokens,  CollGasCompensation.amounts);
//    }

    function getYUSDGasCompensation() external pure returns (uint) {
        return YUSD_GAS_COMPENSATION;
    }

    function getCompositeDebt(uint _debt) external pure returns (uint) {
        return _getCompositeDebt(_debt);
    }

    function unprotectedDecayBaseRateFromBorrowing() external returns (uint) {
        baseRate = calcDecayedBaseRate();
        require(baseRate >= 0 && baseRate <= DECIMAL_PRECISION, ""unprotectedDecayBaseRateFromBorrowing: bad baseRate"");
        
        _updateLastFeeOpTime();
        return baseRate;
    }

    function minutesPassedSinceLastFeeOp() external view returns (uint) {
        return _minutesPassedSinceLastFeeOp();
    }

    function setLastFeeOpTimeToNow() external {
        lastFeeOperationTime = block.timestamp;
    }

    function setBaseRate(uint _baseRate) external {
        baseRate = _baseRate;
    }

    function callGetRedemptionFee(uint _YUSDRedeemed) external view returns (uint) {
        _getRedemptionFee(_YUSDRedeemed);
    }  

    function getActualDebtFromComposite(uint _debtVal) external pure returns (uint) {
        return _getNetDebt(_debtVal);
    }

    function callInternalRemoveTroveOwner(address _troveOwner) external {
        // uint troveOwnersArrayLength = getTroveOwnersCount();
        // _removeTroveOwner(_troveOwner, troveOwnersArrayLength);
    }

    function getTotalStakes(address _collADdress) external view returns (uint) {
        return totalStakes[_collADdress];
    }

    function getTroveIndex(address _troveAddress) external view returns (uint) {
        return Troves[_troveAddress].arrayIndex;
    }

    // _price is no longer used but just useful so we don't have to rewrite test cases
    // function getCurrentICR(address _troveAddress, uint _price) external view returns (uint) {
    //     return getCurrentICR(_troveAddress);
    // }

    function getEDC(address _troveAddress) external view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint YUSDdebt) = _getCurrentTroveState(_troveAddress);
        return (colls.tokens, colls.amounts, YUSDdebt);
    }
    // for testing-easier to convert getCollGasCompensation calls to use this
    function getCollGasCompensation(address _token, uint _amount) external pure returns (uint) {
        address[] memory tokens = new address[](1);
        tokens[0] = _token;

        uint[] memory amounts = new uint[](1);
        amounts[0] = _amount;

        newColls memory totalColl = newColls(tokens, amounts);

        newColls memory compensation = _getCollGasCompensation(totalColl);
        uint ans = compensation.amounts[0];
        return ans;
    }

    function getVC(address[] memory _tokens, uint[] memory _amounts) external view returns (uint) {
        return _getVC(_tokens, _amounts);
    }

    function getUSD(address[] memory _tokens, uint[] memory _amounts) external view returns (uint) {
        newColls memory coll;
        coll.tokens = _tokens;
        coll.amounts = _amounts;
        return _getUSDColls(coll);
    }

    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, ""Not same length"");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }

}",1142
RealWorld_TA_66_LQTYToken_RealWorld_20240808215950.log,66,LQTYToken,296952,4555,301507,125.0,1.57586,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""../Dependencies/CheckContract.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Interfaces/IYETIToken.sol"";
import ""../Interfaces/ILockupContractFactory.sol"";
import ""hardhat/console.sol"";

/*
* Based upon OpenZeppelin's ERC20 contract:
* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol
*  
* and their EIP2612 (ERC20Permit / ERC712) functionality:
* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol
* 
*
*  --- Functionality added specific to the YETIToken ---
* 
* 1) Transfer protection: blacklist of addresses that are invalid recipients (i.e. core Liquity contracts) in external 
* transfer() and transferFrom() calls. The purpose is to protect users from losing tokens by mistakenly sending YETI directly to a Liquity
* core contract, when they should rather call the right function.
*
* 2) sendToSYETI(): callable only by Liquity core contracts, which move YETI tokens from user -> SYETI contract.
*
* 3) Supply hard-capped at 100 million
*
* 4) CommunityIssuance and LockupContractFactory addresses are set at deployment
*
* 5) The bug bounties / hackathons allocation of 2 million tokens is minted at deployment to an EOA

* 6) 32 million tokens are minted at deployment to the CommunityIssuance contract
*
* 7) The LP rewards allocation of (1 + 1/3) million tokens is minted at deployent to a Staking contract
*
* 8) (64 + 2/3) million tokens are minted at deployment to the Liquity multisig
*
* 9) Until one year from deployment:
* -Liquity multisig may only transfer() tokens to LockupContracts that have been deployed via & registered in the 
*  LockupContractFactory 
* -approve(), increaseAllowance(), decreaseAllowance() revert when called by the multisig
* -transferFrom() reverts when the multisig is the sender
* -sendToSYETI() reverts when the multisig is the sender, blocking the multisig from staking its YETI.
* 
* After one year has passed since deployment of the YETIToken, the restrictions on multisig operations are lifted
* and the multisig has the same rights as any other address.
*/

contract YETIToken is CheckContract, IYETIToken {
    using SafeMath for uint256;

    // --- ERC20 Data ---

    bytes32 constant internal _NAME = ""YETI"";
    bytes32 constant internal _SYMBOL = ""YETI"";
    bytes32 constant internal _VERSION = ""1"";
    uint8 constant internal  _DECIMALS = 18;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    uint private _totalSupply;

    // --- EIP 2612 Data ---

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    // keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"");
    bytes32 private constant _TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;

    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
    // invalidate the cached domain separator if the chain id changes.
    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
    uint256 private immutable _CACHED_CHAIN_ID;

    bytes32 private immutable _HASHED_NAME;
    bytes32 private immutable _HASHED_VERSION;
    
    mapping (address => uint256) private _nonces;

    // --- YETIToken specific data ---

    uint public constant ONE_YEAR_IN_SECONDS = 31536000;  // 60 * 60 * 24 * 365

    // uint for use with SafeMath
    uint internal _1_MILLION = 1e24;    // 1e6 * 1e18 = 1e24

    uint internal immutable deploymentStartTime;
    address public immutable multisigAddress;

    address public immutable communityIssuanceAddress;
    address public immutable sYETIAddress;

    uint internal immutable lpRewardsEntitlement;

    ILockupContractFactory public immutable lockupContractFactory;

    // --- Events ---

    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);
    event SYETIAddressSet(address _sYETIAddress);
    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);

    // --- Functions ---

    constructor
    (
        address _communityIssuanceAddress, 
        address _sYETIAddress,
        address _lockupFactoryAddress,
        address _bountyAddress,
        address _lpRewardsAddress,
        address _multisigAddress
    ) 
        public 
    {
        checkContract(_communityIssuanceAddress);
        checkContract(_sYETIAddress);
        checkContract(_lockupFactoryAddress);

        multisigAddress = _multisigAddress;
        deploymentStartTime  = block.timestamp;
        
        communityIssuanceAddress = _communityIssuanceAddress;
        sYETIAddress = _sYETIAddress;
        lockupContractFactory = ILockupContractFactory(_lockupFactoryAddress);

        bytes32 hashedName = keccak256(bytes(_NAME));
        bytes32 hashedVersion = keccak256(bytes(_VERSION));

        _HASHED_NAME = hashedName;
        _HASHED_VERSION = hashedVersion;
        _CACHED_CHAIN_ID = _chainID();
        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);
        
        // --- Initial YETI allocations ---
        // TODO: @KingYeti-change allocations
        uint bountyEntitlement = _1_MILLION.mul(27); // Allocate 27 million for bounties/hackathons
        _mint(_bountyAddress, bountyEntitlement);

        uint depositorsAndFrontEndsEntitlement = _1_MILLION.mul(50); // Allocate 50 million to the algorithmic issuance schedule
        _mint(_communityIssuanceAddress, depositorsAndFrontEndsEntitlement);

        uint _lpRewardsEntitlement = _1_MILLION.mul(3);  // Allocate 3 million for LP rewards
        lpRewardsEntitlement = _lpRewardsEntitlement;
        _mint(_lpRewardsAddress, _lpRewardsEntitlement);
        
        // Allocate the remainder to the YETI Multisig: (100 - 3 - 27 - 50) million = 20
        uint multisigEntitlement = _1_MILLION.mul(100)
            .sub(bountyEntitlement)
            .sub(depositorsAndFrontEndsEntitlement)
            .sub(_lpRewardsEntitlement);

        _mint(_multisigAddress, multisigEntitlement);
    }

    // --- External functions ---

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view override returns (uint256) {
        return _balances[account];
    }

    function getDeploymentStartTime() external view override returns (uint256) {
        return deploymentStartTime;
    }

    function getLpRewardsEntitlement() external view override returns (uint256) {
        return lpRewardsEntitlement;
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        // Restrict the multisig's transfers in first year
        if (_callerIsMultisig() && _isFirstYear()) {
            _requireRecipientIsRegisteredLC(recipient);
        }

        _requireValidRecipient(recipient);

        // Otherwise, standard transfer functionality
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) external view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        if (_isFirstYear()) { _requireCallerIsNotMultisig(); }

        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        if (_isFirstYear()) { _requireSenderIsNotMultisig(sender); }
        
        _requireValidRecipient(recipient);

        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {
        if (_isFirstYear()) { _requireCallerIsNotMultisig(); }
        
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {
        if (_isFirstYear()) { _requireCallerIsNotMultisig(); }
        
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, ""ERC20: decreased allowance below zero""));
        return true;
    }

    function sendToSYETI(address _sender, uint256 _amount) external override {
        _requireCallerIsSYETI();
        if (_isFirstYear()) { _requireSenderIsNotMultisig(_sender); }  // Prevent the multisig from staking YETI
        _transfer(_sender, sYETIAddress, _amount);
    }

    // --- EIP 2612 functionality ---

    function domainSeparator() public view override returns (bytes32) {    
        if (_chainID() == _CACHED_CHAIN_ID) {
            return _CACHED_DOMAIN_SEPARATOR;
        } else {
            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
        }
    }

    function permit
    (
        address owner, 
        address spender, 
        uint amount, 
        uint deadline, 
        uint8 v, 
        bytes32 r, 
        bytes32 s
    ) 
        external 
        override 
    {            
        require(deadline >= now, 'YETI: expired deadline');
        bytes32 digest = keccak256(abi.encodePacked('\x19\x01', 
                         domainSeparator(), keccak256(abi.encode(
                         _PERMIT_TYPEHASH, owner, spender, amount, 
                         _nonces[owner]++, deadline))));
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress == owner, 'YETI: invalid signature');
        _approve(owner, spender, amount);
    }

    function nonces(address owner) external view override returns (uint256) { // FOR EIP 2612
        return _nonces[owner];
    }

    // --- Internal operations ---

    function _chainID() private pure returns (uint256 chainID) {
        assembly {
            chainID := chainid()
        }
    }

    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount, ""ERC20: transfer amount exceeds balance"");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // --- Helper functions ---

    function _callerIsMultisig() internal view returns (bool) {
        return (msg.sender == multisigAddress);
    }

    function _isFirstYear() internal view returns (bool) {
        return (block.timestamp.sub(deploymentStartTime) < ONE_YEAR_IN_SECONDS);
    }

    // --- 'require' functions ---
    
    function _requireValidRecipient(address _recipient) internal view {
        require(
            _recipient != address(0) && 
            _recipient != address(this),
            ""YETI: Cannot transfer tokens directly to the YETI token contract or the zero address""
        );
        require(
            _recipient != communityIssuanceAddress &&
            _recipient != sYETIAddress,
            ""YETI: Cannot transfer tokens directly to the community issuance or staking contract""
        );
    }

    function _requireRecipientIsRegisteredLC(address _recipient) internal view {
        require(lockupContractFactory.isRegisteredLockup(_recipient), 
        ""YETIToken: recipient must be a LockupContract registered in the Factory"");
    }

    function _requireSenderIsNotMultisig(address _sender) internal view {
        require(_sender != multisigAddress, ""YETIToken: sender must not be the multisig"");
    }

    function _requireCallerIsNotMultisig() internal view {
        require(!_callerIsMultisig(), ""YETIToken: caller must not be the multisig"");
    }

    function _requireCallerIsSYETI() internal view {
         require(msg.sender == sYETIAddress, ""YETIToken: caller must be the SYETI contract"");
    }

    // --- Optional functions ---

    function name() external view override returns (string memory) {
        return _NAME;
    }

    function symbol() external view override returns (string memory) {
        return _SYMBOL;
    }

    function decimals() external view override returns (uint8) {
        return _DECIMALS;
    }

    function version() external view override returns (string memory) {
        return _VERSION;
    }

    function permitTypeHash() external view override returns (bytes32) {
        return _PERMIT_TYPEHASH;
    }
}",3323
RealWorld_TA_66_ActivePool_RealWorld_20240808223143.log,66,ActivePool,247296,4999,252295,138.0,1.33646,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.
 *
 * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the
 * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
 *
 */
contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts 
    newColls internal poolColl;

    // YUSD Debt tracker. Tracker of all debt in the system. 
    uint256 internal YUSDDebt;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
    * Returns the collateralBalance for a given collateral
    *
    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
    */
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
    * Returns all collateral balances in state. Not necessarily the contract's actual balances.
    */
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    /*
    * Returns the VC of the contract
    *
    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
    *
    * Computed when called by taking the collateral balances and
    * multiplying them by the corresponding price and ratio and then summing that
    */
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    // --- Pool functionality ---

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.
    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,
    // It also harvests rewards on the user's behalf. 
    // _from is where the reward balance is, _to is where to send the tokens. 
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
            }
        }
        return true;
    }

    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); // reverts if send fails
        return true;
    }

    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            // Collects rewards automatically for that amount and unwraps for the original borrower. 
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); // reverts if send fails
        }
        return true;
    }

    // View function that returns if the contract transferring to needs to have its balances updated. 
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool. 
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    // should be called by BorrowerOperations or DefaultPool
    // __after__ collateral is transferred to this contract.
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2716
RealWorld_TA_66_leverUp_RealWorld_20240808220431.log,66,leverUp,222448,7846,230294,175.0,1.26916,"// // SPDX-License-Identifier: MIT
// // @KingYeti: Ignore File
// pragma solidity 0.6.11;

// import ""../Interfaces/ITroveManager.sol"";
// import ""../Interfaces/IYUSDToken.sol"";
// import ""../Interfaces/IWhitelist.sol"";
// import ""../Interfaces/IBorrowerOperations.sol"";
// import ""./calculateMaxWithdrawHelper.sol"";
// import ""../Dependencies/IERC20.sol"";

// contract leverUp {

//     IYUSDToken public yusdToken;
//     ITroveManager public troveManager;
//     IWhitelist public whitelist;
//     IJoeRouter02 public joeRouter;
//     IBorrowerOperations public borrowerOperations;
//     calculateMaxWithdrawHelper public helper;
//     uint public maxFee= 0;// TODO: set properly
//     uint public MAXINT=uint256(-1);
//     constructor(IYUSDToken _yusdToken, ITroveManager _troveManager, IBorrowerOperations, _borrowerOperations, IWhitelist _whitelist, IJoeRouter02 _joeRouter, calculateMaxWithdrawHelper _helper) public {
//         yusdToken = _yusdToken;
//         troveManager = _troveManager;
//         borrowerOperations = _borrowerOperations;
//         whitelist = _whitelist;
//         joeRouter = _joeRouter;
//         helper = _helper;
//     }

//     /**
//      * @notice Opens new trove, deposits collateral, draws out YUSD, swap YUSD for tokenOut, redeposits collateral into trove, draws more debt until YUSDOut is depleted
//      * @param _colls Addresses of collateral in initial deposit
//      * @param _amountsToAdd Quantities of collateral in initial deposit
//      * @param YUSDOut Total YUSD denominated value of leveraged debt
//      * @param path JoeRouter path to swap, last element in path is tokenOut
//      * @param tokenOut Address of token to be leveraged
//      * @return uint Quantity of token you intent to have a leveraged position in out
//      */

//     function leverSimpleToken(address[] memory _colls, uint[] memory _amountsToAdd, uint YUSDOut, address[] memory path, address tokenOut) {
//         require(_colls.length == _amountsToAdd.length, 'Collateral and amounts are different lengths');
//         require(path[path.length - 1] == tokenOut, 'Last element in path is not tokenOut');
//         require(path[0]==address(yusdToken), 'First element in path is not yusdToken');

//         yusdToken.delegatecall(abi.encodeWithSignature(""approve(address, uint)"", address(joeRouter), MAXINT));
//         tokenOut.delegatecall(abi.encodeWithSignature(""approve(address, uint)"", address(this), MAXINT));
//         uint initialYUSD=yusdToken.balanceOf(msg.sender);
//         uint initialColl=IERC20(tokenOut).balanceOf(msg.sender);
//         uint debtToWithdraw;
//         address[] memory tokens;
//         tokens.push(tokenOut);
//         (address[] memory existingCollAddress, unit[] memory existingColls) = troveManager.getTroveColls(msg.sender);
//         if (existingColls.length == 0) {
//             //No existing trove, need to open new trove

//             (uint value, uint fee)=helper.calculateCollateralVCFee(_colls, _amountsToAdd);
//             debtToWithdraw = value - fee > YUSDOut ? YUSDOut : value - fee;
//             borrowerOperations.delegatecall(abi.encodeWithSignature(""openTrove(uint256, uint256, address, address, address[], uint[])"", maxFee, debtToWithdraw,msg.sender, msg.sender, _colls, _amountsToAdd));
//             troveManager.openTrove(msg.sender, _colls, _amountsToAdd);
//         } else {
//             // Trove exists already, need to deposit collateral
//             borrowerOperations.delegatecall(abi.encodeWithSignature(""addColl(address[],uint[], address, address)"", _colls, _amountsToAdd,msg.sender, msg.sender));
//             (uint value, uint fee)= helper.calculateCollateralVCFee(troveManager.getTroveColls(msg.sender));
//             debtToWithdraw = value - fee > YUSDOut ? YUSDOut : value - fee;
//             borrowerOperations.delegatecall(abi.encodeWithSignature(""withdrawYUSD(uint, uint, address, address)"", maxFee, debtToWithdraw ,msg.sender, msg.sender));
//         }
//         YUSDOut=YUSDOut-debtToWithdraw; //Calculate how much YUSD more to withdraw
//         joeRouter.delegatecall(abi.encodeWithSignature(""swapExactTokensForTokens(uint, uint, address[], address, uint)"", debtToWithdraw, 0, path, msg.sender, now + 1 minutes));
//         while (YUSDOut>0) {
//             uint[] memory amounts;
//             amounts.push(IERC20(tokenOut).balanceOf(msg.sender)-initialColl);
//             (uint value, uint fee)=helper.calculateCollateralVCFee(tokens, amounts);
//             debtToWithdraw = value - fee > YUSDOut ? YUSDOut : value - fee;
//             borrowerOperations.delegatecall(abi.encodeWithSignature(""addColl(address[],uint[], address, address)"", tokens, amounts,msg.sender, msg.sender));
//             borrowerOperations.delegatecall(abi.encodeWithSignature(""withdrawYUSD(uint, uint, address, address)"", maxFee, debtToWithdraw ,msg.sender, msg.sender));
//             YUSDOut=YUSDOut-debtToWithdraw;
//             joeRouter.delegatecall(abi.encodeWithSignature(""swapExactTokensForTokens(uint, uint, address[], address, uint)"", debtToWithdraw, 0, path, msg.sender, now + 1 minutes));
//         }

//     }
// }


// interface IJoeRouter01 {
//     function factory() external pure returns (address);

//     function WAVAX() external pure returns (address);

//     function addLiquidity(
//         address tokenA,
//         address tokenB,
//         uint256 amountADesired,
//         uint256 amountBDesired,
//         uint256 amountAMin,
//         uint256 amountBMin,
//         address to,
//         uint256 deadline
//     )
//         external
//         returns (
//             uint256 amountA,
//             uint256 amountB,
//             uint256 liquidity
//         );

//     function addLiquidityAVAX(
//         address token,
//         uint256 amountTokenDesired,
//         uint256 amountTokenMin,
//         uint256 amountAVAXMin,
//         address to,
//         uint256 deadline
//     )
//         external
//         payable
//         returns (
//             uint256 amountToken,
//             uint256 amountAVAX,
//             uint256 liquidity
//         );

//     function removeLiquidity(
//         address tokenA,
//         address tokenB,
//         uint256 liquidity,
//         uint256 amountAMin,
//         uint256 amountBMin,
//         address to,
//         uint256 deadline
//     ) external returns (uint256 amountA, uint256 amountB);

//     function removeLiquidityAVAX(
//         address token,
//         uint256 liquidity,
//         uint256 amountTokenMin,
//         uint256 amountAVAXMin,
//         address to,
//         uint256 deadline
//     ) external returns (uint256 amountToken, uint256 amountAVAX);

//     function removeLiquidityWithPermit(
//         address tokenA,
//         address tokenB,
//         uint256 liquidity,
//         uint256 amountAMin,
//         uint256 amountBMin,
//         address to,
//         uint256 deadline,
//         bool approveMax,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     ) external returns (uint256 amountA, uint256 amountB);

//     function removeLiquidityAVAXWithPermit(
//         address token,
//         uint256 liquidity,
//         uint256 amountTokenMin,
//         uint256 amountAVAXMin,
//         address to,
//         uint256 deadline,
//         bool approveMax,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     ) external returns (uint256 amountToken, uint256 amountAVAX);

//     function swapExactTokensForTokens(
//         uint256 amountIn,
//         uint256 amountOutMin,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external returns (uint256[] memory amounts);

//     function swapTokensForExactTokens(
//         uint256 amountOut,
//         uint256 amountInMax,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external returns (uint256[] memory amounts);

//     function swapExactAVAXForTokens(
//         uint256 amountOutMin,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external payable returns (uint256[] memory amounts);

//     function swapTokensForExactAVAX(
//         uint256 amountOut,
//         uint256 amountInMax,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external returns (uint256[] memory amounts);

//     function swapExactTokensForAVAX(
//         uint256 amountIn,
//         uint256 amountOutMin,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external returns (uint256[] memory amounts);

//     function swapAVAXForExactTokens(
//         uint256 amountOut,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external payable returns (uint256[] memory amounts);

//     function quote(
//         uint256 amountA,
//         uint256 reserveA,
//         uint256 reserveB
//     ) external pure returns (uint256 amountB);

//     function getAmountOut(
//         uint256 amountIn,
//         uint256 reserveIn,
//         uint256 reserveOut
//     ) external pure returns (uint256 amountOut);

//     function getAmountIn(
//         uint256 amountOut,
//         uint256 reserveIn,
//         uint256 reserveOut
//     ) external pure returns (uint256 amountIn);

//     function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);

//     function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);
// }

// interface IJoeRouter02 is IJoeRouter01 {
//     function removeLiquidityAVAXSupportingFeeOnTransferTokens(
//         address token,
//         uint256 liquidity,
//         uint256 amountTokenMin,
//         uint256 amountAVAXMin,
//         address to,
//         uint256 deadline
//     ) external returns (uint256 amountAVAX);

//     function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(
//         address token,
//         uint256 liquidity,
//         uint256 amountTokenMin,
//         uint256 amountAVAXMin,
//         address to,
//         uint256 deadline,
//         bool approveMax,
//         uint8 v,
//         bytes32 r,
//         bytes32 s
//     ) external returns (uint256 amountAVAX);

//     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
//         uint256 amountIn,
//         uint256 amountOutMin,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external;

//     function swapExactAVAXForTokensSupportingFeeOnTransferTokens(
//         uint256 amountOutMin,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external payable;

//     function swapExactTokensForAVAXSupportingFeeOnTransferTokens(
//         uint256 amountIn,
//         uint256 amountOutMin,
//         address[] calldata path,
//         address to,
//         uint256 deadline
//     ) external;
// }",2632
RealWorld_TA_66_DefaultPoolTester_RealWorld_20240809001118.log,66,DefaultPoolTester,36185,7632,43817,173.0,0.333565,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../DefaultPool.sol"";

contract DefaultPoolTester is DefaultPool {
    
    function unprotectedIncreaseYUSDDebt(uint _amount) external {
        YUSDDebt  = YUSDDebt.add(_amount);
    }

    function unprotectedPayable() external payable {
         // @KingYet: Commented
        // ETH = ETH.add(msg.value);
    }
    function getEthAmount() external view returns (uint) {
        return poolColl.amounts[0];
    }

    function getCollateralVCC(address _collateral) external view returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }
    
}",156
RealWorld_TA_66_IPool_RealWorld_20240809012645.log,66,IPool,39450,1784,41234,79.0,0.23293,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./ICollateralReceiver.sol"";

// Common interface for the Pools.
interface IPool is ICollateralReceiver {
    
    // --- Events ---
    
    event ETHBalanceUpdated(uint _newBalance);
    event YUSDBalanceUpdated(uint _newBalance);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);
    event WhitelistAddressChanged(address _newWhitelistAddress);
    event EtherSent(address _to, uint _amount);
    event CollateralSent(address _collateral, address _to, uint _amount);

    // --- Functions ---

    function getVC() external view returns (uint);

    function getCollateral(address collateralAddress) external view returns (uint);

    function getAllCollateral() external view returns (address[] memory, uint256[] memory);

    function getYUSDDebt() external view returns (uint);

    function increaseYUSDDebt(uint _amount) external;

    function decreaseYUSDDebt(uint _amount) external;

}",246
RealWorld_TA_66_dummyUniV2Router_RealWorld_20240809021135.log,66,dummyUniV2Router,58668,4333,63001,109.0,0.38,"pragma solidity 0.6.12;

import ""../IsYETIRouter.sol"";
import ""../BoringCrypto/BoringOwnable.sol"";
import ""../BoringCrypto/IERC20.sol"";

// Dummy contract for swapping just in one swap from YUSD to YETI 
// in one univ2 pool with the path being just that. Testing purposes only.

contract dummyUniV2Router is IsYETIRouter, BoringOwnable {
    IRouter JOERouter;
    address JOERouterAddress;
    address[] path;
    IERC20 yusdToken;
    IERC20 yetiToken;

    function setup(address _JOERouter, address _yusdToken, address _yetiToken) external onlyOwner {
        JOERouterAddress = _JOERouter;
        JOERouter = IRouter(_JOERouter);
        path = new address[](2);
        yusdToken = IERC20(_yusdToken);
        yetiToken = IERC20(_yetiToken);
        path[0] = _yusdToken;
        path[1] = _yetiToken;
        // Renounce ownership
        transferOwnership(address(0), true, true);
    }

    function swap(uint256 _YUSDAmount, uint256 _minYETIOut, address _to) external override returns (uint256[] memory amounts) {
        address cachedJOERouterAddress = JOERouterAddress;
        IERC20 cachedYUSDToken = yusdToken;
        require(cachedYUSDToken.approve(cachedJOERouterAddress, 0));
        require(cachedYUSDToken.increaseAllowance(cachedJOERouterAddress, _YUSDAmount));
        amounts = JOERouter.swapExactTokensForTokens(_YUSDAmount, _minYETIOut, path, _to, block.timestamp);
    }
}


// Router for Uniswap V2, performs YUSD -> YETI swaps
interface IRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}",464
RealWorld_TA_66_FunctionCaller_RealWorld_20240809000052.log,66,FunctionCaller,50379,2823,53202,98.0,0.308355,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import '../Interfaces/ITroveManager.sol';
import '../Interfaces/ISortedTroves.sol';
import '../Interfaces/IPriceFeed.sol';
import '../Dependencies/LiquityMath.sol';

/* Wrapper contract - used for calculating gas of read-only and internal functions.
Not part of the Liquity application. */
contract FunctionCaller {

    ITroveManager troveManager;
    address public troveManagerAddress;

    ISortedTroves sortedTroves;
    address public sortedTrovesAddress;

    IPriceFeed priceFeed;
    address public priceFeedAddress;

    // --- Dependency setters ---

    function setTroveManagerAddress(address _troveManagerAddress) external {
        troveManagerAddress = _troveManagerAddress;
        troveManager = ITroveManager(_troveManagerAddress);
    }

    function setSortedTrovesAddress(address _sortedTrovesAddress) external {
        troveManagerAddress = _sortedTrovesAddress;
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
    }

    function setPriceFeedAddress(address _priceFeedAddress) external {
        priceFeedAddress = _priceFeedAddress;
        priceFeed = IPriceFeed(_priceFeedAddress);
    }

    // --- Non-view wrapper functions used for calculating gas ---

    function troveManager_getCurrentICR(address _address) external view returns (uint) {
        return troveManager.getCurrentICR(_address);
    }

    function sortedTroves_findInsertPosition(uint _ICR, address _prevId, address _nextId) external view returns (address, address) {
        return sortedTroves.findInsertPosition(_ICR, _prevId, _nextId);
    }
}",364
RealWorld_TA_66_IYUSDToken_RealWorld_20240809010348.log,66,IYUSDToken,35521,3604,39125,106.0,0.249685,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IERC20.sol"";
import ""../Interfaces/IERC2612.sol"";

interface IYUSDToken is IERC20, IERC2612 {
    
    // --- Events ---

    event TroveManagerAddressChanged(address _troveManagerAddress);
    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);
    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);

    event YUSDTokenBalanceUpdated(address _user, uint _amount);

    // --- Functions ---

    function mint(address _account, uint256 _amount) external;

    function burn(address _account, uint256 _amount) external;

    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;

    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;
}",193
RealWorld_TA_66_IERC20_8_RealWorld_20240809005020.log,66,IERC20,71248,1283,72531,78.0,0.3819,"// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}",637
RealWorld_TA_66_LiquitySafeMath128Tester_RealWorld_20240809000811.log,66,LiquitySafeMath128Tester,28345,1257,29602,88.0,0.166865,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/LiquitySafeMath128.sol"";

/* Tester contract for math functions in LiquitySafeMath128.sol library. */

contract LiquitySafeMath128Tester {
    using LiquitySafeMath128 for uint128;

    function add(uint128 a, uint128 b) external pure returns (uint128) {
        return a.add(b);
    }

    function sub(uint128 a, uint128 b) external pure returns (uint128) {
        return a.sub(b);
    }
}",119
RealWorld_TA_66_IUniswapV2Pair_RealWorld_20240809013341.log,66,IUniswapV2Pair,66324,1322,67646,75.0,0.35806,"// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.5.0;

// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol

interface IUniswapV2Pair {
  event Approval(address indexed owner, address indexed spender, uint value);
  event Transfer(address indexed from, address indexed to, uint value);

  function name() external pure returns (string memory);

  function symbol() external pure returns (string memory);

  function decimals() external pure returns (uint8);

  function totalSupply() external view returns (uint);

  function balanceOf(address owner) external view returns (uint);

  function allowance(address owner, address spender) external view returns (uint);

  function approve(address spender, uint value) external returns (bool);

  function transfer(address to, uint value) external returns (bool);

  function transferFrom(
    address from,
    address to,
    uint value
  ) external returns (bool);

  function DOMAIN_SEPARATOR() external view returns (bytes32);

  function PERMIT_TYPEHASH() external pure returns (bytes32);

  function nonces(address owner) external view returns (uint);

  function permit(
    address owner,
    address spender,
    uint value,
    uint deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external;

  event Mint(address indexed sender, uint amount0, uint amount1);
  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
  event Swap(
    address indexed sender,
    uint amount0In,
    uint amount1In,
    uint amount0Out,
    uint amount1Out,
    address indexed to
  );
  event Sync(uint112 reserve0, uint112 reserve1);

  function MINIMUM_LIQUIDITY() external pure returns (uint);

  function factory() external view returns (address);

  function token0() external view returns (address);

  function token1() external view returns (address);

  function getReserves()
    external
    view
    returns (
      uint112 reserve0,
      uint112 reserve1,
      uint32 blockTimestampLast
    );

  function price0CumulativeLast() external view returns (uint);

  function price1CumulativeLast() external view returns (uint);

  function kLast() external view returns (uint);

  function mint(address to) external returns (uint liquidity);

  function burn(address to) external returns (uint amount0, uint amount1);

  function swap(
    uint amount0Out,
    uint amount1Out,
    address to,
    bytes calldata data
  ) external;

  function skim(address to) external;

  function sync() external;

  function initialize(address, address) external;
}",579
RealWorld_TA_66_Migrations_RealWorld_20240808222044.log,66,Migrations,29165,2635,31800,81.0,0.198525,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  constructor() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}",114
RealWorld_TA_66_SafeERC20_RealWorld_20240808231256.log,66,SafeERC20,87277,1851,89128,74.0,0.473405,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../../Interfaces/IERC20.sol"";
import ""../../Dependencies/SafeMath.sol"";
import ""./Address.sol"";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            ""SafeERC20: approve from non-zero to non-zero allowance""
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.increaseAllowance.selector, spender, value));
    }

    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).add(value);
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
        uint256 newAllowance = token.allowance(address(this), spender).sub(value, ""SafeERC20: decreased allowance below zero"");
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, ""SafeERC20: low-level call failed"");
        if (returndata.length != 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), ""SafeERC20: ERC20 operation did not succeed"");
        }
    }
}",846
RealWorld_TA_66_BoringMath_RealWorld_20240809020726.log,66,BoringMath,73535,1455,74990,77.0,0.396775,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;

/// @notice A library for performing overflow-/underflow-safe math,
/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).
library BoringMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b == 0 || (c = a * b) / b == a, ""BoringMath: Mul Overflow"");
    }

    function to128(uint256 a) internal pure returns (uint128 c) {
        require(a <= uint128(-1), ""BoringMath: uint128 Overflow"");
        c = uint128(a);
    }

    function to64(uint256 a) internal pure returns (uint64 c) {
        require(a <= uint64(-1), ""BoringMath: uint64 Overflow"");
        c = uint64(a);
    }

    function to32(uint256 a) internal pure returns (uint32 c) {
        require(a <= uint32(-1), ""BoringMath: uint32 Overflow"");
        c = uint32(a);
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.
library BoringMath128 {
    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.
library BoringMath64 {
    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}

/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.
library BoringMath32 {
    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a + b) >= b, ""BoringMath: Add Overflow"");
    }

    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {
        require((c = a - b) <= a, ""BoringMath: Underflow"");
    }
}",658
RealWorld_TA_66_Ownable_RealWorld_20240808232524.log,66,Ownable,55234,1549,56783,81.0,0.30715,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

/**
 * Based on OpenZeppelin's Ownable contract:
 * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol
 *
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), ""CallerNotOwner"");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     *
     * NOTE: This function is not safe, as it doesnt check owner is calling it.
     * Make sure you check it before calling it.
     */
    function _renounceOwnership() internal {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}",441
RealWorld_TA_66_CommunityIssuance_RealWorld_20240809015859.log,66,CommunityIssuance,112186,4108,116294,110.0,0.64309,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IYETIToken.sol"";
import ""../Interfaces/ICommunityIssuance.sol"";
import ""../Dependencies/BaseMath.sol"";
import ""../Dependencies/LiquityMath.sol"";
import ""../Dependencies/Ownable.sol"";
import ""../Dependencies/CheckContract.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/SafeERC20.sol"";


contract CommunityIssuance is ICommunityIssuance, Ownable, CheckContract, BaseMath {
    using SafeMath for uint;
    using SafeERC20 for IYETIToken;

    // --- Data ---

    bytes32 constant public NAME = ""CommunityIssuance"";

    uint constant public SECONDS_IN_ONE_MINUTE = 60;

   /* The issuance factor F determines the curvature of the issuance curve.
    *
    * Minutes in one year: 60*24*365 = 525600
    *
    * For 50% of remaining tokens issued each year, with minutes as time units, we have:
    * 
    * F ** 525600 = 0.5
    * 
    * Re-arranging:
    * 
    * 525600 * ln(F) = ln(0.5)
    * F = 0.5 ** (1/525600)
    * F = 0.999998681227695000 
    */
    uint constant public ISSUANCE_FACTOR = 999998681227695000;

    /* 
    * The community YETI supply cap is the starting balance of the Community Issuance contract.
    * It should be minted to this contract by YETIToken, when the token is deployed.
    * 
    * Set to 32M (slightly less than 1/3) of total YETI supply.
    */
    uint constant public YETISupplyCap = 32e24; // 32 million

    IYETIToken public yetiToken;

    address public stabilityPoolAddress;

    uint public totalYETIIssued;
    uint public immutable deploymentTime;

    // --- Events ---

    event YETITokenAddressSet(address _yetiTokenAddress);
    event StabilityPoolAddressSet(address _stabilityPoolAddress);
    event TotalYETIIssuedUpdated(uint _totalYETIIssued);

    // --- Functions ---

    constructor() public {
        deploymentTime = block.timestamp;
    }

    function setAddresses
    (
        address _yetiTokenAddress,
        address _stabilityPoolAddress
    ) 
        external 
        onlyOwner 
        override 
    {
        checkContract(_yetiTokenAddress);
        checkContract(_stabilityPoolAddress);

        yetiToken = IYETIToken(_yetiTokenAddress);
        stabilityPoolAddress = _stabilityPoolAddress;

        // When YETIToken deployed, it should have transferred CommunityIssuance's YETI entitlement
        uint YETIBalance = yetiToken.balanceOf(address(this));
        require(YETIBalance >= YETISupplyCap, ""setAddresses: balance must be less than supplycap"");

        emit YETITokenAddressSet(_yetiTokenAddress);
        emit StabilityPoolAddressSet(_stabilityPoolAddress);

        _renounceOwnership();
    }

    function issueYETI() external override returns (uint) {
        _requireCallerIsStabilityPool();

        uint latestTotalYETIIssued = YETISupplyCap.mul(_getCumulativeIssuanceFraction()).div(DECIMAL_PRECISION);
        uint issuance = latestTotalYETIIssued.sub(totalYETIIssued);

        totalYETIIssued = latestTotalYETIIssued;
        emit TotalYETIIssuedUpdated(latestTotalYETIIssued);
        
        return issuance;
    }

    /* Gets 1-f^t    where: f < 1

    f: issuance factor that determines the shape of the curve
    t:  time passed since last YETI issuance event  */
    function _getCumulativeIssuanceFraction() internal view returns (uint) {
        // Get the time passed since deployment
        uint timePassedInMinutes = block.timestamp.sub(deploymentTime).div(SECONDS_IN_ONE_MINUTE);

        // f^t
        uint power = LiquityMath._decPow(ISSUANCE_FACTOR, timePassedInMinutes);

        //  (1 - f^t)
        uint cumulativeIssuanceFraction = (uint(DECIMAL_PRECISION).sub(power));
        require(cumulativeIssuanceFraction <= DECIMAL_PRECISION, ""Fraction must be in range [0,1]""); // must be in range [0,1]

        return cumulativeIssuanceFraction;
    }

    function sendYETI(address _account, uint _YETIamount) external override {
        _requireCallerIsStabilityPool();

        yetiToken.safeTransfer(_account, _YETIamount);
    }

    // --- 'require' functions ---

    function _requireCallerIsStabilityPool() internal view {
        require(msg.sender == stabilityPoolAddress, ""CommunityIssuance: caller is not SP"");
    }
}",1095
RealWorld_TA_66_ICollateralReceiver_RealWorld_20240809014500.log,66,ICollateralReceiver,22047,1703,23750,73.0,0.144295,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

interface ICollateralReceiver {
    function receiveCollateral(address[] memory _tokens, uint[] memory _amounts) external;
}",45
RealWorld_TA_66_ERC20Mock_RealWorld_20240808231542.log,66,ERC20Mock,37772,3119,40891,94.0,0.25124,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";


// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0/contracts/mocks/ERC20Mock.sol
// mock class using ERC20
contract ERC20Mock is ERC20 {
    constructor (
        string memory name,
        string memory symbol,
        address initialAccount,
        uint256 initialBalance
    ) public payable ERC20(name, symbol) {
        _mint(initialAccount, initialBalance);
    }

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    function transferInternal(address from, address to, uint256 value) public {
        _transfer(from, to, value);
    }

    function approveInternal(address owner, address spender, uint256 value) public {
        _approve(owner, spender, value);
    }
}",222
RealWorld_TA_66_IRewarder_RealWorld_20240809005259.log,66,IRewarder,24761,1508,26269,73.0,0.153965,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.7;
import ""./IERC20_8.sol"";

interface IRewarder {
    function onJoeReward(address user, uint256 newLpAmount) external;

    function pendingTokens(address user) external view returns (uint256 pending);

    function rewardToken() external view returns (IERC20);
}",78
RealWorld_TA_66_BorrowerWrappersScript_RealWorld_20240808225856.log,66,BorrowerWrappersScript,144462,5195,149657,123.0,0.82621,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/LiquityMath.sol"";
import ""../Interfaces/IERC20.sol"";
import ""../Interfaces/IBorrowerOperations.sol"";
import ""../Interfaces/ITroveManager.sol"";
import ""../Interfaces/IStabilityPool.sol"";
import ""../Interfaces/IPriceFeed.sol"";
import ""../Interfaces/ISYETI.sol"";
import ""./BorrowerOperationsScript.sol"";
import ""./ETHTransferScript.sol"";
import ""./SYETIScript.sol"";


contract BorrowerWrappersScript is BorrowerOperationsScript, ETHTransferScript, SYETIScript {
    using SafeMath for uint;

    bytes32 constant public NAME = ""BorrowerWrappersScript"";

    ITroveManager immutable troveManager;
    IStabilityPool immutable stabilityPool;
    IERC20 immutable yusdToken;
    IERC20 immutable yetiToken;
    ISYETI immutable sYETI;

    constructor(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _sYETIAddress
    )
        BorrowerOperationsScript(IBorrowerOperations(_borrowerOperationsAddress))
        SYETIScript(_sYETIAddress)
        public
    {
        checkContract(_troveManagerAddress);
        ITroveManager troveManagerCached = ITroveManager(_troveManagerAddress);
        troveManager = troveManagerCached;

        IStabilityPool stabilityPoolCached = troveManagerCached.stabilityPool();
        checkContract(address(stabilityPoolCached));
        stabilityPool = stabilityPoolCached;

//        IPriceFeed priceFeedCached = troveManagerCached.priceFeed();
//        checkContract(address(priceFeedCached));
//        priceFeed = priceFeedCached;

        address yusdTokenCached = address(troveManagerCached.yusdToken());
        checkContract(yusdTokenCached);
        yusdToken = IERC20(yusdTokenCached);

        address yetiTokenCached = address(troveManagerCached.yetiToken());
        checkContract(yetiTokenCached);
        yetiToken = IERC20(yetiTokenCached);

        ISYETI sYETICached = troveManagerCached.sYETI();
        require(_sYETIAddress == address(sYETICached), ""BorrowerWrappersScript: Wrong SYETI address"");
        sYETI = sYETICached;
    }

//    function claimCollateralAndOpenTrove(uint _maxFee, uint _YUSDAmount, address _upperHint, address _lowerHint) external payable {
//        uint balanceBefore = address(this).balance;
//
//        // Claim collateral
//        borrowerOperations.claimCollateral();
//
//        uint balanceAfter = address(this).balance;
//
//        // already checked in CollSurplusPool
//        assert(balanceAfter > balanceBefore);
//
//        uint totalCollateral = balanceAfter.sub(balanceBefore).add(msg.value);
//
//        // Open trove with obtained collateral, plus collateral sent by user
//        borrowerOperations.openTrove{ value: totalCollateral }(_maxFee, _YUSDAmount, _upperHint, _lowerHint);
//    }
//
//    function claimSPRewardsAndRecycle(uint _maxFee, address _upperHint, address _lowerHint) external {
//        uint collBalanceBefore = address(this).balance;
//        uint yetiBalanceBefore = yetiToken.balanceOf(address(this));
//
//        // Claim rewards
//        stabilityPool.withdrawFromSP(0);
//
//        uint collBalanceAfter = address(this).balance;
//        uint yetiBalanceAfter = yetiToken.balanceOf(address(this));
//        uint claimedCollateral = collBalanceAfter.sub(collBalanceBefore);
//
//        // Add claimed ETH to trove, get more YUSD and stake it into the Stability Pool
//        if (claimedCollateral != 0) {
//            _requireUserHasTrove(address(this));
//            uint YUSDAmount = _getNetYUSDAmount(claimedCollateral);
//            borrowerOperations.adjustTrove{ value: claimedCollateral }(_maxFee, 0, YUSDAmount, true, _upperHint, _lowerHint);
//            // Provide withdrawn YUSD to Stability Pool
//            if (YUSDAmount != 0) {
//                stabilityPool.provideToSP(YUSDAmount, address(0));
//            }
//        }
//
//        // Stake claimed YETI
//        uint claimedYETI = yetiBalanceAfter.sub(yetiBalanceBefore);
//        if (claimedYETI != 0) {
//             .stake(claimedYETI);
//        }
//    }
//
//    function claimStakingGainsAndRecycle(uint _maxFee, address _upperHint, address _lowerHint) external {
//        uint collBalanceBefore = address(this).balance;
//        uint yusdBalanceBefore = yusdToken.balanceOf(address(this));
//        uint yetiBalanceBefore = yetiToken.balanceOf(address(this));
//
//        // Claim gains
//        sYETI.unstake(0);
//
//        uint gainedCollateral = address(this).balance.sub(collBalanceBefore); // stack too deep issues :'(
//        uint gainedYUSD = yusdToken.balanceOf(address(this)).sub(yusdBalanceBefore);
//
//        uint netYUSDAmount;
//        // Top up trove and get more YUSD, keeping ICR constant
//        if (gainedCollateral != 0) {
//            _requireUserHasTrove(address(this));
//            netYUSDAmount = _getNetYUSDAmount(gainedCollateral);
//            borrowerOperations.adjustTrove{ value: gainedCollateral }(_maxFee, 0, netYUSDAmount, true, _upperHint, _lowerHint);
//        }
//
//        uint totalYUSD = gainedYUSD.add(netYUSDAmount);
//        if (totalYUSD != 0) {
//            stabilityPool.provideToSP(totalYUSD, address(0));
//
//            // Providing to Stability Pool also triggers YETI claim, so stake it if any
//            uint yetiBalanceAfter = yetiToken.balanceOf(address(this));
//            uint claimedYETI = yetiBalanceAfter.sub(yetiBalanceBefore);
//            if (claimedYETI != 0) {
//                sYETI.mint(claimedYETI);
//            }
//        }
//
//    }
//
//    function _getNetYUSDAmount(uint _collateral) internal returns (uint) {
//        uint price = priceFeed.fetchPrice();
//        uint ICR = troveManager.getCurrentICR(address(this), price);
//
//        uint YUSDAmount = _collateral.mul(price).div(ICR);
//        uint borrowingRate = troveManager.getBorrowingRateWithDecay();
//        uint netDebt = YUSDAmount.mul(LiquityMath.DECIMAL_PRECISION).div(LiquityMath.DECIMAL_PRECISION.add(borrowingRate));
//
//        return netDebt;
//    }

    function _requireUserHasTrove(address _depositor) internal view {
        require(troveManager.isTroveActive(_depositor), ""BorrowerWrappersScript: caller must have an active trove"");
    }
}",1563
RealWorld_TA_66_IERC2612_RealWorld_20240809010536.log,66,IERC2612,66560,1596,68156,76.0,0.36472,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

/**
 * @dev Interface of the ERC2612 standard as defined in the EIP.
 *
 * Adds the {permit} method, which can be used to change one's
 * {IERC20-allowance} without having to send a transaction, by signing a
 * message. This allows users to spend tokens without having to hold Ether.
 *
 * See https://eips.ethereum.org/EIPS/eip-2612.
 * 
 * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/
 */
interface IERC2612 {
    /**
     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,
     * given `owner`'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(address owner, address spender, uint256 amount, 
                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
    
    /**
     * @dev Returns the current ERC2612 nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases `owner`'s nonce by one. This
     * prevents a signature from being used multiple times.
     *
     * `owner` can limit the time a Permit is valid for by setting `deadline` to 
     * a value in the near future. The deadline argument can be set to uint(-1) to 
     * create Permits that effectively never expire.
     */
    function nonces(address owner) external view returns (uint256);
    
    function version() external view returns (string memory);
    function permitTypeHash() external view returns (bytes32);
    function domainSeparator() external view returns (bytes32);
}",578
RealWorld_TA_66_PriceFeed_RealWorld_20240808224407.log,66,PriceFeed,661637,5648,667285,186.0,3.421145,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";


/*
* PriceFeed for mainnet deployment, to be connected to Chainlink's live Collateral:USD aggregator reference
* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.
*
* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for
* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
* Chainlink oracle.
*/
contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    bytes32 constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator
    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system

    // Core Liquity contracts
    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    // Use to convert a price answer to an 18-digit precision uint
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
    uint constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4

    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%

    /*
    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
    * to return to using the Chainlink oracle. 18-digit precision.
    */
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%

    // The last good price seen from an oracle by Liquity
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        int256 answer;
        uint256 timestamp;
        uint80 roundId;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        uint256 value;
        uint256 timestamp;
        bool ifRetrieve;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    // --- Dependency setters ---

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        // Explicitly set initial system status
        status = Status.chainlinkWorking;

        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    // --- Functions ---

    /*
    * fetchPrice():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice() external returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen, switch to Tellor and return last good price
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                /*
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is working and Tellor is broken, remember Tellor is broken
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            // If Chainlink is working, return Chainlink current price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }


        // --- CASE 2: The system fetched last price from Tellor ---
        if (status == Status.usingTellorChainlinkUntrusted) {
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // Otherwise, use Tellor price
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                return _storeTellorPrice(tellorResponse);
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
        if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,
            // return Chainlink price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    // --- Functions ---

    /*
    * fetchPrice_vce_v():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail, 
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice_v() view external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                // If Tellor is frozen, switch to Tellor and return last good price 
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                /* 
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink 
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            // If Chainlink is working, return Chainlink current price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        // --- CASE 2: The system fetched last price from Tellor --- 
        if (status == Status.usingTellorChainlinkUntrusted) { 
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            // Otherwise, use Tellor price
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
         if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch 
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted, 
            // return Chainlink price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    // --- Helper functions ---

    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round
    * for two reasons:
    *
    * 1) It is necessary data for the price deviation check in case 1,
    * and
    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds
    * peace of mind when using or returning to Chainlink.
    */
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid roundId that is 0
        if (_response.roundId == 0) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for non-positive price
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        /*
        * Use the larger price as the denominator:
        * - If price decreased, the percentage deviation is in relation to the the previous price.
        * - If price increased, the percentage deviation is in relation to the current price.
        */
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        // Return true if price has more than doubled, or more than halved.
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for zero price
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        // Return false if either oracle is broken or frozen
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        /*
        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting
        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
        */
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        /*
        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.
        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of
        * future changes.
        *
        */
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            // Scale the returned price value down to Liquity's target precision
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            // Scale the returned price value up to Liquity's target precision
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    // --- Oracle response wrapper functions ---

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            // If call to Tellor succeeds, return the response and success = true
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            // If call to Tellor reverts, return a zero response with success = false
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        // First, try to get current decimal precision:
        try priceAggregator.decimals() returns (uint8 decimals) {
            // If call to Chainlink succeeds, record the current decimal precision
            chainlinkResponse.decimals = decimals;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }

        // Secondly, try to get latest price data:
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        /*
        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a
        * previous round.  We assume the decimals used in the previous round are the same as the current round.
        */

        // Try to get the price data from the previous round:
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return prevChainlinkResponse;
        }
    }
}",7617
RealWorld_TA_66_BoringERC20_RealWorld_20240809020845.log,66,BoringERC20,108401,2417,110818,84.0,0.590345,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;
import ""./IERC20.sol"";

// solhint-disable avoid-low-level-calls

library BoringERC20 {
    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
    bytes4 private constant SIG_NAME = 0x06fdde03; // name()
    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)
    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

    function returnDataToString(bytes memory data) internal pure returns (string memory) {
        if (data.length >= 64) {
            return abi.decode(data, (string));
        } else if (data.length == 32) {
            uint8 i = 0;
            while(i < 32 && data[i] != 0) {
                ++i;
            }
            bytes memory bytesArray = new bytes(i);
            for (i = 0; i < 32 && data[i] != 0; ++i) {
                bytesArray[i] = data[i];
            }
            return string(bytesArray);
        } else {
            return ""???"";
        }
    }

    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.
    /// @param token The address of the ERC-20 token contract.
    /// @return (string) Token symbol.
    function safeSymbol(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));
        return success ? returnDataToString(data) : ""???"";
    }

    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.
    /// @param token The address of the ERC-20 token contract.
    /// @return (string) Token name.
    function safeName(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));
        return success ? returnDataToString(data) : ""???"";
    }

    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.
    /// @param token The address of the ERC-20 token contract.
    /// @return (uint8) Token decimals.
    function safeDecimals(IERC20 token) internal view returns (uint8) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));
        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
    }

    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.
    /// @param token The address of the ERC-20 token.
    /// @param to The address of the user to check.
    /// @return amount The token amount.
    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {
        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));
        require(success && data.length >= 32, ""BoringERC20: BalanceOf failed"");
        amount = abi.decode(data, (uint256));
    }

    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransfer(
        IERC20 token,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: Transfer failed"");
    }

    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
    /// Reverts on a failed transfer.
    /// @param token The address of the ERC-20 token.
    /// @param from Transfer tokens from.
    /// @param to Transfer tokens to.
    /// @param amount The token amount.
    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 amount
    ) internal {
        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));
        require(success && (data.length == 0 || abi.decode(data, (bool))), ""BoringERC20: TransferFrom failed"");
    }
}",1069
